- en: Chain of responsibility of commands
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令责任链
- en: Do you remember the chain of responsibility design pattern? We were passing
    a `string` message between links to print its contents. But we could be using
    the previous Command to retrieve information for logging to the console. We'll
    mainly reuse the code that we have written already.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得责任链设计模式吗？我们曾在链接之间传递一个`string`消息以打印其内容。但我们可以使用之前的命令来检索信息并记录到控制台。我们将主要重用我们已经编写的代码。
- en: 'The `Command` interface will be from the type interface that returns a `string`
    from the previous example:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`Command`接口将来自返回前一个示例中`string`的类型接口：'
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will use the `Command` implementation of the `TimePassed` type too:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用`TimePassed`类型的`Command`实现：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Remember that this type returns the elapsed time from the object creation on
    its `Info() string` method. We also need the `ChainLogger` interface from the
    *Chain of responsibility design pattern* section of this chapter but, this time,
    it will pass Commands on its `Next` method instead of `string`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，此类型在其`Info()`字符串方法中返回对象创建以来的经过时间。我们还需要从本章的“责任链设计模式”部分获取`ChainLogger`接口，但这次，它将在其`Next`方法中传递命令而不是`string`：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We''ll use just the same type for two links in the chain for simplicity. This
    link is very similar to the `FirstLogger` type from the chain of responsibility
    example, but this time it will append the message `Elapsed time from creation:`
    and it will wait 1 second before printing. We''ll call it `Logger` instead of
    `FirstLogger`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将使用相同的类型来表示链中的两个链接。此链接与责任链示例中的`FirstLogger`类型非常相似，但这次它将附加消息`Elapsed
    time from creation:`并在打印之前等待1秒钟。我们将称之为`Logger`而不是`FirstLogger`：
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we need a `main` function to execute the chain that takes `Command`
    pointers:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个`main`函数来执行接受`Command`指针的链：
- en: '[PRE4]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Line by line, we create a variable called `second` with a pointer to a `Logger`;
    this is going to be the second link in our chain. Then we create a variable called
    `first`, that will be the first link in the chain. The first link points to the
    `second` variable, the second link in the chain.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 行行分析，我们创建了一个名为`second`的变量，它指向一个`Logger`；这将是我们链中的第二个链接。然后我们创建了一个名为`first`的变量，它将成为链中的第一个链接。第一个链接指向`second`变量，即链中的第二个链接。
- en: Then, we create an instance of `TimePassed` to use it as the `Command` type.
    The start time of this command is the execution time (the `time.Now()` method
    returns the time in the moment of the execution).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`TimePassed`的实例来使用它作为`Command`类型。此命令的起始时间是执行时间（`time.Now()`方法返回执行时刻的时间）。
- en: 'Finally, we pass the `Command` interface to the chain on the `first.Next(command)`
    statement. The output of this program is the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`first.Next(command)`语句中将`Command`接口传递给链。此程序的输出如下：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The resulting output is reflected in the following diagram: The command with
    the time field is pushed to the first link that knows how to execute Commands
    of any type. Then it passes the Command to the second link that also knows how
    to execute Commands:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 结果输出反映在以下图中：具有时间字段的命令被推送到第一个知道如何执行任何类型命令的链接。然后它将命令传递给第二个链接，该链接也知道如何执行命令：
- en: This approach hides the complexity behind each `Command` execution from the
    Command handlers on each link. The functionality hidden behind a Command can be
    simple or incredibly complex but the idea here is to reuse the handler to manage
    many types of unrelated implementations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法隐藏了每个`Command`执行背后的复杂性，使其从每个链接上的命令处理器中隐藏。命令背后隐藏的功能可以是简单的，也可以是极其复杂的，但这里的想法是重用处理器来管理许多不同类型的无关实现。
