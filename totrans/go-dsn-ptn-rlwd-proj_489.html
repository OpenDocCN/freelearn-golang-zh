<html><head></head><body><div class="book" title="Summary" id="3R0OI1-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec046" class="calibre1"/>Summary</h1></div></div></div><p class="calibre10">We have taken our first steps in the Behavioral patterns. The objective of this chapter was to introduce the reader to the concept of algorithm and execution encapsulation using proper interfaces and structures. With the strategy, we have encapsulated algorithms, with the chain of responsibility handlers and with the Command design pattern executions.</p><p class="calibre10">Now, with the knowledge we have acquired about the strategy pattern, we can uncouple heavily our applications from their algorithms, just for testing, this is a very useful feature to inject mocks in different types that would be almost impossible to test. But also for anything that could need different approaches based on some context (such as shorting a list; some algorithms perform better depending on the distribution of the list).</p><p class="calibre10">The Chain of Responsibility pattern opens the door of middleware of any type and plugin-like libraries to improve the functionality of some part. Many open source projects uses a Chain of Responsibility to handler HTTP requests and responses to extract information to the end user (such as cookies info) or check authentication details (I'll let you pass to the next link only if I have you on my database).</p><p class="calibre10">Finally, the Command pattern is the most common pattern for UI handling but also very useful in many other scenarios where we need some type of handling between many unrelated types that are travelling through the code (such as a message passed through a channel).</p></div></body></html>