- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have taken our first steps in the Behavioral patterns. The objective of this
    chapter was to introduce the reader to the concept of algorithm and execution
    encapsulation using proper interfaces and structures. With the strategy, we have
    encapsulated algorithms, with the chain of responsibility handlers and with the
    Command design pattern executions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with the knowledge we have acquired about the strategy pattern, we can
    uncouple heavily our applications from their algorithms, just for testing, this
    is a very useful feature to inject mocks in different types that would be almost
    impossible to test. But also for anything that could need different approaches
    based on some context (such as shorting a list; some algorithms perform better
    depending on the distribution of the list).
  prefs: []
  type: TYPE_NORMAL
- en: The Chain of Responsibility pattern opens the door of middleware of any type
    and plugin-like libraries to improve the functionality of some part. Many open
    source projects uses a Chain of Responsibility to handler HTTP requests and responses
    to extract information to the end user (such as cookies info) or check authentication
    details (I'll let you pass to the next link only if I have you on my database).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Command pattern is the most common pattern for UI handling but
    also very useful in many other scenarios where we need some type of handling between
    many unrelated types that are travelling through the code (such as a message passed
    through a channel).
  prefs: []
  type: TYPE_NORMAL
