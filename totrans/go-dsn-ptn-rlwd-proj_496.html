<html><head></head><body>
<div class="book" title="Chapter&#xA0;6.&#xA0;Behavioral Patterns - Template, Memento, and Interpreter Design Patterns">
<div class="book" title="Template design pattern">
<div class="book" title="Unit tests for the simple algorithm"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch06lvl2sec0145" class="calibre1"/>Unit tests for the simple algorithm</h2></div></div></div><p class="calibre10">We will focus on testing the public methods only. This is a very common approach. All in all, if your private methods aren't called from some level of the public ones, they aren't called at all. We need two interfaces here, one for the Template implementors and one for the abstract step of the algorithm:</p><pre class="programlisting">type MessageRetriever interface { 
  Message()string 
} 

type Template interface { 
   first() string 
   third() string 
   ExecuteAlgorithm(MessageRetriever) string 
} 
</pre><p class="calibre10">A Template implementor will accept a <code class="email">MessageRetriever</code> interface to execute as part of its execution algorithm. We need a type that implements this interface called <code class="email">Template</code>, we will call it <code class="email">TemplateImpl</code>:</p><pre class="programlisting">type TemplateImpl struct{} 
 
func (t *TemplateImpl) first() string { 
  return "" 
} 
 
func (t *TemplateImpl) third() string { 
  return "" 
} 
 
func (t *TemplateImpl) ExecuteAlgorithm(m MessageRetriever) string { 
  return "" 
} 
</pre><p class="calibre10">So our first test checks the fourth and fifth acceptance criteria. We will create the <code class="email">TestStruct</code> type that implements the <code class="email">MessageRetriever</code> interface returning the string <code class="email">world</code> and has embedded the Template so that it can call the <code class="email">ExecuteAlgorithm</code> method. It will act as the Template and the abstraction:</p><pre class="programlisting">type TestStruct struct { 
  Template 
} 
 
func (m *TestStruct) Message() string { 
  return "world" 
} 
</pre><p class="calibre10">First, we will define the <code class="email">TestStruct</code> type. In this case, the part of the algorithm deferred to us is going to return the <code class="email">world</code> text. This is the string we will look for later in the test doing a check of type "is the word <code class="email">world</code> present on this string?".</p><p class="calibre10">Take a close look, the <code class="email">TestStruct</code> embeds a type called <code class="email">Template</code> which represents the Template pattern of our algorithm.</p><p class="calibre10">When we implement the <code class="email">Message()</code> method, we are implicitly implementing the <code class="email">MessageRetriever</code> interface. So now we can use <code class="email">TestStruct</code> type as a pointer to a <code class="email">MessageRetriever</code> interface:</p><pre class="programlisting">func TestTemplate_ExecuteAlgorithm(t *testing.T) { 
  t.Run("Using interfaces", func(t *testing.T){ 
    s := &amp;TestStruct{} 
    res := s.ExecuteAlgorithm(s) 
   expected := "world" 
 
    if !strings.Contains(res, expected) { 
      t.Errorf("Expected string '%s' wasn't found on returned string\n", expected) 
    } 
  }) 
} 
</pre><p class="calibre10">In the test, we will use the type we have just created. When we call the <code class="email">ExecuteAlgorithm</code> method, we need to pass the <code class="email">MessageRetriever</code> interface. As the <code class="email">TestStruct</code> type also implements the <code class="email">MessageRetriever</code> interface, we can pass it as an argument, but this is not mandatory, of course.</p><p class="calibre10">The result of the <code class="email">ExecuteAlgorithm</code> method, as defined in the fifth acceptance criterion, must return a string that contains the returned value of the <code class="email">first()</code> method, the returned value of <code class="email">TestStruct</code> (the <code class="email">world</code> string) and the returned value of the <code class="email">third()</code> method separated by a space. Our implementation is on the second place; that's why we checked that a space is prefixed and suffixed on the string <code class="email">world</code>.</p><p class="calibre10">So, if the returned string, when calling the <code class="email">ExecuteAlgorithm</code> method, doesn't contain the string <code class="email">world</code>, the test fails.</p><p class="calibre10">This is enough to make the project compile and run the tests that should fail:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v .       </strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestTemplate_ExecuteAlgorithm</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestTemplate_ExecuteAlgorithm (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">    --- FAIL: TestTemplate_ExecuteAlgorithm/Using_interfaces (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">      template_test.go:47: Expected string ' world ' was not found on returned string</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre><p class="calibre10">Time to pass to the implementation of this pattern.</p></div></div></div></body></html>