- en: Anonymous functions
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: This is not the only way to achieve the Template design pattern. We can also
    use an anonymous function to give our implementation to the `ExecuteAlgorithm`
    method.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是实现模板设计模式的唯一方法。我们还可以使用匿名函数将我们的实现提供给 `ExecuteAlgorithm` 方法。
- en: 'Let''s write a test in the same method that was used previously just after
    the test (marked in bold):'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在之前的测试方法之后编写一个相同的测试（用粗体标记）：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our new test is called *Using anonymous functions*. We have also extracted the
    checking on the test to an external function to reuse it in this test. We have
    called this function `expectedOrError` because it will fail with an error if the
    expected value isn't received.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新测试被称为 *使用匿名函数*。我们还已经将测试的检查提取到一个外部函数中，以便在这个测试中重用它。我们把这个函数称为 `expectedOrError`，因为它如果没有收到预期值就会失败。
- en: In our test, we will create a type called `AnonymousTemplate` that replaces
    the previous `Template` type. The `ExecuteAlgorithm` method of this new type accepts
    the `func()` method `string` type that we can implement directly in the test to
    return the string `world`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中，我们将创建一个名为 `AnonymousTemplate` 的类型，它将替换之前的 `Template` 类型。这个新类型的 `ExecuteAlgorithm`
    方法接受一个 `func()` 方法，该方法以 `string` 类型返回，我们可以在测试中直接实现它以返回字符串 `world`。
- en: 'The `AnonymousTemplate` type will have the following structure:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnonymousTemplate` 类型将具有以下结构：'
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The only difference with the `Template` type is that the `ExecuteAlgorithm`
    method accepts a function that returns a string instead of a `MessageRetriever`
    interface. Let''s run the new test:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Template` 类型相比，唯一的区别是 `ExecuteAlgorithm` 方法接受一个返回字符串的函数，而不是 `MessageRetriever`
    接口。让我们运行新的测试：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can read in the output of the test execution, the error is thrown on
    the *Using anonymous functions* test, which is what we were expecting. Now we
    will write the implementation as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以在测试执行的输出中看到的那样，错误是在 *使用匿名函数* 测试中抛出的，这正是我们所期望的。现在我们将按照以下方式编写实现：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The implementation is quite similar to the one in the `Template` type. However,
    now we have passed a function called `f` that we will use as the second item in
    the string array we used on `Join` function. As `f` is simply a function that
    returns a string, the only thing we need to do with it is to execute it in the
    proper place (the second position in the array).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 实现与 `Template` 类型的实现相当相似。然而，现在我们传递了一个名为 `f` 的函数，我们将将其用作在 `Join` 函数上使用的字符串数组中的第二个元素。由于
    `f` 只是一个返回字符串的函数，我们唯一需要做的就是将其在适当的位置（数组的第二个位置）执行。
- en: 'Run the tests again:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Awesome! Now we know two ways to implement the Template design pattern.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们知道了两种实现模板设计模式的方法。
