<html><head></head><body>
<div class="book" title="Chapter&#xA0;6.&#xA0;Behavioral Patterns - Template, Memento, and Interpreter Design Patterns">
<div class="book" title="Template design pattern">
<div class="book" title="How to avoid modifications on the interface"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_9"><a id="ch06lvl2sec0148" class="calibre1"/>How to avoid modifications on the interface</h2></div></div></div><p class="calibre10">The problem of the previous approach is that now we have two templates to maintain and we could end duplicating code. What can we do in the situation that we cannot change the interface are we using? Our interface was <code class="email">MessageRetriever</code> but we want to use an anonymous function now.</p><p class="calibre10">Well, do you remember the Adapter design pattern? We just have to create an <code class="email">Adapter</code> type that, accepting a <code class="email">func() string</code> type, returns an implementation of the <code class="email">MessageRetriever</code> interface. We will call this type <code class="email">TemplateAdapter</code>:</p><pre class="programlisting">type TemplateAdapter struct { 
  myFunc func() string 
} 
 
func (a *TemplateAdapter) Message() string { 
  return "" 
} 
 
func MessageRetrieverAdapter(f func() string) MessageRetriever { 
  return nil 
} 
</pre><p class="calibre10">As you can see, the <code class="email">TemplateAdapter</code> type has a field called <code class="email">myFunc</code> which is of type <code class="email">func() string</code>. We have also defined adapter as private because it shouldn't be used without a function defined in the <code class="email">myFunc</code> field. We have created a public function called the <code class="email">MessageRetrieverAdapter</code> to achieve this. Our test should look more or less like this:</p><pre class="programlisting">t.Run("Using anonymous functions adapted to an interface", func(t *testing.T){ 
  messageRetriever := MessageRetrieverAdapter(func() string { 
    return "world" 
  }) 
 
  if messageRetriever == nil { 
    t.Fatal("Can not continue with a nil MessageRetriever") 
  } 
 
  template := Template{} 
  res := template.ExecuteAlgorithm(messageRetriever) 
 
  expectedOrError(res, " world ", t) 
}) 
</pre><p class="calibre10">Look at the statement where we called the <code class="email">MessageRetrieverAdapter</code> method. We passed an anonymous function as an argument defined as <code class="email">func()</code> string. Then, we reuse the previously defined <code class="email">Template</code> type from our first test to pass the <code class="email">messageRetriever</code> variable. Finally, we checked again with the <code class="email">expectedOrError</code> method. Take a look at the <code class="email">MessageRetrieverAdapter</code> method, it will return a function that has nil value. If strictly following the test-driven development rules, we must do tests first and they must not pass before implementation is done. That's why we returned nil on the <code class="email">MessageRetrieverAdapter</code> function.</p><p class="calibre10">So, let's run the tests:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestTemplate_ExecuteAlgorithm</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestTemplate_ExecuteAlgorithm/Using_anonymous_functions</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestTemplate_ExecuteAlgorithm/Using_anonymous_functions_adapted_to_an_interface</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestTemplate_ExecuteAlgorithm (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">    --- PASS: TestTemplate_ExecuteAlgorithm/Using_interfaces (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">    --- PASS: TestTemplate_ExecuteAlgorithm/Using_anonymous_functions (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">    --- FAIL: TestTemplate_ExecuteAlgorithm/Using_anonymous_functions_adapted_to_an_interface (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">      template_test.go:39: Can not continue with a nil MessageRetriever</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre><p class="calibre10">The test fails on <span class="strong"><em class="calibre11">line 39</em></span> of the code and it doesn't continue (again, depending on how you wrote your code, the line representing your error could be somewhere else). We stop test execution because we will need a valid <code class="email">MessageRetriever</code> interface when we call the <code class="email">ExecuteAlgorithm</code> method.</p><p class="calibre10">For the implementation of the adapter for our Template pattern, we will start with <code class="email">MessageRetrieverAdapter</code> method:</p><pre class="programlisting">func MessageRetrieverAdapter(f func() string) MessageRetriever { 
  return &amp;adapter{myFunc: f} 
} 
</pre><p class="calibre10">It's very easy, right? You could be wondering what happens if we pass <code class="email">nil</code> value for the <code class="email">f</code> argument. Well, we will cover this issue by calling the <code class="email">myFunc</code> function.</p><p class="calibre10">The <code class="email">adapter</code> type is finished with this implementation:</p><pre class="programlisting">type adapter struct { 
  myFunc func() string 
} 
 
func (a *adapter) Message() string { 
  if a.myFunc != nil { 
    return a.myFunc() 
  } 
 
  return "" 
} 
</pre><p class="calibre10">When calling the <code class="email">Message()</code> function, we check that we actually have something stored in the <code class="email">myFunc</code> function before calling. If nothing was stored, we return an empty string.</p><p class="calibre10">Now, our third implementation of the <code class="email">Template</code> type, using the Adapter pattern, is done:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestTemplate_ExecuteAlgorithm</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestTemplate_ExecuteAlgorithm/Using_interfaces</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestTemplate_ExecuteAlgorithm/Using_anonymous_functions</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestTemplate_ExecuteAlgorithm/Using_anonymous_functions_adapted_to_an_interface</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestTemplate_ExecuteAlgorithm (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">    --- PASS: TestTemplate_ExecuteAlgorithm/Using_interfaces (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">    --- PASS: TestTemplate_ExecuteAlgorithm/Using_anonymous_functions (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">    --- PASS: TestTemplate_ExecuteAlgorithm/Using_anonymous_functions_adapted_to_an_interface (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre></div></div></div></body></html>