- en: How to avoid modifications on the interface
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何避免对接口的修改
- en: The problem of the previous approach is that now we have two templates to maintain
    and we could end duplicating code. What can we do in the situation that we cannot
    change the interface are we using? Our interface was `MessageRetriever` but we
    want to use an anonymous function now.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 之前方法的问题在于现在我们有两个模板需要维护，我们可能会重复代码。如果我们不能更改正在使用的接口，我们该怎么办？我们的接口是`MessageRetriever`，但现在我们想使用匿名函数。
- en: 'Well, do you remember the Adapter design pattern? We just have to create an
    `Adapter` type that, accepting a `func() string` type, returns an implementation
    of the `MessageRetriever` interface. We will call this type `TemplateAdapter`:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，你还记得适配器设计模式吗？我们只需要创建一个接受`func() string`类型的`Adapter`类型，并返回`MessageRetriever`接口的实现。我们将这种类型称为`TemplateAdapter`：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, the `TemplateAdapter` type has a field called `myFunc` which
    is of type `func() string`. We have also defined adapter as private because it
    shouldn''t be used without a function defined in the `myFunc` field. We have created
    a public function called the `MessageRetrieverAdapter` to achieve this. Our test
    should look more or less like this:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`TemplateAdapter`类型有一个名为`myFunc`的字段，其类型为`func() string`。我们还定义适配器为私有，因为它不应该在没有在`myFunc`字段中定义函数的情况下使用。我们创建了一个名为`MessageRetrieverAdapter`的公共函数来实现这一点。我们的测试应该看起来大致如下：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Look at the statement where we called the `MessageRetrieverAdapter` method.
    We passed an anonymous function as an argument defined as `func()` string. Then,
    we reuse the previously defined `Template` type from our first test to pass the
    `messageRetriever` variable. Finally, we checked again with the `expectedOrError`
    method. Take a look at the `MessageRetrieverAdapter` method, it will return a
    function that has nil value. If strictly following the test-driven development
    rules, we must do tests first and they must not pass before implementation is
    done. That's why we returned nil on the `MessageRetrieverAdapter` function.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们调用`MessageRetrieverAdapter`方法的语句。我们传递了一个定义为`func() string`的匿名函数作为参数。然后，我们重用第一次测试中定义的`Template`类型来传递`messageRetriever`变量。最后，我们再次使用`expectedOrError`方法进行检查。看看`MessageRetrieverAdapter`方法，它将返回一个具有nil值的函数。如果我们严格遵循测试驱动开发规则，我们必须先进行测试，并且测试必须在实现完成之前通过。这就是为什么我们在`MessageRetrieverAdapter`函数中返回nil的原因。
- en: 'So, let''s run the tests:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们运行测试：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The test fails on *line 39* of the code and it doesn't continue (again, depending
    on how you wrote your code, the line representing your error could be somewhere
    else). We stop test execution because we will need a valid `MessageRetriever`
    interface when we call the `ExecuteAlgorithm` method.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 测试在代码的第*39行*失败，并且没有继续执行（再次强调，这取决于你如何编写代码，表示错误的行可能位于其他位置）。我们停止测试执行，因为我们调用`ExecuteAlgorithm`方法时需要有效的`MessageRetriever`接口。
- en: 'For the implementation of the adapter for our Template pattern, we will start
    with `MessageRetrieverAdapter` method:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的模板模式的适配器实现，我们将从`MessageRetrieverAdapter`方法开始：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It's very easy, right? You could be wondering what happens if we pass `nil` value
    for the `f` argument. Well, we will cover this issue by calling the `myFunc` function.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单，对吧？你可能想知道如果我们为`f`参数传递`nil`值会发生什么。嗯，我们将通过调用`myFunc`函数来解决这个问题。
- en: 'The `adapter` type is finished with this implementation:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`适配器`类型通过以下实现完成：'
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When calling the `Message()` function, we check that we actually have something
    stored in the `myFunc` function before calling. If nothing was stored, we return
    an empty string.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`Message()`函数时，我们在调用`myFunc`函数之前检查是否实际上在该函数中存储了某些内容。如果没有存储任何内容，我们返回一个空字符串。
- en: 'Now, our third implementation of the `Template` type, using the Adapter pattern,
    is done:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用适配器模式完成了对`Template`类型的第三种实现：
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
