- en: Looking for the Template pattern in Go's source code
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Go 的源代码中寻找模板模式
- en: The `Sort` package in Go's source code can be considered a Template implementation
    of a sort algorithm. As defined in the package itself, the `Sort` package provides
    primitives for sorting slices and user-defined collections.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go 源代码中的 `Sort` 包可以被认为是一个排序算法的模板实现。正如包本身所定义的，`Sort` 包提供了对切片和用户定义集合进行排序的原语。
- en: 'Here, we can also find a good example of why Go authors aren''t worried about
    implementing generics. Sorting the lists is maybe the best example of generic
    usage in other languages. The way that Go deals with this is very elegant too-it
    deals with this issue with an interface:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们也可以找到一个很好的例子，说明为什么 Go 的作者不担心实现泛型。对列表进行排序可能是其他语言中泛型使用的最佳例子。Go 处理这个问题的方式也非常优雅——它通过一个接口来处理这个问题：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is the interface for lists that need to be sorted by using the `sort`
    package. In the words of Go''s authors:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是需要使用 `sort` 包进行排序的列表的接口。用 Go 的作者的话来说：
- en: '*"A type, typically, is a collection that satisfies sort. Interface can be
    sorted by the routines in this package. The methods require that the elements
    of the collection be enumerated by an integer index."*'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"一个类型，通常是满足 sort 接口的集合。该集合可以通过本包中的例程进行排序。这些方法要求集合的元素可以通过整数索引进行枚举。"* '
- en: In other words, write a type that implements this `Interface` so that the `Sort`
    package can be used to sort any slice. The sorting algorithm is the template and
    we must define how to retrieve values in our slice.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，编写一个实现这个 `Interface` 的类型，这样 `Sort` 包就可以用来对任何切片进行排序。排序算法是模板，我们必须定义如何在我们的切片中检索值。
- en: 'If we peek in the `sort` package, we can also find an example of how to use
    the sorting template but we will create our own example:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `sort` 包，我们也可以找到一个如何使用排序模板的示例，但我们将创建自己的示例：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, we have done a very simple type that stores an `int` list. This could
    be any kind of list, usually a list of some kind of struct. Then we have implemented
    the `sort.Interface` interface by defining the `Len`, `Swap`, and `Less` methods.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个非常简单的类型，它存储了一个 `int` 列表。这可以是任何类型的列表，通常是某种结构体的列表。然后我们通过定义 `Len`、`Swap`
    和 `Less` 方法实现了 `sort.Interface` 接口。
- en: 'Finally, the `main` function creates an unordered list of numbers of the `MyList`
    type:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`main` 函数创建了一个无序列表，列表中的元素是 `MyList` 类型：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We print the list that we created (unordered) and then we sort it (the `sort.Sort`
    method actually modifies our variable instead of returning a new list so beware!).
    Finally, we print again the resulting list. The console output of this `main`
    method is the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印出我们创建的列表（无序列表），然后对其进行排序（`sort.Sort` 方法实际上修改了我们的变量而不是返回一个新的列表，所以要注意！）。最后，我们再次打印出结果列表。这个
    `main` 方法的控制台输出如下：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `sort.Sort` function has sorted our list in a transparent way. It has a
    lot of code written and delegates `Len`, `Swap` and `Less` methods to an interface,
    like we did in our template delegating to the `MessageRetriever` interface.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort.Sort` 函数以透明的方式对我们的列表进行了排序。它写了很多代码，并将 `Len`、`Swap` 和 `Less` 方法委托给一个接口，就像我们在模板中委托给
    `MessageRetriever` 接口一样。'
