<html><head></head><body>
<div class="book" title="Memento design pattern">
<div class="book" title="Unit test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch06lvl2sec0155" class="calibre1"/>Unit test</h2></div></div></div><p class="calibre10">As mentioned previously, the Memento design pattern is usually composed of three actors: state, memento, and originator. So we will need three types to represent these actors:</p><pre class="programlisting">type State struct { 
  Description string 
} 
</pre><p class="calibre10">The <code class="email">State</code> type is the core business object we will be using during this example. It's any kind of object that we want to track:</p><pre class="programlisting">type memento struct { 
  state State 
} 
</pre><p class="calibre10">The <code class="email">memento</code> type has a field called <code class="email">state</code> representing a single value of a <code class="email">State</code> type. Our <code class="email">states</code> will be containerized within this type before storing them into the <code class="email">care taker</code> type. You could be wondering why we don't store directly <code class="email">State</code> instances. Basically, because it will couple the <code class="email">originator</code> and the <code class="email">careTaker</code> to the business object and we want to have as little coupling as possible. It will also be less flexible, as we will see in the second example:</p><pre class="programlisting">type originator struct { 
  state State 
} 
 
func (o *originator) NewMemento() memento { 
  return memento{} 
} 
 
func (o *originator) ExtractAndStoreState(m memento) { 
  //Does nothing 
} 
</pre><p class="calibre10">The <code class="email">originator</code> type also stores a state. The <code class="email">originator</code> struct's objects will take states from mementos and create new mementos with their stored state.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="tip016" class="calibre1"/>Tip</h3><p class="calibre10">What's the difference between the originator object and the Memento pattern? Why don't we use Originator pattern's object directly? Well, if the Memento contains a specific state, the <code class="email">originator</code> type contains the state that is currently loaded. Also, to save the state of something could be as simple as to take some value or as complex as to maintain the state of some distributed application.</p></div><p class="calibre10">The Originator will have two public methods--the <code class="email">NewMemento()</code> method and the <code class="email">ExtractAndStoreState(m memento)</code> method. The <code class="email">NewMemento</code> method will return a new Memento built with <code class="email">originator</code> current <code class="email">State</code> value. The <code class="email">ExtractAndStoreState</code> method will take the state of a Memento and store it in the <code class="email">Originator</code>'s state field:</p><pre class="programlisting">type careTaker struct { 
  mementoList []memento 
} 
 
func (c *careTaker) Add(m memento) { 
  //Does nothing 
} 
 
func (c *careTaker) Memento(i int) (memento, error) { 
  return memento{}, fmt.Errorf("Not implemented yet") 
} 
</pre><p class="calibre10">The <code class="email">careTaker</code> type stores the Memento list with all the states we need to save. It also stores an <code class="email">Add</code> method to insert a new Memento on the list and a Memento retriever that takes an index on the Memento list.</p><p class="calibre10">So let's start with the <code class="email">Add</code> method of the <code class="email">careTaker</code> type. The <code class="email">Add</code> method must take a <code class="email">memento</code> object and add it to the <code class="email">careTaker</code> object's list of Mementos:</p><pre class="programlisting">func TestCareTaker_Add(t *testing.T) { 
  originator := originator{} 
  originator.state = State{Description:"Idle"} 
 
  careTaker := careTaker{} 
  mem := originator.NewMemento() 
  if mem.state.Description != "Idle" { 
    t.Error("Expected state was not found") 
  } 
</pre><p class="calibre10">At the beginning of our test, we created two basic actors for memento--the <code class="email">originator</code> and the <code class="email">careTaker</code>. We set a first state on the originator with the description <code class="email">Idle</code>.</p><p class="calibre10">Then, we create the first Memento calling the <code class="email">NewMemento</code> method. This should wrap the current originator's state in a <code class="email">memento</code> type. Our first check is very simple--the state description of the returned Memento must be like the state description we pass to the originator, that is, the <code class="email">Idle</code> description.</p><p class="calibre10">The last step to check whether our Memento's <code class="email">Add</code> method works correctly is to see whether the Memento list has grown after adding one item:</p><pre class="programlisting">  currentLen := len(careTaker.mementoList) 
  careTaker.Add(mem) 
 
  if len(careTaker.mementoList) != currentLen+1 { 
    t.Error("No new elements were added on the list") 
  } 
</pre><p class="calibre10">We also have to test the <code class="email">Memento(int) memento</code> method. This should take a <code class="email">memento</code> value from the <code class="email">careTaker</code> list. It takes the index you want to retrieve from the list so, as usual with lists, we must check that it behaves correctly against negative numbers and out of index values:</p><pre class="programlisting">func TestCareTaker_Memento(t *testing.T) { 
  originator := originator{} 
  careTaker := careTaker{} 
 
  originator.state = State{"Idle"} 
  careTaker.Add(originator.NewMemento()) 
</pre><p class="calibre10">We have to start like we did in our previous test--creating an <code class="email">originator</code> and <code class="email">careTaker</code> objects and adding the first Memento to the <code class="email">caretaker</code>:</p><pre class="programlisting">  mem, err := careTaker.Memento(0) 
  if err != nil { 
    t.Fatal(err) 
  } 
 
  if mem.state.Description != "Idle" { 
    t.Error("Unexpected state") 
  } 
</pre><p class="calibre10">Once we have the first object on the <code class="email">careTaker</code> object, we can ask for it using <code class="email">careTaker.Memento(0)</code>. Index <code class="email">0</code> on the <code class="email">Memento(int)</code> method retrieves the first item on the slice (remember that slices start with <code class="email">0</code>). No error should be returned because we have already added a value to the <code class="email">caretaker</code> object.</p><p class="calibre10">Then, after retrieving the first memento, we checked that the description matches the one that we passed at the beginning of the test:</p><pre class="programlisting">  mem, err = careTaker.Memento(-1) 
  if err == nil { 
    t.Fatal("An error is expected when asking for a negative number but no error was found") 
  } 
} 
</pre><p class="calibre10">The last step on this test involves using a negative number to retrieve some value. In this case, an error must be returned that shows that no negative numbers can be used. It is also possible to return the first index when you pass negative numbers but here we will return an error.</p><p class="calibre10">The last function to check is the <code class="email">ExtractAndStoreState</code> method. This function must take a Memento and extract all its state information to set it in the <code class="email">Originator</code> object:</p><pre class="programlisting">func TestOriginator_ExtractAndStoreState(t *testing.T) { 
  originator := originator{state:State{"Idle"}} 
  idleMemento := originator.NewMemento() 
 
  originator.ExtractAndStoreState(idleMemento) 
  if originator.state.Description != "Idle" { 
    t.Error("Unexpected state found") 
  } 
} 
</pre><p class="calibre10">This test is simple. We create a default <code class="email">originator</code> variable with an <code class="email">Idle</code> state. Then, we retrieve a new Memento object to use it later. We change the state of the <code class="email">originator</code> variable to the <code class="email">Working</code> state to ensure that the new state will be written.</p><p class="calibre10">Finally, we have to call the <code class="email">ExtractAndStoreState</code> method with the <code class="email">idleMemento</code> variable. This should restore the state of the originator to the <code class="email">idleMemento</code> state's value, something that we checked in the last <code class="email">if</code> statement.</p><p class="calibre10">Now it's time to run the tests:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v .         </strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestCareTaker_Add</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestCareTaker_Add (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">  memento_test.go:13: Expected state was not found</strong></span>
<span class="strong"><strong class="calibre2">  memento_test.go:20: No new elements were added on the list</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestCareTaker_Memento</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestCareTaker_Memento (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">  memento_test.go:33: Not implemented yet</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestOriginator_ExtractAndStoreState</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestOriginator_ExtractAndStoreState (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">  memento_test.go:54: Unexpected state found</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre><p class="calibre10">Because the three tests fail, we can continue with the implementation.</p></div></div></body></html>