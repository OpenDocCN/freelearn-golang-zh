- en: Unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned previously, the Memento design pattern is usually composed of
    three actors: state, memento, and originator. So we will need three types to represent
    these actors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `State` type is the core business object we will be using during this example.
    It''s any kind of object that we want to track:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `memento` type has a field called `state` representing a single value of
    a `State` type. Our `states` will be containerized within this type before storing
    them into the `care taker` type. You could be wondering why we don''t store directly
    `State` instances. Basically, because it will couple the `originator` and the
    `careTaker` to the business object and we want to have as little coupling as possible.
    It will also be less flexible, as we will see in the second example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `originator` type also stores a state. The `originator` struct's objects
    will take states from mementos and create new mementos with their stored state.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What's the difference between the originator object and the Memento pattern?
    Why don't we use Originator pattern's object directly? Well, if the Memento contains
    a specific state, the `originator` type contains the state that is currently loaded.
    Also, to save the state of something could be as simple as to take some value
    or as complex as to maintain the state of some distributed application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Originator will have two public methods--the `NewMemento()` method and
    the `ExtractAndStoreState(m memento)` method. The `NewMemento` method will return
    a new Memento built with `originator` current `State` value. The `ExtractAndStoreState`
    method will take the state of a Memento and store it in the `Originator`''s state
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `careTaker` type stores the Memento list with all the states we need to
    save. It also stores an `Add` method to insert a new Memento on the list and a
    Memento retriever that takes an index on the Memento list.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s start with the `Add` method of the `careTaker` type. The `Add` method
    must take a `memento` object and add it to the `careTaker` object''s list of Mementos:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of our test, we created two basic actors for memento--the `originator`
    and the `careTaker`. We set a first state on the originator with the description
    `Idle`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we create the first Memento calling the `NewMemento` method. This should
    wrap the current originator's state in a `memento` type. Our first check is very
    simple--the state description of the returned Memento must be like the state description
    we pass to the originator, that is, the `Idle` description.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step to check whether our Memento''s `Add` method works correctly
    is to see whether the Memento list has grown after adding one item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to test the `Memento(int) memento` method. This should take a
    `memento` value from the `careTaker` list. It takes the index you want to retrieve
    from the list so, as usual with lists, we must check that it behaves correctly
    against negative numbers and out of index values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to start like we did in our previous test--creating an `originator`
    and `careTaker` objects and adding the first Memento to the `caretaker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the first object on the `careTaker` object, we can ask for it using `careTaker.Memento(0)`.
    Index `0` on the `Memento(int)` method retrieves the first item on the slice (remember
    that slices start with `0`). No error should be returned because we have already
    added a value to the `caretaker` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, after retrieving the first memento, we checked that the description matches
    the one that we passed at the beginning of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The last step on this test involves using a negative number to retrieve some
    value. In this case, an error must be returned that shows that no negative numbers
    can be used. It is also possible to return the first index when you pass negative
    numbers but here we will return an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last function to check is the `ExtractAndStoreState` method. This function
    must take a Memento and extract all its state information to set it in the `Originator`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This test is simple. We create a default `originator` variable with an `Idle`
    state. Then, we retrieve a new Memento object to use it later. We change the state
    of the `originator` variable to the `Working` state to ensure that the new state
    will be written.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have to call the `ExtractAndStoreState` method with the `idleMemento`
    variable. This should restore the state of the originator to the `idleMemento`
    state's value, something that we checked in the last `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Because the three tests fail, we can continue with the implementation.
  prefs: []
  type: TYPE_NORMAL
