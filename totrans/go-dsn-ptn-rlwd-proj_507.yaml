- en: Unit test
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'As mentioned previously, the Memento design pattern is usually composed of
    three actors: state, memento, and originator. So we will need three types to represent
    these actors:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，备忘录设计模式通常由三个演员组成：状态、备忘录和原型。因此，我们需要三个类型来表示这些演员：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `State` type is the core business object we will be using during this example.
    It''s any kind of object that we want to track:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`State` 类型是我们将在本例中使用的核心业务对象。它是我们想要跟踪的任何类型的对象：'
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `memento` type has a field called `state` representing a single value of
    a `State` type. Our `states` will be containerized within this type before storing
    them into the `care taker` type. You could be wondering why we don''t store directly
    `State` instances. Basically, because it will couple the `originator` and the
    `careTaker` to the business object and we want to have as little coupling as possible.
    It will also be less flexible, as we will see in the second example:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`memento` 类型有一个名为 `state` 的字段，表示 `State` 类型的单个值。我们的 `states` 将在这个类型中容器化，然后再存储到
    `care taker` 类型中。你可能想知道为什么我们不直接存储 `State` 实例。基本上，因为这会将 `originator` 和 `careTaker`
    与业务对象耦合起来，而我们希望尽可能减少耦合。它也将变得不那么灵活，正如我们将在第二个例子中看到的那样：'
- en: '[PRE2]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `originator` type also stores a state. The `originator` struct's objects
    will take states from mementos and create new mementos with their stored state.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`originator` 类型也存储一个状态。`originator` 结构体的对象将从备忘录中获取状态，并使用它们存储的状态创建新的备忘录。'
- en: Tip
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: What's the difference between the originator object and the Memento pattern?
    Why don't we use Originator pattern's object directly? Well, if the Memento contains
    a specific state, the `originator` type contains the state that is currently loaded.
    Also, to save the state of something could be as simple as to take some value
    or as complex as to maintain the state of some distributed application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 原型对象和备忘录模式之间的区别是什么？为什么我们不直接使用原型模式的对象？嗯，如果备忘录包含一个特定的状态，`originator` 类型包含当前加载的状态。此外，保存某个状态可能像获取一些值那样简单，也可能像维护某些分布式应用程序的状态那样复杂。
- en: 'The Originator will have two public methods--the `NewMemento()` method and
    the `ExtractAndStoreState(m memento)` method. The `NewMemento` method will return
    a new Memento built with `originator` current `State` value. The `ExtractAndStoreState`
    method will take the state of a Memento and store it in the `Originator`''s state
    field:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 原型将有两个公共方法——`NewMemento()` 方法和 `ExtractAndStoreState(m memento)` 方法。`NewMemento`
    方法将返回一个使用 `originator` 当前 `State` 值构建的新备忘录。`ExtractAndStoreState` 方法将接受备忘录的状态并将其存储在
    `Originator` 的状态字段中：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `careTaker` type stores the Memento list with all the states we need to
    save. It also stores an `Add` method to insert a new Memento on the list and a
    Memento retriever that takes an index on the Memento list.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`careTaker` 类型存储了包含我们需要保存的所有状态的备忘录列表。它还存储了一个 `Add` 方法，用于在列表中插入新的备忘录，以及一个备忘录检索器，它接受备忘录列表上的索引。'
- en: 'So let''s start with the `Add` method of the `careTaker` type. The `Add` method
    must take a `memento` object and add it to the `careTaker` object''s list of Mementos:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们从 `careTaker` 类型的 `Add` 方法开始。`Add` 方法必须接受一个 `memento` 对象，并将其添加到 `careTaker`
    对象的备忘录列表中：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At the beginning of our test, we created two basic actors for memento--the `originator`
    and the `careTaker`. We set a first state on the originator with the description
    `Idle`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试开始时，我们为备忘录创建了两个基本演员——`originator` 和 `careTaker`。我们在原型上设置了一个初始状态，描述为 `Idle`。
- en: Then, we create the first Memento calling the `NewMemento` method. This should
    wrap the current originator's state in a `memento` type. Our first check is very
    simple--the state description of the returned Memento must be like the state description
    we pass to the originator, that is, the `Idle` description.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用 `NewMemento` 方法创建第一个备忘录。这应该将当前原型状态包装在 `memento` 类型中。我们的第一个检查非常简单——返回的备忘录的状态描述必须类似于我们传递给原型的状态描述，即
    `Idle` 描述。
- en: 'The last step to check whether our Memento''s `Add` method works correctly
    is to see whether the Memento list has grown after adding one item:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的备忘录的 `Add` 方法是否正确工作的最后一步是查看在添加一个项目后备忘录列表是否已增长：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We also have to test the `Memento(int) memento` method. This should take a
    `memento` value from the `careTaker` list. It takes the index you want to retrieve
    from the list so, as usual with lists, we must check that it behaves correctly
    against negative numbers and out of index values:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须测试 `Memento(int) memento` 方法。这应该从 `careTaker` 列表中获取一个 `memento` 值。它接受你想要从列表中检索的索引，因此，像列表中通常那样，我们必须检查它是否正确地处理了负数和越界值：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have to start like we did in our previous test--creating an `originator`
    and `careTaker` objects and adding the first Memento to the `caretaker`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须像之前的测试那样开始——创建一个`originator`和`careTaker`对象，并将第一个记忆体添加到`caretaker`中：
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once we have the first object on the `careTaker` object, we can ask for it using `careTaker.Memento(0)`.
    Index `0` on the `Memento(int)` method retrieves the first item on the slice (remember
    that slices start with `0`). No error should be returned because we have already
    added a value to the `caretaker` object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`careTaker`对象上有了第一个对象，我们可以使用`careTaker.Memento(0)`来请求它。`Memento(int)`方法中的索引`0`检索切片上的第一个项目（记住切片从`0`开始）。不应该返回错误，因为我们已经向`caretaker`对象添加了一个值。
- en: 'Then, after retrieving the first memento, we checked that the description matches
    the one that we passed at the beginning of the test:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在检索到第一个记忆体之后，我们检查描述是否与我们在测试开始时传递的相匹配：
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The last step on this test involves using a negative number to retrieve some
    value. In this case, an error must be returned that shows that no negative numbers
    can be used. It is also possible to return the first index when you pass negative
    numbers but here we will return an error.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试的最后一步涉及使用负数来检索某个值。在这种情况下，必须返回一个错误，表明不能使用负数。当传递负数时，也可以返回第一个索引，但在这里我们将返回一个错误。
- en: 'The last function to check is the `ExtractAndStoreState` method. This function
    must take a Memento and extract all its state information to set it in the `Originator`
    object:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要检查的函数是`ExtractAndStoreState`方法。这个函数必须接受一个记忆体，并从中提取所有状态信息以设置在`Originator`对象中：
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This test is simple. We create a default `originator` variable with an `Idle`
    state. Then, we retrieve a new Memento object to use it later. We change the state
    of the `originator` variable to the `Working` state to ensure that the new state
    will be written.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试很简单。我们创建一个具有`Idle`状态的默认`originator`变量。然后，我们检索一个新的记忆体对象以供以后使用。我们将`originator`变量的状态更改为`Working`状态，以确保新状态将被写入。
- en: Finally, we have to call the `ExtractAndStoreState` method with the `idleMemento`
    variable. This should restore the state of the originator to the `idleMemento`
    state's value, something that we checked in the last `if` statement.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须使用`idleMemento`变量调用`ExtractAndStoreState`方法。这应该将`originator`的状态恢复到`idleMemento`状态值，这是我们之前在最后一个`if`语句中检查过的。
- en: 'Now it''s time to run the tests:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候运行测试了：
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Because the three tests fail, we can continue with the implementation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因为三个测试都失败了，我们可以继续实施。
