<html><head></head><body>
<div class="book" title="Memento design pattern">
<div class="book" title="Implementing the Memento pattern"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch06lvl2sec0156" class="calibre1"/>Implementing the Memento pattern</h2></div></div></div><p class="calibre10">The Memento pattern's implementationÂ is usually very simple if you don't get too crazy. The three actors (<code class="email">memento</code>, <code class="email">originator</code>, and <code class="email">care taker</code>) have a very defined role in the pattern and their implementation is very straightforward:</p><pre class="programlisting">type originator struct { 
  state State 
} 
 
func (o *originator) NewMemento() memento { 
  return memento{state: o.state} 
} 
 
func (o *originator) ExtractAndStoreState(m memento) { 
  o.state = m.state 
} 
</pre><p class="calibre10">The <code class="email">Originator</code> object needs to return a new values of Memento types when calling the <code class="email">NewMemento</code> method. It also needs to store the value of a <code class="email">memento</code> object in the state field of the struct as needed for the <code class="email">ExtractAndStoreState</code> method:</p><pre class="programlisting">type careTaker struct { 
  mementoList []memento 
} 
 
func (c *careTaker) Push(m memento) { 
  c.mementoList = append(c.mementoList, m) 
} 
 
func (c *careTaker) Memento(i int) (memento, error) { 
  if len(c.mementoList) &lt; i || i &lt; 0 { 
    return memento{}, fmt.Errorf("Index not found\n") 
  } 
  return c.mementoList[i], nil 
} 
</pre><p class="calibre10">The <code class="email">careTaker</code> type is also straightforward. When we call the <code class="email">Add</code> method, we overwrite the <code class="email">mementoList</code> field by calling the <code class="email">append</code> method with the value passed in the argument. This creates a new list with the new value included.</p><p class="calibre10">When calling the <code class="email">Memento</code> method, we have to do a couple of checks beforehand. In this case, we check that the index is not outside of the range of the slice and that the index is not a negative number in the <code class="email">if</code> statement, in which case we return an error. If everything goes fine, it just returns the specified <code class="email">memento</code> object and no errors.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="tip017" class="calibre1"/>Tip</h3><p class="calibre10">A note about method and function naming conventions.
You could find some people that like to give slightly more descriptive names to methods such as <code class="email">Memento</code>. An example would be to use a name such as <code class="email">MementoOrError</code> method, clearly showing that you return two objects when calling this function or even <code class="email">GetMementoOrError</code> method.
This could be a very explicit approach for naming and it's not necessarily bad, but you won't find it very common in Go's source code.</p></div>Time to check the test results:
<pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestCareTaker_Add</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestCareTaker_Add (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestCareTaker_Memento</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestCareTaker_Memento (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestOriginator_ExtractAndStoreState</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestOriginator_ExtractAndStoreState (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre><p class="calibre10">That was enough to reach 100% of coverage. While this is far from being a perfect metric, at least we know that we are reaching every corner of our source code and that we haven't cheated in our tests to achieve it.</p></div></div></body></html>