- en: Implementing the Memento pattern
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现备忘录模式
- en: 'The Memento pattern''s implementation is usually very simple if you don''t
    get too crazy. The three actors (`memento`, `originator`, and `care taker`) have
    a very defined role in the pattern and their implementation is very straightforward:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不做得太过分，备忘录模式的实现通常非常简单。三个参与者（`memento`、`originator` 和 `care taker`）在模式中有着非常明确的角色，它们的实现也非常直接：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Originator` object needs to return a new values of Memento types when
    calling the `NewMemento` method. It also needs to store the value of a `memento`
    object in the state field of the struct as needed for the `ExtractAndStoreState`
    method:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`Originator` 对象在调用 `NewMemento` 方法时需要返回 Memento 类型的新的值。它还需要根据需要将 `memento`
    对象的值存储在结构体的状态字段中，以便 `ExtractAndStoreState` 方法使用：'
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `careTaker` type is also straightforward. When we call the `Add` method,
    we overwrite the `mementoList` field by calling the `append` method with the value
    passed in the argument. This creates a new list with the new value included.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`careTaker` 类型也很直接。当我们调用 `Add` 方法时，通过调用带有参数传入的值的 `append` 方法来覆盖 `mementoList`
    字段。这会创建一个新的列表，其中包含新的值。'
- en: When calling the `Memento` method, we have to do a couple of checks beforehand.
    In this case, we check that the index is not outside of the range of the slice
    and that the index is not a negative number in the `if` statement, in which case
    we return an error. If everything goes fine, it just returns the specified `memento`
    object and no errors.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `Memento` 方法之前，我们必须做一些检查。在这种情况下，我们检查索引是否不在切片的范围内，以及索引在 `if` 语句中是否不是负数，如果是，则返回一个错误。如果一切顺利，它只返回指定的
    `memento` 对象，不返回错误。
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A note about method and function naming conventions. You could find some people
    that like to give slightly more descriptive names to methods such as `Memento`.
    An example would be to use a name such as `MementoOrError` method, clearly showing
    that you return two objects when calling this function or even `GetMementoOrError`
    method. This could be a very explicit approach for naming and it's not necessarily
    bad, but you won't find it very common in Go's source code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 关于方法和函数命名约定的说明。你可能会遇到一些人喜欢给方法如 `Memento` 起稍微描述性更强的名字。例如，可以使用 `MementoOrError`
    这样的名字，清楚地表明在调用此函数时返回两个对象，甚至 `GetMementoOrError` 方法。这可能是一种非常明确的命名方法，而且并不一定不好，但在
    Go 的源代码中你不太可能找到它。
- en: 'Time to check the test results:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候检查测试结果了：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That was enough to reach 100% of coverage. While this is far from being a perfect
    metric, at least we know that we are reaching every corner of our source code
    and that we haven't cheated in our tests to achieve it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就足够达到 100% 的覆盖率。虽然这远非一个完美的指标，但至少我们知道我们已经覆盖了源代码的每一个角落，并且在测试中我们没有作弊以达到这个目标。
