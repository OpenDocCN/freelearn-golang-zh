- en: Implementing the Memento pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Memento pattern''s implementationÂ is usually very simple if you don''t
    get too crazy. The three actors (`memento`, `originator`, and `care taker`) have
    a very defined role in the pattern and their implementation is very straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Originator` object needs to return a new values of Memento types when
    calling the `NewMemento` method. It also needs to store the value of a `memento`
    object in the state field of the struct as needed for the `ExtractAndStoreState`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `careTaker` type is also straightforward. When we call the `Add` method,
    we overwrite the `mementoList` field by calling the `append` method with the value
    passed in the argument. This creates a new list with the new value included.
  prefs: []
  type: TYPE_NORMAL
- en: When calling the `Memento` method, we have to do a couple of checks beforehand.
    In this case, we check that the index is not outside of the range of the slice
    and that the index is not a negative number in the `if` statement, in which case
    we return an error. If everything goes fine, it just returns the specified `memento`
    object and no errors.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A note about method and function naming conventions. You could find some people
    that like to give slightly more descriptive names to methods such as `Memento`.
    An example would be to use a name such as `MementoOrError` method, clearly showing
    that you return two objects when calling this function or even `GetMementoOrError`
    method. This could be a very explicit approach for naming and it's not necessarily
    bad, but you won't find it very common in Go's source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to check the test results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: That was enough to reach 100% of coverage. While this is far from being a perfect
    metric, at least we know that we are reaching every corner of our source code
    and that we haven't cheated in our tests to achieve it.
  prefs: []
  type: TYPE_NORMAL
