- en: Another example using the Command and Facade patterns
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一个使用命令和外观模式的例子
- en: The previous example is good and simple enough to understand the functionality
    of the Memento pattern. However, it is more commonly used in conjunction with
    the Command pattern and a simple Facade pattern.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子很好，足够简单，可以理解备忘录模式的功能。然而，它更常与命令模式和简单的外观模式一起使用。
- en: The idea is to use a Command pattern to encapsulate a set of different types
    of states (those that implement a `Command` interface) and provide a small facade
    to automate the insertion in the `caretaker` object.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是使用命令模式来封装一组不同类型的状态（那些实现`Command`接口的状态），并为`caretaker`对象提供一个小的外观来自动化插入。
- en: 'We are going to develop a small example of a hypothetical audio mixer. We are
    going to use the same Memento pattern to save two types of states: `Volume` and
    `Mute`. The `Volume` state is going to be a byte type and the `Mute` state a Boolean
    type. We will use two completely different types to show the flexibility of this
    approach (and its drawbacks).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个假设音频混合器的小型示例。我们将使用相同的备忘录模式来保存两种类型的状态：`Volume`和`Mute`。`Volume`状态将是`byte`类型，而`Mute`状态是布尔类型。我们将使用两种完全不同的类型来展示这种方法的灵活性（及其缺点）。
- en: As a side note, we can also ship each `Command` interface with their own serialization
    methods on the interface. This way, we can give the ability to the caretaker to
    store states in some kind of storage without really knowing what's storing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，我们还可以在每个`Command`接口上提供它们自己的序列化方法。这样，我们可以赋予`caretaker`存储状态的能力，而无需真正知道存储的是什么。
- en: 'Our `Command` interface is going to have one method to return the value of
    its implementer. It''s very simple, every command in our audio mixer that we want
    to undo will have to implement this interface:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Command`接口将有一个方法来返回其实现者的值。这很简单，我们想要撤销的每个音频混合器命令都必须实现这个接口：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There is something interesting in this interface. The `GetValue` method returns
    an interface to a value. This also means that the return type of this method is...
    well... untyped? Not really, but it returns an interface that can be a representation
    of any type and we will need to typecast it later if we want to use its specific
    type. Now we have to define the `Volume` and `Mute` types and implement the `Command`
    interface:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口中有一个有趣的地方。`GetValue`方法返回一个值的接口。这也意味着这个方法的返回类型是...嗯...无类型的？其实不是，但它返回一个可以表示任何类型的接口，我们稍后需要将其类型转换为我们想要使用的特定类型。现在我们必须定义`Volume`和`Mute`类型并实现`Command`接口：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: They are both quite easy implementations. However, the `Mute` type will return
    a `bool` type on the `GetValue()` method and `Volume` will return a `byte` type.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的实现都很简单。然而，`Mute`类型将在`GetValue()`方法上返回`bool`类型，而`Volume`将返回`byte`类型。
- en: 'As in the previous example, we''ll need a `Memento` type that will hold a `Command`.
    In other words, it will store a pointer to a `Mute` or a `Volume` type:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的例子一样，我们需要一个`Memento`类型来保存一个`Command`。换句话说，它将存储一个指向`Mute`或`Volume`类型的指针：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `originator` type works as in the previous example but uses the `Command`
    keyword instead of the `state` keyword:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`originator`类型的工作方式与之前的例子相同，但使用`Command`关键字而不是`state`关键字：'
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And the `caretaker` object is almost the same, but this time we''ll use a stack
    instead of a simple list and we will store a command instead of a state:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`caretaker`对象几乎相同，但这次我们将使用栈而不是简单的列表，并且我们将存储命令而不是状态：'
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, our `Memento` list is replaced with a `Pop` method. It also returns
    a `memento` object but it will return them acting as a stack (last to enter, first
    to go out). So, we take the last element on the stack and store it in the `tempMemento`
    variable. Then we replace the stack with a new version that doesn't contain the
    last element on the next line. Finally, we return the `tempMemento` variable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的`Memento`列表被`Pop`方法所取代。它也返回一个`memento`对象，但它将以栈的形式返回它们（后进先出）。因此，我们取出栈上的最后一个元素并将其存储在`tempMemento`变量中。然后，在下一行我们将栈替换为一个不包含最后一个元素的新版本。最后，我们返回`tempMemento`变量。
- en: 'Until now, everything looks almost like in the previous example. We also talked
    about automating some tasks by using the Facade pattern, so let''s do it. This
    is going to be called the `MementoFacade` type and will have the `SaveSettings`
    and `RestoreSettings` methods. The `SaveSettings` method takes a `Command`, stores
    it in an inner originator, and saves it in an inner `careTaker` field. The `RestoreSettings`
    method makes the opposite flow-restores an index of the `careTaker` and returns
    the `Command` inside the `Memento` object:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切看起来几乎和之前的例子一样。我们也讨论了通过使用外观模式来自动化一些任务，所以让我们来做这件事。这将被称为`MementoFacade`类型，并将具有`SaveSettings`和`RestoreSettings`方法。`SaveSettings`方法接受一个`Command`，将其存储在一个内部发起者中，并将其保存在一个内部的`careTaker`字段中。`RestoreSettings`方法执行相反的操作——恢复`careTaker`的索引，并返回`Memento`对象内部的`Command`：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our Facade pattern will hold the contents of the originator and the care taker
    and will provide those two easy-to-use methods to save and restore settings.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的外观模式将包含发起者和照顾者的内容，并提供这两个易于使用的保存和恢复设置的方法。
- en: So, how do we use this?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何使用这个呢？
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First, we get a variable with a Facade pattern. Zero-value initialization will
    give us zero-valued `originator` and `caretaker` objects. They don't have any
    unexpected field so everything will initialize correctly (if any of them had a
    pointer, for example, it would be initialized to `nil` as mentioned in the *Zero
    initialization* section of [Chapter 1](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 1. Ready... Steady... Go!"), *Ready... Steady... Go!*).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用外观模式获取一个变量。零值初始化将给我们零值的`originator`和`caretaker`对象。它们没有任何意外的字段，所以一切都将正确初始化（如果它们中有任何指针，例如，它将初始化为`nil`，如第1章中*零初始化*部分所述），*准备...
    稳定... 开始!*）。
- en: We create a `Volume` value with `Volume(4)` and, yes, we have used parentheses.
    The `Volume` type does not have any inner field like structs so we cannot use
    curly braces to set its value. The way to set it is to use parentheses (or create
    a pointer to the type `Volume` and then set the value of the pointed space). We
    also save a value of the type `Mute` using the Facade pattern.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Volume(4)`创建一个`Volume`值，是的，我们使用了括号。`Volume`类型没有像结构体那样的内部字段，所以我们不能使用花括号来设置其值。设置它的方法是使用括号（或者创建一个指向类型`Volume`的指针，然后设置指向空间的值）。我们还使用外观模式保存了一个类型为`Mute`的值。
- en: 'We don''t know what `Command` type is returned here, so we need to make a type
    assertion. We will make a small function to help us with this that checks the
    type and prints an appropriate value:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道这里返回的是哪种`Command`类型，所以我们需要进行类型断言。我们将创建一个小的函数来帮助我们完成这项工作，该函数检查类型并打印适当的值：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `assertAndPrint` method takes a `Command` type and casts it to the two
    possible types-`Volume` or `Mute`. In each case, it prints a message to the console
    with a personalized message. Now we can continue and finish the `main` function,
    which will look like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertAndPrint`方法接受一个`Command`类型，并将其转换为两种可能类型——`Volume`或`Mute`。在每种情况下，它都会在控制台打印一个带有个性化信息的消息。现在我们可以继续并完成`main`函数，它看起来像这样：'
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The part highlighted in bold shows the new changes within the `main` function.
    We took the index 0 from the `careTaker` object and passed it to the new function
    and the same with the index `1`. Running this small program, we should get the
    `Volume` and `Mute` values on the console:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的部分显示了`main`函数中的新更改。我们从`careTaker`对象中取出索引0并传递给新函数，同样也传递索引`1`。运行这个小程序，我们应该在控制台得到`Volume`和`Mute`值：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Great! In this small example, we have combined three different design patterns
    to keep getting comfortable using various patterns. Keep in mind that we could
    have abstracted the creation of `Volume` and `Mute` states to a Factory pattern
    too so this is not where would stop.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！在这个小例子中，我们已经结合了三种不同的设计模式，以便继续舒适地使用各种模式。记住，我们也可以将`Volume`和`Mute`状态的创建抽象为工厂模式，所以这并不是我们停止的地方。
