- en: Another example using the Command and Facade patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous example is good and simple enough to understand the functionality
    of the Memento pattern. However, it is more commonly used in conjunction with
    the Command pattern and a simple Facade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to use a Command pattern to encapsulate a set of different types
    of states (those that implement a `Command` interface) and provide a small facade
    to automate the insertion in the `caretaker` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to develop a small example of a hypothetical audio mixer. We are
    going to use the same Memento pattern to save two types of states: `Volume` and
    `Mute`. The `Volume` state is going to be a byte type and the `Mute` state a Boolean
    type. We will use two completely different types to show the flexibility of this
    approach (and its drawbacks).'
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, we can also ship each `Command` interface with their own serialization
    methods on the interface. This way, we can give the ability to the caretaker to
    store states in some kind of storage without really knowing what's storing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Command` interface is going to have one method to return the value of
    its implementer. It''s very simple, every command in our audio mixer that we want
    to undo will have to implement this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There is something interesting in this interface. The `GetValue` method returns
    an interface to a value. This also means that the return type of this method is...
    well... untyped? Not really, but it returns an interface that can be a representation
    of any type and we will need to typecast it later if we want to use its specific
    type. Now we have to define the `Volume` and `Mute` types and implement the `Command`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: They are both quite easy implementations. However, the `Mute` type will return
    a `bool` type on the `GetValue()` method and `Volume` will return a `byte` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the previous example, we''ll need a `Memento` type that will hold a `Command`.
    In other words, it will store a pointer to a `Mute` or a `Volume` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `originator` type works as in the previous example but uses the `Command`
    keyword instead of the `state` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `caretaker` object is almost the same, but this time we''ll use a stack
    instead of a simple list and we will store a command instead of a state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: However, our `Memento` list is replaced with a `Pop` method. It also returns
    a `memento` object but it will return them acting as a stack (last to enter, first
    to go out). So, we take the last element on the stack and store it in the `tempMemento`
    variable. Then we replace the stack with a new version that doesn't contain the
    last element on the next line. Finally, we return the `tempMemento` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Until now, everything looks almost like in the previous example. We also talked
    about automating some tasks by using the Facade pattern, so let''s do it. This
    is going to be called the `MementoFacade` type and will have the `SaveSettings`
    and `RestoreSettings` methods. The `SaveSettings` method takes a `Command`, stores
    it in an inner originator, and saves it in an inner `careTaker` field. The `RestoreSettings`
    method makes the opposite flow-restores an index of the `careTaker` and returns
    the `Command` inside the `Memento` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our Facade pattern will hold the contents of the originator and the care taker
    and will provide those two easy-to-use methods to save and restore settings.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we use this?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First, we get a variable with a Facade pattern. Zero-value initialization will
    give us zero-valued `originator` and `caretaker` objects. They don't have any
    unexpected field so everything will initialize correctly (if any of them had a
    pointer, for example, it would be initialized to `nil` as mentioned in the *Zero
    initialization* section of [Chapter 1](part0090_split_000.html#2LQIK1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 1. Ready... Steady... Go!"), *Ready... Steady... Go!*).
  prefs: []
  type: TYPE_NORMAL
- en: We create a `Volume` value with `Volume(4)` and, yes, we have used parentheses.
    The `Volume` type does not have any inner field like structs so we cannot use
    curly braces to set its value. The way to set it is to use parentheses (or create
    a pointer to the type `Volume` and then set the value of the pointed space). We
    also save a value of the type `Mute` using the Facade pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t know what `Command` type is returned here, so we need to make a type
    assertion. We will make a small function to help us with this that checks the
    type and prints an appropriate value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `assertAndPrint` method takes a `Command` type and casts it to the two
    possible types-`Volume` or `Mute`. In each case, it prints a message to the console
    with a personalized message. Now we can continue and finish the `main` function,
    which will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The part highlighted in bold shows the new changes within the `main` function.
    We took the index 0 from the `careTaker` object and passed it to the new function
    and the same with the index `1`. Running this small program, we should get the
    `Volume` and `Mute` values on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Great! In this small example, we have combined three different design patterns
    to keep getting comfortable using various patterns. Keep in mind that we could
    have abstracted the creation of `Volume` and `Mute` states to a Factory pattern
    too so this is not where would stop.
  prefs: []
  type: TYPE_NORMAL
