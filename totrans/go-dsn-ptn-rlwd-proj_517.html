<html><head></head><body>
<div class="book" title="Interpreter design pattern">
<div class="book" title="Implementation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch06lvl2sec0164" class="calibre1"/>Implementation</h2></div></div></div><p class="calibre10">Implementation is going to be longer than testing this time. To start, we will define our possible operators in constants:</p><pre class="programlisting">const ( 
  SUM = "sum" 
  SUB = "sub" 
  MUL = "mul" 
  DIV = "div" 
) 
</pre><p class="calibre10">Interpreter patterns are usually implemented using an abstract syntax tree, something that is commonly achieved using a stack. We have created stacks before during the book so this should be already familiar to readers:</p><pre class="programlisting">type polishNotationStack []int 
 
func (p *polishNotationStack) Push(s int) { 
  *p = append(*p, s) 
} 
 
func (p *polishNotationStack) Pop() int { 
  length := len(*p) 
 
  if length &gt; 0 { 
    temp := (*p)[length-1] 
    *p = (*p)[:length-1] 
    return temp 
  } 
 
  return 0 
} 
</pre><p class="calibre10">We have two methods--the <code class="email">Push</code> method to add elements to the top of the stack and the <code class="email">Pop</code> method to remove elements and return them. In case you are thinking that the line <code class="email">*p = (*p)[:length-1]</code> is a bit cryptic, we'll explain it.</p><p class="calibre10">The value stored in the direction of <code class="email">p</code> will be overridden with the actual value in the direction of <code class="email">p (*p)</code> but taking only the elements from the beginning to the penultimate element of the array <code class="email">(:length-1)</code>.</p><p class="calibre10">So, now we will go step by step with the <code class="email">Calculate</code> function, creating more functions as far as we need them:</p><pre class="programlisting">func Calculate(o string) (int, error) { 
  stack := polishNotationStack{} 
  operators := strings.Split(o, " ") 
</pre><p class="calibre10">The first two things we need to do are to create the stack and to get all different symbols from the incoming operation (in this case, we aren't checking that it isn't empty). We split the incoming string operations by the space to get a nice slice of symbols (values and operators).</p><p class="calibre10">Next, we will iterate over every symbol by using range but we need a function to know whether the incoming symbol is a value or an operator:</p><pre class="programlisting">func isOperator(o string) bool { 
  if o == SUM || o == SUB || o == MUL || o == DIV { 
    return true 
  } 
 
  return false 
} 
</pre><p class="calibre10">If the incoming symbol is any of the ones defined in our constants, the incoming symbol is an operator:</p><pre class="programlisting">func Calculate(o string) (int, error) { 
  stack := polishNotationStack{} 
  operators := strings.Split(o, " ") 
 
<span class="strong"><strong class="calibre2">for _, operatorString := range operators {</strong></span>
<span class="strong"><strong class="calibre2">  
  if isOperator(operatorString) {</strong></span>
<span class="strong"><strong class="calibre2">      
    right := stack.Pop()</strong></span>
<span class="strong"><strong class="calibre2">      
    left := stack.Pop()</strong></span>
<span class="strong"><strong class="calibre2">    
  } 
  else 
  {</strong></span>
<span class="strong"><strong class="calibre2">      
    //Is a value</strong></span>
<span class="strong"><strong class="calibre2">    
  }
</strong></span>
<span class="strong"><strong class="calibre2">}</strong></span>
</pre><p class="calibre10">If it is an operator, we consider that we have already passed two values so what we have to do is to take those two values from the stack. The first value taken would be the rightmost and the second the leftmost (remember that in subtractions and divisions, the order of the operands is important). Then, we need some function to get the operation we want to perform:</p><pre class="programlisting">func getOperationFunc(o string) func(a, b int) int { 
  switch o { 
  case SUM: 
    return func(a, b int) int { 
      return a + b 
    } 
  case SUB: 
    return func(a, b int) int { 
      return a - b 
    } 
  case MUL: 
    return func(a, b int) int { 
      return a * b 
    } 
  case DIV: 
    return func(a, b int) int { 
      return a / b 
    } 
  } 
  return nil 
} 
</pre><p class="calibre10">The <code class="email">getOperationFunc</code> functions returns a two-argument function that returns an integer. We check the incoming operator and we return an anonymous function that performs the specified operation. So, now our <code class="email">for range</code> continues like this:</p><pre class="programlisting">func Calculate(o string) (int, error) { 
  stack := polishNotationStack{} 
  operators := strings.Split(o, " ") 
 
for _, operatorString := range operators { 
  if isOperator(operatorString) { 
      right := stack.Pop() 
      left := stack.Pop() 
<span class="strong"><strong class="calibre2">      mathFunc := getOperationFunc(operatorString)</strong></span>
<span class="strong"><strong class="calibre2">      res := mathFunc(left, right)</strong></span>
<span class="strong"><strong class="calibre2">      stack.Push(res)</strong></span> 
    } else { 
      //Is a value 
    } 
} 
</pre><p class="calibre10">The <code class="email">mathFunc</code> variable is returned by the function. We use it immediately to perform the operation on the left and right values taken from the stack and we store its result in a new variable called <code class="email">res</code>. Finally, we need to push this new value to the stack to keep operating with it later.</p><p class="calibre10">Now, here is the implementation when the incoming symbol is a value:</p><pre class="programlisting">func Calculate(o string) (int, error) { 
  stack := polishNotationStack{} 
  operators := strings.Split(o, " ") 
 
for _, operatorString := range operators { 
    if isOperator(operatorString) { 
      right := stack.Pop() 
      left := stack.Pop() 
      mathFunc := getOperationFunc(operatorString) 
      res := mathFunc(left, right) 
      stack.Push(res) 
    } else { 
<span class="strong"><strong class="calibre2">      val, err := strconv.Atoi(operatorString)</strong></span>
<span class="strong"><strong class="calibre2">      
      if err != nil {</strong></span>
<span class="strong"><strong class="calibre2">        
        return 0, err</strong></span>
<span class="strong"><strong class="calibre2">      
      }</strong></span>
<span class="strong"><strong class="calibre2">      
      stack.Push(val)</strong></span> 
    } 
  } 
</pre><p class="calibre10">What we need to do every time we get a symbol is to push it to the stack. We have to parse the string symbol to a usable <code class="email">int</code> type. This is commonly done with the <code class="email">strconv</code> package by using its <code class="email">Atoi</code> function. The <code class="email">Atoi</code> function takes a string and returns an integer from it or an error. If everything goes well, the value is pushed into the stack.</p><p class="calibre10">At the end of the <code class="email">range</code> statement, just one value must be stored on it, so we just need to return it and the function is done:</p><pre class="programlisting">func Calculate(o string) (int, error) { 
  stack := polishNotationStack{} 
  operators := strings.Split(o, " ") 
 
for _, operatorString := range operators { 
    if isOperator(operatorString) { 
      right := stack.Pop() 
      left := stack.Pop() 
      mathFunc := getOperationFunc(operatorString) 
      res := mathFunc(left, right) 
      stack.Push(res) 
    } else { 
      val, err := strconv.Atoi(operatorString) 
      if err != nil { 
        return 0, err 
      } 
 
      stack.Push(val) 
    } 
  } 
<span class="strong"><strong class="calibre2">  return int(stack.Pop()), nil</strong></span>
<span class="strong"><strong class="calibre2">}</strong></span>
</pre><p class="calibre10">Time to run the tests again:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go test -v .</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre><p class="calibre10">Great! We have just created a reverse polish notation interpreter in a very simple and easy way (we still lack the parser, but that's another story).</p></div></div></body></html>