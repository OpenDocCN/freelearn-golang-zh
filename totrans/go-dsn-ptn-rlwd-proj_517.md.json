["```go\nconst ( \n  SUM = \"sum\" \n  SUB = \"sub\" \n  MUL = \"mul\" \n  DIV = \"div\" \n) \n\n```", "```go\ntype polishNotationStack []int \n\nfunc (p *polishNotationStack) Push(s int) { \n  *p = append(*p, s) \n} \n\nfunc (p *polishNotationStack) Pop() int { \n  length := len(*p) \n\n  if length > 0 { \n    temp := (*p)[length-1] \n    *p = (*p)[:length-1] \n    return temp \n  } \n\n  return 0 \n} \n\n```", "```go\nfunc Calculate(o string) (int, error) { \n  stack := polishNotationStack{} \n  operators := strings.Split(o, \" \") \n\n```", "```go\nfunc isOperator(o string) bool { \n  if o == SUM || o == SUB || o == MUL || o == DIV { \n    return true \n  } \n\n  return false \n} \n\n```", "```go\nfunc Calculate(o string) (int, error) { \n  stack := polishNotationStack{} \n  operators := strings.Split(o, \" \") \n\nfor _, operatorString := range operators {\n if isOperator(operatorString) {\n right := stack.Pop()\n left := stack.Pop()\n } \n  else \n  {\n //Is a value\n } \n}\n\n```", "```go\nfunc getOperationFunc(o string) func(a, b int) int { \n  switch o { \n  case SUM: \n    return func(a, b int) int { \n      return a + b \n    } \n  case SUB: \n    return func(a, b int) int { \n      return a - b \n    } \n  case MUL: \n    return func(a, b int) int { \n      return a * b \n    } \n  case DIV: \n    return func(a, b int) int { \n      return a / b \n    } \n  } \n  return nil \n} \n\n```", "```go\nfunc Calculate(o string) (int, error) { \n  stack := polishNotationStack{} \n  operators := strings.Split(o, \" \") \n\nfor _, operatorString := range operators { \n  if isOperator(operatorString) { \n      right := stack.Pop() \n      left := stack.Pop() \n mathFunc := getOperationFunc(operatorString)\n res := mathFunc(left, right)\n stack.Push(res) \n    } else { \n      //Is a value \n    } \n} \n\n```", "```go\nfunc Calculate(o string) (int, error) { \n  stack := polishNotationStack{} \n  operators := strings.Split(o, \" \") \n\nfor _, operatorString := range operators { \n    if isOperator(operatorString) { \n      right := stack.Pop() \n      left := stack.Pop() \n      mathFunc := getOperationFunc(operatorString) \n      res := mathFunc(left, right) \n      stack.Push(res) \n    } else { \n val, err := strconv.Atoi(operatorString)\n if err != nil {\n return 0, err\n }\n stack.Push(val) \n    } \n  } \n\n```", "```go\nfunc Calculate(o string) (int, error) { \n  stack := polishNotationStack{} \n  operators := strings.Split(o, \" \") \n\nfor _, operatorString := range operators { \n    if isOperator(operatorString) { \n      right := stack.Pop() \n      left := stack.Pop() \n      mathFunc := getOperationFunc(operatorString) \n      res := mathFunc(left, right) \n      stack.Push(res) \n    } else { \n      val, err := strconv.Atoi(operatorString) \n      if err != nil { \n        return 0, err \n      } \n\n      stack.Push(val) \n    } \n  } \n return int(stack.Pop()), nil\n}\n\n```", "```go\n$ go test -v .\nok\n\n```"]