- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implementation is going to be longer than testing this time. To start, we will
    define our possible operators in constants:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Interpreter patterns are usually implemented using an abstract syntax tree,
    something that is commonly achieved using a stack. We have created stacks before
    during the book so this should be already familiar to readers:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have two methods--the `Push` method to add elements to the top of the stack
    and the `Pop` method to remove elements and return them. In case you are thinking
    that the line `*p = (*p)[:length-1]` is a bit cryptic, we'll explain it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: The value stored in the direction of `p` will be overridden with the actual
    value in the direction of `p (*p)` but taking only the elements from the beginning
    to the penultimate element of the array `(:length-1)`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now we will go step by step with the `Calculate` function, creating more
    functions as far as we need them:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first two things we need to do are to create the stack and to get all different
    symbols from the incoming operation (in this case, we aren't checking that it
    isn't empty). We split the incoming string operations by the space to get a nice
    slice of symbols (values and operators).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will iterate over every symbol by using range but we need a function
    to know whether the incoming symbol is a value or an operator:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the incoming symbol is any of the ones defined in our constants, the incoming
    symbol is an operator:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If it is an operator, we consider that we have already passed two values so
    what we have to do is to take those two values from the stack. The first value
    taken would be the rightmost and the second the leftmost (remember that in subtractions
    and divisions, the order of the operands is important). Then, we need some function
    to get the operation we want to perform:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `getOperationFunc` functions returns a two-argument function that returns
    an integer. We check the incoming operator and we return an anonymous function
    that performs the specified operation. So, now our `for range` continues like
    this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `mathFunc` variable is returned by the function. We use it immediately to
    perform the operation on the left and right values taken from the stack and we
    store its result in a new variable called `res`. Finally, we need to push this
    new value to the stack to keep operating with it later.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, here is the implementation when the incoming symbol is a value:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What we need to do every time we get a symbol is to push it to the stack. We
    have to parse the string symbol to a usable `int` type. This is commonly done
    with the `strconv` package by using its `Atoi` function. The `Atoi` function takes
    a string and returns an integer from it or an error. If everything goes well,
    the value is pushed into the stack.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the `range` statement, just one value must be stored on it, so
    we just need to return it and the function is done:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Time to run the tests again:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Great! We have just created a reverse polish notation interpreter in a very
    simple and easy way (we still lack the parser, but that's another story).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们刚刚以一种非常简单和容易的方式创建了一个逆波兰表示法解释器（我们仍然缺少解析器，但这又是另一个故事了）。
