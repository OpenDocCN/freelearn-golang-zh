- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Implementation is going to be longer than testing this time. To start, we will
    define our possible operators in constants:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这次实现将比测试更长。首先，我们将定义我们的可能运算符为常量：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Interpreter patterns are usually implemented using an abstract syntax tree,
    something that is commonly achieved using a stack. We have created stacks before
    during the book so this should be already familiar to readers:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器模式通常使用抽象语法树来实现，这通常是通过使用栈来实现的。我们在书中之前已经创建过栈，所以这应该已经熟悉读者：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have two methods--the `Push` method to add elements to the top of the stack
    and the `Pop` method to remove elements and return them. In case you are thinking
    that the line `*p = (*p)[:length-1]` is a bit cryptic, we'll explain it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法--`Push`方法用于向栈顶添加元素，`Pop`方法用于移除元素并返回它们。如果你认为`*p = (*p)[:length-1]`这一行有点晦涩，我们将解释它。
- en: The value stored in the direction of `p` will be overridden with the actual
    value in the direction of `p (*p)` but taking only the elements from the beginning
    to the penultimate element of the array `(:length-1)`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在`p`方向上的值将被`p`方向上的实际值覆盖（`*p`），但只取数组的前一个元素（`(:length-1)`）。
- en: 'So, now we will go step by step with the `Calculate` function, creating more
    functions as far as we need them:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将逐步使用`Calculate`函数，根据需要创建更多函数：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first two things we need to do are to create the stack and to get all different
    symbols from the incoming operation (in this case, we aren't checking that it
    isn't empty). We split the incoming string operations by the space to get a nice
    slice of symbols (values and operators).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建栈，并从传入的操作中获取所有不同的符号（在这种情况下，我们并没有检查它是否为空）。我们通过空格分割传入的字符串操作，以获取一个漂亮的符号切片（值和运算符）。
- en: 'Next, we will iterate over every symbol by using range but we need a function
    to know whether the incoming symbol is a value or an operator:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`range`迭代每个符号，但我们需要一个函数来知道传入的符号是值还是运算符：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If the incoming symbol is any of the ones defined in our constants, the incoming
    symbol is an operator:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传入的符号是我们在常量中定义的任何一个，传入的符号就是一个运算符：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If it is an operator, we consider that we have already passed two values so
    what we have to do is to take those two values from the stack. The first value
    taken would be the rightmost and the second the leftmost (remember that in subtractions
    and divisions, the order of the operands is important). Then, we need some function
    to get the operation we want to perform:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它是一个运算符，我们考虑我们已经通过了两个值，所以我们必须从栈中取出这两个值。第一个取出的值将是最右边的，第二个是最左边的（记住，在减法和除法中，操作数的顺序很重要）。然后，我们需要一些函数来获取我们想要执行的操作：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `getOperationFunc` functions returns a two-argument function that returns
    an integer. We check the incoming operator and we return an anonymous function
    that performs the specified operation. So, now our `for range` continues like
    this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`getOperationFunc`函数返回一个接受两个参数的函数，该函数返回一个整数。我们检查传入的运算符，并返回一个执行指定操作的匿名函数。因此，现在我们的`for
    range`继续这样：'
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `mathFunc` variable is returned by the function. We use it immediately to
    perform the operation on the left and right values taken from the stack and we
    store its result in a new variable called `res`. Finally, we need to push this
    new value to the stack to keep operating with it later.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`mathFunc`变量由函数返回。我们立即使用它来对从栈中取出的左右值执行操作，并将其结果存储在一个新变量`res`中。最后，我们需要将这个新值推入栈中，以便稍后继续操作。'
- en: 'Now, here is the implementation when the incoming symbol is a value:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里是对传入符号为值的实现：
- en: '[PRE7]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What we need to do every time we get a symbol is to push it to the stack. We
    have to parse the string symbol to a usable `int` type. This is commonly done
    with the `strconv` package by using its `Atoi` function. The `Atoi` function takes
    a string and returns an integer from it or an error. If everything goes well,
    the value is pushed into the stack.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们获取一个符号时，我们需要将其推入栈中。我们必须将字符串符号解析为可用的`int`类型。这通常使用`strconv`包的`Atoi`函数来完成。`Atoi`函数接受一个字符串并从中返回一个整数或错误。如果一切顺利，值将被推入栈中。
- en: 'At the end of the `range` statement, just one value must be stored on it, so
    we just need to return it and the function is done:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`range`语句的末尾，只需存储一个值，所以我们只需返回它，函数就完成了：
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Time to run the tests again:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试的时间到了：
- en: '[PRE9]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Great! We have just created a reverse polish notation interpreter in a very
    simple and easy way (we still lack the parser, but that's another story).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们刚刚以一种非常简单和容易的方式创建了一个逆波兰表示法解释器（我们仍然缺少解析器，但这又是另一个故事了）。
