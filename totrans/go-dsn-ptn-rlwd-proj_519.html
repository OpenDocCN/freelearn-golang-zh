<html><head></head><body>
<div class="book" title="Interpreter design pattern">
<div class="book" title="Interpreter pattern again - now using interfaces"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_8"><a id="ch06lvl2sec0166" class="calibre1"/>Interpreter pattern again - now using interfaces</h2></div></div></div><p class="calibre10">The main interface we are going to use is called the <code class="email">Interpreter</code> interface. This interface has a <code class="email">Read()</code> method that every symbol (value or operator) must implement:</p><pre class="programlisting">type Interpreter interface { 
  Read() int 
} 
</pre><p class="calibre10">We will implement only the sum and the subtraction from the operators and a type called <code class="email">Value</code> for the numbers:</p><pre class="programlisting">type value int 
 
func (v *value) Read() int { 
  return int(*v) 
} 
</pre><p class="calibre10">The <code class="email">Value</code> is a type <code class="email">int</code> that, when implementing the <code class="email">Read</code> method, just returns its value:</p><pre class="programlisting">type operationSum struct { 
  Left  Interpreter 
  Right Interpreter 
} 
 
func (a *operationSum) Read() int { 
  return a.Left.Read() + a.Right.Read() 
} 
</pre><p class="calibre10">The <code class="email">operationSum</code> struct has the <code class="email">Left</code> and <code class="email">Right</code> fields and its <code class="email">Read</code> method returns the sum of each of their <code class="email">Read</code> methods. The <code class="email">operationSubtract</code> struct is the same but subtracting:</p><pre class="programlisting">type operationSubtract struct { 
  Left  Interpreter 
  Right Interpreter 
} 
 
func (s *operationSubtract) Read() int { 
  return s.Left.Read() - s.Right.Read() 
} 
</pre><p class="calibre10">We also need a Factory pattern to create operators; we will call it the <code class="email">operatorFactory</code> method. The difference now is that it not only accepts the symbol but also the <code class="email">Left</code> and <code class="email">Right</code> values taken from the stack:</p><pre class="programlisting">func operatorFactory(o string, left, right Interpreter) Interpreter { 
  switch o { 
  case SUM: 
    return &amp;operationSum{ 
      Left: left, 
      Right: right, 
    } 
  case SUB: 
    return &amp;operationSubtract{ 
      Left: left, 
      Right: right, 
    } 
  } 
 
  return nil 
} 
</pre><p class="calibre10">As we have just mentioned, we also need a stack. We can reuse the one from the previous example by changing its type:</p><pre class="programlisting">type polishNotationStack []Interpreter 
 
func (p *polishNotationStack) Push(s Interpreter) { 
  *p = append(*p, s) 
} 
 
func (p *polishNotationStack) Pop() Interpreter { 
  length := len(*p) 
 
  if length &gt; 0 { 
    temp := (*p)[length-1] 
    *p = (*p)[:length-1] 
    return temp 
  } 
 
  return nil 
} 
</pre><p class="calibre10">Now the stack works with Interpreter pointers instead of <code class="email">int</code> but its functionality is the same. Finally, our <code class="email">main</code> method also looks similar to our previous example:</p><pre class="programlisting">func main() { 
  stack := polishNotationStack{} 
  operators := strings.Split("3 4 sum 2 sub", " ") 
 
  for _, operatorString := range operators { 
    if operatorString == SUM || operatorString == SUB { 
      right := stack.Pop() 
      left := stack.Pop() 
      mathFunc := operatorFactory(operatorString, left, right) 
      res := value(mathFunc.Read()) 
      stack.Push(&amp;res) 
    } else { 
      val, err := strconv.Atoi(operatorString) 
      if err != nil { 
        panic(err) 
      } 
 
      temp := value(val) 
      stack.Push(&amp;temp) 
    } 
  } 
 
  println(int(stack.Pop().Read())) 
} 
</pre><p class="calibre10">Like before, we check whether the symbol is operator or value first. When it's a value, it pushes it into the stack.</p><p class="calibre10">When the symbol is an operator, we also take the right and left values from the stack, we call the Factory pattern using the current operator and the left and right values that we just took from the stack. Once we have the operator type, we just need to call its <code class="email">Read</code> method to push the returned value to the stack too.</p><p class="calibre10">Finally, just one example must be left on the stack, so we print it:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run interpreter.go</strong></span>
<span class="strong"><strong class="calibre2">5</strong></span>
</pre></div></div></body></html>