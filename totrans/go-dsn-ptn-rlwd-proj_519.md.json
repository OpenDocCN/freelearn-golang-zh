["```go\ntype Interpreter interface { \n  Read() int \n} \n\n```", "```go\ntype value int \n\nfunc (v *value) Read() int { \n  return int(*v) \n} \n\n```", "```go\ntype operationSum struct { \n  Left  Interpreter \n  Right Interpreter \n} \n\nfunc (a *operationSum) Read() int { \n  return a.Left.Read() + a.Right.Read() \n} \n\n```", "```go\ntype operationSubtract struct { \n  Left  Interpreter \n  Right Interpreter \n} \n\nfunc (s *operationSubtract) Read() int { \n  return s.Left.Read() - s.Right.Read() \n} \n\n```", "```go\nfunc operatorFactory(o string, left, right Interpreter) Interpreter { \n  switch o { \n  case SUM: \n    return &operationSum{ \n      Left: left, \n      Right: right, \n    } \n  case SUB: \n    return &operationSubtract{ \n      Left: left, \n      Right: right, \n    } \n  } \n\n  return nil \n} \n\n```", "```go\ntype polishNotationStack []Interpreter \n\nfunc (p *polishNotationStack) Push(s Interpreter) { \n  *p = append(*p, s) \n} \n\nfunc (p *polishNotationStack) Pop() Interpreter { \n  length := len(*p) \n\n  if length > 0 { \n    temp := (*p)[length-1] \n    *p = (*p)[:length-1] \n    return temp \n  } \n\n  return nil \n} \n\n```", "```go\nfunc main() { \n  stack := polishNotationStack{} \n  operators := strings.Split(\"3 4 sum 2 sub\", \" \") \n\n  for _, operatorString := range operators { \n    if operatorString == SUM || operatorString == SUB { \n      right := stack.Pop() \n      left := stack.Pop() \n      mathFunc := operatorFactory(operatorString, left, right) \n      res := value(mathFunc.Read()) \n      stack.Push(&res) \n    } else { \n      val, err := strconv.Atoi(operatorString) \n      if err != nil { \n        panic(err) \n      } \n\n      temp := value(val) \n      stack.Push(&temp) \n    } \n  } \n\n  println(int(stack.Pop().Read())) \n} \n\n```", "```go\n$ go run interpreter.go\n5\n\n```"]