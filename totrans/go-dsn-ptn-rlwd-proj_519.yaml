- en: Interpreter pattern again - now using interfaces
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 再次实现解释器模式 - 现在使用接口
- en: 'The main interface we are going to use is called the `Interpreter` interface.
    This interface has a `Read()` method that every symbol (value or operator) must
    implement:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的主要接口称为`Interpreter`接口。此接口有一个`Read()`方法，每个符号（值或操作符）都必须实现：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will implement only the sum and the subtraction from the operators and a
    type called `Value` for the numbers:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只实现操作符的加法和减法以及一个名为`Value`的类型用于数字：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Value` is a type `int` that, when implementing the `Read` method, just
    returns its value:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`Value`是一个`int`类型，在实现`Read`方法时，只需返回其值：'
- en: '[PRE2]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `operationSum` struct has the `Left` and `Right` fields and its `Read`
    method returns the sum of each of their `Read` methods. The `operationSubtract` struct
    is the same but subtracting:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`operationSum`结构体有`Left`和`Right`字段，其`Read`方法返回每个`Read`方法的和。`operationSubtract`结构体与之相同，但进行减法操作：'
- en: '[PRE3]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We also need a Factory pattern to create operators; we will call it the `operatorFactory`
    method. The difference now is that it not only accepts the symbol but also the
    `Left` and `Right` values taken from the stack:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个工厂模式来创建操作符；我们将称之为`operatorFactory`方法。现在的不同之处在于它不仅接受符号，还接受从栈中取出的`Left`和`Right`值：
- en: '[PRE4]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As we have just mentioned, we also need a stack. We can reuse the one from
    the previous example by changing its type:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才提到的，我们还需要一个栈。我们可以通过更改其类型来重用之前的示例：
- en: '[PRE5]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now the stack works with Interpreter pointers instead of `int` but its functionality
    is the same. Finally, our `main` method also looks similar to our previous example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在栈使用解释器指针而不是`int`，但其功能相同。最后，我们的`main`方法也类似于之前的示例：
- en: '[PRE6]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Like before, we check whether the symbol is operator or value first. When it's
    a value, it pushes it into the stack.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们首先检查符号是操作符还是值。当它是值时，将其推入栈中。
- en: When the symbol is an operator, we also take the right and left values from
    the stack, we call the Factory pattern using the current operator and the left
    and right values that we just took from the stack. Once we have the operator type,
    we just need to call its `Read` method to push the returned value to the stack
    too.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当符号是一个操作符时，我们也从栈中取出左右值，我们使用当前操作符和从栈中取出的左右值来调用工厂模式。一旦我们有了操作符类型，我们只需调用它的`Read`方法，将返回的值推送到栈中。
- en: 'Finally, just one example must be left on the stack, so we print it:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，只留下一个示例在栈上，所以我们打印它：
- en: '[PRE7]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
