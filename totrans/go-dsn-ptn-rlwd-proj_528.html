<html><head></head><body>
<div class="book" title="Chapter&#xA0;7.&#xA0;Behavioral Patterns - Visitor, State, Mediator, and Observer Design Patterns">
<div class="book" title="Visitor design pattern">
<div class="book" title="Unit tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch07lvl2sec0172" class="calibre1"/>Unit tests</h2></div></div></div><p class="calibre10">As we mentioned before, we will need a role for the <code class="email">Visitor</code> and the <code class="email">Visitable</code> interfaces. They will be interfaces. We also need the <code class="email">MessageA</code> and <code class="email">MessageB</code> structs:</p><pre class="programlisting">package visitor 
 
import ( 
  "io" 
  "os" 
  "fmt" 
) 
 
type MessageA struct { 
  Msg string 
  Output io.Writer 
} 
 
type MessageB struct { 
  Msg string 
  Output io.Writer 
} 
 
type Visitor interface { 
  VisitA(*MessageA) 
  VisitB(*MessageB) 
} 
 
type Visitable interface { 
  Accept(Visitor) 
} 
 
type MessageVisitor struct {} 
</pre><p class="calibre10">The types <code class="email">MessageA</code> and <code class="email">MessageB</code> structs both have an <code class="email">Msg</code> field to store the text that they will print. The output <code class="email">io.Writer</code> will implement the <code class="email">os.Stdout</code> interface by default or a new <code class="email">io.Writer</code> interface, like the one we will use to check that the contents are correct.</p><p class="calibre10">The <code class="email">Visitor</code> interface has a <code class="email">Visit</code> method, one for each of <code class="email">Visitable</code> interface's <code class="email">MessageA</code> and <code class="email">MessageB</code> type. The <code class="email">Visitable</code> interface has a method called <code class="email">Accept(Visitor)</code> that will execute the decoupled algorithm.</p><p class="calibre10">Like in previous examples, we will create a type that implements the <code class="email">io.Writer</code> package so that we can use it in tests:</p><pre class="programlisting">package visitor 
 
import "testing" 
 
type TestHelper struct { 
  Received string 
} 
 
func (t *TestHelper) Write(p []byte) (int, error) { 
  t.Received = string(p) 
  return len(p), nil 
} 
</pre><p class="calibre10">The <code class="email">TestHelper</code> struct implements the <code class="email">io.Writer</code> interface. Its functionality is quite simple; it stores the written bytes on the <code class="email">Received</code> field. Later we can check the contents of <code class="email">Received</code> to test against our expected value.</p><p class="calibre10">We will write just one test that will check the overall correctness of the code. Within this test, we will write two sub tests: one for <code class="email">MessageA</code> and one for <code class="email">MessageB</code> types:</p><pre class="programlisting">func Test_Overall(t *testing.T) { 
  testHelper := &amp;TestHelper{} 
  visitor := &amp;MessageVisitor{} 
  ... 
} 
</pre><p class="calibre10">We will use a <code class="email">TestHelper</code> struct and a <code class="email">MessageVisitor</code> struct on each test for each message type. First, we will test the <code class="email">MessageA</code> type:</p><pre class="programlisting">func Test_Overall(t *testing.T) { 
  testHelper := &amp;TestHelper{} 
  visitor := &amp;MessageVisitor{} 
 
  t.Run("MessageA test", func(t *testing.T){ 
    msg := MessageA{ 
      Msg: "Hello World", 
      Output: testHelper, 
    } 
 
    msg.Accept(visitor) 
    msg.Print() 
 
    expected := "A: Hello World (Visited A)" 
    if testHelper.Received !=  expected { 
      t.Errorf("Expected result was incorrect. %s != %s", 
      testHelper.Received, expected) 
    } 
  }) 
  ... 
} 
</pre><p class="calibre10">This is the full first test. We created <code class="email">MessageA</code> struct, giving it a value <code class="email">Hello World</code> for the <code class="email">Msg</code> field and the pointer to <code class="email">TestHelper</code>, which we created at the beginning of the test. Then, we execute its <code class="email">Accept</code> method. Inside the <code class="email">Accept(Visitor)</code> method on the <code class="email">MessageA</code> struct, the <code class="email">VisitA(*MessageA)</code> method is executed to alter the contents of the <code class="email">Msg</code> field (that's why we passed the pointer to <code class="email">VisitA</code> method, without a pointer the contents won't be persisted).</p><p class="calibre10">To test if the <code class="email">Visitor</code> type has done its job within the <code class="email">Accept</code> method, we must call the <code class="email">Print()</code> method on the <code class="email">MessageA</code> type later. This way, the <code class="email">MessageA</code> struct must write the contents of <code class="email">Msg</code> to the provided <code class="email">io.Writer</code> interface (our <code class="email">TestHelper</code>).</p><p class="calibre10">The last part of the test is the check. According to the description of <span class="strong"><em class="calibre11">acceptance criteria 2</em></span>, the output text of <code class="email">MessageA</code> type must be prefixed with the text <code class="email">A:</code>, the stored message and the text <code class="email">"(Visited)"</code> just at the end. So, for the <code class="email">MessageA</code> type, the expected text must be <code class="email">"A: Hello World (Visited)"</code>, this is the check that we did in the <code class="email">if</code> section.</p><p class="calibre10">The <code class="email">MessageB</code> type has a very similar implementation:</p><pre class="programlisting">  t.Run("MessageB test", func(t *testing.T){ 
    msg := MessageB { 
      Msg: "Hello World", 
      Output: testHelper, 
    } 
 
    msg.Accept(visitor) 
    msg.Print() 
 
    expected := "B: Hello World (Visited B)" 
    if testHelper.Received !=  expected { 
      t.Errorf("Expected result was incorrect. %s != %s", 
        testHelper.Received, expected) 
    } 
  }) 
} 
</pre><p class="calibre10">In fact, we have just changed the type from <code class="email">MessageA</code> to <code class="email">MessageB</code> and the expected text now is <code class="email">"B: Hello World (Visited B)"</code>. The <code class="email">Msg</code> field is also <code class="email">"Hello World"</code> and we also used the <code class="email">TestHelper</code> type.</p><p class="calibre10">We still lack the correct implementations of the interfaces to compile the code and run the tests. The <code class="email">MessageA</code> and <code class="email">MessageB</code> structs have to implement the <code class="email">Accept(Visitor)</code> method:</p><pre class="programlisting">func (m *MessageA) Accept(v Visitor) { 
  //Do nothing 
} 
 
func (m *MessageB) Accept(v Visitor) { 
  //Do nothing 
} 
</pre><p class="calibre10">We need the implementations of the <code class="email">VisitA(*MessageA)</code> and <code class="email">VisitB(*MessageB)</code> methods that are declared on the <code class="email">Visitor</code> interface. The <code class="email">MessageVisitor</code> interface is the type that must implement them:</p><pre class="programlisting">func (mf *MessageVisitor) VisitA(m *MessageA){ 
  //Do nothing 
} 
func (mf *MessageVisitor) VisitB(m *MessageB){ 
  //Do nothing 
} 
</pre><p class="calibre10">Finally, we will create a <code class="email">Print()</code> method for each message type. This is the method that we will use to test the contents of the <code class="email">Msg</code> field on each type:</p><pre class="programlisting">func (m *MessageA) Print(){ 
  //Do nothing 
} 
 
func (m *MessageB) Print(){ 
  //Do nothing 
} 
</pre><p class="calibre10">Now we can run the tests to really check if they are failing yet:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   Test_Overall</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   Test_Overall/MessageA_test</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   Test_Overall/MessageB_test</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: Test_Overall (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">  --- FAIL: Test_Overall/MessageA_test (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">      visitor_test.go:30: Expected result was incorrect.  != A: Hello World (Visited A)</strong></span>
<span class="strong"><strong class="calibre2">  --- FAIL: Test_Overall/MessageB_test (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">      visitor_test.go:46: Expected result was incorrect.  != B: Hello World (Visited B)</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre><p class="calibre10">The outputs of the tests are clear. The expected messages were incorrect because the contents were empty. It's time to create the implementations.</p></div></div></div></body></html>