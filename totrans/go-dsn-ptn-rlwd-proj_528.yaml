- en: Unit tests
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'As we mentioned before, we will need a role for the `Visitor` and the `Visitable`
    interfaces. They will be interfaces. We also need the `MessageA` and `MessageB`
    structs:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，我们需要为 `Visitor` 和 `Visitable` 接口定义一个角色。它们将是接口。我们还需要 `MessageA` 和 `MessageB`
    结构体：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The types `MessageA` and `MessageB` structs both have an `Msg` field to store
    the text that they will print. The output `io.Writer` will implement the `os.Stdout`
    interface by default or a new `io.Writer` interface, like the one we will use
    to check that the contents are correct.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `MessageA` 和 `MessageB` 结构体都有一个 `Msg` 字段来存储它们将要打印的文本。默认情况下，输出 `io.Writer`
    将实现 `os.Stdout` 接口，或者一个新的 `io.Writer` 接口，就像我们将要用来检查内容是否正确的那样。
- en: The `Visitor` interface has a `Visit` method, one for each of `Visitable` interface's
    `MessageA` and `MessageB` type. The `Visitable` interface has a method called `Accept(Visitor)`
    that will execute the decoupled algorithm.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`Visitor` 接口有一个 `Visit` 方法，对应于 `Visitable` 接口的 `MessageA` 和 `MessageB` 类型。`Visitable`
    接口有一个名为 `Accept(Visitor)` 的方法，它将执行解耦算法。'
- en: 'Like in previous examples, we will create a type that implements the `io.Writer`
    package so that we can use it in tests:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在之前的例子中一样，我们将创建一个实现 `io.Writer` 包的类型，这样我们就可以在测试中使用它：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `TestHelper` struct implements the `io.Writer` interface. Its functionality
    is quite simple; it stores the written bytes on the `Received` field. Later we
    can check the contents of `Received` to test against our expected value.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestHelper` 结构体实现了 `io.Writer` 接口。它的功能相当简单；它将写入的字节存储在 `Received` 字段中。稍后我们可以检查
    `Received` 的内容，以测试我们的预期值。'
- en: 'We will write just one test that will check the overall correctness of the
    code. Within this test, we will write two sub tests: one for `MessageA` and one
    for `MessageB` types:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只写一个测试来检查代码的整体正确性。在这个测试中，我们将写两个子测试：一个用于 `MessageA` 类型，一个用于 `MessageB` 类型：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will use a `TestHelper` struct and a `MessageVisitor` struct on each test
    for each message type. First, we will test the `MessageA` type:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在每个测试中为每种消息类型使用一个 `TestHelper` 结构体和一个 `MessageVisitor` 结构体。首先，我们将测试 `MessageA`
    类型：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is the full first test. We created `MessageA` struct, giving it a value
    `Hello World` for the `Msg` field and the pointer to `TestHelper`, which we created
    at the beginning of the test. Then, we execute its `Accept` method. Inside the
    `Accept(Visitor)` method on the `MessageA` struct, the `VisitA(*MessageA)` method
    is executed to alter the contents of the `Msg` field (that's why we passed the
    pointer to `VisitA` method, without a pointer the contents won't be persisted).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的第一个测试。我们创建了 `MessageA` 结构体，给它 `Msg` 字段赋值为 `Hello World`，并传递了我们在测试开始时创建的
    `TestHelper` 指针。然后，我们执行它的 `Accept` 方法。在 `MessageA` 结构体上的 `Accept(Visitor)` 方法内部，执行了
    `VisitA(*MessageA)` 方法来更改 `Msg` 字段的内容（这就是为什么我们传递了 `VisitA` 方法的指针，如果没有指针，内容将不会持久化）。
- en: To test if the `Visitor` type has done its job within the `Accept` method, we
    must call the `Print()` method on the `MessageA` type later. This way, the `MessageA` struct
    must write the contents of `Msg` to the provided `io.Writer` interface (our `TestHelper`).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 `Visitor` 类型是否在 `Accept` 方法中完成了其工作，我们必须稍后对 `MessageA` 类型调用 `Print()` 方法。这样，`MessageA`
    结构体必须将 `Msg` 字段的内容写入提供的 `io.Writer` 接口（我们的 `TestHelper`）。
- en: 'The last part of the test is the check. According to the description of *acceptance
    criteria 2*, the output text of `MessageA` type must be prefixed with the text `A:`,
    the stored message and the text `"(Visited)"` just at the end. So, for the `MessageA`
    type, the expected text must be `"A: Hello World (Visited)"`, this is the check
    that we did in the `if` section.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '测试的最后部分是检查。根据 *验收标准 2* 的描述，`MessageA` 类型的输出文本必须以文本 `A:` 开头，然后是存储的消息和文本 `"(Visited)"`，正好在末尾。因此，对于
    `MessageA` 类型，预期的文本必须是 `"A: Hello World (Visited)"`，这就是我们在 `if` 部分所做的检查。'
- en: 'The `MessageB` type has a very similar implementation:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessageB` 类型的实现非常相似：'
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In fact, we have just changed the type from `MessageA` to `MessageB` and the
    expected text now is `"B: Hello World (Visited B)"`. The `Msg` field is also `"Hello
    World"` and we also used the `TestHelper` type.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，我们只是将类型从 `MessageA` 改为 `MessageB`，并且预期的文本现在是 `"B: Hello World (Visited
    B)"`。`Msg` 字段也是 `"Hello World"`，我们同样使用了 `TestHelper` 类型。'
- en: 'We still lack the correct implementations of the interfaces to compile the
    code and run the tests. The `MessageA` and `MessageB` structs have to implement
    the `Accept(Visitor)` method:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然缺少接口的正确实现来编译代码和运行测试。`MessageA` 和 `MessageB` 结构体必须实现 `Accept(Visitor)` 方法：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We need the implementations of the `VisitA(*MessageA)` and `VisitB(*MessageB)`
    methods that are declared on the `Visitor` interface. The `MessageVisitor` interface
    is the type that must implement them:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现`Visitor`接口中声明的`VisitA(*MessageA)`和`VisitB(*MessageB)`方法。`MessageVisitor`接口是实现它们的类型：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we will create a `Print()` method for each message type. This is the
    method that we will use to test the contents of the `Msg` field on each type:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为每种消息类型创建一个`Print()`方法。这是我们用来测试每个类型`Msg`字段内容的那个方法：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we can run the tests to really check if they are failing yet:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行测试来真正检查它们是否已经失败：
- en: '[PRE8]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The outputs of the tests are clear. The expected messages were incorrect because
    the contents were empty. It's time to create the implementations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的输出是清晰的。预期的消息是不正确的，因为内容为空。是时候创建实现类了。
