<html><head></head><body>
<div class="book" title="Chapter&#xA0;7.&#xA0;Behavioral Patterns - Visitor, State, Mediator, and Observer Design Patterns">
<div class="book" title="Visitor design pattern">
<div class="book" title="Implementation of Visitor pattern"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch07lvl2sec0173" class="calibre1"/>Implementation of Visitor pattern</h2></div></div></div><p class="calibre10">We will start completing the implementation of the <code class="email">VisitA(*MessageA)</code> and <code class="email">VisitB(*MessageB)</code> methods:</p><pre class="programlisting">func (mf *MessageVisitor) VisitA(m *MessageA){ 
  m.Msg = fmt.Sprintf("%s %s", m.Msg, "(Visited A)") 
} 
func (mf *MessageVisitor) VisitB(m *MessageB){ 
  m.Msg = fmt.Sprintf("%s %s", m.Msg, "(Visited B)") 
} 
</pre><p class="calibre10">Its functionality is quite straightforward--the <code class="email">fmt.Sprintf</code> method returns a formatted string with the actual contents of <code class="email">m.Msg</code>, a white space, and the message, <code class="email">Visited</code>. This string will be stored on the <code class="email">Msg</code> field, overriding the previous contents.</p><p class="calibre10">Now we will develop the <code class="email">Accept</code> method for each message type that must execute the corresponding Visitor:</p><pre class="programlisting">func (m *MessageA) Accept(v Visitor) { 
  v.VisitA(m) 
} 
 
func (m *MessageB) Accept(v Visitor) { 
  v.VisitB(m) 
} 
</pre><p class="calibre10">This small code has some implications on it. In both cases, we are using a <code class="email">Visitor</code>, which in our example is exactly the same as the <code class="email">MessageVisitor</code> interface, but they could be completely different. The key is to understand that the Visitor pattern executes an algorithm in its <code class="email">Visit</code> method that deals with the <code class="email">Visitable</code> object. What could the <code class="email">Visitor</code> be doing? In this example, it alters the <code class="email">Visitable</code> object, but it could be simply fetching information from it. For example, we could have a <code class="email">Person</code> type with lots of fields: name, surname, age, address, city, postal code, and so on. We could write a Visitor to fetch just the name and surname from a person as a unique string, a visitor to fetch the address info for a different section of an app, and so on.</p><p class="calibre10">Finally, there is the <code class="email">Print()</code> method, which will help us to test the types. We mentioned before that it must print to the <code class="email">Stdout</code> call by default:</p><pre class="programlisting">func (m *MessageA) Print() { 
  if m.Output == nil { 
    m.Output = os.Stdout 
  } 
 
  fmt.Fprintf(m.Output, "A: %s", m.Msg) 
} 
 
func (m *MessageB) Print() { 
  if m.Output == nil { 
    m.Output = os.Stdout 
  } 
  fmt.Fprintf(m.Output, "B: %s", m.Msg) 
} 
</pre><p class="calibre10">It first checks the content of the <code class="email">Output</code> field to assign the output of the <code class="email">os.Stdout</code> call in case it is null. In our tests, we are storing a pointer there to our <code class="email">TestHelper</code> type so this line is never executed in our test. Finally, each message type prints to the <code class="email">Output</code> field, the full message stored in the <code class="email">Msg</code> field. This is done by using the <code class="email">Fprintf</code> method, which takes an <code class="email">io.Writer</code> package as the first argument and the text to format as the next arguments.</p><p class="calibre10">Our implementation is now complete and we can run the tests again to see if they all pass now:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   Test_Overall</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   Test_Overall/MessageA_test</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   Test_Overall/MessageB_test</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: Test_Overall (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">  --- PASS: Test_Overall/MessageA_test (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">  --- PASS: Test_Overall/MessageB_test (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre><p class="calibre10">Everything is OK! The Visitor pattern has done its job flawlessly and the message contents were altered after calling their <code class="email">Visit</code> methods. The very important thing here is that we can add more functionality to both the structs, <code class="email">MessageA</code> and <code class="email">MessageB</code>, without altering their types. We can just create a new Visitor type that does everything on the <code class="email">Visitable</code>, for example, we can create a <code class="email">Visitor</code> to add a method that prints the contents of the <code class="email">Msg</code> field:</p><pre class="programlisting">type MsgFieldVisitorPrinter struct {} 
 
func (mf *MsgFieldVisitorPrinter) VisitA(m *MessageA){ 
  fmt.Printf(m.Msg) 
} 
func (mf *MsgFieldVisitorPrinter) VisitB(m *MessageB){ 
  fmt.Printf(m.Msg) 
} 
</pre><p class="calibre10">We have just added some functionality to both types without altering their contents! That's the power of the Visitor design pattern.</p></div></div></div></body></html>