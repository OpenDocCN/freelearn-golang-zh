- en: Implementation of Visitor pattern
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问者模式的实现
- en: 'We will start completing the implementation of the `VisitA(*MessageA)` and
    `VisitB(*MessageB)` methods:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始完成`VisitA(*MessageA)`和`VisitB(*MessageB)`方法的实现：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Its functionality is quite straightforward--the `fmt.Sprintf` method returns
    a formatted string with the actual contents of `m.Msg`, a white space, and the
    message, `Visited`. This string will be stored on the `Msg` field, overriding
    the previous contents.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 其功能相当直接——`fmt.Sprintf`方法返回一个格式化的字符串，包含`m.Msg`的实际内容、一个空格和消息`Visited`。这个字符串将被存储在`Msg`字段中，覆盖之前的内容。
- en: 'Now we will develop the `Accept` method for each message type that must execute
    the corresponding Visitor:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为每种消息类型开发必须执行相应访问者的`Accept`方法：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This small code has some implications on it. In both cases, we are using a
    `Visitor`, which in our example is exactly the same as the `MessageVisitor` interface,
    but they could be completely different. The key is to understand that the Visitor
    pattern executes an algorithm in its `Visit` method that deals with the `Visitable`
    object. What could the `Visitor` be doing? In this example, it alters the `Visitable`
    object, but it could be simply fetching information from it. For example, we could
    have a `Person` type with lots of fields: name, surname, age, address, city, postal
    code, and so on. We could write a Visitor to fetch just the name and surname from
    a person as a unique string, a visitor to fetch the address info for a different
    section of an app, and so on.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这段小代码有一些影响。在两种情况下，我们都在使用一个`Visitor`，在我们的例子中，它与`MessageVisitor`接口完全相同，但它们可以是完全不同的。关键是理解访问者模式在其`Visit`方法中执行一个算法，该算法处理`Visitable`对象。`Visitor`可以做什么？在这个例子中，它改变了`Visitable`对象，但它也可以简单地从它那里获取信息。例如，我们可以有一个具有许多字段`Person`类型：姓名、姓氏、年龄、地址、城市、邮政编码等等。我们可以编写一个访问者来从一个人那里获取唯一的字符串（姓名和姓氏），一个访问者来获取应用程序不同部分的地址信息，等等。
- en: 'Finally, there is the `Print()` method, which will help us to test the types.
    We mentioned before that it must print to the `Stdout` call by default:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个`Print()`方法，它将帮助我们测试类型。我们之前提到，它默认必须打印到`Stdout`调用：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It first checks the content of the `Output` field to assign the output of the `os.Stdout` call
    in case it is null. In our tests, we are storing a pointer there to our `TestHelper`
    type so this line is never executed in our test. Finally, each message type prints
    to the `Output` field, the full message stored in the `Msg` field. This is done
    by using the `Fprintf` method, which takes an `io.Writer` package as the first
    argument and the text to format as the next arguments.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先检查`Output`字段的内容，以分配`os.Stdout`调用的输出，以防它是空的。在我们的测试中，我们在这里存储了一个指向我们的`TestHelper`类型的指针，因此这一行在我们的测试中永远不会执行。最后，每种消息类型都会打印到`Output`字段，即存储在`Msg`字段中的完整消息。这是通过使用`Fprintf`方法完成的，它将`io.Writer`包作为第一个参数，将格式化文本作为后续参数。
- en: 'Our implementation is now complete and we can run the tests again to see if
    they all pass now:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实施现在已完成，我们可以再次运行测试，看看它们现在是否都通过了：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Everything is OK! The Visitor pattern has done its job flawlessly and the message
    contents were altered after calling their `Visit` methods. The very important
    thing here is that we can add more functionality to both the structs, `MessageA`
    and `MessageB`, without altering their types. We can just create a new Visitor
    type that does everything on the `Visitable`, for example, we can create a `Visitor`
    to add a method that prints the contents of the `Msg` field:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一切正常！访问者模式完美地完成了它的任务，并且在调用它们的`Visit`方法后，消息内容被更改了。这里非常重要的一点是，我们可以向`MessageA`和`MessageB`这两个结构体添加更多功能，而无需更改它们的类型。我们只需创建一个新的`Visitor`类型，它对`Visitable`做所有事情，例如，我们可以创建一个`Visitor`来添加一个打印`Msg`字段内容的方法：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have just added some functionality to both types without altering their contents!
    That's the power of the Visitor design pattern.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚向这两种类型添加了一些功能，而没有改变它们的内容！这就是访问者设计模式的力量。
