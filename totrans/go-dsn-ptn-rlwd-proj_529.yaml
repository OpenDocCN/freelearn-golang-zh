- en: Implementation of Visitor pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start completing the implementation of the `VisitA(*MessageA)` and
    `VisitB(*MessageB)` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Its functionality is quite straightforward--the `fmt.Sprintf` method returns
    a formatted string with the actual contents of `m.Msg`, a white space, and the
    message, `Visited`. This string will be stored on the `Msg` field, overriding
    the previous contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will develop the `Accept` method for each message type that must execute
    the corresponding Visitor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This small code has some implications on it. In both cases, we are using a
    `Visitor`, which in our example is exactly the same as the `MessageVisitor` interface,
    but they could be completely different. The key is to understand that the Visitor
    pattern executes an algorithm in its `Visit` method that deals with the `Visitable`
    object. What could the `Visitor` be doing? In this example, it alters the `Visitable`
    object, but it could be simply fetching information from it. For example, we could
    have a `Person` type with lots of fields: name, surname, age, address, city, postal
    code, and so on. We could write a Visitor to fetch just the name and surname from
    a person as a unique string, a visitor to fetch the address info for a different
    section of an app, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there is the `Print()` method, which will help us to test the types.
    We mentioned before that it must print to the `Stdout` call by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It first checks the content of the `Output` field to assign the output of the `os.Stdout` call
    in case it is null. In our tests, we are storing a pointer there to our `TestHelper`
    type so this line is never executed in our test. Finally, each message type prints
    to the `Output` field, the full message stored in the `Msg` field. This is done
    by using the `Fprintf` method, which takes an `io.Writer` package as the first
    argument and the text to format as the next arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our implementation is now complete and we can run the tests again to see if
    they all pass now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything is OK! The Visitor pattern has done its job flawlessly and the message
    contents were altered after calling their `Visit` methods. The very important
    thing here is that we can add more functionality to both the structs, `MessageA`
    and `MessageB`, without altering their types. We can just create a new Visitor
    type that does everything on the `Visitable`, for example, we can create a `Visitor`
    to add a method that prints the contents of the `Msg` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have just added some functionality to both types without altering their contents!
    That's the power of the Visitor design pattern.
  prefs: []
  type: TYPE_NORMAL
