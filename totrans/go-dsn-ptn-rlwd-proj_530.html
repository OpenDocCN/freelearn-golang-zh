<html><head></head><body>
<div class="book" title="Chapter&#xA0;7.&#xA0;Behavioral Patterns - Visitor, State, Mediator, and Observer Design Patterns">
<div class="book" title="Visitor design pattern">
<div class="book" title="Another example"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_8"><a id="ch07lvl2sec0174" class="calibre1"/>Another example</h2></div></div></div><p class="calibre10">We will develop a second example, this one a bit more complex. In this case, we will emulate an online shop with a few products. The products will have plain types, with just fields and we will make a couple of visitors to deal with them in the group.</p><p class="calibre10">First of all, we will develop the interfaces. The <code class="email">ProductInfoRetriever</code> type has a method to get the price and the name of the product. The <code class="email">Visitor</code> interface, like before, has a <code class="email">Visit</code> method that accepts the <code class="email">ProductInfoRetriever</code> type. Finally, <code class="email">Visitable</code> interface is exactly the same; it has an <code class="email">Accept</code> method that takes a <code class="email">Visitor</code> type as an argument:</p><pre class="programlisting">type ProductInfoRetriever interface { 
  GetPrice() float32 
  GetName() string 
} 
 
type Visitor interface { 
  Visit(ProductInfoRetriever) 
} 
 
type Visitable interface { 
  Accept(Visitor) 
} 
</pre><p class="calibre10">All the products of the online shop must implement the <code class="email">ProductInfoRetriever</code> type. Also, most products will have some commons fields, such as name or price (the ones defined in the <code class="email">ProductInfoRetriever</code> interface). We created the <code class="email">Product</code> type, implemented the <code class="email">ProductInfoRetriever</code> and the <code class="email">Visitable</code> interfaces, and embedded it on each product:</p><pre class="programlisting">type Product struct { 
  Price float32 
  Name  string 
} 
 
func (p *Product) GetPrice() float32 { 
  return p.Price 
} 
 
func (p *Product) Accept(v Visitor) { 
  v.Visit(p) 
} 
 
func (p *Product) GetName() string { 
  return p.Name 
} 
</pre><p class="calibre10">Now we have a very generic <code class="email">Product</code> type that can store the information about almost any product of the shop. For example, we could have a <code class="email">Rice</code> and a <code class="email">Pasta</code> product:</p><pre class="programlisting">type Rice struct { 
  Product 
} 
 
type Pasta struct { 
  Product 
} 
</pre><p class="calibre10">Each has the <code class="email">Product</code> type embedded. Now we need to create a couple of <code class="email">Visitors</code> interfaces, one that sums the price of all products and one that prints the name of each product:</p><pre class="programlisting">type PriceVisitor struct { 
  Sum float32 
} 
 
func (pv *PriceVisitor) Visit(p ProductInfoRetriever) { 
  pv.Sum += p.GetPrice() 
} 
 
type NamePrinter struct { 
  ProductList string 
} 
 
func (n *NamePrinter) Visit(p ProductInfoRetriever) { 
  n.Names = fmt.Sprintf("%s\n%s", p.GetName(), n.ProductList) 
} 
</pre><p class="calibre10">The <code class="email">PriceVisitor</code> struct takes the value of the <code class="email">Price</code> variable of the <code class="email">ProductInfoRetriever</code> type, passed as an argument, and adds it to the <code class="email">Sum</code> field. The <code class="email">NamePrinter</code> struct stores the name of the <code class="email">ProductInfoRetriever</code> type, passed as an argument, and appends it to a new line on the <code class="email">ProductList</code> field.</p><p class="calibre10">Time for the <code class="email">main</code> function:</p><pre class="programlisting">func main() { 
  products := make([]Visitable, 2) 
  products[0] = &amp;Rice{ 
    Product: Product{ 
      Price: 32.0, 
      Name:  "Some rice", 
    }, 
  } 
  products[1] = &amp;Pasta{ 
    Product: Product{ 
      Price: 40.0, 
      Name:  "Some pasta", 
    }, 
  } 
 
  //Print the sum of prices 
  priceVisitor := &amp;PriceVisitor{} 
 
  for _, p := range products { 
    p.Accept(priceVisitor) 
  } 
 
  fmt.Printf("Total: %f\n", priceVisitor.Sum) 
 
  //Print the products list 
  nameVisitor := &amp;NamePrinter{} 
 
  for _, p := range products { 
    p.Accept(nameVisitor) 
  } 
 
  fmt.Printf("\nProduct list:\n-------------\n%s",  nameVisitor.ProductList) 
} 
</pre><p class="calibre10">We create a slice of two <code class="email">Visitable</code> objects: a <code class="email">Rice</code> and a <code class="email">Pasta</code> type with some arbitrary names. Then we iterate for each of them using a <code class="email">PriceVisitor</code> instance as an argument. We print the total price after the range for. Finally, we repeat this operation with the <code class="email">NamePrinter</code> and print the resulting <code class="email">ProductList</code>. The output of this <code class="email">main</code> function is as follows:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go run visitor.go</strong></span>
<span class="strong"><strong class="calibre2">Total: 72.000000</strong></span>
<span class="strong"><strong class="calibre2">Product list:</strong></span>
<span class="strong"><strong class="calibre2">-------------</strong></span>
<span class="strong"><strong class="calibre2">Some pasta</strong></span>
<span class="strong"><strong class="calibre2">Some rice</strong></span>
</pre><p class="calibre10">Ok, this is a nice example of the Visitor pattern but... what if there are special considerations about a product? For example, what if we need to sum 20 to the total price of a fridge type? OK, let's write the <code class="email">Fridge</code> structure:</p><pre class="programlisting">type Fridge struct { 
  Product 
} 
</pre><p class="calibre10">The idea here is to just override the <code class="email">GetPrice()</code> method to return the product's price plus 20:</p><pre class="programlisting">type Fridge struct { 
  Product 
} 
 
func (f *Fridge) GetPrice() float32 { 
  return f.Product.Price + 20 
} 
</pre><p class="calibre10">Unfortunately, this isn't enough for our example. The <code class="email">Fridge</code> structure is not of a  <code class="email">Visitable</code> type. The <code class="email">Product</code> struct is of a <code class="email">Visitable</code> type and the <code class="email">Fridge</code> struct has a <code class="email">Product</code> struct embedded but, as we mentioned in earlier chapters, a type that embeds a second type cannot be considered of that latter type, even when it has all its fields and methods. The solution is to also implement the <code class="email">Accept(Visitor)</code> method so that it can be considered as a <code class="email">Visitable</code>:</p><pre class="programlisting">type Fridge struct { 
  Product 
} 
 
func (f *Fridge) GetPrice() float32 { 
  return f.Product.Price + 20 
} 
 
func (f *Fridge) Accept(v Visitor) { 
  v.Visit(f) 
} 
</pre><p class="calibre10">Let's rewrite the <code class="email">main</code> function  to add this new <code class="email">Fridge</code> product to the slice:</p><pre class="programlisting">func main() { 
  products := make([]Visitable, 3) 
  products[0] = &amp;Rice{ 
    Product: Product{ 
      Price: 32.0, 
      Name:  "Some rice", 
    }, 
  } 
  products[1] = &amp;Pasta{ 
    Product: Product{ 
      Price: 40.0, 
      Name:  "Some pasta", 
    }, 
  } 
  products[2] = &amp;Fridge{ 
    Product: Product{ 
      Price: 50, 
      Name:  "A fridge", 
    }, 
  } 
  ... 
} 
</pre><p class="calibre10">Everything else continues the same. Running this new <code class="email">main</code> function produces the following output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run visitor.go</strong></span>
<span class="strong"><strong class="calibre2">Total: 142.000000</strong></span>
<span class="strong"><strong class="calibre2">Product list:</strong></span>
<span class="strong"><strong class="calibre2">-------------</strong></span>
<span class="strong"><strong class="calibre2">A fridge</strong></span>
<span class="strong"><strong class="calibre2">Some pasta</strong></span>
<span class="strong"><strong class="calibre2">Some rice</strong></span>
</pre><p class="calibre10">As expected, the total price is higher now, outputting the sum of the rice (32), the pasta (40), and the fridge (50 of the product plus 20 of the transport, so 70). We could be adding visitors forever to this products, but the idea is clear--we decoupled some algorithms outside of the types to the visitors.</p></div></div></div></body></html>