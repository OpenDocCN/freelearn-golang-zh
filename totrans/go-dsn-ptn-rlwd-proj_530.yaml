- en: Another example
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will develop a second example, this one a bit more complex. In this case,
    we will emulate an online shop with a few products. The products will have plain
    types, with just fields and we will make a couple of visitors to deal with them
    in the group.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will develop the interfaces. The `ProductInfoRetriever` type
    has a method to get the price and the name of the product. The `Visitor` interface,
    like before, has a `Visit` method that accepts the `ProductInfoRetriever` type.
    Finally, `Visitable` interface is exactly the same; it has an `Accept` method
    that takes a `Visitor` type as an argument:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All the products of the online shop must implement the `ProductInfoRetriever`
    type. Also, most products will have some commons fields, such as name or price
    (the ones defined in the `ProductInfoRetriever` interface). We created the `Product`
    type, implemented the `ProductInfoRetriever` and the `Visitable` interfaces, and
    embedded it on each product:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we have a very generic `Product` type that can store the information about
    almost any product of the shop. For example, we could have a `Rice` and a `Pasta`
    product:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Each has the `Product` type embedded. Now we need to create a couple of `Visitors`
    interfaces, one that sums the price of all products and one that prints the name
    of each product:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `PriceVisitor` struct takes the value of the `Price` variable of the `ProductInfoRetriever`
    type, passed as an argument, and adds it to the `Sum` field. The `NamePrinter`
    struct stores the name of the `ProductInfoRetriever` type, passed as an argument,
    and appends it to a new line on the `ProductList` field.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for the `main` function:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We create a slice of two `Visitable` objects: a `Rice` and a `Pasta` type with
    some arbitrary names. Then we iterate for each of them using a `PriceVisitor`
    instance as an argument. We print the total price after the range for. Finally,
    we repeat this operation with the `NamePrinter` and print the resulting `ProductList`.
    The output of this `main` function is as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Ok, this is a nice example of the Visitor pattern but... what if there are
    special considerations about a product? For example, what if we need to sum 20
    to the total price of a fridge type? OK, let''s write the `Fridge` structure:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The idea here is to just override the `GetPrice()` method to return the product''s
    price plus 20:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Unfortunately, this isn''t enough for our example. The `Fridge` structure is
    not of a  `Visitable` type. The `Product` struct is of a `Visitable` type and
    the `Fridge` struct has a `Product` struct embedded but, as we mentioned in earlier
    chapters, a type that embeds a second type cannot be considered of that latter
    type, even when it has all its fields and methods. The solution is to also implement
    the `Accept(Visitor)` method so that it can be considered as a `Visitable`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s rewrite the `main` function  to add this new `Fridge` product to the
    slice:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Everything else continues the same. Running this new `main` function produces
    the following output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一切照旧。运行这个新的`main`函数会产生以下输出：
- en: '[PRE10]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As expected, the total price is higher now, outputting the sum of the rice (32),
    the pasta (40), and the fridge (50 of the product plus 20 of the transport, so
    70). We could be adding visitors forever to this products, but the idea is clear--we
    decoupled some algorithms outside of the types to the visitors.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，现在的总价更高了，这是大米（32）、意面（40）和冰箱（该产品的50加上运输的20，所以总共70）。我们可以永远向这些产品添加访客，但理念是清晰的——我们将一些算法从类型中解耦到了访客。
