- en: Another example
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另一个例子
- en: We will develop a second example, this one a bit more complex. In this case,
    we will emulate an online shop with a few products. The products will have plain
    types, with just fields and we will make a couple of visitors to deal with them
    in the group.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发第二个例子，这个例子稍微复杂一些。在这种情况下，我们将模拟一个带有几个产品的在线商店。产品将具有普通类型，只有字段，我们将制作几个访客来处理它们。
- en: 'First of all, we will develop the interfaces. The `ProductInfoRetriever` type
    has a method to get the price and the name of the product. The `Visitor` interface,
    like before, has a `Visit` method that accepts the `ProductInfoRetriever` type.
    Finally, `Visitable` interface is exactly the same; it has an `Accept` method
    that takes a `Visitor` type as an argument:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将开发接口。`ProductInfoRetriever`类型有一个获取产品价格和名称的方法。`Visitor`接口，就像之前一样，有一个接受`ProductInfoRetriever`类型的`Visit`方法。最后，`Visitable`接口完全相同；它有一个接受`Visitor`类型作为参数的`Accept`方法：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'All the products of the online shop must implement the `ProductInfoRetriever`
    type. Also, most products will have some commons fields, such as name or price
    (the ones defined in the `ProductInfoRetriever` interface). We created the `Product`
    type, implemented the `ProductInfoRetriever` and the `Visitable` interfaces, and
    embedded it on each product:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在线商店的所有产品都必须实现`ProductInfoRetriever`类型。此外，大多数产品将有一些公共字段，例如名称或价格（在`ProductInfoRetriever`接口中定义的）。我们创建了`Product`类型，实现了`ProductInfoRetriever`和`Visitable`接口，并将其嵌入到每个产品中：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we have a very generic `Product` type that can store the information about
    almost any product of the shop. For example, we could have a `Rice` and a `Pasta`
    product:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个非常通用的`Product`类型，可以存储商店几乎任何产品的信息。例如，我们可能有一个`Rice`和`Pasta`产品：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Each has the `Product` type embedded. Now we need to create a couple of `Visitors`
    interfaces, one that sums the price of all products and one that prints the name
    of each product:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每个都嵌入了`Product`类型。现在我们需要创建几个`Visitors`接口，一个用于计算所有产品的价格总和，另一个用于打印每个产品的名称：
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `PriceVisitor` struct takes the value of the `Price` variable of the `ProductInfoRetriever`
    type, passed as an argument, and adds it to the `Sum` field. The `NamePrinter`
    struct stores the name of the `ProductInfoRetriever` type, passed as an argument,
    and appends it to a new line on the `ProductList` field.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`PriceVisitor`结构体接受作为参数传递的`ProductInfoRetriever`类型的`Price`变量的值，并将其添加到`Sum`字段。`NamePrinter`结构体存储作为参数传递的`ProductInfoRetriever`类型的名称，并将其追加到`ProductList`字段的下一行。'
- en: 'Time for the `main` function:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候编写`main`函数了：
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We create a slice of two `Visitable` objects: a `Rice` and a `Pasta` type with
    some arbitrary names. Then we iterate for each of them using a `PriceVisitor`
    instance as an argument. We print the total price after the range for. Finally,
    we repeat this operation with the `NamePrinter` and print the resulting `ProductList`.
    The output of this `main` function is as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含两个`Visitable`对象的切片：一个`Rice`和一个`Pasta`类型，具有一些任意的名称。然后我们使用`PriceVisitor`实例作为参数，遍历它们中的每一个。在for循环结束后，我们打印出总价格。最后，我们使用`NamePrinter`重复此操作并打印出结果`ProductList`。这个`main`函数的输出如下：
- en: '[PRE5]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Ok, this is a nice example of the Visitor pattern but... what if there are
    special considerations about a product? For example, what if we need to sum 20
    to the total price of a fridge type? OK, let''s write the `Fridge` structure:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是一个很好的Visitor模式的例子，但是...如果对某个产品有特殊考虑怎么办？例如，如果我们需要将20加到冰箱类型的总价格上怎么办？好的，让我们编写`Fridge`结构：
- en: '[PRE6]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The idea here is to just override the `GetPrice()` method to return the product''s
    price plus 20:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是只是重写`GetPrice()`方法，使其返回产品的价格加上20：
- en: '[PRE7]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Unfortunately, this isn''t enough for our example. The `Fridge` structure is
    not of a  `Visitable` type. The `Product` struct is of a `Visitable` type and
    the `Fridge` struct has a `Product` struct embedded but, as we mentioned in earlier
    chapters, a type that embeds a second type cannot be considered of that latter
    type, even when it has all its fields and methods. The solution is to also implement
    the `Accept(Visitor)` method so that it can be considered as a `Visitable`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这对我们的例子还不够。`Fridge`结构不是`Visitable`类型。`Product`结构是`Visitable`类型，`Fridge`结构体嵌入了一个`Product`结构体，但正如我们在前面的章节中提到的，嵌入第二个类型的类型不能被认为是后者类型，即使它具有所有字段和方法。解决方案是实现`Accept(Visitor)`方法，使其可以被认为是`Visitable`：
- en: '[PRE8]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s rewrite the `main` function  to add this new `Fridge` product to the
    slice:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写`main`函数，添加这个新的`Fridge`产品到切片中：
- en: '[PRE9]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Everything else continues the same. Running this new `main` function produces
    the following output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一切照旧。运行这个新的`main`函数会产生以下输出：
- en: '[PRE10]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As expected, the total price is higher now, outputting the sum of the rice (32),
    the pasta (40), and the fridge (50 of the product plus 20 of the transport, so
    70). We could be adding visitors forever to this products, but the idea is clear--we
    decoupled some algorithms outside of the types to the visitors.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，现在的总价更高了，这是大米（32）、意面（40）和冰箱（该产品的50加上运输的20，所以总共70）。我们可以永远向这些产品添加访客，但理念是清晰的——我们将一些算法从类型中解耦到了访客。
