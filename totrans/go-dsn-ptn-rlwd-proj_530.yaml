- en: Another example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will develop a second example, this one a bit more complex. In this case,
    we will emulate an online shop with a few products. The products will have plain
    types, with just fields and we will make a couple of visitors to deal with them
    in the group.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we will develop the interfaces. The `ProductInfoRetriever` type
    has a method to get the price and the name of the product. The `Visitor` interface,
    like before, has a `Visit` method that accepts the `ProductInfoRetriever` type.
    Finally, `Visitable` interface is exactly the same; it has an `Accept` method
    that takes a `Visitor` type as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'All the products of the online shop must implement the `ProductInfoRetriever`
    type. Also, most products will have some commons fields, such as name or price
    (the ones defined in the `ProductInfoRetriever` interface). We created the `Product`
    type, implemented the `ProductInfoRetriever` and the `Visitable` interfaces, and
    embedded it on each product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a very generic `Product` type that can store the information about
    almost any product of the shop. For example, we could have a `Rice` and a `Pasta`
    product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Each has the `Product` type embedded. Now we need to create a couple of `Visitors`
    interfaces, one that sums the price of all products and one that prints the name
    of each product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `PriceVisitor` struct takes the value of the `Price` variable of the `ProductInfoRetriever`
    type, passed as an argument, and adds it to the `Sum` field. The `NamePrinter`
    struct stores the name of the `ProductInfoRetriever` type, passed as an argument,
    and appends it to a new line on the `ProductList` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a slice of two `Visitable` objects: a `Rice` and a `Pasta` type with
    some arbitrary names. Then we iterate for each of them using a `PriceVisitor`
    instance as an argument. We print the total price after the range for. Finally,
    we repeat this operation with the `NamePrinter` and print the resulting `ProductList`.
    The output of this `main` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Ok, this is a nice example of the Visitor pattern but... what if there are
    special considerations about a product? For example, what if we need to sum 20
    to the total price of a fridge type? OK, let''s write the `Fridge` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea here is to just override the `GetPrice()` method to return the product''s
    price plus 20:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this isn''t enough for our example. The `Fridge` structure is
    not of a  `Visitable` type. The `Product` struct is of a `Visitable` type and
    the `Fridge` struct has a `Product` struct embedded but, as we mentioned in earlier
    chapters, a type that embeds a second type cannot be considered of that latter
    type, even when it has all its fields and methods. The solution is to also implement
    the `Accept(Visitor)` method so that it can be considered as a `Visitable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rewrite the `main` function  to add this new `Fridge` product to the
    slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything else continues the same. Running this new `main` function produces
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the total price is higher now, outputting the sum of the rice (32),
    the pasta (40), and the fridge (50 of the product plus 20 of the transport, so
    70). We could be adding visitors forever to this products, but the idea is clear--we
    decoupled some algorithms outside of the types to the visitors.
  prefs: []
  type: TYPE_NORMAL
