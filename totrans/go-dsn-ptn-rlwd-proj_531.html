<html><head></head><body>
<div class="book" title="Chapter&#xA0;7.&#xA0;Behavioral Patterns - Visitor, State, Mediator, and Observer Design Patterns">
<div class="book" title="Visitor design pattern">
<div class="book" title="Visitors to the rescue!"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_9"><a id="ch07lvl2sec0175" class="calibre1"/>Visitors to the rescue!</h2></div></div></div><p class="calibre10">We have seen a powerful abstraction to add new algorithms to some types. However, because of the lack of overloading in Go, this pattern could be limiting in some aspects (we have seen it in the first example, where we had to create the <code class="email">VisitA</code> and <code class="email">VisitB</code> implementations). In the second example, we haven't dealt with this limitation because we have used an interface to the <code class="email">Visit</code> method of the <code class="email">Visitor</code> struct, but we just used one type of visitor (<code class="email">ProductInfoRetriever</code>) and we would have the same problem if we implemented a <code class="email">Visit</code> method for a second type, which is one of the objectives of the original <span class="strong"><em class="calibre11">Gang of Four</em></span> design patterns.</p></div></div></div></body></html>