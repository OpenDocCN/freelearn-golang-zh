<html><head></head><body>
<div class="book" title="State design pattern">
<div class="book" title="Implementation of State pattern"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch07lvl2sec0180" class="calibre1"/>Implementation of State pattern</h2></div></div></div><p class="calibre10">The idea of unit tests is quite straightforward in a State pattern so we will spend more time explaining in detail the mechanism to use it, which is a bit more complex than usual.</p><p class="calibre10">First of all, we need the interface to represent the different states and a game context to store the information between states. For this game, the context needs to store the number of retries, if the user has won or not, the secret number to guess, and the current state. The state will have an <code class="email">executeState</code> method that accepts one of these contexts and returns <code class="email">true</code> if the game has finished, or <code class="email">false</code> if not:</p><pre class="programlisting">type GameState interface { 
  executeState(*GameContext) bool 
} 
 
type GameContext struct { 
  SecretNumber int 
  Retries int 
  Won bool 
  Next GameState 
} 
</pre><p class="calibre10">As described in <span class="strong"><em class="calibre11">acceptance criteria 1</em></span>, the player must be able to introduce the number of retries they want. This will be achieved by a state called <code class="email">StartState</code>. Also, the <code class="email">StartState</code> struct must prepare the game, setting the context to its initial value before the player:</p><pre class="programlisting">type StartState struct{} 
func(s *StartState) executeState(c *GameContext) bool { 
  c.Next = &amp;AskState{} 
 
  rand.Seed(time.Now().UnixNano()) 
  c.SecretNumber = rand.Intn(10) 
 
  fmt.Println("Introduce a number a number of retries to set the difficulty:") 
  fmt.Fscanf(os.Stdin, "%d\n", &amp;c.Retries) 
 
  return true 
} 
</pre><p class="calibre10">First of all, the <code class="email">StartState</code> struct implements the <code class="email">GameState</code> structure because it has the <code class="email">executeState(*Context)</code> method of Boolean type on its structure. At the beginning of this state, it sets the only state possible after executing this one--the <code class="email">AskState</code> state. The <code class="email">AskState</code> struct is not declared yet, but it will be the state where we ask the player for a number to guess.</p><p class="calibre10">In the next two lines, we use the <code class="email">Rand</code> package of Go to generate a random number. In the first line, we feed the random generator with the <code class="email">int64</code> type number returned by the current moment, so we ensure a random feed in each execution (if you put a constant number here, the randomizer will also generate the same number too). The <code class="email">rand.Intn(int)</code> method returns an integer number between zero and the specified number, so here we cover <span class="strong"><em class="calibre11">acceptance criteria 2</em></span>.</p><p class="calibre10">Next, a message asking for a number of retries to set precedes the <code class="email">fmt.Fscanf</code> method, a powerful function where you can pass it an <code class="email">io.Reader</code> (the standard input of the console), a format (number), and an interface to store the contents of the reader, in this case, the <code class="email">Retries</code> field of the context.</p><p class="calibre10">Finally, we return <code class="email">true</code> to tell the engine that the game must continue. Let's see the <code class="email">AskState</code> struct, which we have used at the beginning of the function:</p><pre class="programlisting">type AskState struct {} 
func (a *AskState) executeState(c *GameContext) bool{ 
  fmt.Printf("Introduce a number between 0 and 10, you have %d tries left\n", c.Retries) 
 
  var n int 
  fmt.Fscanf(os.Stdin, "%d", &amp;n) 
  c.Retries = c.Retries - 1 
 
  if n == c.SecretNumber { 
    c.Won = true 
    c.Next = &amp;FinishState{} 
  } 
 
  if c.Retries == 0 { 
    c.Next = &amp;FinishState{} 
  } 
 
  return true 
} 
</pre><p class="calibre10">The <code class="email">AskState</code> structure also implements the <code class="email">GameState</code> state, as you have probably guessed already. This states starts with a message for the player, asking them to insert a new number. In the next three lines, we create a local variable to store the contents of the number that the player will introduce. We used the <code class="email">fmt.Fscanf</code> method again, as we did in <code class="email">StartState</code> struct to capture the player's input and store it in the variable <code class="email">n</code>. Then, we have one retry less in our counter, so we have to subtract one to the number of retries represented in the <code class="email">Retries</code> field.</p><p class="calibre10">Then, there are two checks: one that checks if the user has entered the correct number, in which case the context field <code class="email">Won</code> is set to <code class="email">true</code> and the next state is set to the <code class="email">FinishState</code> struct (not declared yet).</p><p class="calibre10">The second check is controlling that the number of retries has not reached zero, in which case it won't let the player ask again for a number and it will send the player to the <code class="email">FinishState</code> struct directly. After all, we have to tell the game engine again that the game must continue by returning <code class="email">true</code> in the <code class="email">executeState</code> method.</p><p class="calibre10">Finally, we define the <code class="email">FinishState</code> struct. It controls the exit status of the game, checking the contents of the <code class="email">Won</code> field in the context object:</p><pre class="programlisting">type FinishState struct{} 
func(f *FinishState) executeState(c *GameContext) bool { 
  if c.Won { 
    println("Congrats, you won") 
  }  
  else { 
    println("You lose") 
  } 
  return false 
} 
</pre><p class="calibre10">The <code class="email">TheFinishState</code> struct also implements the <code class="email">GameState</code> state by having <code class="email">executeState</code> method in its structure. The idea here is very simple--if the player has won (this field is set previously in the <code class="email">AskState</code> struct), the <code class="email">FinishState</code> structure will print the message <code class="email">Congrats, you won</code>. If the player has not won (remember that the zero value of the Boolean variable is <code class="email">false</code>), the <code class="email">FinishState</code> prints the message <code class="email">You lose.</code>
</p><p class="calibre10">In this case, the game can be considered finished, so we return <code class="email">false</code> to say that the game must not continue.</p><p class="calibre10">We just need the <code class="email">main</code> method to play our game:</p><pre class="programlisting">func main() { 
  start := StartState{} 
  game := GameContext{ 
    Next:&amp;start, 
  } 
  for game.Next.executeState(&amp;game) {} 
} 
</pre><p class="calibre10">Well, yes, it can't be simpler. The game must begin with the <code class="email">start</code> method, although it could be abstracted more outside in case that the game needs more initialization in the future, but in our case it is fine. Then, we create a context where we set the <code class="email">Next</code> state as a pointer to the <code class="email">start</code> variable. So the first state that will be executed in the game will be the <code class="email">StartState</code> state.</p><p class="calibre10">The last line of the <code class="email">main</code> function has a lot of things just there. We create a loop, without any statement inside it. As with any loop, it keeps looping after the condition is not satisfied. The condition we are using is the returned value of the <code class="email">GameStates</code> structure, <code class="email">true</code> as soon as the game is not finished.</p><p class="calibre10">So, the idea is simple: we execute the state in the context, passing a pointer to the context to it. Each state returns <code class="email">true</code> until the game has finished and the <code class="email">FinishState</code> struct will return <code class="email">false</code>. So our for loop will keep looping, waiting for a <code class="email">false</code> condition sent by the <code class="email">FinishState</code> structure to end the application.</p><p class="calibre10">Let's play once:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go run state.go</strong></span>
<span class="strong"><strong class="calibre2">Introduce a number a number of retries to set the difficulty:</strong></span>
<span class="strong"><strong class="calibre2">5</strong></span>
<span class="strong"><strong class="calibre2">Introduce a number between 0 and 10, you have 5 tries left</strong></span>
<span class="strong"><strong class="calibre2">8</strong></span>
<span class="strong"><strong class="calibre2">Introduce a number between 0 and 10, you have 4 tries left</strong></span>
<span class="strong"><strong class="calibre2">2</strong></span>
<span class="strong"><strong class="calibre2">Introduce a number between 0 and 10, you have 3 tries left</strong></span>
<span class="strong"><strong class="calibre2">1</strong></span>
<span class="strong"><strong class="calibre2">Introduce a number between 0 and 10, you have 2 tries left</strong></span>
<span class="strong"><strong class="calibre2">3</strong></span>
<span class="strong"><strong class="calibre2">Introduce a number between 0 and 10, you have 1 tries left</strong></span>
<span class="strong"><strong class="calibre2">4</strong></span>
<span class="strong"><strong class="calibre2">You lose</strong></span>
</pre><p class="calibre10">We lost! We set the number of retries to 5. Then we kept inserting numbers, trying to guess the secret number. We entered 8, 2, 1, 3, and 4, but it wasn't any of them. I don't even know what the correct number was; let's fix this!</p><p class="calibre10">Go to the definition of the <code class="email">FinishState</code> struct and change the line where it says <code class="email">You lose</code>, and replace it with the following:</p><pre class="programlisting">fmt.Printf("You lose. The correct number was: %d\n", c.SecretNumber) 
</pre><p class="calibre10">Now it will show the correct number. Let's play again:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go run state.go</strong></span>
<span class="strong"><strong class="calibre2">Introduce a number a number of retries to set the difficulty:</strong></span>
<span class="strong"><strong class="calibre2">3</strong></span>
<span class="strong"><strong class="calibre2">Introduce a number between 0 and 10, you have 3 tries left</strong></span>
<span class="strong"><strong class="calibre2">6</strong></span>
<span class="strong"><strong class="calibre2">Introduce a number between 0 and 10, you have 2 tries left</strong></span>
<span class="strong"><strong class="calibre2">2</strong></span>
<span class="strong"><strong class="calibre2">Introduce a number between 0 and 10, you have 1 tries left</strong></span>
<span class="strong"><strong class="calibre2">1</strong></span>
<span class="strong"><strong class="calibre2">You lose. The correct number was: 9</strong></span>
</pre><p class="calibre10">This time we make it a little harder by setting only three tries... and we lost again. I entered 6, 2, and 1, but the correct number was 9. Last try:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go run state.go</strong></span>
<span class="strong"><strong class="calibre2">Introduce a number a number of retries to set the difficulty:</strong></span>
<span class="strong"><strong class="calibre2">5</strong></span>
<span class="strong"><strong class="calibre2">Introduce a number between 0 and 10, you have 5 tries left</strong></span>
<span class="strong"><strong class="calibre2">3</strong></span>
<span class="strong"><strong class="calibre2">Introduce a number between 0 and 10, you have 4 tries left</strong></span>
<span class="strong"><strong class="calibre2">4</strong></span>
<span class="strong"><strong class="calibre2">Introduce a number between 0 and 10, you have 3 tries left</strong></span>
<span class="strong"><strong class="calibre2">5</strong></span>
<span class="strong"><strong class="calibre2">Introduce a number between 0 and 10, you have 2 tries left</strong></span>
<span class="strong"><strong class="calibre2">6</strong></span>
<span class="strong"><strong class="calibre2">Congrats, you won</strong></span>
</pre><p class="calibre10">Great! This time we lowered the difficulty, allowing up to five tries and we won! we even had one more try left, but we guessed the number in the fourth try after entering 3, 4, 5. The correct number was 6, which was my fourth try.</p></div></div></body></html>