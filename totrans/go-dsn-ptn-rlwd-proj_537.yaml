- en: Implementation of State pattern
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态模式的实现
- en: The idea of unit tests is quite straightforward in a State pattern so we will
    spend more time explaining in detail the mechanism to use it, which is a bit more
    complex than usual.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在状态模式中，单元测试的想法非常直接，所以我们将花更多的时间详细解释使用它的机制，这比通常要复杂一些。
- en: 'First of all, we need the interface to represent the different states and a
    game context to store the information between states. For this game, the context
    needs to store the number of retries, if the user has won or not, the secret number
    to guess, and the current state. The state will have an `executeState` method
    that accepts one of these contexts and returns `true` if the game has finished,
    or `false` if not:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个接口来表示不同的状态，以及一个游戏上下文来存储状态之间的信息。对于这个游戏，上下文需要存储尝试次数、用户是否获胜、要猜测的秘密数字以及当前状态。状态将有一个`executeState`方法，它接受这些上下文之一，如果游戏结束则返回`true`，如果没有则返回`false`：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As described in *acceptance criteria 1*, the player must be able to introduce
    the number of retries they want. This will be achieved by a state called `StartState`.
    Also, the `StartState` struct must prepare the game, setting the context to its
    initial value before the player:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如*接受标准 1*所述，玩家必须能够输入他们想要的尝试次数。这将通过一个名为`StartState`的状态来实现。此外，`StartState`结构体必须准备游戏，在玩家之前将上下文设置为初始值：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First of all, the `StartState` struct implements the `GameState` structure because
    it has the `executeState(*Context)` method of Boolean type on its structure. At
    the beginning of this state, it sets the only state possible after executing this
    one--the `AskState` state. The `AskState` struct is not declared yet, but it will
    be the state where we ask the player for a number to guess.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`StartState`结构体实现了`GameState`结构，因为它在其结构体上有一个布尔类型的`executeState(*Context)`方法。在这个状态的开始，它设置了执行此状态后唯一可能的状态——`AskState`状态。`AskState`结构体尚未声明，但它将是要求玩家输入猜测数字的状态：
- en: In the next two lines, we use the `Rand` package of Go to generate a random
    number. In the first line, we feed the random generator with the `int64` type
    number returned by the current moment, so we ensure a random feed in each execution
    (if you put a constant number here, the randomizer will also generate the same
    number too). The `rand.Intn(int)` method returns an integer number between zero
    and the specified number, so here we cover *acceptance criteria 2*.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两行中，我们使用Go的`Rand`包生成随机数。在第一行中，我们将随机生成器与当前时刻返回的`int64`类型数字一起使用，以确保每次执行时都是随机输入（如果你在这里放一个常数，随机数生成器也会生成相同的数字）。`rand.Intn(int)`方法返回一个介于零和指定数字之间的整数，因此我们涵盖了*接受标准
    2*：
- en: Next, a message asking for a number of retries to set precedes the `fmt.Fscanf`
    method, a powerful function where you can pass it an `io.Reader` (the standard
    input of the console), a format (number), and an interface to store the contents
    of the reader, in this case, the `Retries` field of the context.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，一个请求设置尝试次数的消息位于`fmt.Fscanf`方法之前，这是一个功能强大的函数，你可以向它传递一个`io.Reader`（控制台的标准输入）、一个格式（数字）和一个接口来存储读取器的内容，在这种情况下，是上下文的`Retries`字段。
- en: 'Finally, we return `true` to tell the engine that the game must continue. Let''s
    see the `AskState` struct, which we have used at the beginning of the function:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们返回`true`以告知引擎游戏必须继续。让我们看看 `AskState` 结构体，这是我们函数开始时使用的：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `AskState` structure also implements the `GameState` state, as you have
    probably guessed already. This states starts with a message for the player, asking
    them to insert a new number. In the next three lines, we create a local variable
    to store the contents of the number that the player will introduce. We used the
    `fmt.Fscanf` method again, as we did in `StartState` struct to capture the player's
    input and store it in the variable `n`. Then, we have one retry less in our counter,
    so we have to subtract one to the number of retries represented in the `Retries`
    field.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`AskState`结构体还实现了 `GameState`状态，正如你可能已经猜到的。这个状态开始时会给玩家一个消息，要求他们输入一个新的数字。在接下来的三行中，我们创建一个局部变量来存储玩家将要输入的数字的内容。我们再次使用了`fmt.Fscanf`方法，就像我们在`StartState`结构体中所做的那样，来捕获玩家的输入并将其存储在变量`n`中。然后，我们的计数器中少了一次尝试，所以我们必须从`Retries`字段表示的尝试次数中减去一次：'
- en: 'Then, there are two checks: one that checks if the user has entered the correct
    number, in which case the context field `Won` is set to `true` and the next state
    is set to the `FinishState` struct (not declared yet).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，有两个检查：一个检查用户是否输入了正确的数字，如果是这样，上下文字段`Won`将被设置为`true`，下一个状态将被设置为`FinishState`结构体（尚未声明）。
- en: The second check is controlling that the number of retries has not reached zero,
    in which case it won't let the player ask again for a number and it will send
    the player to the `FinishState` struct directly. After all, we have to tell the
    game engine again that the game must continue by returning `true` in the `executeState`
    method.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次检查是控制重试次数是否未达到零，如果是这样，它不会让玩家再次请求数字，并且会直接将玩家发送到`FinishState`结构体。毕竟，我们必须再次通过在`executeState`方法中返回`true`来告诉游戏引擎游戏必须继续。
- en: 'Finally, we define the `FinishState` struct. It controls the exit status of
    the game, checking the contents of the `Won` field in the context object:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了`FinishState`结构体。它控制着游戏的退出状态，检查上下文对象中`Won`字段的值：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `TheFinishState` struct also implements the `GameState` state by having
    `executeState` method in its structure. The idea here is very simple--if the player
    has won (this field is set previously in the `AskState` struct), the `FinishState`
    structure will print the message `Congrats, you won`. If the player has not won
    (remember that the zero value of the Boolean variable is `false`), the `FinishState`
    prints the message `You lose.`
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`TheFinishState`结构体通过在其结构体中实现`executeState`方法来实现了`GameState`状态。这里的想法非常简单——如果玩家赢了（这个字段在`AskState`结构体中之前已经设置），`FinishState`结构体会打印消息`恭喜，你赢了`。如果玩家没有赢（记住布尔变量的零值是`false`），`FinishState`会打印消息`你输了`。'
- en: In this case, the game can be considered finished, so we return `false` to say
    that the game must not continue.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，游戏可以被认为是结束了，因此我们返回`false`以表明游戏必须继续。
- en: 'We just need the `main` method to play our game:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要`main`方法来玩我们的游戏：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Well, yes, it can't be simpler. The game must begin with the `start` method,
    although it could be abstracted more outside in case that the game needs more
    initialization in the future, but in our case it is fine. Then, we create a context
    where we set the `Next` state as a pointer to the `start` variable. So the first
    state that will be executed in the game will be the `StartState` state.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，是的，这很简单。游戏必须从`start`方法开始，尽管将来如果游戏需要更多的初始化，它可以在外部进一步抽象化，但在这个案例中是合适的。然后，我们创建一个上下文，我们将`Next`状态设置为指向`start`变量的指针。因此，游戏将首先执行的是`StartState`状态。
- en: The last line of the `main` function has a lot of things just there. We create
    a loop, without any statement inside it. As with any loop, it keeps looping after
    the condition is not satisfied. The condition we are using is the returned value
    of the `GameStates` structure, `true` as soon as the game is not finished.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数的最后一行有很多东西。我们创建了一个循环，循环体内没有任何语句。与任何循环一样，当条件不满足时，它会继续循环。我们使用的是`GameStates`结构的返回值作为条件，即游戏未结束时返回`true`。'
- en: 'So, the idea is simple: we execute the state in the context, passing a pointer
    to the context to it. Each state returns `true` until the game has finished and
    the `FinishState` struct will return `false`. So our for loop will keep looping,
    waiting for a `false` condition sent by the `FinishState` structure to end the
    application.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个想法很简单：我们在上下文中执行状态，传递上下文的指针给它。每个状态都会返回`true`，直到游戏结束，`FinishState`结构体会返回`false`。所以我们的for循环会继续循环，等待`FinishState`结构体发送的`false`条件来结束应用程序。
- en: 'Let''s play once:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们玩一次：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We lost! We set the number of retries to 5\. Then we kept inserting numbers,
    trying to guess the secret number. We entered 8, 2, 1, 3, and 4, but it wasn't
    any of them. I don't even know what the correct number was; let's fix this!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们输了！我们将重试次数设置为5。然后我们继续输入数字，试图猜测秘密数字。我们输入了8、2、1、3和4，但都不是。我甚至不知道正确的数字是什么；让我们修复这个问题！
- en: 'Go to the definition of the `FinishState` struct and change the line where
    it says `You lose`, and replace it with the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 前往`FinishState`结构体的定义，并更改显示`You lose`的行，将其替换为以下内容：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now it will show the correct number. Let''s play again:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它将显示正确的数字。让我们再玩一次：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This time we make it a little harder by setting only three tries... and we
    lost again. I entered 6, 2, and 1, but the correct number was 9\. Last try:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们让它更难一些，只设置三个尝试...我们又输了。我输入了6、2和1，但正确的数字是9。最后一次尝试：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Great! This time we lowered the difficulty, allowing up to five tries and we
    won! we even had one more try left, but we guessed the number in the fourth try
    after entering 3, 4, 5\. The correct number was 6, which was my fourth try.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！这次我们降低了难度，允许最多尝试五次，并且我们成功了！我们甚至还有一次尝试的机会，但在输入了3、4、5之后，我们在第四次尝试中猜对了数字。正确的数字是6，这是我第四次尝试。
