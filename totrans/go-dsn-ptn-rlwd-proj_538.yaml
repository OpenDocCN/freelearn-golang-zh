- en: A state to win and a state to lose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Have you realized that we could have a winning and a lose state instead of
    printing the messages directly in the `FinishState` struct? This way we could,
    for example, check some hypothetical scoreboard in the win section to see if we
    have set a record. Let''s refactor our game. First we need a `WinState` and a
    `LoseState` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These two new states have nothing new. They contain the same messages that
    were previously in the `FinishState` state that, by the way, must be modified
    to use these new states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, the finish state doesn't print anything and, instead, delegates this to
    the next state in the chain--the `WinState` structure, if the user has won and
    the `LoseState` struct, if not. Remember that the game doesn't finish on the `FinishState`
    struct now, and we must return `true` instead of `false` to notify to the engine
    that it must keep executing states in the chain.
  prefs: []
  type: TYPE_NORMAL
