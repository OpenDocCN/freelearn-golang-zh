- en: A state to win and a state to lose
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个获胜状态和一个失败状态
- en: 'Have you realized that we could have a winning and a lose state instead of
    printing the messages directly in the `FinishState` struct? This way we could,
    for example, check some hypothetical scoreboard in the win section to see if we
    have set a record. Let''s refactor our game. First we need a `WinState` and a
    `LoseState` struct:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否意识到我们可以有一个获胜状态和一个失败状态，而不是直接在`FinishState`结构中打印消息？这样我们就可以，例如，检查胜利部分的一些假设的分数板，看看我们是否创下了记录。让我们重构我们的游戏。首先我们需要一个`WinState`和一个`LoseState`结构：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These two new states have nothing new. They contain the same messages that
    were previously in the `FinishState` state that, by the way, must be modified
    to use these new states:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个新状态没有新增内容。它们包含之前在`FinishState`状态中已有的相同消息，顺便提一下，必须修改以使用这些新状态：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, the finish state doesn't print anything and, instead, delegates this to
    the next state in the chain--the `WinState` structure, if the user has won and
    the `LoseState` struct, if not. Remember that the game doesn't finish on the `FinishState`
    struct now, and we must return `true` instead of `false` to notify to the engine
    that it must keep executing states in the chain.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，完成状态不打印任何内容，而是将任务委托给链中的下一个状态——如果用户获胜，则是`WinState`结构，如果没有获胜，则是`LoseState`结构。记住，现在游戏不是在`FinishState`结构中结束的，我们必须返回`true`而不是`false`来通知引擎它必须继续执行链中的状态。
