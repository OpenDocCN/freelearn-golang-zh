<html><head></head><body>
<div class="book" title="Mediator design pattern">
<div class="book" title="Implementation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch07lvl2sec0187" class="calibre1"/>Implementation</h2></div></div></div><p class="calibre10">We have to jump directly to the implementation because we cannot test that the sum will be correct (well, we can, but we will be testing if Go is correctly written!). We could test that we pass the acceptance criteria, but it's a bit of an overkill for our example.</p><p class="calibre10">So let's start by implementing the necessary types:</p><pre class="programlisting">package main 
 
type One struct{} 
type Two struct{} 
type Three struct{} 
type Four struct{} 
type Five struct{} 
type Six struct{} 
type Seven struct{} 
type Eight struct{} 
type Nine struct{} 
type Zero struct{} 
</pre><p class="calibre10">Well... this look quite awkward. We already have numeric types in Go to perform these operations, we don't need a type for each number!</p><p class="calibre10">But let's continue for a second with this insane approach. Let's implement the <code class="email">One</code> struct:</p><pre class="programlisting">type One struct{} 
 
func (o *One) OnePlus(n interface{}) interface{} { 
  switch n.(type) { 
  case One: 
    return &amp;Two{} 
  case Two: 
    return &amp;Three{} 
  case Three: 
    return &amp;Four{} 
  case Four: 
    return &amp;Five{} 
  case Five: 
    return &amp;Six{} 
  case Six: 
    return &amp;Seven{} 
  case Seven: 
    return &amp;Eight{} 
  case Eight: 
    return &amp;Nine{} 
  case Nine: 
    return [2]interface{}{&amp;One{}, &amp;Zero{}} 
  default: 
    return fmt.Errorf("Number not found") 
  } 
} 
</pre><p class="calibre10">OK , I'll stop here. What is wrong with this implementation? This is completely crazy! It's overkill to make every operation possible between numbers to make sums! Especially when we have more than one digit.</p><p class="calibre10">Well, believe it or not, this is how a lot of software is commonly designed today. A small app where an object uses two or three objects grows, and it ends up using dozens of them. It becomes an absolute hell to simply add or remove a type from the application because it is hidden in some of this craziness.</p><p class="calibre10">So what can we do in this calculator? Use a Mediator type that frees all the cases:</p><pre class="programlisting">func Sum(a, b interface{}) interface{}{ 
  switch a := a.(type) { 
    case One: 
    switch b.(type) { 
      case One: 
        return &amp;Two{} 
      case Two: 
        return &amp;Three{} 
      default: 
        return fmt.Errorf("Number not found") 
    } 
    case Two: 
    switch b.(type) { 
      case One: 
        return &amp;Three{} 
      case Two: 
        return &amp;Four{} 
      default: 
      return fmt.Errorf("Number not found") 
 
    } 
    case int: 
    switch b := b.(type) { 
      case One: 
        return &amp;Three{} 
      case Two: 
        return &amp;Four{} 
      case int: 
        return a + b 
      default: 
      return fmt.Errorf("Number not found") 
 
    } 
    default: 
    return fmt.Errorf("Number not found") 
  } 
} 
</pre><p class="calibre10">We have just developed a couple of numbers to keep things short. The <code class="email">Sum</code> function acts as a mediator between two numbers. First it checks the type of the first number named <code class="email">a</code>. Then, for each type of the first number, it checks the type of the second number named <code class="email">b</code> and returns the resulting type.</p><p class="calibre10">While the solution still looks very crazy now, the only one that knows about all possible numbers in the calculator is the <code class="email">Sum</code> function. But take a closer look and you'll see that we have added a type case for the <code class="email">int</code> type. We have cases <code class="email">One</code>, <code class="email">Two</code> , and <code class="email">int</code>. Inside the <code class="email">int</code> case, we also have another <code class="email">int</code> case for the <code class="email">b</code> number. What do we do here? If both types are of the <code class="email">int</code> case, we can return the sum of them.</p><p class="calibre10">Do you think that this will work? Let's write a simple <code class="email">main</code> function:</p><pre class="programlisting">func main(){ 
  fmt.Printf("%#v\n", Sum(One{}, Two{})) 
  fmt.Printf("%d\n", Sum(1,2)) 
} 
</pre><p class="calibre10">We print the sum of type <code class="email">One</code> and type <code class="email">Two</code>. By using the <code class="email">"%#v"</code> format, we ask to print information about the type. The second line in the function uses <code class="email">int</code> types, and we also print the result. This in the console produces the following output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$go run mediator.go</strong></span>
<span class="strong"><strong class="calibre2">&amp;main.Three{}</strong></span>
<span class="strong"><strong class="calibre2">7</strong></span>
</pre><p class="calibre10">Not very impressive, right? But let's think for a second. By using the Mediator pattern, we have been able to refactor the initial calculator, where we have to define every operation on every type to a Mediator pattern, the <code class="email">Sum</code> function.</p><p class="calibre10">The nice thing is that, thanks to the Mediator pattern, we have been able to start using integers as values for our calculator. We have just defined the simplest example by adding two integers, but we could have done the same with an integer and the <code class="email">type</code>:</p><pre class="programlisting">  case One: 
    switch b := b.(type) { 
    case One: 
      return &amp;Two{} 
    case Two: 
      return &amp;Three{} 
    case int: 
      return b+1 
    default: 
      return fmt.Errorf("Number not found") 
    } 
</pre><p class="calibre10">With this small modification, we can now use type <code class="email">One</code> with an <code class="email">int</code> as number <code class="email">b</code>. If we keep working on this Mediator pattern, we could achieve a lot of flexibility between types, without having to implement every possible operation between them, generating a tight coupling.</p><p class="calibre10">We'll add a new <code class="email">Sum</code> method in the main function to see this in action:</p><pre class="programlisting">func main(){ 
  fmt.Printf("%#v\n", Sum(One{}, Two{})) 
  fmt.Printf("%d\n", Sum(1,2)) 
<span class="strong"><strong class="calibre2">  fmt.Printf("%d\n", Sum(One{},2))</strong></span> 
} 
<span class="strong"><strong class="calibre2">$go run mediator.go&amp;main.Three{}33</strong></span>
</pre><p class="calibre10">Nice. The Mediator pattern is in charge of knowing about the possible types and returns the most convenient type for our case, which is an integer. Now we could keep growing this <code class="email">Sum</code> function until we completely get rid of using the numeric types we have defined.</p></div></div></body></html>