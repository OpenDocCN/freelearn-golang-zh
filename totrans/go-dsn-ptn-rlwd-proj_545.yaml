- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: We have to jump directly to the implementation because we cannot test that the
    sum will be correct (well, we can, but we will be testing if Go is correctly written!).
    We could test that we pass the acceptance criteria, but it's a bit of an overkill
    for our example.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须直接跳到实现，因为我们无法测试求和是否正确（嗯，我们可以，但我们将测试Go是否正确编写！）。我们可以测试是否通过了验收标准，但这对于我们这个例子来说有点过度了。
- en: 'So let''s start by implementing the necessary types:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们先实现必要的类型：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Well... this look quite awkward. We already have numeric types in Go to perform
    these operations, we don't need a type for each number!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯...这看起来相当尴尬。我们已经在Go中有了用于执行这些操作的数值类型，我们不需要为每个数字定义一个类型！
- en: 'But let''s continue for a second with this insane approach. Let''s implement
    the `One` struct:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们继续用这种疯狂的方法。让我们实现`One`结构体：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: OK , I'll stop here. What is wrong with this implementation? This is completely
    crazy! It's overkill to make every operation possible between numbers to make
    sums! Especially when we have more than one digit.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我就说到这里。这个实现有什么问题？这完全疯狂！为了使数字之间可能的每个操作都进行求和，这是过度设计！尤其是当我们有多个数字时。
- en: Well, believe it or not, this is how a lot of software is commonly designed
    today. A small app where an object uses two or three objects grows, and it ends
    up using dozens of them. It becomes an absolute hell to simply add or remove a
    type from the application because it is hidden in some of this craziness.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，信不信由你，这就是今天许多软件通常的设计方式。一个小应用，其中对象使用两个或三个对象，最终会使用几十个对象。简单地添加或删除应用程序中的类型变得绝对痛苦，因为它们隐藏在这些疯狂之中。
- en: 'So what can we do in this calculator? Use a Mediator type that frees all the
    cases:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在这个计算器中我们能做什么呢？使用一个中介类型来释放所有情况：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have just developed a couple of numbers to keep things short. The `Sum` function
    acts as a mediator between two numbers. First it checks the type of the first
    number named `a`. Then, for each type of the first number, it checks the type
    of the second number named `b` and returns the resulting type.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是开发了一些数字来简化事情。`Sum`函数作为两个数字之间的中介。首先，它检查第一个数字（命名为`a`）的类型。然后，对于第一个数字的每种类型，它检查第二个数字（命名为`b`）的类型，并返回结果类型。
- en: While the solution still looks very crazy now, the only one that knows about
    all possible numbers in the calculator is the `Sum` function. But take a closer
    look and you'll see that we have added a type case for the `int` type. We have
    cases `One`, `Two` , and `int`. Inside the `int` case, we also have another `int` case
    for the `b` number. What do we do here? If both types are of the `int` case, we
    can return the sum of them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然现在的解决方案看起来仍然非常疯狂，但唯一知道计算器中所有可能数字的是`Sum`函数。但仔细看看，你会发现我们为`int`类型添加了一个类型情况。我们有`One`、`Two`和`int`的情况。在`int`情况内部，我们还有一个`int`情况用于`b`数字。我们在这里做什么呢？如果两种类型都是`int`情况，我们可以返回它们的和。
- en: 'Do you think that this will work? Let''s write a simple `main` function:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为这会工作吗？让我们写一个简单的`main`函数：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We print the sum of type `One` and type `Two`. By using the `"%#v"` format,
    we ask to print information about the type. The second line in the function uses
    `int` types, and we also print the result. This in the console produces the following
    output:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打印了`One`类型和`Two`类型的和。通过使用`"%#v"`格式，我们要求打印有关类型的信息。函数中的第二行使用了`int`类型，我们也打印了结果。这在控制台产生了以下输出：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Not very impressive, right? But let's think for a second. By using the Mediator
    pattern, we have been able to refactor the initial calculator, where we have to
    define every operation on every type to a Mediator pattern, the `Sum` function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是很令人印象深刻，对吧？但让我们思考一下。通过使用中介者模式，我们已经能够重构最初的计算器，其中我们必须为每种类型定义每个操作，变成了中介者模式，即`Sum`函数。
- en: 'The nice thing is that, thanks to the Mediator pattern, we have been able to
    start using integers as values for our calculator. We have just defined the simplest
    example by adding two integers, but we could have done the same with an integer
    and the `type`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 好事是，多亏了中介者模式，我们能够开始使用整数作为计算器的值。我们只是通过添加两个整数定义了最简单的例子，但我们可以用整数和`type`做同样的事情：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With this small modification, we can now use type `One` with an `int` as number
    `b`. If we keep working on this Mediator pattern, we could achieve a lot of flexibility
    between types, without having to implement every possible operation between them,
    generating a tight coupling.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个小的修改，我们现在可以使用`One`类型和`int`作为数字`b`。如果我们继续在这个中介者模式上工作，我们可以实现类型之间的大量灵活性，而无需实现它们之间所有可能的操作，从而生成紧密耦合。
- en: 'We''ll add a new `Sum` method in the main function to see this in action:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在主函数中添加一个新的`Sum`方法，以查看其作用：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Nice. The Mediator pattern is in charge of knowing about the possible types
    and returns the most convenient type for our case, which is an integer. Now we
    could keep growing this `Sum` function until we completely get rid of using the
    numeric types we have defined.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 很好。中介者模式负责了解可能的数据类型，并返回对我们案例最方便的类型，即整数。现在我们可以继续扩展这个`Sum`函数，直到我们完全摆脱使用我们已定义的数值类型。
