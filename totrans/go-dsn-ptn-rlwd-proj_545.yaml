- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have to jump directly to the implementation because we cannot test that the
    sum will be correct (well, we can, but we will be testing if Go is correctly written!).
    We could test that we pass the acceptance criteria, but it's a bit of an overkill
    for our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s start by implementing the necessary types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Well... this look quite awkward. We already have numeric types in Go to perform
    these operations, we don't need a type for each number!
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s continue for a second with this insane approach. Let''s implement
    the `One` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: OK , I'll stop here. What is wrong with this implementation? This is completely
    crazy! It's overkill to make every operation possible between numbers to make
    sums! Especially when we have more than one digit.
  prefs: []
  type: TYPE_NORMAL
- en: Well, believe it or not, this is how a lot of software is commonly designed
    today. A small app where an object uses two or three objects grows, and it ends
    up using dozens of them. It becomes an absolute hell to simply add or remove a
    type from the application because it is hidden in some of this craziness.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what can we do in this calculator? Use a Mediator type that frees all the
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have just developed a couple of numbers to keep things short. The `Sum` function
    acts as a mediator between two numbers. First it checks the type of the first
    number named `a`. Then, for each type of the first number, it checks the type
    of the second number named `b` and returns the resulting type.
  prefs: []
  type: TYPE_NORMAL
- en: While the solution still looks very crazy now, the only one that knows about
    all possible numbers in the calculator is the `Sum` function. But take a closer
    look and you'll see that we have added a type case for the `int` type. We have
    cases `One`, `Two` , and `int`. Inside the `int` case, we also have another `int` case
    for the `b` number. What do we do here? If both types are of the `int` case, we
    can return the sum of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you think that this will work? Let''s write a simple `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We print the sum of type `One` and type `Two`. By using the `"%#v"` format,
    we ask to print information about the type. The second line in the function uses
    `int` types, and we also print the result. This in the console produces the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Not very impressive, right? But let's think for a second. By using the Mediator
    pattern, we have been able to refactor the initial calculator, where we have to
    define every operation on every type to a Mediator pattern, the `Sum` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nice thing is that, thanks to the Mediator pattern, we have been able to
    start using integers as values for our calculator. We have just defined the simplest
    example by adding two integers, but we could have done the same with an integer
    and the `type`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With this small modification, we can now use type `One` with an `int` as number
    `b`. If we keep working on this Mediator pattern, we could achieve a lot of flexibility
    between types, without having to implement every possible operation between them,
    generating a tight coupling.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add a new `Sum` method in the main function to see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Nice. The Mediator pattern is in charge of knowing about the possible types
    and returns the most convenient type for our case, which is an integer. Now we
    could keep growing this `Sum` function until we completely get rid of using the
    numeric types we have defined.
  prefs: []
  type: TYPE_NORMAL
