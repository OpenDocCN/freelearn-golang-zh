<html><head></head><body>
<div class="book" title="Observer design pattern">
<div class="book" title="Unit tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch07lvl2sec0193" class="calibre1"/>Unit tests</h2></div></div></div><p class="calibre10">Maybe you have realized that our requirements defined almost exclusively the <code class="email">Publisher</code> type. This is because the action performed by the observer is irrelevant for the Observer pattern. It should simply execute an action, in this case the <code class="email">Notify</code> method, that one or many types will implement. So let's define this only interface for this pattern:</p><pre class="programlisting">type Observer interface { 
  Notify(string) 
} 
</pre><p class="calibre10">The <code class="email">Observer</code> interface has a <code class="email">Notify</code> method that accepts a <code class="email">string</code> type that will contain the message to spread. It does not need to return anything, but we could return an error if we want to check if all observers have been reached when calling the <code class="email">publish</code> method of the <code class="email">Publisher</code> structure.</p><p class="calibre10">To test all the acceptance criteria, we just need a structure called <code class="email">Publisher</code> with three methods:</p><pre class="programlisting">type Publisher struct { 
  ObserversList []Observer 
} 
 
func (s *Publisher) AddObserver(o Observer) {} 
 
func (s *Publisher) RemoveObserver(o Observer) {} 
 
func (s *Publisher) NotifyObservers(m string) {} 
</pre><p class="calibre10">The <code class="email">Publisher</code> structure stores the list of subscribed observers in a slice field called <code class="email">ObserversList</code>. Then it has the three methods mentioned on the acceptance criteria-the <code class="email">AddObserver</code> method to subscribe a new observer to the publisher, the <code class="email">RemoveObserver</code> method to unsubscribe an observer, and the <code class="email">NotifyObservers</code> method with a string that acts as the message we want to spread between all observers.</p><p class="calibre10">With these three methods, we have to set up a root test to configure the <code class="email">Publisher</code> and three subtests to test each method. We also need to define a test type structure that implements the <code class="email">Observer</code> interface. This structure is going to be called <code class="email">TestObserver</code>:</p><pre class="programlisting">type TestObserver struct { 
  ID      int 
  Message string 
} 
func (p *TestObserver) Notify(m string) { 
  fmt.Printf("Observer %d: message '%s' received \n", p.ID, m) 
  p.Message = m 
} 
</pre><p class="calibre10">The <code class="email">TestObserver</code> structure implements the Observer pattern by defining a <code class="email">Notify(string)</code> method in its structure. In this case, it prints the received message together with its own observer ID. Then, it stores the message in its <code class="email">Message</code> field. This allows us to check later if the content of the <code class="email">Message</code> field is as expected. Remember that it could also be done by passing the <code class="email">testing.T</code> pointer and the expected message and checking within the <code class="email">TestObserver</code> structure.</p><p class="calibre10">Now we can set up the <code class="email">Publisher</code> structure to execute the three tests. We will create three instances of the <code class="email">TestObserver</code> structure:</p><pre class="programlisting">func TestSubject(t *testing.T) { 
  testObserver1 := &amp;TestObserver{1, ""} 
  testObserver2 := &amp;TestObserver{2, ""} 
  testObserver3 := &amp;TestObserver{3, ""} 
  publisher := Publisher{} 
</pre><p class="calibre10">We have given a different ID to each observer so that we can see later that each of them has printed the expected message. Then, we have added the observers by calling the <code class="email">AddObserver</code> method on the <code class="email">Publisher</code> structure.</p><p class="calibre10">Let's write an <code class="email">AddObserver</code> test, it must add a new observer to the <code class="email">ObserversList</code> field of the <code class="email">Publisher</code> structure:</p><pre class="programlisting">  t.Run("AddObserver", func(t *testing.T) { 
    publisher.AddObserver(testObserver1) 
    publisher.AddObserver(testObserver2) 
    publisher.AddObserver(testObserver3) 
 
    if len(publisher.ObserversList) != 3 { 
      t.Fail() 
    } 
  }) 
</pre><p class="calibre10">We have added three observers to the <code class="email">Publisher</code> structure, so the length of the slice must be 3. If it's not 3, the test will fail.</p><p class="calibre10">The <code class="email">RemoveObserver</code> test will take the observer with ID 2 and remove it from the list:</p><pre class="programlisting">  t.Run("RemoveObserver", func(t *testing.T) { 
    publisher.RemoveObserver(testObserver2) 
 
    if len(publisher.ObserversList) != 2 { 
      t.Errorf("The size of the observer list is not the " + 
        "expected. 3 != %d\n", len(publisher.ObserversList)) 
    } 
     
    for _, observer := range publisher.ObserversList { 
      testObserver, ok := observer.(TestObserver) 
      if !ok {  
        t.Fail() 
      } 
       
      if testObserver.ID == 2 { 
        t.Fail() 
      } 
    } 
  }) 
</pre><p class="calibre10">After removing the second observer, the length of the <code class="email">Publisher</code> structure must be 2 now. We also check that none of the observers left have the <code class="email">ID</code> 2 because it must be removed.</p><p class="calibre10">The last method to test is the <code class="email">Notify</code> method. When using the <code class="email">Notify</code> method, all instances of <code class="email">TestObserver</code> structure must change their <code class="email">Message</code> field from empty to the passed message (<code class="email">Hello World!</code> in this case). First we will check that all the <code class="email">Message</code> fields are, in fact, empty before calling the <code class="email">NotifyObservers</code> test:</p><pre class="programlisting">t.Run("Notify", func(t *testing.T) { 
    for _, observer := range publisher.ObserversList { 
      printObserver, ok := observer.(*TestObserver) 
      if !ok { 
        t.Fail() 
        break 
      } 
 
      if printObserver.Message != "" { 
        t.Errorf("The observer's Message field weren't " + "  empty: %s\n", printObserver.Message) 
      } 
    } 
</pre><p class="calibre10">Using a <code class="email">for</code> statement, we are iterating over the <code class="email">ObserversList</code> field to slice in the <code class="email">publisher</code> instance. We need to make a type casting from a pointer to an observer, to a pointer to the <code class="email">TestObserver</code> structure, and check that the casting has been done correctly. Then, we check that the <code class="email">Message</code> field is actually empty.</p><p class="calibre10">The next step is to create a message to send--in this case, it will be <code class="email">"Hello World!"</code> and then pass this message to the <code class="email">NotifyObservers</code> method to notify every observer on the list (currently observers 1 and 3 only):</p><pre class="programlisting">    ... 
    message := "Hello World!" 
    publisher.NotifyObservers(message) 
 
    for _, observer := range publisher.ObserversList { 
      printObserver, ok := observer.(*TestObserver) 
      if !ok { 
        t.Fail() 
        break 
      } 
 
      if printObserver.Message != message { 
        t.Errorf("Expected message on observer %d was " + 
          "not expected: '%s' != '%s'\n", printObserver.ID, 
          printObserver.Message, message) 
      } 
    } 
  }) 
} 
</pre><p class="calibre10">After calling the <code class="email">NotifyObservers</code> method, each <code class="email">TestObserver</code> tests in the <code class="email">ObserversList</code> field must have the message <code class="email">"Hello World!"</code> stored in their <code class="email">Message</code> field. Again, we use a <code class="email">for</code> loop to iterate over every observer of the <code class="email">ObserversList</code> field and we typecast each to a <code class="email">TestObserver</code> test (remember that <code class="email">TestObserver</code> structure doesn't have any field as it's an interface). We could avoid type casting by adding a new <code class="email">Message()</code> method to <code class="email">Observer</code> instance and implementing it in the <code class="email">TestObserver</code> structure to return the contents of the <code class="email">Message</code> field. Both methods are equally valid. Once we have type casted to a <code class="email">TestObserver</code> method called <code class="email">printObserver</code> variable as a local variable, we check that each instance in the <code class="email">ObserversList</code> structure has the string <code class="email">"Hello World!"</code> stored in their <code class="email">Message</code> field.</p><p class="calibre10">Time to run the tests that must fail all to check their effectiveness in the later implementation:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v  
=== RUN   TestSubject 
=== RUN   TestSubject/AddObserver 
=== RUN   TestSubject/RemoveObserver 
=== RUN   TestSubject/Notify 
--- FAIL: TestSubject (0.00s) 
    --- FAIL: TestSubject/AddObserver (0.00s) 
    --- FAIL: TestSubject/RemoveObserver (0.00s) 
        observer_test.go:40: The size of the observer list is not the expected. 3 != 0 
    --- PASS: TestSubject/Notify (0.00s) 
FAIL 
exit status 1 
FAIL</strong></span>
</pre><p class="calibre10">Something isn't working as expected. How is the <code class="email">Notify</code> method passing the tests if we haven't implemented the function yet? Take a look at the test of the <code class="email">Notify</code> method again. The test iterates over the <code class="email">ObserversList</code> structure and each <code class="email">F</code>
<code class="email">ail</code> call is inside this for loop. If the list is empty, it won't iterate, so it won't execute any <code class="email">Fail call</code>.</p><p class="calibre10">Let's fix this issue by adding a small non-empty list check at the beginning of the <code class="email">Notify</code> test:</p><pre class="programlisting">  if len(publisher.ObserversList) == 0 { 
      t.Errorf("The list is empty. Nothing to test\n") 
  } 
</pre><p class="calibre10">And we will rerun the tests to see if the <code class="email">TestSubject/Notify</code> method is already failing:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestSubject</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestSubject/AddObserver</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestSubject/RemoveObserver</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestSubject/Notify</strong></span>
<span class="strong"><strong class="calibre2">--- FAIL: TestSubject (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">    --- FAIL: TestSubject/AddObserver (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">    --- FAIL: TestSubject/RemoveObserver (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        observer_test.go:40: The size of the observer list is not the expected. 3 != 0</strong></span>
<span class="strong"><strong class="calibre2">    --- FAIL: TestSubject/Notify (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        observer_test.go:58: The list is empty. Nothing to test</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
</pre><p class="calibre10">Nice, all of them are failing and now we have some guarantee on our tests. We can proceed to the implementation.</p></div></div></body></html>