- en: Unit tests
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'Maybe you have realized that our requirements defined almost exclusively the
    `Publisher` type. This is because the action performed by the observer is irrelevant
    for the Observer pattern. It should simply execute an action, in this case the
    `Notify` method, that one or many types will implement. So let''s define this
    only interface for this pattern:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你已经意识到，我们定义的要求几乎完全针对`Publisher`类型。这是因为观察者的动作对于观察者模式来说是不相关的。它应该简单地执行一个动作，在这种情况下是`Notify`方法，这个动作将由一个或多个类型实现。所以让我们只为这个模式定义这个接口：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Observer` interface has a `Notify` method that accepts a `string` type
    that will contain the message to spread. It does not need to return anything,
    but we could return an error if we want to check if all observers have been reached
    when calling the `publish` method of the `Publisher` structure.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observer`接口有一个`Notify`方法，它接受一个包含要传播的消息的`string`类型。它不需要返回任何内容，但如果我们想检查在调用`Publisher`结构的`publish`方法时是否已到达所有观察者，我们可以返回一个错误。'
- en: 'To test all the acceptance criteria, we just need a structure called `Publisher`
    with three methods:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试所有验收标准，我们只需要一个名为`Publisher`的结构，它有三个方法：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Publisher` structure stores the list of subscribed observers in a slice
    field called `ObserversList`. Then it has the three methods mentioned on the acceptance
    criteria-the `AddObserver` method to subscribe a new observer to the publisher,
    the `RemoveObserver` method to unsubscribe an observer, and the `NotifyObservers`
    method with a string that acts as the message we want to spread between all observers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`Publisher`结构将订阅观察者的列表存储在一个名为`ObserversList`的切片字段中。然后它具有在验收标准中提到的三个方法——`AddObserver`方法用于将新的观察者订阅到发布者，`RemoveObserver`方法用于取消订阅观察者，以及带有字符串的`NotifyObservers`方法，该字符串充当我们在所有观察者之间传播的消息。'
- en: 'With these three methods, we have to set up a root test to configure the `Publisher`
    and three subtests to test each method. We also need to define a test type structure
    that implements the `Observer` interface. This structure is going to be called
    `TestObserver`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三个方法，我们必须设置一个根测试来配置`Publisher`和三个子测试来测试每个方法。我们还需要定义一个实现`Observer`接口的测试类型结构。这个结构将被命名为`TestObserver`：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `TestObserver` structure implements the Observer pattern by defining a `Notify(string)`
    method in its structure. In this case, it prints the received message together
    with its own observer ID. Then, it stores the message in its `Message` field.
    This allows us to check later if the content of the `Message` field is as expected.
    Remember that it could also be done by passing the `testing.T` pointer and the
    expected message and checking within the `TestObserver` structure.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestObserver`结构通过在其结构中定义一个`Notify(string)`方法来实现观察者模式。在这种情况下，它打印接收到的消息以及它自己的观察者ID。然后，它将消息存储在其`Message`字段中。这允许我们稍后检查`Message`字段的内容是否如预期。记住，这也可以通过传递`testing.T`指针和预期的消息，并在`TestObserver`结构内部进行检查来实现。'
- en: 'Now we can set up the `Publisher` structure to execute the three tests. We
    will create three instances of the `TestObserver` structure:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以设置`Publisher`结构来执行三个测试。我们将创建三个`TestObserver`结构的实例：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have given a different ID to each observer so that we can see later that
    each of them has printed the expected message. Then, we have added the observers
    by calling the `AddObserver` method on the `Publisher` structure.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个观察者分配了一个不同的ID，这样我们就可以在以后看到每个观察者都打印了预期的消息。然后，我们通过在`Publisher`结构上调用`AddObserver`方法来添加观察者。
- en: 'Let''s write an `AddObserver` test, it must add a new observer to the `ObserversList`
    field of the `Publisher` structure:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个`AddObserver`测试，它必须将新的观察者添加到`Publisher`结构的`ObserversList`字段中：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have added three observers to the `Publisher` structure, so the length of
    the slice must be 3\. If it's not 3, the test will fail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经向`Publisher`结构添加了三个观察者，所以切片的长度必须是3。如果不是3，测试将失败。
- en: 'The `RemoveObserver` test will take the observer with ID 2 and remove it from
    the list:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveObserver`测试将获取ID为2的观察者并将其从列表中移除：'
- en: '[PRE5]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After removing the second observer, the length of the `Publisher` structure
    must be 2 now. We also check that none of the observers left have the `ID` 2 because
    it must be removed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在移除第二个观察者后，现在`Publisher`结构的长度必须是2。我们还检查剩下的观察者中没有ID为2的，因为它必须被移除。
- en: 'The last method to test is the `Notify` method. When using the `Notify` method,
    all instances of `TestObserver` structure must change their `Message` field from
    empty to the passed message (`Hello World!` in this case). First we will check
    that all the `Message` fields are, in fact, empty before calling the `NotifyObservers`
    test:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要测试的方法是`Notify`方法。当使用`Notify`方法时，所有`TestObserver`结构的实例都必须将它们的`Message`字段从空更改为传递的消息（在这种情况下是`Hello
    World!`）。首先，我们将在调用`NotifyObservers`测试之前检查所有`Message`字段实际上是否为空：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using a `for` statement, we are iterating over the `ObserversList` field to
    slice in the `publisher` instance. We need to make a type casting from a pointer
    to an observer, to a pointer to the `TestObserver` structure, and check that the
    casting has been done correctly. Then, we check that the `Message` field is actually
    empty.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for`语句，我们正在遍历`ObserversList`字段以在`publisher`实例中切片。我们需要将观察者指针转换为`TestObserver`结构指针，并检查转换是否正确完成。然后，我们检查`Message`字段是否实际上为空。
- en: 'The next step is to create a message to send--in this case, it will be `"Hello
    World!"` and then pass this message to the `NotifyObservers` method to notify
    every observer on the list (currently observers 1 and 3 only):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建要发送的消息--在这种情况下，它将是`"Hello World!"`，然后将其传递给`NotifyObservers`方法以通知列表上的每个观察者（目前只有观察者1和3）：
- en: '[PRE7]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After calling the `NotifyObservers` method, each `TestObserver` tests in the
    `ObserversList` field must have the message `"Hello World!"` stored in their `Message`
    field. Again, we use a `for` loop to iterate over every observer of the `ObserversList`
    field and we typecast each to a `TestObserver` test (remember that `TestObserver`
    structure doesn't have any field as it's an interface). We could avoid type casting
    by adding a new `Message()` method to `Observer` instance and implementing it
    in the `TestObserver` structure to return the contents of the `Message` field.
    Both methods are equally valid. Once we have type casted to a `TestObserver` method
    called `printObserver` variable as a local variable, we check that each instance
    in the `ObserversList` structure has the string `"Hello World!"` stored in their
    `Message` field.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`NotifyObservers`方法后，`ObserversList`字段中的每个`TestObserver`测试都必须在它们的`Message`字段中存储消息`"Hello
    World!"`。再次，我们使用`for`循环遍历`ObserversList`字段的每个观察者，并将每个转换为`TestObserver`测试（记住`TestObserver`结构没有字段，因为它是一个接口）。我们可以通过向`Observer`实例添加一个新的`Message()`方法并在`TestObserver`结构中实现它来避免类型转换，以返回`Message`字段的值。两种方法都是有效的。一旦我们将类型转换为名为`printObserver`的局部变量`TestObserver`方法，我们就检查`ObserversList`结构中的每个实例是否在它们的`Message`字段中存储了字符串`"Hello
    World!"`。
- en: 'Time to run the tests that must fail all to check their effectiveness in the
    later implementation:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行必须全部失败的测试，以检查它们在后续实现中的有效性：
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Something isn't working as expected. How is the `Notify` method passing the
    tests if we haven't implemented the function yet? Take a look at the test of the
    `Notify` method again. The test iterates over the `ObserversList` structure and
    each `F` `ail` call is inside this for loop. If the list is empty, it won't iterate,
    so it won't execute any `Fail call`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有些事情没有按预期工作。如果我们还没有实现该函数，`Notify`方法是如何通过测试的？再次查看`Notify`方法的测试。测试遍历`ObserversList`结构，每个`Fail`调用都在这个`for`循环内部。如果列表为空，它不会迭代，因此不会执行任何`Fail`调用。
- en: 'Let''s fix this issue by adding a small non-empty list check at the beginning
    of the `Notify` test:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在`Notify`测试的开始处添加一个小的不为空列表检查来解决这个问题：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And we will rerun the tests to see if the `TestSubject/Notify` method is already
    failing:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新运行测试以查看`TestSubject/Notify`方法是否已经失败：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Nice, all of them are failing and now we have some guarantee on our tests. We
    can proceed to the implementation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，它们都失败了，现在我们对测试有了保证。我们可以继续实施。
