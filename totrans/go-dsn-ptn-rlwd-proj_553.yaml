- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Our implementation is just to define the `AddObserver`, the `RemoveObserver`,
    and the `NotifyObservers` methods:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现只是定义了`AddObserver`、`RemoveObserver`和`NotifyObservers`方法：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `AddObserver` method adds the `Observer` instance to the `ObserversList`
    structure by appending the pointer to the current list of pointers. This one was
    very easy. The `AddObserver` test must be passing now (but not the rest or we
    could have done something wrong):'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddObserver`方法通过将当前指针列表的指针附加到`ObserversList`结构体中，将`Observer`实例添加到`ObserversList`结构体中。这个操作非常简单。`AddObserver`测试现在应该通过（但其他部分没有通过，我们可能做错了什么）：'
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Excellent. Just the `AddObserver` method has passed the test, so we can now
    continue to the `RemoveObserver` method:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。只有`AddObserver`方法通过了测试，所以我们现在可以继续到`RemoveObserver`方法：
- en: '[PRE2]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `RemoveObserver` method will iterate for each element in the `ObserversList`
    structure, comparing the `Observer` object''s `o` variable with the ones stored
    in the list. If it finds a match, it saves the index  in the local variable, `indexToRemove`,
    and stops the iteration. The way to remove indexes on a slice in Go is a bit tricky:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveObserver`方法将遍历`ObserversList`结构中的每个元素，比较`Observer`对象的`o`变量与列表中存储的变量。如果找到匹配项，它将索引保存到局部变量`indexToRemove`中，并停止迭代。在Go中移除切片上的索引有点棘手：'
- en: First, we need to use slice indexing to return a new slice containing every
    object from the beginning of the slice to the index we want to remove (not included).
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要使用切片索引来返回一个新的切片，包含从切片开始到我们想要删除的索引（不包括）之间的所有对象。
- en: Then, we get another slice from the index we want to remove (not included) to
    the last object in the slice
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从这个索引（不包括）到最后一个对象获取另一个切片
- en: Finally, we join the previous two new slices into a new one (the `append` function)
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将前两个新切片合并成一个新的切片（即`append`函数）
- en: For example, in a list from 1 to 10 in which we want to remove the number 5,
    we have to create a new slice, joining a slice from 1 to 4 and a slice from 6
    to 10.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个从1到10的列表中，我们想要删除数字5，我们必须创建一个新的切片，将1到4的切片和6到10的切片连接起来。
- en: This index removal is done with the `append` function again because we are actually
    appending two lists together. Just take a closer look at the three dots at the
    end of the second argument of the `append` function. The `append` function adds
    an element (the second argument) to a slice (the first), but we want to append
    an entire list. This can be achieved using the three dots, which translate to
    something like *keep adding elements until you finish the second array*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种索引删除是通过`append`函数再次完成的，因为我们实际上是在将两个列表连接起来。只需仔细看看`append`函数第二个参数末尾的三个点。`append`函数将一个元素（第二个参数）添加到一个切片（第一个参数）中，但我们要添加一个整个列表。这可以通过使用三个点来实现，这相当于*继续添加元素，直到完成第二个数组*。
- en: 'Ok, let''s run this test now:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在让我们运行这个测试：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We continue in the good path. The `RemoveObserver` test has been fixed without
    fixing anything else. Now we have to finish our implementation by defining the
    `NotifyObservers` method:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续沿着正确的路径前进。`RemoveObserver`测试已经修复，但没有修复其他任何东西。现在我们必须通过定义`NotifyObservers`方法来完成我们的实现：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `NotifyObservers` method is quite simple because it prints a message to
    the console to announce that a particular message is going to be passed to the
    `Observers`. After this, we use a for loop to iterate over `ObserversList` structure
    and execute each `Notify(string)` method by passing the argument `m`. After executing
    this, all observers must have the message `Hello World!` stored in their `Message`
    field. Let''s see if this is true by running the tests:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`NotifyObservers`方法相当简单，因为它向控制台打印一条消息，宣布要将特定消息传递给`Observers`。之后，我们使用for循环遍历`ObserversList`结构体，并通过传递参数`m`执行每个`Notify(string)`方法。执行此操作后，所有观察者必须在其`Message`字段中存储消息`Hello
    World!`。让我们通过运行测试来查看这是否正确：'
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Excellent! We can also see the outputs of the `Publisher` and `Observer` types
    on the console. The `Publisher` structure prints the following message:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们还可以在控制台上看到`Publisher`和`Observer`类型的输出。`Publisher`结构体打印以下消息：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After this, all observers print their respective messages as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，所有观察者将按照以下方式打印它们各自的消息：
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: And the same for the third observer.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三个观察者也是如此。
