<html><head></head><body>
<div class="book" title="Chapter&#xA0;8.&#xA0;Introduction to Gos Concurrency" id="43JDK1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="A little bit of history and theory"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch08lvl1sec055" class="calibre1"/>A little bit of history and theory</h1></div></div></div><p class="calibre10">When we talk about Go's concurrency, it's impossible not to talk about history. In the last decades, we saw an improvement in the speed of CPUs until we reached the hardware limits imposed by current hardware materials, design, and architectures. When we reached this point, we started to play with the first multicore computers, the first double CPU motherboards, and then single CPUs with more than one core in their heart.</p><p class="calibre10">Unfortunately, the languages we are using are still the ones created when we had single core CPUs, such as Java or C++. While being terrific systems languages, they lack a proper concurrency support by design. You can develop concurrent apps in both of the languages used in your project by using third party tools or by developing your own (not a very easy task).</p><p class="calibre10">Go's concurrency was designed with these caveats in mind. The creators wanted garbage collected and procedural language that is familiar for newcomers, but which, at the same time, can be used to write concurrent applications easily and without affecting the core of the language.</p><p class="calibre10">We have experienced this in the early chapters. We have developed more than 20 design patterns without a word about concurrency. This clearly shows that the concurrent features of the Go language are completely separated from the core language while being part of it, a perfect example of abstraction and encapsulation.</p><p class="calibre10">There are many concurrency models in computer science, the most famous being the actor model present in languages such as <span class="strong"><strong class="calibre2">Erlang</strong></span> or <span class="strong"><strong class="calibre2">Scala</strong></span>. Go, on the other side, uses <span class="strong"><strong class="calibre2">Communicating Sequential Processes</strong></span> (<span class="strong"><strong class="calibre2">CSP</strong></span>), which has a different approach to concurrency.</p></div></div></body></html>