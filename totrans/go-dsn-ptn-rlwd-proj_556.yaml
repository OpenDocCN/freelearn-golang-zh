- en: A little bit of history and theory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一点历史和理论
- en: When we talk about Go's concurrency, it's impossible not to talk about history.
    In the last decades, we saw an improvement in the speed of CPUs until we reached
    the hardware limits imposed by current hardware materials, design, and architectures.
    When we reached this point, we started to play with the first multicore computers,
    the first double CPU motherboards, and then single CPUs with more than one core
    in their heart.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论 Go 的并发时，不可避免地要谈到历史。在过去几十年里，我们看到了 CPU 速度的提高，直到我们达到了由当前硬件材料、设计和架构所施加的硬件限制。当我们达到这个点时，我们开始玩弄第一台多核计算机，第一块双
    CPU 主板，然后是具有一个以上核心的单核 CPU。
- en: Unfortunately, the languages we are using are still the ones created when we
    had single core CPUs, such as Java or C++. While being terrific systems languages,
    they lack a proper concurrency support by design. You can develop concurrent apps
    in both of the languages used in your project by using third party tools or by
    developing your own (not a very easy task).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们使用的语言仍然是我们在单核 CPU 时代创建的，如 Java 或 C++。虽然它们是出色的系统语言，但它们在设计上缺乏适当的并发支持。你可以在项目中使用的两种语言中通过使用第三方工具或开发自己的（这不是一件容易的任务）来开发并发应用程序。
- en: Go's concurrency was designed with these caveats in mind. The creators wanted
    garbage collected and procedural language that is familiar for newcomers, but
    which, at the same time, can be used to write concurrent applications easily and
    without affecting the core of the language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的并发设计考虑到了这些注意事项。创造者希望语言具有垃圾回收和适合新手的程序性，同时又能轻松地编写并发应用程序，而不影响语言的内核。
- en: We have experienced this in the early chapters. We have developed more than
    20 design patterns without a word about concurrency. This clearly shows that the
    concurrent features of the Go language are completely separated from the core
    language while being part of it, a perfect example of abstraction and encapsulation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在早期章节中已经体验过这一点。我们开发了20多个设计模式，但没有提到并发。这清楚地表明，Go 语言的并发特性与核心语言完全分离，同时又是其一部分，这是抽象和封装的完美例子。
- en: There are many concurrency models in computer science, the most famous being
    the actor model present in languages such as **Erlang** or **Scala**. Go, on the
    other side, uses **Communicating Sequential Processes** (**CSP**), which has a
    different approach to concurrency.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中有许多并发模型，最著名的是存在于 **Erlang** 或 **Scala** 等语言中的演员模型。另一方面，Go 使用 **通信顺序进程**（**CSP**），它对并发有不同方法。
