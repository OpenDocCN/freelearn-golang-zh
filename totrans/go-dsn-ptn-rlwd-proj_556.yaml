- en: A little bit of history and theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about Go's concurrency, it's impossible not to talk about history.
    In the last decades, we saw an improvement in the speed of CPUs until we reached
    the hardware limits imposed by current hardware materials, design, and architectures.
    When we reached this point, we started to play with the first multicore computers,
    the first double CPU motherboards, and then single CPUs with more than one core
    in their heart.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the languages we are using are still the ones created when we
    had single core CPUs, such as Java or C++. While being terrific systems languages,
    they lack a proper concurrency support by design. You can develop concurrent apps
    in both of the languages used in your project by using third party tools or by
    developing your own (not a very easy task).
  prefs: []
  type: TYPE_NORMAL
- en: Go's concurrency was designed with these caveats in mind. The creators wanted
    garbage collected and procedural language that is familiar for newcomers, but
    which, at the same time, can be used to write concurrent applications easily and
    without affecting the core of the language.
  prefs: []
  type: TYPE_NORMAL
- en: We have experienced this in the early chapters. We have developed more than
    20 design patterns without a word about concurrency. This clearly shows that the
    concurrent features of the Go language are completely separated from the core
    language while being part of it, a perfect example of abstraction and encapsulation.
  prefs: []
  type: TYPE_NORMAL
- en: There are many concurrency models in computer science, the most famous being
    the actor model present in languages such as **Erlang** or **Scala**. Go, on the
    other side, uses **Communicating Sequential Processes** (**CSP**), which has a
    different approach to concurrency.
  prefs: []
  type: TYPE_NORMAL
