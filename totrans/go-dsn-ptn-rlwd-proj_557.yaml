- en: Concurrency versus parallelism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many people have misunderstood the differences between both, even thinking
    that they are the same. There is a popular speech by Rob Pike, one of the creators
    of Go, *Concurrency is not parallelism*, which I really agree with. As a quick
    summary of the talk, we can extract the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency is about dealing with many things at once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallelism is about doing many things at the same time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency enables parallelism by designing a correct structure of concurrency
    work.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can think of the mechanism of a bike. When we pedal, we usually
    push down the pedal to produce force (and this push, raises our opposite leg on
    the opposite pedal). We cannot push with both legs at the same time because the
    cranks don't allow us to do it. But this design allows the construction of a parallel
    bike, commonly called a **tandem bike**. A tandem bike is a bike that two people
    can ride at the same time; they both pedal and apply force to the bike.
  prefs: []
  type: TYPE_NORMAL
- en: In the bike example, concurrency is the design of a bike that, with two legs
    (Goroutines), you can produce power to move the bike by yourself. The design is
    concurrent and correct. If we use a tandem bike and two people (two cores), the
    solution is concurrent, correct, and parallel. But the key thing is that with
    a concurrent design, we don't have to worry about parallelism; we can think about
    it as an extra feature if our concurrent design is correct. In fact, we can use
    the tandem bike with only one person, but the concurrent design of the legs, pedals,
    chain, wheels of a bike is still correct.
  prefs: []
  type: TYPE_NORMAL
- en: '![Concurrency versus parallelism](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With concurrency, on the left side, we have a design and a structure that is
    executed sequentially by the same CPU core. Once we have this design and structure,
    parallelism can be achieved by simply repeating this structure on a different
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: This is how Go eases the reasoning about concurrent and parallel programs by
    simply not worrying too much about parallel execution and focusing much more on
    concurrent design and structure. Breaking a big task into smaller tasks that can
    be run concurrently usually provides much better performance in a single-core
    computer, but, if this design can also be run in parallel, we could achieve an
    even higher throughput (or not, depending on the design).
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we can set the number of cores in use in a Go app by setting the environment
    variable `GOMAXPROCS` to the number of cores we want. This is not only useful
    when using schedulers, such as **Apache Mesos**, but it gives us more control
    about how a Go app works and performs.
  prefs: []
  type: TYPE_NORMAL
- en: So, to recap, it is very important to keep in mind that concurrency is about
    structure and parallelism is about execution. We must think about making our programs
    concurrent in a better way, by breaking them down into smaller pieces of work,
    and Go's scheduler will try to make them parallel if it's possible and allowed.
  prefs: []
  type: TYPE_NORMAL
