- en: CSP versus actor-based concurrency
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSP与基于actor的并发
- en: The most common and, perhaps, intuitive way to think about concurrency is close
    to the way the actor model works.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑并发最常见和可能最直观的方式几乎与actor模型的工作方式相似。
- en: '![CSP versus actor-based concurrency](img/00036.jpeg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![CSP与基于actor的并发](img/00036.jpeg)'
- en: In the actor model, if **Actor 1** wants to communicate with **Actor 2**, then
    **Actor 1** must know **Actor 2** first; for example, it must have its process
    ID, maybe from the creation step, and put a message on its inbox queue. After
    placing the message, **Actor 1** can continue its tasks without getting blocked
    if **Actor 2** cannot process the message immediately.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在actor模型中，如果**Actor 1**想与**Actor 2**通信，那么**Actor 1**必须首先知道**Actor 2**；例如，它必须从创建步骤中获取其进程ID，并将其消息放在其收件箱队列中。放置消息后，如果**Actor
    2**不能立即处理消息，**Actor 1**可以继续其任务而不会受阻。
- en: 'CSP, on the other side, introduces a new entity into the equation-channels.
    Channels are the way to communicate between processes because they are completely
    anonymous (unlike actors, where we need to know their process IDs). In the case
    of CSP, we don''t have a process ID to use to communicate. Instead, we have to
    create a channel to the processes to allow incoming and outgoing communication.
    In this case, what we know that the receiver is the channel it uses to receive
    data:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从另一方面来看，CSP在等式中引入了一个新的实体——通道。通道是进程之间通信的方式，因为它们是完全匿名的（与actor不同，我们需要知道它们的进程ID）。在CSP的情况下，我们没有进程ID可以用来通信。相反，我们必须为进程创建一个通道，以便允许传入和传出通信。在这种情况下，我们知道接收者是它用来接收数据的通道：
- en: '![CSP versus actor-based concurrency](img/00037.jpeg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![CSP与基于actor的并发](img/00037.jpeg)'
- en: In this diagram, we can see that the processes are anonymous, but we have a
    channel with ID 1, that is, **Channel 1**, which connects them together. This
    abstraction does not tell us how many processes are on each side of the channel;
    it simply connects them and allows communication between processes by using the
    channel.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们可以看到过程是匿名的，但我们有一个ID为1的通道，即**通道1**，它将它们连接在一起。这种抽象并没有告诉我们通道两边的每个通道上有多少个过程；它只是将它们连接起来，并允许通过通道在过程之间进行通信。
- en: The key here is that channels isolate both extremes so that process A can send
    data through a channel that will be handled by potentially one or more processes
    that' are transparent to A. It also works the same in reverse; process B can receive
    data from many channels one at a time.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于通道隔离了两个极端，使得过程A可以通过一个通道发送数据，这个通道将由一个或多个对A透明的进程处理。反过来也是一样的；过程B可以一次接收来自多个通道的数据。
