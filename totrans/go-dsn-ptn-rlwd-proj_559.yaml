- en: Goroutines
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goroutines
- en: In Go, we achieve concurrency by working with Goroutines. They are like processes
    that run applications in a computer concurrently; in fact, the main loop of Go
    could be considered a Goroutine, too. Goroutines are used in places where we would
    use actors. They execute some logic and die (or keep looping if necessary).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，我们通过使用Goroutines来实现并发。它们就像在计算机上并发运行应用程序的进程；实际上，Go的主循环也可以被视为一个Goroutine。Goroutines被用于我们本应使用演员的地方。它们执行一些逻辑然后结束（或者在必要时持续循环）。
- en: But Goroutines are not threads. We can launch thousands of concurrent Goroutines,
    even millions. They are incredibly cheap, with a small growth stack. We will use
    Goroutines to execute code that we want to work concurrently. For example, three
    calls to three services to compose a response can be designed concurrently with
    three Goroutines to do the service calls potentially in parallel and a fourth
    Goroutine to receive them and compose the response. What's the point here? That
    if we have a computer with four cores, we could potentially run this service call
    in parallel, but if we use a one-core computer, the design will still be correct
    and the calls will be executed concurrently in only one core. By designing concurrent
    applications, we don't need to worry about parallel execution.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但Goroutines并不是线程。我们可以启动成千上万的并发Goroutines，甚至数百万个。它们非常便宜，具有较小的增长堆栈。我们将使用Goroutines来执行我们想要并发执行的代码。例如，对三个服务进行三次调用以组成响应可以设计为使用三个Goroutines并发进行服务调用，可能并行，以及一个第四个Goroutine来接收它们并组成响应。这里的关键点是什么？如果我们有一台具有四个核心的计算机，我们可能可以并行运行这个服务调用，但如果我们使用单核计算机，设计仍然正确，调用将在单个核心中并发执行。通过设计并发应用程序，我们不需要担心并行执行。
- en: Returning to the bike analogy, we were pushing the pedals of the bike with our
    two legs. That's two Goroutines concurrently pushing the pedals. When we use the
    tandem, we had a total of four Goroutines, possibly working in parallel. But we
    also have two hands to handle the front and rear brakes. That's a total of eight
    Goroutines for our two threads bike. Actually, we don't pedal when we brake and
    we don't brake when we pedal; that's a correct concurrent design. Our nervous
    system transports the information about when to stop pedaling and when to start
    braking. In Go, our nervous system is composed of channels; we will see them after
    playing a bit with Goroutines first.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 回到自行车的比喻，我们用两条腿推动自行车的踏板。这就是两个Goroutines并发地推动踏板。当我们使用双人自行车时，我们总共有四个Goroutines，可能并行工作。但我们还有两只手来控制前后刹车。对于我们的双人自行车，这总共是八个Goroutines。实际上，我们在刹车时不会踩踏板，我们在踩踏板时不会刹车；这是一个正确的并发设计。我们的神经系统传递关于何时停止踩踏板和何时开始刹车的信息。在Go中，我们的神经系统由通道组成；我们将在玩了一会儿Goroutines之后看到它们。
