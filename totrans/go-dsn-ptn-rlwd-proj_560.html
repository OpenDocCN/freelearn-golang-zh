<html><head></head><body>
<div class="book" title="Goroutines">
<div class="book" title="Our first Goroutine"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec0198" class="calibre1"/>Our first Goroutine</h2></div></div></div><p class="calibre10">Enough of the explanations now. Let's get our hands dirty. For our first Goroutine, we will print the message <code class="email">Hello World!</code> in a Goroutine. Let's start with what we've been doing up until now:</p><pre class="programlisting">package main 
 
func main() { 
  helloWorld() 
} 
 
func helloWorld(){ 
  println("Hello World!") 
} 
</pre><p class="calibre10">Running this small snippet of code will simply output <code class="email">Hello World!</code> in the console:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go</strong></span>
<span class="strong"><strong class="calibre2">Hello World!</strong></span>
</pre><p class="calibre10">Not impressive at all. To run it in a new Goroutine, we just need to add the keyword <code class="email">go</code> at the beginning of the call to the function:</p><pre class="programlisting">package main 
 
func main() { 
  go helloWorld() 
} 
 
func helloWorld(){ 
  println("Hello World!") 
} 
</pre><p class="calibre10">With this simple word, we are telling Go to start a new Goroutine running the contents of the <code class="email">helloWorld</code> function.</p><p class="calibre10">So, let's run it:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go 
$</strong></span>
</pre><p class="calibre10">What? It printed nothing! Why is that? Things get complicated when you start to deal with concurrent applications. The problem is that the <code class="email">main</code> function finishes before the <code class="email">helloWorld</code> function gets executed. Let's analyse it step by step. The <code class="email">main</code> function starts and schedules a new Goroutine that will execute the <code class="email">helloWorld</code> function, but the function isn't executed when the function finishes--it is still in the scheduling process.</p><p class="calibre10">So, our <code class="email">main</code> problem is that the <code class="email">main</code> function has to wait for the Goroutine to be executed before finishing. So let's pause for a second to give some room to the Goroutine:</p><pre class="programlisting">package main 
import "time" 
 
func main() { 
  go helloWorld() 
 
  time.Sleep(time.Second) 
} 
 
func helloWorld(){ 
  println("Hello World!") 
} 
</pre><p class="calibre10">The <code class="email">time.Sleep</code> function effectively sleeps the main Goroutine for one second before continuing (and exiting). If we run this now, we must get the message:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go</strong></span>
<span class="strong"><strong class="calibre2">Hello World!</strong></span>
</pre><p class="calibre10">I suppose you must have noticed by now the small gap of time where the program is freezing before finishing. This is the function for sleeping. If you are doing a lot of tasks, you might want to raise the waiting time to whatever you want. Just remember that in any application the <code class="email">main</code> function cannot finish before the rest of the Goroutines.</p></div></div></body></html>