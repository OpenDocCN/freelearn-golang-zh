- en: Our first Goroutine
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个Goroutine
- en: 'Enough of the explanations now. Let''s get our hands dirty. For our first Goroutine,
    we will print the message `Hello World!` in a Goroutine. Let''s start with what
    we''ve been doing up until now:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在就不再解释了。让我们动手实践。对于我们的第一个Goroutine，我们将在Goroutine中打印消息`Hello World!`。让我们从到目前为止我们所做的一切开始：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Not impressive at all. To run it in a new Goroutine, we just need to add the
    keyword `go` at the beginning of the call to the function:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 完全不令人印象深刻。要在一个新的Goroutine中运行它，我们只需要在调用函数的开始处添加关键字`go`：
- en: '[PRE2]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this simple word, we are telling Go to start a new Goroutine running the
    contents of the `helloWorld` function.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的词，我们告诉Go启动一个新的Goroutine，运行`helloWorld`函数的内容。
- en: 'So, let''s run it:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们运行它：
- en: '[PRE3]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What? It printed nothing! Why is that? Things get complicated when you start
    to deal with concurrent applications. The problem is that the `main` function
    finishes before the `helloWorld` function gets executed. Let's analyse it step
    by step. The `main` function starts and schedules a new Goroutine that will execute
    the `helloWorld` function, but the function isn't executed when the function finishes--it
    is still in the scheduling process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？它什么都没打印出来！为什么？当你开始处理并发应用程序时，事情会变得复杂。问题是`main`函数在`helloWorld`函数执行之前就结束了。让我们一步一步地分析。`main`函数开始并安排一个新的Goroutine来执行`helloWorld`函数，但函数在结束时并没有执行——它仍然处于调度过程中。
- en: 'So, our `main` problem is that the `main` function has to wait for the Goroutine
    to be executed before finishing. So let''s pause for a second to give some room
    to the Goroutine:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们面临的主要问题是`main`函数必须等待Goroutine执行完毕后才能结束。所以，让我们暂停一下，给Goroutine留出一些空间：
- en: '[PRE4]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `time.Sleep` function effectively sleeps the main Goroutine for one second
    before continuing (and exiting). If we run this now, we must get the message:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Sleep`函数有效地使主Goroutine休眠一秒钟，然后再继续（并退出）。如果我们现在运行这个程序，我们必须得到以下消息：'
- en: '[PRE5]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: I suppose you must have noticed by now the small gap of time where the program
    is freezing before finishing. This is the function for sleeping. If you are doing
    a lot of tasks, you might want to raise the waiting time to whatever you want.
    Just remember that in any application the `main` function cannot finish before
    the rest of the Goroutines.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你现在一定注意到了程序在结束前短暂冻结的小时间间隔。这是睡眠函数。如果你要做很多任务，你可能希望将等待时间提高到你想要的任何时间。只需记住，在任何应用程序中，`main`函数不能在其余的Goroutine之前结束。
