<html><head></head><body>
<div class="book" title="Goroutines">
<div class="book" title="Anonymous functions launched as new Goroutines"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec0199" class="calibre1"/>Anonymous functions launched as new Goroutines</h2></div></div></div><p class="calibre10">We have defined the <code class="email">helloWorld</code> function so that it can be launched with a different Goroutine. This is not strictly necessary because you can launch snippets of code directly in the function's scope:</p><pre class="programlisting">package main 
import "time" 
 
func main() { 
  go func() { 
    println("Hello World") 
  }() 
  time.Sleep(time.Second) 
} 
</pre><p class="calibre10">This is also valid. We have used an anonymous function and we have launched it in a new Goroutine using the <code class="email">go</code> keyword. Take a closer look at the closing braces of the function-they are followed by opening and closing parenthesis, indicating the execution of the function.</p><p class="calibre10">We can also pass data to anonymous functions:</p><pre class="programlisting">package main 
import "time" 
 
func main() { 
  go func(msg string) { 
    println(msg) 
  }("Hello World") 
  time.Sleep(time.Second) 
} 
</pre><p class="calibre10">This is also valid. We had defined an anonymous function that received a string, which then printed the received string. When we called the function in a different Goroutine, we passed the message we wanted to print. In this sense, the following example would also be valid:</p><pre class="programlisting">package main 
import "time" 
 
func main() { 
  messagePrinter := func(msg string) { 
    println(msg) 
  } 
 
  go messagePrinter("Hello World") 
  go messagePrinter("Hello goroutine") 
  time.Sleep(time.Second) 
} 
</pre><p class="calibre10">In this case, we have defined a function within the scope of our <code class="email">main</code> function and stored it in a variable called <code class="email">messagePrinter</code>. Now we can concurrently print as many messages as we want by using the <code class="email">messagePrinter(string)</code> signature:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go</strong></span>
<span class="strong"><strong class="calibre2">Hello World</strong></span>
<span class="strong"><strong class="calibre2">Hello goroutine</strong></span>
</pre><p class="calibre10">We have just scratched the surface of concurrent programming in Go, but we can already see that it can be quite powerful. But we definitely have to do something with that sleeping period. WaitGroups can help us with this problem.</p></div></div></body></html>