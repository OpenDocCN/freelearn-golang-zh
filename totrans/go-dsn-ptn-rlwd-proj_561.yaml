- en: Anonymous functions launched as new Goroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have defined the `helloWorld` function so that it can be launched with a
    different Goroutine. This is not strictly necessary because you can launch snippets
    of code directly in the function''s scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is also valid. We have used an anonymous function and we have launched
    it in a new Goroutine using the `go` keyword. Take a closer look at the closing
    braces of the function-they are followed by opening and closing parenthesis, indicating
    the execution of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also pass data to anonymous functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is also valid. We had defined an anonymous function that received a string,
    which then printed the received string. When we called the function in a different
    Goroutine, we passed the message we wanted to print. In this sense, the following
    example would also be valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we have defined a function within the scope of our `main` function
    and stored it in a variable called `messagePrinter`. Now we can concurrently print
    as many messages as we want by using the `messagePrinter(string)` signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have just scratched the surface of concurrent programming in Go, but we can
    already see that it can be quite powerful. But we definitely have to do something
    with that sleeping period. WaitGroups can help us with this problem.
  prefs: []
  type: TYPE_NORMAL
