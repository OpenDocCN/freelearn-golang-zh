- en: Anonymous functions launched as new Goroutines
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为新Goroutine启动的匿名函数
- en: 'We have defined the `helloWorld` function so that it can be launched with a
    different Goroutine. This is not strictly necessary because you can launch snippets
    of code directly in the function''s scope:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了`helloWorld`函数，使其可以用不同的Goroutine启动。这并不是严格必要的，因为你可以直接在函数的作用域内启动代码片段：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is also valid. We have used an anonymous function and we have launched
    it in a new Goroutine using the `go` keyword. Take a closer look at the closing
    braces of the function-they are followed by opening and closing parenthesis, indicating
    the execution of the function.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是有效的。我们使用了一个匿名函数，并使用`go`关键字在新的Goroutine中启动了它。仔细看看函数的结束花括号——它们后面跟着一个开括号和一个闭括号，这表明函数的执行。
- en: 'We can also pass data to anonymous functions:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将数据传递给匿名函数：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is also valid. We had defined an anonymous function that received a string,
    which then printed the received string. When we called the function in a different
    Goroutine, we passed the message we wanted to print. In this sense, the following
    example would also be valid:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是有效的。我们定义了一个匿名函数，它接收一个字符串，然后打印出接收到的字符串。当我们在一个不同的Goroutine中调用这个函数时，我们传递了想要打印的消息。从这个意义上说，以下示例也是有效的：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this case, we have defined a function within the scope of our `main` function
    and stored it in a variable called `messagePrinter`. Now we can concurrently print
    as many messages as we want by using the `messagePrinter(string)` signature:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在`main`函数的作用域内定义了一个函数，并将其存储在一个名为`messagePrinter`的变量中。现在我们可以通过使用`messagePrinter(string)`签名并发地打印出我们想要的任何数量的消息：
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have just scratched the surface of concurrent programming in Go, but we can
    already see that it can be quite powerful. But we definitely have to do something
    with that sleeping period. WaitGroups can help us with this problem.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚触及了Go中并发编程的表面，但我们已经可以看到它可以非常强大。但我们确实需要做些什么来处理那个睡眠期。WaitGroups可以帮助我们解决这个问题。
