<html><head></head><body>
<div class="book" title="Goroutines">
<div class="book" title="WaitGroups"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec0200" class="calibre1"/>WaitGroups</h2></div></div></div><p class="calibre10">WaitGroup comes in the synchronization package (the <code class="email">sync</code> package) to help us synchronize many concurrent Goroutines. It works very easily--every time we have to wait for one Goroutine to finish, we add <code class="email">1</code> to the group, and once all of them are added, we ask the group to wait. When the Goroutine finishes, it says <code class="email">Done</code> and the WaitGroup will take one from the group:</p><pre class="programlisting">package main 
 
import ( 
  "sync" 
  "fmt" 
) 
 
func main() { 
  var wait sync.WaitGroup 
  wait.Add(1) 
 
  go func(){ 
    fmt.Println("Hello World!") 
    wait.Done() 
  }() 
  wait.Wait() 
} 
</pre><p class="calibre10">This is the simplest possible example of a WaitGroup. First, we created a variable to hold it called the <code class="email">wait</code> variable. Next, before launching the new Goroutine, we say to the WaitGroup <code class="email">hey, you'll have to wait for one thing to finish</code> by using the <code class="email">wait.Add(1)</code> method. Now we can launch the <code class="email">1</code> that the WaitGroup has to wait for, which in this case is the previous Goroutine that prints <code class="email">Hello World</code> and says <code class="email">Done </code>(by using the <code class="email">wait.Done()</code> method) at the end of the Goroutine. Finally, we indicate to the WaitGroup to wait. We have to remember that the function <code class="email">wait.Wait()</code> was probably executed before the Goroutine.</p><p class="calibre10">Let's run the code again:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go </strong></span>
<span class="strong"><strong class="calibre2">Hello World!</strong></span>
</pre><p class="calibre10">Now it just waits the necessary time and not one millisecond more before exiting the application. Remember that when we use the <code class="email">Add(value)</code> method, we add entities to the WaitGroup, and when we use the <code class="email">Done()</code> method, we subtract one.</p><p class="calibre10">Actually, the <code class="email">Add</code> function takes a delta value, so the following code is equivalent to the previous:</p><pre class="programlisting">package main 
 
import ( 
  "sync" 
  "fmt" 
) 
 
func main() { 
  var wait sync.WaitGroup 
  wait.Add(1) 
 
  go func(){ 
    fmt.Println("Hello World!") 
    wait.Add(-1) 
  }() 
  wait.Wait() 
} 
</pre><p class="calibre10">In this case, we added <code class="email">1</code> before launching the Goroutine and we added <code class="email">-1</code> (subtracted 1) at the end of it. If we know in advance how many Goroutines we are going to launch, we can also call the <code class="email">Add</code> method just once:</p><pre class="programlisting">package main 
import ( 
  "fmt" 
  "sync" 
) 
 
func main() { 
  var wait sync.WaitGroup 
 
  goRoutines := 5 
  wait.Add(goRoutines) 
 
  for i := 0; i &lt; goRoutines; i++ { 
    go func(goRoutineID int) { 
      fmt.Printf("ID:%d: Hello goroutines!\n", goRoutineID) 
      wait.Done() 
    }(i) 
  } 
  wait.Wait() 
} 
</pre><p class="calibre10">In this example, we are going to create five Goroutines (as stated in the <code class="email">goroutines</code> variable). We know it in advance, so we simply add them all to the WaitGroup. We are then going to launch the same amount of <code class="email">goroutine</code> variables by using a <code class="email">for</code> loop. Every time one Goroutine finishes, it calls the <code class="email">Done()</code> method of the WaitGroup that is effectively waiting at the end of the main loop.</p><p class="calibre10">Again, in this case, the code reaches the end of the <code class="email">main</code> function before all Goroutines are launched (if any), and the WaitGroup makes the execution of the main flow wait until all <code class="email">Done</code> messages are called. Let's run this small program:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go </strong></span>

<span class="strong"><strong class="calibre2">ID:4: Hello goroutines!</strong></span>
<span class="strong"><strong class="calibre2">ID:0: Hello goroutines!</strong></span>
<span class="strong"><strong class="calibre2">ID:1: Hello goroutines!</strong></span>
<span class="strong"><strong class="calibre2">ID:2: Hello goroutines!</strong></span>
<span class="strong"><strong class="calibre2">ID:3: Hello goroutines!</strong></span>
</pre><p class="calibre10">We haven't mentioned it before, but we have passed the iteration index to each Goroutine as the parameter <code class="email">GoroutineID</code> to print it with the message <code class="email">Hello goroutines! </code>You might also have noticed that the Goroutines aren't executed in order. Of course! We are dealing with a scheduler that doesn't guarantee the order of execution of the Goroutines. This is something to keep in mind when programming concurrent applications. In fact, if we execute it again, we won't necessarily get the same order of output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go</strong></span>
<span class="strong"><strong class="calibre2">ID:4: Hello goroutines!</strong></span>
<span class="strong"><strong class="calibre2">ID:2: Hello goroutines!</strong></span>
<span class="strong"><strong class="calibre2">ID:1: Hello goroutines!</strong></span>
<span class="strong"><strong class="calibre2">ID:3: Hello goroutines!</strong></span>
<span class="strong"><strong class="calibre2">ID:0: Hello goroutines!</strong></span>
</pre></div></div></body></html>