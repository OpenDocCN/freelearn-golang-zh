- en: WaitGroups
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WaitGroups
- en: 'WaitGroup comes in the synchronization package (the `sync` package) to help
    us synchronize many concurrent Goroutines. It works very easily--every time we
    have to wait for one Goroutine to finish, we add `1` to the group, and once all
    of them are added, we ask the group to wait. When the Goroutine finishes, it says
    `Done` and the WaitGroup will take one from the group:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: WaitGroup 属于同步包（`sync` 包），它帮助我们同步许多并发 Goroutines。它工作起来非常简单——每次我们不得不等待一个 Goroutine
    完成，我们就向组中添加 `1`，一旦所有这些都被添加，我们就要求组等待。当 Goroutine 完成时，它会说 `Done`，WaitGroup 将从组中减去一个：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the simplest possible example of a WaitGroup. First, we created a variable
    to hold it called the `wait` variable. Next, before launching the new Goroutine,
    we say to the WaitGroup `hey, you'll have to wait for one thing to finish` by
    using the `wait.Add(1)` method. Now we can launch the `1` that the WaitGroup has
    to wait for, which in this case is the previous Goroutine that prints `Hello World`
    and says `Done` (by using the `wait.Done()` method) at the end of the Goroutine.
    Finally, we indicate to the WaitGroup to wait. We have to remember that the function
    `wait.Wait()` was probably executed before the Goroutine.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的 WaitGroup 示例。首先，我们创建了一个变量来持有它，称为 `wait` 变量。然后，在启动新的 Goroutine 之前，我们通过使用
    `wait.Add(1)` 方法告诉 WaitGroup “嘿，你将不得不等待某件事情完成”。现在我们可以启动 WaitGroup 必须等待的 `1`，在这种情况下，是打印
    `Hello World` 并在 Goroutine 末尾说 `Done`（使用 `wait.Done()` 方法）的先前 Goroutine。最后，我们向
    WaitGroup 指示等待。我们必须记住，函数 `wait.Wait()` 可能是在 Goroutine 之前执行的。
- en: 'Let''s run the code again:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行代码：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now it just waits the necessary time and not one millisecond more before exiting
    the application. Remember that when we use the `Add(value)` method, we add entities
    to the WaitGroup, and when we use the `Done()` method, we subtract one.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它只等待必要的时间，然后才退出应用程序。记住，当我们使用 `Add(value)` 方法时，我们向 WaitGroup 添加实体，当我们使用 `Done()`
    方法时，我们减去一个。
- en: 'Actually, the `Add` function takes a delta value, so the following code is
    equivalent to the previous:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Add` 函数接受一个增量值，所以下面的代码与之前的代码等价：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this case, we added `1` before launching the Goroutine and we added `-1`
    (subtracted 1) at the end of it. If we know in advance how many Goroutines we
    are going to launch, we can also call the `Add` method just once:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在启动 Goroutine 之前添加了 `1`，并在其末尾添加了 `-1`（减去 1）。如果我们事先知道将要启动多少个 Goroutines，我们也可以只调用一次
    `Add` 方法：
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we are going to create five Goroutines (as stated in the `goroutines`
    variable). We know it in advance, so we simply add them all to the WaitGroup.
    We are then going to launch the same amount of `goroutine` variables by using
    a `for` loop. Every time one Goroutine finishes, it calls the `Done()` method
    of the WaitGroup that is effectively waiting at the end of the main loop.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们打算创建五个 Goroutines（如 `goroutines` 变量所述）。我们事先知道这一点，所以我们只需将它们全部添加到 WaitGroup
    中。然后，我们将使用 `for` 循环启动相同数量的 `goroutine` 变量。每次一个 Goroutine 完成，它就会调用 WaitGroup 的
    `Done()` 方法，这个 WaitGroup 正在主循环的末尾等待。
- en: 'Again, in this case, the code reaches the end of the `main` function before
    all Goroutines are launched (if any), and the WaitGroup makes the execution of
    the main flow wait until all `Done` messages are called. Let''s run this small
    program:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在这种情况下，代码在所有 Goroutines（如果有）启动之前就已经到达了 `main` 函数的末尾，WaitGroup 使得主流程的执行等待直到所有
    `Done` 消息都被调用。让我们运行这个小程序：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We haven''t mentioned it before, but we have passed the iteration index to
    each Goroutine as the parameter `GoroutineID` to print it with the message `Hello
    goroutines!` You might also have noticed that the Goroutines aren''t executed
    in order. Of course! We are dealing with a scheduler that doesn''t guarantee the
    order of execution of the Goroutines. This is something to keep in mind when programming
    concurrent applications. In fact, if we execute it again, we won''t necessarily
    get the same order of output:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有提到，但我们已经将迭代索引传递给每个 Goroutine 作为参数 `GoroutineID`，以便用消息 `Hello goroutines!`
    打印它。你可能也注意到了，Goroutines 并不是按顺序执行的。当然！我们正在处理一个不保证 Goroutines 执行顺序的调度器。这是在编写并发应用程序时需要注意的事情。事实上，如果我们再次执行它，我们不一定能得到相同的输出顺序：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
