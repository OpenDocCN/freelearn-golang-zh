- en: WaitGroups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'WaitGroup comes in the synchronization package (the `sync` package) to help
    us synchronize many concurrent Goroutines. It works very easily--every time we
    have to wait for one Goroutine to finish, we add `1` to the group, and once all
    of them are added, we ask the group to wait. When the Goroutine finishes, it says
    `Done` and the WaitGroup will take one from the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is the simplest possible example of a WaitGroup. First, we created a variable
    to hold it called the `wait` variable. Next, before launching the new Goroutine,
    we say to the WaitGroup `hey, you'll have to wait for one thing to finish` by
    using the `wait.Add(1)` method. Now we can launch the `1` that the WaitGroup has
    to wait for, which in this case is the previous Goroutine that prints `Hello World`
    and says `Done` (by using the `wait.Done()` method) at the end of the Goroutine.
    Finally, we indicate to the WaitGroup to wait. We have to remember that the function
    `wait.Wait()` was probably executed before the Goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the code again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now it just waits the necessary time and not one millisecond more before exiting
    the application. Remember that when we use the `Add(value)` method, we add entities
    to the WaitGroup, and when we use the `Done()` method, we subtract one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, the `Add` function takes a delta value, so the following code is
    equivalent to the previous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we added `1` before launching the Goroutine and we added `-1`
    (subtracted 1) at the end of it. If we know in advance how many Goroutines we
    are going to launch, we can also call the `Add` method just once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are going to create five Goroutines (as stated in the `goroutines`
    variable). We know it in advance, so we simply add them all to the WaitGroup.
    We are then going to launch the same amount of `goroutine` variables by using
    a `for` loop. Every time one Goroutine finishes, it calls the `Done()` method
    of the WaitGroup that is effectively waiting at the end of the main loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, in this case, the code reaches the end of the `main` function before
    all Goroutines are launched (if any), and the WaitGroup makes the execution of
    the main flow wait until all `Done` messages are called. Let''s run this small
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We haven''t mentioned it before, but we have passed the iteration index to
    each Goroutine as the parameter `GoroutineID` to print it with the message `Hello
    goroutines!` You might also have noticed that the Goroutines aren''t executed
    in order. Of course! We are dealing with a scheduler that doesn''t guarantee the
    order of execution of the Goroutines. This is something to keep in mind when programming
    concurrent applications. In fact, if we execute it again, we won''t necessarily
    get the same order of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
