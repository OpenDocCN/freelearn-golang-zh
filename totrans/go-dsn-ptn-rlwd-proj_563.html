<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Callbacks" id="45GEO1-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec057" class="calibre1"/>Callbacks</h1></div></div></div><p class="calibre10">Now that we know how to use WaitGroups, we can also introduce the concept of callbacks. If you have ever worked with languages like JavaScript that use them extensively, this section will be familiar to you. A callback is an anonymous function that will be executed within the context of a different function.</p><p class="calibre10">For example, we want to write a function to convert a string to uppercase, as well as making it asynchronous. How do we write this function so that we can work with callbacks? There's a little trick-we can have have a function that takes a string and returns a string:</p><pre class="programlisting">func toUpperSync(word string) string { 
  //Code will go here 
} 
</pre><p class="calibre10">So take the returning type of this function (a string) and put it as the second parameter in an anonymous function, as shown here:</p><pre class="programlisting">func toUpperSync(word string, f func(string)) { 
  //Code will go here 
} 
</pre><p class="calibre10">Now, the <code class="email">toUpperSync</code> function returns nothing, but also takes a function that, by coincidence, also takes a string. We can execute this function with the result we will usually return.</p><pre class="programlisting">func toUpperSync(word string, f func(string)) { 
  f(strings.ToUpper(word)) 
} 
</pre><p class="calibre10">We execute the <code class="email">f</code> function with the result of calling the <code class="email">strings.ToUpper</code> method with the provided word (which returns the word <code class="email">parameter</code> in uppercase). Let's write the <code class="email">main</code> function too:</p><pre class="programlisting">package main 
 
import ( 
  "fmt" 
  "strings" 
) 
 
func main() { 
  toUpperSync("Hello Callbacks!", func(v string) {   
    fmt.Printf("Callback: %s\n", v) }) 
} 
 
func toUpperSync(word string, f func(string)) { 
  f(strings.ToUpper(word)) 
} 
</pre><p class="calibre10">In our main code, we have defined our callback. As you can see, we passed the test <code class="email">Hello Callbacks!</code> to convert it to uppercase. Next we pass the callback to be executed with the result of passing our string to uppercase. In this case, we simply print the text in the console with the text <code class="email">Callback</code> in front of it. When we execute this code, we get the following result:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go</strong></span>
<span class="strong"><strong class="calibre2">Callback: HELLO CALLBACKS!</strong></span>
</pre><p class="calibre10">Strictly speaking, this is a synchronous callback. To make it asynchronous we have to introduce some concurrent handling:</p><pre class="programlisting">package main 
import ( 
  "fmt" 
  "strings" 
  "sync" 
) 
 
var wait sync.WaitGroup 
 
func main() { 
  wait.Add(1) 
 
  toUpperAsync("Hello Callbacks!", func(v string) { 
    fmt.Printf("Callback: %s\n", v) 
    wait.Done() 
  }) 
 
  println("Waiting async response...") 
  wait.Wait() 
} 
 
func toUpperAsync(word string, f func(string)) { 
  go func(){ 
    f(strings.ToUpper(word)) 
  }() 
} 
</pre><p class="calibre10">This is the same code executed asynchronously. We use WaitGroups to handle concurrency (we will see later that channels can also be used for this). Now, our function <code class="email">toUpperAsync</code> is, as its name implies, asynchronous. We launched the callback in a different Goroutine by using the keyword <code class="email">go</code> when calling the callback. We write a small message to show the ordering nature of the concurrent execution more precisely. We wait until the callback signals that it's finished and we can exit the program safely. When we execute this, we get the following result:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go </strong></span>

<span class="strong"><strong class="calibre2">Waiting async response...</strong></span>
<span class="strong"><strong class="calibre2">Callback: HELLO CALLBACKS!</strong></span>
</pre><p class="calibre10">As you can see, the program reaches the end of the <code class="email">main</code> function before executing the callback in the <code class="email">toUpperAsync</code> function. This pattern brings many possibilities, but leaves us open to one big problem called callback hell.</p></div></body></html>