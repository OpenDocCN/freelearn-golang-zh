- en: Callbacks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Callbacks
- en: Now that we know how to use WaitGroups, we can also introduce the concept of
    callbacks. If you have ever worked with languages like JavaScript that use them
    extensively, this section will be familiar to you. A callback is an anonymous
    function that will be executed within the context of a different function.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何使用 WaitGroups，我们也可以引入回调的概念。如果你曾经使用过像 JavaScript 这样的语言，这些语言广泛使用回调，那么这一节对你来说将会很熟悉。回调是一个匿名函数，它将在另一个函数的上下文中执行。
- en: 'For example, we want to write a function to convert a string to uppercase,
    as well as making it asynchronous. How do we write this function so that we can
    work with callbacks? There''s a little trick-we can have have a function that
    takes a string and returns a string:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们想要编写一个函数将字符串转换为大写，同时使其异步。我们如何编写这个函数以便我们可以使用回调？有一个小技巧——我们可以有一个函数，它接受一个字符串并返回一个字符串：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So take the returning type of this function (a string) and put it as the second
    parameter in an anonymous function, as shown here:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将这个函数的返回类型（一个字符串）作为匿名函数的第二个参数，如下所示：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, the `toUpperSync` function returns nothing, but also takes a function that,
    by coincidence, also takes a string. We can execute this function with the result
    we will usually return.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`toUpperSync` 函数既不返回任何内容，也接受一个函数，巧合的是，这个函数也接受一个字符串。我们可以使用我们通常将返回的结果来执行这个函数。
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We execute the `f` function with the result of calling the `strings.ToUpper`
    method with the provided word (which returns the word `parameter` in uppercase).
    Let''s write the `main` function too:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用调用 `strings.ToUpper` 方法（它返回大写的 `parameter` 单词）的结果来执行 `f` 函数。让我们也写一下 `main`
    函数：
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In our main code, we have defined our callback. As you can see, we passed the
    test `Hello Callbacks!` to convert it to uppercase. Next we pass the callback
    to be executed with the result of passing our string to uppercase. In this case,
    we simply print the text in the console with the text `Callback` in front of it.
    When we execute this code, we get the following result:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主代码中，我们定义了我们的回调函数。正如你所见，我们传递了测试 `Hello Callbacks!` 来将其转换为大写。接下来，我们将回调函数与将我们的字符串转换为大写的操作结果一起执行。在这种情况下，我们只是在控制台前加上文本
    `Callback` 并打印文本。当我们执行此代码时，我们得到以下结果：
- en: '[PRE4]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Strictly speaking, this is a synchronous callback. To make it asynchronous
    we have to introduce some concurrent handling:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，这是一个同步回调。为了使其异步，我们必须引入一些并发处理：
- en: '[PRE5]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is the same code executed asynchronously. We use WaitGroups to handle
    concurrency (we will see later that channels can also be used for this). Now,
    our function `toUpperAsync` is, as its name implies, asynchronous. We launched
    the callback in a different Goroutine by using the keyword `go` when calling the
    callback. We write a small message to show the ordering nature of the concurrent
    execution more precisely. We wait until the callback signals that it''s finished
    and we can exit the program safely. When we execute this, we get the following
    result:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是异步执行的同一段代码。我们使用 WaitGroups 来处理并发（我们稍后会看到通道也可以用于此）。现在，我们的 `toUpperAsync` 函数，正如其名称所暗示的，是异步的。我们在调用回调时使用关键字
    `go` 在不同的 Goroutine 中启动了回调。我们写了一条小消息来更精确地显示并发执行的顺序性。我们等待回调发出完成信号，然后我们可以安全地退出程序。当我们执行这个操作时，我们得到以下结果：
- en: '[PRE6]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, the program reaches the end of the `main` function before executing
    the callback in the `toUpperAsync` function. This pattern brings many possibilities,
    but leaves us open to one big problem called callback hell.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，程序在执行 `toUpperAsync` 函数中的回调之前，就已经到达了 `main` 函数的末尾。这种模式带来了许多可能性，但同时也给我们留下了一个大问题，称为回调地狱。
