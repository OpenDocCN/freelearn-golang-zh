- en: Mutexes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 互斥锁
- en: If you are working with concurrent applications, you have to deal with more
    than one resource potentially accessing some memory location. This is usually
    called **race condition**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理并发应用程序，你必须处理多个资源可能访问某些内存位置的情况。这通常被称为**竞态条件**。
- en: In simpler terms, a race condition is similar to that moment where two people
    try to get the last piece of pizza at exactly the same time--their hands collide.
    Replace the pizza with a variable and their hands with Goroutines and we'll have
    a perfect analogy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 用更简单的话来说，竞态条件就像两个人试图同时拿到最后一片披萨的那一刻——他们的手撞到了一起。把披萨换成变量，把他们的手换成Goroutines，我们就能找到一个完美的类比。
- en: There is one character at the dinner table to solve this issues--a father or
    mother. They have kept the pizza on a different table and we have to ask for permission
    to stand up before getting our slice of pizza. It doesn't matter if all the kids
    ask at the same time--they will only allow one kid to stand.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在餐桌上有一个角色可以解决这个问题——父亲或母亲。他们把披萨放在另一张桌子上，我们必须在拿到披萨片之前请求许可站起来。无论所有孩子是否同时请求——他们只会允许一个孩子站起来。
- en: Well, a mutex is like our parents. They'll control who can access the pizza--I
    mean, a variable--and they won't allow anyone else to access it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，互斥锁就像我们的父母。他们会控制谁可以访问披萨——我的意思是，一个变量——并且不允许其他人访问它。
- en: To use a mutex, we have to actively lock it; if it's already locked (another
    Goroutine is using it), we'll have to wait until it's unlocked again. Once we
    get access to the mutex, we can lock it again, do whatever modifications are needed,
    and unlock it again. We'll look at this using an example.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用互斥锁，我们必须主动锁定它；如果它已经被锁定（另一个Goroutine正在使用它），我们必须等待它再次解锁。一旦我们获得对互斥锁的访问权限，我们就可以再次锁定它，进行所需的任何修改，然后再次解锁。我们将通过一个例子来查看这一点。
