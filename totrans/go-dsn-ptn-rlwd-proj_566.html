<html><head></head><body>
<div class="book" title="Mutexes">
<div class="book" title="An example with mutexes - concurrent counter"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec0202" class="calibre1"/>An example with mutexes - concurrent counter</h2></div></div></div><p class="calibre10">Mutexes are widely used in concurrent programming. Maybe not so much in Go because it has a more idiomatic way of concurrent programming in its use of channels, but it's worth seeing how they work for the situations where channels simply don't fit so well.</p><p class="calibre10">For our example, we are going to develop a small concurrent counter. This counter will add one to an integer field in a <code class="email">Counter</code> type. This should be done in a concurrent-safe way.</p><p class="calibre10">Our <code class="email">Counter</code> structure is defined like this:</p><pre class="programlisting">type Counter struct { 
  sync.Mutex 
  value int 
} 
</pre><p class="calibre10">The <code class="email">Counter</code> structure has a field of <code class="email">int</code> type that stores the current value of the count. It also embeds the <code class="email">Mutex</code> type from the <code class="email">sync</code> package. Embedding this field will allow us to lock and unlock the entire structure without actively calling a specific field.</p><p class="calibre10">Our <code class="email">main</code> function launches 10 Goroutines that try to add one to the field value of <code class="email">Counter</code> structure. All of this is done concurrently:</p><pre class="programlisting">package main 
 
import ( 
  "sync" 
  "time" 
) 
 
func main() { 
  counter := Counter{} 
 
  for i := 0; i &lt; 10; i++ { 
    go func(i int) { 
      counter.Lock() 
      counter.value++ 
      defer counter.Unlock() 
    }(i) 
  } 
  time.Sleep(time.Second) 
 
  counter.Lock() 
  defer counter.Unlock() 
 
  println(counter.value) 
} 
</pre><p class="calibre10">We have created a type called <code class="email">Counter</code>. Using a <code class="email">for</code> loop, we have launched a total of 10 Goroutines, as we saw in the <span class="strong"><em class="calibre11">Anonymous functions launched as new Goroutines</em></span> section. But inside every Goroutine, we are locking the counter so that no more Goroutines can access it, adding one to the field value, and unlocking it again so others can access it.</p><p class="calibre10">Finally, we'll print the value held by the counter. It must be 10 because we have launched 10 Goroutines.</p><p class="calibre10">But how can we know that this program is thread safe? Well, Go comes with a very handy built-in feature called the "race detector".</p></div></div></body></html>