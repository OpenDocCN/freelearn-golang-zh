- en: An example with mutexes - concurrent counter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mutexes are widely used in concurrent programming. Maybe not so much in Go because
    it has a more idiomatic way of concurrent programming in its use of channels,
    but it's worth seeing how they work for the situations where channels simply don't
    fit so well.
  prefs: []
  type: TYPE_NORMAL
- en: For our example, we are going to develop a small concurrent counter. This counter
    will add one to an integer field in a `Counter` type. This should be done in a
    concurrent-safe way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Counter` structure is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `Counter` structure has a field of `int` type that stores the current value
    of the count. It also embeds the `Mutex` type from the `sync` package. Embedding
    this field will allow us to lock and unlock the entire structure without actively
    calling a specific field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `main` function launches 10 Goroutines that try to add one to the field
    value of `Counter` structure. All of this is done concurrently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have created a type called `Counter`. Using a `for` loop, we have launched
    a total of 10 Goroutines, as we saw in the *Anonymous functions launched as new
    Goroutines* section. But inside every Goroutine, we are locking the counter so
    that no more Goroutines can access it, adding one to the field value, and unlocking
    it again so others can access it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll print the value held by the counter. It must be 10 because we
    have launched 10 Goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: But how can we know that this program is thread safe? Well, Go comes with a
    very handy built-in feature called the "race detector".
  prefs: []
  type: TYPE_NORMAL
