- en: An example with mutexes - concurrent counter
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以下是一个使用互斥锁的示例 - 并发计数器
- en: Mutexes are widely used in concurrent programming. Maybe not so much in Go because
    it has a more idiomatic way of concurrent programming in its use of channels,
    but it's worth seeing how they work for the situations where channels simply don't
    fit so well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁在并发编程中被广泛使用。也许在Go中不是那么多，因为Go在通道的使用上提供了更符合习惯的并发编程方式，但了解它们的工作原理对于通道不适合的情况是很有价值的。
- en: For our example, we are going to develop a small concurrent counter. This counter
    will add one to an integer field in a `Counter` type. This should be done in a
    concurrent-safe way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将开发一个小型的并发计数器。这个计数器将向 `Counter` 类型中的整数字段加一。这应该以线程安全的方式进行。
- en: 'Our `Counter` structure is defined like this:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Counter` 结构体定义如下：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Counter` structure has a field of `int` type that stores the current value
    of the count. It also embeds the `Mutex` type from the `sync` package. Embedding
    this field will allow us to lock and unlock the entire structure without actively
    calling a specific field.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter` 结构体有一个 `int` 类型的字段，用于存储当前计数值。它还嵌入了 `sync` 包中的 `Mutex` 类型。嵌入这个字段将允许我们在不主动调用特定字段的情况下锁定和解锁整个结构体。'
- en: 'Our `main` function launches 10 Goroutines that try to add one to the field
    value of `Counter` structure. All of this is done concurrently:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `main` 函数启动了10个Goroutines，这些Goroutines尝试将 `Counter` 结构体的字段值加一。所有这些操作都是并发的：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have created a type called `Counter`. Using a `for` loop, we have launched
    a total of 10 Goroutines, as we saw in the *Anonymous functions launched as new
    Goroutines* section. But inside every Goroutine, we are locking the counter so
    that no more Goroutines can access it, adding one to the field value, and unlocking
    it again so others can access it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `Counter` 的类型。使用 `for` 循环，我们启动了总共10个Goroutines，正如我们在 *作为新Goroutines启动的匿名函数*
    部分所看到的。但在每个Goroutine内部，我们锁定计数器，以确保没有更多的Goroutines可以访问它，将字段值加一，然后再次解锁，以便其他人可以访问它。
- en: Finally, we'll print the value held by the counter. It must be 10 because we
    have launched 10 Goroutines.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将打印计数器的值。它必须是10，因为我们启动了10个Goroutines。
- en: But how can we know that this program is thread safe? Well, Go comes with a
    very handy built-in feature called the "race detector".
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何知道这个程序是线程安全的呢？嗯，Go 语言自带一个非常实用的内置功能，称为“竞态检测器”。
