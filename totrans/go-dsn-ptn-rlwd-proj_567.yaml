- en: Presenting the race detector
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示竞态条件检测器
- en: We already know what a race condition is. To recap, it is used when two processes
    try to access the same resource at the same time with one or more writing operations
    (both processes writing or one process writing while the other reads) involved
    at that precise moment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道什么是竞态条件。为了回顾，当两个进程在那一刻尝试同时访问同一资源，并且涉及一个或多个写操作（两个进程都在写或一个进程在写而另一个在读取）时，就会使用它。
- en: 'Go has a very handy tool to help diagnose race conditions, that you can run
    in your tests or your main application directly. So let''s reuse the example we
    just wrote for the *mutexes* section and run it with the race detector. This is
    as simple as adding the `-race` command-line flag to the command execution of
    our program:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go有一个非常方便的工具可以帮助诊断竞态条件，你可以在测试或主应用程序中直接运行它。所以，让我们重用我们刚才为*互斥锁*部分编写的示例，并使用竞态条件检测器运行它。这只需要将`-race`命令行标志添加到程序命令执行中：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Well, not very impressive is it? But in fact it is telling us that it has not
    detected a potential race condition in the code of this program. Let''s make the
    detector of `-race` flag warn us of a possible race condition by not locking `counter`
    before we modify it:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这并不那么令人印象深刻，对吧？但实际上，它告诉我们，它没有在程序代码中检测到潜在的竞态条件。让我们通过在修改`counter`之前不锁定它来让`-race`标志的检测器警告我们可能存在的竞态条件：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside the `for` loop, comment the `Lock` and `Unlock` calls before and after
    adding `1` to the field value. This will introduce a race condition. Let''s run
    the same program again with the race flag activated:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中，在将`1`加到字段值之前和之后，注释掉`Lock`和`Unlock`调用。这将引入一个竞态条件。让我们再次运行带有激活的竞态条件的相同程序：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'I have reduced the output a bit to see things more clearly. We can see a big,
    uppercase message reading `WARNING: DATA RACE`. But this output is very easy to
    reason with. First, it is telling us that some memory position represented by
    *line 19* on our `main.go` file is reading some variable. But there is also a
    write operation in *line 19* of the same file!'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '我稍微减少了输出，以便更清晰地看到内容。我们可以看到一个大的、大写的信息显示`WARNING: DATA RACE`。但这个输出很容易理解。首先，它告诉我们，在`main.go`文件的*第19行*表示的某个内存位置正在读取某个变量。但同一文件的*第19行*也有写操作！'
- en: This is because a "`++`" operation requires a read of the current value and
    a write to add one to it. That's why the race condition is in the same line, because
    every time it's executed it reads and writes the field in the `Counter` structure.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为"`++`"操作需要读取当前值并将其加一。这就是为什么竞态条件在同一行，因为每次执行时都会读取并写入`Counter`结构中的字段。
- en: 'But let''s keep in mind that the race detector works at runtime. It doesn''t
    analyze our code statically! What does it mean? It means that we can have a potential
    race condition in our design that the race detector will not detect. For example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们记住，竞态条件检测器是在运行时工作的。它不会静态分析我们的代码！这意味着什么？这意味着我们可能在我们设计中有一个潜在的竞态条件，而竞态条件检测器将无法检测到。例如：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will leave the code as shown in the preceding example. We will take all
    locks and unlocks from the code and launch a single Goroutine to update the `value`
    field:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保留前面示例中的代码。我们将从代码中移除所有的加锁和解锁操作，并启动一个单独的Goroutine来更新`value`字段：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'No warnings, so the code is correct. Well, we know, by design, it''s not. We
    can raise the number of Goroutines executed to two and see what happens:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 没有警告，所以代码是正确的。然而，我们知道，按照设计，它并不是。我们可以将执行的Goroutine数量提高到两个，看看会发生什么：
- en: '[PRE5]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s execute the program again:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次执行程序：
- en: '[PRE6]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now yes, the race condition is detected. But what if we reduce the number of
    processors in use to just one? Will we have a race condition too?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是的，检测到了竞态条件。但如果我们减少使用的处理器数量到只有一个呢？我们也会出现竞态条件吗？
- en: '[PRE7]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It seems that no race condition has been detected. This is because the scheduler
    executed one Goroutine first and then the other, so, finally, the race condition
    didn't occur. But with a higher number of Goroutines it will also warn us about
    a race condition, even using only one core.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来没有检测到竞态条件。这是因为调度器首先执行了一个Goroutine，然后才是另一个，所以最终没有发生竞态条件。但是，如果Goroutine的数量更多，它也会警告我们存在竞态条件，即使只使用一个核心。
- en: So, the race detector can help us to detect race conditions that are happening
    in our code, but it won't protect us from a bad design that is not immediately
    executing race conditions. A very useful feature that can save us from lots of
    headaches.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，竞态条件检测器可以帮助我们检测代码中正在发生的竞态条件，但它不会保护我们免受那些不会立即执行竞态条件的不良设计。这是一个非常有用的功能，可以让我们避免很多头疼的问题。
