<html><head></head><body>
<div class="book" title="Channels">
<div class="book" title="Our first channel"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec0204" class="calibre1"/>Our first channel</h2></div></div></div><p class="calibre10">Working with many Goroutines seems pretty difficult if we can't create some synchronization between them. The order of execution could be irrelevant as soon as they are synchronized. Channels are the second key feature to write concurrent applications in Go.</p><p class="calibre10">A TV channel in real life is something that connects an emission (from a studio) to millions of TVs (the receivers). Channels in Go work in a similar fashion. One or more Goroutines can work as emitters, and one or more Goroutine can act as receivers.</p><p class="calibre10">One more thing channels, by default, block the execution of Goroutines until something is received. It is asÂ if our favourite TV show delays the emission until we turn the TV on so we don't miss anything.</p><p class="calibre10">How is this done in Go?</p><pre class="programlisting">package main 
 
import "fmt" 
 
func main() { 
  channel := make(chan string) 
  go func() { 
    channel &lt;- "Hello World!" 
  }() 
 
  message := &lt;-channel 
  fmt.Println(message) 
} 
</pre><p class="calibre10">To create channels in Go, we use the same syntax that we use to create slices. The <code class="email">make</code> keyword is used to create a channel, and we have to pass the keyword <code class="email">chan</code> and the type that the channel will transport, in this case, strings. With this, we have a blocking channel with the name <code class="email">channel</code>. Next, we launch a Goroutines that sends the message <code class="email">Hello World!</code> to the channel. This is indicated by the intuitive arrow that shows the flow--the <code class="email">Hello World!</code> text going to (<code class="email">&lt;-</code>) a channel. This works like an assignment in a variable, so we can only pass something to a channel by first writing the channel, then the arrow, and finally the value to pass. We cannot write <code class="email">"Hello World!" -&gt; channel</code>.</p><p class="calibre10">As we mentioned earlier, this channel is blocking the execution of Gorountines until a message is received. In this case, the execution of the <code class="email">main</code> function is stopped until the message from the launched Goroutines reaches the other end of the channel in the line <code class="email">message := &lt;-channel</code>. In this case, the arrow points in the same direction, but it's placed before the channel, indicating that the data is being extracted from the channel and assigned to a new variable called <code class="email">message</code> (using the new assignment "<code class="email">:=</code>" operator).</p><p class="calibre10">In this case, we don't need to use a WaitGroup to synchronize the <code class="email">main</code> function with the created Goroutines, as the default nature of channels is to block until data is received. But does it work the other way around? If there is no receiver when the Goroutine sends the message, does it continue? Let's edit this example to see this:</p><pre class="programlisting">package main 
 
import ( 
  "fmt" 
  "time" 
) 
 
func main() { 
  channel := make(chan string) 
 
  var waitGroup sync.WaitGroup 
 
  waitGroup.Add(1) 
  go func() { 
    channel &lt;- "Hello World!" 
    println("Finishing goroutine") 
    waitGroup.Done() 
  }() 
 
  time.Sleep(time.Second) 
  message := &lt;-channel 
  fmt.Println(message) 
  waitGroup.Wait() 
} 
</pre><p class="calibre10">We are going to use the <code class="email">Sleep</code> function again. In this case, we print a message when the Goroutine is finished. The big difference is in the <code class="email">main</code> function. Now we wait one second before we listen to the channel for data:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go</strong></span>

<span class="strong"><strong class="calibre2">Finishing goroutine</strong></span>
<span class="strong"><strong class="calibre2">Hello World!</strong></span>
</pre><p class="calibre10">The output can differ because, again, there are no guarantees in the order of execution, but now we can see that no message is printed until one second has passed. After the initial delay, we start listening to the channel, take the data, and print it. So the emitter also has to wait for a cue from the other side of the channel to continue its execution.</p><p class="calibre10">To recap, channels are ways to communicate between Goroutines by sending data through one end and receiving it at the other (like a pipe). In their default state, an emitter Goroutine will block its execution until a receiver Goroutine takes the data. The same goes for a receiver Goroutine, which will block until some emitter sends data through the channel. So you can have passive listeners (waiting for data) or passive emitters (waiting for listeners).</p></div></div></body></html>