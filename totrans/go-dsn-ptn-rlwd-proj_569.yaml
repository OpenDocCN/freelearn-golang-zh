- en: Our first channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with many Goroutines seems pretty difficult if we can't create some
    synchronization between them. The order of execution could be irrelevant as soon
    as they are synchronized. Channels are the second key feature to write concurrent
    applications in Go.
  prefs: []
  type: TYPE_NORMAL
- en: A TV channel in real life is something that connects an emission (from a studio)
    to millions of TVs (the receivers). Channels in Go work in a similar fashion.
    One or more Goroutines can work as emitters, and one or more Goroutine can act
    as receivers.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing channels, by default, block the execution of Goroutines until
    something is received. It is asÂ if our favourite TV show delays the emission until
    we turn the TV on so we don't miss anything.
  prefs: []
  type: TYPE_NORMAL
- en: How is this done in Go?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To create channels in Go, we use the same syntax that we use to create slices.
    The `make` keyword is used to create a channel, and we have to pass the keyword
    `chan` and the type that the channel will transport, in this case, strings. With
    this, we have a blocking channel with the name `channel`. Next, we launch a Goroutines
    that sends the message `Hello World!` to the channel. This is indicated by the
    intuitive arrow that shows the flow--the `Hello World!` text going to (`<-`) a
    channel. This works like an assignment in a variable, so we can only pass something
    to a channel by first writing the channel, then the arrow, and finally the value
    to pass. We cannot write `"Hello World!" -> channel`.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, this channel is blocking the execution of Gorountines
    until a message is received. In this case, the execution of the `main` function
    is stopped until the message from the launched Goroutines reaches the other end
    of the channel in the line `message := <-channel`. In this case, the arrow points
    in the same direction, but it's placed before the channel, indicating that the
    data is being extracted from the channel and assigned to a new variable called
    `message` (using the new assignment "`:=`" operator).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we don''t need to use a WaitGroup to synchronize the `main` function
    with the created Goroutines, as the default nature of channels is to block until
    data is received. But does it work the other way around? If there is no receiver
    when the Goroutine sends the message, does it continue? Let''s edit this example
    to see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to use the `Sleep` function again. In this case, we print a message
    when the Goroutine is finished. The big difference is in the `main` function.
    Now we wait one second before we listen to the channel for data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output can differ because, again, there are no guarantees in the order of
    execution, but now we can see that no message is printed until one second has
    passed. After the initial delay, we start listening to the channel, take the data,
    and print it. So the emitter also has to wait for a cue from the other side of
    the channel to continue its execution.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, channels are ways to communicate between Goroutines by sending data
    through one end and receiving it at the other (like a pipe). In their default
    state, an emitter Goroutine will block its execution until a receiver Goroutine
    takes the data. The same goes for a receiver Goroutine, which will block until
    some emitter sends data through the channel. So you can have passive listeners
    (waiting for data) or passive emitters (waiting for listeners).
  prefs: []
  type: TYPE_NORMAL
