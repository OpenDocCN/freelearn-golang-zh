- en: Our first channel
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的第一个频道
- en: Working with many Goroutines seems pretty difficult if we can't create some
    synchronization between them. The order of execution could be irrelevant as soon
    as they are synchronized. Channels are the second key feature to write concurrent
    applications in Go.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法在它们之间创建一些同步，那么与许多 Goroutines 一起工作似乎相当困难。一旦它们同步，执行顺序可能就无关紧要了。频道是编写 Go 中并发应用程序的第二个关键特性。
- en: A TV channel in real life is something that connects an emission (from a studio)
    to millions of TVs (the receivers). Channels in Go work in a similar fashion.
    One or more Goroutines can work as emitters, and one or more Goroutine can act
    as receivers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 生活中的电视频道是将发射（来自工作室）连接到数百万台电视（接收器）的东西。Go 中的频道以类似的方式工作。一个或多个 Goroutines 可以作为发射器，一个或多个
    Goroutine 可以作为接收器。
- en: One more thing channels, by default, block the execution of Goroutines until
    something is received. It is as if our favourite TV show delays the emission until
    we turn the TV on so we don't miss anything.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一点，默认情况下，频道会阻塞 Goroutines 的执行，直到接收到某些东西。这就像我们最喜欢的电视剧在打开电视之前延迟发射，这样我们就不错过任何内容。
- en: How is this done in Go?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中是如何做到这一点的？
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To create channels in Go, we use the same syntax that we use to create slices.
    The `make` keyword is used to create a channel, and we have to pass the keyword
    `chan` and the type that the channel will transport, in this case, strings. With
    this, we have a blocking channel with the name `channel`. Next, we launch a Goroutines
    that sends the message `Hello World!` to the channel. This is indicated by the
    intuitive arrow that shows the flow--the `Hello World!` text going to (`<-`) a
    channel. This works like an assignment in a variable, so we can only pass something
    to a channel by first writing the channel, then the arrow, and finally the value
    to pass. We cannot write `"Hello World!" -> channel`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中创建频道时，我们使用与创建切片相同的语法。`make` 关键字用于创建频道，我们必须传递关键字 `chan` 和频道将要传输的类型，在这种情况下，是字符串。有了这个，我们就有一个名为
    `channel` 的阻塞频道。接下来，我们启动一个 Goroutines，将消息 `Hello World!` 发送到频道。这由直观的箭头指示，显示了流向--`Hello
    World!` 文本流向（`<-`）一个频道。这就像变量中的赋值一样，因此我们只能通过首先写入频道，然后是箭头，最后是传递的值来向频道传递某些内容。我们不能写
    `"Hello World!" -> channel`。
- en: As we mentioned earlier, this channel is blocking the execution of Gorountines
    until a message is received. In this case, the execution of the `main` function
    is stopped until the message from the launched Goroutines reaches the other end
    of the channel in the line `message := <-channel`. In this case, the arrow points
    in the same direction, but it's placed before the channel, indicating that the
    data is being extracted from the channel and assigned to a new variable called
    `message` (using the new assignment "`:=`" operator).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这个频道会阻塞 Goroutines 的执行，直到接收到消息。在这种情况下，`main` 函数的执行会停止，直到从启动的 Goroutines
    发送到频道另一端的消息在 `message := <-channel` 这一行达到。在这种情况下，箭头指向同一方向，但它放在频道之前，表示数据正在从频道中提取并分配给一个名为
    `message` 的新变量（使用新的赋值运算符 "`:=`"）。
- en: 'In this case, we don''t need to use a WaitGroup to synchronize the `main` function
    with the created Goroutines, as the default nature of channels is to block until
    data is received. But does it work the other way around? If there is no receiver
    when the Goroutine sends the message, does it continue? Let''s edit this example
    to see this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们不需要使用 WaitGroup 来同步 `main` 函数与创建的 Goroutines，因为频道默认的性质是阻塞，直到接收到数据。但是反过来呢？如果
    Goroutine 发送消息时没有接收者，它会继续吗？让我们编辑这个例子来看看：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We are going to use the `Sleep` function again. In this case, we print a message
    when the Goroutine is finished. The big difference is in the `main` function.
    Now we wait one second before we listen to the channel for data:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用 `Sleep` 函数。在这种情况下，当 Goroutine 完成时，我们打印一条消息。与 `main` 函数中的主要区别在于，现在我们在监听频道以获取数据之前等待一秒钟：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output can differ because, again, there are no guarantees in the order of
    execution, but now we can see that no message is printed until one second has
    passed. After the initial delay, we start listening to the channel, take the data,
    and print it. So the emitter also has to wait for a cue from the other side of
    the channel to continue its execution.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 输出可能不同，因为，同样，执行顺序没有保证，但现在我们可以看到，直到一秒钟过去之前，没有任何消息被打印出来。在初始延迟之后，我们开始监听频道，获取数据，并打印它。因此，发射器也必须等待来自频道另一侧的提示才能继续执行。
- en: To recap, channels are ways to communicate between Goroutines by sending data
    through one end and receiving it at the other (like a pipe). In their default
    state, an emitter Goroutine will block its execution until a receiver Goroutine
    takes the data. The same goes for a receiver Goroutine, which will block until
    some emitter sends data through the channel. So you can have passive listeners
    (waiting for data) or passive emitters (waiting for listeners).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，通道是goroutines之间通过一端发送数据并在另一端接收数据的方式进行通信的方式（就像管道一样）。在其默认状态下，一个发射器goroutine会阻塞其执行，直到接收器goroutine取走数据。对于接收器goroutine也是如此，它会阻塞直到某个发射器通过通道发送数据。因此，你可以有被动的监听者（等待数据）或被动的发射者（等待监听者）。
