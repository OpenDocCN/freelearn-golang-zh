<html><head></head><body>
<div class="book" title="Channels">
<div class="book" title="Buffered channels"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec0205" class="calibre1"/>Buffered channels</h2></div></div></div><p class="calibre10">A buffered channel works in a similar way to default unbuffered channels. You also pass and take values from them by using the arrows, but, unlike unbuffered channels, senders don't need to wait until some Goroutine picks the data that they are sending:</p><pre class="programlisting">package main 
 
import ( 
  "fmt" 
  "time" 
) 
 
func main() { 
  channel := make(chan string, 1) 
 
  go func() { 
    channel &lt;- "Hello World!" 
    println("Finishing goroutine") 
  }() 
 
  time.Sleep(time.Second) 
 
  message := &lt;-channel 
  fmt.Println(message) 
} 
</pre><p class="calibre10">This example is like the first example we used for channels, but now we have set the capacity of the channel to one in the <code class="email">make</code> statement. With this, we tell the compiler that this channel has a capacity of one string before getting blocked. So the first string doesn't block the emitter, but the second would. Let's run this example:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go</strong></span>

<span class="strong"><strong class="calibre2">Finishing goroutine</strong></span>
<span class="strong"><strong class="calibre2">Hello World!</strong></span>
</pre><p class="calibre10">Now we can run this small program as many times as we want--the output will always be in the same order. This time, we have launched the concurrent function and waited for one second. Previously, the anonymous function wouldn't continue until the second has passed and someone can pick the sent data. In this case, with a buffered channel, the data is held in the channel and frees the Goroutine to continue its execution. In this case, the Goroutine is always finishing before the wait time passes.</p><p class="calibre10">This new channel has a size of one, so a second message would block the Goroutine execution:</p><pre class="programlisting">package main 
 
import ( 
  "fmt" 
  "time" 
) 
 
func main() { 
  channel := make(chan string, 1) 
 
  go func() { 
    channel &lt;- "Hello World! 1" 
    channel &lt;- "Hello World! 2" 
    println("Finishing goroutine") 
  }() 
 
  time.Sleep(time.Second) 
 
  message := &lt;-channel 
  fmt.Println(message) 
} 
</pre><p class="calibre10">Here, we add a second <code class="email">Hello world! 2</code> message, and we provide itÂ with an index. In this case, the output of this program could be like the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go</strong></span>
<span class="strong"><strong class="calibre2">Hello World! 1</strong></span>
</pre><p class="calibre10">Indicating that we have just taken one message from the channel buffer, we have printed it, and the <code class="email">main</code> function finished before the launched Goroutine could finish. The Goroutine got blocked when sending the second message and couldn't continue until the other end took the first message. Then it prints it so quickly that it doesn't have time to print the message to show the ending of the Goroutine. If you keep executing the program on the console, sooner or later the scheduler will finish the Goroutine execution before the main thread.</p></div></div></body></html>