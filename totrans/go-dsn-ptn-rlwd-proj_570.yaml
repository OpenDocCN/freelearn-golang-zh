- en: Buffered channels
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓冲通道
- en: 'A buffered channel works in a similar way to default unbuffered channels. You
    also pass and take values from them by using the arrows, but, unlike unbuffered
    channels, senders don''t need to wait until some Goroutine picks the data that
    they are sending:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲通道的工作方式与默认的无缓冲通道类似。你同样通过使用箭头从它们中传递和取走值，但与无缓冲通道不同，发送者不需要等待某个Goroutine取走它们发送的数据：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This example is like the first example we used for channels, but now we have
    set the capacity of the channel to one in the `make` statement. With this, we
    tell the compiler that this channel has a capacity of one string before getting
    blocked. So the first string doesn''t block the emitter, but the second would.
    Let''s run this example:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子就像我们最初用于通道的第一个例子，但现在我们在`make`语句中将通道的容量设置为1。通过这种方式，我们告诉编译器在阻塞之前，这个通道有一个字符串的容量。所以第一个字符串不会阻塞发射者，但第二个会。让我们运行这个例子：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we can run this small program as many times as we want--the output will
    always be in the same order. This time, we have launched the concurrent function
    and waited for one second. Previously, the anonymous function wouldn't continue
    until the second has passed and someone can pick the sent data. In this case,
    with a buffered channel, the data is held in the channel and frees the Goroutine
    to continue its execution. In this case, the Goroutine is always finishing before
    the wait time passes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行这个小程序任意多次——输出结果总是按照相同的顺序。这次，我们启动了并发函数并等待了一秒钟。之前，匿名函数不会继续执行，直到秒数过去并且有人可以取走发送的数据。在这种情况下，使用带缓冲的通道，数据被保存在通道中，从而释放了Goroutine继续执行。在这种情况下，Goroutine总是在等待时间过去之前完成。
- en: 'This new channel has a size of one, so a second message would block the Goroutine
    execution:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新通道的大小为1，所以第二条消息会阻塞Goroutine的执行：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we add a second `Hello world! 2` message, and we provide it with an index.
    In this case, the output of this program could be like the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一条第二条“Hello world! 2”消息，并给它提供了一个索引。在这种情况下，这个程序的输出可能如下所示：
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Indicating that we have just taken one message from the channel buffer, we have
    printed it, and the `main` function finished before the launched Goroutine could
    finish. The Goroutine got blocked when sending the second message and couldn't
    continue until the other end took the first message. Then it prints it so quickly
    that it doesn't have time to print the message to show the ending of the Goroutine.
    If you keep executing the program on the console, sooner or later the scheduler
    will finish the Goroutine execution before the main thread.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 表明我们刚刚从通道缓冲区取走了一条消息，并打印了它，而`main`函数在启动的Goroutine完成之前就已经结束了。当发送第二条消息时，Goroutine被阻塞，直到另一端取走第一条消息。然后它打印得如此之快，以至于没有时间打印出表示Goroutine结束的消息。如果你在控制台上持续执行程序，迟早调度器会在主线程之前完成Goroutine的执行。
