- en: Buffered channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A buffered channel works in a similar way to default unbuffered channels. You
    also pass and take values from them by using the arrows, but, unlike unbuffered
    channels, senders don''t need to wait until some Goroutine picks the data that
    they are sending:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is like the first example we used for channels, but now we have
    set the capacity of the channel to one in the `make` statement. With this, we
    tell the compiler that this channel has a capacity of one string before getting
    blocked. So the first string doesn''t block the emitter, but the second would.
    Let''s run this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we can run this small program as many times as we want--the output will
    always be in the same order. This time, we have launched the concurrent function
    and waited for one second. Previously, the anonymous function wouldn't continue
    until the second has passed and someone can pick the sent data. In this case,
    with a buffered channel, the data is held in the channel and frees the Goroutine
    to continue its execution. In this case, the Goroutine is always finishing before
    the wait time passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This new channel has a size of one, so a second message would block the Goroutine
    execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we add a second `Hello world! 2` message, and we provide itÂ with an index.
    In this case, the output of this program could be like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Indicating that we have just taken one message from the channel buffer, we have
    printed it, and the `main` function finished before the launched Goroutine could
    finish. The Goroutine got blocked when sending the second message and couldn't
    continue until the other end took the first message. Then it prints it so quickly
    that it doesn't have time to print the message to show the ending of the Goroutine.
    If you keep executing the program on the console, sooner or later the scheduler
    will finish the Goroutine execution before the main thread.
  prefs: []
  type: TYPE_NORMAL
