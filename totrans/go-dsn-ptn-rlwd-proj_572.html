<html><head></head><body>
<div class="book" title="Channels">
<div class="book" title="The select statement"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec0207" class="calibre1"/>The select statement</h2></div></div></div><p class="calibre10">The select statement is also a key feature in Go. It is used to handle more than one channel input within a Goroutine. In fact, it opens lots of possibilities, and we will use it extensively in the following chapters.</p><p class="calibre10">
</p><div class="mediaobject"><img src="../images/00038.jpeg" alt="The select statement" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">
</p><p class="calibre10">In the <code class="email">select</code> structure, we ask the program to choose between one or more channels to receive their data. We can save this data in a variable and make something with it before finishing the select. The <code class="email">select</code> structure is just executed once; it doesn't matter if it is listening to more channels, it will be executed only once and the code will continue executing. If we want it to handle the same channels more than once, we have to put it in a <code class="email">for</code> loop.</p><p class="calibre10">We will make a small app that will send the message <code class="email">hello</code> and the message <code class="email">goodbye</code> to the same Goroutine, which will print them and exit if it doesn't receive anything else in five seconds.</p><p class="calibre10">First, we will make a generic function that sends a string over a channel:</p><pre class="programlisting">func sendString(ch chan&lt;- string, s string) { 
  ch &lt;- s 
} 
</pre><p class="calibre10">Now we can send a string over a channel by simply calling the <code class="email">sendString</code> method. It's time for the receiver. The receiver will take messages from both channels--the one that sends <code class="email">hello</code> messages and the one that sends <code class="email">goodbye</code> messages. You can also see this in the previous diagram:</p><pre class="programlisting">func receiver(helloCh, goodbyeCh &lt;-chan string, quitCh chan&lt;- bool) { 
  for { 
    select { 
    case msg := &lt;-helloCh: 
      println(msg) 
    case msg := &lt;-goodbyeCh: 
      println(msg) 
    case &lt;-time.After(time.Second * 2): 
      println("Nothing received in 2 seconds. Exiting") 
      quitCh &lt;- true 
      break 
    } 
  } 
} 
</pre><p class="calibre10">Let's start with the arguments. This function takes three channels--two receiving channels and one to send something through it. Then, it starts an infinite loop with the <code class="email">for</code> keyword. This way we can keep listening to both channels forever.</p><p class="calibre10">Inside the scope of <code class="email">select</code> block, we have to use a case for each channel we want to handle (have you realized how similar it is to the <code class="email">switch</code> statement?). Let's see the three cases step by step:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The first case takes the incoming data from the <code class="email">helloCh</code> argument and saves it in a variable called <code class="email">msg</code>. Then it prints the contents of this variable.</li><li class="listitem">The second case takes the incoming data from the <code class="email">goodbyeCh</code> argument and saves it in a variable called <code class="email">msg</code> too. Then it also prints the content of this variable.</li><li class="listitem">The third case is quite interesting. It calls the <code class="email">time</code> function. After that, if we check its signature, it accepts a time and duration value and returns a receiving channel. This receiving channel will receive a time, the value of <code class="email">time</code> after the specified duration has passed. In our example, we use the channel it returns as a timeout. Because the select is restarted after each handle, the timer is restarted too. This is a very simple way to set a timer to a Goroutine waiting for the response of one or many channels.</li></ul></div><p class="calibre10">Everything is ready for the <code class="email">main</code> function:</p><pre class="programlisting">package main 
import "time" 
 
func main() { 
  helloCh := make(chan string, 1) 
  goodbyeCh := make(chan string, 1) 
  quitCh := make(chan bool) 
  go receiver(helloCh, goodbyeCh, quitCh) 
 
  go sendString(helloCh, "hello!") 
 
  time.Sleep(time.Second) 
 
  go sendString(goodbyeCh, "goodbye!") 
  &lt;-quitCh 
} 
</pre><p class="calibre10">Again, step by step, we created the three channels that we'll need in this exercise. Then, we launched our <code class="email">receiver</code> function in a different Goroutine. This Goroutine is handled by Go's scheduler and our program continues. We launched a new Goroutine to send the message <code class="email">hello</code> to the <code class="email">helloCh</code> arguments. Again, this is going to occur eventually when the Go's scheduler decides.</p><p class="calibre10">Our program continues again and waits for a second. In this break, Go's scheduler will have time to execute the receiver and the first message (if it hasn't done so yet), so the <code class="email">hello!</code> message will appear on the console during the break.</p><p class="calibre10">A new message is sent over the <code class="email">goodbye</code> channel with the <code class="email">goodbye!</code> text in a new Goroutine, and our program continues again to a line where we wait for an incoming message in the <code class="email">quitCh</code> argument.</p><p class="calibre10">We have launched three Goroutines already--the receiver that it is still running, the first message that had finished when the message was handled by the <code class="email">select</code> statement, and the second message was been printed almost immediately and had finished too. So just the receiver is running at this moment, and if it doesn't receive any other message in the following two seconds, it will handle the incoming message from the <code class="email">time</code> structure. After <code class="email">channel</code> type, print a message to say that it is quitting, send a <code class="email">true</code> to the <code class="email">quitCh</code>, and break the infinite loop where it was looping.</p><p class="calibre10">Let's run this small app:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go</strong></span>

<span class="strong"><strong class="calibre2">hello!</strong></span>
<span class="strong"><strong class="calibre2">goodbye!</strong></span>
<span class="strong"><strong class="calibre2">Nothing received in 2 seconds. Exiting</strong></span>
</pre><p class="calibre10">The result  may not be very impressive, but the concept is clear. We can handle many incoming channels in the same Goroutine by using the select statement.</p></div></div></body></html>