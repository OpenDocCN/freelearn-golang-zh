- en: The select statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The select statement is also a key feature in Go. It is used to handle more
    than one channel input within a Goroutine. In fact, it opens lots of possibilities,
    and we will use it extensively in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '![The select statement](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the `select` structure, we ask the program to choose between one or more
    channels to receive their data. We can save this data in a variable and make something
    with it before finishing the select. The `select` structure is just executed once;
    it doesn't matter if it is listening to more channels, it will be executed only
    once and the code will continue executing. If we want it to handle the same channels
    more than once, we have to put it in a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: We will make a small app that will send the message `hello` and the message
    `goodbye` to the same Goroutine, which will print them and exit if it doesn't
    receive anything else in five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will make a generic function that sends a string over a channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can send a string over a channel by simply calling the `sendString`
    method. It''s time for the receiver. The receiver will take messages from both
    channels--the one that sends `hello` messages and the one that sends `goodbye`
    messages. You can also see this in the previous diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's start with the arguments. This function takes three channels--two receiving
    channels and one to send something through it. Then, it starts an infinite loop
    with the `for` keyword. This way we can keep listening to both channels forever.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the scope of `select` block, we have to use a case for each channel
    we want to handle (have you realized how similar it is to the `switch` statement?).
    Let''s see the three cases step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: The first case takes the incoming data from the `helloCh` argument and saves
    it in a variable called `msg`. Then it prints the contents of this variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second case takes the incoming data from the `goodbyeCh` argument and saves
    it in a variable called `msg` too. Then it also prints the content of this variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third case is quite interesting. It calls the `time` function. After that,
    if we check its signature, it accepts a time and duration value and returns a
    receiving channel. This receiving channel will receive a time, the value of `time`
    after the specified duration has passed. In our example, we use the channel it
    returns as a timeout. Because the select is restarted after each handle, the timer
    is restarted too. This is a very simple way to set a timer to a Goroutine waiting
    for the response of one or many channels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Everything is ready for the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Again, step by step, we created the three channels that we'll need in this exercise.
    Then, we launched our `receiver` function in a different Goroutine. This Goroutine
    is handled by Go's scheduler and our program continues. We launched a new Goroutine
    to send the message `hello` to the `helloCh` arguments. Again, this is going to
    occur eventually when the Go's scheduler decides.
  prefs: []
  type: TYPE_NORMAL
- en: Our program continues again and waits for a second. In this break, Go's scheduler
    will have time to execute the receiver and the first message (if it hasn't done
    so yet), so the `hello!` message will appear on the console during the break.
  prefs: []
  type: TYPE_NORMAL
- en: A new message is sent over the `goodbye` channel with the `goodbye!` text in
    a new Goroutine, and our program continues again to a line where we wait for an
    incoming message in the `quitCh` argument.
  prefs: []
  type: TYPE_NORMAL
- en: We have launched three Goroutines already--the receiver that it is still running,
    the first message that had finished when the message was handled by the `select`
    statement, and the second message was been printed almost immediately and had
    finished too. So just the receiver is running at this moment, and if it doesn't
    receive any other message in the following two seconds, it will handle the incoming
    message from the `time` structure. After `channel` type, print a message to say
    that it is quitting, send a `true` to the `quitCh`, and break the infinite loop
    where it was looping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run this small app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The result  may not be very impressive, but the concept is clear. We can handle
    many incoming channels in the same Goroutine by using the select statement.
  prefs: []
  type: TYPE_NORMAL
