- en: The select statement
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`select`语句'
- en: The select statement is also a key feature in Go. It is used to handle more
    than one channel input within a Goroutine. In fact, it opens lots of possibilities,
    and we will use it extensively in the following chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '`select`语句也是Go语言的一个关键特性。它用于在Goroutine中处理多个通道输入。实际上，它开辟了许多可能性，我们将在接下来的章节中广泛使用它。'
- en: '![The select statement](img/00038.jpeg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![select语句](img/00038.jpeg)'
- en: In the `select` structure, we ask the program to choose between one or more
    channels to receive their data. We can save this data in a variable and make something
    with it before finishing the select. The `select` structure is just executed once;
    it doesn't matter if it is listening to more channels, it will be executed only
    once and the code will continue executing. If we want it to handle the same channels
    more than once, we have to put it in a `for` loop.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在`select`结构中，我们要求程序在多个通道之间选择一个或多个通道来接收它们的数据。我们可以将这个数据保存在一个变量中，并在完成选择之前对它进行处理。`select`结构只执行一次；它不在乎它是否正在监听更多的通道，它只会执行一次，代码将继续执行。如果我们想让它处理相同的通道多次，我们必须将它放在一个`for`循环中。
- en: We will make a small app that will send the message `hello` and the message
    `goodbye` to the same Goroutine, which will print them and exit if it doesn't
    receive anything else in five seconds.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个小程序，它将向同一个Goroutine发送`hello`消息和`goodbye`消息，该Goroutine将打印它们，并在五秒钟内没有收到其他任何消息时退出。
- en: 'First, we will make a generic function that sends a string over a channel:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个通用的函数，通过通道发送字符串：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we can send a string over a channel by simply calling the `sendString`
    method. It''s time for the receiver. The receiver will take messages from both
    channels--the one that sends `hello` messages and the one that sends `goodbye`
    messages. You can also see this in the previous diagram:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过简单地调用`sendString`方法在通道上发送一个字符串。现在是接收者的时间。接收者将从两个通道接收消息——发送`hello`消息的通道和发送`goodbye`消息的通道。你也可以在之前的图中看到这一点：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's start with the arguments. This function takes three channels--two receiving
    channels and one to send something through it. Then, it starts an infinite loop
    with the `for` keyword. This way we can keep listening to both channels forever.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从参数开始。这个函数接受三个通道——两个接收通道和一个通过它发送东西的通道。然后，它使用`for`关键字启动一个无限循环。这样我们就可以永远地监听这两个通道。
- en: 'Inside the scope of `select` block, we have to use a case for each channel
    we want to handle (have you realized how similar it is to the `switch` statement?).
    Let''s see the three cases step by step:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在`select`块的作用域内，我们必须为每个我们想要处理的通道使用一个case（你有没有意识到它和`switch`语句多么相似？）。让我们一步一步地看看这三个case：
- en: The first case takes the incoming data from the `helloCh` argument and saves
    it in a variable called `msg`. Then it prints the contents of this variable.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种情况从`helloCh`参数接收传入的数据，并将其保存在一个名为`msg`的变量中。然后它打印这个变量的内容。
- en: The second case takes the incoming data from the `goodbyeCh` argument and saves
    it in a variable called `msg` too. Then it also prints the content of this variable.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种情况从`goodbyeCh`参数接收传入的数据，并将其保存在一个名为`msg`的变量中。然后它还打印这个变量的内容。
- en: The third case is quite interesting. It calls the `time` function. After that,
    if we check its signature, it accepts a time and duration value and returns a
    receiving channel. This receiving channel will receive a time, the value of `time`
    after the specified duration has passed. In our example, we use the channel it
    returns as a timeout. Because the select is restarted after each handle, the timer
    is restarted too. This is a very simple way to set a timer to a Goroutine waiting
    for the response of one or many channels.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种情况非常有趣。它调用了`time`函数。之后，如果我们检查它的签名，它接受一个时间和持续时间值，并返回一个接收通道。这个接收通道将接收一个时间，即在指定持续时间过后`time`的值。在我们的例子中，我们使用它返回的通道作为超时。因为每次处理之后select都会重新启动，计时器也会重新启动。这是一种非常简单的方法来为等待一个或多个通道响应的Goroutine设置计时器。
- en: 'Everything is ready for the `main` function:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都为`main`函数准备好了：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Again, step by step, we created the three channels that we'll need in this exercise.
    Then, we launched our `receiver` function in a different Goroutine. This Goroutine
    is handled by Go's scheduler and our program continues. We launched a new Goroutine
    to send the message `hello` to the `helloCh` arguments. Again, this is going to
    occur eventually when the Go's scheduler decides.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，一步一步地，我们创建了在这个练习中需要的三个通道。然后，我们在不同的Goroutine中启动了我们的`receiver`函数。这个Goroutine由Go的调度器处理，我们的程序继续运行。我们启动了一个新的Goroutine，将消息`hello`发送到`helloCh`参数。再次，这将在Go的调度器决定时最终发生。
- en: Our program continues again and waits for a second. In this break, Go's scheduler
    will have time to execute the receiver and the first message (if it hasn't done
    so yet), so the `hello!` message will appear on the console during the break.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序再次继续并等待一秒钟。在这个中断期间，Go的调度器将有时间执行接收器和第一个消息（如果尚未执行），所以`hello!`消息将在中断期间出现在控制台上。
- en: A new message is sent over the `goodbye` channel with the `goodbye!` text in
    a new Goroutine, and our program continues again to a line where we wait for an
    incoming message in the `quitCh` argument.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个新的Goroutine中通过`goodbye`通道发送了一条带有`goodbye!`文本的新消息，然后我们的程序再次继续到一个等待`quitCh`参数传入消息的行。
- en: We have launched three Goroutines already--the receiver that it is still running,
    the first message that had finished when the message was handled by the `select`
    statement, and the second message was been printed almost immediately and had
    finished too. So just the receiver is running at this moment, and if it doesn't
    receive any other message in the following two seconds, it will handle the incoming
    message from the `time` structure. After `channel` type, print a message to say
    that it is quitting, send a `true` to the `quitCh`, and break the infinite loop
    where it was looping.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经启动了三个Goroutines——仍在运行的接收器，当消息被`select`语句处理时完成的第一个消息，以及第二个消息几乎立即打印出来并完成。所以此刻只有接收器在运行，如果接下来两秒钟内没有接收到其他消息，它将处理来自`time`结构的传入消息。在`channel`类型之后，打印一条消息表示它正在退出，向`quitCh`发送一个`true`，并跳出它正在循环的无穷循环。
- en: 'Let''s run this small app:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个小应用程序：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The result  may not be very impressive, but the concept is clear. We can handle
    many incoming channels in the same Goroutine by using the select statement.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可能不会非常令人印象深刻，但概念是清晰的。我们可以通过使用select语句在同一个Goroutine中处理许多传入的通道。
