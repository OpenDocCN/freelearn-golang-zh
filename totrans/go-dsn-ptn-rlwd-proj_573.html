<html><head></head><body>
<div class="book" title="Channels">
<div class="book" title="Ranging over channels too!"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch08lvl2sec0208" class="calibre1"/>Ranging over channels too!</h2></div></div></div><p class="calibre10">The last feature about channels that we will see is ranging over channels. We are talking about the range keyword. We have used it extensively to range over lists, and we can use it to range over a channel too:</p><pre class="programlisting">package main 
 
import "time" 
 
func main() { 
  ch := make(chan int) 
 
  go func() { 
    ch &lt;- 1 
    time.Sleep(time.Second) 
 
    ch &lt;- 2 
 
    close(ch) 
  }() 
  for v := range ch { 
    println(v) 
  } 
} 
</pre><p class="calibre10">In this case, we have created an unbuffered channel, but it would work with a buffered one too. We launched a function in a new Goroutine that sends the number "1" over a channel, waits a second, sends the number "2", and closes the channel.</p><p class="calibre10">The last step is to range over the channel. The syntax is quite similar to a list range. We store the incoming data from the channel in the variable <code class="email">v</code> and we print this variable to the console. The range keeps iterating until the channel is closed, taking data from the channel.</p><p class="calibre10">Can you guess the output of this little program?</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">$ go run main.go</strong></span>

<span class="strong"><strong class="calibre2">1</strong></span>
<span class="strong"><strong class="calibre2">2</strong></span>
</pre><p class="calibre10">Again, not very impressive. It prints the number "1", then waits a second, prints the number "2", and exits the application.</p><p class="calibre10">According to the design of this concurrent app, the range was iterates over possible incoming data from the</p><p class="calibre10">channel</p><p class="calibre10">until the concurrent Goroutine closes this channel. AtÂ that moment, the range finishes and the app can exit.</p><p class="calibre10">Range is very useful in taking data from a channel, and it's commonly used in fan-in patterns where many different Goroutines send data to the same channel.</p></div></div></body></html>