- en: Ranging over channels too!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last feature about channels that we will see is ranging over channels.
    We are talking about the range keyword. We have used it extensively to range over
    lists, and we can use it to range over a channel too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have created an unbuffered channel, but it would work with
    a buffered one too. We launched a function in a new Goroutine that sends the number
    "1" over a channel, waits a second, sends the number "2", and closes the channel.
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to range over the channel. The syntax is quite similar to a
    list range. We store the incoming data from the channel in the variable `v` and
    we print this variable to the console. The range keeps iterating until the channel
    is closed, taking data from the channel.
  prefs: []
  type: TYPE_NORMAL
- en: Can you guess the output of this little program?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Again, not very impressive. It prints the number "1", then waits a second, prints
    the number "2", and exits the application.
  prefs: []
  type: TYPE_NORMAL
- en: According to the design of this concurrent app, the range was iterates over
    possible incoming data from the
  prefs: []
  type: TYPE_NORMAL
- en: channel
  prefs: []
  type: TYPE_NORMAL
- en: until the concurrent Goroutine closes this channel. AtÂ that moment, the range
    finishes and the app can exit.
  prefs: []
  type: TYPE_NORMAL
- en: Range is very useful in taking data from a channel, and it's commonly used in
    fan-in patterns where many different Goroutines send data to the same channel.
  prefs: []
  type: TYPE_NORMAL
