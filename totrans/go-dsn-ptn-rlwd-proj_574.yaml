- en: Using it all - concurrent singleton
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用所有这些——并发单例
- en: Now that we know how to create Goroutines and channels, we'll put all our knowledge
    in a single package. Think back to the first few chapter, when we explained the
    singleton pattern-it was some structure or variable that could only exist once
    in our code. All access to this structure should be done using the pattern described,
    but, in fact, it wasn't concurrent safe.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了如何创建Goroutines和通道，我们将把所有知识整合到一个单独的包中。回想一下前几章，当我们解释单例模式时——它是一种只能在我们代码中存在一次的结构或变量。对这个结构的所有访问都应该使用所描述的模式进行，但实际上它并不具备并发安全性。
- en: Now we will write with concurrency in mind. We will write a concurrent counter,
    like the one we wrote in the *mutexes* section, but this time we will solve it
    with channels.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将以并发性为出发点来编写代码。我们将编写一个并发计数器，就像我们在*互斥锁*部分所写的那样，但这次我们将使用通道来解决这个问题。
