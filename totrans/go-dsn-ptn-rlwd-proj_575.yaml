- en: Unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To restrict concurrent access to the `singleton` instance, just one Goroutine
    will be able to access it. We'll access it using channels--the first one to add
    one, the second one to get the current count, and the third one to stop the Goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: We will add one 10,000 times using 10,000 different Goroutines launched from
    two different `singleton` instances. Then, we'll introduce a loop to check the
    count of the `singleton` until it is 5,000, but we'll write how much the count
    is before starting the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the count has reached 5,000, the loop will exit and quit the running Goroutine-the
    test code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see the full test we'll use. After creating two instances of the
    `singleton`, we have created a `for` loop that launches the `AddOne` method 5,000
    times from each instance. This is not happening yet; they are being scheduled
    and will be executed eventually. We are printing the count of the `singleton`
    instance to clearly see this eventuality; depending on the computer, it will print
    some number greater than 0 and lower than 10,000.
  prefs: []
  type: TYPE_NORMAL
- en: The last step before stopping the Goroutine that is holding the count is to
    enter a loop that checks the value of the count and waits 10 milliseconds if the
    value is not the expected value (10,000). Once it reaches this value, the loop
    will exit and we can stop the `singleton` instance.
  prefs: []
  type: TYPE_NORMAL
- en: We'll jump directly to the implementation as the requirement is quite simple.
  prefs: []
  type: TYPE_NORMAL
