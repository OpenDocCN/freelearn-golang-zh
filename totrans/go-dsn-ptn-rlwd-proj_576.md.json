["```go\nvar addCh chan bool = make(chan bool) \nvar getCountCh chan chan int = make(chan chan int) \nvar quitCh chan bool = make(chan bool) \n\nfunc init() { \n  var count int \n\n  go func(addCh <-chan bool, getCountCh <-chan chan int, quitCh <-chan bool) { \n    for { \n      select { \n      case <-addCh: \n        count++ \n      case ch := <-getCountCh: \n        ch <- count \n      case <-quitCh: \n        return \n      } \n    } \n  }(addCh, getCountCh, quitCh) \n} \n\n```", "```go\ntype singleton struct {} \n\nvar instance singleton \nfunc GetInstance() *singleton { \n  return &instance \n} \n\n```", "```go\nfunc (s *singleton) AddOne() { \n  addCh <- true \n} \n\naddCh case in our Goroutine in turn. The addCh case simply executes count++ and finishes, letting select channel control flow that is executed on init function above to execute the next instruction:\n```", "```go\nfunc (s *singleton) GetCount() int { \n  resCh := make(chan int) \n  defer close(resCh) \n  getCountCh <- resCh \n  return <-resCh \n} \n\n```", "```go\nfunc (s *singleton) Stop() { \n  quitCh <- true \n  close(addCh) \n  close(getCountCh) \n  close(quitCh) \n} \n\n```", "```go\n$ go test -v .\n=== RUN   TestStartInstance\nBefore loop, current count is 4911\n--- PASS: TestStartInstance (0.03s)\nPASS\nok\n\n```", "```go\ntype singleton struct { \n  count int \n  sync.RWMutex \n} \n\nvar instance singleton \n\nfunc GetInstance() *singleton { \n  return &instance \n} \n\nfunc (s *singleton) AddOne() { \n  s.Lock() \n  defer s.Unlock() \n  s.count++ \n} \n\nfunc (s *singleton) GetCount()int { \n  s.RLock() \n  defer s.RUnlock() \n  return s.count \n} \n\n```"]