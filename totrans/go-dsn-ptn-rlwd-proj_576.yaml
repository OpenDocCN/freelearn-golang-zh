- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First of all, we''ll create the Goroutine that will hold the count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We created three channels, as we mentioned earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: The `addCh` channel is used to communicate with the action of adding one to
    the count, and receives a `bool` type just to signal "add one" (we don't need
    to send the number, although we could).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getCountCh` channel will return a channel that will receive the current
    value of the count. Take a moment to reason about the `getCountCh` channel-it's
    a channel that receives a channel that receives integer types. It sounds a bit
    complicated, but it will make more sense when we finish the example, don't worry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `quitCh` channel will communicate to the Goroutine that it should end its
    infinite loop and finish itself too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we have the channels that we need to perform the actions we want. Next,
    we launch the Goroutine passing the channels as arguments. As you can see, we
    are restricting the direction of the channels to provide more type safety. Inside
    this Goroutine, we create an infinite `for` loop. This loop won't stop until a
    break is executed within it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `select` statement, if you remember, was a way to receive data
    from different channels at the same time. We have three cases, so we listen to
    the three incoming channels that entered as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The `addCh` case will add one to the count. Remember that only one case can
    be executed on each iteration so that no Goroutine could be accessing the current
    count until we finish adding one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getCountCh` channel receives a channel that receives an integer, so we
    capture this new channel and send the current value through it to the other end.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `quitCh` channel breaks the `for` loop, so the Goroutine ends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One last thing. The `init()` function in any package will get executed on program
    execution, so we don't need to worry about executing this function specifically
    from our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll create the type that the tests are expecting. We will see that
    all the magic and logic is hidden from the end user in this type (as we have seen
    in the code of the test):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `singleton` type works similar to the way it worked in [Chapter 2](part0111_split_000.html#39REE2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 2. Creational Patterns - Singleton, Builder, Factory, Prototype, and
    Abstract Factory Design Patterns") , *Creational Patterns - Singleton, Builder,
    Factory, Prototype, and Abstract Factory*, but this time it won't hold the count
    value. We created a local value for it called `instance`, and we return the pointer
    to this instance when we call the `GetInstance()` method. It is not strictly necessary
    to do it this way, but we don't need to allocate a new instance of the `singleton`
    type every time we want to access the count variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `AddOne()` method will have to add one to the current count. How?
    By sending `true` to the `addCh` channel. That''s simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `GetCount` method creates a channel every time it's called and defers the
    action of closing it at the end of the function. This channel is unbuffered as
    we have seen previously in this chapter. An unbuffered channel blocks the execution
    until it receives some data. So we send this channel to `getCountCh` which is
    a channel too and, effectively, expects a `chan int` type to send the current
    count value back through it. The `GetCount()` method will not return until the
    value of `count` variable arrives to the `resCh` channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be thinking, why aren''t we using the same channel in both directions
    to receive the value of the count? This way we will avoid an allocation. Well,
    if we use the same channel inside the `GetCount()` method, we will have two listeners
    in this channel--one in `select` statement, at the beginning of the file on the
    `init` function, and one there, so it could resolve to any of them when sending
    the value back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we have to stop the Goroutine at some moment. The `Stop` method sends
    the value to the `singleton` type Goroutine so that the `quitCh` case is triggered
    and the `for` loop is broken. The next step is to close all channels so that no
    more data can be sent through them. This is very convenient when you know that
    you won't be using some of your channels anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to execute the tests and take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Very little code output, but everything has worked as expected. In the test,
    we printed the value of the count before entering the loop that iterates until
    it reaches the value 10,000\. As we saw previously, the Go scheduler will try
    to run the content of the Goroutines using as many OS threads as you configured
    by using the `GOMAXPROCS` configuration. In my computer, it is set to `4` because
    my computer has four cores. But the point is that we can see that a lot of things
    can happen after launching a Goroutine (or 10,000) and the next execution line.
  prefs: []
  type: TYPE_NORMAL
- en: But what about its use of mutexes?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the code is much leaner. As we saw previously, we can embed the
    mutex within the `singleton` structure. The count is also held in the `count`
    field and the `AddOne()` and `GetCount()` methods lock and unlock the value to
    be concurrently safe.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing. In this `singleton` instance, we are using the `RWMutex` type
    instead of the already known `sync.Mutex` type. The main difference here is that
    the `RWMutex` type has two types of locks--a read lock and a write lock. The read
    lock, executed by calling the `RLock` method, only waits if a write lock is currently
    active. At the same time, it only blocks a write lock, so that many read actions
    can be done in parallel. It makes a lot of sense; we don't want to block a Goroutine
    that wants to read a value just because another Goroutine is also reading the
    value-it won't change. The `sync.RWMutex` type helps us to achieve this logic
    in our code.
  prefs: []
  type: TYPE_NORMAL
