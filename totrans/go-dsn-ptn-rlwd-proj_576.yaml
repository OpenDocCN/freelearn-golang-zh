- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'First of all, we''ll create the Goroutine that will hold the count:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个Goroutine来保持计数：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We created three channels, as we mentioned earlier:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了三个通道，正如我们之前提到的：
- en: The `addCh` channel is used to communicate with the action of adding one to
    the count, and receives a `bool` type just to signal "add one" (we don't need
    to send the number, although we could).
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addCh`通道用于与增加计数的行为进行通信，并接收一个`bool`类型，仅用于表示“加一”（我们不需要发送数字，尽管我们可以）。'
- en: The `getCountCh` channel will return a channel that will receive the current
    value of the count. Take a moment to reason about the `getCountCh` channel-it's
    a channel that receives a channel that receives integer types. It sounds a bit
    complicated, but it will make more sense when we finish the example, don't worry.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCountCh`通道将返回一个接收计数当前值的通道。花点时间思考一下`getCountCh`通道——这是一个接收接收整数类型的通道的通道。听起来有点复杂，但当我们完成示例时，它将更有意义，不用担心。'
- en: The `quitCh` channel will communicate to the Goroutine that it should end its
    infinite loop and finish itself too.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quitCh`通道将通知Goroutine它应该结束其无限循环并自行结束。'
- en: Now we have the channels that we need to perform the actions we want. Next,
    we launch the Goroutine passing the channels as arguments. As you can see, we
    are restricting the direction of the channels to provide more type safety. Inside
    this Goroutine, we create an infinite `for` loop. This loop won't stop until a
    break is executed within it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了执行我们想要执行的操作所需的通道。接下来，我们将启动Goroutine，并将通道作为参数传递。正如你所看到的，我们正在限制通道的方向以提供更多的类型安全性。在这个Goroutine内部，我们创建了一个无限`for`循环。这个循环不会停止，直到其中执行了`break`。
- en: 'Finally, the `select` statement, if you remember, was a way to receive data
    from different channels at the same time. We have three cases, so we listen to
    the three incoming channels that entered as arguments:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你还记得，`select`语句是同时从不同通道接收数据的一种方式。我们有三个情况，所以我们将监听作为参数传入的三个输入通道：
- en: The `addCh` case will add one to the count. Remember that only one case can
    be executed on each iteration so that no Goroutine could be accessing the current
    count until we finish adding one.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addCh`情况将增加计数。记住，每个迭代只能执行一个情况，这样就没有Goroutine可以在我们完成加一之前访问当前计数。'
- en: The `getCountCh` channel receives a channel that receives an integer, so we
    capture this new channel and send the current value through it to the other end.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getCountCh`通道接收一个接收整数的通道，所以我们捕获这个新通道并通过它发送当前值到另一端。'
- en: The `quitCh` channel breaks the `for` loop, so the Goroutine ends.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quitCh`通道会中断`for`循环，因此Goroutine结束。'
- en: One last thing. The `init()` function in any package will get executed on program
    execution, so we don't need to worry about executing this function specifically
    from our code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情。任何包中的`init()`函数在程序执行时都会被调用，所以我们不需要担心从我们的代码中特别执行这个函数。
- en: 'Now, we''ll create the type that the tests are expecting. We will see that
    all the magic and logic is hidden from the end user in this type (as we have seen
    in the code of the test):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建测试期望的类型。我们将看到所有的魔法和逻辑都隐藏在这个类型中（正如我们在测试代码中所看到的）：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `singleton` type works similar to the way it worked in [Chapter 2](part0111_split_000.html#39REE2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 2. Creational Patterns - Singleton, Builder, Factory, Prototype, and
    Abstract Factory Design Patterns") , *Creational Patterns - Singleton, Builder,
    Factory, Prototype, and Abstract Factory*, but this time it won't hold the count
    value. We created a local value for it called `instance`, and we return the pointer
    to this instance when we call the `GetInstance()` method. It is not strictly necessary
    to do it this way, but we don't need to allocate a new instance of the `singleton`
    type every time we want to access the count variable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`singleton`类型的工作方式与它在[第2章](part0111_split_000.html#39REE2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第2章。创建型模式 - 单例、建造者、工厂、原型和抽象工厂设计模式")中工作的方式相似，即*创建型模式 - 单例、建造者、工厂、原型和抽象工厂*，但这次它不会保持计数值。我们为它创建了一个局部值，称为`instance`，当我们调用`GetInstance()`方法时，我们返回这个实例的指针。这样做并不严格必要，但每次我们想要访问计数变量时，我们不需要为`singleton`类型分配一个新的实例。'
- en: 'First, the `AddOne()` method will have to add one to the current count. How?
    By sending `true` to the `addCh` channel. That''s simple:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`AddOne()`方法必须将当前计数加一。如何？通过向`addCh`通道发送`true`。很简单：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `GetCount` method creates a channel every time it's called and defers the
    action of closing it at the end of the function. This channel is unbuffered as
    we have seen previously in this chapter. An unbuffered channel blocks the execution
    until it receives some data. So we send this channel to `getCountCh` which is
    a channel too and, effectively, expects a `chan int` type to send the current
    count value back through it. The `GetCount()` method will not return until the
    value of `count` variable arrives to the `resCh` channel.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetCount`方法每次被调用时都会创建一个通道，并在函数结束时延迟关闭它的操作。这个通道是无缓冲的，正如我们在本章之前所看到的。无缓冲的通道会在接收到一些数据之前阻塞执行。因此，我们将这个通道发送到`getCountCh`，它也是一个通道，并且实际上期望通过它发送一个`chan
    int`类型的当前计数器值。`GetCount()`方法将不会返回，直到`count`变量的值到达`resCh`通道。'
- en: 'You might be thinking, why aren''t we using the same channel in both directions
    to receive the value of the count? This way we will avoid an allocation. Well,
    if we use the same channel inside the `GetCount()` method, we will have two listeners
    in this channel--one in `select` statement, at the beginning of the file on the
    `init` function, and one there, so it could resolve to any of them when sending
    the value back:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么我们不在两个方向上使用相同的通道来接收计数器的值？这样我们可以避免分配。好吧，如果我们将相同的通道放在`GetCount()`方法内部，那么这个通道将有两个监听者——一个在文件的开始处的`init`函数中的`select`语句中，另一个在这里，所以在发送值回传时，它可能指向任何一个：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, we have to stop the Goroutine at some moment. The `Stop` method sends
    the value to the `singleton` type Goroutine so that the `quitCh` case is triggered
    and the `for` loop is broken. The next step is to close all channels so that no
    more data can be sent through them. This is very convenient when you know that
    you won't be using some of your channels anymore.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须在某个时刻停止Goroutine。`Stop`方法将值发送到`singleton`类型的Goroutine，从而触发`quitCh`情况并中断`for`循环。下一步是关闭所有通道，这样就不会再有数据通过它们发送。当你知道你不会再使用一些通道时，这非常方便。
- en: 'Time to execute the tests and take a look:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候执行测试并查看结果了：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Very little code output, but everything has worked as expected. In the test,
    we printed the value of the count before entering the loop that iterates until
    it reaches the value 10,000\. As we saw previously, the Go scheduler will try
    to run the content of the Goroutines using as many OS threads as you configured
    by using the `GOMAXPROCS` configuration. In my computer, it is set to `4` because
    my computer has four cores. But the point is that we can see that a lot of things
    can happen after launching a Goroutine (or 10,000) and the next execution line.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 代码输出非常少，但一切如预期般工作。在测试中，我们在进入迭代直到达到10,000这个值的循环之前打印了计数器的值。正如我们之前所看到的，Go调度器会尝试使用你通过`GOMAXPROCS`配置设置的尽可能多的操作系统线程来运行Goroutines的内容。在我的电脑上，它设置为`4`，因为我的电脑有四个核心。但关键是，我们可以看到在启动Goroutine（或10,000个）之后和下一行执行之间会发生很多事情。
- en: But what about its use of mutexes?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但它的互斥锁（mutexes）的使用又是如何呢？
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, the code is much leaner. As we saw previously, we can embed the
    mutex within the `singleton` structure. The count is also held in the `count`
    field and the `AddOne()` and `GetCount()` methods lock and unlock the value to
    be concurrently safe.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，代码更加简洁。正如我们之前所看到的，我们可以在`singleton`结构体内部嵌入互斥锁。计数器也保存在`count`字段中，而`AddOne()`和`GetCount()`方法会锁定和解锁要并发安全的值。
- en: One more thing. In this `singleton` instance, we are using the `RWMutex` type
    instead of the already known `sync.Mutex` type. The main difference here is that
    the `RWMutex` type has two types of locks--a read lock and a write lock. The read
    lock, executed by calling the `RLock` method, only waits if a write lock is currently
    active. At the same time, it only blocks a write lock, so that many read actions
    can be done in parallel. It makes a lot of sense; we don't want to block a Goroutine
    that wants to read a value just because another Goroutine is also reading the
    value-it won't change. The `sync.RWMutex` type helps us to achieve this logic
    in our code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事。在这个`singleton`实例中，我们使用的是`RWMutex`类型而不是已经知道的`sync.Mutex`类型。这里的主要区别在于`RWMutex`类型有两种锁——读锁和写锁。通过调用`RLock`方法执行的读锁，只有在当前有一个写锁活动时才会等待。同时，它只会阻塞写锁，这样就可以并行执行许多读操作。这很有意义；我们不希望因为另一个Goroutine也在读取值而阻塞想要读取值的Goroutine——它不会改变。`sync.RWMutex`类型帮助我们实现代码中的这种逻辑。
