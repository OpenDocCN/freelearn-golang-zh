<html><head></head><body><div class="book" title="Summary" id="49AH01-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec061" class="calibre1"/>Summary</h1></div></div></div><p class="calibre10">We have seen how to write a concurrent Singleton using mutexes and channels. While the channels example was more complex, it also shows the core power of Go's concurrency, as you can achieve complex levels of event-driven architectures by simply using channels.</p><p class="calibre10">Just keep in mind that, if you haven't written concurrent code in the past, it can take some time to start thinking concurrently in a comfortable way. But it's nothing that practice cannot solve.</p><p class="calibre10">We have seen the importance of designing concurrent apps to achieve parallelism in our programs. We have dealt with most of Go's primitives to write concurrent applications, and now we can write common concurrent design patterns.</p></div></body></html>