- en: Summary
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have seen how to write a concurrent Singleton using mutexes and channels.
    While the channels example was more complex, it also shows the core power of Go's
    concurrency, as you can achieve complex levels of event-driven architectures by
    simply using channels.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用互斥锁和通道编写并发单例。虽然通道示例更为复杂，但它也展示了Go并发性的核心力量，因为你可以通过简单地使用通道来实现复杂的事件驱动架构。
- en: Just keep in mind that, if you haven't written concurrent code in the past,
    it can take some time to start thinking concurrently in a comfortable way. But
    it's nothing that practice cannot solve.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，如果你以前没有编写过并发代码，可能需要一些时间才能开始以舒适的方式并发思考。但实践可以解决所有问题。
- en: We have seen the importance of designing concurrent apps to achieve parallelism
    in our programs. We have dealt with most of Go's primitives to write concurrent
    applications, and now we can write common concurrent design patterns.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了设计并发应用程序以实现程序中并行性的重要性。我们已经处理了Go的大多数原语来编写并发应用程序，现在我们可以编写常见的并发设计模式。
