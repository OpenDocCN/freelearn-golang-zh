<html><head></head><body>
<div class="book" title="Chapter&#xA0;9.&#xA0;Concurrency Patterns - Barrier, Future, and Pipeline Design Patterns">
<div class="book" title="Barrier concurrency pattern">
<div class="book" title="An HTTP GET aggregator"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec0213" class="calibre1"/>An HTTP GET aggregator</h2></div></div></div><p class="calibre10">For our example, we are going to write a very typical situation in a microservices application-an app that performs two HTTP <code class="email">GET</code> calls and joins them in a single response that will be printed on the console.</p><p class="calibre10">Our small app must perform each request in a different Goroutine and print the result on the console if both responses are correct. If any of them returns an error, then we print just the error.</p><p class="calibre10">The design must be concurrent, allowing us to take advantage of our multicore CPUs to make the calls in parallel:</p><p class="calibre10">
</p><div class="mediaobject"><img src="../images/00039.jpeg" alt="An HTTP GET aggregator" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">
</p><p class="calibre10">In the preceding diagram, the solid lines represent calls and the dashed lines represent channels. The balloons are Goroutines, so we have two Goroutines launched by the <code class="email">main</code> function (which could also be considered a Goroutine). These two functions will communicate back to the <code class="email">main</code> function by using a <span class="strong"><strong class="calibre2">common channel</strong></span> that they received when they were created on the <code class="email">makeRequest</code> calls.</p></div></div></div></body></html>