- en: An HTTP GET aggregator
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个HTTP GET聚合器
- en: For our example, we are going to write a very typical situation in a microservices
    application-an app that performs two HTTP `GET` calls and joins them in a single
    response that will be printed on the console.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将编写一个在微服务应用中非常典型的情况——一个执行两个HTTP `GET`调用并将它们合并成一个将在控制台上打印的单个响应的应用程序。
- en: Our small app must perform each request in a different Goroutine and print the
    result on the console if both responses are correct. If any of them returns an
    error, then we print just the error.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小应用程序必须在不同的Goroutine中执行每个请求，并在两个响应都正确的情况下在控制台上打印结果。如果任何一个返回错误，那么我们只打印错误。
- en: 'The design must be concurrent, allowing us to take advantage of our multicore
    CPUs to make the calls in parallel:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 设计必须是并发的，这样我们就可以利用我们的多核CPU并行地发出调用：
- en: '![An HTTP GET aggregator](img/00039.jpeg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![一个HTTP GET聚合器](img/00039.jpeg)'
- en: In the preceding diagram, the solid lines represent calls and the dashed lines
    represent channels. The balloons are Goroutines, so we have two Goroutines launched
    by the `main` function (which could also be considered a Goroutine). These two
    functions will communicate back to the `main` function by using a **common channel**
    that they received when they were created on the `makeRequest` calls.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，实线代表调用，虚线代表通道。气球是Goroutines，因此我们有两个由`main`函数启动的Goroutines（这也可以被视为一个Goroutine）。这两个函数将通过使用它们在`makeRequest`调用时接收到的**公共通道**与`main`函数进行通信。
