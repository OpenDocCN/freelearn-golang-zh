<html><head></head><body>
<div class="book" title="Chapter&#xA0;9.&#xA0;Concurrency Patterns - Barrier, Future, and Pipeline Design Patterns">
<div class="book" title="Barrier concurrency pattern">
<div class="book" title="Unit test - integration"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch09lvl2sec0215" class="calibre1"/>Unit test - integration</h2></div></div></div><p class="calibre10">To write unit or integration tests for concurrent designs can sometimes be tricky, but this won't stop us from writing our awesome unit tests. We will have a single <code class="email">barrier</code> method that accepts a set of endpoints defined as a <code class="email">string</code> type. The barrier will make a <code class="email">GET</code> request to each endpoint and compose the result before printing it out. In this case, we will write three integration tests to simplify our code so we don't need to generate mock responses:</p><pre class="programlisting">package barrier 
 
import ( 
    "bytes" 
    "io" 
    "os" 
    "strings" 
    "testing" 
) 
 
func TestBarrier(t *testing.T) { 
  t.Run("Correct endpoints", func(t *testing.T) { 
    endpoints := []string{"http://httpbin.org/headers",  "http://httpbin.org/User-Agent"
    } 
  }) 
 
  t.Run("One endpoint incorrect", func(t *testing.T) { 
    endpoints := []string{"http://malformed-url",  "http://httpbin.org/User-Agent"} 
  }) 
 
  t.Run("Very short timeout", func(t *testing.T) { 
    endpoints := []string{"http://httpbin.org/headers",  "http://httpbin.org/User-Agent"} 
  }) 
} 
</pre><p class="calibre10">We have a single test that will execute three subtests:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The first test makes two calls to the correct endpoints</li><li class="listitem">The second test will have an incorrect endpoint, so it must return an error</li><li class="listitem">The last test will return the maximum timeout time so that we can force a timeout error</li></ul></div><p class="calibre10">We will have a function called <code class="email">barrier</code> that will accept an undetermined number of endpoints in the form of strings. Its signature could be like this:</p><pre class="programlisting">func barrier(endpoints ...string) {} 
</pre><p class="calibre10">As you can see, the <code class="email">barrier</code> function doesn't return any value because its result will be printed on the console. Previously, we have written an implementation of an <code class="email">io.Writer</code> interface to emulate the writing on the operating system's <code class="email">stdout</code> library. Just to change things a bit, we will capture the <code class="email">stdout</code> library instead of emulating one. The process to capture the <code class="email">stdout</code> library isn't difficult once you understand concurrency primitives in Go:</p><pre class="programlisting">func captureBarrierOutput(endpoints ...string) string { 
    reader, writer, _ := os.Pipe() 
 
    os.Stdout = writer 
    out := make(chan string) 
    
    go func() { 
      var buf bytes.Buffer 
      io.Copy(&amp;buf, reader) 
      out &lt;- buf.String() 
    }() 
 
    barrier(endpoints...) 
 
    writer.Close() 
    temp := &lt;-out 
 
    return temp 
} 
</pre><p class="calibre10">Don't feel daunted by this code; it's really simple. First we created a pipe; we have done this before in <a class="calibre1" title="Chapter 3. Structural Patterns - Composite, Adapter, and Bridge Design Patterns" href="part0117_split_000.html#3FIHQ2-9c484ed022e64a0fb0e1aebf8e05d4fd">Chapter 3</a>, <span class="strong"><em class="calibre11">Structural Patterns - Adapter, Bridge, and Composite Design Patterns</em></span>, when we talked about the Adapter design pattern. To recall, a pipe allows us to connect an <code class="email">io.Writer</code> interface to an <code class="email">io.Reader</code> interface so that the reader input is the <code class="email">Writer</code> output. We define the <code class="email">os.Stdout</code> as the writer. Then, to capture <code class="email">stdout</code> output, we will need a different Goroutine that listens while we write to the console. As you know, if we write, we don't capture, and if we capture, we are not writing. The keyword here is <code class="email">while</code>; it is a good rule of thumb that if you find this word in some definition, you'll probably need a concurrent structure. So we use the <code class="email">go</code> keyword to launch a different Goroutine that copies reader input to a bytes buffer before sending the contents of the buffer through a channel (that we should have previously created).</p><p class="calibre10">At this point, we have a listening Goroutine, but we haven't printed anything yet, so we call our (not yet written) function <code class="email">barrier</code> with the provided endpoints. Next, we have to close the writer to signal the Goroutine that no more input is going to come to it. Our channel called out blocks execution until some value is received (the one sent by our launched Goroutine). The last step is to return the contents captured from the console.</p><p class="calibre10">OK, so we have a function called <code class="email">captureBarrierOutput</code> that will capture the outputs in <code class="email">stdout</code> and return them as a string. We can write our tests now:</p><pre class="programlisting">t.Run("Correct endpoints", func(t *testing.T) { 
    endpoints := []string{"http://httpbin.org/headers", "http://httpbin.org/User-Agent"
    } 
 
<span class="strong"><strong class="calibre2">    result := captureBarrierOutput(endpoints...)</strong></span>
<span class="strong"><strong class="calibre2">    
    if !strings.Contains(result, "Accept-Encoding") || strings.Contains (result, "User-Agent") 
  {</strong></span>
<span class="strong"><strong class="calibre2">      
    t.Fail()</strong></span>
<span class="strong"><strong class="calibre2">    
  }</strong></span>
<span class="strong"><strong class="calibre2">    
  t.Log(result)</strong></span> 
}) 
</pre><p class="calibre10">All the tests are very easy to implement. All in all, it is the <code class="email">captureBarrierOutput</code> function that calls the <code class="email">barrier</code> function. So we pass the endpoints and check the returned result. Our composed response directed to <a class="calibre1" href="http://httpbin.org">http://httpbin.org
</a> must contain the text <span class="strong"><em class="calibre11">Accept-Encoding</em></span> and <span class="strong"><em class="calibre11">User-Agent</em></span> in the responses of each endpoint. If we don't find those texts, the test will fail. For debugging purposes, we log the response in case we want to check it with the <code class="email">-v</code> flag on the go test:</p><pre class="programlisting">t.Run("One endpoint incorrect", func(t *testing.T) { 
  endpoints := []string
  {
    "http://malformed-url", "http://httpbin.org/User-Agent"} 
 
<span class="strong"><strong class="calibre2">    result := captureBarrierOutput(endpoints...)</strong></span>
<span class="strong"><strong class="calibre2">    
    if !strings.Contains(result, "ERROR") {</strong></span>
<span class="strong"><strong class="calibre2">        
        t.Fail()</strong></span>
<span class="strong"><strong class="calibre2">    
    }</strong></span>
<span class="strong"><strong class="calibre2">    
    t.Log(result)</strong></span> 
}) 
</pre><p class="calibre10">This time we used an incorrect endpoint URL, so the response must return the error prefixed with the word <span class="strong"><em class="calibre11">ERROR</em></span> that we will write ourselves in the <code class="email">barrier</code> function.</p><p class="calibre10">The last function will reduce the timeout of the HTTP <code class="email">GET</code> client to a minimum of 1 ms, so we force a timeout:</p><pre class="programlisting">t.Run("Very short timeout", func(t *testing.T) { 
  endpoints := []string
  {
    "http://httpbin.org/headers", "http://httpbin.org/User-Agent"} 
<span class="strong"><strong class="calibre2">    timeoutMilliseconds = 1</strong></span>
<span class="strong"><strong class="calibre2">    
    result := captureBarrierOutput(endpoints...)</strong></span>
<span class="strong"><strong class="calibre2">    
    if !strings.Contains(result, "Timeout") {</strong></span>
<span class="strong"><strong class="calibre2">        
      t.Fail()</strong></span>
<span class="strong"><strong class="calibre2">    
    }</strong></span>
<span class="strong"><strong class="calibre2">    
    t.Log(result)</strong></span> 
  }) 
</pre><p class="calibre10">The <code class="email">timeoutMilliseconds</code> variable will be a package variable that we will have to define later during implementation.</p></div></div></div></body></html>