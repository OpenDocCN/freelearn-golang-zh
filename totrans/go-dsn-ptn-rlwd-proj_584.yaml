- en: Unit test - integration
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试 - 集成测试
- en: 'To write unit or integration tests for concurrent designs can sometimes be
    tricky, but this won''t stop us from writing our awesome unit tests. We will have
    a single `barrier` method that accepts a set of endpoints defined as a `string`
    type. The barrier will make a `GET` request to each endpoint and compose the result
    before printing it out. In this case, we will write three integration tests to
    simplify our code so we don''t need to generate mock responses:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为并发设计编写单元测试或集成测试有时可能很棘手，但这不会阻止我们编写我们出色的单元测试。我们将有一个单独的 `barrier` 方法，它接受一组以 `string`
    类型定义的端点。屏障将对每个端点发起 `GET` 请求并在打印之前组合结果。在这种情况下，我们将编写三个集成测试以简化我们的代码，这样我们就不需要生成模拟响应：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have a single test that will execute three subtests:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个单独的测试，将执行三个子测试：
- en: The first test makes two calls to the correct endpoints
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一次测试调用正确的端点两次
- en: The second test will have an incorrect endpoint, so it must return an error
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次测试将有一个错误的端点，因此它必须返回一个错误
- en: The last test will return the maximum timeout time so that we can force a timeout
    error
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一次测试将返回最大超时时间，以便我们可以强制超时错误
- en: 'We will have a function called `barrier` that will accept an undetermined number
    of endpoints in the form of strings. Its signature could be like this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将有一个名为 `barrier` 的函数，它将接受以字符串形式表示的不确定数量的端点。它的签名可能如下所示：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, the `barrier` function doesn''t return any value because its
    result will be printed on the console. Previously, we have written an implementation
    of an `io.Writer` interface to emulate the writing on the operating system''s
    `stdout` library. Just to change things a bit, we will capture the `stdout` library
    instead of emulating one. The process to capture the `stdout` library isn''t difficult
    once you understand concurrency primitives in Go:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`barrier` 函数不返回任何值，因为它的结果将在控制台上打印。之前，我们已经编写了一个 `io.Writer` 接口的实现来模拟操作系统
    `stdout` 库的写入。为了改变一下，我们将捕获 `stdout` 库而不是模拟一个。一旦你理解了 Go 中的并发原语，捕获 `stdout` 库的过程并不困难：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Don't feel daunted by this code; it's really simple. First we created a pipe;
    we have done this before in [Chapter 3](part0117_split_000.html#3FIHQ2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 3. Structural Patterns - Composite, Adapter, and Bridge Design Patterns"),
    *Structural Patterns - Adapter, Bridge, and Composite Design Patterns*, when we
    talked about the Adapter design pattern. To recall, a pipe allows us to connect
    an `io.Writer` interface to an `io.Reader` interface so that the reader input
    is the `Writer` output. We define the `os.Stdout` as the writer. Then, to capture
    `stdout` output, we will need a different Goroutine that listens while we write
    to the console. As you know, if we write, we don't capture, and if we capture,
    we are not writing. The keyword here is `while`; it is a good rule of thumb that
    if you find this word in some definition, you'll probably need a concurrent structure.
    So we use the `go` keyword to launch a different Goroutine that copies reader
    input to a bytes buffer before sending the contents of the buffer through a channel
    (that we should have previously created).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被这段代码吓倒；它真的很简单。首先我们创建了一个管道；我们之前在 [第 3 章](part0117_split_000.html#3FIHQ2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第 3 章。结构型模式 - 组合、适配器和桥接设计模式") 中做过，*结构型模式 - 适配器、桥接和组合设计模式*，当我们讨论适配器设计模式时。为了回忆，管道允许我们将
    `io.Writer` 接口连接到 `io.Reader` 接口，以便读者的输入是 `Writer` 的输出。我们将 `os.Stdout` 定义为写入者。然后，为了捕获
    `stdout` 输出，我们需要一个不同的 Goroutine，在我们向控制台写入时进行监听。正如你所知，如果我们写入，我们不会捕获，如果我们捕获，我们就不在写入。这里的关键字是
    `while`；如果你在某个定义中找到这个单词，你可能会需要并发结构。所以我们使用 `go` 关键字启动一个不同的 Goroutine，在将缓冲区的内容通过通道发送之前，将读取器的输入复制到一个字节缓冲区中（我们应该之前创建的通道）。
- en: At this point, we have a listening Goroutine, but we haven't printed anything
    yet, so we call our (not yet written) function `barrier` with the provided endpoints.
    Next, we have to close the writer to signal the Goroutine that no more input is
    going to come to it. Our channel called out blocks execution until some value
    is received (the one sent by our launched Goroutine). The last step is to return
    the contents captured from the console.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个监听 Goroutine，但我们还没有打印任何内容，所以我们需要调用我们（尚未编写的）函数 `barrier` 并提供端点。接下来，我们必须关闭写入者以向
    Goroutine 发送信号，表示不会再有输入。我们称为 `out` 的通道会阻塞执行，直到接收到某个值（由我们启动的 Goroutine 发送的值）。最后一步是返回从控制台捕获的内容。
- en: 'OK, so we have a function called `captureBarrierOutput` that will capture the
    outputs in `stdout` and return them as a string. We can write our tests now:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们有一个名为 `captureBarrierOutput` 的函数，它将捕获 `stdout` 中的输出并将它们作为字符串返回。我们现在可以编写我们的测试了：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All the tests are very easy to implement. All in all, it is the `captureBarrierOutput`
    function that calls the `barrier` function. So we pass the endpoints and check
    the returned result. Our composed response directed to [http://httpbin.org](http://httpbin.org)
    must contain the text *Accept-Encoding* and *User-Agent* in the responses of each
    endpoint. If we don''t find those texts, the test will fail. For debugging purposes,
    we log the response in case we want to check it with the `-v` flag on the go test:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都非常容易实现。总的来说，是 `captureBarrierOutput` 函数调用 `barrier` 函数。因此，我们传递端点并检查返回的结果。我们指向
    [http://httpbin.org](http://httpbin.org) 的组合响应必须在每个端点的响应中包含文本 *Accept-Encoding*
    和 *User-Agent*。如果我们找不到这些文本，测试将失败。为了调试目的，我们记录响应，以便我们可以在 go test 的 `-v` 标志下检查它：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time we used an incorrect endpoint URL, so the response must return the
    error prefixed with the word *ERROR* that we will write ourselves in the `barrier`
    function.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们使用了错误的端点URL，因此响应必须返回以单词 *ERROR* 开头的错误，这个错误我们将自己在 `barrier` 函数中编写。
- en: 'The last function will reduce the timeout of the HTTP `GET` client to a minimum
    of 1 ms, so we force a timeout:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数将 HTTP `GET` 客户端的超时时间减少到最小值 1 毫秒，因此我们强制设置超时：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `timeoutMilliseconds` variable will be a package variable that we will have
    to define later during implementation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeoutMilliseconds` 变量将是一个需要在实现过程中定义的包变量。'
