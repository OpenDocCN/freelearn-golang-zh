- en: Unit test - integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write unit or integration tests for concurrent designs can sometimes be
    tricky, but this won''t stop us from writing our awesome unit tests. We will have
    a single `barrier` method that accepts a set of endpoints defined as a `string`
    type. The barrier will make a `GET` request to each endpoint and compose the result
    before printing it out. In this case, we will write three integration tests to
    simplify our code so we don''t need to generate mock responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a single test that will execute three subtests:'
  prefs: []
  type: TYPE_NORMAL
- en: The first test makes two calls to the correct endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second test will have an incorrect endpoint, so it must return an error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last test will return the maximum timeout time so that we can force a timeout
    error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will have a function called `barrier` that will accept an undetermined number
    of endpoints in the form of strings. Its signature could be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `barrier` function doesn''t return any value because its
    result will be printed on the console. Previously, we have written an implementation
    of an `io.Writer` interface to emulate the writing on the operating system''s
    `stdout` library. Just to change things a bit, we will capture the `stdout` library
    instead of emulating one. The process to capture the `stdout` library isn''t difficult
    once you understand concurrency primitives in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Don't feel daunted by this code; it's really simple. First we created a pipe;
    we have done this before in [Chapter 3](part0117_split_000.html#3FIHQ2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 3. Structural Patterns - Composite, Adapter, and Bridge Design Patterns"),
    *Structural Patterns - Adapter, Bridge, and Composite Design Patterns*, when we
    talked about the Adapter design pattern. To recall, a pipe allows us to connect
    an `io.Writer` interface to an `io.Reader` interface so that the reader input
    is the `Writer` output. We define the `os.Stdout` as the writer. Then, to capture
    `stdout` output, we will need a different Goroutine that listens while we write
    to the console. As you know, if we write, we don't capture, and if we capture,
    we are not writing. The keyword here is `while`; it is a good rule of thumb that
    if you find this word in some definition, you'll probably need a concurrent structure.
    So we use the `go` keyword to launch a different Goroutine that copies reader
    input to a bytes buffer before sending the contents of the buffer through a channel
    (that we should have previously created).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have a listening Goroutine, but we haven't printed anything
    yet, so we call our (not yet written) function `barrier` with the provided endpoints.
    Next, we have to close the writer to signal the Goroutine that no more input is
    going to come to it. Our channel called out blocks execution until some value
    is received (the one sent by our launched Goroutine). The last step is to return
    the contents captured from the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, so we have a function called `captureBarrierOutput` that will capture the
    outputs in `stdout` and return them as a string. We can write our tests now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'All the tests are very easy to implement. All in all, it is the `captureBarrierOutput`
    function that calls the `barrier` function. So we pass the endpoints and check
    the returned result. Our composed response directed to [http://httpbin.org](http://httpbin.org)
    must contain the text *Accept-Encoding* and *User-Agent* in the responses of each
    endpoint. If we don''t find those texts, the test will fail. For debugging purposes,
    we log the response in case we want to check it with the `-v` flag on the go test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This time we used an incorrect endpoint URL, so the response must return the
    error prefixed with the word *ERROR* that we will write ourselves in the `barrier`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last function will reduce the timeout of the HTTP `GET` client to a minimum
    of 1 ms, so we force a timeout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `timeoutMilliseconds` variable will be a package variable that we will have
    to define later during implementation.
  prefs: []
  type: TYPE_NORMAL
