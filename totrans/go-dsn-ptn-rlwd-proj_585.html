<html><head></head><body>
<div class="book" title="Chapter&#xA0;9.&#xA0;Concurrency Patterns - Barrier, Future, and Pipeline Design Patterns">
<div class="book" title="Barrier concurrency pattern">
<div class="book" title="Implementation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch09lvl2sec0216" class="calibre1"/>Implementation</h2></div></div></div><p class="calibre10">We needed to define a package variable called <code class="email">timeoutMilliseconds</code>. Let's start from there:</p><pre class="programlisting">package barrier 
 
import ( 
    "fmt" 
    "io/ioutil" 
    "net/http" 
    "time" 
) 
 
var timeoutMilliseconds int = 5000 
</pre><p class="calibre10">The initial timeout delay is 5 seconds (5,000 milliseconds) and we will need those packages in our code.</p><p class="calibre10">OK, so we need a function that launches a Goroutine for each endpoint URL. Do you remember how we achieve the communication between Goroutines? Exactly--channels! So we will need a channel to handle responses and a channel to handle errors.</p><p class="calibre10">But we can simplify it a bit more. We will receive two correct responses, two errors, or a response and an error; in any case, there are always two responses, so we can join errors and responses in a merged type:</p><pre class="programlisting">type barrierResp struct { 
    Err  error 
    Resp string 
} 
</pre><p class="calibre10">So, each Goroutine will send back a value of the <code class="email">barrierResp</code> type. This value will have a value for <code class="email">Err</code> or a value for the <code class="email">Resp</code> field.</p><p class="calibre10">The procedure is simple: we create a channel of size 2, the one that will receive responses of the <code class="email">barrierResp</code> type, we launch both requests and wait for two responses, and then check to see if there is any error:</p><pre class="programlisting">func barrier(endpoints ...string) { 
    requestNumber := len(endpoints) 
 
    in := make(chan barrierResp, requestNumber) 
    defer close(in) 
 
    responses := make([]barrierResp, requestNumber) 
 
    for _, endpoint := range endpoints { 
        go makeRequest(in, endpoint) 
    } 
 
    var hasError bool 
    for i := 0; i &lt; requestNumber; i++ { 
        resp := &lt;-in 
        if resp.Err != nil { 
            fmt.Println("ERROR: ", resp.Err) 
            hasError = true 
        } 
        responses[i] = resp 
    } 
 
    if !hasError { 
        for _, resp := range responses { 
            fmt.Println(resp.Resp) 
        } 
    } 
} 
</pre><p class="calibre10">Following the previous description, we created a buffered channel called <code class="email">in</code>, making it the size of the incoming endpoints, and we deferred channel closing. Then, we launched a function called <code class="email">makeRequest</code> with each endpoint and the response channel.</p><p class="calibre10">Now we will loop  twice, once for each endpoint. In the loop, we block the execution waiting for data from the <code class="email">in</code> channel. If we find an error, we print it prefixed with the word <span class="strong"><em class="calibre11">ERROR</em></span> as we expect in our tests, and set <code class="email">hasErrorvar</code> to true. After two responses, if we don't find any error (<code class="email">hasError== false</code>) we print every response and the channel will be closed.</p><p class="calibre10">We still lack the <code class="email">makeRequest</code> function:</p><pre class="programlisting">func makeRequest(out chan&lt;- barrierResp, url string) { 
    res := barrierResp{} 
    client := http.Client{ 
        Timeout: time.Duration(time.Duration(timeoutMilliseconds) * time.Millisecond), 
    } 
 
    resp, err := client.Get(url) 
    if err != nil { 
        res.Err = err 
        out &lt;- res 
        return 
    } 
 
    byt, err := ioutil.ReadAll(resp.Body) 
    if err != nil { 
        res.Err = err 
        out &lt;- res 
        return 
    } 
 
    res.Resp = string(byt) 
    out &lt;- res 
} 
</pre><p class="calibre10">The <code class="email">makeRequest</code> function is a very straightforward functions that accepts a channel to output <code class="email">barrierResp</code> values to and a URL to request. We create an <code class="email">http.Client</code> and set its timeout field to the value of the <code class="email">timeoutMilliseconds</code> package variable. This is how we can change the timeout delay before the <code class="email">in</code> function tests. Then, we simply make the <code class="email">GET</code> call, take the response, parse it to a byte slice, and send it through the <code class="email">out</code> channel.</p><p class="calibre10">We do all this by filling a variable called <code class="email">res</code> of the <code class="email">barrierResp</code> type. If we find an error while performing a <code class="email">GET</code> request or parsing the body of the result, we fill the <code class="email">res.Err</code> field, send it to the <code class="email">out</code> channel (which has the opposite side connected to the original Goroutine), and exit the function (so we don't send two values through the <code class="email">out</code> channel by mistake).</p><p class="calibre10">Time to run the tests. Remember that you need an Internet connection, or the first two tests will fail. We will first try the test that has two endpoints that are correct:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -run=TestBarrier/Correct_endpoints -v .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestBarrier</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestBarrier/Correct_endpoints</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestBarrier (0.54s)</strong></span>
<span class="strong"><strong class="calibre2">    --- PASS: TestBarrier/Correct_endpoints (0.54s)</strong></span>
<span class="strong"><strong class="calibre2">        barrier_test.go:20: {</strong></span>
<span class="strong"><strong class="calibre2">          "headers": {</strong></span>
<span class="strong"><strong class="calibre2">            "Accept-Encoding": "gzip", </strong></span>
<span class="strong"><strong class="calibre2">"Host": "httpbin.org",</strong></span>
<span class="strong"><strong class="calibre2">"User-Agent": "Go-http-client/1.1"</strong></span>
<span class="strong"><strong class="calibre2">             }</strong></span>
<span class="strong"><strong class="calibre2">         }</strong></span>
<span class="strong"><strong class="calibre2">         {</strong></span>
<span class="strong"><strong class="calibre2">              "User-Agent": "Go-http-client/1.1"</strong></span>
<span class="strong"><strong class="calibre2">          }
</strong></span>
<span class="strong"><strong class="calibre2">    ok</strong></span>
</pre><p class="calibre10">Perfect. We have a JSON response with a key, <code class="email">headers</code>, and another JSON response with a key <code class="email">User-Agent</code>. In our integration tests, we were looking for the strings, <code class="email">User-Agent</code> and <code class="email">Accept-Encoding</code>, which are present, so the test has passed successfully.</p><p class="calibre10">Now we will run the test that has an incorrect endpoint:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -run=TestBarrier/One_endpoint_incorrect -v .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestBarrier</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestBarrier/One_endpoint_incorrect</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestBarrier (0.27s)</strong></span>
<span class="strong"><strong class="calibre2">    --- PASS: TestBarrier/One_endpoint_incorrect (0.27s)</strong></span>
<span class="strong"><strong class="calibre2">        barrier_test.go:31: ERROR:  Get http://malformed-url: dial tcp: lookup malformed-url: no such host</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre><p class="calibre10">We can see that we have had an error where <code class="email">http://malformed-url</code> has returned a <span class="strong"><em class="calibre11">no such host</em></span> error. A request to this URL must return a text with the word <code class="email">ERROR:</code> prefixed, as we stated during the acceptance criteria, that's why this test is correct (we don't have a false positive).</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note019" class="calibre1"/>Note</h3><p class="calibre10">In testing, it's very important to understand the concepts of "false positive" and "false negative" tests. A false positive test is roughly described as a test that passes a condition when it shouldn't (result: all passed) while the false negative is just the reverse (result: test failed). For example, we could be testing that a string is returned when doing the requests but, the returned string could be completely empty! This will lead to a false negative, a test that doesn't fail even when we are checking a behavior that is incorrect on purpose (a request to <code class="email">http://malformed-url</code>).</p></div><p class="calibre10">The last test reduced the timeout time to 1 ms:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -run=TestBarrier/Very_short_timeout -v .     
=== RUN   TestBarrier 
=== RUN   TestBarrier/Very_short_timeout 
--- PASS: TestBarrier (0.00s) 
    --- PASS: TestBarrier/Very_short_timeout (0.00s) 
        barrier_test.go:43: ERROR:  Get http://httpbin.org/User-Agent: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) 
        ERROR:  Get http://httpbin.org/headers: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) 
                 
ok</strong></span>
</pre><p class="calibre10">Again, the test passed successfully and we have got two timeout errors. The URLs were correct, but we didn't have a response in less than one millisecond, so the client has returned a timeout error.</p></div></div></div></body></html>