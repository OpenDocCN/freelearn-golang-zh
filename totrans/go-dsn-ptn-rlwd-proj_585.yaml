- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We needed to define a package variable called `timeoutMilliseconds`. Let''s
    start from there:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The initial timeout delay is 5 seconds (5,000 milliseconds) and we will need
    those packages in our code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: OK, so we need a function that launches a Goroutine for each endpoint URL. Do
    you remember how we achieve the communication between Goroutines? Exactly--channels!
    So we will need a channel to handle responses and a channel to handle errors.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can simplify it a bit more. We will receive two correct responses, two
    errors, or a response and an error; in any case, there are always two responses,
    so we can join errors and responses in a merged type:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, each Goroutine will send back a value of the `barrierResp` type. This value
    will have a value for `Err` or a value for the `Resp` field.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'The procedure is simple: we create a channel of size 2, the one that will receive
    responses of the `barrierResp` type, we launch both requests and wait for two
    responses, and then check to see if there is any error:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Following the previous description, we created a buffered channel called `in`,
    making it the size of the incoming endpoints, and we deferred channel closing.
    Then, we launched a function called `makeRequest` with each endpoint and the response
    channel.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Now we will loop  twice, once for each endpoint. In the loop, we block the execution
    waiting for data from the `in` channel. If we find an error, we print it prefixed
    with the word *ERROR* as we expect in our tests, and set `hasErrorvar` to true.
    After two responses, if we don't find any error (`hasError== false`) we print
    every response and the channel will be closed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'We still lack the `makeRequest` function:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `makeRequest` function is a very straightforward functions that accepts
    a channel to output `barrierResp` values to and a URL to request. We create an
    `http.Client` and set its timeout field to the value of the `timeoutMilliseconds`
    package variable. This is how we can change the timeout delay before the `in`
    function tests. Then, we simply make the `GET` call, take the response, parse
    it to a byte slice, and send it through the `out` channel.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: We do all this by filling a variable called `res` of the `barrierResp` type.
    If we find an error while performing a `GET` request or parsing the body of the
    result, we fill the `res.Err` field, send it to the `out` channel (which has the
    opposite side connected to the original Goroutine), and exit the function (so
    we don't send two values through the `out` channel by mistake).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Time to run the tests. Remember that you need an Internet connection, or the
    first two tests will fail. We will first try the test that has two endpoints that
    are correct:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Perfect. We have a JSON response with a key, `headers`, and another JSON response
    with a key `User-Agent`. In our integration tests, we were looking for the strings, `User-Agent`
    and `Accept-Encoding`, which are present, so the test has passed successfully.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will run the test that has an incorrect endpoint:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将运行一个有错误端点的测试：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can see that we have had an error where `http://malformed-url` has returned
    a *no such host* error. A request to this URL must return a text with the word
    `ERROR:` prefixed, as we stated during the acceptance criteria, that's why this
    test is correct (we don't have a false positive).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们遇到了一个错误，即`http://malformed-url`返回了一个“没有这样的主机”错误。对这个URL的请求必须返回以`ERROR:`开头的前缀文本，正如我们在验收标准中所述，这就是为什么这个测试是正确的（我们没有假阳性）。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In testing, it''s very important to understand the concepts of "false positive"
    and "false negative" tests. A false positive test is roughly described as a test
    that passes a condition when it shouldn''t (result: all passed) while the false
    negative is just the reverse (result: test failed). For example, we could be testing
    that a string is returned when doing the requests but, the returned string could
    be completely empty! This will lead to a false negative, a test that doesn''t
    fail even when we are checking a behavior that is incorrect on purpose (a request
    to `http://malformed-url`).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，理解“假阳性”和“假阴性”测试的概念非常重要。假阳性测试大致描述为在不应通过条件时通过测试（结果：全部通过）而假阴性则正好相反（结果：测试失败）。例如，我们可能在请求时测试是否返回字符串，但返回的字符串可能是完全空的！这将导致假阴性，即即使我们在检查故意错误的行为（对`http://malformed-url`的请求）时，测试也没有失败。
- en: 'The last test reduced the timeout time to 1 ms:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次测试将超时时间减少到1毫秒：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, the test passed successfully and we have got two timeout errors. The
    URLs were correct, but we didn't have a response in less than one millisecond,
    so the client has returned a timeout error.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，测试成功通过，我们得到了两个超时错误。URL是正确的，但我们没有在不到一毫秒的时间内收到响应，因此客户端返回了超时错误。
