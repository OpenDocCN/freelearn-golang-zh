- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'We needed to define a package variable called `timeoutMilliseconds`. Let''s
    start from there:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义一个名为 `timeoutMilliseconds` 的包变量。让我们从这里开始：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The initial timeout delay is 5 seconds (5,000 milliseconds) and we will need
    those packages in our code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的超时延迟是 5 秒（5,000 毫秒），我们将在我们的代码中需要这些包。
- en: OK, so we need a function that launches a Goroutine for each endpoint URL. Do
    you remember how we achieve the communication between Goroutines? Exactly--channels!
    So we will need a channel to handle responses and a channel to handle errors.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们需要一个函数来为每个端点 URL 启动一个 Goroutine。你还记得我们是如何在 Goroutine 之间实现通信的吗？没错——通道！所以我们需要一个通道来处理响应，另一个通道来处理错误。
- en: 'But we can simplify it a bit more. We will receive two correct responses, two
    errors, or a response and an error; in any case, there are always two responses,
    so we can join errors and responses in a merged type:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以进一步简化它。我们将收到两个正确的响应，两个错误，或者一个响应和一个错误；在任何情况下，总是有两个响应，所以我们可以将错误和响应合并到一个合并类型中：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, each Goroutine will send back a value of the `barrierResp` type. This value
    will have a value for `Err` or a value for the `Resp` field.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个 Goroutine 都会发送一个 `barrierResp` 类型的值。这个值将包含 `Err` 字段的值或 `Resp` 字段的值。
- en: 'The procedure is simple: we create a channel of size 2, the one that will receive
    responses of the `barrierResp` type, we launch both requests and wait for two
    responses, and then check to see if there is any error:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 程序很简单：我们创建了一个大小为 2 的通道，它将接收 `barrierResp` 类型的响应，我们启动了两个请求并等待两个响应，然后检查是否有任何错误：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Following the previous description, we created a buffered channel called `in`,
    making it the size of the incoming endpoints, and we deferred channel closing.
    Then, we launched a function called `makeRequest` with each endpoint and the response
    channel.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的描述，我们创建了一个缓冲通道 `in`，使其大小与传入的端点相同，并延迟了通道的关闭。然后，我们为每个端点启动了一个名为 `makeRequest`
    的函数和响应通道。
- en: Now we will loop  twice, once for each endpoint. In the loop, we block the execution
    waiting for data from the `in` channel. If we find an error, we print it prefixed
    with the word *ERROR* as we expect in our tests, and set `hasErrorvar` to true.
    After two responses, if we don't find any error (`hasError== false`) we print
    every response and the channel will be closed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将循环两次，一次针对每个端点。在循环中，我们阻塞执行，等待来自 `in` 通道的数据。如果我们发现错误，我们将打印它，并在前面加上单词 *ERROR*，正如我们在测试中预期的那样，并将
    `hasErrorvar` 设置为 true。在两个响应之后，如果我们没有找到任何错误（`hasError== false`），我们将打印每个响应，并且通道将被关闭。
- en: 'We still lack the `makeRequest` function:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然缺少 `makeRequest` 函数：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `makeRequest` function is a very straightforward functions that accepts
    a channel to output `barrierResp` values to and a URL to request. We create an
    `http.Client` and set its timeout field to the value of the `timeoutMilliseconds`
    package variable. This is how we can change the timeout delay before the `in`
    function tests. Then, we simply make the `GET` call, take the response, parse
    it to a byte slice, and send it through the `out` channel.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeRequest` 函数是一个非常直接的函数，它接受一个输出 `barrierResp` 值的通道和一个请求的 URL。我们创建一个 `http.Client`
    并将其超时字段设置为 `timeoutMilliseconds` 包变量的值。这就是我们可以在 `in` 函数测试之前更改超时延迟的方法。然后，我们简单地发起
    `GET` 请求，获取响应，将其解析为字节切片，并通过 `out` 通道发送。'
- en: We do all this by filling a variable called `res` of the `barrierResp` type.
    If we find an error while performing a `GET` request or parsing the body of the
    result, we fill the `res.Err` field, send it to the `out` channel (which has the
    opposite side connected to the original Goroutine), and exit the function (so
    we don't send two values through the `out` channel by mistake).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过填充一个名为 `res` 的 `barrierResp` 类型变量来完成所有这些。如果在执行 `GET` 请求或解析结果体时发现错误，我们将填充
    `res.Err` 字段，将其发送到 `out` 通道（其另一端连接到原始 Goroutine），并退出函数（这样我们就不小心通过 `out` 通道发送两个值了）。
- en: 'Time to run the tests. Remember that you need an Internet connection, or the
    first two tests will fail. We will first try the test that has two endpoints that
    are correct:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行测试了。请记住，你需要一个互联网连接，否则前两个测试将会失败。我们首先尝试测试包含两个正确端点的测试：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Perfect. We have a JSON response with a key, `headers`, and another JSON response
    with a key `User-Agent`. In our integration tests, we were looking for the strings, `User-Agent`
    and `Accept-Encoding`, which are present, so the test has passed successfully.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。我们得到了一个包含键 `headers` 的 JSON 响应，以及另一个包含键 `User-Agent` 的 JSON 响应。在我们的集成测试中，我们寻找的是字符串
    `User-Agent` 和 `Accept-Encoding`，它们都存在，所以测试已经成功通过。
- en: 'Now we will run the test that has an incorrect endpoint:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将运行一个有错误端点的测试：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can see that we have had an error where `http://malformed-url` has returned
    a *no such host* error. A request to this URL must return a text with the word
    `ERROR:` prefixed, as we stated during the acceptance criteria, that's why this
    test is correct (we don't have a false positive).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们遇到了一个错误，即`http://malformed-url`返回了一个“没有这样的主机”错误。对这个URL的请求必须返回以`ERROR:`开头的前缀文本，正如我们在验收标准中所述，这就是为什么这个测试是正确的（我们没有假阳性）。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In testing, it''s very important to understand the concepts of "false positive"
    and "false negative" tests. A false positive test is roughly described as a test
    that passes a condition when it shouldn''t (result: all passed) while the false
    negative is just the reverse (result: test failed). For example, we could be testing
    that a string is returned when doing the requests but, the returned string could
    be completely empty! This will lead to a false negative, a test that doesn''t
    fail even when we are checking a behavior that is incorrect on purpose (a request
    to `http://malformed-url`).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，理解“假阳性”和“假阴性”测试的概念非常重要。假阳性测试大致描述为在不应通过条件时通过测试（结果：全部通过）而假阴性则正好相反（结果：测试失败）。例如，我们可能在请求时测试是否返回字符串，但返回的字符串可能是完全空的！这将导致假阴性，即即使我们在检查故意错误的行为（对`http://malformed-url`的请求）时，测试也没有失败。
- en: 'The last test reduced the timeout time to 1 ms:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次测试将超时时间减少到1毫秒：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Again, the test passed successfully and we have got two timeout errors. The
    URLs were correct, but we didn't have a response in less than one millisecond,
    so the client has returned a timeout error.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，测试成功通过，我们得到了两个超时错误。URL是正确的，但我们没有在不到一毫秒的时间内收到响应，因此客户端返回了超时错误。
