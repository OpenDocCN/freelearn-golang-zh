<html><head></head><body>
<div class="book" title="Future design pattern">
<div class="book" title="Description"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec0218" class="calibre1"/>Description</h2></div></div></div><p class="calibre10">In short, we will define each possible behavior of an action before executing them in different Goroutines. Node.js uses this approach, providing event-driven programming by default. The idea here is to achieve a <span class="strong"><em class="calibre11">fire-and-forget</em></span> that handles all possible results in an action.</p><p class="calibre10">To understand it better, we can talk about a type that has embedded the behavior in case an execution goes well or in case it fails.</p><p class="calibre10">
</p><div class="mediaobject"><img src="../images/00040.jpeg" alt="Description" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">
</p><p class="calibre10">In the preceding diagram, the <code class="email">main</code> function launches a <span class="strong"><strong class="calibre2">Future</strong></span> within a new Goroutine. It won't wait for anything, nor will it receive any progress of the Future. It really fires and forgets it.</p><p class="calibre10">The interesting thing here is that we can launch a new Future within a Future and embed as many Futures as we want in the same Goroutine (or new ones). The idea is to take advantage of the result of one Future to launch the next. For example:</p><p class="calibre10">
</p><div class="mediaobject"><img src="../images/00041.jpeg" alt="Description" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">
</p><p class="calibre10">Here, we have the same Future. In this case, if the <code class="email">Execute</code> function returned a correct result, the <code class="email">Success</code> function is executed, and only in this case we execute a new Goroutine with another Future inside (or even without a Goroutine).</p><p class="calibre10">This is a kind of lazy programming, where a Future could be calling to itself indefinitely or just until some rule is satisfied. The idea is to define the behavior in advance and let the future resolve the possible solutions.</p></div></div></body></html>