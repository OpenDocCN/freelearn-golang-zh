- en: Description
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述
- en: In short, we will define each possible behavior of an action before executing
    them in different Goroutines. Node.js uses this approach, providing event-driven
    programming by default. The idea here is to achieve a *fire-and-forget* that handles
    all possible results in an action.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们将在不同的Goroutine中执行之前定义每个动作的每个可能行为。Node.js使用这种方法，默认提供事件驱动编程。这里的理念是实现一种*触发并忘记*，它可以处理动作中所有可能的结果。
- en: To understand it better, we can talk about a type that has embedded the behavior
    in case an execution goes well or in case it fails.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解，我们可以讨论一种类型，它将行为嵌入其中，无论是执行成功还是失败。
- en: '![Description](img/00040.jpeg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![描述](img/00040.jpeg)'
- en: In the preceding diagram, the `main` function launches a **Future** within a
    new Goroutine. It won't wait for anything, nor will it receive any progress of
    the Future. It really fires and forgets it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，`main`函数在一个新的Goroutine中启动了一个**Future**。它不会等待任何事情，也不会接收Future的任何进度。它实际上是一次性触发并忘记。
- en: 'The interesting thing here is that we can launch a new Future within a Future
    and embed as many Futures as we want in the same Goroutine (or new ones). The
    idea is to take advantage of the result of one Future to launch the next. For
    example:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有趣的是，我们可以在Future中启动一个新的Future，并在同一个Goroutine（或新的）中嵌入尽可能多的Future。其理念是利用一个Future的结果来启动下一个。例如：
- en: '![Description](img/00041.jpeg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![描述](img/00041.jpeg)'
- en: Here, we have the same Future. In this case, if the `Execute` function returned
    a correct result, the `Success` function is executed, and only in this case we
    execute a new Goroutine with another Future inside (or even without a Goroutine).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们拥有相同的Future。在这种情况下，如果`Execute`函数返回了正确的结果，则执行`Success`函数，并且只有在这种情况下，我们才会在一个新的Goroutine中执行另一个包含Future的新操作（或者甚至没有Goroutine）。
- en: This is a kind of lazy programming, where a Future could be calling to itself
    indefinitely or just until some rule is satisfied. The idea is to define the behavior
    in advance and let the future resolve the possible solutions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种懒惰编程，其中Future可以无限期地调用自己，或者直到某个规则得到满足为止。其理念是提前定义行为，并让未来解决可能的解决方案。
