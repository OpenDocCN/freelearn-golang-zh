- en: Unit tests
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'So, as we mentioned, we will use first class functions to achieve this behavior,
    and we will need three specific types of function:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如我们提到的，我们将使用一等函数来实现这种行为，并且我们需要三种特定的函数类型：
- en: '`type SuccessFunc func(string)`: The `SuccessFunc` function will be executed
    if everything went well. Its string argument will be the result of the operation,
    so this function will be called by our Goroutine.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type SuccessFunc func(string)`: 如果一切顺利，将执行`SuccessFunc`函数。它的字符串参数将是操作的结果，因此这个函数将由我们的Goroutine调用。'
- en: '`type FailFunc func(error)`: The `FailFunc` function handles the opposite result,
    that is, when something goes wrong, and, as you can see, it will return an error.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type FailFunc func(error)`: `FailFunc`函数处理相反的结果，即当出现错误时，并且，正如你所看到的，它将返回一个错误。'
- en: '`type ExecuteStringFunc func() (string, error)`: Finally, the `ExecuteStringFunc` function
    is a type that defines the operation we want to perform. Maybe it will return
    a string or an error. Don''t worry if this all seems confusing; it will be clearer
    later.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type ExecuteStringFunc func() (string, error)`: 最后，`ExecuteStringFunc`函数是一个类型，它定义了我们想要执行的操作。也许它会返回一个字符串或一个错误。如果你觉得这一切都很混乱，不用担心；稍后会更清楚。'
- en: 'So, we create the `future` object, we define a success behavior, we define
    a fail behavior, and we pass an `ExecuteStringFunc` type to be executed. In the
    implementation file, we''ll need a new type:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们创建了一个`future`对象，定义了一个成功行为，定义了一个失败行为，并将一个`ExecuteStringFunc`类型传递以执行。在实现文件中，我们需要一个新的类型：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will also create two tests in the `_test.go` file:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在`_test.go`文件中创建两个测试：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will define functions by chaining them, as you would usually see in Node.js.
    Code like this is compact and not particularly difficult to follow:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过链式调用定义函数，就像你通常在Node.js中看到的那样。这样的代码紧凑，并不特别难懂：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `future.Success` function must be defined in the `MaybeString` structure
    to accept a `SuccessFunc` function that will be executed if everything goes correctly
    and return the same pointer to the `future` object (so we can keep chaining).
    The `Fail` function must also be defined in the `MaybeString` structure and must
    accept a `FailFunc` function to later return the pointer. We return the pointer
    in both cases so we can define the `Fail` and the `Success` or vice versa.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`future.Success`函数必须在`MaybeString`结构中定义，以接受一个`SuccessFunc`函数，如果一切顺利，该函数将被执行，并返回相同的`future`对象指针（这样我们就可以继续链式调用）。`Fail`函数也必须在`MaybeString`结构中定义，并必须接受一个`FailFunc`函数，稍后返回指针。在两种情况下，我们都返回指针，这样我们就可以定义`Fail`和`Success`或反之亦然。'
- en: Finally, we use the `Execute` method to pass an `ExecuteStringFunc` type (a
    function that accepts nothing and returns a string or an error). In this case,
    we return a string and nil, so we expect that the `SuccessFunc` function will
    be executed and we log the result to the console. In case that fail function is
    executed, the test has failed because the `FailFunc` function shouldn't be executed
    for a returned nil error.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`Execute`方法传递一个`ExecuteStringFunc`类型（一个不接受任何参数并返回字符串或错误的函数）。在这种情况下，我们返回一个字符串和nil，因此我们期望执行`SuccessFunc`函数并将结果记录到控制台。如果执行失败函数，则测试失败，因为对于返回的nil错误，`FailFunc`函数不应该被执行。
- en: 'But we still lack something here. We said that the function must be executed
    asynchronously in a different Goroutine, so we have to synchronize this test somehow
    so that it doesn''t finish too soon. Again, we can use a channel or a `sync.WaitGroup`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们在这里仍然缺少一些东西。我们说函数必须在不同的Goroutine中异步执行，因此我们必须以某种方式同步这个测试，以便它不会太早完成。同样，我们可以使用一个通道或`sync.WaitGroup`：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have seen WaitGroups before in the previous channel. This WaitGroup is configured
    to wait for one signal (`wg.Add(1)`). The `Success` and `Fail` methods will trigger
    the `Done()` method of the `WaitGroup` to allow execution to continue and finish
    testing (that is why the `Wait()` method is at the end). Remember that each `Done()`
    method will subtract one from the WaitGroup, and we have added only one, so our
    `Wait()` method will only block until one `Done()` method is executed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的通道中已经看到了WaitGroups。这个WaitGroup被配置为等待一个信号（`wg.Add(1)`）。`Success`和`Fail`方法将触发`WaitGroup`的`Done()`方法，以允许执行继续并完成测试（这就是为什么`Wait()`方法在最后）。记住，每个`Done()`方法都会从WaitGroup中减去一个，我们只添加了一个，所以我们的`Wait()`方法只会阻塞，直到执行了一个`Done()`方法。
- en: 'Using what we know of making a `Success` result unit test, it''s easy to make
    a Failed result unit test by swapping the `t.Fail()` method call from the error
    to success so that the test fails if a call to success is done:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们已知的知识来创建一个`成功`结果单元测试，通过将`t.Fail()`方法调用从错误更改为成功，就可以轻松地创建一个`失败`结果单元测试，这样如果执行了成功的调用，测试就会失败：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you are using an IDE like me, your `Success`, `Fail`, and `Execute` method
    calls must be in red. This is because we lack our method''s declaration in the
    implementation file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像我一样使用IDE，你的`Success`、`Fail`和`Execute`方法调用必须显示为红色。这是因为我们在实现文件中缺少方法声明：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our test seems ready to execute. Let''s try it out:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试看起来已经准备好执行了。让我们试一试：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Well... the tests have failed, yes... but not in a controllable way. Why is
    this? We don't have any implementation yet, so no `Success` or `Fail` functions
    are being executed either. Our WaitGroup is waiting forever for a call to the `Done()`
    method that will never arrive, so it can't continue and finish the test. That's
    the meaning of *All Goroutines are asleep - deadlock!*. In our specific example,
    it would mean *Nobody is going to call Done(), so we are dead!*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯...测试失败了，是的...但不是可控的方式。为什么是这样？我们还没有任何实现，所以既没有执行`Success`也没有执行`Fail`函数。我们的WaitGroup正在无限期地等待一个永远不会到达的`Done()`方法调用，因此它无法继续并完成测试。这就是*所有Goroutines都处于休眠状态
    - 死锁*的含义。在我们的具体例子中，这意味着*没有人会调用Done()，所以我们处于死锁状态!*。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Thanks to the Go compiler and the runtime executor, we can detect deadlocks
    easily. Imagine if Go runtime couldn't detect deadlocks--we would be effectively
    stuck in a blank screen without knowing what was wrong.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢Go编译器和运行时执行器，我们可以轻松地检测死锁。想象一下，如果Go运行时无法检测死锁，我们就会有效地陷入一个空白屏幕，而不知道出了什么问题。
- en: So how can we solve this? Well, an easy way would be with a timeout that calls
    the `Done()` method after waiting a while for completion. For this code, it's
    safe to wait for 1 second because it's not doing long-running operations.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们该如何解决这个问题呢？一个简单的方法是在等待一段时间后调用`Done()`方法。对于这段代码，等待1秒钟是安全的，因为它没有进行长时间运行的操作。
- en: 'We will declare a `timeout` function within our `test` file that waits for
    a second, then prints a message, sets the test as failed, and lets the WaitGroup
    continue by calling its `Done()` method:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`test`文件中声明一个`timeout`函数，该函数等待一秒钟，然后打印一条消息，将测试设置为失败，并通过调用其`Done()`方法让WaitGroup继续：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The final look of each subtest is similar to our previous example of the `"Success
    result"`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子测试的最终外观类似于我们之前的`"成功结果"`示例：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s see what happens when we execute our tests again:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看再次执行我们的测试会发生什么：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our tests failed, but in a controlled way. Look at the end of the `FAIL` lines--notice
    how the elapsed time is 1 second because it has been triggered by the timeout,
    as we can see in the logging messages.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试虽然失败了，但是以可控的方式进行。看看`FAIL`行尾——注意，经过的时间是1秒，因为它已经被超时触发，正如我们在日志消息中看到的那样。
- en: It's time to pass to the implementation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候转向实现部分了。
