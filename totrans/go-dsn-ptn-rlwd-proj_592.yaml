- en: Unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, as we mentioned, we will use first class functions to achieve this behavior,
    and we will need three specific types of function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type SuccessFunc func(string)`: The `SuccessFunc` function will be executed
    if everything went well. Its string argument will be the result of the operation,
    so this function will be called by our Goroutine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type FailFunc func(error)`: The `FailFunc` function handles the opposite result,
    that is, when something goes wrong, and, as you can see, it will return an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type ExecuteStringFunc func() (string, error)`: Finally, the `ExecuteStringFunc` function
    is a type that defines the operation we want to perform. Maybe it will return
    a string or an error. Don''t worry if this all seems confusing; it will be clearer
    later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we create the `future` object, we define a success behavior, we define
    a fail behavior, and we pass an `ExecuteStringFunc` type to be executed. In the
    implementation file, we''ll need a new type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also create two tests in the `_test.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define functions by chaining them, as you would usually see in Node.js.
    Code like this is compact and not particularly difficult to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `future.Success` function must be defined in the `MaybeString` structure
    to accept a `SuccessFunc` function that will be executed if everything goes correctly
    and return the same pointer to the `future` object (so we can keep chaining).
    The `Fail` function must also be defined in the `MaybeString` structure and must
    accept a `FailFunc` function to later return the pointer. We return the pointer
    in both cases so we can define the `Fail` and the `Success` or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the `Execute` method to pass an `ExecuteStringFunc` type (a
    function that accepts nothing and returns a string or an error). In this case,
    we return a string and nil, so we expect that the `SuccessFunc` function will
    be executed and we log the result to the console. In case that fail function is
    executed, the test has failed because the `FailFunc` function shouldn't be executed
    for a returned nil error.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we still lack something here. We said that the function must be executed
    asynchronously in a different Goroutine, so we have to synchronize this test somehow
    so that it doesn''t finish too soon. Again, we can use a channel or a `sync.WaitGroup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have seen WaitGroups before in the previous channel. This WaitGroup is configured
    to wait for one signal (`wg.Add(1)`). The `Success` and `Fail` methods will trigger
    the `Done()` method of the `WaitGroup` to allow execution to continue and finish
    testing (that is why the `Wait()` method is at the end). Remember that each `Done()`
    method will subtract one from the WaitGroup, and we have added only one, so our
    `Wait()` method will only block until one `Done()` method is executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using what we know of making a `Success` result unit test, it''s easy to make
    a Failed result unit test by swapping the `t.Fail()` method call from the error
    to success so that the test fails if a call to success is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using an IDE like me, your `Success`, `Fail`, and `Execute` method
    calls must be in red. This is because we lack our method''s declaration in the
    implementation file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our test seems ready to execute. Let''s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Well... the tests have failed, yes... but not in a controllable way. Why is
    this? We don't have any implementation yet, so no `Success` or `Fail` functions
    are being executed either. Our WaitGroup is waiting forever for a call to the `Done()`
    method that will never arrive, so it can't continue and finish the test. That's
    the meaning of *All Goroutines are asleep - deadlock!*. In our specific example,
    it would mean *Nobody is going to call Done(), so we are dead!*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thanks to the Go compiler and the runtime executor, we can detect deadlocks
    easily. Imagine if Go runtime couldn't detect deadlocks--we would be effectively
    stuck in a blank screen without knowing what was wrong.
  prefs: []
  type: TYPE_NORMAL
- en: So how can we solve this? Well, an easy way would be with a timeout that calls
    the `Done()` method after waiting a while for completion. For this code, it's
    safe to wait for 1 second because it's not doing long-running operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will declare a `timeout` function within our `test` file that waits for
    a second, then prints a message, sets the test as failed, and lets the WaitGroup
    continue by calling its `Done()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The final look of each subtest is similar to our previous example of the `"Success
    result"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what happens when we execute our tests again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our tests failed, but in a controlled way. Look at the end of the `FAIL` lines--notice
    how the elapsed time is 1 second because it has been triggered by the timeout,
    as we can see in the logging messages.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to pass to the implementation.
  prefs: []
  type: TYPE_NORMAL
