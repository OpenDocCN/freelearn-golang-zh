- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: According to our tests, the implementation must take a `SuccessFunc`, a `FailFunc`,
    and an `ExecuteStringFunc` function in a chained fashion within the `MaybeString`
    type and launches the `ExecuteStringFunc` function asynchronously to call `SuccessFunc`
    or `FailFunc` functions according to the returned result of the `ExecuteStringFunc`
    function.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的测试，实现必须在 `MaybeString` 类型中以链式方式接收 `SuccessFunc`、`FailFunc` 和 `ExecuteStringFunc`
    函数，并异步启动 `ExecuteStringFunc` 函数来根据 `ExecuteStringFunc` 函数返回的结果调用 `SuccessFunc`
    或 `FailFunc` 函数。
- en: 'The chain is implemented by storing the functions within the type and returning
    the pointer to the type. We are talking about our previously declared type methods,
    of course:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 链接是通过在类型中存储函数并返回类型指针来实现的。我们当然是在谈论之前声明的类型方法：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We needed two fields to store the `SuccessFunc` and `FailFunc` functions, which
    are named the `successFunc` and `failFunc` fields respectively. This way, calls
    to the `Success` and `Fail` methods simply store their incoming functions to our
    new fields. They are simply setters that also return the pointer to the specific
    `MaybeString` value. These type methods take a pointer to the `MaybeString` structure,
    so don't forget to put "`*`" on `MaybeString` after the `func` declaration.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个字段来存储 `SuccessFunc` 和 `FailFunc` 函数，分别命名为 `successFunc` 和 `failFunc` 字段。这样，对
    `Success` 和 `Fail` 方法的调用只是将传入的函数存储到我们新的字段中。它们只是返回特定 `MaybeString` 值指针的设置器。这些类型方法接受
    `MaybeString` 结构的指针，所以不要忘记在 `func` 声明后 `MaybeString` 上加上 "`*`"。
- en: Execute takes the `ExecuteStringFunc` method and executes it asynchronously.
    This seems quite simple with a Goroutine, right?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`Execute` 方法接收 `ExecuteStringFunc` 方法并异步执行。这用 Goroutine 来看似乎很简单，对吧？'
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Looks quite simple because it is simple! We launch the Goroutine that executes
    the `f` method (an `ExecuteStringFunc`) and takes its result--maybe a string and
    maybe an error. If an error is present, we call the field `failFunc` in our `MaybeString`
    structure. If no error is present, we call the `successFunc` field. We use a Goroutine
    to delegate a function execution and error handling so our Goroutine doesn't have
    to do it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单，因为它确实很简单！我们启动执行 `f` 方法（一个 `ExecuteStringFunc`）的 Goroutine 并获取其结果——可能是一个字符串和一个错误。如果存在错误，我们在
    `MaybeString` 结构中调用 `failFunc` 字段。如果没有错误，我们调用 `successFunc` 字段。我们使用 Goroutine
    来委托函数执行和错误处理，这样我们的 Goroutine 就不必执行它。
- en: 'Let''s run unit tests now:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行单元测试：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Great! Look how the execution time is now nearly zero, so our timeouts have
    not been executed (actually, they were executed, but the tests already finished
    and their result was already stated).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！看看执行时间现在几乎为零，所以我们的超时没有被执行（实际上，它们已经执行了，但测试已经完成，结果已经声明）。
- en: What's more, now we can use our `MaybeString` type to asynchronously execute
    any type of function that accepts nothing and returns a string or an error. A
    function that accepts nothing seems a bit useless, right? But we can use closures
    to introduce a context into this type of function.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，现在我们可以使用我们的 `MaybeString` 类型异步执行任何不接受任何参数并返回字符串或错误的函数。不接受任何参数的函数似乎有点无用，对吧？但我们可以使用闭包将上下文引入这种类型的函数。
- en: 'Let''s write a `setContext` function that takes a string as an argument and
    returns an `ExecuteStringFunc` method that returns the previous argument with
    the suffix `Closure!`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个 `setContext` 函数，它接受一个字符串作为参数，并返回一个返回前一个参数后缀为 `Closure!` 的 `ExecuteStringFunc`
    方法：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, we can write a new test that uses this closure:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以编写一个新的测试，使用这个闭包：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `setContext` function returns an `ExecuteStringFunc` method it can pass
    directly to the `Execute` function. We call the `setContext` function with an
    arbitrary text that we know will be returned.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`setContext` 函数返回一个可以直接传递给 `Execute` 函数的 `ExecuteStringFunc` 方法。我们使用一个任意文本调用
    `setContext` 函数，我们知道它将返回。'
- en: Let's execute our tests again. Now everything has to go well!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次执行我们的测试。现在一切必须顺利！
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It gave us an OK too. Closure test shows the behavior that we explained before.
    By taking a message `"Hello"` and appending it with something else (`"Closure!"`),
    we can change the context of the text we want to return. Now scale this to a HTTP
    `GET` call, a call to a database, or anything you can imagine. It will just need
    to end by returning a string or an error. Remember, however, that everything within
    the `setContext` function but outside of the anonymous function that we are returning
    is not concurrent, and will be executed asynchronously before calling execute,
    so we must try to put as much logic as possible within the anonymous function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它也给了我们一个OK。闭包测试显示了之前解释过的行为。通过取一个消息 `"Hello"` 并将其与其它内容（`"Closure!"`）拼接，我们可以改变我们想要返回的文本的上下文。现在将这个概念扩展到HTTP
    `GET` 调用、对数据库的调用，或者你能想象到的任何东西。它只需要以返回一个字符串或错误来结束。然而，记住，在`setContext`函数内部但不在我们返回的匿名函数之外的任何内容都不是并发的，它将在调用execute之前异步执行，所以我们必须尽量在匿名函数内放置尽可能多的逻辑。
