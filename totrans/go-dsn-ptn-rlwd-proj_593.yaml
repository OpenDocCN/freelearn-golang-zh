- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to our tests, the implementation must take a `SuccessFunc`, a `FailFunc`,
    and an `ExecuteStringFunc` function in a chained fashion within the `MaybeString`
    type and launches the `ExecuteStringFunc` function asynchronously to call `SuccessFunc`
    or `FailFunc` functions according to the returned result of the `ExecuteStringFunc`
    function.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The chain is implemented by storing the functions within the type and returning
    the pointer to the type. We are talking about our previously declared type methods,
    of course:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We needed two fields to store the `SuccessFunc` and `FailFunc` functions, which
    are named the `successFunc` and `failFunc` fields respectively. This way, calls
    to the `Success` and `Fail` methods simply store their incoming functions to our
    new fields. They are simply setters that also return the pointer to the specific
    `MaybeString` value. These type methods take a pointer to the `MaybeString` structure,
    so don't forget to put "`*`" on `MaybeString` after the `func` declaration.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Execute takes the `ExecuteStringFunc` method and executes it asynchronously.
    This seems quite simple with a Goroutine, right?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Looks quite simple because it is simple! We launch the Goroutine that executes
    the `f` method (an `ExecuteStringFunc`) and takes its result--maybe a string and
    maybe an error. If an error is present, we call the field `failFunc` in our `MaybeString`
    structure. If no error is present, we call the `successFunc` field. We use a Goroutine
    to delegate a function execution and error handling so our Goroutine doesn't have
    to do it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run unit tests now:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Great! Look how the execution time is now nearly zero, so our timeouts have
    not been executed (actually, they were executed, but the tests already finished
    and their result was already stated).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: What's more, now we can use our `MaybeString` type to asynchronously execute
    any type of function that accepts nothing and returns a string or an error. A
    function that accepts nothing seems a bit useless, right? But we can use closures
    to introduce a context into this type of function.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a `setContext` function that takes a string as an argument and
    returns an `ExecuteStringFunc` method that returns the previous argument with
    the suffix `Closure!`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, we can write a new test that uses this closure:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `setContext` function returns an `ExecuteStringFunc` method it can pass
    directly to the `Execute` function. We call the `setContext` function with an
    arbitrary text that we know will be returned.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Let's execute our tests again. Now everything has to go well!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It gave us an OK too. Closure test shows the behavior that we explained before.
    By taking a message `"Hello"` and appending it with something else (`"Closure!"`),
    we can change the context of the text we want to return. Now scale this to a HTTP
    `GET` call, a call to a database, or anything you can imagine. It will just need
    to end by returning a string or an error. Remember, however, that everything within
    the `setContext` function but outside of the anonymous function that we are returning
    is not concurrent, and will be executed asynchronously before calling execute,
    so we must try to put as much logic as possible within the anonymous function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它也给了我们一个OK。闭包测试显示了之前解释过的行为。通过取一个消息 `"Hello"` 并将其与其它内容（`"Closure!"`）拼接，我们可以改变我们想要返回的文本的上下文。现在将这个概念扩展到HTTP
    `GET` 调用、对数据库的调用，或者你能想象到的任何东西。它只需要以返回一个字符串或错误来结束。然而，记住，在`setContext`函数内部但不在我们返回的匿名函数之外的任何内容都不是并发的，它将在调用execute之前异步执行，所以我们必须尽量在匿名函数内放置尽可能多的逻辑。
