<html><head></head><body>
<div class="book" title="Pipeline design pattern">
<div class="book" title="Implementation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch09lvl2sec0230" class="calibre1"/>Implementation</h2></div></div></div><p class="calibre10">The key for our implementation is to separate every operation in a different Goroutine and connect them with channels. The <code class="email">LaunchPipeline</code> function is the one that orchestrates them all, as shown in the following diagram:</p><p class="calibre10">
</p><div class="mediaobject"><img src="../images/00042.jpeg" alt="Implementation" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">
</p><p class="calibre10">The operation consist of three steps: generate a list of numbers, raise them to the power of 2, and add the resulting numbers.</p><p class="calibre10">Each step in this Pipeline pattern will have the following structure:</p><pre class="programlisting">func functionName(in &lt;-chan int) (&lt;-chan int){ 
  out := make(chan bool, 100) 
 
  go func(){ 
    for v := range in { 
      // Do something with v and send it to channel out 
} 
 
close(out) 
   }() 
 
  return out 
} 
</pre><p class="calibre10">This function represents a common step. Let's dissect it in the same order that the Go scheduler will probably take to execute it:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The <code class="email">functionName</code> function will commonly receive a channel to take values from (<code class="email">in &lt;-chan int</code>). We call it the <code class="email">in</code> function, as in the word incoming. We can't send values through it within the scope of this function; that's why the arrow points <code class="email">out</code> of the keyword <code class="email">chan</code>.</li><li class="listitem" value="2">The <code class="email">functionName</code> function returns a channel (<code class="email">&lt;-chan in</code>) that the function caller will only be allowed to take values from (again, represented by the arrow pointing <code class="email">out</code> of the keyword <code class="email">chan</code>). This also means that any value that goes through that channel must be generated within the scope of the function.</li><li class="listitem" value="3">In the first line of the function, we create a channel called <code class="email">out</code> that will be the return of the function (<span class="strong"><em class="calibre11">point 2</em></span> in this list).</li><li class="listitem" value="4">Then, we will launch a new Goroutine. Its scope will enter into play after returning this function, so let's continue.</li><li class="listitem" value="5">We return the previously created <code class="email">out</code> channel.</li><li class="listitem" value="6">Eventually, after finishing the execution of the function and returning the channel <code class="email">out</code>, the Goroutine executes. It will take values from the <code class="email">in</code> channel until it's closed. So the caller of this function is responsible for closing this channel, otherwise the Goroutine will never end!</li><li class="listitem" value="7">When the <code class="email">in</code> channel is closed, the for loop finishes and we close the <code class="email">out</code> channel. Any Goroutine making use of this channel will not receive any new values since the last that was sent.</li></ol><div class="calibre12"/></div><p class="calibre10">The only step that doesn't completely fit this approach is the first step that receives a number, representing the upper threshold on the list instead of a channel of incoming values. So, if we code this operation for each step in our pipeline, the final diagram looks more like this:</p><p class="calibre10">
</p><div class="mediaobject"><img src="../images/00043.jpeg" alt="Implementation" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">
</p><p class="calibre10">Although the idea is exactly the same, now we can see that it's the function <code class="email">LaunchPipeline</code> that is the one that is going to be receiving channels and sending them back to the next step in the Pipeline. Using this diagram, we can clearly see the flow of the pipeline creation by following the numbers of the arrows. A solid arrow represents a function call and a dashed arrow a channel.</p><p class="calibre10">Let's look a little more closely at the code.</p><div class="book" title="The list generator"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec04" class="calibre1"/>The list generator</h3></div></div></div><p class="calibre10">The first step in the operation is list generation. The list starts at <code class="email">1</code> and we will receive an integer representing the higher threshold. We have to pass each number in the list to the next step:</p><pre class="programlisting">func generator(max int) &lt;-chan int { 
  outChInt := make(chan int, 100) 
 
  go func() { 
    for i := 1; i &lt;= max; i++ { 
      outChInt &lt;- i 
    } 
 
    close(outChInt) 
  }() 
  return outChInt 
} 
</pre><p class="calibre10">As we mentioned earlier, this is the pattern that we will follow in each step: create a channel, launch the Goroutine that will send the data through the channel, and immediately return the channel. This Goroutine will iterate from 1 to the max argument, which is the higher threshold for our list, and send each number through the channel. After sending every number, the channel is closed so that no more data can be sent through it, but the data already buffered can be retrieved.</p></div><div class="book" title="Raising numbers to the power of 2"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec05" class="calibre1"/>Raising numbers to the power of 2</h3></div></div></div><p class="calibre10">The second step will take every incoming number from the first step's channel (that is taken from the arguments) and raise it to the power of 2. Every result must be sent to the third step using a new channel:</p><pre class="programlisting">func power(in &lt;-chan int) &lt;-chan int { 
  out := make(chan int, 100) 
 
  go func() { 
    for v := range in { 
      out &lt;- v * v 
    } 
    close(out) 
  }() 
  return out 
} 
</pre><p class="calibre10">We use the same pattern again: create a channel and launch the Goroutine while we return the created channel.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note021" class="calibre1"/>Note</h3><p class="calibre10">The<code class="email"> for-range</code> loop keeps taking values from a channel indefinitely until the channel is closed.</p></div></div><div class="book" title="Final reduce operation"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec06" class="calibre1"/>Final reduce operation</h3></div></div></div><p class="calibre10">The third and final step receives every number from the second step and keeps adding them to a local value until the connection channel is closed:</p><pre class="programlisting">func sum(in &lt;-chan int) &lt;-chan int { 
  out := make(chan int, 100) 
  go func() { 
    var sum int 
 
    for v := range in { 
      sum += v 
    } 
 
    out &lt;- sum 
    close(out) 
  }()
 
  return out 
} 
</pre><p class="calibre10">The function sum also takes a channel as an argument (the one returned from <span class="strong"><em class="calibre11">step 2</em></span>). It also follows the same pattern of creating a channel, launching the Goroutine, and returning a channel. Goroutine keeps adding values to a variable called <code class="email">sum</code> until the <code class="email">in</code> channel is closed. When the <code class="email">in</code> channel is closed, the value of sum is sent to the <code class="email">out</code> channel, and it's immediately closed.</p></div><div class="book" title="Launching the Pipeline pattern"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec07" class="calibre1"/>Launching the Pipeline pattern</h3></div></div></div><p class="calibre10">Finally, we can implement the <code class="email">LaunchPipeline</code> function:</p><pre class="programlisting">func LaunchPipeline(amount int) int { 
  firstCh := generator(amount) 
  secondCh := power(firstCh) 
  thirdCh := sum(secondCh) 
 
  result := &lt;-thirdCh 
 
  return result 
} 
</pre><p class="calibre10">The function <code class="email">generator</code> first returns the channel that is passed to the power function. The <code class="email">power</code> function returns the second channel that is passed to the <code class="email">sum</code> function. The function <code class="email">sum</code> finally returns the first channel that will receive a unique value, the result. Let's try to test this now:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   TestLaunchPipeline</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: TestLaunchPipeline (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">        pipeline_test.go:18: 14 == 14</strong></span>
<span class="strong"><strong class="calibre2">        pipeline_test.go:18: 55 == 55</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre><p class="calibre10">Awesome! It's worth mentioning that the <code class="email">LaunchPipeline</code> function doesn't need to allocate every channel, and can be rewritten like this:</p><pre class="programlisting">func LaunchPipeline(amount int) int { 
  return &lt;-sum(power(generator(amount))) 
} 
</pre><p class="calibre10">The result of the <code class="email">generator</code> function is passed directly to the <code class="email">power</code> function and the result of <code class="email">power</code> to <code class="email">sum</code> functions.</p></div></div></div></body></html>