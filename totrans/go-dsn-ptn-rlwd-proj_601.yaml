- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'The key for our implementation is to separate every operation in a different
    Goroutine and connect them with channels. The `LaunchPipeline` function is the
    one that orchestrates them all, as shown in the following diagram:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的关键是将每个操作分离到不同的 Goroutine 中，并通过通道将它们连接起来。`LaunchPipeline` 函数是协调所有这些操作的函数，如下面的图表所示：
- en: '![Implementation](img/00042.jpeg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/00042.jpeg)'
- en: 'The operation consist of three steps: generate a list of numbers, raise them
    to the power of 2, and add the resulting numbers.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 操作由三个步骤组成：生成一个数字列表，将它们提高到平方，然后添加结果数字。
- en: 'Each step in this Pipeline pattern will have the following structure:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此 Pipeline 模式中的每个步骤都将具有以下结构：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This function represents a common step. Let''s dissect it in the same order
    that the Go scheduler will probably take to execute it:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数代表一个常见步骤。让我们按照 Go 调度器可能执行它的顺序来分析它：
- en: The `functionName` function will commonly receive a channel to take values from
    (`in <-chan int`). We call it the `in` function, as in the word incoming. We can't
    send values through it within the scope of this function; that's why the arrow
    points `out` of the keyword `chan`.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`functionName` 函数通常接收一个通道来从中取值（`in <-chan int`）。我们称它为 `in` 函数，正如单词 incoming。我们无法在此函数的作用域内通过它发送值；这就是为什么箭头指向关键字
    `chan` 的外部。'
- en: The `functionName` function returns a channel (`<-chan in`) that the function
    caller will only be allowed to take values from (again, represented by the arrow
    pointing `out` of the keyword `chan`). This also means that any value that goes
    through that channel must be generated within the scope of the function.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`functionName` 函数返回一个通道 (`<-chan in`)，函数调用者只能从中取值（再次，由指向关键字 `chan` 的箭头表示）。这也意味着通过该通道传递的任何值都必须在函数的作用域内生成。'
- en: In the first line of the function, we create a channel called `out` that will
    be the return of the function (*point 2* in this list).
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数的第一行，我们创建了一个名为 `out` 的通道，它将是函数的返回值（此列表中的第 2 点）。
- en: Then, we will launch a new Goroutine. Its scope will enter into play after returning
    this function, so let's continue.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将启动一个新的 Goroutine。它的作用域将在返回此函数后进入，所以让我们继续。
- en: We return the previously created `out` channel.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们返回之前创建的 `out` 通道。
- en: Eventually, after finishing the execution of the function and returning the
    channel `out`, the Goroutine executes. It will take values from the `in` channel
    until it's closed. So the caller of this function is responsible for closing this
    channel, otherwise the Goroutine will never end!
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终，在执行完函数并返回通道 `out` 之后，Goroutine 将开始执行。它将从 `in` 通道中取值，直到该通道关闭。因此，调用此函数的责任人需要关闭此通道，否则
    Goroutine 将永远不会结束！
- en: When the `in` channel is closed, the for loop finishes and we close the `out`
    channel. Any Goroutine making use of this channel will not receive any new values
    since the last that was sent.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `in` 通道关闭时，for 循环结束，我们关闭 `out` 通道。任何使用此通道的 Goroutine 都不会收到最后发送的任何新值。
- en: 'The only step that doesn''t completely fit this approach is the first step
    that receives a number, representing the upper threshold on the list instead of
    a channel of incoming values. So, if we code this operation for each step in our
    pipeline, the final diagram looks more like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一不完全符合这种方法的步骤是第一个接收一个数字的步骤，该数字代表列表的上限阈值，而不是传入值的通道。因此，如果我们为管道中的每个步骤编写此操作，最终的图表看起来更像这样：
- en: '![Implementation](img/00043.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/00043.jpeg)'
- en: Although the idea is exactly the same, now we can see that it's the function
    `LaunchPipeline` that is the one that is going to be receiving channels and sending
    them back to the next step in the Pipeline. Using this diagram, we can clearly
    see the flow of the pipeline creation by following the numbers of the arrows.
    A solid arrow represents a function call and a dashed arrow a channel.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然想法完全相同，但现在我们可以看到，是 `LaunchPipeline` 函数将要接收通道并将它们发送回 Pipeline 中的下一个步骤。使用此图表，我们可以通过跟随箭头的数字清楚地看到管道创建的流程。实线箭头表示函数调用，虚线箭头表示通道。
- en: Let's look a little more closely at the code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看代码。
- en: The list generator
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列表生成器
- en: 'The first step in the operation is list generation. The list starts at `1`
    and we will receive an integer representing the higher threshold. We have to pass
    each number in the list to the next step:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的第一步是列表生成。列表从 `1` 开始，我们将接收一个表示更高阈值的整数。我们必须将列表中的每个数字传递到下一个步骤：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we mentioned earlier, this is the pattern that we will follow in each step:
    create a channel, launch the Goroutine that will send the data through the channel,
    and immediately return the channel. This Goroutine will iterate from 1 to the
    max argument, which is the higher threshold for our list, and send each number
    through the channel. After sending every number, the channel is closed so that
    no more data can be sent through it, but the data already buffered can be retrieved.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，这是我们将在每一步中遵循的模式：创建一个通道，启动一个Goroutine，该Goroutine将通过通道发送数据，并立即返回通道。这个Goroutine将从1迭代到最大参数，即我们列表的较高阈值，并将每个数字通过通道发送。发送完每个数字后，通道被关闭，因此无法再通过它发送更多数据，但已缓存的可以检索。
- en: Raising numbers to the power of 2
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数字平方
- en: 'The second step will take every incoming number from the first step''s channel
    (that is taken from the arguments) and raise it to the power of 2\. Every result
    must be sent to the third step using a new channel:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步将接收第一步的通道（即从参数中获取）的每个传入数字，并将其平方。每个结果都必须通过一个新的通道发送到第三步：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We use the same pattern again: create a channel and launch the Goroutine while
    we return the created channel.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用相同的模式：创建一个通道，并在返回创建的通道的同时启动Goroutine。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `for-range` loop keeps taking values from a channel indefinitely until the
    channel is closed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`for-range`循环无限期地从通道中获取值，直到通道关闭。'
- en: Final reduce operation
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最终的归约操作
- en: 'The third and final step receives every number from the second step and keeps
    adding them to a local value until the connection channel is closed:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步和最后一步接收第二步的每个数字，并将它们持续添加到一个局部值中，直到连接通道关闭：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The function sum also takes a channel as an argument (the one returned from
    *step 2*). It also follows the same pattern of creating a channel, launching the
    Goroutine, and returning a channel. Goroutine keeps adding values to a variable
    called `sum` until the `in` channel is closed. When the `in` channel is closed,
    the value of sum is sent to the `out` channel, and it's immediately closed.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`sum`也接受一个通道作为参数（来自*步骤2*）。它也遵循相同的模式：创建通道、启动Goroutine和返回通道。Goroutine持续将值添加到一个名为`sum`的变量中，直到`in`通道关闭。当`in`通道关闭时，`sum`的值被发送到`out`通道，并且它立即关闭。
- en: Launching the Pipeline pattern
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动管道模式
- en: 'Finally, we can implement the `LaunchPipeline` function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以实现`LaunchPipeline`函数：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The function `generator` first returns the channel that is passed to the power
    function. The `power` function returns the second channel that is passed to the `sum`
    function. The function `sum` finally returns the first channel that will receive
    a unique value, the result. Let''s try to test this now:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`generator`首先返回传递给`power`函数的通道。`power`函数返回传递给`sum`函数的第二个通道。`sum`函数最终返回将接收唯一值，即结果的第一个通道。现在让我们尝试测试一下：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Awesome! It''s worth mentioning that the `LaunchPipeline` function doesn''t
    need to allocate every channel, and can be rewritten like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！值得一提的是，`LaunchPipeline`函数不需要为每个通道分配，可以重写如下：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The result of the `generator` function is passed directly to the `power` function
    and the result of `power` to `sum` functions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`generator`函数的结果直接传递到`power`函数，`power`函数的结果传递到`sum`函数。'
