<html><head></head><body><div class="book" title="Summary" id="4D4J81-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec065" class="calibre1"/>Summary</h1></div></div></div><p class="calibre10">Concurrency design patterns are a step forward in difficulty, and take some time to grasp. Our biggest mistake as concurrent programmers is thinking in terms of parallelism (How can I make this parallel? or How can I run this in a new thread?) instead of in terms of concurrent structures.</p><p class="calibre10">Pure functions (functions that will always produce the same output (given the same input) without affecting anything outside their scope) help in this design.</p><p class="calibre10">Concurrent programming requires practice and more practice. Go makes it easy once you understand the basic primitives. Diagrams can help you to understand the possible flow of data, but the best way of understanding it all is simply to practice.</p><p class="calibre10">In the following chapter, we will see how to use a pool of pipeline workers to do some work instead of having a unique pipeline. Also, we will learn how to create the publish/subscriber pattern in a concurrent structure and see how different the same pattern can be when we build by using concurrency.</p></div></body></html>