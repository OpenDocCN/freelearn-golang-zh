- en: Chapter 10. Concurrency Patterns - Workers Pool and Publish/Subscriber Design
    Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章。并发模式 - 工作者池和发布/订阅设计模式
- en: We have reached the final chapter of the book, where we will discuss a couple
    of patterns with concurrent structures. We will explain every step in detail so
    you can follow the examples carefully.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了本书的最后一章，我们将讨论一些具有并发结构的模式。我们将详细解释每一步，以便您可以仔细地跟随示例。
- en: The idea is to learn about patterns to design concurrent applications in idiomatic
    Go. We are using channels and Goroutines heavily, instead of locks or sharing
    variables.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是了解如何在惯用的 Go 语言中设计并发应用程序的模式。我们大量使用通道和 Goroutines，而不是锁或共享变量。
- en: We will look at one way to develop a pool of workers. This is useful to control
    the number of Goroutines in an execution.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将探讨一种开发工作者池的方法。这在控制执行中的 Goroutines 数量时非常有用。
- en: The second example is a rewrite of the Observer pattern, which we saw on [Chapter
    7](part0134_split_000.html#3VPBC2-9c484ed022e64a0fb0e1aebf8e05d4fd "Chapter 7. Behavioral
    Patterns - Visitor, State, Mediator, and Observer Design Patterns"), *Behavioral
    Patterns - Visitor, State, Mediator, and Observer Design Patterns*, written with
    a concurrent structure. With this example we'll dig a bit more into the concurrent
    structures and look at how they can differ from a common approach.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个示例是对观察者模式的重写，我们在[第 7 章](part0134_split_000.html#3VPBC2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第 7 章。行为模式 - 访问者、状态、调解器和观察者设计模式")中看到了它，*行为模式 - 访问者、状态、调解器和观察者设计模式*，这次是用并发结构编写的。通过这个示例，我们将更深入地挖掘并发结构，并看看它们如何与常见方法有所不同。
