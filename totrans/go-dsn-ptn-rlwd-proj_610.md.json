["```go\n   // workers_pipeline.go file \n    type Request struct { \n          Data    interface{} \n          Handler RequestHandler \n    } \n\n```", "```go\ntype RequestHandler func(interface{}) \n\n```", "```go\nfunc NewStringRequest(s string, id int, wg *sync.WaitGroup) Request { \n    return := Request{ \n        Data: \"Hello\", Handler: func(i interface{})\n        { \n            defer wg.Done() \n            s, ok := i.(string) \n                if !ok{ \n                    log.Fatal(\"Invalid casting to string\") \n                 } \n             fmt.Println(s) \n         } \n    } \n} \n\n```", "```go\n   // worker.go file \n    type WorkerLauncher interface { \n        LaunchWorker(in chan Request) \n    } \n\n```", "```go\n   // dispatcher.go file \n    type Dispatcher interface { \n        LaunchWorker(w WorkerLauncher) \n        MakeRequest(Request) \n        Stop() \n    } \n\n```", "```go\n    type dispatcher struct { \n        inCh chan Request \n    } \n\n```", "```go\n    func (d *dispatcher) LaunchWorker(id int, w WorkerLauncher) { \n        w.LaunchWorker(d.inCh) \n    } \n\n    func (d *dispatcher) Stop(){ \n        close(d.inCh) \n    } \n\n    func (d *dispatcher) MakeRequest(r Request) { \n        d.inCh <- r \n    } \n\n```", "```go\n    func (d *dispatcher) MakeRequest(r Request) { \n        select { \n        case d.inCh <- r: \n        case <-time.After(time.Second * 5): \n            return \n        } \n    } \n\n```", "```go\n    func NewDispatcher(b int) Dispatcher { \n        return &dispatcher{ \n            inCh:make(chan Request, b), \n        } \n    } \n\n```", "```go\n   // worker.go file \n    type PreffixSuffixWorker struct { \n        id int \n        prefixS string \n        suffixS string \n    } \n\n    func (w *PreffixSuffixWorker) LaunchWorker(i int, in chan Request) {} \n\n```", "```go\n    func (w *PreffixSuffixWorker) uppercase(in <-chan Request) <-chan Request { \n        out := make(chan Request) \n\n        go func() { \n            for msg := range in { \n                s, ok := msg.Data.(string) \n\n                if !ok { \n                    msg.handler(nil) \n                    continue \n                } \n\n                msg.Data = strings.ToUpper(s) \n\n                out <- msg \n            } \n\n            close(out) \n        }() \n\n        return out \n    } \n\n```", "```go\nfunc (w *PreffixSuffixWorker) append(in <-chan Request) <-chan Request { \n    out := make(chan Request) \n    go func() { \n        for msg := range in { \n        uppercaseString, ok := msg.Data.(string) \n\n        if !ok { \n            msg.handler(nil) \n            continue \n            } \n        msg.Data = fmt.Sprintf(\"%s%s\", uppercaseString, w.suffixS) \n        out <- msg \n        } \n        close(out) \n    }() \n    return out \n} \n\n```", "```go\n    func (w *PreffixSuffixWorker) prefix(in <-chan Request) { \n        go func() { \n            for msg := range in { \n                uppercasedStringWithSuffix, ok := msg.Data.(string) \n\n                if !ok { \n                    msg.handler(nil) \n                    continue \n                } \n\n                msg.handler(fmt.Sprintf(\"%s%s\", w.prefixS, uppercasedStringWithSuffix)) \n            } \n        }() \n    } \n\n```", "```go\n    func (w *PreffixSuffixWorker) LaunchWorker(in chan Request) { \n        w.prefix(w.append(w.uppercase(in))) \n    } \n\n```"]