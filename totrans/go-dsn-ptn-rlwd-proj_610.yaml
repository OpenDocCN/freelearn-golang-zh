- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'The very beginning is a request type. According to the description, it must
    hold the string that will enter the pipeline as well as the handler function:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最开始是一个请求类型。根据描述，它必须包含将进入管道的字符串以及处理器函数：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Where is the `return`? We have a `Data` field of type `interface{}` so we can
    use it to pass a string. By using an interface, we can reuse this type for a `string`,
    an `int`, or a `struct` data type. The receiver is the one who must know how to
    deal with the incoming interface.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`在哪里？我们有一个类型为`interface{}`的`Data`字段，我们可以用它来传递一个字符串。通过使用接口，我们可以重用这种类型来传递`string`、`int`或`struct`数据类型。接收者必须知道如何处理传入的接口。'
- en: 'The `Handler` field has the type `Request` handler, which we haven''t defined
    yet:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handler`字段具有`Request`处理器的类型，这是我们还没有定义的：'
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A request handler is any function that accepts an interface as its first argument,
    and returns nothing. Again, we see the `interface{}`, where we would usually see
    a string. This is one of the receivers we mentioned previously, which we'll need
    to cast the incoming result.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 请求处理器是任何接受接口作为其第一个参数且不返回任何内容的函数。再次，我们看到`interface{}`，通常我们会看到字符串。这是我们之前提到的一个接收者，我们需要将其转换为传入的结果。
- en: 'So, when sending a request, we must fill it with some value in the `Data` field
    and implement a handler; for example:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在发送请求时，我们必须在`Data`字段中填充一些值并实现一个处理器；例如：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The handler is defined by using a closure. We again check the type if the interface
    (and we defer the call to the `Done()` method at the end). In case of an improper
    interface, we simply print its contents and return. If the casting is OK, we also
    print them, but here is where we will usually do something with the result of
    the operation; we have to use type casting to retrieve the contents of the `interface{}`
    (which is a string). This must be done in every step in the pipeline, although
    it will introduce a bit of overhead.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器是通过闭包定义的。我们再次检查接口的类型（并在最后延迟调用`Done()`方法）。如果接口不正确，我们简单地打印其内容并返回。如果类型转换是正确的，我们也会打印它们，但在这里我们通常会处理操作的结果；我们必须使用类型转换来检索`interface{}`（它是一个字符串）的内容。这必须在管道的每个步骤中完成，尽管这会引入一点开销。
- en: 'Now we need a type that can handle `Request` types. Possible implementations
    are virtually infinite, so it is better to define an interface first:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个可以处理`Request`类型的类型。可能的实现几乎是无限的，因此最好首先定义一个接口：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `WorkerLauncher` interface must implement only the `LaunchWorker(chan Request)`
    method. Any type that implements this interface will have to receive a channel
    of `Request` type to satisfy it. This channel of the `Request` type is the single
    entrance point to the pipeline.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkerLauncher`接口必须仅实现`LaunchWorker(chan Request)`方法。任何实现此接口的类型都必须接收一个`Request`类型的通道以满足它。这个`Request`类型的通道是管道的单一入口点。'
- en: The dispatcher
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调度器
- en: 'Now, to launch workers in parallel and handle all the possible incoming channels,
    we''ll need something like a dispatcher:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了并行启动工作线程并处理所有可能的输入通道，我们需要一个类似于调度器的工具：
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A `Dispatcher` interface can launch an injected `WorkerLaunchers` type in its
    own `LaunchWorker` method. The `Dispatcher` interface must use the `LaunchWorker`
    method of any of the `WorkerLauncher` types to initialize a pipeline. This way
    we can reuse the `Dispatcher` interface to launch many types of `WorkerLaunchers`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispatcher`接口可以在其`LaunchWorker`方法中启动注入的`WorkerLaunchers`类型。`Dispatcher`接口必须使用任何`WorkerLauncher`类型的`LaunchWorker`方法来初始化管道。这样我们就可以重用`Dispatcher`接口来启动许多类型的`WorkerLaunchers`。'
- en: When using `MakeRequest(Request)`, the `Dispatcher` interface exposes a nice
    method to inject a new `Request` into the workers pool.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`MakeRequest(Request)`时，`Dispatcher`接口提供了一个很好的方法将新的`Request`注入到工作线程池中。
- en: Finally, the user must call stop when all Goroutines must be finished. We must
    handle graceful shutdown in our apps, and we want to avoid Goroutine leaks.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当所有Goroutines都必须完成时，用户必须调用停止。我们必须在我们的应用程序中处理优雅的关闭，并希望避免Goroutine泄漏。
- en: 'We have enough interfaces, so let''s start with the dispatcher which is a bit
    less complicated:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有足够的接口，所以让我们从稍微简单一点的调度器开始：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our `dispatcher` structure stores a channel of `Request` type in one of its
    fields. This is going to be the single point of entrance for requests in any pipeline.
    We said that it must implement three methods, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`dispatcher`结构在其字段中存储一个`Request`类型的通道。这将是任何管道中请求的单一入口点。我们说它必须实现三种方法，如下所示：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, the `Dispatcher` interface doesn't need to do anything special
    to itself before launching a worker, so the `LaunchWorker` method on the `Dispatcher`
    simply executes the `LaunchWorker` method of the incoming `WorkerLauncher,`which
    also has a `LaunchWorker` method to initiate itself. We have previously defined
    that a `WorkerLauncher` type needs at least an ID and a channel for incoming requests,
    so that's what we are passing through.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Dispatcher`接口在启动worker之前不需要对自己做任何特殊的事情，所以`Dispatcher`上的`LaunchWorker`方法简单地执行传入的`WorkerLauncher`的`LaunchWorker`方法，它也有一个`LaunchWorker`方法来启动自己。我们之前定义了`WorkerLauncher`类型至少需要一个ID和一个传入请求的通道，所以这就是我们传递的内容。
- en: It may seem unnecessary to implement the `LaunchWorker` method in the `Dispatcher`
    interface. In different scenarios, it could be interesting to save running worker
    IDs in the dispatcher to control which ones are up or down; the idea is to hide
    launching implementation details. In this case, the `Dispatcher` interface is
    merely acting as a Facade design pattern hiding some implementation details from
    the user.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的`LaunchWorker`方法在`Dispatcher`接口中可能看起来没有必要。在不同的场景中，将正在运行的worker ID保存在分发器中，以控制哪些是开启或关闭的，这个想法是隐藏启动实现细节。在这种情况下，`Dispatcher`接口仅仅作为外观设计模式，隐藏了一些实现细节给用户。
- en: The second method is `Stop`. It closes the incoming requests channel, provoking
    a chain reaction. We saw in the pipeline example that, when closing the incoming
    channel, each for-range loop within the Goroutines breaks and the Goroutine is
    also finished. In this case, when closing a shared channel, it will provoke the
    same reaction, but in every listening Goroutine, so all pipelines will be stopped.
    Cool, huh?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方法是`Stop`。它关闭传入请求的通道，引发连锁反应。我们在管道示例中看到，当关闭传入通道时，Goroutine内的每个for-range循环都会中断，Goroutine也会结束。在这种情况下，当关闭共享通道时，它将在每个监听Goroutine中引发相同的反应，因此所有管道都将停止。酷，不是吗？
- en: 'Request implementation is very simple; we just pass the request in the argument
    to the channel of incoming requests. The Goroutine will block there forever until
    the opposite end of the channel retrieves the request. Forever? That seems like
    a lot if something happens. We can introduce a timeout, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 请求实现非常简单；我们只需将请求作为参数传递给传入请求的通道。Goroutine将永远在那里阻塞，直到通道的另一端检索到请求。永远？如果发生什么情况，这似乎太多了。我们可以引入一个超时，如下所示：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you remember from previous chapters, we can use select to control which
    operation is performed over a channel. Like a `switch` case, just one operation
    can be executed. In this case, we have two different operations: sending and receiving.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得前面的章节，我们可以使用`select`来控制对通道执行哪个操作。就像`switch`语句一样，只能执行一个操作。在这种情况下，我们有两种不同的操作：发送和接收。
- en: The first case is a sending operation--try to send this, and it will block there
    until someone takes the value in the opposite side of the channel. Not a huge
    improvement, then. The second case is a receiving operation; it will be triggered
    after 5 seconds if the upper request can't be sent successfully, and the function
    will return. It would be very convenient to return an error here, but to make
    things simple, we will leave it empty
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个案例是发送操作--尝试发送这个，它将在这里阻塞，直到有人从通道的另一端取走值。那么，改进并不大。第二个案例是接收操作；如果上级请求无法成功发送，它将在5秒后触发，并且函数将返回。在这里返回一个错误会很方便，但为了简单起见，我们将它留空。
- en: 'Finally, in the dispatcher, for convenience, we will define a `Dispatcher`
    creator:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了方便起见，在分发器中我们将定义一个`Dispatcher`创建器：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By using this function instead of creating the dispatcher manually, we can simply
    avoid small mistakes, such as forgetting to initialize the channel field. As you
    can see, the `b` argument refers to the buffer size in the channel.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个函数而不是手动创建分发器，我们可以简单地避免一些小错误，比如忘记初始化通道字段。正如您所看到的，`b`参数指的是通道中的缓冲区大小。
- en: The pipeline
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管道
- en: 'So, our dispatcher is done and we need to develop the pipeline described in
    the acceptance criteria. First, we need a type to implement the `WorkerLauncher`
    type:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的分发器已经完成，我们需要开发验收标准中描述的管道。首先，我们需要一个类型来实现`WorkerLauncher`类型：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `PreffixSuffixWorker` variable stores an ID, a string to prefix, and another
    string to suffix the incoming data of the `Request` type. So, the values to prefix
    and append will be static in these fields, and we will take them from there.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreffixSuffixWorker`变量存储一个ID，一个用于前缀的字符串，以及一个用于后缀传入`Request`类型数据的字符串。因此，要前缀和附加的值将在这两个字段中是静态的，我们将从那里获取它们。'
- en: 'We will implement the `LaunchWorker` method later and begin with each step
    in the pipeline. According to *first acceptance criteria*, the incoming string
    must be uppercase. So, the uppercase method will be the first step in our pipeline:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后实现`LaunchWorker`方法，并从管道中的每个步骤开始。根据*第一个验收标准*，传入的字符串必须是大写。因此，大写方法将是我们的管道中的第一步：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Good. As in the previous chapter, a step in the pipeline accepts a channel of
    incoming data and returns a channel of the same type. It has a very similar approach
    to the examples we developed in the previous chapter. This time, though, we aren't
    using package functions, and uppercase is part of the `PreffixSuffixWorker` type
    and the incoming data is a `struct` instead of an `int`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。正如前一章中提到的，管道中的一个步骤接受一个传入数据的通道，并返回一个相同类型的通道。它与我们前一章中开发的示例有非常相似的方法。不过，这次我们不是使用包函数，大写是`PreffixSuffixWorker`类型的一部分，而传入的数据是一个`struct`而不是`int`。
- en: The `msg` variable is a `Request` type and it will have a handler function and
    data in the form of an interface. The `Data` field should be a string, so we type
    cast it before using it. When type casting a value, we will receive the same value
    with the requested type and a `true` or `false` flag (represented by the `ok`
    variable). If the `ok` variable is `false`, the cast could not be done and we
    won't throw the value down the pipeline. We stop this `Request` here by sending
    a `nil` to the handler (which will also provoke a type-casting error).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`msg`变量是`Request`类型，它将有一个处理函数和以interface形式的数据。`Data`字段应该是一个字符串，所以我们使用类型转换在用它之前。在类型转换一个值时，我们将收到请求的类型相同的值和一个`true`或`false`标志（由`ok`变量表示）。如果`ok`变量是`false`，则无法进行转换，我们不会将值扔到管道中。我们通过向处理程序发送`nil`来停止这个`Request`（这也会引发类型转换错误）。'
- en: Once we have a nice string in the `s` variable, we can uppercase it and store
    it again in the `Data` field to send down the pipeline to the next step. Be aware
    that the value will be sent as an interface again, so the next step will need
    to cast it again. This is the downside of using this approach.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在`s`变量中有一个漂亮的字符串，我们就可以将其转换为大写并再次存储在`Data`字段中，以便将其发送到管道的下一个步骤。请注意，值将再次作为interface发送，因此下一个步骤将需要再次进行类型转换。这是使用这种方法的一个缺点。
- en: 'With the first step done, let''s continue with the second. According to the
    *second acceptance criteria* now, a predefined text must be appended. This text
    is the one stored in the `suffixS` field:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步完成后，让我们继续进行第二步。根据现在的*第二个验收标准*，必须附加一个预定义的文本。这个文本是存储在`suffixS`字段中的：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `append` function has the same structure as the `uppercase` function. It
    receives and returns a channel of incoming requests, and launches a new Goroutine
    that iterates over the incoming channel until it is closed. We need to type cast
    the incoming value, as mentioned previously.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`函数与`uppercase`函数具有相同的结构。它接收并返回一个传入请求的通道，并启动一个新的Goroutine，该Goroutine遍历传入的通道，直到其关闭。我们需要进行类型转换，正如之前提到的。'
- en: In this step in the pipeline the incoming string is uppercase (after doing a
    type assertion). To append any text to it, we just need to use the `fmt.Sprintf()`
    function, as we have done many times before, which formats a new string with the
    provided data. In this case, we pass the value of the `suffixS` field as the second
    value, to append it to the end of the string.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道的这个步骤中，传入的字符串已经是大写的（在类型断言之后）。要向其添加任何文本，我们只需使用`fmt.Sprintf()`函数，就像我们之前多次做的那样，它使用提供的数据格式化一个新的字符串。在这种情况下，我们将`suffixS`字段的值作为第二个值传递，以将其附加到字符串的末尾。
- en: 'Just the last step in the pipeline is missing, the prefix operation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 管道中最后一步缺失，即前缀操作：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What's calling your attention in this function? Yes, it doesn't return any channel
    now. We could have done this entire pipeline in two ways. I suppose you have realized
    that we have used a `Future` handler function to execute with the final result
    in the pipeline. A second approach would be to pass a channel to return the data
    back to its origin. In some cases, a Future would be enough, while in others it
    could be more convenient to pass a channel so that it can be connected to a different
    pipeline (for example).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数中什么引起了你的注意？是的，它现在不返回任何通道。我们可以用两种方式完成整个流水线。我想你可能已经意识到，我们在流水线中使用了`Future`处理器函数来执行最终结果。第二种方法是将通道传递回其原始位置。在某些情况下，`Future`可能足够，而在其他情况下，传递通道可能更方便，以便它可以连接到不同的管道（例如）。
- en: In any case, the structure of a step in a pipeline must be very familiar to
    you already. We cast the value, check the result of the casting, and send nil
    to the handler if anything went wrong. But, in case everything was OK, the last
    thing to do is to format the text again to place the `prefixS` field at the beginning
    of the text, to send the resulting string back to the origin by calling the request's
    handler.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，流水线中步骤的结构对你来说应该已经很熟悉了。我们赋予值，检查赋值的結果，如果发生错误，则将nil发送到处理器。但是，如果一切正常，最后要做的就是再次格式化文本，将`prefixS`字段放置在文本的开头，通过调用请求的处理器将结果字符串发送回原始位置。
- en: 'Now, with our worker almost finished, we can implement the `LaunchWorker` method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着我们的工作几乎完成，我们可以实现`LaunchWorker`方法：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That's all for workers! We simply pass the returning channels to the next steps
    in the Pipeline, as we did in the previous chapter. Remember that the pipeline
    is executed from inside to outside of the calls. So, what's the order of execution
    of any incoming data to the pipeline?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工人来说，这就结束了！我们只需将返回的通道传递到流水线的下一步，就像我们在上一章中所做的那样。记住，流水线是从调用内部到外部执行的。那么，任何传入流水线的数据执行的顺序是什么？
- en: The data enters the pipeline through the Goroutine launched in the `uppercase`
    method.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据通过在`uppercase`方法中启动的Goroutine进入流水线。
- en: Then, it goes to the Goroutine launched in `append`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它进入在`append`方法中启动的Goroutine。
- en: Finally, in enters the Goroutine launched in `prefix` method, which doesn't
    return anything but executes the handler after prefixing the incoming string with
    more data.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它进入在`prefix`方法中启动的Goroutine，这个Goroutine不返回任何内容，但在给传入的字符串添加更多数据后执行处理器。
- en: Now we have a full pipeline and a dispatcher of pipelines. The dispatcher will
    launch as many instances of the pipelines as we want to route the incoming requests
    to any available worker.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完整的流水线和管道调度器。调度器将启动尽可能多的管道实例，以便将传入的请求路由到任何可用的工人。
- en: If none of the workers takes the request within 5 seconds, the request is lost.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在5秒内没有任何工人接受请求，请求就会丢失。
- en: Let's use this library in a small app.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在一个小型应用程序中使用这个库。
