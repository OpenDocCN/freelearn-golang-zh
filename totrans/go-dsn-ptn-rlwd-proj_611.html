<html><head></head><body>
<div class="book" title="Chapter&#xA0;10.&#xA0;Concurrency Patterns - Workers Pool and Publish/Subscriber Design Patterns">
<div class="book" title="Workers pool">
<div class="book" title="An app using the workers pool"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch10lvl2sec0237" class="calibre1"/>An app using the workers pool</h2></div></div></div><p class="calibre10">We will launch three workers of our defined pipeline. We use the <code class="email">NewDispatcher</code> function to create the dispatcher and the channel that will receive all requests. This channel has a fixed buffer, which will be able to store up to 100 incoming messages before blocking:</p><pre class="programlisting">   // workers_pipeline.go 
    func main() { 
        bufferSize := 100 
        var dispatcher Dispatcher = NewDispatcher(bufferSize) 
</pre><p class="calibre10">Then, we will launch the workers by calling the <code class="email">LaunchWorker</code> method in the <code class="email">Dispatcher</code> interface three times with an already filled <code class="email">WorkerLauncher</code> type:</p><pre class="programlisting">    workers := 3 
    for i := 0; i &lt; workers; i++ { 
        var w WorkerLauncher = &amp;PreffixSuffixWorker{ 
            prefixS: fmt.Sprintf("WorkerID: %d -&gt; ", i), 
            suffixS: " World", 
            id:i, 
        } 
        dispatcher.LaunchWorker(w) 
    } 
</pre><p class="calibre10">Each <code class="email">WorkerLauncher</code> type is an instance of <code class="email">PreffixSuffixWorker</code>. The prefix will be a small text showing the worker ID and the suffix text <code class="email">world</code>.</p><p class="calibre10">At this point, we have three workers with three Goroutines, each running concurrently and waiting for messages to arrive:</p><pre class="programlisting">    requests := 10 
 
    var wg sync.WaitGroup 
    wg.Add(requests) 
</pre><p class="calibre10">We will make 10 requests. We also need a WaitGroup to properly synchronize the app so that it doesn't exit too early. You can find yourself using WaitGroups quite a lot when dealing with concurrent applications. For 10 requests, we'll need to wait for 10 calls to the <code class="email">Done()</code> method, so we call the <code class="email">Add()</code> method with a <span class="strong"><em class="calibre11">delta</em></span> of 10. It's called delta because you can also pass a -5 later to leave it in five requests. In some situations, it can be useful:</p><pre class="programlisting">    for i := 0; i &lt; requests; i++ { 
        req := NewStringRequest("(Msg_id: %d) -&gt; Hello", i, &amp;wg) 
        dispatcher.MakeRequest(req) 
    } 
 
    dispatcher.Stop() 
 
    wg.Wait() 
}</pre><p class="calibre10">To make requests, we will iterate a <code class="email">for</code> loop. First, we create a <code class="email">Request</code> using the function <code class="email">NewStringRequest</code> that we wrote at the beginning of the Implementation section. In this value, the <code class="email">Data</code> field will be the text we'll pass down the pipeline, and it will be the text that is "in the middle" of the appending and suffixing operation. In this case, we will send the message number and the word <code class="email">hello</code>.</p><p class="calibre10">Once we have a request, we call the <code class="email">MakeRequest</code> method with it. After all requests have been done, we stop the dispatcher that, as explained previously, will provoke a chain reaction that will stop all Goroutines in the pipeline.</p><p class="calibre10">Finally, we wait for the group so that all calls to the <code class="email">Done()</code> method are received, which signals that all operations have been finished. It's time to try it out:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">    go run *</strong></span>
<span class="strong"><strong class="calibre2">    WorkerID: 1 -&gt; (MSG_ID: 0) -&gt; HELLO World</strong></span>
<span class="strong"><strong class="calibre2">    WorkerID: 0 -&gt; (MSG_ID: 3) -&gt; HELLO World</strong></span>
<span class="strong"><strong class="calibre2">    WorkerID: 0 -&gt; (MSG_ID: 4) -&gt; HELLO World</strong></span>
<span class="strong"><strong class="calibre2">    WorkerID: 0 -&gt; (MSG_ID: 5) -&gt; HELLO World</strong></span>
<span class="strong"><strong class="calibre2">    WorkerID: 2 -&gt; (MSG_ID: 2) -&gt; HELLO World</strong></span>
<span class="strong"><strong class="calibre2">    WorkerID: 1 -&gt; (MSG_ID: 1) -&gt; HELLO World</strong></span>
<span class="strong"><strong class="calibre2">    WorkerID: 0 -&gt; (MSG_ID: 6) -&gt; HELLO World</strong></span>
<span class="strong"><strong class="calibre2">    WorkerID: 2 -&gt; (MSG_ID: 9) -&gt; HELLO World</strong></span>
<span class="strong"><strong class="calibre2">    WorkerID: 0 -&gt; (MSG_ID: 7) -&gt; HELLO World</strong></span>
<span class="strong"><strong class="calibre2">    WorkerID: 0 -&gt; (MSG_ID: 8) -&gt; HELLO World</strong></span>
</pre><p class="calibre10">Let's analyze the first message:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">This would be zero, so the message sent is <code class="email">(Msg_id: 0) -&gt; Hello</code>.</li><li class="listitem" value="2">Then, the text is uppercased, so now we have <code class="email">(MSG_ID: 0) -&gt; HELLO</code>.</li><li class="listitem" value="3">After uppercasing an append operation with the text <code class="email">world</code> (note the space at the beginning of the text) is done. This will give us the text <code class="email">(MSG_ID: 0) -&gt; HELLO World</code>.</li><li class="listitem" value="4">Finally, the text <code class="email">WorkerID: 1</code> (in this case, the first worker took the task, but it could be any of them) is appended to the text from step 3 to give us the full returned message, <code class="email">WorkerID: 1 -&gt; (MSG_ID: 0) -&gt; HELLO World</code>.</li></ol><div class="calibre12"/></div></div></div></div></body></html>