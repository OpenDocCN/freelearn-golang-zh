- en: An app using the workers pool
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工作池的应用程序
- en: 'We will launch three workers of our defined pipeline. We use the `NewDispatcher`
    function to create the dispatcher and the channel that will receive all requests.
    This channel has a fixed buffer, which will be able to store up to 100 incoming
    messages before blocking:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将启动我们定义的管道中的三个工作进程。我们使用`NewDispatcher`函数创建调度器和将接收所有请求的通道。这个通道有一个固定缓冲区，它能够在阻塞之前存储多达100条传入的消息：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, we will launch the workers by calling the `LaunchWorker` method in the
    `Dispatcher` interface three times with an already filled `WorkerLauncher` type:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将通过在`Dispatcher`接口中三次调用`LaunchWorker`方法来启动工作进程，使用已经填充的`WorkerLauncher`类型：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each `WorkerLauncher` type is an instance of `PreffixSuffixWorker`. The prefix
    will be a small text showing the worker ID and the suffix text `world`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`WorkerLauncher`类型都是`PreffixSuffixWorker`的实例。前缀将是一个显示工作进程ID的小文本，后缀文本是`world`。
- en: 'At this point, we have three workers with three Goroutines, each running concurrently
    and waiting for messages to arrive:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们有三个工作进程和三个Goroutines，它们正在并发运行并等待消息到达：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will make 10 requests. We also need a WaitGroup to properly synchronize
    the app so that it doesn''t exit too early. You can find yourself using WaitGroups
    quite a lot when dealing with concurrent applications. For 10 requests, we''ll
    need to wait for 10 calls to the `Done()` method, so we call the `Add()` method
    with a *delta* of 10\. It''s called delta because you can also pass a -5 later
    to leave it in five requests. In some situations, it can be useful:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发出10个请求。我们还需要一个WaitGroup来正确同步应用程序，以便它不会太早退出。当处理并发应用程序时，你可能会发现自己经常使用WaitGroups。对于10个请求，我们需要等待10次对`Done()`方法的调用，因此我们使用带有*增量*为10的`Add()`方法。它被称为增量，因为你也可以稍后传递-5来使其在五个请求中完成。在某些情况下，这可能很有用：
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To make requests, we will iterate a `for` loop. First, we create a `Request`
    using the function `NewStringRequest` that we wrote at the beginning of the Implementation
    section. In this value, the `Data` field will be the text we'll pass down the
    pipeline, and it will be the text that is "in the middle" of the appending and
    suffixing operation. In this case, we will send the message number and the word
    `hello`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发出请求，我们将迭代一个`for`循环。首先，我们使用我们在实现部分开头编写的函数`NewStringRequest`创建一个`Request`。在这个值中，`Data`字段将是我们将通过管道传递的文本，它将是追加和后缀操作中的“中间”文本。在这种情况下，我们将发送消息编号和单词`hello`。
- en: Once we have a request, we call the `MakeRequest` method with it. After all
    requests have been done, we stop the dispatcher that, as explained previously,
    will provoke a chain reaction that will stop all Goroutines in the pipeline.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们收到请求，我们就用它调用`MakeRequest`方法。完成所有请求后，我们停止调度器，正如之前解释的那样，这将引发连锁反应，停止管道中的所有Goroutines。
- en: 'Finally, we wait for the group so that all calls to the `Done()` method are
    received, which signals that all operations have been finished. It''s time to
    try it out:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们等待组完成，以便接收到所有对`Done()`方法的调用，这表示所有操作都已完成。现在是时候尝试一下了：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s analyze the first message:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析第一条消息：
- en: 'This would be zero, so the message sent is `(Msg_id: 0) -> Hello`.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '这将是零，所以发送的消息是`(Msg_id: 0) -> Hello`。'
- en: 'Then, the text is uppercased, so now we have `(MSG_ID: 0) -> HELLO`.'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，文本被转换为大写，所以我们现在有`(MSG_ID: 0) -> HELLO`。'
- en: 'After uppercasing an append operation with the text `world` (note the space
    at the beginning of the text) is done. This will give us the text `(MSG_ID: 0)
    -> HELLO World`.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在将文本`world`（注意文本开头的空格）添加到转换为大写操作完成后。这将给我们文本`(MSG_ID: 0) -> HELLO World`。'
- en: 'Finally, the text `WorkerID: 1` (in this case, the first worker took the task,
    but it could be any of them) is appended to the text from step 3 to give us the
    full returned message, `WorkerID: 1 -> (MSG_ID: 0) -> HELLO World`.'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '最后，文本`WorkerID: 1`（在这种情况下，第一个工作进程接受了任务，但可能是任何一个）被附加到步骤3中的文本上，以给出完整的返回消息，`WorkerID:
    1 -> (MSG_ID: 0) -> HELLO World`。'
