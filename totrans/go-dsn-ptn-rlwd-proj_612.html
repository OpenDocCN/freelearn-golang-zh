<html><head></head><body>
<div class="book" title="Chapter&#xA0;10.&#xA0;Concurrency Patterns - Workers Pool and Publish/Subscriber Design Patterns">
<div class="book" title="Workers pool">
<div class="book" title="No tests?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_8"><a id="ch10lvl2sec0238" class="calibre1"/>No tests?</h2></div></div></div><p class="calibre10">Concurrent applications are difficult to test, especially if you are doing networking operations. It can be difficult, and code can change a lot just to test it. In any case, it is not justifiable to not perform tests. In this case, it is not especially difficult to test our small app. Create a test and copy/paste the contents of the <code class="email">main</code> function there:</p><pre class="programlisting">//workers_pipeline.go file 
package main 
 
import "testing" 
 
func Test_Dispatcher(t *testing.T){ 
    //pasted code from main function 
<span class="strong"><strong class="calibre2">    bufferSize := 100</strong></span>
<span class="strong"><strong class="calibre2">   
    var dispatcher Dispatcher = NewDispatcher(bufferSize)</strong></span>
<span class="strong"><strong class="calibre2">   
    workers := 3</strong></span>
<span class="strong"><strong class="calibre2">   
    for i := 0; i &lt; workers; i++ 
    {</strong></span>
<span class="strong"><strong class="calibre2">        
        var w WorkerLauncher = &amp;PreffixSuffixWorker{</strong></span>
<span class="strong"><strong class="calibre2">               
            prefixS: fmt.Sprintf("WorkerID: %d -&gt; ", i), </strong></span>
<span class="strong"><strong class="calibre2">suffixS: " World", </strong></span>
<span class="strong"><strong class="calibre2">id: i,</strong></span>
<span class="strong"><strong class="calibre2">}</strong></span>
<span class="strong"><strong class="calibre2">        
        dispatcher.LaunchWorker(w)</strong></span>
<span class="strong"><strong class="calibre2">   
    }</strong></span>
<span class="strong"><strong class="calibre2">   
    //Simulate Requests</strong></span>
<span class="strong"><strong class="calibre2">   
    requests := 10</strong></span>
<span class="strong"><strong class="calibre2">   
    var wg 
    sync.WaitGroup</strong></span>
<span class="strong"><strong class="calibre2">   
    wg.Add(requests)</strong></span> 
} 
</pre><p class="calibre10">Now we have to rewrite our handler to test that the returned contents are the ones we are expecting. Go to the <code class="email">for</code> loop to modify the function that we are passing as a handler on each <code class="email">Request</code>:</p><pre class="programlisting">for i := 0; i &lt; requests; i++ { 
    req := Request{ 
        Data: fmt.Sprintf("(Msg_id: %d) -&gt; Hello", i), 
        handler: func(i interface{}) 
        { 
            s, ok := i.(string) 
            defer wg.Done() 
<span class="strong"><strong class="calibre2">            if !ok 
            {</strong></span>
<span class="strong"><strong class="calibre2">                    
                t.Fail()</strong></span>
<span class="strong"><strong class="calibre2">                
            }</strong></span>
<span class="strong"><strong class="calibre2">                
            ok, err := regexp.Match(</strong></span>
<span class="strong"><strong class="calibre2">`WorkerID\: \d* -\&gt; \(MSG_ID: \d*\) -&gt; [A-Z]*\sWorld`,</strong></span>
<span class="strong"><strong class="calibre2"> []byte(s))
</strong></span>
<span class="strong"><strong class="calibre2">        
            if !ok || err != nil {</strong></span>
<span class="strong"><strong class="calibre2">                    
                t.Fail()</strong></span>
<span class="strong"><strong class="calibre2">                
            }</strong></span> 
        }, 
    } 
    dispatcher.MakeRequest(req) 
} 
</pre><p class="calibre10">We are going to use regular expressions to test the business. If you are not familiar with regular expressions, they are a quite powerful feature that help you to match content within a string. If you remember in our exercises when we were using the <code class="email">strings</code> package. <code class="email">Contains</code> is the function to find a text inside a string. We can also do it with regular expressions.</p><p class="calibre10">The problem is that regular expressions are quite expensive and consume a lot of resources.</p><p class="calibre10">We are using the <code class="email">Match</code> function of the <code class="email">regexp</code> package to provide a template to match. Our template is <code class="email">WorkerID\: \d* -&gt; \(MSG_ID: \d\) -&gt; [A-Z]*\sWorld</code> (without quotes). Specifically, it describes the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A string that has the content <code class="email">WorkerID: \d* -&gt; (MSG_ID: \d*", here "\d*</code> indicates any digit written zero or more times, so it will match <code class="email">WorkerID: 10 -&gt; (MSG_ID: 1"</code> and <code class="email">"WorkerID: 1 -&gt; (MSG_ID: 10</code>.</li><li class="listitem"><code class="email">"\) -&gt; [A-Z]*\sWorld"</code> (parentheses must be escaped using backslashes). "<code class="email">*</code>" means any uppercase character written zero or more times, so <code class="email">"\s"</code> is a white space and it must finish with the text <code class="email">World</code>, so <code class="email">) -&gt; HELLO World"</code> will match, but <code class="email">) -&gt; Hello World"</code> won't, because <code class="email">"Hello</code> must be all uppercase.</li></ul></div><p class="calibre10">Running this test gives us the following output:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -v .</strong></span>
<span class="strong"><strong class="calibre2">=== RUN   Test_Dispatcher</strong></span>
<span class="strong"><strong class="calibre2">--- PASS: Test_Dispatcher (0.00s)</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">ok</strong></span>
</pre><p class="calibre10">Not bad, but we aren't testing that code is being executed concurrently, so this is more a business test than a unit test. Concurrency testing would force us to write the code in a completely different manner to check that it is creating the proper amount of Goroutines and the pipeline is following the expected workflow. This is not bad, but it's quite complex, and outside of the context of this book.</p></div></div></div></body></html>