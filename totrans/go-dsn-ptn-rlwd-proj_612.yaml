- en: No tests?
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有测试？
- en: 'Concurrent applications are difficult to test, especially if you are doing
    networking operations. It can be difficult, and code can change a lot just to
    test it. In any case, it is not justifiable to not perform tests. In this case,
    it is not especially difficult to test our small app. Create a test and copy/paste
    the contents of the `main` function there:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 并发应用程序很难测试，尤其是如果你在进行网络操作。这可能很困难，代码可能需要大量更改才能进行测试。无论如何，不进行测试是不合理的。在这种情况下，测试我们的小应用程序并不特别困难。创建一个测试并将`main`函数的内容复制粘贴到那里：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now we have to rewrite our handler to test that the returned contents are the
    ones we are expecting. Go to the `for` loop to modify the function that we are
    passing as a handler on each `Request`:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须重写我们的处理程序来测试返回的内容是否是我们预期的。转到`for`循环，修改我们传递给每个`Request`的处理程序函数：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are going to use regular expressions to test the business. If you are not
    familiar with regular expressions, they are a quite powerful feature that help
    you to match content within a string. If you remember in our exercises when we
    were using the `strings` package. `Contains` is the function to find a text inside
    a string. We can also do it with regular expressions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用正则表达式来测试业务。如果你不熟悉正则表达式，它们是一个非常强大的功能，可以帮助你在字符串中匹配内容。如果你记得在我们使用`strings`包的练习中。`Contains`是用于在字符串中查找文本的函数。我们也可以使用正则表达式来完成这个操作。
- en: The problem is that regular expressions are quite expensive and consume a lot
    of resources.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于正则表达式相当昂贵，并且消耗大量资源。
- en: 'We are using the `Match` function of the `regexp` package to provide a template
    to match. Our template is `WorkerID\: \d* -> \(MSG_ID: \d\) -> [A-Z]*\sWorld`
    (without quotes). Specifically, it describes the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '我们正在使用`regexp`包的`Match`函数提供一个模板进行匹配。我们的模板是`WorkerID\: \d* -> \(MSG_ID: \d\)
    -> [A-Z]*\sWorld`（不带引号）。具体来说，它描述了以下内容：'
- en: 'A string that has the content `WorkerID: \d* -> (MSG_ID: \d*", here "\d*` indicates
    any digit written zero or more times, so it will match `WorkerID: 10 -> (MSG_ID:
    1"` and `"WorkerID: 1 -> (MSG_ID: 10`.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一个包含内容`WorkerID: \d* -> (MSG_ID: \d*`的字符串，这里`"\d*"`表示任何数字可以出现零次或多次，因此它会匹配`WorkerID:
    10 -> (MSG_ID: 1"`和`"WorkerID: 1 -> (MSG_ID: 10"`。'
- en: '`"\) -> [A-Z]*\sWorld"` (parentheses must be escaped using backslashes). "`*`"
    means any uppercase character written zero or more times, so `"\s"` is a white
    space and it must finish with the text `World`, so `) -> HELLO World"` will match,
    but `) -> Hello World"` won''t, because `"Hello` must be all uppercase.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"\) -> [A-Z]*\sWorld"`（括号必须使用反斜杠转义）。`*`表示任何大写字母字符，可以出现零次或多次，因此`"\s"`代表一个空白字符，并且它必须以文本`World`结束，所以`)
    -> HELLO World"`将会匹配，但`) -> Hello World"`不会匹配，因为`"Hello"`必须全部为大写。'
- en: 'Running this test gives us the following output:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个测试会给出以下输出：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Not bad, but we aren't testing that code is being executed concurrently, so
    this is more a business test than a unit test. Concurrency testing would force
    us to write the code in a completely different manner to check that it is creating
    the proper amount of Goroutines and the pipeline is following the expected workflow.
    This is not bad, but it's quite complex, and outside of the context of this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错，但我们并不是在测试代码是否并发执行，所以这更像是一个业务测试而不是单元测试。并发测试会迫使我们以完全不同的方式编写代码，以检查是否创建了正确数量的Goroutines，并且管道是否遵循预期的流程。这并不坏，但相当复杂，而且超出了本书的语境。
