- en: Wrapping up the Worker pool
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结工作池
- en: With the workers pool, we have our first complex concurrent application that
    can be used in real-world production systems. It also has room to improve, but
    it is a very good design pattern to build concurrent bounded apps.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过工作池，我们拥有了第一个可以在实际生产系统中使用的复杂并发应用程序。它还有改进的空间，但这是一个非常好的设计模式来构建并发有界应用程序。
- en: It is key that we always have the number of Goroutines that are being launched
    under control. While it's easy to launch thousands to achieve more parallelism
    in an app, we must be very careful that they don't have code that can hang them
    in an infinite loop, too.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于我们始终要控制正在启动的 Goroutines 的数量。虽然启动数千个以在应用程序中获得更多并行性很容易，但我们必须非常小心，确保它们没有可能导致无限循环挂起的代码。
- en: With the workers pool, we can now fragment a simple operation in many parallel
    tasks. Think about it; this could achieve the same result with one simple call
    to `fmt.Printf`, but we have done a pipeline with it; then, we launched few instances
    of this pipeline and finally, distributed the workload between all those pipes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工作池，我们现在可以将一个简单的操作分解成许多并行任务。想想看；这可以通过对 `fmt.Printf` 的一个简单调用实现相同的结果，但我们已经通过它建立了一个管道；然后，我们启动了这个管道的几个实例，最后，将工作负载分配给了所有这些管道。
