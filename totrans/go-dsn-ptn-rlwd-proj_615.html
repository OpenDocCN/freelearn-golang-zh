<html><head></head><body>
<div class="book" title="Concurrent Publish/Subscriber design pattern">
<div class="book" title="Description"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec0240" class="calibre1"/>Description</h2></div></div></div><p class="calibre10">If you remember from the previous explanation, the Observer pattern maintains a list of observers or subscribers that want to be notified of a particular event. In this case, each subscriber is going to run in a different Goroutine as well as the publisher. We will have new problems with building this structure:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Now, the access to the list of subscribers must be serialized. If we are reading the list with one Goroutine, we cannot be removing a subscriber from it or we will have a race.</li><li class="listitem">When a subscriber is removed, the subscriber's Goroutine must be closed too, or it will keep iterating forever and we will run into Goroutine leaks.</li><li class="listitem">When stopping the publisher, all subscribers must stop their Goroutines, too.</li></ul></div></div></div></body></html>