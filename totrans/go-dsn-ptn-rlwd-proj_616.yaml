- en: Objectives
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标
- en: 'The objectives of this publish/subscriber are the same as the ones we wrote
    on the Observer pattern. The difference here is the way we will develop it. The
    idea is to make a concurrent structure to achieve the same functionality, which
    is as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这个发布/订阅的目标与我们在观察者模式中写下的目标相同。这里的区别在于我们将如何开发它。想法是创建一个并发结构以实现相同的功能，具体如下：
- en: Providing an event-driven architecture where one event can trigger one or more
    actions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个事件驱动的架构，其中单个事件可以触发一个或多个动作
- en: Uncoupling the actions that are performed from the event that triggers them
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将执行的动作与触发它们的动作解耦
- en: Providing more than one source event that triggers the same action
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供多个触发相同动作的源事件
- en: The idea is to uncouple senders from receivers, hiding from the sender the identity
    of the receivers that will process its event, and hiding the receivers from the
    number of senders that can communicate with them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是将发送者与接收者解耦，从发送者那里隐藏将要处理其事件的接收者身份，并从接收者那里隐藏可以与之通信的发送者数量。
- en: In particular, if I develop a click in a button in some application, it could
    do something (such as log us in somewhere). Weeks later, we might decide to make
    it show a popup, too. If, every time we want to add some functionality to this
    button, we have to change the code where it handles the click action, that function
    will become huge and not very portable to other projects. If we use a publisher
    and one observer for every action, the click function only needs to publish one
    single event using a publisher, and we will just write subscribers to this event
    every time we want to improve the functionality. This is especially important
    in applications with user interfaces where many things to do in a single UI action
    can slow the responsiveness of an interface, completely destroying the user experience.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，如果我在某个应用程序中的按钮上开发一个点击事件，它可能执行某些操作（例如登录到某个地方）。几周后，我们可能会决定让它显示一个弹出窗口。如果我们每次想要向这个按钮添加一些功能时，都必须更改处理点击动作的代码，那么这个函数将变得很大，并且不太容易移植到其他项目中。如果我们为每个动作使用一个发布者和一个观察者，点击函数只需要使用发布者发布一个单一的事件，每次我们想要改进功能时，我们只需为这个事件编写订阅者。这在具有用户界面的应用程序中尤为重要，因为单个UI动作中要执行的多项任务可能会降低界面的响应速度，完全破坏用户体验。
- en: By using a concurrent structure to develop the Observer pattern, a UI cannot
    feel all the tasks that are being executed in the background if a concurrent structure
    is defined and the device allows us to execute parallel tasks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用并发结构来开发观察者模式，如果定义了并发结构并且设备允许我们执行并行任务，UI就无法感觉到正在后台执行的所有任务。
