<html><head></head><body>
<div class="book" title="Concurrent Publish/Subscriber design pattern">
<div class="book" title="Example - a concurrent notifier"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec0242" class="calibre1"/>Example - a concurrent notifier</h2></div></div></div><p class="calibre10">We will develop a <span class="strong"><em class="calibre11">notifier</em></span> similar to the one we developed in <a class="calibre1" title="Chapter 7. Behavioral Patterns - Visitor, State, Mediator, and Observer Design Patterns" href="part0134_split_000.html#3VPBC2-9c484ed022e64a0fb0e1aebf8e05d4fd">
Chapter 7</a>, <span class="strong"><em class="calibre11">Behavioral Patterns - Visitor, State, Mediator, and Observer Design Patterns</em></span>. This is to focus on the concurrent nature of the structure instead of detailing too many things that have already been explained. We have developed an observer already, so we are familiar with the concept.</p><p class="calibre10">This particular notifier will work by passing around <code class="email">interface{}</code> values, like in the workers pool example. This way, we can use it for more than a single type by introducing some overhead when casting on the receiver.</p><p class="calibre10">We will work with two interfaces now. First, a <code class="email">Subscriber</code> interface:</p><pre class="programlisting">    type Subscriber interface { 
        Notify(interface{}) error 
        Close() 
    } 
</pre><p class="calibre10">Like in the previous example, it must have a <code class="email">Notify</code> method in the <code class="email">Subscriber</code> interface of new events. This is the <code class="email">Notify</code> method that accepts an <code class="email">interface{}</code> value and returns an error. The <code class="email">Close()</code> method, however, is new, and it must trigger whatever actions are needed to stop the Goroutine where the subscriber is listening for new events.</p><p class="calibre10">The second and final interface is the <code class="email">Publisher</code> interface:</p><pre class="programlisting">    type Publisher interface { 
        start() 
        AddSubscriberCh() chan&lt;- Subscriber 
        RemoveSubscriberCh() chan&lt;- Subscriber 
        PublishingCh() chan&lt;- interface{} 
        Stop() 
    } 
</pre><p class="calibre10">The <code class="email">Publisher</code> interface has the same actions we already know for a publisher but to work with channels. The <code class="email">AddSubscriberCh</code> and <code class="email">RemoveSubscriberCh</code> methods accepts a <code class="email">Subscriber</code> interface (any type that satisfies the <code class="email">Subscriber</code> interface). It must have a method to publish messages and a <code class="email">Stop</code> method to stop them all (publisher and subscriber Goroutines)</p></div></div></body></html>