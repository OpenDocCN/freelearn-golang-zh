- en: Example - a concurrent notifier
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 一个并发通知器
- en: We will develop a *notifier* similar to the one we developed in  [Chapter 7](part0134_split_000.html#3VPBC2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 7. Behavioral Patterns - Visitor, State, Mediator, and Observer Design
    Patterns"), *Behavioral Patterns - Visitor, State, Mediator, and Observer Design
    Patterns*. This is to focus on the concurrent nature of the structure instead
    of detailing too many things that have already been explained. We have developed
    an observer already, so we are familiar with the concept.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开发一个类似于我们在第7章中开发的**通知器**，即[第7章](part0134_split_000.html#3VPBC2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "第7章。行为模式 - 访问者、状态、中介者和观察者设计模式")中开发的，**行为模式 - 访问者、状态、中介者和观察者设计模式**。这是为了专注于结构的并发性，而不是详细说明已经解释过的太多内容。我们已经开发了一个观察者，因此我们对这个概念很熟悉。
- en: This particular notifier will work by passing around `interface{}` values, like
    in the workers pool example. This way, we can use it for more than a single type
    by introducing some overhead when casting on the receiver.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的通知器将通过传递`interface{}`值来工作，就像在工作者池示例中一样。这样，我们可以通过在接收器上进行类型转换时引入一些开销，使其适用于不止一种类型。
- en: 'We will work with two interfaces now. First, a `Subscriber` interface:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用两个接口。首先是一个`Subscriber`接口：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Like in the previous example, it must have a `Notify` method in the `Subscriber`
    interface of new events. This is the `Notify` method that accepts an `interface{}`
    value and returns an error. The `Close()` method, however, is new, and it must
    trigger whatever actions are needed to stop the Goroutine where the subscriber
    is listening for new events.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在先前的示例中一样，它必须在`Subscriber`接口中有一个`Notify`方法来通知新事件。这是接受一个`interface{}`值并返回错误的`Notify`方法。然而，`Close()`方法却是新的，并且它必须触发在订阅者监听新事件的地方停止Goroutine所需的任何操作。
- en: 'The second and final interface is the `Publisher` interface:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个也是最后一个接口是`Publisher`接口：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Publisher` interface has the same actions we already know for a publisher
    but to work with channels. The `AddSubscriberCh` and `RemoveSubscriberCh` methods
    accepts a `Subscriber` interface (any type that satisfies the `Subscriber` interface).
    It must have a method to publish messages and a `Stop` method to stop them all
    (publisher and subscriber Goroutines)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`Publisher`接口具有我们已知的用于发布者的相同操作，但用于处理通道。`AddSubscriberCh`和`RemoveSubscriberCh`方法接受一个`Subscriber`接口（任何满足`Subscriber`接口的类型）。它必须有一个发布消息的方法和一个`Stop`方法来停止所有操作（发布者和订阅者Goroutines）'
