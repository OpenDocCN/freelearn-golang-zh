- en: Example - a concurrent notifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will develop a *notifier* similar to the one we developed in  [Chapter 7](part0134_split_000.html#3VPBC2-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Chapter 7. Behavioral Patterns - Visitor, State, Mediator, and Observer Design
    Patterns"), *Behavioral Patterns - Visitor, State, Mediator, and Observer Design
    Patterns*. This is to focus on the concurrent nature of the structure instead
    of detailing too many things that have already been explained. We have developed
    an observer already, so we are familiar with the concept.
  prefs: []
  type: TYPE_NORMAL
- en: This particular notifier will work by passing around `interface{}` values, like
    in the workers pool example. This way, we can use it for more than a single type
    by introducing some overhead when casting on the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will work with two interfaces now. First, a `Subscriber` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Like in the previous example, it must have a `Notify` method in the `Subscriber`
    interface of new events. This is the `Notify` method that accepts an `interface{}`
    value and returns an error. The `Close()` method, however, is new, and it must
    trigger whatever actions are needed to stop the Goroutine where the subscriber
    is listening for new events.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second and final interface is the `Publisher` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Publisher` interface has the same actions we already know for a publisher
    but to work with channels. The `AddSubscriberCh` and `RemoveSubscriberCh` methods
    accepts a `Subscriber` interface (any type that satisfies the `Subscriber` interface).
    It must have a method to publish messages and a `Stop` method to stop them all
    (publisher and subscriber Goroutines)
  prefs: []
  type: TYPE_NORMAL
