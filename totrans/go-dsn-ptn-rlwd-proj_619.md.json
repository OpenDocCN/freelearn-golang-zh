["```go\n    // writer_sub.go file \n    package main \n\n    import \"errors\" \n\n    type writerSubscriber struct { \n        id int \n        Writer io.Writer \n    } \n\n    func (s *writerSubscriber) Notify(msg interface{}) error { \n        return erorrs.NeW(\"Not implemented yet\") \n    } \n    func (s *writerSubscriber) Close() {} \n\n```", "```go\n    package main \n    func TestStdoutPrinter(t *testing.T) { \n\n```", "```go\n    func TestWriter(t *testing.T) { \n        sub := NewWriterSubscriber(0, nil) \n\n```", "```go\n    func NewWriterSubscriber(id int, out io.Writer) Subscriber { \n        return &writerSubscriber{} \n    } \n\n```", "```go\n    type mockWriter struct { \n        testingFunc func(string) \n    } \n\n    func (m *mockWriter) Write(p []byte) (n int, err error) { \n        m.testingFunc(string(p)) \n        return len(p), nil \n    } \n\n```", "```go\n    // writer_sub_test.go file \n    func TestPublisher(t *testing.T) { \n        msg := \"Hello\" \n\n        var wg sync.WaitGroup \n        wg.Add(1) \n\n        stdoutPrinter := sub.(*writerSubscriber) \n        stdoutPrinter.Writer = &mockWriter{ \n            testingFunc: func(res string) { \n                if !strings.Contains(res, msg) { \n                    t.Fatal(fmt.Errorf(\"Incorrect string: %s\", res)) \n                } \n                wg.Done() \n            }, \n        } \n\n```", "```go\nerr := sub.Notify(msg) \nif err != nil { \n    t.Fatal(err) \n    } \n\n    wg.Wait() \n    sub.Close() \n} \n\n```", "```go\ngo test -cover -v -run=TestWriter .\n=== RUN   TestWriter\n--- FAIL: TestWriter (0.00s)\n writer_sub_test.go:40: Not implemented yet\nFAIL\ncoverage: 6.7% of statements\nexit status 1\nFAIL\n\n```", "```go\nerr := sub.Notify(msg)\nif err != nil {\n wg.Done()\nt.Error(err)\n }\n wg.Wait()\nsub.Close()\n } \n\n```", "```go\n    // publisher.go type \n    type publisher struct { \n        subscribers []Subscriber \n    } \n\n```", "```go\n    // publisher_test.go \n    type mockSubscriber struct { \n        notifyTestingFunc func(msg interface{}) \n        closeTestingFunc func() \n    } \n\n    func (m *mockSubscriber) Close() { \n        m.closeTestingFunc() \n    } \n\n    func (m *mockSubscriber) Notify(msg interface{}) error { \n        m.notifyTestingFunc(msg) \n        return nil \n    } \n\n```", "```go\n    func TestPublisher(t *testing.T) { \n        msg := \"Hello\" \n\n        p := NewPublisher() \n\n```", "```go\n   // publisher.go file \n    func NewPublisher() Publisher { \n        return &publisher{} \n    } \n\n```", "```go\n        var wg sync.WaitGroup \n\n        sub := &mockSubscriber{ \n            notifyTestingFunc: func(msg interface{}) { \n                defer wg.Done() \n\n                s, ok := msg.(string) \n                if !ok { \n                    t.Fatal(errors.New(\"Could not assert result\")) \n                } \n\n                if s != msg { \n                    t.Fail() \n                } \n            }, \n            closeTestingFunc: func() { \n                wg.Done() \n            }, \n        } \n\n```", "```go\n        p.AddSubscriberCh() <- sub \n        wg.Add(1) \n\n        p.PublishingCh() <- msg \n        wg.Wait() \n\n```", "```go\n        pubCon := p.(*publisher) \n        if len(pubCon.subscribers) != 1 { \n            t.Error(\"Unexpected number of subscribers\") \n        } \n\n```", "```go\n   wg.Add(1) \n   p.RemoveSubscriberCh() <- sub \n   wg.Wait() \n\n   //Number of subscribers is restored to zero \n   if len(pubCon.subscribers) != 0 { \n         t.Error(\"Expected no subscribers\") \n   } \n\n   p.Stop() \n}  \n\n```", "```go\n    type publisher struct { \n        subscribers []Subscriber \n        addSubCh    chan Subscriber \n        removeSubCh chan Subscriber \n        in          chan interface{} \n        stop        chan struct{} \n    } \n\n    func (p *publisher) AddSubscriberCh() chan<- Subscriber { \n        return nil \n    } \n\n    func (p *publisher) RemoveSubscriberCh() chan<- Subscriber { \n        return nil \n    } \n\n    func (p *publisher) PublishingCh() chan<- interface{} { \n        return nil \n    } \n\n    func (p *publisher) Stop(){} \n\n```", "```go\ngo test -cover -v -run=TestPublisher .\natal error: all goroutines are asleep - deadlock!\ngoroutine 1 [chan receive]:\ntesting.(*T).Run(0xc0420780c0, 0x5244c6, 0xd, 0x5335a0, 0xc042037d20)\n /usr/local/go/src/testing/testing.go:647 +0x31d\ntesting.RunTests.func1(0xc0420780c0)\n /usr/local/go/src/testing/testing.go:793 +0x74\ntesting.tRunner(0xc0420780c0, 0xc042037e10)\n /usr/local/go/src/testing/testing.go:610 +0x88\ntesting.RunTests(0x5335b8, 0x5ada40, 0x2, 0x2, 0x40d7e9)\n /usr/local/go/src/testing/testing.go:799 +0x2fc\ntesting.(*M).Run(0xc042037ed8, 0xc04200a4f0)\n /usr/local/go/src/testing/testing.go:743 +0x8c\nmain.main()\n go-design-patterns/concurrency_3/pubsub/_test/_testmain.go:56 +0xcd\ngoroutine 5 [chan send (nil chan)]:\ngo-design-patterns/concurrency_3/pubsub.TestPublisher(0xc042078180)\n go-design-patterns/concurrency_3/pubsub/publisher_test.go:55 +0x372\ntesting.tRunner(0xc042078180, 0x5335a0)\n /usr/local/go/src/testing/testing.go:610 +0x88\ncreated by testing.(*T).Run\n /usr/local/go/src/testing/testing.go:646 +0x2f3\nexit status 2\nFAIL  go-design-patterns/concurrency_3/pubsub   1.587s\n\n```"]