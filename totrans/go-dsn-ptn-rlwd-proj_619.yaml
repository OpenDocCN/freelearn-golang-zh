- en: Unit test
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: We have mentioned previously that testing concurrent applications can be difficult.
    With the correct mechanism, it still can be done, so let's see how much we can
    test without big headaches.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，测试并发应用程序可能很困难。有了正确的机制，这仍然可以做到，所以让我们看看我们可以在不遇到大麻烦的情况下测试多少。
- en: Testing subscriber
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试订阅者
- en: 'Starting with subscribers, which seem to have a more encapsulated functionality,
    the first subscriber must print incoming messages from the publisher to an `io.Writer`
    interface. We have mentioned that the subscriber has an interface with two methods,
    `Notify(interface{}) error` and the `Close()` method:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从订阅者开始，它们似乎具有更封装的功能，第一个订阅者必须将发布者传入的消息打印到`io.Writer`接口。我们提到订阅者有一个接口，包含两个方法，`Notify(interface{})
    error`和`Close()`方法：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'OK. This is going to be our `writer_sub.go` file. Create the corresponding
    test file, called the `writer_sub_test.go` file:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。这将是我们`writer_sub.go`文件。创建相应的测试文件，称为`writer_sub_test.go`文件：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, the first problem we have is that the functionality prints to the `stdout`,
    so there''s no return value to check. We can solve it in three ways:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们遇到的第一问题是功能打印到`stdout`，因此没有返回值可以检查。我们可以用三种方式解决这个问题：
- en: Capturing the `stdout` method.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获`stdout`方法。
- en: Injecting an `io.Writer` interface to print to it. This is the preferred solution,
    as it makes the code more manageable.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向其中注入`io.Writer`接口以打印到它。这是首选解决方案，因为它使代码更易于管理。
- en: Redirecting the `stdout` method to a different file.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`stdout`方法重定向到不同的文件。
- en: 'We''ll take the second approach. Redirection is also a possibility. The `os.Stdout`
    is a pointer to an `os.File` type, so it involves replacing this file with one
    we control, and reading from it:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用第二种方法。重定向也是一个可能性。`os.Stdout`是一个指向`os.File`类型的指针，因此它涉及用我们控制的文件替换这个文件，并从中读取：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `NewWriterSubscriber` subscriber isn''t defined yet. It must help in the
    creation of this particular subscriber, returning a type that satisfies the `Subscriber`
    interface, so let''s quickly declare it on the `writer_sub.go` file:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewWriterSubscriber`订阅者尚未定义。它必须帮助创建这个特定的订阅者，返回一个满足`Subscriber`接口的类型，所以让我们在`writer_sub.go`文件中快速声明它：'
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Ideally, it must accept an ID and an `io.Writer` interface as the destination
    for its writes. In this case, we need a custom `io.Writer` interface for our test,
    so we''ll create a `mockWriter` on the `writer_sub_test.go` file for it:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，它必须接受一个ID和一个`io.Writer`接口作为其写入的目的地。在这种情况下，我们需要为我们的测试创建一个自定义的`io.Writer`接口，所以我们在`writer_sub_test.go`文件中为它创建一个`mockWriter`：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `mockWriter` structure will accept a `testingFunc` as one of its fields.
    This `testingFunc` field accepts a string that represents the bytes written to
    the `mockWriter` structure. To implement an `io.Writer` interface, we need to
    define a `Write([]byte) (int, error)` method. In our definition, we pass the contents
    of `p` as a string (remember that we always need to return the bytes read and
    an error, or not, on every `Write` method). This approach delegates the definition
    of `testingFunc` to the scope of the test.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`mockWriter`结构体会接受一个`testingFunc`作为其字段之一。这个`testingFunc`字段接受一个表示写入`mockWriter`结构的字节的字符串。为了实现`io.Writer`接口，我们需要定义一个`Write([]byte)
    (int, error)`方法。在我们的定义中，我们将`p`的内容作为字符串传递（记住，我们总是在每个`Write`方法上返回读取的字节数和错误，或者不返回）。这种方法将`testingFunc`的定义委托给测试的作用域。'
- en: 'We are going to call the `Notify` method on the `Subcriber` interface, which
    must write on the `io.Writer` interface like the `mockWriter` structure. So, we''ll
    define the `testingFunc` of a `mockWriter` structure before calling the `Notify`
    method:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`Subcriber`接口上的`Notify`方法，它必须在`io.Writer`接口上写入，就像`mockWriter`结构体一样。因此，在调用`Notify`方法之前，我们将定义`mockWriter`结构的`testingFunc`：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will send the `Hello` message. This also means that whatever the `Subscriber`
    interface does, it must eventually print the `Hello` message on the provided `io.Writer`
    interface.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发送`Hello`消息。这也意味着无论`Subscriber`接口做什么，它最终必须在提供的`io.Writer`接口上打印`Hello`消息。
- en: So if, eventually, we receive a string on the testing function, we'll need to
    synchronize with the `Subscriber` interface to avoid race conditions on tests.
    That's why we use so much `WaitGroup`. It's a very handy and easy-to-use type
    to handle this scenario. One `Notify` method call will need to wait for one call
    to the `Done()` method, so we call the `Add(1)` method (with one unit).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果最终我们在测试函数中接收到一个字符串，我们需要与 `Subscriber` 接口同步，以避免测试中的竞态条件。这就是为什么我们使用了如此多的 `WaitGroup`。它是一个非常方便且易于使用的类型来处理这种情况。一个
    `Notify` 方法调用需要等待一个 `Done()` 方法的调用，所以我们调用 `Add(1)` 方法（一个单位）。
- en: Ideally, the `NewWriterSubscriber` function must return an interface, so we
    need to type assert it to the type we are working with during the test, in this
    case, the `stdoutPrinter` method. I have omitted error checking when doing the
    casting on purpose, just to make things easier. Once we have a `writerSubscriber`
    type, we can access its `Write` field to replace it with the `mockWriter` structure.
    We could have directly passed an `io.Writer` interface on the `NewWriterSubscriber`
    function, but we wouldn't cover the scenario where a nil object is passed and
    it sets the `os.Stdout` instance to a default value.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，`NewWriterSubscriber` 函数必须返回一个接口，因此我们需要在测试期间将其断言为我们正在使用的类型，在这种情况下是 `stdoutPrinter`
    方法。我故意省略了在类型转换时的错误检查，只是为了使事情更简单。一旦我们有了 `writerSubscriber` 类型，我们就可以访问其 `Write`
    字段来替换为 `mockWriter` 结构。我们本可以直接在 `NewWriterSubscriber` 函数中传递一个 `io.Writer` 接口，但这样我们就不会覆盖传递
    nil 对象并将其设置为默认值的场景。
- en: So, the testing function will eventually receive a string containing what was
    written by the subscriber. We just need to check if the received string, the one
    that the `Subscriber` interface will receive, prints the word `Hello` at some
    point and nothing better that `strings.Contains` function for it. Everything is
    defined under the scope of the testing function, so we can use the value of the
    `t` object to also signal that the test has failed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，测试函数最终将接收到一个包含订阅者所写内容的字符串。我们只需要检查接收到的字符串，即 `Subscriber` 接口将接收到的字符串，在某个时刻是否打印了单词
    `Hello`，并且没有比 `strings.Contains` 函数更好的方法。所有内容都在测试函数的作用域内定义，因此我们可以使用 `t` 对象的值来表示测试失败。
- en: 'Once we have done the checking, we must call to the `Done()` method to signal
    that we have already tested the expected result:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了检查，我们必须调用 `Done()` 方法来表示我们已经测试了预期的结果：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We must actually call the `Notify` and `Wait` methods for the call to the `Done`
    method to check that everything was correct.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上必须调用 `Notify` 和 `Wait` 方法来检查 `Done` 方法的调用是否正确。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Did you realize that we have defined the behavior on tests more or less in reverse?
    This is very common in concurrent apps. It can be confusing sometimes, as it becomes
    difficult to know what a function could be doing if we can't follow calls linearly,
    but you get used to it quite quickly. Instead of thinking "it does this, then
    this, then that," it's more like "this will be called when executing that." This
    is also because the order of execution in a concurrent application is unknown
    until some point, unless we use synchronization primitives (such as WaitGroups
    and channels) to pause execution at certain moments.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你意识到我们没有在测试中定义行为，而是大致相反吗？这在并发应用程序中非常常见。有时可能会令人困惑，因为如果我们不能线性地跟踪调用，就很难知道一个函数可能会做什么，但你会很快习惯它。与其想“它这样做，然后这样做，然后那样做”，不如想“当执行那个时，这将被调用”。这也是因为在并发应用程序中，执行顺序在某个点之前是未知的，除非我们使用同步原语（如
    WaitGroups 和通道）在特定时刻暂停执行。
- en: 'Let''s execute the test for this type now:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为此类型执行测试：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'It has exited fast but it has failed. Actually, the call to the `Done()` method
    has not been executed, so it would be nice to change the last part of our test
    to this instead:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它快速退出但失败了。实际上，对 `Done()` 方法的调用尚未执行，所以最好将我们测试的最后部分改为这样：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, it doesn't stop execution because we are calling the `Error` function instead
    of the `Fatal` function, but we call the `Done()` method and the test ends where
    we prefer it to end, after the `Wait()` method is called. You can try to run the
    tests again, but the output will be the same.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它不会停止执行，因为我们调用的是 `Error` 函数而不是 `Fatal` 函数，但我们调用了 `Done()` 方法，并且测试在调用 `Wait()`
    方法后结束，这是我们希望它结束的地方。你可以再次尝试运行测试，但输出将相同。
- en: Testing publisher
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试发布者
- en: 'We have already seen a `Publisher` interface and the type that will satisfy
    which was the `publisher` type. The only thing we know for sure is that it will
    need some way to store subscribers, so it will at least have a `Subscribers` slice:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`Publisher`接口以及满足该接口的类型，即`publisher`类型。我们唯一确定的是它需要某种方式来存储订阅者，因此它至少有一个`Subscribers`切片：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To test the `publisher` type, we will also need a mock for the `Subscriber`
    interface:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`publisher`类型，我们还需要对`Subscriber`接口进行模拟：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `mockSubscriber` type must implement the `Subscriber` interface, so it must
    have a `Close()` and a `Notify(interface{}) error` method. We can embed an existing
    type that implements it, such as,  the `writerSubscriber`, and override just the
    method that is interesting for us, but we will need to define both, so we won't
    embed anything.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`mockSubscriber`类型必须实现`Subscriber`接口，因此它必须有一个`Close()`和一个`Notify(interface{})
    error`方法。我们可以嵌入一个实现它的现有类型，例如`writerSubscriber`，并仅覆盖对我们有意义的那个方法，但我们需要定义两个方法，所以我们将不嵌入任何内容。'
- en: 'So, we need to override the `Notify` and `Close` methods in this case to call
    the testing functions stored on the fields of the `mockSubscriber` type:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，我们需要覆盖`Notify`和`Close`方法来调用存储在`mockSubscriber`类型字段上的测试函数：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'First of all, we will be sending messages through channels directly, this could
    lead to potential unwanted deadlocks so the first thing to define is a panic handler
    for cases such as, sending to close channels or no Goroutines listening on a channel.
    The message we will send to subscribers is `Hello`. So, each subscriber that has
    been received using the channel returned by the `AddSubscriberCh` method must
    receive this message. We will also use a *New* function to create Publishers,
    called `NewPublisher`. Change the `publisher.go` file now to write it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过通道直接发送消息，这可能导致潜在的死锁，因此我们首先需要定义一个针对诸如向关闭的通道发送消息或没有Goroutines监听通道的情况的panic处理器。我们将发送给订阅者的消息是`Hello`。因此，使用`AddSubscriberCh`方法返回的通道接收到的每个订阅者都必须接收到这条消息。我们还将使用一个名为`New`的函数来创建发布者，称为`NewPublisher`。现在更改`publisher.go`文件以编写它：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we''ll define the `mockSubscriber` to add it to the publisher list of known
    subscribers. Back to the `publisher_test.go` file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将定义`mockSubscriber`以将其添加到已知的订阅者列表中。回到`publisher_test.go`文件：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As usual, we start with a WaitGroup. First, testing the function in our subscriber
    defers a call to the `Done()` method at the end of its execution. Then it needs
    to type cast `msg` variable because it's coming as an interface. Remember that
    this way, we can use the `Publisher` interface with many types by introducing
    the overhead of the type assertion. This is done on line `s, ok := msg.(string)`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常一样，我们从WaitGroup开始。首先，在订阅者定义中的测试函数在执行结束时推迟调用`Done()`方法。然后它需要将`msg`变量类型转换为字符串，因为它是以接口的形式传入的。记住，这样我们就可以通过引入类型断言的开销使用`Publisher`接口与许多类型一起使用。这是在行`s,
    ok := msg.(string)`中完成的。
- en: 'Once we have type cast `msg` to a string, `s`, we just need to check if the
    value received in the subscriber is the same as the value we sent, or fail the
    test if not:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将`msg`类型转换为字符串`s`，我们只需检查接收到的订阅者中的值是否与我们发送的值相同，如果不是，则测试失败：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We add the `mockSubscriber` type using the `AddSubscriberCh` method. We publish
    our message just after getting ready, by adding one to the `WaitGroup`, and just
    before setting the `WaitGroup` to wait so that the test doesn't continue until
    the `mockSubscriber` type calls the `Done()` method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`AddSubscriberCh`方法添加`mockSubscriber`类型。在准备就绪后，通过将一个元素添加到`WaitGroup`中，并在设置`WaitGroup`等待之前发布我们的消息，这样测试就不会在`mockSubscriber`类型调用`Done()`方法之前继续。
- en: 'Also, we need to check if the number of the `Subscriber` interface has grown
    after calling the `AddSubscriberCh` method, so we''ll need to get the concrete
    instance of publisher on the test:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还需要检查在调用`AddSubscriberCh`方法后`Subscriber`接口的数量是否增加，因此我们需要在测试中获取发布者的具体实例：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Type assertion is our friend today! Once we have the concrete type, we can
    access the underlying slice of subscribers for the `Publisher` interface. The
    number of subscribers must be 1 after calling the `AddSubscriberCh` method once,
    or the test will fail. The next step is to check just the opposite--when we remove
    a `Subscriber` interface, it must be taken from this list:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言是我们今天的良友！一旦我们有了具体类型，我们就可以访问`Publisher`接口的底层订阅者切片。在调用一次`AddSubscriberCh`方法后，订阅者的数量必须是1，否则测试将失败。下一步是检查相反的情况——当我们移除`Subscriber`接口时，它必须从这个列表中取出：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The final step in our test is to stop the publisher so no more messages can
    be sent and all the Goroutines are stopped.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试的最终步骤是停止发布者，这样就不会有更多的消息被发送，并且所有Goroutines都会停止。
- en: 'The test is finished, but we can''t run tests until the `publisher` type has
    all the methods implemented; this must be the final result:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 测试已经完成，但我们不能运行测试，直到`publisher`类型实现了所有方法；这必须是最终结果：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With this empty implementation, nothing good can happen when running the tests:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种空实现，在运行测试时什么好事都不会发生：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Yes it has failed but, it's not a controlled fail at all. This was done on purpose
    to show a couple of things to be careful of in Go. First of all, the error produced
    in this test is a **fatal** error, which usually points to a bug in the code.
    This is important because while a **panic** error can be recovered, you cannot
    do the same with a fatal error.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，它失败了，但这根本不是可控的失败。这是故意为之，为了展示在Go中需要注意的几个问题。首先，这个测试中产生的错误是一个**致命**错误，这通常指向代码中的错误。这很重要，因为虽然**panic**错误可以被恢复，但你不能对致命错误做同样的事情。
- en: 'In this case, the error is telling us the problem: `goroutine 5 [chan send
    (nil chan)]`, a nil channel so it''s actually a bug in our code. How can we solve
    this? Well, this is also interesting.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，错误告诉我们问题：`goroutine 5 [chan send (nil chan)]`，一个`nil`通道，所以这实际上是我们代码中的一个错误。我们如何解决这个问题？嗯，这也是很有趣的。
- en: The fact that we have a `nil` channel is caused by the code we wrote to compile
    unit tests but this particular error won't be raised once the appropriate code
    is written (because we'll never return a nil channel in this case). We could return
    a channel that is never use we cause a fatal error with a deadlock, which wouldn't
    be any progress at all either.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`nil`通道的事实是由于我们编写的用于编译单元测试的代码造成的，但这个特定的错误一旦编写了适当的代码就不会被触发（因为我们永远不会在这种情况下返回一个`nil`通道）。我们本可以返回一个永远不会使用的通道，这会导致死锁，这根本没有任何进展。
- en: An idiomatic way to solve it would be to return a channel and an error so that
    you can have an error package with a type implementing the `Error` interface that
    returns a specific error such as `NoGoroutinesListening` or `ChannelNotCreated`.
    We have already seen many of this implementations so we'll leave these as an exercise
    to the reader and we will move forward to maintain focus on the concurrent nature
    of the chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种习惯性方法是通过返回一个通道和一个错误，这样你就可以有一个包含实现`Error`接口的类型的具体错误的错误包，例如`NoGoroutinesListening`或`ChannelNotCreated`。我们已经看到了许多这样的实现，所以我们将把这些留作读者的练习，并将继续前进，以保持对章节并发特性的关注。
- en: Nothing surprising there, so we can move to the implementation phase.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么令人惊讶的，所以我们可以进入实现阶段。
