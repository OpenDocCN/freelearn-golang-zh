["```go\n    type writerSubscriber struct { \n        in     chan interface{} \n        id     int \n        Writer io.Writer \n    } \n\n    func NewWriterSubscriber(id int, out io.Writer) Subscriber { \n        if out == nil { \n            out = os.Stdout \n        } \n\n        s := &writerSubscriber{ \n            id:     id, \n            in:     make(chan interface{}), \n            Writer: out, \n        } \n\n        go func(){ \n            for msg := range s.in { \n                fmt.Fprintf(s.Writer, \"(W%d): %v\\n\", s.id, msg) \n            } \n        }() \n\n        return s \n    } \n\n```", "```go\n    func (s *writerSubscriber) Close() { \n        close(s.in) \n    } \n\n```", "```go\n    func (s *writerSubscriber) Notify(msg interface{}) (err error) { \n        defer func(){ \n            if rec := recover(); rec != nil { \n                err = fmt.Errorf(\"%#v\", rec) \n            } \n        }() \n\n        select { \n        case s.in <- msg: \n        case <-time.After(time.Second): \n            err = fmt.Errorf(\"Timeout\\n\") \n        } \n\n        return \n    } \n\n```", "```go\ngo test -run=TestWriter -v .\n=== RUN   TestWriter\n--- PASS: TestWriter (0.00s)\nPASS\nok\n\n```", "```go\n    type publisher struct { \n        subscribers []Subscriber \n        addSubCh    chan Subscriber \n        removeSubCh chan Subscriber \n        in          chan interface{} \n        stop        chan struct{} \n    } \n\n```", "```go\n    func (p *publisher) AddSubscriber() { \n        return p.addSubCh \n    } \n\n    func (p *publisher) RemoveSubscriberCh() { \n        return p.removeSubCh \n    } \n\n    func (p *publisher) PublishMessage(){ \n        return p.in \n    } \n\n```", "```go\nfunc (p *publisher) Stop(){ \n  close(p.stop) \n} \n\n```", "```go\nfunc (p *publisher) start() { \n  for { \n    select { \n    case msg := <-p.in: \n      for _, ch := range p.subscribers { \n        sub.Notify(msg) \n      } \n\n```", "```go\n    case sub := <-p.addSubCh: \n    p.subscribers = append(p.subscribers, sub) \n\n```", "```go\n     case sub := <-p.removeSubCh: \n     for i, candidate := range p.subscribers { \n         if candidate == sub { \n             p.subscribers = append(p.subscribers[:i], p.subscribers[i+1:]...) \n             candidate.Close() \n             break \n        } \n    } \n\n```", "```go\n    case <-p.stop: \n    for _, sub := range p.subscribers { \n        sub.Close() \n            } \n\n        close(p.addSubCh) \n        close(p.in) \n        close(p.removeSubCh) \n\n        return \n        } \n    } \n} \n\n```", "```go\ngo test -race .\nok\n\n```"]