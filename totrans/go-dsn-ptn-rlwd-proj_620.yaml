- en: Implementation
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To recall, the `writerSubscriber` must receive messages that it will write on
    a type that satisfies the `io.Writer` interface.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'So, where do we start? Well, each subscriber will run its own Goroutine, and
    we have seen that the best method to communicate with a Goroutine is a channel.
    So, we will need a field with a channel in the `Subscriber` type. We can use the
    same approach as in pipelines to end with the `NewWriterSubscriber` function and
    the `writerSubscriber` type:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the first step, if no writer is specified (the `out` argument is nil), the
    default `io.Writer` interface is `stdout`. Then, we create a new pointer to the
    `writerSubscriber` type with the ID passed in the first argument, the value of
    out (`os.Stdout`, or whatever came in the argument if it wasn't nil), and a channel
    called in to maintain the same naming as in previous examples.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Then we launch a new Goroutine; this is the launching mechanism we mentioned.
    Like in the pipelines, the subscriber will iterate over the `in` channel every
    time a new message is received and it will format its contents to a string, which
    also contains the ID of the current subscriber.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'As we learned previously, if the `in` channel is closed, the `for range` loop
    will stop and that particular Goroutine will finish, so the only thing we need
    to do in the `Close` method is to actually close the `in` channel:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'OK, only the `Notify` method is left; the `Notify` method is a convenient method
    to manage a particular behavior when communicating, and we will use a pattern
    that is common in many calls:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When communicating with a channel, there are two behavior that we must usually
    control: one is waiting time and the other is when the channel is closed. The
    deferred function actually works for any panicking error that can occur within
    the function. If the Goroutine panics, it will still execute the deferred function
    with the `recover()` method. The `recover()` method returns an interface of whatever
    the error was, so in our case, we set the returning variable error to the formatted
    value returned by `recover` (which is an interface). The `"%#v"` parameter gives
    us most of the information about any type when formatted to a string. The returned
    error will be ugly, but it will contain most of the information we can extract
    about the error. For a closed channel, for example, it will return "send on a
    closed channel". Well, this seems clear enough.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'The second rule is about waiting time. When we send a value over a channel,
    we will be blocked until another Goroutine takes the value from it (it will happen
    the same with a filled buffered channel). We don''t want to get blocked forever,
    so we set a timeout period of one second by using a select handler. In short,
    with select we are saying: either you take the value in less than 1 second or
    I will discard it and return an error.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the `Close`, `Notify`, and `NewWriterSubscriber` methods, so we can
    try our test again:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Much better now. The `Writer` has taken the mock writer we wrote on the test
    and has written to it the value we pass to the Notify method. At the same time,
    close has probably closed the channel effectively, because the `Notify` method
    is returning an error after calling the `Close` method. One thing to mention is
    that we can't check if a channel is closed or not without interacting with it;
    that's why we had to defer the execution of a closure that will check the contents
    of the `recover()` function in the `Notify` method.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在好多了。`Writer`已经将我们在测试中编写的模拟写入器写入我们传递给`Notify`方法的值。同时，关闭操作可能已经有效地关闭了通道，因为`Notify`方法在调用`Close`方法后返回了一个错误。有一点要提的是，我们无法在不与之交互的情况下检查通道是否已关闭；这就是为什么我们不得不延迟执行一个将检查`Notify`方法中`recover()`函数内容的闭包的执行。
- en: Implementing the publisher
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现发布者
- en: OK, the publisher will need also a launching mechanism, but the main problems
    to deal with are race conditions accessing the subscriber list. We can solve this
    issue with a Mutex object from the `sync` package but we have already seen how
    to use this so we will use channels instead.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，发布者也需要一个启动机制，但主要需要处理的问题是访问订阅者列表的竞态条件。我们可以使用`sync`包中的Mutex对象来解决这个问题，但我们已经看到了如何使用它，所以我们将使用通道。
- en: 'When using channels, we will need a channel for each action that can be considered
    dangerous--add a subscriber, remove a subscriber, retrieve the list of subscribers
    to `Notify` method them of a message, and a channel to stop all the subscribers.
    We also need a channel for incoming messages:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用通道时，我们将需要一个通道来处理每个可能被视为危险的操作--添加订阅者、移除订阅者、检索订阅者列表以通过消息通知他们，以及一个用于停止所有订阅者的通道。我们还需要一个通道来处理传入的消息：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Names are self-descriptive but, in short, subscribers maintain the list of subscribers;
    this is the slice that needs multiplexed access. The `addSubCh` instance is the
    channel to communicate with when you want to add a new subscriber; that's why
    it's a channel of subscribers. The same explanation applies to the `removeSubCh`
    channel, but this channel is to remove the subscriber. The `in` channel will handle
    incoming messages that must be broadcast to all subscribers. Finally, the stop
    channel must be called when we want to kill all Goroutines.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 名称具有自我描述性，但简而言之，订阅者维护订阅者列表；这是需要复用访问的切片。`addSubCh`实例是在你想添加新订阅者时进行通信的通道；这就是为什么它是一个订阅者通道。同样的解释也适用于`removeSubCh`通道，但这个通道是用来移除订阅者的。`in`通道将处理必须广播给所有订阅者的传入消息。最后，当我们想要终止所有Goroutines时，必须调用停止通道。
- en: 'OK, let''s start with the `AddSubscriberCh`, `RemoveSubscriber` and `PublishingCh`
    methods, which must return the channel to add and remove subscribers and the channel
    to send messages to all of them:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们从`AddSubscriberCh`、`RemoveSubscriber`和`PublishingCh`方法开始，这些方法必须返回添加和移除订阅者的通道以及向所有这些发送消息的通道：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Stop()` function the `stop` channel by closing it. This will effectively
    spread the signal to every listening Goroutine:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stop()`函数通过关闭`stop`通道。这将有效地将信号传播到每个监听的Goroutine：'
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Stop` method, the function to stop the publisher and the subscribers, also
    pushes to its respective channel, called stop.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stop`方法，停止发布者和订阅者的函数，也会向其各自的通道推送，称为停止通道。'
- en: You may be wondering why we don't simply leave the channels available so that
    users push directly to this channel instead of using the proxying function. Well,
    the idea is that the user that integrates the library in their app doesn't have
    to deal with the complexity of the concurrent structure associated with the library,
    so they can focus on their business while maximizing performance as much as possible.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们不简单地将通道保持可用，让用户直接向这个通道推送，而不是使用代理函数。好吧，想法是，将库集成到他们的应用程序中的用户不需要处理与库相关的并发结构的复杂性，这样他们就可以专注于自己的业务，尽可能最大化性能。
- en: Handling channels without race conditions
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无竞态条件地处理通道
- en: Until now, we have forwarded data to the channels on the publisher but we haven't
    actually handled any of that data. The launcher mechanism that is going to launch
    a different Goroutine will handle them all.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将数据转发到发布者的通道上，但我们实际上并没有处理任何这些数据。将要启动不同Goroutine的启动机制将处理所有这些。
- en: 'We will create a launch method that we will execute by using the `go` keyword
    instead of embedding the whole function inside the `NewPublisher` function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个启动方法，我们将通过使用`go`关键字来执行它，而不是将整个函数嵌入到`NewPublisher`函数中：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Launch` is a private method and we haven''t tested it. Remember that private
    methods are usually called from public methods (the ones we have tested). Generally,
    if a private method is not called from a public method, it can''t be called at
    all!'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Launch`是一个私有方法，我们还没有对其进行测试。记住，私有方法通常是从公共方法（我们已经测试过的那些）中调用的。一般来说，如果一个私有方法没有被公共方法调用，那么它根本不能被调用！'
- en: The first thing we notice with this method is that it is an infinite for loop
    that will repeat a select operation between many channels but only one of them
    can be executed each time. The first of these operations is the one that receives
    a new message to publish to subscribers. The `case msg := <- p.in:` code handles
    this incoming operation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先注意到这个方法是一个无限循环，它将在许多通道之间重复选择操作，但每次只能执行其中一个。这些操作中的第一个是接收新消息以发布给订阅者。`case
    msg := <- p.in:`代码处理这个传入的操作。
- en: 'In this case, we are iterating over all subscribers and executing their `Notify`
    method. You may be wondering why we don''t add the `go` keyword in front so that
    the `Notify` method is executed as a different Goroutine and therefore iterates
    much faster. Well, this because we aren''t demultiplexing the actions of receiving
    a message and of closing the message. So, if we launch the subscriber in a new
    Goroutine and it is closed while the message is processed in the `Notify` method,
    we''ll have a race condition where a message will try to be sent within the `Notify`
    method to a closed channel. In fact, we are considering this scenario when we
    develop the `Notify` method but, still, we won''t control the number of Goroutines
    launched if we call the `Notify` method in a new Goroutine each time. For simplicity,
    we just call the `Notify` method, but it is a nice exercise to control the number
    of Goroutines waiting for a return in a `Notify` method execution. By buffering
    the `in` channel in each subscriber, we can also achieve a good solution:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在遍历所有订阅者并执行它们的`Notify`方法。你可能想知道为什么我们不添加`go`关键字，这样`Notify`方法就可以作为一个不同的Goroutine执行，从而迭代得更快。嗯，这是因为我们并没有解复用接收消息和关闭消息的动作。所以，如果我们在一个新的Goroutine中启动订阅者，并且它在`Notify`方法处理消息时被关闭，我们将在`Notify`方法中尝试向一个已关闭的通道发送消息，这将产生一个竞态条件。实际上，我们在开发`Notify`方法时考虑了这种场景，但我们仍然不会控制每次调用`Notify`方法时启动的Goroutine数量。为了简单起见，我们只是调用`Notify`方法，但这是一个很好的练习，可以在`Notify`方法执行中控制等待返回的Goroutine数量。通过在每个订阅者中缓冲`in`通道，我们也可以得到一个好的解决方案：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next operation is what to do when a value arrives to the channel to add
    subscribers. In this case it''s simple: we update it, appending the new value
    to it. While this case is executed, not other calls can be executed in this selection:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个操作是当一个值到达通道以添加订阅者时应该做什么。在这种情况下很简单：我们更新它，将其新值附加到它上面。当这个案例执行时，其他调用不能在这个选择中执行：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When a value arrives at the remove channel, the operation is a bit more complex
    because we have to search for the subscriber in the slice. We use a *O(N)* approach
    for it, iterating from the beginning until we find it, but the search algorithm
    could be greatly improved. Once we find the corresponding `Subscriber` interface,
    we remove it from the subscribers slice and stop it. One thing to mention is that
    on tests, we are accessing the length of the subscribers slice directly without
    demultiplexing the operation. This is clearly a race condition, but generally,
    it isn't reflected when running the race detector.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值到达移除通道时，操作稍微复杂一些，因为我们必须在切片中搜索订阅者。我们使用*O(N)*方法进行搜索，从开始迭代直到找到它，但搜索算法可以大大改进。一旦我们找到相应的`Subscriber`接口，我们就从订阅者切片中移除它并停止它。有一点需要提及的是，在测试中，我们直接访问订阅者切片的长度，而没有解复用操作。这显然是一个竞态条件，但通常在运行竞态检测器时并不会反映出来。
- en: 'The solution will be to develop a method just to multiplex calls to get the
    length of the slice, but it won''t belong to the public interface. Again, for
    simplicity, we''ll leave it like this, or this example may become too complex
    to handle:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案将是开发一种仅用于获取切片长度的多路复用调用方法，但它不会属于公共接口。再次，为了简单起见，我们将保持现状，否则这个例子可能会变得过于复杂而难以处理：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The last operation to demultiplex is the `stop` operation, which must stop all
    Goroutines in the publisher and subscribers. Then we have to iterate through every
    Subscriber stored in the subscribers field to execute their `Close()` method,
    so their Goroutines are closed, too. Finally, if we return this Goroutine, it
    will finish, too.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个解复用操作是`停止`操作，它必须停止发布者和订阅者中的所有Goroutines。然后我们必须遍历存储在`subscribers`字段中的每个订阅者，以执行它们的`Close()`方法，这样它们的Goroutines也会关闭。最后，如果我们返回这个Goroutine，它也会结束。
- en: 'OK, time to execute all tests and see how is it going:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在是执行所有测试并看看进展如何的时候了：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Not so bad. All tests have passed successfully and we have our Observer pattern
    ready. While the example can still be improved, it is a great example of how we
    must handle an Observer pattern using channels in Go. As an exercise, we encourage
    you to try the same example using mutexes instead of channels to control access.
    It's a bit easier, and will also give you an insight of how to work with mutexes.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 还不错。所有测试都成功通过，我们已经准备好了观察者模式。虽然这个例子还可以改进，但它是一个很好的例子，说明了我们必须如何使用Go中的通道来处理观察者模式。作为一个练习，我们鼓励你尝试使用互斥锁而不是通道来控制访问的相同例子。这会容易一些，也会让你了解如何与互斥锁一起工作。
