<html><head></head><body>
<div class="book" title="Chapter&#xA0;1.&#xA0; Chat Application with Web Sockets">
<div class="book" title="A simple web server">
<div class="book" title="Separating views from logic using templates"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec007" class="calibre1"/>Separating views from logic using templates</h2></div></div></div><p class="calibre10">Templates allow us to blend generic text with specific text, for instance, injecting a user's name into a welcome message. For example, consider the following template:</p><pre class="programlisting">Hello {{name}}, how are you? 
</pre><p class="calibre10">We are able to replace the <code class="email">{{name}}</code> text in the preceding template with the real name of a person. So if Bruce signs in, he might see:</p><pre class="programlisting">Hello Bruce, how are you? 
</pre><p class="calibre10">The Go standard library has two main template packages: one called <code class="email">text/template</code> for text and one called <code class="email">html/template</code> for HTML. The <code class="email">html/template</code> package does the same as the text version except that it understands the context in which data will be injected into the template. This is useful because it avoids script injection attacks and resolves common issues such as having to encode special characters for URLs.</p><p class="calibre10">Initially, we just want to move the HTML code from inside our Go code to its own file, but won't blend any text just yet. The template packages make loading external files very easy, so it's a good choice for us.</p><p class="calibre10">Create a new folder under our <code class="email">chat</code> folder called <code class="email">templates</code> and create a <code class="email">chat.html</code> file inside it. We will move the HTML from <code class="email">main.go</code> to this file, but we will make a minor change to ensure our changes have taken effect:</p><pre class="programlisting">&lt;html&gt; 
  &lt;head&gt; 
    &lt;title&gt;Chat&lt;/title&gt; 
  &lt;/head&gt; 
  &lt;body&gt; 
    Let's chat (from template) 
  &lt;/body&gt; 
&lt;/html&gt; 
</pre><p class="calibre10">Now, we have our external HTML file ready to go, but we need a way to compile the template and serve it to the user's browser.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip7" class="calibre1"/>Tip</h3><p class="calibre10">Compiling a template is a process by which the source template is interpreted and prepared for blending with various data, which must happen before a template can be used but only needs to happen once.</p></div><p class="calibre10">We are going to write our own <code class="email">struct</code> type that is responsible for loading, compiling, and delivering our template. We will define a new type that will take a <code class="email">filename</code> string, compile the template once (using the <code class="email">sync.Once</code> type), keep the reference to the compiled template, and then respond to HTTP requests. You will need to import the <code class="email">text/template</code>, <code class="email">path/filepath</code>, and <code class="email">sync</code> packages in order to build your code.</p><p class="calibre10">In <code class="email">main.go</code>, insert the following code above the <code class="email">func main()</code> line:</p><pre class="programlisting">// templ represents a single template 
type templateHandler struct { 
  once     sync.Once 
  filename string 
  templ    *template.Template 
} 
// ServeHTTP handles the HTTP request. 
func (t *templateHandler) ServeHTTP(w http.ResponseWriter, r  *http.Request) { 
  t.once.Do(func() { 
    t.templ =  template.Must(template.ParseFiles(filepath.Join("templates",
      t.filename))) 
  }) 
  t.templ.Execute(w, nil) 
} 
</pre><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip8" class="calibre1"/>Tip</h3><p class="calibre10">Did you know that you could automate the adding and removing of imported packages? See <a class="calibre1" title="Appendix Appendix. Good Practices for a Stable Go Environment" href="part0227_split_000.html#6OFFM1-9c484ed022e64a0fb0e1aebf8e05d4fd">Appendix</a>, <span class="strong"><em class="calibre11">Good Practices for a Stable Go Environment</em></span>, on how to do this.</p></div><p class="calibre10">The <code class="email">templateHandler</code> type has a single method called <code class="email">ServeHTTP</code> whose signature looks suspiciously like the method we passed to <code class="email">http.HandleFunc</code> earlier. This method will load the source file, compile the template and execute it, and write the output to the specified <code class="email">http.ResponseWriter</code> method. Because the <code class="email">ServeHTTP</code> method satisfies the <code class="email">http.Handler</code> interface, we can actually pass it directly to <code class="email">http.Handle</code>.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip9" class="calibre1"/>Tip</h3><p class="calibre10">A quick look at the Go standard library source code, which is located at
<a class="calibre1" href="http://golang.org/pkg/net/http/#Handler">http://golang.org/pkg/net/http/#Handler</a>, will reveal that the interface definition for <code class="email">http.Handler</code> specifies that only the <code class="email">ServeHTTP</code> method need be present in order for a type to be used to serve HTTP requests by the <code class="email">net/http</code> package.</p></div><div class="book" title="Doing things once"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec000" class="calibre1"/>Doing things once</h3></div></div></div><p class="calibre10">We only need to compile the template once, and there are a few different ways to approach this in Go. The most obvious is to have a <code class="email">NewTemplateHandler</code> function that creates the type and calls some initialization code to compile the template. If we were sure the function would be called by only one goroutine (probably the main one during the setup in the <code class="email">main</code> function), this would be a perfectly acceptable approach. An alternative, which we have employed in the preceding section, is to compile the template once inside the <code class="email">ServeHTTP</code> method. The <code class="email">sync.Once</code> type guarantees that the function we pass as an argument will only be executed once, regardless of how many goroutines are calling <code class="email">ServeHTTP</code>. This is helpful because web servers in Go are automatically concurrent and once our chat application takes the world by storm, we could very well expect to have many concurrent calls to the <code class="email">ServeHTTP</code> method.</p><p class="calibre10">Compiling the template inside the <code class="email">ServeHTTP</code> method also ensures that our code does not waste time doing work before it is definitely needed. This lazy initialization approach doesn't save us much in our present case, but in cases where the setup tasks are time- and resource-intensive and where the functionality is used less frequently, it's easy to see how this approach would come in handy.</p></div><div class="book" title="Using your own handlers"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec001" class="calibre1"/>Using your own handlers</h3></div></div></div><p class="calibre10">To implement our <code class="email">templateHandler</code> type, we need to update the <code class="email">main</code> body function so that it looks like this:</p><pre class="programlisting">func main() { 
  // root 
  http.Handle("/", &amp;templateHandler{filename: "chat.html"}) 
  // start the web server 
  if err := http.ListenAndServe(":8080", nil); err != nil { 
    log.Fatal("ListenAndServe:", err) 
  } 
} 
</pre><p class="calibre10">The <code class="email">templateHandler</code> structure is a valid <code class="email">http.Handler</code> type so we can pass it directly to the <code class="email">http.Handle</code> function and ask it to handle requests that match the specified pattern. In the preceding code, we created a new object of the type <code class="email">templateHandler</code>,  specifying the filename as <code class="email">chat.html</code> that we then take the address of (using the <code class="email">&amp;</code> address of the operator) and pass it to the <code class="email">http.Handle</code> function. We do not store a reference to our newly created <code class="email">templateHandler</code> type, but that's OK because we don't need to refer to it again.</p><p class="calibre10">In your terminal, exit the program by pressing <span class="strong"><em class="calibre11">Ctrl + C</em></span> and re-run it, then refresh your browser and notice the addition of the (from template) text. Now our code is much simpler than an HTML code and free from its ugly blocks.</p></div></div></div></div></body></html>