- en: Separating views from logic using templates
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Templates allow us to blend generic text with specific text, for instance,
    injecting a user''s name into a welcome message. For example, consider the following
    template:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We are able to replace the `{{name}}` text in the preceding template with the
    real name of a person. So if Bruce signs in, he might see:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The Go standard library has two main template packages: one called `text/template`
    for text and one called `html/template` for HTML. The `html/template` package
    does the same as the text version except that it understands the context in which
    data will be injected into the template. This is useful because it avoids script
    injection attacks and resolves common issues such as having to encode special
    characters for URLs.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we just want to move the HTML code from inside our Go code to its
    own file, but won't blend any text just yet. The template packages make loading
    external files very easy, so it's a good choice for us.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder under our `chat` folder called `templates` and create a `chat.html`
    file inside it. We will move the HTML from `main.go` to this file, but we will
    make a minor change to ensure our changes have taken effect:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, we have our external HTML file ready to go, but we need a way to compile
    the template and serve it to the user's browser.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Compiling a template is a process by which the source template is interpreted
    and prepared for blending with various data, which must happen before a template
    can be used but only needs to happen once.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: We are going to write our own `struct` type that is responsible for loading,
    compiling, and delivering our template. We will define a new type that will take
    a `filename` string, compile the template once (using the `sync.Once` type), keep
    the reference to the compiled template, and then respond to HTTP requests. You
    will need to import the `text/template`, `path/filepath`, and `sync` packages
    in order to build your code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main.go`, insert the following code above the `func main()` line:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Did you know that you could automate the adding and removing of imported packages?
    See [Appendix](part0227_split_000.html#6OFFM1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Appendix Appendix. Good Practices for a Stable Go Environment"), *Good Practices
    for a Stable Go Environment*, on how to do this.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The `templateHandler` type has a single method called `ServeHTTP` whose signature
    looks suspiciously like the method we passed to `http.HandleFunc` earlier. This
    method will load the source file, compile the template and execute it, and write
    the output to the specified `http.ResponseWriter` method. Because the `ServeHTTP`
    method satisfies the `http.Handler` interface, we can actually pass it directly
    to `http.Handle`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A quick look at the Go standard library source code, which is located at [http://golang.org/pkg/net/http/#Handler](http://golang.org/pkg/net/http/#Handler),
    will reveal that the interface definition for `http.Handler` specifies that only
    the `ServeHTTP` method need be present in order for a type to be used to serve
    HTTP requests by the `net/http` package.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看位于[http://golang.org/pkg/net/http/#Handler](http://golang.org/pkg/net/http/#Handler)的Go标准库源代码，可以发现`http.Handler`接口定义指定，只有`ServeHTTP`方法存在，类型才能被`net/http`包用来处理HTTP请求。
- en: Doing things once
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一次性完成事情
- en: We only need to compile the template once, and there are a few different ways
    to approach this in Go. The most obvious is to have a `NewTemplateHandler` function
    that creates the type and calls some initialization code to compile the template.
    If we were sure the function would be called by only one goroutine (probably the
    main one during the setup in the `main` function), this would be a perfectly acceptable
    approach. An alternative, which we have employed in the preceding section, is
    to compile the template once inside the `ServeHTTP` method. The `sync.Once` type
    guarantees that the function we pass as an argument will only be executed once,
    regardless of how many goroutines are calling `ServeHTTP`. This is helpful because
    web servers in Go are automatically concurrent and once our chat application takes
    the world by storm, we could very well expect to have many concurrent calls to
    the `ServeHTTP` method.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要编译一次模板，在Go中有几种不同的方法可以做到这一点。最明显的方法是有一个`NewTemplateHandler`函数，它创建类型并调用一些初始化代码来编译模板。如果我们确信该函数只会被一个goroutine调用（可能是在`main`函数中的设置阶段），这将是一个完全可接受的方法。另一种方法，我们在前面的章节中已经使用过，是在`ServeHTTP`方法内部一次性编译模板。`sync.Once`类型保证我们传递给它的函数只执行一次，不管有多少goroutine调用`ServeHTTP`。这很有帮助，因为Go中的Web服务器是自动并发的，一旦我们的聊天应用风靡全球，我们完全可能期望有多个并发调用`ServeHTTP`方法。
- en: Compiling the template inside the `ServeHTTP` method also ensures that our code
    does not waste time doing work before it is definitely needed. This lazy initialization
    approach doesn't save us much in our present case, but in cases where the setup
    tasks are time- and resource-intensive and where the functionality is used less
    frequently, it's easy to see how this approach would come in handy.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ServeHTTP`方法内部编译模板也确保了我们的代码在绝对需要之前不会浪费时间做无用功。这种懒加载初始化方法在我们目前的案例中并没有节省我们太多，但在设置任务耗时且资源密集，以及功能使用频率较低的情况下，很容易看出这种方法的实用性。
- en: Using your own handlers
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自己的处理器
- en: 'To implement our `templateHandler` type, we need to update the `main` body
    function so that it looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现我们的`templateHandler`类型，我们需要更新`main`主体函数，使其看起来像这样：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `templateHandler` structure is a valid `http.Handler` type so we can pass
    it directly to the `http.Handle` function and ask it to handle requests that match
    the specified pattern. In the preceding code, we created a new object of the type `templateHandler`,
     specifying the filename as `chat.html` that we then take the address of (using
    the `&` address of the operator) and pass it to the `http.Handle` function. We
    do not store a reference to our newly created `templateHandler` type, but that's
    OK because we don't need to refer to it again.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`templateHandler`结构是一个有效的`http.Handler`类型，因此我们可以直接将其传递给`http.Handle`函数，并要求它处理与指定模式匹配的请求。在前面的代码中，我们创建了一个新的`templateHandler`类型的对象，指定文件名为`chat.html`，然后我们使用（使用`&`取地址运算符）获取其地址，并将其传递给`http.Handle`函数。我们不需要存储新创建的`templateHandler`类型的引用，但这没关系，因为我们不需要再次引用它。'
- en: In your terminal, exit the program by pressing *Ctrl + C* and re-run it, then
    refresh your browser and notice the addition of the (from template) text. Now
    our code is much simpler than an HTML code and free from its ugly blocks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端中，通过按*Ctrl + C*退出程序，然后重新运行它，然后刷新浏览器，注意查看（来自模板）文本的添加。现在我们的代码比HTML代码简单得多，并且摆脱了其丑陋的块状结构。
