- en: Separating views from logic using templates
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用模板将视图与逻辑分离
- en: 'Templates allow us to blend generic text with specific text, for instance,
    injecting a user''s name into a welcome message. For example, consider the following
    template:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模板允许我们将通用文本与特定文本混合，例如，将用户的姓名注入到欢迎信息中。例如，考虑以下模板：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We are able to replace the `{{name}}` text in the preceding template with the
    real name of a person. So if Bruce signs in, he might see:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够将前面模板中的`{{name}}`文本替换为某人的真实姓名。所以如果布鲁斯登录，他可能会看到：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The Go standard library has two main template packages: one called `text/template`
    for text and one called `html/template` for HTML. The `html/template` package
    does the same as the text version except that it understands the context in which
    data will be injected into the template. This is useful because it avoids script
    injection attacks and resolves common issues such as having to encode special
    characters for URLs.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库中有两个主要的模板包：一个称为`text/template`用于文本，另一个称为`html/template`用于HTML。`html/template`包与文本版本的功能相同，但它理解数据将被注入模板的上下文。这很有用，因为它可以避免脚本注入攻击并解决诸如必须对URL中的特殊字符进行编码等常见问题。
- en: Initially, we just want to move the HTML code from inside our Go code to its
    own file, but won't blend any text just yet. The template packages make loading
    external files very easy, so it's a good choice for us.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，我们只想将Go代码内部的HTML代码移动到其自己的文件中，但暂时不会混合任何文本。模板包使加载外部文件变得非常容易，因此对我们来说是一个不错的选择。
- en: 'Create a new folder under our `chat` folder called `templates` and create a `chat.html`
    file inside it. We will move the HTML from `main.go` to this file, but we will
    make a minor change to ensure our changes have taken effect:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`chat`文件夹下创建一个新的文件夹名为`templates`，并在其中创建一个`chat.html`文件。我们将把`main.go`中的HTML代码移动到这个文件中，但我们会进行一些小的修改以确保我们的更改生效：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, we have our external HTML file ready to go, but we need a way to compile
    the template and serve it to the user's browser.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了外部HTML文件，但我们需要一种方法来编译模板并将其提供给用户的浏览器。
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Compiling a template is a process by which the source template is interpreted
    and prepared for blending with various data, which must happen before a template
    can be used but only needs to happen once.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 编译模板是一个将源模板进行解释并准备与各种数据混合的过程，这在使用模板之前必须发生，但只需要发生一次。
- en: We are going to write our own `struct` type that is responsible for loading,
    compiling, and delivering our template. We will define a new type that will take
    a `filename` string, compile the template once (using the `sync.Once` type), keep
    the reference to the compiled template, and then respond to HTTP requests. You
    will need to import the `text/template`, `path/filepath`, and `sync` packages
    in order to build your code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写自己的`struct`类型，该类型负责加载、编译和交付我们的模板。我们将定义一个新的类型，它将接受一个`filename`字符串，一次性编译模板（使用`sync.Once`类型），保留编译后模板的引用，然后响应HTTP请求。为了构建你的代码，你需要导入`text/template`、`path/filepath`和`sync`包。
- en: 'In `main.go`, insert the following code above the `func main()` line:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.go`中，在`func main()`行上方插入以下代码：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Did you know that you could automate the adding and removing of imported packages?
    See [Appendix](part0227_split_000.html#6OFFM1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Appendix Appendix. Good Practices for a Stable Go Environment"), *Good Practices
    for a Stable Go Environment*, on how to do this.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你可以自动化添加和删除导入的包吗？请参阅[附录](part0227_split_000.html#6OFFM1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "附录 附录。稳定Go环境的良好实践")，*稳定Go环境的良好实践*，了解如何做到这一点。
- en: The `templateHandler` type has a single method called `ServeHTTP` whose signature
    looks suspiciously like the method we passed to `http.HandleFunc` earlier. This
    method will load the source file, compile the template and execute it, and write
    the output to the specified `http.ResponseWriter` method. Because the `ServeHTTP`
    method satisfies the `http.Handler` interface, we can actually pass it directly
    to `http.Handle`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`templateHandler`类型有一个名为`ServeHTTP`的单个方法，其签名看起来与之前传递给`http.HandleFunc`的方法非常相似。此方法将加载源文件，编译模板并执行它，然后将输出写入指定的`http.ResponseWriter`方法。因为`ServeHTTP`方法满足`http.Handler`接口，我们实际上可以直接将其传递给`http.Handle`。'
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A quick look at the Go standard library source code, which is located at [http://golang.org/pkg/net/http/#Handler](http://golang.org/pkg/net/http/#Handler),
    will reveal that the interface definition for `http.Handler` specifies that only
    the `ServeHTTP` method need be present in order for a type to be used to serve
    HTTP requests by the `net/http` package.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看位于[http://golang.org/pkg/net/http/#Handler](http://golang.org/pkg/net/http/#Handler)的Go标准库源代码，可以发现`http.Handler`接口定义指定，只有`ServeHTTP`方法存在，类型才能被`net/http`包用来处理HTTP请求。
- en: Doing things once
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一次性完成事情
- en: We only need to compile the template once, and there are a few different ways
    to approach this in Go. The most obvious is to have a `NewTemplateHandler` function
    that creates the type and calls some initialization code to compile the template.
    If we were sure the function would be called by only one goroutine (probably the
    main one during the setup in the `main` function), this would be a perfectly acceptable
    approach. An alternative, which we have employed in the preceding section, is
    to compile the template once inside the `ServeHTTP` method. The `sync.Once` type
    guarantees that the function we pass as an argument will only be executed once,
    regardless of how many goroutines are calling `ServeHTTP`. This is helpful because
    web servers in Go are automatically concurrent and once our chat application takes
    the world by storm, we could very well expect to have many concurrent calls to
    the `ServeHTTP` method.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要编译一次模板，在Go中有几种不同的方法可以做到这一点。最明显的方法是有一个`NewTemplateHandler`函数，它创建类型并调用一些初始化代码来编译模板。如果我们确信该函数只会被一个goroutine调用（可能是在`main`函数中的设置阶段），这将是一个完全可接受的方法。另一种方法，我们在前面的章节中已经使用过，是在`ServeHTTP`方法内部一次性编译模板。`sync.Once`类型保证我们传递给它的函数只执行一次，不管有多少goroutine调用`ServeHTTP`。这很有帮助，因为Go中的Web服务器是自动并发的，一旦我们的聊天应用风靡全球，我们完全可能期望有多个并发调用`ServeHTTP`方法。
- en: Compiling the template inside the `ServeHTTP` method also ensures that our code
    does not waste time doing work before it is definitely needed. This lazy initialization
    approach doesn't save us much in our present case, but in cases where the setup
    tasks are time- and resource-intensive and where the functionality is used less
    frequently, it's easy to see how this approach would come in handy.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ServeHTTP`方法内部编译模板也确保了我们的代码在绝对需要之前不会浪费时间做无用功。这种懒加载初始化方法在我们目前的案例中并没有节省我们太多，但在设置任务耗时且资源密集，以及功能使用频率较低的情况下，很容易看出这种方法的实用性。
- en: Using your own handlers
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自己的处理器
- en: 'To implement our `templateHandler` type, we need to update the `main` body
    function so that it looks like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现我们的`templateHandler`类型，我们需要更新`main`主体函数，使其看起来像这样：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `templateHandler` structure is a valid `http.Handler` type so we can pass
    it directly to the `http.Handle` function and ask it to handle requests that match
    the specified pattern. In the preceding code, we created a new object of the type `templateHandler`,
     specifying the filename as `chat.html` that we then take the address of (using
    the `&` address of the operator) and pass it to the `http.Handle` function. We
    do not store a reference to our newly created `templateHandler` type, but that's
    OK because we don't need to refer to it again.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`templateHandler`结构是一个有效的`http.Handler`类型，因此我们可以直接将其传递给`http.Handle`函数，并要求它处理与指定模式匹配的请求。在前面的代码中，我们创建了一个新的`templateHandler`类型的对象，指定文件名为`chat.html`，然后我们使用（使用`&`取地址运算符）获取其地址，并将其传递给`http.Handle`函数。我们不需要存储新创建的`templateHandler`类型的引用，但这没关系，因为我们不需要再次引用它。'
- en: In your terminal, exit the program by pressing *Ctrl + C* and re-run it, then
    refresh your browser and notice the addition of the (from template) text. Now
    our code is much simpler than an HTML code and free from its ugly blocks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端中，通过按*Ctrl + C*退出程序，然后重新运行它，然后刷新浏览器，注意查看（来自模板）文本的添加。现在我们的代码比HTML代码简单得多，并且摆脱了其丑陋的块状结构。
