- en: Modeling the client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file called `client.go` alongside `main.go` in the `chat` folder
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `socket` will hold a reference to the web socket that
    will allow us to communicate with the client, and the `send` field is a buffered
    channel through which received messages are queued ready to be forwarded to the
    user's browser (via the socket). The `room` field will keep a reference to the
    room that the client is chatting in this is required so that we can forward messages
    to everyone else in the room.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to build this code, you will notice a few errors. You must ensure
    that you have called `go get` to retrieve the `websocket` package, which is as
    easy as opening a terminal and typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Building the code again will yield another error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that we have referred to a `room` type without defining it anywhere.
    To make the compiler happy, create a file called `room.go` and insert the following
    placeholder code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will improve this definition later once we know a little more about what
    our room needs to do, but for now, this will allow us to proceed. Later, the `forward`
    channel is what we will use to send the incoming messages to all other clients.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can think of channels as an in-memory thread-safe message queue where senders
    pass data and receivers read data in a non-blocking, thread-safe way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for a client to do any work, we must define some methods that will
    do the actual reading and writing to and from the web socket. Adding the following
    code to `client.go` outside (underneath) the `client` struct will add two methods
    called `read` and `write` to the `client` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `read` method allows our client to read from the socket via the `ReadMessage`
    method, continually sending any received messages to the `forward` channel on
    the `room` type. If it encounters an error (such as `'the socket has died'`),
    the loop will break and the socket will be closed. Similarly, the `write` method
    continually accepts messages from the `send` channel writing everything out of
    the socket via the `WriteMessage` method. If writing to the socket fails, the `for`
    loop is broken and the socket is closed. Build the package again to ensure everything
    compiles.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding code, we introduced the `defer` keyword, which is worth exploring
    a little. We are asking Go to run `c.socket.Close()` when the function exits.
    It's extremely useful for when you need to do some tidying up in a function (such
    as closing a file or, as in our case, a socket) but aren't sure where the function
    will exit. As our code grows, if this function has multiple `return` statements,
    we won't need to add any more calls to close the socket, because this single `defer`
    statement will catch them all.
  prefs: []
  type: TYPE_NORMAL
- en: Some people complain about the performance of using the `defer` keyword, since
    it doesn't perform as well as typing the `close` statement before every exit point
    in the function. You must weigh up the runtime performance cost against the code
    maintenance cost and potential bugs that may get introduced if you decide not
    to use defer. As a general rule of thumb, writing clean and clear code wins; after
    all, we can always come back and optimize any bits of code we feel is slowing
    our product down if we are lucky enough to have such success.
  prefs: []
  type: TYPE_NORMAL
