- en: Modeling the client
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端建模
- en: 'Create a new file called `client.go` alongside `main.go` in the `chat` folder
    and add the following code:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chat`文件夹中与`main.go`并列创建一个名为`client.go`的新文件，并添加以下代码：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, `socket` will hold a reference to the web socket that
    will allow us to communicate with the client, and the `send` field is a buffered
    channel through which received messages are queued ready to be forwarded to the
    user's browser (via the socket). The `room` field will keep a reference to the
    room that the client is chatting in this is required so that we can forward messages
    to everyone else in the room.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`socket`将保存对允许我们与客户端通信的WebSocket的引用，而`send`字段是一个缓冲通道，通过它接收到的消息被排队，准备转发到用户的浏览器（通过socket）。`room`字段将保存客户端正在聊天的房间的引用，这是必要的，以便我们可以将消息转发给房间中的其他所有人。
- en: 'If you try to build this code, you will notice a few errors. You must ensure
    that you have called `go get` to retrieve the `websocket` package, which is as
    easy as opening a terminal and typing the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试构建此代码，你会注意到一些错误。你必须确保你已经调用`go get`来检索`websocket`包，这就像打开一个终端并输入以下内容一样简单：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Building the code again will yield another error:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建代码将产生另一个错误：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The problem is that we have referred to a `room` type without defining it anywhere.
    To make the compiler happy, create a file called `room.go` and insert the following
    placeholder code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于我们在没有定义它的任何地方引用了一个`room`类型。为了让编译器高兴，创建一个名为`room.go`的文件，并插入以下占位符代码：
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will improve this definition later once we know a little more about what
    our room needs to do, but for now, this will allow us to proceed. Later, the `forward`
    channel is what we will use to send the incoming messages to all other clients.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在了解我们的房间需要做什么之后改进这个定义，但现在，这将允许我们继续前进。稍后，`forward`通道是我们将用来将传入的消息发送给所有其他客户端的通道。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can think of channels as an in-memory thread-safe message queue where senders
    pass data and receivers read data in a non-blocking, thread-safe way.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将通道视为一个内存中的线程安全消息队列，发送者通过它传递数据，接收者以非阻塞、线程安全的方式读取数据。
- en: 'In order for a client to do any work, we must define some methods that will
    do the actual reading and writing to and from the web socket. Adding the following
    code to `client.go` outside (underneath) the `client` struct will add two methods
    called `read` and `write` to the `client` type:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让客户端做任何工作，我们必须定义一些方法，这些方法将执行实际的从WebSocket读取和写入操作。将以下代码添加到`client.go`中的`client`结构体外部（在下面）将向`client`类型添加两个名为`read`和`write`的方法：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `read` method allows our client to read from the socket via the `ReadMessage`
    method, continually sending any received messages to the `forward` channel on
    the `room` type. If it encounters an error (such as `'the socket has died'`),
    the loop will break and the socket will be closed. Similarly, the `write` method
    continually accepts messages from the `send` channel writing everything out of
    the socket via the `WriteMessage` method. If writing to the socket fails, the `for`
    loop is broken and the socket is closed. Build the package again to ensure everything
    compiles.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`方法允许我们的客户端通过`ReadMessage`方法从socket读取，不断地将接收到的任何消息发送到`room`类型的`forward`通道。如果遇到错误（例如`''the
    socket has died''`），循环将中断，套接字将被关闭。同样，`write`方法不断地从`send`通道接收消息，通过`WriteMessage`方法将所有内容写入socket。如果写入socket失败，`for`循环将被中断，套接字将被关闭。再次构建包以确保一切都能编译。'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding code, we introduced the `defer` keyword, which is worth exploring
    a little. We are asking Go to run `c.socket.Close()` when the function exits.
    It's extremely useful for when you need to do some tidying up in a function (such
    as closing a file or, as in our case, a socket) but aren't sure where the function
    will exit. As our code grows, if this function has multiple `return` statements,
    we won't need to add any more calls to close the socket, because this single `defer`
    statement will catch them all.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们介绍了`defer`关键字，这值得稍微探索一下。我们要求Go在函数退出时运行`c.socket.Close()`。这在需要在一个函数中做一些清理工作（例如关闭文件或，在我们的例子中，关闭套接字）但不确定函数将在哪里退出时非常有用。随着我们的代码增长，如果这个函数有多个`return`语句，我们就不需要添加任何更多调用来关闭套接字，因为这个单独的`defer`语句将捕获它们所有。
- en: Some people complain about the performance of using the `defer` keyword, since
    it doesn't perform as well as typing the `close` statement before every exit point
    in the function. You must weigh up the runtime performance cost against the code
    maintenance cost and potential bugs that may get introduced if you decide not
    to use defer. As a general rule of thumb, writing clean and clear code wins; after
    all, we can always come back and optimize any bits of code we feel is slowing
    our product down if we are lucky enough to have such success.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人抱怨使用`defer`关键字时的性能，因为它并不像在函数的每个退出点之前输入`close`语句那样表现良好。你必须权衡运行时性能成本与代码维护成本以及可能引入的潜在错误。一般来说，编写清晰和干净的代码是获胜的关键；毕竟，如果我们足够幸运，我们总是可以回来优化那些我们认为会减慢产品速度的任何代码片段。
