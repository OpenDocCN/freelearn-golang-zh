- en: Concurrency programming using idiomatic Go
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用惯用Go语言进行并发编程
- en: Now we get to use an extremely powerful feature of Go's concurrency offerings
    the `select` statement. We can use `select` statements whenever we need to synchronize
    or modify shared memory, or take different actions depending on the various activities
    within our channels.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来使用Go并发提供的非常强大的功能之一——`select`语句。我们可以在需要同步或修改共享内存，或者根据我们通道内的各种活动执行不同操作时使用`select`语句。
- en: 'Beneath the `room` structure, add the following `run` method that contains
    three `select` cases:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在`room`结构体下面，添加以下包含三个`select`情况的`run`方法：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Although this might seem like a lot of code to digest, once we break it down
    a little, we will see that it is fairly simple, although extremely powerful. The
    top `for` loop indicates that this method will run forever, until the program
    is terminated. This might seem like a mistake, but remember, if we run this code
    as a goroutine, it will run in the background, which won't block the rest of our
    application. The preceding code will keep watching the three channels inside our
    room: `join`, `leave`, and `forward`. If a message is received on any of those
    channels, the `select` statement will run the code for that particular case.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能看起来有很多代码需要消化，但一旦我们稍微分解一下，我们会发现它相当简单，尽管非常强大。顶部的`for`循环表明这个方法将永远运行，直到程序终止。这看起来可能像是一个错误，但请记住，如果我们以goroutine的形式运行此代码，它将在后台运行，这不会阻塞我们的应用程序的其他部分。前面的代码将不断监视我们房间内的三个通道：`join`、`leave`和`forward`。如果任何这些通道收到消息，`select`语句将运行特定情况的代码。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: It is important to remember that it will only run one block of case code at
    a time. This is how we are able to synchronize to ensure that our `r.clients`
    map is only ever modified by one thing at a time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，它一次只会运行一个case代码块。这就是我们能够同步以确保我们的`r.clients`映射一次只被一个东西修改的原因。
- en: If we receive a message on the `join` channel, we simply update the `r.clients`
    map to keep a reference of the client that has joined the room. Notice that we
    are setting the value to `true`. We are using the map more like a slice, but do
    not have to worry about shrinking the slice as clients come and go through time
    setting the value to `true` is just a handy, low-memory way of storing the reference.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`join`通道上收到消息，我们只需更新`r.clients`映射以保持对已加入房间的客户端的引用。请注意，我们正在将值设置为`true`。我们更像是使用切片，但不必担心随着客户端的来去而缩小切片；将值设置为`true`只是存储引用的一种方便、低内存的方式。
- en: If we receive a message on the `leave` channel, we simply delete the `client`
    type from the map, and close its `send` channel. If we receive a message on the `forward`
    channel, we iterate over all the clients and add the message to each client's `send`
    channel. Then, the `write` method of our client type will pick it up and send
    it down the socket to the browser.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`leave`通道上收到消息，我们只需从映射中删除`client`类型，并关闭其`send`通道。如果我们收到`forward`通道上的消息，我们将遍历所有客户端并将消息添加到每个客户端的`send`通道。然后，我们的客户端类型的`write`方法将获取它并将其发送到浏览器的套接字。
