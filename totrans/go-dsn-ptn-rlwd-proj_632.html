<html><head></head><body>
<div class="book" title="Modeling a chat room and clients on the server">
<div class="book" title="Turning a room into an HTTP handler"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec0012" class="calibre1"/>Turning a room into an HTTP handler</h2></div></div></div><p class="calibre10">Now we are going to turn our <code class="email">room</code> type into an <code class="email">http.Handler</code> type like we did with the template handler earlier. As you will recall, to do this, we must simply add a method called <code class="email">ServeHTTP</code> with the appropriate signature.</p><p class="calibre10">Add the following code to the bottom of the <code class="email">room.go</code> file:</p><pre class="programlisting">const ( 
  socketBufferSize  = 1024 
  messageBufferSize = 256 
)  
var upgrader = &amp;websocket.Upgrader{ReadBufferSize:  socketBufferSize,
  WriteBufferSize: socketBufferSize}  
func (r *room) ServeHTTP(w http.ResponseWriter, req *http.Request) { 
  socket, err := upgrader.Upgrade(w, req, nil) 
  if err != nil { 
    log.Fatal("ServeHTTP:", err) 
    return 
  } 
  client := &amp;client{ 
    socket: socket, 
    send:   make(chan []byte, messageBufferSize), 
    room:   r, 
  } 
  r.join &lt;- client 
  defer func() { r.leave &lt;- client }() 
  go client.write() 
  client.read() 
} 
</pre><p class="calibre10">The <code class="email">ServeHTTP</code> method means a room can now act as a handler. We will implement it shortly, but first let's have a look at what is going on in this snippet of code.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip15" class="calibre1"/>Tip</h3><p class="calibre10">If you accessed the chat endpoint in a web browser, you would likely crash the program and see an error like <span class="strong"><strong class="calibre2">ServeHTTPwebsocket: version != 13</strong></span>. This is because it is intended to be accessed via a web socket rather than a web browser.</p></div><p class="calibre10">In order to use web sockets, we must upgrade the HTTP connection using the <code class="email">websocket.Upgrader</code> type, which is reusable so we need only create one. Then, when a request comes in via the <code class="email">ServeHTTP</code> method, we get the socket by calling the <code class="email">upgrader.Upgrade</code> method. All being well, we then create our client and pass it into the <code class="email">join</code> channel for the current room. We also defer the leaving operation for when the client is finished, which will ensure everything is tidied up after a user goes away.</p><p class="calibre10">The <code class="email">write</code> method for the client is then called as a goroutine, as indicated by the three characters at the beginning of the line <code class="email">go</code> (the word <code class="email">go</code> followed by a space character). This tells Go to run the method in a different thread or goroutine.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note0016" class="calibre1"/>Note</h3><p class="calibre10">Compare the amount of code needed to achieve multithreading or concurrency in other languages with the three key presses that achieve it in Go, and you will see why it has become a favorite among system developers.</p></div><p class="calibre10">Finally, we call the <code class="email">read</code> method in the main thread, which will block operations (keeping the connection alive) until it's time to close it. Adding constants at the top of the snippet is a good practice for declaring values that would otherwise be hardcoded throughout the project. As these grow in number, you might consider putting them in a file of their own, or at least at the top of their respective files so they remain easy to read and modify.</p></div></div></body></html>