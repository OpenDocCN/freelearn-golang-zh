- en: Turning a room into an HTTP handler
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将房间转换为HTTP处理器
- en: Now we are going to turn our `room` type into an `http.Handler` type like we
    did with the template handler earlier. As you will recall, to do this, we must
    simply add a method called `ServeHTTP` with the appropriate signature.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将我们的`room`类型转换为与之前模板处理器相同的`http.Handler`类型。如您所回忆的那样，要做到这一点，我们只需添加一个名为`ServeHTTP`的方法，并使用适当的签名。
- en: 'Add the following code to the bottom of the `room.go` file:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`room.go`文件的底部：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In order to use web sockets, we must upgrade the HTTP connection using the `websocket.Upgrader`
    type, which is reusable so we need only create one. Then, when a request comes
    in via the `ServeHTTP` method, we get the socket by calling the `upgrader.Upgrade`
    method. All being well, we then create our client and pass it into the `join`
    channel for the current room. We also defer the leaving operation for when the
    client is finished, which will ensure everything is tidied up after a user goes
    away.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用WebSocket，我们必须使用`websocket.Upgrader`类型升级HTTP连接，它是可重用的，因此我们只需要创建一个。然后，当通过`ServeHTTP`方法收到请求时，我们通过调用`upgrader.Upgrade`方法来获取套接字。如果一切顺利，我们随后创建我们的客户端并将其传递给当前房间的`join`通道。我们还推迟了离开操作，以便在客户端完成后执行，这将确保在用户离开后一切都被整理干净。
- en: The `write` method for the client is then called as a goroutine, as indicated
    by the three characters at the beginning of the line `go` (the word `go` followed
    by a space character). This tells Go to run the method in a different thread or
    goroutine.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的`write`方法随后作为一个goroutine被调用，这从行首的三个字符`go`（单词`go`后跟一个空格字符）可以看出。这告诉Go在另一个线程或goroutine中运行该方法。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Compare the amount of code needed to achieve multithreading or concurrency in
    other languages with the three key presses that achieve it in Go, and you will
    see why it has become a favorite among system developers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将其他语言中实现多线程或并发所需的代码量与Go语言中通过三个按键就能实现的功能进行比较，你就会明白为什么它成为了系统开发者的最爱。
- en: Finally, we call the `read` method in the main thread, which will block operations
    (keeping the connection alive) until it's time to close it. Adding constants at
    the top of the snippet is a good practice for declaring values that would otherwise
    be hardcoded throughout the project. As these grow in number, you might consider
    putting them in a file of their own, or at least at the top of their respective
    files so they remain easy to read and modify.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在主线程中调用`read`方法，这将阻塞操作（保持连接活跃）直到关闭它的时候。在代码片段的顶部添加常量是一种良好的实践，用于声明那些在其他地方硬编码的值。随着这些值的增加，您可能考虑将它们放入一个单独的文件中，或者至少在各自的文件顶部，以便它们易于阅读和修改。
