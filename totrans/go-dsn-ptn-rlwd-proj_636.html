<html><head></head><body>
<div class="book" title="Building an HTML and JavaScript chat client" id="4JQ761-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Getting more out of templates"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec0015" class="calibre1"/>Getting more out of templates</h2></div></div></div><p class="calibre10">Currently, we are using templates to deliver static HTML, which is nice because it gives us a clean and simple way to separate the client code from the server code. However, templates are actually much more powerful, and we are going to tweak our application to make some more realistic use of them.</p><p class="calibre10">The host address of our application (<code class="email">:8080</code>) is hardcoded at two places at the moment. The first instance is in <code class="email">main.go</code> where we start the web server:</p><pre class="programlisting">if err := http.ListenAndServe(":8080", nil); err != nil { 
  log.Fatal("ListenAndServe:", err) 
} 
</pre><p class="calibre10">The second time it is hardcoded in the JavaScript when we open the socket:</p><pre class="programlisting">socket = new WebSocket("ws://localhost:8080/room"); 
</pre><p class="calibre10">Our chat application is pretty stubborn if it insists on only running locally on port <code class="email">8080</code>, so we are going to use command-line flags to make it configurable and then use the injection capabilities of templates to make sure our JavaScript knows the right host.</p><p class="calibre10">Update your <code class="email">main</code> function in <code class="email">main.go</code>:</p><pre class="programlisting">func main() {   
  var addr = flag.String("addr", ":8080", "The addr of the  application.") 
  flag.Parse() // parse the flags 
  r := newRoom() 
  http.Handle("/", &amp;templateHandler{filename: "chat.html"}) 
  http.Handle("/room", r) 
  // get the room going 
  go r.run() 
  // start the web server 
  log.Println("Starting web server on", *addr) 
  if err := http.ListenAndServe(*addr, nil); err != nil { 
    log.Fatal("ListenAndServe:", err) 
  } 
} 
</pre><p class="calibre10">You will need to import the <code class="email">flag</code> package in order for this code to build. The definition for the <code class="email">addr</code> variable sets up our flag as a string that defaults to <code class="email">:8080</code> (with a short description of what the value is intended for). We must call <code class="email">flag.Parse()</code> that parses the arguments and extracts the appropriate information. Then, we can reference the value of the host flag by using <code class="email">*addr</code>.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note0017" class="calibre1"/>Note</h3><p class="calibre10">The call to <code class="email">flag.String</code> returns a type of <code class="email">*string</code>, which is to say it returns the address of a string variable where the value of the flag is stored. To get the value itself (and not the address of the value), we must use the pointer indirection operator, <code class="email">*</code>.</p></div><p class="calibre10">We also added a <code class="email">log.Println</code> call to output the address in the terminal so we can be sure that our changes have taken effect.</p><p class="calibre10">We are going to modify the <code class="email">templateHandler</code> type we wrote so that it passes the details of the request as data into the template's <code class="email">Execute</code> method. In <code class="email">main.go</code>, update the <code class="email">ServeHTTP</code> function to pass the request <code class="email">r</code> as the <code class="email">data</code> argument to the <code class="email">Execute</code> method:</p><pre class="programlisting">func (t *templateHandler) ServeHTTP(w http.ResponseWriter, r  *http.Request) { 
  t.once.Do(func() { 
    t.templ =  template.Must(template.ParseFiles(filepath.Join("templates",
      t.filename))) 
  }) 
  t.templ.Execute(w, r) 
} 
</pre><p class="calibre10">This tells the template to render itself using data that can be extracted from <code class="email">http.Request</code>, which happens to include the host address that we need.</p><p class="calibre10">To use the <code class="email">Host</code> value of <code class="email">http.Request</code>, we can then make use of the special template syntax that allows us to inject data. Update the line where we create our socket in the <code class="email">chat.html</code> file:</p><pre class="programlisting">socket = new WebSocket("ws://{{.Host}}/room"); 
</pre><p class="calibre10">The double curly braces represent an annotation and the way we tell our template source to inject data. The <code class="email">{{.Host}}</code> is essentially equivalent of telling it to replace the annotation with the value from <code class="email">request.Host</code> (since we passed the request <code class="email">r</code> object in as data).</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip18" class="calibre1"/>Tip</h3><p class="calibre10">We have only scratched the surface of the power of the templates built into Go's standard library. The <code class="email">text/template</code> package documentation is a great place to learn more about what you can achieve. You can find more about it at <a class="calibre1" href="http://golang.org/pkg/text/template">http://golang.org/pkg/text/template</a>.</p></div><p class="calibre10">Rebuild and run the chat program again, but this time notice that the chatting operations no longer produce an error, whichever host we specify:</p><pre class="programlisting">go build -o chat 
./chat -addr=":3000" 
</pre><p class="calibre10">View the source of the page in the browser and notice that <code class="email">{{.Host}}</code> has been replaced with the actual host of the application. Valid hosts aren't just port numbers; you can also specify the IP addresses or other hostnames provided they are allowed in your environment, for example, <code class="email">-addr="192.168.0.1:3000"</code>.</p></div></div></body></html>