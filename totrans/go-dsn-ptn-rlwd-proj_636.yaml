- en: Getting more out of templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, we are using templates to deliver static HTML, which is nice because
    it gives us a clean and simple way to separate the client code from the server
    code. However, templates are actually much more powerful, and we are going to
    tweak our application to make some more realistic use of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The host address of our application (`:8080`) is hardcoded at two places at
    the moment. The first instance is in `main.go` where we start the web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The second time it is hardcoded in the JavaScript when we open the socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our chat application is pretty stubborn if it insists on only running locally
    on port `8080`, so we are going to use command-line flags to make it configurable
    and then use the injection capabilities of templates to make sure our JavaScript
    knows the right host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update your `main` function in `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You will need to import the `flag` package in order for this code to build.
    The definition for the `addr` variable sets up our flag as a string that defaults
    to `:8080` (with a short description of what the value is intended for). We must
    call `flag.Parse()` that parses the arguments and extracts the appropriate information.
    Then, we can reference the value of the host flag by using `*addr`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The call to `flag.String` returns a type of `*string`, which is to say it returns
    the address of a string variable where the value of the flag is stored. To get
    the value itself (and not the address of the value), we must use the pointer indirection
    operator, `*`.
  prefs: []
  type: TYPE_NORMAL
- en: We also added a `log.Println` call to output the address in the terminal so
    we can be sure that our changes have taken effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to modify the `templateHandler` type we wrote so that it passes
    the details of the request as data into the template''s `Execute` method. In `main.go`,
    update the `ServeHTTP` function to pass the request `r` as the `data` argument
    to the `Execute` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This tells the template to render itself using data that can be extracted from `http.Request`,
    which happens to include the host address that we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `Host` value of `http.Request`, we can then make use of the special
    template syntax that allows us to inject data. Update the line where we create
    our socket in the `chat.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The double curly braces represent an annotation and the way we tell our template
    source to inject data. The `{{.Host}}` is essentially equivalent of telling it
    to replace the annotation with the value from `request.Host` (since we passed
    the request `r` object in as data).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have only scratched the surface of the power of the templates built into
    Go's standard library. The `text/template` package documentation is a great place
    to learn more about what you can achieve. You can find more about it at [http://golang.org/pkg/text/template](http://golang.org/pkg/text/template).
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebuild and run the chat program again, but this time notice that the chatting
    operations no longer produce an error, whichever host we specify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: View the source of the page in the browser and notice that `{{.Host}}` has been
    replaced with the actual host of the application. Valid hosts aren't just port
    numbers; you can also specify the IP addresses or other hostnames provided they
    are allowed in your environment, for example, `-addr="192.168.0.1:3000"`.
  prefs: []
  type: TYPE_NORMAL
