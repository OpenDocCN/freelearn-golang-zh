- en: Getting more out of templates
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 充分利用模板
- en: Currently, we are using templates to deliver static HTML, which is nice because
    it gives us a clean and simple way to separate the client code from the server
    code. However, templates are actually much more powerful, and we are going to
    tweak our application to make some more realistic use of them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们正在使用模板来提供静态HTML，这很好，因为它为我们提供了一个干净简单的方法来将客户端代码与服务器端代码分离。然而，模板实际上要强大得多，我们打算调整我们的应用程序，以便更现实地使用它们。
- en: 'The host address of our application (`:8080`) is hardcoded at two places at
    the moment. The first instance is in `main.go` where we start the web server:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序的宿主地址（`:8080`）在两个地方硬编码。第一个实例是在`main.go`中，我们启动了Web服务器：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second time it is hardcoded in the JavaScript when we open the socket:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次硬编码在打开套接字时的JavaScript中：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our chat application is pretty stubborn if it insists on only running locally
    on port `8080`, so we are going to use command-line flags to make it configurable
    and then use the injection capabilities of templates to make sure our JavaScript
    knows the right host.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的聊天应用程序坚持只在本地端口`8080`上运行，那么它就相当固执，因此我们将使用命令行标志来使其可配置，然后使用模板的注入功能来确保我们的JavaScript知道正确的宿主。
- en: 'Update your `main` function in `main.go`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`main.go`中的`main`函数：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will need to import the `flag` package in order for this code to build.
    The definition for the `addr` variable sets up our flag as a string that defaults
    to `:8080` (with a short description of what the value is intended for). We must
    call `flag.Parse()` that parses the arguments and extracts the appropriate information.
    Then, we can reference the value of the host flag by using `*addr`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此代码构建，您需要导入`flag`包。`addr`变量的定义设置我们的标志为一个默认值为`:8080`的字符串（带有对值用途的简短描述）。我们必须调用`flag.Parse()`来解析参数并提取适当的信息。然后，我们可以通过使用`*addr`来引用宿主标志的值。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The call to `flag.String` returns a type of `*string`, which is to say it returns
    the address of a string variable where the value of the flag is stored. To get
    the value itself (and not the address of the value), we must use the pointer indirection
    operator, `*`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`flag.String`的调用返回一个类型为`*string`，这意味着它返回一个字符串变量的地址，其中存储了标志的值。为了获取值本身（而不是值的地址），我们必须使用指针间接运算符，`*`。'
- en: We also added a `log.Println` call to output the address in the terminal so
    we can be sure that our changes have taken effect.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个`log.Println`调用，以便在终端输出地址，这样我们就可以确保我们的更改已经生效。
- en: 'We are going to modify the `templateHandler` type we wrote so that it passes
    the details of the request as data into the template''s `Execute` method. In `main.go`,
    update the `ServeHTTP` function to pass the request `r` as the `data` argument
    to the `Execute` method:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改我们编写的`templateHandler`类型，使其将请求的详细信息作为数据传递到模板的`Execute`方法。在`main.go`中，更新`ServeHTTP`函数，将请求`r`作为`data`参数传递给`Execute`方法：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This tells the template to render itself using data that can be extracted from `http.Request`,
    which happens to include the host address that we need.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉模板使用可以从`http.Request`中提取的数据来渲染自身，碰巧这包括我们需要的宿主地址。
- en: 'To use the `Host` value of `http.Request`, we can then make use of the special
    template syntax that allows us to inject data. Update the line where we create
    our socket in the `chat.html` file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`http.Request`的`Host`值，我们可以利用特殊的模板语法，这允许我们注入数据。更新在`chat.html`文件中创建我们的套接字的行：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The double curly braces represent an annotation and the way we tell our template
    source to inject data. The `{{.Host}}` is essentially equivalent of telling it
    to replace the annotation with the value from `request.Host` (since we passed
    the request `r` object in as data).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 双大括号表示注释，以及我们告诉模板源注入数据的方式。`{{.Host}}`基本上等同于告诉它用`request.Host`的值替换注释（因为我们作为数据传递了请求`r`对象）。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We have only scratched the surface of the power of the templates built into
    Go's standard library. The `text/template` package documentation is a great place
    to learn more about what you can achieve. You can find more about it at [http://golang.org/pkg/text/template](http://golang.org/pkg/text/template).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是触及了Go标准库中内置的模板的强大功能的一角。`text/template`包的文档是一个学习你可以实现什么的好地方。你可以在[http://golang.org/pkg/text/template](http://golang.org/pkg/text/template)了解更多。
- en: 'Rebuild and run the chat program again, but this time notice that the chatting
    operations no longer produce an error, whichever host we specify:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建并再次运行聊天程序，但这次请注意，聊天操作不再产生错误，无论我们指定哪个宿主：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: View the source of the page in the browser and notice that `{{.Host}}` has been
    replaced with the actual host of the application. Valid hosts aren't just port
    numbers; you can also specify the IP addresses or other hostnames provided they
    are allowed in your environment, for example, `-addr="192.168.0.1:3000"`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中查看页面源代码，你会注意到`{{.Host}}`已被应用程序的实际主机名替换。有效的宿主不仅限于端口号；你也可以指定环境允许的IP地址或其他主机名，例如，`-addr="192.168.0.1:3000"`。
