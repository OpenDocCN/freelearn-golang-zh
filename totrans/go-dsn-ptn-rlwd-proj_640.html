<html><head></head><body>
<div class="book" title="Tracing code to get a look under the hood">
<div class="book" title="Unit tests"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec0018" class="calibre1"/>Unit tests</h2></div></div></div><p class="calibre10">We promised ourselves that we would follow test-driven practices, but interfaces are simply definitions that do not provide any implementation and so cannot be directly tested. But we are about to write a real implementation of a <code class="email">Tracer</code> method, and we will indeed write the tests first.</p><p class="calibre10">Create a new file called <code class="email">tracer_test.go</code> in the <code class="email">trace</code> folder and insert the following scaffold code:</p><pre class="programlisting">package trace 
import ( 
  "testing" 
)  
func TestNew(t *testing.T) { 
  t.Error("We haven't written our test yet") 
} 
</pre><p class="calibre10">Testing was built into the Go tool chain from the very beginning, making writing automatable tests a first-class citizen. The test code lives alongside the production code in files suffixed with <code class="email">_test.go</code>. The Go tools will treat any function that starts with <code class="email">Test</code> (taking a single <code class="email">*testing.T</code> argument) as a unit test, and it will be executed when we run our tests. To run them for this package, navigate to the <code class="email">trace</code> folder in a terminal and do the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test</strong></span>
</pre><p class="calibre10">You will see that our tests fail because of our call to <code class="email">t.Error</code> in the body of our <code class="email">TestNew</code> function:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">--- FAIL: TestNew (0.00 seconds)</strong></span>
<span class="strong"><strong class="calibre2">    tracer_test.go:8: We haven't written our test yet</strong></span>
<span class="strong"><strong class="calibre2">FAIL</strong></span>
<span class="strong"><strong class="calibre2">exit status 1</strong></span>
<span class="strong"><strong class="calibre2">FAIL  trace 0.011s</strong></span>
</pre><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip21" class="calibre1"/>Tip</h3><p class="calibre10">Clearing the terminal before each test run is a great way to make sure you aren't confusing previous runs with the most recent one. On Windows, you can use the <code class="email">cls</code> command; on Unix machines, the <code class="email">clear</code> command does the same thing.</p></div><p class="calibre10">Obviously, we haven't properly written our test and we don't expect it to pass yet, so let's update the <code class="email">TestNew</code> function:</p><pre class="programlisting">func TestNew(t *testing.T) { 
  var buf bytes.Buffer 
  tracer := New(&amp;buf) 
  if tracer == nil { 
    t.Error("Return from New should not be nil") 
  } else { 
    tracer.Trace("Hello trace package.") 
    if buf.String() != "Hello trace package.\n" { 
      t.Errorf("Trace should not write '%s'.", buf.String()) 
    } 
  } 
 
} 
</pre><p class="calibre10">Most packages throughout the book are available from the Go standard library, so you can add an <code class="email">import</code> statement for the appropriate package in order to access the package. Others are external, and that's when you need to use <code class="email">go get</code> to download them before they can be imported. For this case, you'll need to add <code class="email">import "bytes"</code> to the top of the file.</p><p class="calibre10">We have started designing our API by becoming the first user of it. We want to be able to capture the output of our tracer in a <code class="email">bytes.Buffer</code> variable so that we can then ensure that the string in the buffer matches the expected value. If it does not, a call to <code class="email">t.Errorf</code> will fail the test. Before that, we check to make sure the return from a made-up <code class="email">New</code> function is not <code class="email">nil</code>; again, if it is, the test will fail because of the call to <code class="email">t.Error</code>.</p><div class="book" title="Red-green testing"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec002" class="calibre1"/>Red-green testing</h3></div></div></div><p class="calibre10">Running <code class="email">go test</code> now actually produces an error; it complains that there is no <code class="email">New</code> function. We haven't made a mistake here; we are following a practice known as red-green testing. Red-green testing proposes that we first write a unit test, see it fail (or produce an error), write the minimum amount of code possible to make that test pass, and rinse and repeat it again. The key point here being that we want to make sure the code we add is actually doing something as well as ensuring that the test code we write is testing something meaningful.</p><p class="calibre10">Consider a meaningless test for a minute:</p><pre class="programlisting">if true == true { 
  t.Error("True should be true") 
} 
</pre><p class="calibre10">It is logically impossible for <code class="email">true</code> to not be  true (if <code class="email">true</code> ever equals <code class="email">false</code>, it's time to get a new computer), and so our test is pointless. If a test or claim cannot fail, there is no value whatsoever to be found in it.</p><p class="calibre10">Replacing <code class="email">true</code> with a variable that you expect to be set to <code class="email">true</code> under certain conditions would mean that such a test can indeed fail (like when the code being tested is misbehaving) at this point, you have a meaningful test that is worth contributing to the code base.</p><p class="calibre10">You can treat the output of <code class="email">go test</code> like a to-do list, solving only one problem at a time. Right now, the complaint about the missing <code class="email">New</code> function is all we will address. In the <code class="email">trace.go</code> file, let's add the minimum amount of code possible to progress with things; add the following snippet underneath the interface type definition:</p><pre class="programlisting">func New() {} 
</pre><p class="calibre10">Running <code class="email">go test</code> now shows us that things have indeed progressed, albeit not very far. We now have two errors:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">./tracer_test.go:11: too many arguments in call to New</strong></span>
<span class="strong"><strong class="calibre2">./tracer_test.go:11: New(&amp;buf) used as value</strong></span>
</pre><p class="calibre10">The first error tells us that we are passing arguments to our <code class="email">New</code> function, but the <code class="email">New</code> function doesn't accept any. The second error says that we are using the return of the <code class="email">New</code> function as a value, but that the <code class="email">New</code> function doesn't return anything. You might have seen this coming, and indeed as you gain more experience writing test-driven code, you will most likely jump over such trivial details. However, to properly illustrate the method, we are going to be pedantic for a while. Let's address the first error by updating our <code class="email">New</code> function to take in the expected argument:</p><pre class="programlisting">func New(w io.Writer) {} 
</pre><p class="calibre10">We are taking an argument that satisfies the <code class="email">io.Writer</code> interface, which means that the specified object must have a suitable <code class="email">Write</code> method.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note0022" class="calibre1"/>Note</h3><p class="calibre10">Using existing interfaces, especially ones found in the Go standard library, is an extremely powerful and often necessary way to ensure that your code is as flexible and elegant as possible.</p></div><p class="calibre10">Accepting <code class="email">io.Writer</code> means that the user can decide where the tracing output will be written. This output could be the standard output, a file, network socket, <code class="email">bytes.Buffer</code> as in our test case, or even some custom-made object, provided it can act like an <code class="email">io.Writer</code> interface.  </p><p class="calibre10">Running <code class="email">go test</code> again shows us that we have resolved the first error and we only need add a return type in order to progress past our second error:</p><pre class="programlisting">func New(w io.Writer) Tracer {} 
</pre><p class="calibre10">We are stating that our <code class="email">New</code> function will return a <code class="email">Tracer</code>, but we do not return anything, which <code class="email">go test</code> happily complains about:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">./tracer.go:13: missing return at end of function</strong></span>
</pre><p class="calibre10">Fixing this is easy; we can just return <code class="email">nil</code> from the <code class="email">New</code> function:</p><pre class="programlisting">func New(w io.Writer) Tracer { 
  return nil 
} 
</pre><p class="calibre10">Of course, our test code has asserted that the return should not be <code class="email">nil</code>, so <code class="email">go test</code> now gives us a failure message:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">tracer_test.go:14: Return from New should not be nil</strong></span>
</pre><p class="calibre10">You can see how this hyper-strict adherence to the red-green principle can get a little tedious, but it is vital that we do not jump too far ahead. If we were to write a lot of implementation code in one go, we will very likely have code that is not covered by a unit test.</p><p class="calibre10">The ever-thoughtful core team has even solved this problem for us by providing code coverage statistics. The following command provides code statistics:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -cover</strong></span>
</pre><p class="calibre10">Provided that all tests pass, adding the <code class="email">-cover</code> flag will tell us how much of our code was touched during the execution of the tests. Obviously, the closer we get to 100 percent the better.</p></div></div></div></body></html>