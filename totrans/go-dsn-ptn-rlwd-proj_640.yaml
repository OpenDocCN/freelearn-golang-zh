- en: Unit tests
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: We promised ourselves that we would follow test-driven practices, but interfaces
    are simply definitions that do not provide any implementation and so cannot be
    directly tested. But we are about to write a real implementation of a `Tracer`
    method, and we will indeed write the tests first.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们承诺自己将遵循测试驱动实践，但接口仅仅是定义，并不提供任何实现，因此不能直接进行测试。但我们即将编写一个真正的`Tracer`方法的实现，并且我们确实会先编写测试。
- en: 'Create a new file called `tracer_test.go` in the `trace` folder and insert
    the following scaffold code:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在`trace`文件夹中创建一个名为`tracer_test.go`的新文件，并插入以下脚手架代码：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Testing was built into the Go tool chain from the very beginning, making writing
    automatable tests a first-class citizen. The test code lives alongside the production
    code in files suffixed with `_test.go`. The Go tools will treat any function that
    starts with `Test` (taking a single `*testing.T` argument) as a unit test, and
    it will be executed when we run our tests. To run them for this package, navigate
    to the `trace` folder in a terminal and do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 测试从一开始就被构建到Go工具链中，使得编写可自动化的测试成为一等公民。测试代码与生产代码一起生活在以`_test.go`结尾的文件中。Go工具将任何以`Test`开头（接受单个`*testing.T`参数）的函数视为单元测试，并且当运行我们的测试时将执行它。要为此包运行它们，在终端中导航到`trace`文件夹，并执行以下操作：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will see that our tests fail because of our call to `t.Error` in the body
    of our `TestNew` function:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现我们的测试失败是因为我们在`TestNew`函数体中调用了`t.Error`：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Clearing the terminal before each test run is a great way to make sure you aren't
    confusing previous runs with the most recent one. On Windows, you can use the `cls`
    command; on Unix machines, the `clear` command does the same thing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次测试运行之前清除终端是一个很好的方法，以确保你不会将之前的运行与最近的运行混淆。在Windows上，你可以使用`cls`命令；在Unix机器上，`clear`命令做同样的事情。
- en: 'Obviously, we haven''t properly written our test and we don''t expect it to
    pass yet, so let''s update the `TestNew` function:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们没有正确编写我们的测试，并且我们并不期望它通过，所以让我们更新`TestNew`函数：
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Most packages throughout the book are available from the Go standard library,
    so you can add an `import` statement for the appropriate package in order to access
    the package. Others are external, and that's when you need to use `go get` to
    download them before they can be imported. For this case, you'll need to add `import
    "bytes"` to the top of the file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 书中大部分包都来自Go标准库，所以你可以添加适当的包的`import`语句来访问该包。其他的是外部的，这时你需要使用`go get`来下载它们，然后再导入。对于这种情况，你需要在文件顶部添加`import
    "bytes"`。
- en: We have started designing our API by becoming the first user of it. We want
    to be able to capture the output of our tracer in a `bytes.Buffer` variable so
    that we can then ensure that the string in the buffer matches the expected value.
    If it does not, a call to `t.Errorf` will fail the test. Before that, we check
    to make sure the return from a made-up `New` function is not `nil`; again, if
    it is, the test will fail because of the call to `t.Error`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过成为API的第一个用户开始设计我们的API。我们希望能够在`bytes.Buffer`变量中捕获我们的tracer的输出，这样我们就可以确保缓冲区中的字符串与预期值匹配。如果不匹配，对`t.Errorf`的调用将使测试失败。在此之前，我们检查确保从虚构的`New`函数返回的不是`nil`；如果是，测试将因为对`t.Error`的调用而失败。
- en: Red-green testing
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 红绿测试
- en: Running `go test` now actually produces an error; it complains that there is
    no `New` function. We haven't made a mistake here; we are following a practice
    known as red-green testing. Red-green testing proposes that we first write a unit
    test, see it fail (or produce an error), write the minimum amount of code possible
    to make that test pass, and rinse and repeat it again. The key point here being
    that we want to make sure the code we add is actually doing something as well
    as ensuring that the test code we write is testing something meaningful.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`go test`实际上会产生一个错误；它抱怨没有`New`函数。这里我们并没有犯错误；我们正在遵循一种被称为红绿测试的实践。红绿测试建议我们首先编写单元测试，看到它失败（或产生错误），编写尽可能少的代码来使该测试通过，然后重复这个过程。这里的关键点是，我们想要确保我们添加的代码实际上在做一些事情，同时确保我们编写的测试代码在测试一些有意义的内容。
- en: 'Consider a meaningless test for a minute:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下一个无意义的测试一分钟：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is logically impossible for `true` to not be  true (if `true` ever equals `false`,
    it's time to get a new computer), and so our test is pointless. If a test or claim
    cannot fail, there is no value whatsoever to be found in it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑上，`true`不可能不是`true`（如果`true`曾经等于`false`，那么是时候换一台新电脑了），因此我们的测试是毫无意义的。如果一个测试或声明无法失败，那么在其中找不到任何价值。
- en: Replacing `true` with a variable that you expect to be set to `true` under certain
    conditions would mean that such a test can indeed fail (like when the code being
    tested is misbehaving) at this point, you have a meaningful test that is worth
    contributing to the code base.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将`true`替换为在特定条件下预期将被设置为`true`的变量，这意味着这样的测试确实可以在这一点失败（比如当被测试的代码行为不当时），现在你有一个有意义的测试，值得贡献到代码库中。
- en: 'You can treat the output of `go test` like a to-do list, solving only one problem
    at a time. Right now, the complaint about the missing `New` function is all we
    will address. In the `trace.go` file, let''s add the minimum amount of code possible
    to progress with things; add the following snippet underneath the interface type
    definition:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`go test`的输出视为待办事项列表，一次解决一个问题。现在，关于缺少`New`函数的抱怨是我们将解决的所有问题。在`trace.go`文件中，让我们添加尽可能少的代码来推进事情；在接口类型定义下方添加以下片段：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running `go test` now shows us that things have indeed progressed, albeit not
    very far. We now have two errors:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次运行`go test`显示事情确实有所进展，尽管进展不大。我们现在有两个错误：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first error tells us that we are passing arguments to our `New` function,
    but the `New` function doesn''t accept any. The second error says that we are
    using the return of the `New` function as a value, but that the `New` function
    doesn''t return anything. You might have seen this coming, and indeed as you gain
    more experience writing test-driven code, you will most likely jump over such
    trivial details. However, to properly illustrate the method, we are going to be
    pedantic for a while. Let''s address the first error by updating our `New` function
    to take in the expected argument:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个错误告诉我们我们在向`New`函数传递参数，但`New`函数不接受任何参数。第二个错误说我们在使用`New`函数的返回值作为值，但`New`函数没有返回任何内容。你可能已经预料到了这一点，而且随着你编写测试驱动代码经验的增加，你很可能会跳过这样的琐事。然而，为了正确说明这种方法，我们将暂时变得一丝不苟。让我们通过更新`New`函数以接受预期的参数来解决第一个错误：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are taking an argument that satisfies the `io.Writer` interface, which means
    that the specified object must have a suitable `Write` method.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在接受一个满足`io.Writer`接口的参数，这意味着指定的对象必须有一个合适的`Write`方法。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using existing interfaces, especially ones found in the Go standard library,
    is an extremely powerful and often necessary way to ensure that your code is as
    flexible and elegant as possible.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现有的接口，特别是那些在Go标准库中找到的接口，是确保你的代码尽可能灵活和优雅的极其强大且通常必要的方法。
- en: Accepting `io.Writer` means that the user can decide where the tracing output
    will be written. This output could be the standard output, a file, network socket,
    `bytes.Buffer` as in our test case, or even some custom-made object, provided
    it can act like an `io.Writer` interface.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接受`io.Writer`意味着用户可以决定跟踪输出将被写入的位置。这个输出可以是标准输出、一个文件、网络套接字、就像我们测试案例中的`bytes.Buffer`，甚至是一些自定义对象，只要它能够像`io.Writer`接口一样操作。
- en: 'Running `go test` again shows us that we have resolved the first error and
    we only need add a return type in order to progress past our second error:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`go test`显示我们已经解决了第一个错误，我们只需要添加一个返回类型就可以解决第二个错误：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We are stating that our `New` function will return a `Tracer`, but we do not
    return anything, which `go test` happily complains about:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明我们的`New`函数将返回一个`Tracer`，但我们没有返回任何内容，`go test`对此表示不满：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Fixing this is easy; we can just return `nil` from the `New` function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这个问题很容易；我们只需从`New`函数返回`nil`：
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Of course, our test code has asserted that the return should not be `nil`,
    so `go test` now gives us a failure message:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的测试代码已经断言返回值不应该为`nil`，所以现在`go test`给出了一个失败信息：
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can see how this hyper-strict adherence to the red-green principle can get
    a little tedious, but it is vital that we do not jump too far ahead. If we were
    to write a lot of implementation code in one go, we will very likely have code
    that is not covered by a unit test.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这种对红绿原则的过度严格遵循可能会变得有点繁琐，但我们必须确保不要走得太远。如果我们一次性写很多实现代码，我们很可能会有一些没有被单元测试覆盖的代码。
- en: 'The ever-thoughtful core team has even solved this problem for us by providing
    code coverage statistics. The following command provides code statistics:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 总是深思熟虑的核心团队甚至为我们解决了这个问题，通过提供代码覆盖率统计。以下命令提供了代码统计：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Provided that all tests pass, adding the `-cover` flag will tell us how much
    of our code was touched during the execution of the tests. Obviously, the closer
    we get to 100 percent the better.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有测试都通过，添加`-cover`标志将告诉我们测试执行期间我们的代码被触动了多少。显然，我们越接近100%，效果就越好。
