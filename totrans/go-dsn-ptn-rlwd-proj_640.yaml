- en: Unit tests
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We promised ourselves that we would follow test-driven practices, but interfaces
    are simply definitions that do not provide any implementation and so cannot be
    directly tested. But we are about to write a real implementation of a `Tracer`
    method, and we will indeed write the tests first.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `tracer_test.go` in the `trace` folder and insert
    the following scaffold code:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Testing was built into the Go tool chain from the very beginning, making writing
    automatable tests a first-class citizen. The test code lives alongside the production
    code in files suffixed with `_test.go`. The Go tools will treat any function that
    starts with `Test` (taking a single `*testing.T` argument) as a unit test, and
    it will be executed when we run our tests. To run them for this package, navigate
    to the `trace` folder in a terminal and do the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You will see that our tests fail because of our call to `t.Error` in the body
    of our `TestNew` function:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Clearing the terminal before each test run is a great way to make sure you aren't
    confusing previous runs with the most recent one. On Windows, you can use the `cls`
    command; on Unix machines, the `clear` command does the same thing.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, we haven''t properly written our test and we don''t expect it to
    pass yet, so let''s update the `TestNew` function:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Most packages throughout the book are available from the Go standard library,
    so you can add an `import` statement for the appropriate package in order to access
    the package. Others are external, and that's when you need to use `go get` to
    download them before they can be imported. For this case, you'll need to add `import
    "bytes"` to the top of the file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: We have started designing our API by becoming the first user of it. We want
    to be able to capture the output of our tracer in a `bytes.Buffer` variable so
    that we can then ensure that the string in the buffer matches the expected value.
    If it does not, a call to `t.Errorf` will fail the test. Before that, we check
    to make sure the return from a made-up `New` function is not `nil`; again, if
    it is, the test will fail because of the call to `t.Error`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Red-green testing
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Running `go test` now actually produces an error; it complains that there is
    no `New` function. We haven't made a mistake here; we are following a practice
    known as red-green testing. Red-green testing proposes that we first write a unit
    test, see it fail (or produce an error), write the minimum amount of code possible
    to make that test pass, and rinse and repeat it again. The key point here being
    that we want to make sure the code we add is actually doing something as well
    as ensuring that the test code we write is testing something meaningful.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a meaningless test for a minute:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It is logically impossible for `true` to not be  true (if `true` ever equals `false`,
    it's time to get a new computer), and so our test is pointless. If a test or claim
    cannot fail, there is no value whatsoever to be found in it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Replacing `true` with a variable that you expect to be set to `true` under certain
    conditions would mean that such a test can indeed fail (like when the code being
    tested is misbehaving) at this point, you have a meaningful test that is worth
    contributing to the code base.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'You can treat the output of `go test` like a to-do list, solving only one problem
    at a time. Right now, the complaint about the missing `New` function is all we
    will address. In the `trace.go` file, let''s add the minimum amount of code possible
    to progress with things; add the following snippet underneath the interface type
    definition:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running `go test` now shows us that things have indeed progressed, albeit not
    very far. We now have two errors:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first error tells us that we are passing arguments to our `New` function,
    but the `New` function doesn''t accept any. The second error says that we are
    using the return of the `New` function as a value, but that the `New` function
    doesn''t return anything. You might have seen this coming, and indeed as you gain
    more experience writing test-driven code, you will most likely jump over such
    trivial details. However, to properly illustrate the method, we are going to be
    pedantic for a while. Let''s address the first error by updating our `New` function
    to take in the expected argument:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We are taking an argument that satisfies the `io.Writer` interface, which means
    that the specified object must have a suitable `Write` method.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using existing interfaces, especially ones found in the Go standard library,
    is an extremely powerful and often necessary way to ensure that your code is as
    flexible and elegant as possible.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Accepting `io.Writer` means that the user can decide where the tracing output
    will be written. This output could be the standard output, a file, network socket,
    `bytes.Buffer` as in our test case, or even some custom-made object, provided
    it can act like an `io.Writer` interface.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `go test` again shows us that we have resolved the first error and
    we only need add a return type in order to progress past our second error:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We are stating that our `New` function will return a `Tracer`, but we do not
    return anything, which `go test` happily complains about:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Fixing this is easy; we can just return `nil` from the `New` function:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Of course, our test code has asserted that the return should not be `nil`,
    so `go test` now gives us a failure message:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can see how this hyper-strict adherence to the red-green principle can get
    a little tedious, but it is vital that we do not jump too far ahead. If we were
    to write a lot of implementation code in one go, we will very likely have code
    that is not covered by a unit test.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'The ever-thoughtful core team has even solved this problem for us by providing
    code coverage statistics. The following command provides code statistics:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Provided that all tests pass, adding the `-cover` flag will tell us how much
    of our code was touched during the execution of the tests. Obviously, the closer
    we get to 100 percent the better.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有测试都通过，添加`-cover`标志将告诉我们测试执行期间我们的代码被触动了多少。显然，我们越接近100%，效果就越好。
