<html><head></head><body>
<div class="book" title="Tracing code to get a look under the hood">
<div class="book" title="Implementing the interface"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec0019" class="calibre1"/>Implementing the interface</h2></div></div></div><p class="calibre10">To satisfy this test, we need something that we can properly return from the <code class="email">New</code> method because <code class="email">Tracer</code> is only an interface and we have to return something real. Let's add an implementation of a tracer to our <code class="email">tracer.go</code> file:</p><pre class="programlisting">type tracer struct { 
  out io.Writer 
}  
func (t *tracer) Trace(a ...interface{}) {} 
</pre><p class="calibre10">Our implementation is extremely simple: the <code class="email">tracer</code> type has an <code class="email">io.Writer</code> field called <code class="email">out</code> which is where we will write the trace output to. And the <code class="email">Trace</code> method exactly matches the method required by the <code class="email">Tracer</code> interface, although it doesn't do anything yet.</p><p class="calibre10">Now we can finally fix the <code class="email">New</code> method:</p><pre class="programlisting">func New(w io.Writer) Tracer { 
  return &amp;tracer{out: w} 
} 
</pre><p class="calibre10">Running <code class="email">go test</code> again shows us that our expectation was not met because nothing was written during our call to <code class="email">Trace</code>:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">tracer_test.go:18: Trace should not write ''.</strong></span>
</pre><p class="calibre10">Let's update our <code class="email">Trace</code> method to write the blended arguments to the specified <code class="email">io.Writer</code> field:</p><pre class="programlisting">func (t *tracer) Trace(a ...interface{}) { 
  fmt.Fprint(t.out, a...) 
  fmt.Fprintln(t.out) 
} 
</pre><p class="calibre10">When the <code class="email">Trace</code> method is called, we use <code class="email">fmt.Fprint</code> (and <code class="email">fmt.Fprintln</code>) to format and write the trace details to the <code class="email">out</code> writer.</p><p class="calibre10">Have we finally satisfied our test?</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test -cover</strong></span>
<span class="strong"><strong class="calibre2">PASS</strong></span>
<span class="strong"><strong class="calibre2">coverage: 100.0% of statements</strong></span>
<span class="strong"><strong class="calibre2">ok    trace 0.011s</strong></span>
</pre><p class="calibre10">Congratulations! We have successfully passed our test and have 100 percent test coverage. Once we have finished our glass of champagne, we can take a minute to consider something very interesting about our implementation.</p><div class="book" title="Unexported types being returned to users"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch01lvl3sec003" class="calibre1"/>Unexported types being returned to users</h3></div></div></div><p class="calibre10">The <code class="email">tracer</code> struct type we wrote is <span class="strong"><strong class="calibre2">unexported</strong></span> because it begins with a lowercase <code class="email">t</code>, so how is it that we are able to return it from the exported <code class="email">New</code> function? After all, doesn't the user receive the returned object? This is perfectly acceptable and valid Go code; the user will only ever see an object that satisfies the <code class="email">Tracer</code> interface and will never even know about our private <code class="email">tracer</code> type. Since they only interact with the interface anyway, it wouldn't matter if our <code class="email">tracer</code> implementation exposed other methods or fields; they would never be seen. This allows us to keep the public API of our package clean and simple.</p><p class="calibre10">This hidden implementation technique is used throughout the Go standard library; for example, the <code class="email">ioutil.NopCloser</code> method is a function that turns a normal <code class="email">io.Reader</code> interface into <code class="email">io.ReadCloser</code> where the <code class="email">Close</code> method does nothing (used for when <code class="email">io.Reader</code> objects that don't need to be closed are passed into functions that require <code class="email">io.ReadCloser</code> types). The method returns <code class="email">io.ReadCloser</code> as far as the user is concerned, but under the hood, there is a secret <code class="email">nopCloser</code> type hiding the implementation details.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note0023" class="calibre1"/>Note</h3><p class="calibre10">To see this for yourself, browse the Go standard library source code at
<a class="calibre1" href="http://golang.org/src/pkg/io/ioutil/ioutil.go">http://golang.org/src/pkg/io/ioutil/ioutil.go</a> and search for the <code class="email">nopCloser</code> struct.</p></div></div></div></div></body></html>