- en: Implementing the interface
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现接口
- en: 'To satisfy this test, we need something that we can properly return from the `New`
    method because `Tracer` is only an interface and we have to return something real.
    Let''s add an implementation of a tracer to our `tracer.go` file:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这个测试，我们需要从`New`方法中正确返回的东西，因为`Tracer`只是一个接口，我们必须返回一个真实的东西。让我们在我们的`tracer.go`文件中添加一个跟踪器的实现：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Our implementation is extremely simple: the `tracer` type has an `io.Writer`
    field called `out` which is where we will write the trace output to. And the `Trace`
    method exactly matches the method required by the `Tracer` interface, although
    it doesn''t do anything yet.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现非常简单：`tracer`类型有一个名为`out`的`io.Writer`字段，我们将在这里写入跟踪输出。`Trace`方法正好符合`Tracer`接口所需的方法，尽管它目前还没有做任何事情。
- en: 'Now we can finally fix the `New` method:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以最终修复`New`方法：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Running `go test` again shows us that our expectation was not met because nothing
    was written during our call to `Trace`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`go test`显示我们的预期没有达到，因为在我们的`Trace`调用期间没有写入任何内容：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s update our `Trace` method to write the blended arguments to the specified `io.Writer`
    field:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新我们的`Trace`方法，将混合参数写入指定的`io.Writer`字段：
- en: '[PRE3]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When the `Trace` method is called, we use `fmt.Fprint` (and `fmt.Fprintln`)
    to format and write the trace details to the `out` writer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`Trace`方法时，我们使用`fmt.Fprint`（以及`fmt.Fprintln`）来格式化和将跟踪详细信息写入`out`写入器。
- en: Have we finally satisfied our test?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终满足我们的测试了吗？
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Congratulations! We have successfully passed our test and have 100 percent test
    coverage. Once we have finished our glass of champagne, we can take a minute to
    consider something very interesting about our implementation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们已经成功通过了测试，并且有100%的测试覆盖率。在我们喝完一杯香槟之后，我们可以花一分钟时间考虑我们实现中的一个非常有趣的事情。
- en: Unexported types being returned to users
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回给用户的未导出类型
- en: The `tracer` struct type we wrote is **unexported** because it begins with a
    lowercase `t`, so how is it that we are able to return it from the exported `New`
    function? After all, doesn't the user receive the returned object? This is perfectly
    acceptable and valid Go code; the user will only ever see an object that satisfies
    the `Tracer` interface and will never even know about our private `tracer` type.
    Since they only interact with the interface anyway, it wouldn't matter if our
    `tracer` implementation exposed other methods or fields; they would never be seen.
    This allows us to keep the public API of our package clean and simple.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的`tracer`结构体类型是**未导出**的，因为它以小写`t`开头，那么我们是如何从导出的`New`函数中返回它的呢？毕竟，用户不会收到返回的对象吗？这是完全可接受和有效的Go代码；用户将只会看到一个满足`Tracer`接口的对象，甚至永远不会知道我们的私有`tracer`类型。由于他们无论如何只与接口交互，所以我们的`tracer`实现公开了其他方法或字段，它们也永远不会被看到。这使我们能够保持我们包的公共API简洁简单。
- en: This hidden implementation technique is used throughout the Go standard library;
    for example, the `ioutil.NopCloser` method is a function that turns a normal `io.Reader` interface
    into `io.ReadCloser` where the `Close` method does nothing (used for when `io.Reader`
    objects that don't need to be closed are passed into functions that require `io.ReadCloser`
    types). The method returns `io.ReadCloser` as far as the user is concerned, but
    under the hood, there is a secret `nopCloser` type hiding the implementation details.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种隐藏的实现技术贯穿于Go标准库中；例如，`ioutil.NopCloser`方法是一个将正常的`io.Reader`接口转换为`io.ReadCloser`的函数，其中`Close`方法不执行任何操作（用于当不需要关闭的`io.Reader`对象被传递到需要`io.ReadCloser`类型的函数中时）。该方法对用户而言返回`io.ReadCloser`，但在底层，有一个隐藏的`nopCloser`类型隐藏了实现细节。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To see this for yourself, browse the Go standard library source code at [http://golang.org/src/pkg/io/ioutil/ioutil.go](http://golang.org/src/pkg/io/ioutil/ioutil.go)
    and search for the `nopCloser` struct.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要亲自查看，请浏览Go标准库源代码[http://golang.org/src/pkg/io/ioutil/ioutil.go](http://golang.org/src/pkg/io/ioutil/ioutil.go)，并搜索`nopCloser`结构体。
