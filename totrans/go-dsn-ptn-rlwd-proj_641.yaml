- en: Implementing the interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To satisfy this test, we need something that we can properly return from the `New`
    method because `Tracer` is only an interface and we have to return something real.
    Let''s add an implementation of a tracer to our `tracer.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Our implementation is extremely simple: the `tracer` type has an `io.Writer`
    field called `out` which is where we will write the trace output to. And the `Trace`
    method exactly matches the method required by the `Tracer` interface, although
    it doesn''t do anything yet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can finally fix the `New` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `go test` again shows us that our expectation was not met because nothing
    was written during our call to `Trace`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s update our `Trace` method to write the blended arguments to the specified `io.Writer`
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When the `Trace` method is called, we use `fmt.Fprint` (and `fmt.Fprintln`)
    to format and write the trace details to the `out` writer.
  prefs: []
  type: TYPE_NORMAL
- en: Have we finally satisfied our test?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! We have successfully passed our test and have 100 percent test
    coverage. Once we have finished our glass of champagne, we can take a minute to
    consider something very interesting about our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Unexported types being returned to users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `tracer` struct type we wrote is **unexported** because it begins with a
    lowercase `t`, so how is it that we are able to return it from the exported `New`
    function? After all, doesn't the user receive the returned object? This is perfectly
    acceptable and valid Go code; the user will only ever see an object that satisfies
    the `Tracer` interface and will never even know about our private `tracer` type.
    Since they only interact with the interface anyway, it wouldn't matter if our
    `tracer` implementation exposed other methods or fields; they would never be seen.
    This allows us to keep the public API of our package clean and simple.
  prefs: []
  type: TYPE_NORMAL
- en: This hidden implementation technique is used throughout the Go standard library;
    for example, the `ioutil.NopCloser` method is a function that turns a normal `io.Reader` interface
    into `io.ReadCloser` where the `Close` method does nothing (used for when `io.Reader`
    objects that don't need to be closed are passed into functions that require `io.ReadCloser`
    types). The method returns `io.ReadCloser` as far as the user is concerned, but
    under the hood, there is a secret `nopCloser` type hiding the implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see this for yourself, browse the Go standard library source code at [http://golang.org/src/pkg/io/ioutil/ioutil.go](http://golang.org/src/pkg/io/ioutil/ioutil.go)
    and search for the `nopCloser` struct.
  prefs: []
  type: TYPE_NORMAL
