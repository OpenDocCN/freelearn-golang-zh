<html><head></head><body>
<div class="book" title="Tracing code to get a look under the hood">
<div class="book" title="Using our new trace package"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec0020" class="calibre1"/>Using our new trace package</h2></div></div></div><p class="calibre10">Now that we have completed the first version of our <code class="email">trace</code> package, we can use it in our chat application in order to better understand what is going on when users send messages through the user interface.</p><p class="calibre10">In <code class="email">room.go</code>, let's import our new package and make some calls to the <code class="email">Trace</code> method. The path to the <code class="email">trace</code> package we just wrote will depend on your <code class="email">GOPATH</code> environment variable because the import path is relative to the <code class="email">$GOPATH/src</code> folder. So if you create your <code class="email">trace</code> package in <code class="email">$GOPATH/src/mycode/trace</code>, then you would need to import <code class="email">mycode/trace</code>.</p><p class="calibre10">Update the <code class="email">room</code> type and the <code class="email">run()</code> method like this:</p><pre class="programlisting">type room struct { 
  // forward is a channel that holds incoming messages 
  // that should be forwarded to the other clients. 
  forward chan []byte 
  // join is a channel for clients wishing to join the room. 
  join chan *client 
  // leave is a channel for clients wishing to leave the room. 
  leave chan *client 
  // clients holds all current clients in this room. 
  clients map[*client]bool  
  // tracer will receive trace information of activity 
  // in the room. 
  tracer trace.Tracer 
} 
func (r *room) run() { 
  for { 
    select { 
    case client := &lt;-r.join: 
      // joining 
      r.clients[client] = true 
      r.tracer.Trace("New client joined") 
    case client := &lt;-r.leave: 
      // leaving 
      delete(r.clients, client) 
      close(client.send) 
      r.tracer.Trace("Client left") 
    case msg := &lt;-r.forward: 
      r.tracer.Trace("Message received: ", string(msg)) 
      // forward message to all clients 
      for client := range r.clients { 
        client.send &lt;- msg 
        r.tracer.Trace(" -- sent to client") 
      } 
    } 
  } 
}  
</pre><p class="calibre10">We added a <code class="email">trace.Tracer</code> field to our <code class="email">room</code> type and then made periodic calls to the <code class="email">Trace</code> method peppered throughout the code. If we run our program and try to send messages, you'll notice that the application panics because the <code class="email">tracer</code> field is <code class="email">nil</code>. We can remedy this for now by making sure we create and assign an appropriate object when we create our <code class="email">room</code> type. Update the <code class="email">main.go</code> file to do this:</p><pre class="programlisting">r := newRoom() 
r.tracer = trace.New(os.Stdout) 
</pre><p class="calibre10">We are using our <code class="email">New</code> method to create an object that will send the output to the <code class="email">os.Stdout</code> standard output pipe (this is a technical way of saying we want it to print the output to our terminal).</p><p class="calibre10">Rebuild and run the program and use two browsers to play with the application, and notice that the terminal now has some interesting trace information for us:</p><p class="calibre10">
</p><div class="mediaobject"><img src="../images/00045.jpeg" alt="Using our new trace package" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">
</p><p class="calibre10">Now we are able to use the debug information to get an insight into what the application is doing, which will assist us when developing and supporting our project.</p></div></div></body></html>