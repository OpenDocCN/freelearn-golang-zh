<html><head></head><body>
<div class="book" title="Tracing code to get a look under the hood">
<div class="book" title="Making tracing optional"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch01lvl2sec0021" class="calibre1"/>Making tracing optional</h2></div></div></div><p class="calibre10">Once the application is released, the sort of tracing information we are generating will be pretty useless if it's just printed out to some terminal somewhere, or even worse, if it creates a lot of noise for our system administrators. Also, remember that when we don't set a tracer for our <code class="email">room</code> type, our code panics, which isn't a very user-friendly situation. To resolve these two issues, we are going to enhance our <code class="email">trace</code> package with a <code class="email">trace.Off()</code> method that will return an object that satisfies the <code class="email">Tracer</code> interface but will not do anything when the <code class="email">Trace</code> method is called.</p><p class="calibre10">Let's add a test that calls the <code class="email">Off</code> function to get a silent tracer before making a call to <code class="email">Trace</code> to ensure the code doesn't panic. Since the tracing won't happen, that's all we can do in our test code. Add the following test function to the <code class="email">tracer_test.go</code> file:</p><pre class="programlisting">func TestOff(t *testing.T) { 
  var silentTracer Tracer = Off() 
  silentTracer.Trace("something") 
} 
</pre><p class="calibre10">To make it pass, add the following code to the <code class="email">tracer.go</code> file:</p><pre class="programlisting">type nilTracer struct{} 
 
func (t *nilTracer) Trace(a ...interface{}) {} 
 
// Off creates a Tracer that will ignore calls to Trace. 
func Off() Tracer { 
  return &amp;nilTracer{} 
} 
</pre><p class="calibre10">Our <code class="email">nilTracer</code> struct has defined a <code class="email">Trace</code> method that does nothing, and a call to the <code class="email">Off()</code> method will create a new <code class="email">nilTracer</code> struct and return it. Notice that our <code class="email">nilTracer</code> struct differs from our <code class="email">tracer</code> struct in that it doesn't take an <code class="email">io.Writer</code> interface; it doesn't need one because it isn't going to write anything.</p><p class="calibre10">Now let's solve our second problem by updating our <code class="email">newRoom</code> method in the <code class="email">room.go</code> file:</p><pre class="programlisting">func newRoom() *room { 
  return &amp;room{ 
    forward: make(chan []byte), 
    join:    make(chan *client), 
    leave:   make(chan *client), 
    clients: make(map[*client]bool), 
    tracer:  trace.Off(), 
  } 
} 
</pre><p class="calibre10">By default, our <code class="email">room</code> type will be created with a <code class="email">nilTracer</code> struct and any calls to <code class="email">Trace</code> will just be ignored. You can try this out by removing the <code class="email">r.tracer = trace.New(os.Stdout)</code> line from the <code class="email">main.go</code> file: notice that nothing gets written to the terminal when you use the application and there is no panic.</p></div></div></body></html>