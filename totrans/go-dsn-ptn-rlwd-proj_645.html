<html><head></head><body><div class="book" title="Summary" id="4LN8A1-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec0011" class="calibre1"/>Summary</h1></div></div></div><p class="calibre10">In this chapter, we developed a complete concurrent chat application and our own simple package to trace the flow of our programs to help us better understand what is going on under the hood.</p><p class="calibre10">We used the <code class="email">net/http</code> package to quickly build what turned out to be a very powerful concurrent HTTP web server. In one particular case, we then upgraded the connection to open a web socket between the client and server. This means that we can easily and quickly communicate messages to the user's web browser without having to write messy polling code. We explored how templates are useful to separate the code from the content as well as to allow us to inject data into our template source, which let us make the host address configurable. Command-line flags helped us give simple configuration control to the people hosting our application while also letting us specify sensible defaults.</p><p class="calibre10">Our chat application made use of Go's powerful concurrency capabilities that allowed us to write clear <span class="strong"><em class="calibre11">threaded</em></span> code in just a few lines of idiomatic Go. By controlling the coming and going of clients through channels, we were able to set synchronization points in our code that prevented us from corrupting memory by attempting to modify the same objects at the same time.</p><p class="calibre10">We learned how interfaces such as <code class="email">http.Handler</code> and our own <code class="email">trace.Tracer</code> interface allow us to provide disparate implementations without having to touch the code that makes use of them, and in some cases, without having to expose even the name of the implementation to our users. We saw how just by adding a <code class="email">ServeHTTP</code> method to our <code class="email">room</code> type, we turned our custom room concept into a valid HTTP handler object, which managed our web socket connections.</p><p class="calibre10">We aren't actually very far away from being able to properly release our application, except for one major oversight: you cannot see who sent each message. We have no concept of users or even usernames, and for a real chat application, this is not acceptable.</p><p class="calibre10">In the next chapter, we will add the names of the people responding to their messages in order to make them feel like they are having a real conversation with other humans.</p></div></body></html>