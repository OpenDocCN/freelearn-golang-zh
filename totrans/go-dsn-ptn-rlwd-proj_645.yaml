- en: Summary
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we developed a complete concurrent chat application and our
    own simple package to trace the flow of our programs to help us better understand
    what is going on under the hood.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开发了一个完整的并发聊天应用程序以及我们自己的简单包，以追踪程序流程，帮助我们更好地理解底层发生的事情。
- en: We used the `net/http` package to quickly build what turned out to be a very
    powerful concurrent HTTP web server. In one particular case, we then upgraded
    the connection to open a web socket between the client and server. This means
    that we can easily and quickly communicate messages to the user's web browser
    without having to write messy polling code. We explored how templates are useful
    to separate the code from the content as well as to allow us to inject data into
    our template source, which let us make the host address configurable. Command-line
    flags helped us give simple configuration control to the people hosting our application
    while also letting us specify sensible defaults.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`net/http`包来快速构建一个最终证明非常强大的并发HTTP网络服务器。在某个特定情况下，我们将连接升级以在客户端和服务器之间打开WebSocket。这意味着我们可以轻松快速地向用户的网络浏览器发送消息，而无需编写混乱的轮询代码。我们探讨了模板如何有助于将代码与内容分离，以及如何允许我们将数据注入模板源，这使得我们可以使主机地址可配置。命令行标志帮助我们向托管我们应用程序的人提供简单的配置控制，同时让我们指定合理的默认值。
- en: Our chat application made use of Go's powerful concurrency capabilities that
    allowed us to write clear *threaded* code in just a few lines of idiomatic Go.
    By controlling the coming and going of clients through channels, we were able
    to set synchronization points in our code that prevented us from corrupting memory
    by attempting to modify the same objects at the same time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的聊天应用程序利用了Go强大的并发能力，使我们能够在几行惯用的Go代码中编写清晰的*多线程*代码。通过通过通道控制客户端的进出，我们能够在代码中设置同步点，防止我们通过同时修改相同的对象来损坏内存。
- en: We learned how interfaces such as `http.Handler` and our own `trace.Tracer` interface
    allow us to provide disparate implementations without having to touch the code
    that makes use of them, and in some cases, without having to expose even the name
    of the implementation to our users. We saw how just by adding a `ServeHTTP` method
    to our `room` type, we turned our custom room concept into a valid HTTP handler
    object, which managed our web socket connections.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何通过接口如`http.Handler`和我们的`trace.Tracer`接口，在不触及使用它们的代码的情况下提供不同的实现，在某些情况下，甚至不需要向用户暴露实现名称。我们看到，只需在我们的`room`类型中添加一个`ServeHTTP`方法，我们就能将我们的自定义房间概念转变为一个有效的HTTP处理器对象，该对象管理我们的WebSocket连接。
- en: 'We aren''t actually very far away from being able to properly release our application,
    except for one major oversight: you cannot see who sent each message. We have
    no concept of users or even usernames, and for a real chat application, this is
    not acceptable.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上离正确发布我们的应用程序并不远，只是有一个主要的疏忽：您无法看到谁发送了每条消息。我们没有用户或用户名的概念，对于一个真正的聊天应用程序来说，这是不可接受的。
- en: In the next chapter, we will add the names of the people responding to their
    messages in order to make them feel like they are having a real conversation with
    other humans.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将添加回复消息的人的名字，以便让他们感觉像是在与其他人类进行真正的对话。
