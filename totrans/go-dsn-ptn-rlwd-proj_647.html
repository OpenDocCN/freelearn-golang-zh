<html><head></head><body>
<div class="book" title="Chapter&#xA0;2.&#xA0; Adding User Accounts" id="4MLOS1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Handlers all the way down"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec0012" class="calibre1"/>Handlers all the way down</h1></div></div></div><p class="calibre10">For our chat application, we implemented our own <code class="email">http.Handler</code> type (the room) in order to easily compile, execute, and deliver HTML content to browsers. Since this is a very simple but powerful interface, we are going to continue to use it wherever possible when adding functionality to our HTTP processing.</p><p class="calibre10">In order to determine whether a user is allowed to proceed, we will create an authorization wrapper handler that will perform the check and pass the execution on to the inner handler only if the user is authorized.</p><p class="calibre10">Our wrapper handler will satisfy the same <code class="email">http.Handler</code> interface as the object inside it, allowing us to wrap any valid handler. In fact, even the authentication handler we are about to write could be later encapsulated inside a similar wrapper if required.</p><p class="calibre10">
</p><div class="mediaobject"><img src="../images/00046.jpeg" alt="Handlers all the way down" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">
</p><p class="calibre10">Chaining pattern when applied to HTTP handlers</p><p class="calibre10">The preceding diagram shows how this pattern could be applied in a more complicated HTTP handler scenario. Each object implements the <code class="email">http.Handler</code> interface. This means that an object could be passed to the <code class="email">http.Handle</code> method to directly handle a request, or it can be given to another object, which could add some kind of extra functionality. The <code class="email">Logging</code> handler may write to a log file before and after the <code class="email">ServeHTTP</code> method is called on the inner handler. Because the inner handler is just another <code class="email">http.Handler</code>, any other handler can be wrapped in (or decorated with) the <code class="email">Logging</code> handler.</p><p class="calibre10">It is also common for an object to contain logic that decides which inner handler should be executed. For example, our authentication handler will either pass the execution to the wrapped handler, or handle the request itself by issuing a redirect to the browser.</p><p class="calibre10">That's plenty of theory for now; let's write some code. Create a new file called <code class="email">auth.go</code> in the <code class="email">chat</code> folder:</p><pre class="programlisting">package main 
import ("net/http") 
type authHandler struct { 
  next http.Handler 
} 
func (h *authHandler) ServeHTTP(w http.ResponseWriter, r  *http.Request) { 
  _, err := r.Cookie("auth") 
  if err == http.ErrNoCookie { 
    // not authenticated 
    w.Header().Set("Location", "/login") 
    w.WriteHeader(http.StatusTemporaryRedirect) 
    return 
  }  
  if err != nil { 
    // some other error 
   http.Error(w, err.Error(), http.StatusInternalServerError) 
   return 
  }  
  // success - call the next handler 
  h.next.ServeHTTP(w, r) 
} 
func MustAuth(handler http.Handler) http.Handler { 
  return &amp;authHandler{next: handler} 
} 
</pre><p class="calibre10">The <code class="email">authHandler</code> type not only implements the <code class="email">ServeHTTP</code> method (which satisfies the <code class="email">http.Handler</code> interface), but also stores (wraps) <code class="email">http.Handler</code> in the <code class="email">next</code> field. Our <code class="email">MustAuth</code> helper function simply creates <code class="email">authHandler</code> that wraps any other <code class="email">http.Handler</code>. This is the pattern that allows us to easily add authorization to our code in <code class="email">main.go</code>.</p><p class="calibre10">Let's tweak the following root mapping line:</p><pre class="programlisting">http.Handle("/", &amp;templateHandler{filename: "chat.html"}) 
</pre><p class="calibre10">Let's change the first argument to make it explicit about the page meant for chatting. Next, let's use the <code class="email">MustAuth</code> function to wrap <code class="email">templateHandler</code> for the second argument:</p><pre class="programlisting">http.Handle("/chat", MustAuth(&amp;templateHandler{filename:  "chat.html"})) 
</pre><p class="calibre10">Wrapping <code class="email">templateHandler</code> with the <code class="email">MustAuth</code> function will cause the execution to run through <code class="email">authHandler</code> first; it will run only to <code class="email">templateHandler</code> if the request is authenticated.</p><p class="calibre10">The <code class="email">ServeHTTP</code> method in <code class="email">authHandler</code> will look for a special cookie called <code class="email">auth</code>, and it will use the <code class="email">Header</code> and <code class="email">WriteHeader</code> methods on <code class="email">http.ResponseWriter</code> to redirect the user to a login page if the cookie is missing. Notice that we discard the cookie itself using the underscore character and capture only the returning error; this is because we only care about whether the cookie is present at this point.</p><p class="calibre10">Build and run the chat application and try to hit <code class="email">http://localhost:8080/chat</code>:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go build -o chat</strong></span>
<span class="strong"><strong class="calibre2">./chat -host=":8080"</strong></span>
</pre><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip25" class="calibre1"/>Tip</h3><p class="calibre10">You need to delete your cookies to clear out previous authentication tokens or any other cookies that might be left over from other development projects served through the localhost.</p></div><p class="calibre10">If you look in the address bar of your browser, you will notice that you are immediately redirected to the <code class="email">/login</code> page. Since we cannot handle that path yet, you'll just get a <span class="strong"><strong class="calibre2">404 page not found</strong></span> error.</p></div></div></body></html>