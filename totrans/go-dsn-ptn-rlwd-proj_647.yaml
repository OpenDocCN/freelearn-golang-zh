- en: Handlers all the way down
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Handlers all the way down
- en: For our chat application, we implemented our own `http.Handler` type (the room)
    in order to easily compile, execute, and deliver HTML content to browsers. Since
    this is a very simple but powerful interface, we are going to continue to use
    it wherever possible when adding functionality to our HTTP processing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的聊天应用程序，我们实现了自己的 `http.Handler` 类型（房间），以便轻松编译、执行并将 HTML 内容传递给浏览器。由于这是一个非常简单但功能强大的接口，我们在添加功能到我们的
    HTTP 处理时将尽可能继续使用它。
- en: In order to determine whether a user is allowed to proceed, we will create an
    authorization wrapper handler that will perform the check and pass the execution
    on to the inner handler only if the user is authorized.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定用户是否被允许继续操作，我们将创建一个授权包装处理程序，该处理程序将执行检查，并且只有当用户被授权时，才会将执行传递给内部处理程序。
- en: Our wrapper handler will satisfy the same `http.Handler` interface as the object
    inside it, allowing us to wrap any valid handler. In fact, even the authentication
    handler we are about to write could be later encapsulated inside a similar wrapper
    if required.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的外部包装处理程序将满足与内部对象相同的 `http.Handler` 接口，允许我们包装任何有效的处理程序。实际上，甚至我们即将编写的认证处理程序如果需要的话，也可以封装在类似的包装器中。
- en: '![Handlers all the way down](img/00046.jpeg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Handlers all the way down](img/00046.jpeg)'
- en: Chaining pattern when applied to HTTP handlers
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 将链式模式应用于 HTTP 处理程序
- en: The preceding diagram shows how this pattern could be applied in a more complicated
    HTTP handler scenario. Each object implements the `http.Handler` interface. This
    means that an object could be passed to the `http.Handle` method to directly handle
    a request, or it can be given to another object, which could add some kind of
    extra functionality. The `Logging` handler may write to a log file before and
    after the `ServeHTTP` method is called on the inner handler. Because the inner
    handler is just another `http.Handler`, any other handler can be wrapped in (or
    decorated with) the `Logging` handler.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示展示了如何在更复杂的 HTTP 处理程序场景中应用这种模式。每个对象都实现了 `http.Handler` 接口。这意味着一个对象可以被传递给
    `http.Handle` 方法以直接处理请求，或者它可以被传递给另一个对象，该对象可以添加某种额外的功能。`Logging` 处理程序可能在内部处理程序的
    `ServeHTTP` 方法被调用前后写入日志文件。因为内部处理程序只是另一个 `http.Handler`，所以任何其他处理程序都可以被包装在（或装饰）`Logging`
    处理程序中。
- en: It is also common for an object to contain logic that decides which inner handler
    should be executed. For example, our authentication handler will either pass the
    execution to the wrapped handler, or handle the request itself by issuing a redirect
    to the browser.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个对象会包含逻辑来决定哪个内部处理程序应该被执行。例如，我们的认证处理程序将要么将执行传递给包装的处理程序，要么通过向浏览器发出重定向来处理请求本身。
- en: 'That''s plenty of theory for now; let''s write some code. Create a new file
    called `auth.go` in the `chat` folder:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的理论已经足够多了；让我们写一些代码。在 `chat` 文件夹中创建一个名为 `auth.go` 的新文件：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `authHandler` type not only implements the `ServeHTTP` method (which satisfies
    the `http.Handler` interface), but also stores (wraps) `http.Handler` in the `next`
    field. Our `MustAuth` helper function simply creates `authHandler` that wraps
    any other `http.Handler`. This is the pattern that allows us to easily add authorization
    to our code in `main.go`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`authHandler` 类型不仅实现了 `ServeHTTP` 方法（这满足了 `http.Handler` 接口），还在 `next` 字段中存储（包装）了
    `http.Handler`。我们的 `MustAuth` 辅助函数简单地创建了一个包装任何其他 `http.Handler` 的 `authHandler`。这就是允许我们在
    `main.go` 中轻松添加授权到我们的代码的模式。'
- en: 'Let''s tweak the following root mapping line:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调整以下根映射行：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s change the first argument to make it explicit about the page meant for
    chatting. Next, let''s use the `MustAuth` function to wrap `templateHandler` for
    the second argument:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改第一个参数，使其明确表示用于聊天的页面。接下来，让我们使用 `MustAuth` 函数来包装 `templateHandler` 作为第二个参数：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Wrapping `templateHandler` with the `MustAuth` function will cause the execution
    to run through `authHandler` first; it will run only to `templateHandler` if the
    request is authenticated.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `MustAuth` 函数包装 `templateHandler` 将导致执行首先运行通过 `authHandler`；如果请求已认证，它将只运行到
    `templateHandler`。
- en: The `ServeHTTP` method in `authHandler` will look for a special cookie called
    `auth`, and it will use the `Header` and `WriteHeader` methods on `http.ResponseWriter`
    to redirect the user to a login page if the cookie is missing. Notice that we
    discard the cookie itself using the underscore character and capture only the
    returning error; this is because we only care about whether the cookie is present
    at this point.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`authHandler`中的`ServeHTTP`方法会寻找一个名为`auth`的特殊cookie，并且它将使用`http.ResponseWriter`上的`Header`和`WriteHeader`方法将用户重定向到登录页面，如果cookie缺失。请注意，我们使用下划线字符丢弃cookie本身，只捕获返回的错误；这是因为我们此时只关心cookie是否存在。'
- en: 'Build and run the chat application and try to hit `http://localhost:8080/chat`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行聊天应用程序，并尝试访问`http://localhost:8080/chat`：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You need to delete your cookies to clear out previous authentication tokens
    or any other cookies that might be left over from other development projects served
    through the localhost.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要删除您的cookies来清除之前的认证令牌或任何可能遗留在通过localhost运行的其他开发项目中的其他cookies。
- en: If you look in the address bar of your browser, you will notice that you are
    immediately redirected to the `/login` page. Since we cannot handle that path
    yet, you'll just get a **404 page not found** error.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看浏览器地址栏，您会注意到您会立即重定向到`/login`页面。由于我们目前还不能处理该路径，您将只会收到一个**404页面未找到**错误。
