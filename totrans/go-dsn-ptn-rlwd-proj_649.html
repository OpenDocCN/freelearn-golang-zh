<html><head></head><body><div class="book" title="Endpoints with dynamic paths" id="4OIQ01-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec0014" class="calibre1"/>Endpoints with dynamic paths</h1></div></div></div><p class="calibre10">Pattern matching for the <code class="email">http</code> package in the Go standard library isn't the most comprehensive and fully featured implementation out there. For example, Ruby on Rails makes it much easier to have dynamic segments inside the path. You could map the route like this:</p><pre class="programlisting">"auth/:action/:provider_name" 
</pre><p class="calibre10">Rails then provides a data map (or dictionary) containing the values that it automatically extracted from the matched path. So if you visit <code class="email">auth/login/google</code>, then <code class="email">params[:provider_name]</code> would equal <code class="email">google</code> and <code class="email">params[:action]</code> would equal <code class="email">login</code>.</p><p class="calibre10">The most the <code class="email">http</code> package lets us specify by default is a path prefix, which we can make use of by leaving a trailing slash at the end of the pattern:</p><pre class="programlisting">"auth/" 
</pre><p class="calibre10">We would then have to manually parse the remaining segments to extract the appropriate data. This is acceptable for relatively simple cases. This suits our needs for the time being since we only need to handle a few different paths, such as the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">/auth/login/google</code></li><li class="listitem"><code class="email">/auth/login/facebook</code></li><li class="listitem"><code class="email">/auth/callback/google</code></li><li class="listitem"><code class="email">/auth/callback/facebook</code></li></ul></div><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip28" class="calibre1"/>Tip</h3><p class="calibre10">If you need to handle more advanced routing situations, you may want to consider using dedicated packages, such as <code class="email">goweb</code>, <code class="email">pat</code>, <code class="email">routes</code>, or <code class="email">mux</code>. For extremely simple cases such as ours, built-in capabilities will do.</p></div><p class="calibre10">We are going to create a new handler that powers our login process. In <code class="email">auth.go</code>, add the following <code class="email">loginHandler</code> code:</p><pre class="programlisting">// loginHandler handles the third-party login process. 
// format: /auth/{action}/{provider} 
func loginHandler(w http.ResponseWriter, r *http.Request) { 
  segs := strings.Split(r.URL.Path, "/") 
  action := segs[2] 
  provider := segs[3] 
  switch action { 
  case "login": 
    log.Println("TODO handle login for", provider) 
      default: 
        w.WriteHeader(http.StatusNotFound) 
        fmt.Fprintf(w, "Auth action %s not supported", action) 
  } 
} 
</pre><p class="calibre10">In the preceding code, we break the path into segments using <code class="email">strings.Split</code> before pulling out the values for <code class="email">action</code> and <code class="email">provider</code>. If the action value is known, we will run the specific code; otherwise, we will write out an error message and return an <code class="email">http.StatusNotFound</code> status code (which in the language of HTTP status code is <code class="email">404</code>).</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note0029" class="calibre1"/>Note</h3><p class="calibre10">We will not bulletproof our code right now. But it's worth noticing that if someone hits <code class="email">loginHandler</code> with few segments, our code will panic because it would expect <code class="email">segs[2]</code> and <code class="email">segs[3]</code> to exist.</p><p class="calibre10">For extra credit, see whether you can protect your code against this and return a nice error message instead of making it panic if someone hits <code class="email">/auth/nonsense</code>.</p></div><p class="calibre10">Our <code class="email">loginHandler</code> is only a function and not an object that implements the <code class="email">http.Handler</code> interface. This is because, unlike other handlers, we don't need it to store any state. The Go standard library supports this, so we can use the <code class="email">http.HandleFunc</code> function to map it in a way similar to how we used <code class="email">http.Handle</code> earlier. In <code class="email">main.go</code>, update the handlers:</p><pre class="programlisting">http.Handle("/chat", MustAuth(&amp;templateHandler{filename:  "chat.html"})) 
http.Handle("/login", &amp;templateHandler{filename: "login.html"}) 
http.HandleFunc("/auth/", loginHandler) 
http.Handle("/room", r) 
</pre><p class="calibre10">Rebuild and run the chat application:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go build -o chat</strong></span>
<span class="strong"><strong class="calibre2">./chat -host=":8080"</strong></span>
</pre><p class="calibre10">Hit the following URLs and notice the output logged in the terminal:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">http://localhost:8080/auth/login/google</code> outputs <code class="email">TODO handle login for google</code></li><li class="listitem"><code class="email">http://localhost:8080/auth/login/facebook</code> outputs <code class="email">TODO handle login for facebook</code></li></ul></div><p class="calibre10">We have successfully implemented a dynamic path-matching mechanism that just prints out <code class="email">TODO</code> messages so far; we need to integrate it with authorization services in order to make our login process work.</p></div></body></html>