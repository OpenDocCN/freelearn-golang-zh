- en: Endpoints with dynamic paths
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态路径端点
- en: 'Pattern matching for the `http` package in the Go standard library isn''t the
    most comprehensive and fully featured implementation out there. For example, Ruby
    on Rails makes it much easier to have dynamic segments inside the path. You could
    map the route like this:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go 标准库中 `http` 包的路径匹配功能并不是最全面和功能最丰富的实现。例如，Ruby on Rails 使得在路径内部拥有动态段变得容易得多。你可以像这样映射路由：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Rails then provides a data map (or dictionary) containing the values that it
    automatically extracted from the matched path. So if you visit `auth/login/google`,
    then `params[:provider_name]` would equal `google` and `params[:action]` would
    equal `login`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果访问 `auth/login/google`，那么 `params[:provider_name]` 将等于 `google`，而 `params[:action]`
    将等于 `login`。
- en: 'The most the `http` package lets us specify by default is a path prefix, which
    we can make use of by leaving a trailing slash at the end of the pattern:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`http` 包允许我们指定的最多是路径前缀，我们可以通过在模式末尾保留一个尾随斜杠来利用它：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We would then have to manually parse the remaining segments to extract the
    appropriate data. This is acceptable for relatively simple cases. This suits our
    needs for the time being since we only need to handle a few different paths, such
    as the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须手动解析剩余的段以提取适当的数据。这对于相对简单的情况是可以接受的。这符合我们目前的需求，因为我们只需要处理几个不同的路径，例如以下路径：
- en: '`/auth/login/google`'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/auth/login/google`'
- en: '`/auth/login/facebook`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/auth/login/facebook`'
- en: '`/auth/callback/google`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/auth/callback/google`'
- en: '`/auth/callback/facebook`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/auth/callback/facebook`'
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you need to handle more advanced routing situations, you may want to consider
    using dedicated packages, such as `goweb`, `pat`, `routes`, or `mux`. For extremely
    simple cases such as ours, built-in capabilities will do.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要处理更高级的路由情况，你可能想要考虑使用专门的包，例如 `goweb`、`pat`、`routes` 或 `mux`。对于像我们这样极其简单的情况，内置功能就足够了。
- en: 'We are going to create a new handler that powers our login process. In `auth.go`,
    add the following `loginHandler` code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的处理器来驱动我们的登录过程。在 `auth.go` 文件中，添加以下 `loginHandler` 代码：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, we break the path into segments using `strings.Split`
    before pulling out the values for `action` and `provider`. If the action value
    is known, we will run the specific code; otherwise, we will write out an error
    message and return an `http.StatusNotFound` status code (which in the language
    of HTTP status code is `404`).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在提取 `action` 和 `provider` 的值之前，使用 `strings.Split` 将路径分解成段。如果动作值已知，我们将运行特定的代码；否则，我们将输出一个错误消息并返回一个
    `http.StatusNotFound` 状态码（在 HTTP 状态码的语言中是 `404`）。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will not bulletproof our code right now. But it's worth noticing that if
    someone hits `loginHandler` with few segments, our code will panic because it
    would expect `segs[2]` and `segs[3]` to exist.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不会对代码进行加固。但值得注意的是，如果有人用少量段访问 `loginHandler`，我们的代码会崩溃，因为它会期望 `segs[2]` 和
    `segs[3]` 存在。
- en: For extra credit, see whether you can protect your code against this and return
    a nice error message instead of making it panic if someone hits `/auth/nonsense`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外加分项，看看你是否可以保护你的代码免受这种影响，并在有人访问 `/auth/nonsense` 时返回一个友好的错误消息而不是让它崩溃。
- en: 'Our `loginHandler` is only a function and not an object that implements the
    `http.Handler` interface. This is because, unlike other handlers, we don''t need
    it to store any state. The Go standard library supports this, so we can use the
    `http.HandleFunc` function to map it in a way similar to how we used `http.Handle`
    earlier. In `main.go`, update the handlers:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `loginHandler` 只是一个函数，而不是实现 `http.Handler` 接口的对象。这是因为，与其它处理器不同，我们不需要它存储任何状态。Go
    标准库支持这一点，因此我们可以使用 `http.HandleFunc` 函数以类似于我们之前使用 `http.Handle` 的方式来映射它。在 `main.go`
    中更新处理器：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Rebuild and run the chat application:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建并运行聊天应用：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Hit the following URLs and notice the output logged in the terminal:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 访问以下 URL 并注意终端中记录的输出：
- en: '`http://localhost:8080/auth/login/google` outputs `TODO handle login for google`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/auth/login/google` 输出 `TODO handle login for google`'
- en: '`http://localhost:8080/auth/login/facebook` outputs `TODO handle login for
    facebook`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/auth/login/facebook` 输出 `TODO handle login for facebook`'
- en: We have successfully implemented a dynamic path-matching mechanism that just
    prints out `TODO` messages so far; we need to integrate it with authorization
    services in order to make our login process work.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功实现了一个仅打印 `TODO` 消息的动态路径匹配机制；我们需要将其与授权服务集成，以便使我们的登录过程生效。
