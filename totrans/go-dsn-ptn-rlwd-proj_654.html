<html><head></head><body>
<div class="book" title="Implementing external logging in">
<div class="book" title="Logging in"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec0024" class="calibre1"/>Logging in</h2></div></div></div><p class="calibre10">Now that we have configured Gomniauth, we need to redirect users to the provider's authorization page when they land on our <code class="email">/auth/login/{provider}</code> path. We just have to update our <code class="email">loginHandler</code> function in <code class="email">auth.go</code>:</p><pre class="programlisting">func loginHandler(w http.ResponseWriter, r *http.Request) { 
  segs := strings.Split(r.URL.Path, "/") 
  action := segs[2] 
  provider := segs[3] 
  switch action { 
  case "login": 
    provider, err := gomniauth.Provider(provider) 
    if err != nil { 
      http.Error(w, fmt.Sprintf("Error when trying to get provider 
      %s: %s",provider, err), http.StatusBadRequest) 
      return 
    } 
    loginUrl, err := provider.GetBeginAuthURL(nil, nil) 
    if err != nil { 
      http.Error(w, fmt.Sprintf("Error when trying to GetBeginAuthURL            
      for %s:%s", provider, err), http. StatusInternalServerError) 
      return 
    } 
    w.Header.Set("Location", loginUrl) 
    w.WriteHeader(http.StatusTemporaryRedirect) 
    default: 
      w.WriteHeader(http.StatusNotFound) 
      fmt.Fprintf(w, "Auth action %s not supported", action) 
  } 
} 
</pre><p class="calibre10">We do two main things here. First, we use the <code class="email">gomniauth.Provider</code> function to get the provider object that matches the object specified in the URL (such as <code class="email">google</code> or <code class="email">github</code>). Then, we use the <code class="email">GetBeginAuthURL</code> method to get the location where we must send users to in order to start the authorization process.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note0033" class="calibre1"/>Note</h3><p class="calibre10">The <code class="email">GetBeginAuthURL(nil, nil)</code> arguments are for the state and options respectively, which we are not going to use for our chat application.</p><p class="calibre10">The first argument is a state map of data that is encoded and signed and sent to the authentication provider. The provider doesn't do anything with the state; it just sends it back to our callback endpoint. This is useful if, for example, we want to redirect the user back to the original page they were trying to access before the authentication process intervened. For our purpose, we have only the <code class="email">/chat</code> endpoint, so we don't need to worry about sending any state.</p><p class="calibre10">The second argument is a map of additional options that will be sent to the authentication provider, which somehow modifies the behavior of the authentication process. For example, you can specify your own <code class="email">scope</code> parameter, which allows you to make a request for permission to access additional information from the provider. For more information about the available options, search for OAuth2 on the Internet or read the documentation for each provider, as these values differ from service to service.</p></div><p class="calibre10">If our code gets no error from the <code class="email">GetBeginAuthURL</code> call, we simply redirect the user's browser to the returned URL.</p><p class="calibre10">If errors occur, we use the <code class="email">http.Error</code> function to write the error message out with a <code class="email">non-200</code> status code.</p><p class="calibre10">Rebuild and run the chat application:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go build -o chat</strong></span>
<span class="strong"><strong class="calibre2">./chat -host=":8080"</strong></span>
</pre><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip34" class="calibre1"/>Tip</h3><p class="calibre10">We will continue to stop, rebuild, and run our projects manually throughout this book, but there are some tools that will take care of this for you by watching for changes and restarting Go applications automatically. If you're interested in such tools, check out <a class="calibre1" href="https://github.com/pilu/fresh">https://github.com/pilu/fresh</a> and <a class="calibre1" href="https://github.com/codegangsta/gin">https://github.com/codegangsta/gin</a>.</p></div><p class="calibre10">Open the main chat page by accessing <code class="email">http://localhost:8080/chat</code>. As we aren't logged in yet, we are redirected to our sign-in page. Click on the <span class="strong"><strong class="calibre2">Google</strong></span> option to sign in using your Google account and you will notice that you are presented with a Google-specific sign-in page (if you are not already signed in to Google). Once you are signed in, you will be presented with a page asking you to give permission for our chat application before you can view basic information about your account:</p><p class="calibre10">
</p><div class="mediaobject"><img src="../images/00049.jpeg" alt="Logging in" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">
</p><p class="calibre10">This is the same flow that the users of our chat application will experience when signing in.</p><p class="calibre10">Click on <span class="strong"><strong class="calibre2">Accept</strong></span> and you will notice that you are redirected to our application code but presented with an <code class="email">Auth action callback not supported</code> error. This is because we haven't yet implemented the callback functionality in <code class="email">loginHandler</code>.</p></div></div></body></html>