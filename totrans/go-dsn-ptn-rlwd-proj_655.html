<html><head></head><body>
<div class="book" title="Implementing external logging in">
<div class="book" title="Handling the response from the provider"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec0025" class="calibre1"/>Handling the response from the provider</h2></div></div></div><p class="calibre10">Once the user clicks on <span class="strong"><strong class="calibre2">Accept</strong></span> on the provider's website (or if they click on the equivalent of <span class="strong"><strong class="calibre2">Cancel</strong></span>), they will be redirected to the callback endpoint in our application.</p><p class="calibre10">A quick glance at the complete URL that comes back shows us the grant code that the provider has given us:</p><pre class="programlisting">http://localhost:8080/auth/callback/google?code=4/Q92xJ- BQfoX6PHhzkjhgtyfLc0Ylm.QqV4u9AbA9sYguyfbjFEsNoJKMOjQI 
</pre><p class="calibre10">We don't have to worry about what to do with this code because Gomniauth does it for us; we can simply jump to implementing our callback handler. However, it's worth knowing that this code will be exchanged by the authentication provider for a token that allows us to access private user data. For added security, this additional step happens behind the scenes, from server to server rather than in the browser.</p><p class="calibre10">In <code class="email">auth.go</code>, we are ready to add another switch case to our action path segment. Insert the following code before the default case:</p><pre class="programlisting">case "callback": 
  provider, err := gomniauth.Provider(provider) 
  if err != nil { 
    http.Error(w, fmt.Sprintf("Error when trying to get provider %s: %s",    
    provider, err), http.StatusBadRequest) 
    return 
  } 
  creds, err :=  provider.CompleteAuth(objx.MustFromURLQuery(r.URL.RawQuery)) 
  if err != nil { 
    http.Error(w, fmt.Sprintf("Error when trying to complete auth for 
    %s: %s", provider, err), http.StatusInternalServerError) 
    return 
  } 
  user, err := provider.GetUser(creds) 
  if err != nil { 
    http.Error(w, fmt.Sprintf("Error when trying to get user from %s: %s", 
    provider, err), http.StatusInternalServerError) 
    return 
  } 
  authCookieValue := objx.New(map[string]interface{}{ 
    "name": user.Name(), 
  }).MustBase64() 
  http.SetCookie(w, &amp;http.Cookie{ 
    Name:  "auth", 
    Value: authCookieValue, 
    Path:  "/"}) 
  w.Header().Set("Location", "/chat") 
  w.WriteHeader(http.StatusTemporaryRedirect) 
</pre><p class="calibre10">When the authentication provider redirects the users after they have granted permission, the URL specifies that it is a callback action. We look up the authentication provider as we did before and call its <code class="email">CompleteAuth</code> method. We parse <code class="email">RawQuery</code> from the request into <code class="email">objx.Map</code> (the multipurpose map type that Gomniauth uses), and the <code class="email">CompleteAuth</code> method uses the values to complete the OAuth2 provider handshake with the provider. All being well, we will be given some authorized credentials with which we will be able to access our user's basic data. We then use the <code class="email">GetUser</code> method for the provider, and Gomniauth will use the specified credentials to access some basic information about the user.</p><p class="calibre10">Once we have the user data, we <span class="strong"><strong class="calibre2">Base64-encode</strong></span> the <code class="email">Name</code> field in a JSON object and store it as a value for our <code class="email">auth</code> cookie for later use.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip35" class="calibre1"/>Tip</h3><p class="calibre10">Base64-encoding data ensures it won't contain any special or unpredictable characters, which is useful for situations such as passing data to a URL or storing it in a cookie. Remember that although Base64-encoded data looks encrypted, it is not you can easily decode Base64-encoded data back to the original text with little effort. There are online tools that do this for you.</p></div><p class="calibre10">After setting the cookie, we redirect the user to the chat page, which we can safely assume was the original destination.</p><p class="calibre10">Once you build and run the code again and hit the <code class="email">/chat</code> page, you will notice that the sign up flow works and we are finally allowed back to the chat page. Most browsers have an inspector or a console—a tool that allows you to view the cookies that the server has sent you-that you can use to see whether the <code class="email">auth</code> cookie has appeared:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go build -o chat</strong></span>
<span class="strong"><strong class="calibre2">./chat -host=":8080"</strong></span>
</pre><p class="calibre10">In our case, the cookie value is <code class="email">eyJuYW1lIjoiTWF0IFJ5ZXIifQ==</code>, which is a Base64-encoded version of <code class="email">{"name":"Mat Ryer"}</code>. Remember, we never typed in a name in our chat application; instead, Gomniauth asked Google for a name when we opted to sign in with Google. Storing non-signed cookies like this is fine for incidental information, such as a user's name; however, you should avoid storing any sensitive information using non-signed cookies as it's easy for people to access and change the data.</p></div></div></body></html>