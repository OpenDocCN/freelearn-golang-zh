- en: Handling the response from the provider
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理来自提供者的响应
- en: Once the user clicks on **Accept** on the provider's website (or if they click
    on the equivalent of **Cancel**), they will be redirected to the callback endpoint
    in our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在提供者网站上点击 **接受**（或如果他们点击了相当于 **取消** 的选项），他们将被重定向到我们应用程序中的回调端点。
- en: 'A quick glance at the complete URL that comes back shows us the grant code
    that the provider has given us:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看返回的完整 URL 可以显示我们提供者给出的授权代码：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We don't have to worry about what to do with this code because Gomniauth does
    it for us; we can simply jump to implementing our callback handler. However, it's
    worth knowing that this code will be exchanged by the authentication provider
    for a token that allows us to access private user data. For added security, this
    additional step happens behind the scenes, from server to server rather than in
    the browser.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必担心如何处理这段代码，因为 Gomniauth 会为我们处理；我们只需简单地跳转到实现我们的回调处理程序。然而，了解这一点是有价值的，即这段代码将由身份验证提供者交换为允许我们访问私有用户数据的令牌。为了增加安全性，这一额外步骤是在服务器之间幕后发生的，而不是在浏览器中。
- en: 'In `auth.go`, we are ready to add another switch case to our action path segment.
    Insert the following code before the default case:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `auth.go` 文件中，我们准备在我们的操作路径段中添加另一个 switch case。在默认 case 之前插入以下代码：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the authentication provider redirects the users after they have granted
    permission, the URL specifies that it is a callback action. We look up the authentication
    provider as we did before and call its `CompleteAuth` method. We parse `RawQuery`
    from the request into `objx.Map` (the multipurpose map type that Gomniauth uses),
    and the `CompleteAuth` method uses the values to complete the OAuth2 provider
    handshake with the provider. All being well, we will be given some authorized
    credentials with which we will be able to access our user's basic data. We then
    use the `GetUser` method for the provider, and Gomniauth will use the specified
    credentials to access some basic information about the user.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当身份验证提供者在用户授予权限后重定向用户时，URL 指定这是一个回调操作。我们像之前一样查找身份验证提供者，并调用其 `CompleteAuth` 方法。我们将请求中的
    `RawQuery` 解析到 `objx.Map`（Gomniauth 使用的多功能映射类型），`CompleteAuth` 方法使用这些值与提供者完成 OAuth2
    提供者握手。一切顺利的话，我们将获得一些授权凭证，我们可以用这些凭证访问我们用户的基本数据。然后我们使用提供者的 `GetUser` 方法，Gomniauth
    将使用指定的凭证访问有关用户的一些基本信息。
- en: Once we have the user data, we **Base64-encode** the `Name` field in a JSON
    object and store it as a value for our `auth` cookie for later use.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了用户数据，我们将 JSON 对象中的 `Name` 字段 **Base64 编码**，并将其存储为我们的 `auth` cookie 的值以供以后使用。
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Base64-encoding data ensures it won't contain any special or unpredictable characters,
    which is useful for situations such as passing data to a URL or storing it in
    a cookie. Remember that although Base64-encoded data looks encrypted, it is not
    you can easily decode Base64-encoded data back to the original text with little
    effort. There are online tools that do this for you.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Base64 编码数据确保它不会包含任何特殊或不可预测的字符，这在将数据传递到 URL 或存储在 cookie 中的情况下很有用。记住，尽管 Base64
    编码的数据看起来是加密的，但你仍然可以轻松地将 Base64 编码的数据解码回原始文本，只需一点努力。有一些在线工具可以为你做这件事。
- en: After setting the cookie, we redirect the user to the chat page, which we can
    safely assume was the original destination.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 cookie 后，我们将用户重定向到聊天页面，我们可以安全地假设这是原始目的地。
- en: 'Once you build and run the code again and hit the `/chat` page, you will notice
    that the sign up flow works and we are finally allowed back to the chat page.
    Most browsers have an inspector or a console—a tool that allows you to view the
    cookies that the server has sent you-that you can use to see whether the `auth`
    cookie has appeared:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建并运行代码后，点击 `/chat` 页面，你会注意到注册流程正常工作，我们最终被允许返回到聊天页面。大多数浏览器都有一个检查器或控制台——这是一个允许你查看服务器发送给你的
    cookie 的工具——你可以用它来查看 `auth` cookie 是否出现：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In our case, the cookie value is `eyJuYW1lIjoiTWF0IFJ5ZXIifQ==`, which is a
    Base64-encoded version of `{"name":"Mat Ryer"}`. Remember, we never typed in a
    name in our chat application; instead, Gomniauth asked Google for a name when
    we opted to sign in with Google. Storing non-signed cookies like this is fine
    for incidental information, such as a user's name; however, you should avoid storing
    any sensitive information using non-signed cookies as it's easy for people to
    access and change the data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这个例子中，cookie的值是`eyJuYW1lIjoiTWF0IFJ5ZXIifQ==`，这是`{"name":"Mat Ryer"}`的Base64编码版本。记住，我们从未在我们的聊天应用中输入过名字；相反，当我们选择使用Google登录时，Gomniauth向Google请求了一个名字。存储这样的非签名cookie对于偶然信息，如用户的名字，是可以的；然而，你应该避免使用非签名cookie存储任何敏感信息，因为这很容易被他人访问和更改数据。
