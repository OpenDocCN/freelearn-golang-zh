- en: Handling the response from the provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the user clicks on **Accept** on the provider's website (or if they click
    on the equivalent of **Cancel**), they will be redirected to the callback endpoint
    in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick glance at the complete URL that comes back shows us the grant code
    that the provider has given us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We don't have to worry about what to do with this code because Gomniauth does
    it for us; we can simply jump to implementing our callback handler. However, it's
    worth knowing that this code will be exchanged by the authentication provider
    for a token that allows us to access private user data. For added security, this
    additional step happens behind the scenes, from server to server rather than in
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `auth.go`, we are ready to add another switch case to our action path segment.
    Insert the following code before the default case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When the authentication provider redirects the users after they have granted
    permission, the URL specifies that it is a callback action. We look up the authentication
    provider as we did before and call its `CompleteAuth` method. We parse `RawQuery`
    from the request into `objx.Map` (the multipurpose map type that Gomniauth uses),
    and the `CompleteAuth` method uses the values to complete the OAuth2 provider
    handshake with the provider. All being well, we will be given some authorized
    credentials with which we will be able to access our user's basic data. We then
    use the `GetUser` method for the provider, and Gomniauth will use the specified
    credentials to access some basic information about the user.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the user data, we **Base64-encode** the `Name` field in a JSON
    object and store it as a value for our `auth` cookie for later use.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Base64-encoding data ensures it won't contain any special or unpredictable characters,
    which is useful for situations such as passing data to a URL or storing it in
    a cookie. Remember that although Base64-encoded data looks encrypted, it is not
    you can easily decode Base64-encoded data back to the original text with little
    effort. There are online tools that do this for you.
  prefs: []
  type: TYPE_NORMAL
- en: After setting the cookie, we redirect the user to the chat page, which we can
    safely assume was the original destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you build and run the code again and hit the `/chat` page, you will notice
    that the sign up flow works and we are finally allowed back to the chat page.
    Most browsers have an inspector or a console—a tool that allows you to view the
    cookies that the server has sent you-that you can use to see whether the `auth`
    cookie has appeared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In our case, the cookie value is `eyJuYW1lIjoiTWF0IFJ5ZXIifQ==`, which is a
    Base64-encoded version of `{"name":"Mat Ryer"}`. Remember, we never typed in a
    name in our chat application; instead, Gomniauth asked Google for a name when
    we opted to sign in with Google. Storing non-signed cookies like this is fine
    for incidental information, such as a user's name; however, you should avoid storing
    any sensitive information using non-signed cookies as it's easy for people to
    access and change the data.
  prefs: []
  type: TYPE_NORMAL
