<html><head></head><body>
<div class="book" title="Implementing external logging in">
<div class="book" title="Augmenting messages with additional data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec0027" class="calibre1"/>Augmenting messages with additional data</h2></div></div></div><p class="calibre10">So far, our chat application has only transmitted messages as slices of bytes or <code class="email">[]byte</code> types between the client and the server; therefore, the forward channel for our room has the <code class="email">chan []byte</code> type. In order to send data (such as who sent it and when) in addition to the message itself, we enhance our forward channel and also how we interact with the web socket on both ends.</p><p class="calibre10">Define a new type that will replace the <code class="email">[]byte</code> slice by creating a new file called <code class="email">message.go</code> in the <code class="email">chat</code> folder:</p><pre class="programlisting">package main 
import ( 
  "time" 
) 
// message represents a single message 
type message struct { 
  Name    string 
  Message string 
  When    time.Time 
} 
</pre><p class="calibre10">The <code class="email">message</code> type will encapsulate the message string itself, but we have also added the <code class="email">Name</code> and <code class="email">When</code> fields that respectively hold the user's name and a timestamp of when the message was sent.</p><p class="calibre10">Since the <code class="email">client</code> type is responsible for communicating with the browser, it needs to transmit and receive more than just a single message string. As we are talking to a JavaScript application (that is, the chat client running in the browser) and the Go standard library has a great JSON implementation, this seems like the perfect choice to encode additional information in the messages. We will change the <code class="email">read</code> and <code class="email">write</code> methods in <code class="email">client.go</code> to use the <code class="email">ReadJSON</code> and <code class="email">WriteJSON</code> methods on the socket, and we will encode and decode our new <code class="email">message</code> type:</p><pre class="programlisting">func (c *client) read() { 
  defer c.socket.Close() 
  for { 
    var msg *message 
    err := c.socket.ReadJSON(&amp;msg) 
    if err != nil { 
      return 
    } 
    msg.When = time.Now() 
    msg.Name = c.userData["name"].(string) 
    c.room.forward &lt;- msg  
} 
}  
func (c *client) write() { 
  defer c.socket.Close() 
  for msg := range c.send { 
    err := c.socket.WriteJSON(msg) 
    if err != nil { 
      break 
    } 
  } 
} 
</pre><p class="calibre10">When we receive a message from the browser, we will expect to populate only the <code class="email">Message</code> field, which is why we set the <code class="email">When</code> and <code class="email">Name</code> fields ourselves in the preceding code.</p><p class="calibre10">You will notice that when you try to build the preceding code, it complains about a few things. The main reason is that we are trying to send a <code class="email">*message</code> object down our <code class="email">forward</code> and <code class="email">send chan []byte</code> channels. This is not allowed until we change the type of the channel. In <code class="email">room.go</code>, change the <code class="email">forward</code> field to be of the type <code class="email">chan *message</code>, and do the same for the <code class="email">send chan</code> type in <code class="email">client.go</code>.</p><p class="calibre10">We must update the code that initializes our channels since the types have now changed. Alternatively, you can wait for the compiler to raise these issues and fix them as you go. In <code class="email">room.go</code>, you need to make the following changes:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Change <code class="email">forward: make(chan []byte)</code> to <code class="email">forward: make(chan *message)</code></li><li class="listitem">Change <code class="email">r.tracer.Trace("Message received: ", string(msg))</code> to <code class="email">r.tracer.Trace("Message received: ", msg.Message)</code></li><li class="listitem">Change <code class="email">send: make(chan []byte, messageBufferSize)</code> to <code class="email">send: make(chan *message, messageBufferSize)</code></li></ul></div><p class="calibre10">The compiler will also complain about the lack of user data on the client, which is a fair point because the <code class="email">client</code> type has no idea about the new user data we have added to the cookie. Update the <code class="email">client</code> struct to include a new general-purpose <code class="email">map[string]interface{}</code> called <code class="email">userData</code>:</p><pre class="programlisting">// client represents a single chatting user. 
type client struct { 
  // socket is the web socket for this client. 
  socket *websocket.Conn 
  // send is a channel on which messages are sent. 
  send chan *message 
  // room is the room this client is chatting in. 
  room *room 
  // userData holds information about the user 
  userData map[string]interface{} 
} 
</pre><p class="calibre10">The user data comes from the client cookie that we access through the <code class="email">http.Request</code> object's <code class="email">Cookie</code> method. In <code class="email">room.go</code>, update <code class="email">ServeHTTP</code> with the following changes:</p><pre class="programlisting">func (r *room) ServeHTTP(w http.ResponseWriter, req *http.Request) { 
  socket, err := upgrader.Upgrade(w, req, nil) 
  if err != nil { 
    log.Fatal("ServeHTTP:", err) 
    return 
  } 
  authCookie, err := req.Cookie("auth") 
  if err != nil { 
    log.Fatal("Failed to get auth cookie:", err) 
    return 
  } 
  client := &amp;client{ 
    socket:   socket, 
    send:     make(chan *message, messageBufferSize), 
    room:     r, 
    userData: objx.MustFromBase64(authCookie.Value), 
  } 
  r.join &lt;- client 
  defer func() { r.leave &lt;- client }() 
  go client.write() 
  client.read() 
} 
</pre><p class="calibre10">We use the <code class="email">Cookie</code> method on the <code class="email">http.Request</code> type to get our user data before passing it to the client. We are using the <code class="email">objx.MustFromBase64</code> method to convert our encoded cookie value back into a usable map object.</p><p class="calibre10">Now that we have changed the type being sent and received on the socket from <code class="email">[]byte</code> to <code class="email">*message</code>, we must tell our JavaScript client that we are sending JSON instead of just a plain string. Also, we must ask that it send JSON back to the server when a user submits a message. In <code class="email">chat.html</code>, first update the <code class="email">socket.send</code> call:</p><pre class="programlisting">socket.send(JSON.stringify({"Message": msgBox.val()})); 
</pre><p class="calibre10">We are using <code class="email">JSON.stringify</code> to serialize the specified JSON object (containing just the <code class="email">Message</code> field) into a string, which is then sent to the server. Our Go code will decode (or unmarshal) the JSON string into a <code class="email">message</code> object, matching the field names from the client JSON object with those of our <code class="email">message</code> type.</p><p class="calibre10">Finally, update the <code class="email">socket.onmessage</code> callback function to expect JSON, and also add the name of the sender to the page:</p><pre class="programlisting">socket.onmessage = function(e) { 
  var msg = JSON.parse(e.data); 
  messages.append( 
    $("&lt;li&gt;").append( 
      $("&lt;strong&gt;").text(msg.Name + ": "), 
      $("&lt;span&gt;").text(msg.Message) 
    ) 
  ); 
} 
</pre><p class="calibre10">In the preceding code snippet, we used JavaScript's <code class="email">JSON.parse</code> function to turn the JSON string into a JavaScript object and then access the fields to build up the elements needed to properly display them.</p><p class="calibre10">Build and run the application, and if you can, log in with two different accounts in two different browsers (or invite a friend to help you test it):</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go build -o chat</strong></span>
<span class="strong"><strong class="calibre2">./chat -host=":8080"</strong></span>
</pre><p class="calibre10">The following screenshot shows the chat application's browser chat screens:</p><p class="calibre10">
</p><div class="mediaobject"><img src="../images/00050.jpeg" alt="Augmenting messages with additional data" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">
</p></div></div></body></html>