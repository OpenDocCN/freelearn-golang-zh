- en: Augmenting messages with additional data
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增强消息以包含附加数据
- en: So far, our chat application has only transmitted messages as slices of bytes
    or `[]byte` types between the client and the server; therefore, the forward channel
    for our room has the `chan []byte` type. In order to send data (such as who sent
    it and when) in addition to the message itself, we enhance our forward channel
    and also how we interact with the web socket on both ends.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的聊天应用程序只在客户端和服务器之间以字节切片或`[]byte`类型传输消息；因此，我们房间的前进通道具有`chan []byte`类型。为了在消息本身之外发送数据（例如谁发送了它以及何时发送），我们增强了我们的前进通道，并且也增强了我们在两端与WebSocket的交互方式。
- en: 'Define a new type that will replace the `[]byte` slice by creating a new file
    called `message.go` in the `chat` folder:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个新的类型，通过在`chat`文件夹中创建一个名为`message.go`的新文件来替换`[]byte`切片：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `message` type will encapsulate the message string itself, but we have also
    added the `Name` and `When` fields that respectively hold the user's name and
    a timestamp of when the message was sent.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`message`类型将封装消息字符串本身，但我们还添加了`Name`和`When`字段，分别用于存储用户的名称和消息发送的时间戳。'
- en: 'Since the `client` type is responsible for communicating with the browser,
    it needs to transmit and receive more than just a single message string. As we
    are talking to a JavaScript application (that is, the chat client running in the
    browser) and the Go standard library has a great JSON implementation, this seems
    like the perfect choice to encode additional information in the messages. We will
    change the `read` and `write` methods in `client.go` to use the `ReadJSON` and
    `WriteJSON` methods on the socket, and we will encode and decode our new `message`
    type:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`client`类型负责与浏览器进行通信，它需要传输和接收的不仅仅是单个消息字符串。因为我们正在与一个JavaScript应用程序（即运行在浏览器中的聊天客户端）进行通信，而Go标准库有一个出色的JSON实现，这似乎是将附加信息编码在消息中的完美选择。我们将更改`client.go`中的`read`和`write`方法，以使用套接字上的`ReadJSON`和`WriteJSON`方法，并将编码和解码我们的新`message`类型：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When we receive a message from the browser, we will expect to populate only
    the `Message` field, which is why we set the `When` and `Name` fields ourselves
    in the preceding code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从浏览器接收消息时，我们期望只填充`Message`字段，这就是为什么我们在前面的代码中自己设置了`When`和`Name`字段。
- en: You will notice that when you try to build the preceding code, it complains
    about a few things. The main reason is that we are trying to send a `*message`
    object down our `forward` and `send chan []byte` channels. This is not allowed
    until we change the type of the channel. In `room.go`, change the `forward` field
    to be of the type `chan *message`, and do the same for the `send chan` type in
    `client.go`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试构建前面的代码时，你会注意到一些问题。主要原因是我们试图通过`forward`和`send chan []byte`通道发送`*message`对象。在我们更改通道类型之前，这是不允许的。在`room.go`中，将`forward`字段更改为`chan
    *message`类型，并在`client.go`中对`send chan`类型做同样的更改。
- en: 'We must update the code that initializes our channels since the types have
    now changed. Alternatively, you can wait for the compiler to raise these issues
    and fix them as you go. In `room.go`, you need to make the following changes:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须更新初始化我们的通道的代码，因为类型已经更改。或者，你可以等待编译器提出这些问题，并在过程中修复它们。在`room.go`中，你需要进行以下更改：
- en: 'Change `forward: make(chan []byte)` to `forward: make(chan *message)`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将`forward: make(chan []byte)`更改为`forward: make(chan *message)`'
- en: 'Change `r.tracer.Trace("Message received: ", string(msg))` to `r.tracer.Trace("Message
    received: ", msg.Message)`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将`r.tracer.Trace("Message received: ", string(msg))`更改为`r.tracer.Trace("Message
    received: ", msg.Message)`'
- en: 'Change `send: make(chan []byte, messageBufferSize)` to `send: make(chan *message,
    messageBufferSize)`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将`send: make(chan []byte, messageBufferSize)`更改为`send: make(chan *message,
    messageBufferSize)`'
- en: 'The compiler will also complain about the lack of user data on the client,
    which is a fair point because the `client` type has no idea about the new user
    data we have added to the cookie. Update the `client` struct to include a new
    general-purpose `map[string]interface{}` called `userData`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器还会抱怨客户端缺少用户数据，这是一个合理的观点，因为`client`类型对我们添加到cookie中的新用户数据一无所知。更新`client`结构体以包含一个新的通用`map[string]interface{}`，称为`userData`：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The user data comes from the client cookie that we access through the `http.Request`
    object''s `Cookie` method. In `room.go`, update `ServeHTTP` with the following
    changes:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 用户数据来自我们通过`http.Request`对象的`Cookie`方法访问的客户端cookie。在`room.go`中，更新`ServeHTTP`如下：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We use the `Cookie` method on the `http.Request` type to get our user data before
    passing it to the client. We are using the `objx.MustFromBase64` method to convert
    our encoded cookie value back into a usable map object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`http.Request`类型的`Cookie`方法在传递给客户端之前获取我们的用户数据。我们使用`objx.MustFromBase64`方法将我们的编码cookie值转换回可用的map对象。
- en: 'Now that we have changed the type being sent and received on the socket from
    `[]byte` to `*message`, we must tell our JavaScript client that we are sending
    JSON instead of just a plain string. Also, we must ask that it send JSON back
    to the server when a user submits a message. In `chat.html`, first update the
    `socket.send` call:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将socket上发送和接收的类型从`[]byte`更改为`*message`，我们必须通知我们的JavaScript客户端我们现在发送的是JSON而不是纯字符串。此外，我们还要求它在用户提交消息时将JSON发送回服务器。在`chat.html`中，首先更新`socket.send`调用：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are using `JSON.stringify` to serialize the specified JSON object (containing
    just the `Message` field) into a string, which is then sent to the server. Our
    Go code will decode (or unmarshal) the JSON string into a `message` object, matching
    the field names from the client JSON object with those of our `message` type.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`JSON.stringify`将指定的JSON对象（仅包含`Message`字段）序列化为字符串，然后将该字符串发送到服务器。我们的Go代码将解码（或反序列化）JSON字符串到`message`对象，将客户端JSON对象中的字段名称与我们的`message`类型中的字段名称相匹配。
- en: 'Finally, update the `socket.onmessage` callback function to expect JSON, and
    also add the name of the sender to the page:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新`socket.onmessage`回调函数，使其期望接收JSON，并将发送者的名字添加到页面中：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Build and run the application, and if you can, log in with two different accounts
    in two different browsers (or invite a friend to help you test it):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序，如果可能的话，在两个不同的浏览器中使用两个不同的账户登录（或者邀请一个朋友帮助你测试它）：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following screenshot shows the chat application''s browser chat screens:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了聊天应用的浏览器聊天界面：
- en: '![Augmenting messages with additional data](img/00050.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![使用附加数据增强消息](img/00050.jpeg)'
