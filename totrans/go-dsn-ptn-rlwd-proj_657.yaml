- en: Augmenting messages with additional data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, our chat application has only transmitted messages as slices of bytes
    or `[]byte` types between the client and the server; therefore, the forward channel
    for our room has the `chan []byte` type. In order to send data (such as who sent
    it and when) in addition to the message itself, we enhance our forward channel
    and also how we interact with the web socket on both ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a new type that will replace the `[]byte` slice by creating a new file
    called `message.go` in the `chat` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `message` type will encapsulate the message string itself, but we have also
    added the `Name` and `When` fields that respectively hold the user's name and
    a timestamp of when the message was sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `client` type is responsible for communicating with the browser,
    it needs to transmit and receive more than just a single message string. As we
    are talking to a JavaScript application (that is, the chat client running in the
    browser) and the Go standard library has a great JSON implementation, this seems
    like the perfect choice to encode additional information in the messages. We will
    change the `read` and `write` methods in `client.go` to use the `ReadJSON` and
    `WriteJSON` methods on the socket, and we will encode and decode our new `message`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When we receive a message from the browser, we will expect to populate only
    the `Message` field, which is why we set the `When` and `Name` fields ourselves
    in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that when you try to build the preceding code, it complains
    about a few things. The main reason is that we are trying to send a `*message`
    object down our `forward` and `send chan []byte` channels. This is not allowed
    until we change the type of the channel. In `room.go`, change the `forward` field
    to be of the type `chan *message`, and do the same for the `send chan` type in
    `client.go`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must update the code that initializes our channels since the types have
    now changed. Alternatively, you can wait for the compiler to raise these issues
    and fix them as you go. In `room.go`, you need to make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change `forward: make(chan []byte)` to `forward: make(chan *message)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Change `r.tracer.Trace("Message received: ", string(msg))` to `r.tracer.Trace("Message
    received: ", msg.Message)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Change `send: make(chan []byte, messageBufferSize)` to `send: make(chan *message,
    messageBufferSize)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The compiler will also complain about the lack of user data on the client,
    which is a fair point because the `client` type has no idea about the new user
    data we have added to the cookie. Update the `client` struct to include a new
    general-purpose `map[string]interface{}` called `userData`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The user data comes from the client cookie that we access through the `http.Request`
    object''s `Cookie` method. In `room.go`, update `ServeHTTP` with the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We use the `Cookie` method on the `http.Request` type to get our user data before
    passing it to the client. We are using the `objx.MustFromBase64` method to convert
    our encoded cookie value back into a usable map object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have changed the type being sent and received on the socket from
    `[]byte` to `*message`, we must tell our JavaScript client that we are sending
    JSON instead of just a plain string. Also, we must ask that it send JSON back
    to the server when a user submits a message. In `chat.html`, first update the
    `socket.send` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We are using `JSON.stringify` to serialize the specified JSON object (containing
    just the `Message` field) into a string, which is then sent to the server. Our
    Go code will decode (or unmarshal) the JSON string into a `message` object, matching
    the field names from the client JSON object with those of our `message` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, update the `socket.onmessage` callback function to expect JSON, and
    also add the name of the sender to the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the application, and if you can, log in with two different accounts
    in two different browsers (or invite a friend to help you test it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the chat application''s browser chat screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Augmenting messages with additional data](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
