<html><head></head><body><div class="book" title="Summary" id="4SCS81-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec0018" class="calibre1"/>Summary</h1></div></div></div><p class="calibre10">In this chapter, we added a useful and necessary feature to our chat application by asking users to authenticate themselves using OAuth2 service providers before we allow them to join the conversation. We made use of several open source packages, such as <code class="email">Gomniauth</code>, which dramatically reduced the amount of multiserver complexity we would otherwise have dealt with.</p><p class="calibre10">We implemented a pattern when we wrapped <code class="email">http.Handler</code> types to allow us to easily specify which paths require the user to be authenticated and which were available, even without an <code class="email">auth</code> cookie. Our <code class="email">MustAuth</code> helper function allowed us to generate the wrapper types in a fluent and simple way, without adding clutter and confusion to our code.</p><p class="calibre10">We saw how to use cookies and Base64-encoding to safely (although not securely) store the state of particular users in their respective browsers and to make use of that data over normal connections and through web sockets. We took more control of the data available to our templates in order to provide the name of the user to the UI and saw how to only provide certain data under specific conditions.</p><p class="calibre10">Since we needed to send and receive additional information over the web socket, we learned how easy it was to change the channels of native types into channels that work with types of our own, such as our <code class="email">message</code> type. We also learned how to transmit JSON objects over the socket, rather than just slices of bytes. Thanks to the type safety of Go and the ability to specify types for channels, the compiler helps ensure that we do not send anything other than <code class="email">message</code> objects through <code class="email">chan *message</code>. Attempting to do so would result in a compiler error, alerting us to the fact right away.</p><p class="calibre10">From building a chat application to seeing the name of the person chatting is a great leap forward in terms of usability. But it's very formal and might not attract modern users of the Web, who are used to a much more visual experience. We are missing pictures of people chatting, and in the next chapter, we will explore different ways in which this could be done. We can allow users to better represent themselves in our application by pulling profile pictures (avatars) from the OAuth2 provider, the Gravatar web service, or the local disk after the users have uploaded them.</p><p class="calibre10">As an extra assignment, see whether you can make use of the <code class="email">time.Time</code> field that we put into the <code class="email">message</code> type to tell users when the messages were sent.</p></div></body></html>