- en: Summary
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added a useful and necessary feature to our chat application
    by asking users to authenticate themselves using OAuth2 service providers before
    we allow them to join the conversation. We made use of several open source packages,
    such as `Gomniauth`, which dramatically reduced the amount of multiserver complexity
    we would otherwise have dealt with.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过要求用户在使用 OAuth2 服务提供商进行身份验证后才能加入对话，为我们聊天应用添加了一个有用且必要的功能。我们使用了几个开源包，如
    `Gomniauth`，这大大减少了我们本应处理的跨服务器复杂度。
- en: We implemented a pattern when we wrapped `http.Handler` types to allow us to
    easily specify which paths require the user to be authenticated and which were
    available, even without an `auth` cookie. Our `MustAuth` helper function allowed
    us to generate the wrapper types in a fluent and simple way, without adding clutter
    and confusion to our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个模式，当我们包装 `http.Handler` 类型时，可以轻松指定哪些路径需要用户进行身份验证，哪些是可用的，即使没有 `auth` cookie。我们的
    `MustAuth` 辅助函数允许我们以流畅和简单的方式生成包装类型，而不会给我们的代码增加混乱和困惑。
- en: We saw how to use cookies and Base64-encoding to safely (although not securely)
    store the state of particular users in their respective browsers and to make use
    of that data over normal connections and through web sockets. We took more control
    of the data available to our templates in order to provide the name of the user
    to the UI and saw how to only provide certain data under specific conditions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用 cookies 和 Base64 编码来安全（尽管不是安全地）存储特定用户在其各自的浏览器中的状态，并利用这些数据在正常连接和通过
    WebSocket 中。我们更多地控制了模板可用的数据，以便将用户名提供给 UI，并看到了如何在特定条件下仅提供某些数据。
- en: Since we needed to send and receive additional information over the web socket,
    we learned how easy it was to change the channels of native types into channels
    that work with types of our own, such as our `message` type. We also learned how
    to transmit JSON objects over the socket, rather than just slices of bytes. Thanks
    to the type safety of Go and the ability to specify types for channels, the compiler
    helps ensure that we do not send anything other than `message` objects through
    `chan *message`. Attempting to do so would result in a compiler error, alerting
    us to the fact right away.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要通过 WebSocket 发送和接收额外的信息，我们了解到将原生类型的通道转换为与我们的自定义类型（如我们的 `message` 类型）一起工作的通道是多么容易。我们还学会了如何在套接字上传输
    JSON 对象，而不仅仅是字节的切片。得益于 Go 的类型安全性和为通道指定类型的能力，编译器帮助我们确保不会通过 `chan *message` 发送除
    `message` 对象之外的内容。尝试这样做会导致编译器错误，立即提醒我们这一点。
- en: From building a chat application to seeing the name of the person chatting is
    a great leap forward in terms of usability. But it's very formal and might not
    attract modern users of the Web, who are used to a much more visual experience.
    We are missing pictures of people chatting, and in the next chapter, we will explore
    different ways in which this could be done. We can allow users to better represent
    themselves in our application by pulling profile pictures (avatars) from the OAuth2
    provider, the Gravatar web service, or the local disk after the users have uploaded
    them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从构建聊天应用到现在可以看到聊天者的名字，在可用性方面是一个巨大的进步。但它非常正式，可能不会吸引习惯于更视觉体验的现代网络用户。我们缺少聊天者的图片，在下一章中，我们将探讨不同的方法来实现这一点。我们可以通过从
    OAuth2 提供商、Gravatar 网络服务或本地磁盘（用户上传后）拉取个人资料图片（头像）来让用户更好地在我们的应用中代表自己。
- en: As an extra assignment, see whether you can make use of the `time.Time` field
    that we put into the `message` type to tell users when the messages were sent.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外作业，看看你是否可以利用我们放入 `message` 类型的 `time.Time` 字段来告诉用户消息是在何时发送的。
