<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;3.&#xA0;Three Ways to Implement Profile Pictures"><div class="book" id="4TBCQ2-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch25" class="calibre1"/>Chapter 3. Three Ways to Implement Profile Pictures</h1></div></div></div><p class="calibre10">So far, our chat application has made use of the <span class="strong"><strong class="calibre2">OAuth2</strong></span> protocol to allow users to sign in to our application so that we know who is saying what. In this chapter, we are going to add profile pictures to make the chatting experience more engaging.</p><p class="calibre10">We will look at the following ways to add pictures or avatars alongside the messages in our application:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Using the avatar picture provided by the auth service</li><li class="listitem">Using the <a class="calibre1" href="https://en.gravatar.com/">https://en.gravatar.com/</a> web service to look up a picture by the user's e-mail address</li><li class="listitem">Allowing the user to upload their own picture and host it themselves</li></ul></div><p class="calibre10">The first two options allow us to delegate the hosting of pictures to a third party either an authorization service or <a class="calibre1" href="https://en.gravatar.com/">https://en.gravatar.com/</a> which is great because it reduces the cost of hosting our application (in terms of storage costs and bandwidth, since the user's browsers will actually download the pictures from the servers of the authenticating service, not ours). The third option requires us to host pictures ourselves at a location that is accessible on the Web.</p><p class="calibre10">These options aren't mutually exclusive; you will most likely use a combination of them in a real-world production application. Toward the end of the chapter, you will see how the flexible design that emerges allows us to try each implementation in turn until we find an appropriate avatar.</p><p class="calibre10">We are going to be agile with our design throughout this chapter, doing the minimum work needed to accomplish each milestone. This means that at the end of each section, we will have working implementations that are demonstrable in the browser. This also means that we will refactor code as and when we need to and discuss the rationale behind the decisions we make as we go.</p><p class="calibre10">Specifically, in this chapter, you will learn:</p><div class="book"><ul class="itemizedlist"><li class="listitem">What the good practices to get additional information from auth services are, even when there are no standards in place</li><li class="listitem">When it is appropriate to build abstractions into our code</li><li class="listitem">How Go's zero-initialization pattern can save time and memory</li><li class="listitem">How reusing an interface allows us to work with collections and individual objects in the same way as the existing interface did</li><li class="listitem">How to use the <a class="calibre1" href="https://en.gravatar.com/">https://en.gravatar.com/</a> web service</li><li class="listitem">How to do MD5 hashing in Go</li><li class="listitem">How to upload files over HTTP and store them on a server</li><li class="listitem">How to serve static files through a Go web server</li><li class="listitem">How to use unit tests to guide the refactoring of code</li><li class="listitem">How and when to abstract functionality from <code class="email">struct</code> types into interfaces</li></ul></div></div></body></html>