- en: Chapter 3. Three Ways to Implement Profile Pictures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our chat application has made use of the **OAuth2** protocol to allow
    users to sign in to our application so that we know who is saying what. In this
    chapter, we are going to add profile pictures to make the chatting experience
    more engaging.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at the following ways to add pictures or avatars alongside the
    messages in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the avatar picture provided by the auth service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the [https://en.gravatar.com/](https://en.gravatar.com/) web service to
    look up a picture by the user's e-mail address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing the user to upload their own picture and host it themselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two options allow us to delegate the hosting of pictures to a third
    party either an authorization service or [https://en.gravatar.com/](https://en.gravatar.com/) which
    is great because it reduces the cost of hosting our application (in terms of storage
    costs and bandwidth, since the user's browsers will actually download the pictures
    from the servers of the authenticating service, not ours). The third option requires
    us to host pictures ourselves at a location that is accessible on the Web.
  prefs: []
  type: TYPE_NORMAL
- en: These options aren't mutually exclusive; you will most likely use a combination
    of them in a real-world production application. Toward the end of the chapter,
    you will see how the flexible design that emerges allows us to try each implementation
    in turn until we find an appropriate avatar.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to be agile with our design throughout this chapter, doing the
    minimum work needed to accomplish each milestone. This means that at the end of
    each section, we will have working implementations that are demonstrable in the
    browser. This also means that we will refactor code as and when we need to and
    discuss the rationale behind the decisions we make as we go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, you will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: What the good practices to get additional information from auth services are,
    even when there are no standards in place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it is appropriate to build abstractions into our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Go's zero-initialization pattern can save time and memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How reusing an interface allows us to work with collections and individual objects
    in the same way as the existing interface did
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the [https://en.gravatar.com/](https://en.gravatar.com/) web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do MD5 hashing in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to upload files over HTTP and store them on a server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to serve static files through a Go web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use unit tests to guide the refactoring of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How and when to abstract functionality from `struct` types into interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
