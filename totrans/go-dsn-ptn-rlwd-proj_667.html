<html><head></head><body>
<div class="book" title="Implementing Gravatar">
<div class="book" title="Abstracting the avatar URL process"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec0033" class="calibre1"/>Abstracting the avatar URL process</h2></div></div></div><p class="calibre10">Since we have three different ways of obtaining the avatar URL in our application, we have reached the point where it would be sensible to learn how to abstract the functionality in order to cleanly implement the options. Abstraction refers to a process in which we separate the idea of something from its specific implementation. The <code class="email">http.Handler</code> method is a great example of how a handler will be used along with its ins and outs, without being specific about what action is taken by each handler.</p><p class="calibre10">In Go, we start to describe our idea of getting an avatar URL by defining an interface. Let's create a new file called <code class="email">avatar.go</code> and insert the following code:</p><pre class="programlisting">package main 
import ( 
  "errors" 
) 
// ErrNoAvatar is the error that is returned when the 
// Avatar instance is unable to provide an avatar URL. 
var ErrNoAvatarURL = errors.New("chat: Unable to get an avatar  URL.") 
// Avatar represents types capable of representing 
// user profile pictures. 
type Avatar interface { 
  // GetAvatarURL gets the avatar URL for the specified client, 
  // or returns an error if something goes wrong. 
  // ErrNoAvatarURL is returned if the object is unable to get 
  // a URL for the specified client. 
  GetAvatarURL(c *client) (string, error) 
} 
</pre><p class="calibre10">The <code class="email">Avatar</code> interface describes the <code class="email">GetAvatarURL</code> method that a type must satisfy in order to be able to get avatar URLs. We took the client as an argument so that we know the user for which the URL to be returned. The method returns two arguments: a string (which will be the URL if things go well) and an error in case something goes wrong.</p><p class="calibre10">One of the things that could go wrong is simply that one of the specific implementations of <code class="email">Avatar</code> is unable to get the URL. In that case, <code class="email">GetAvatarURL</code> will return the <code class="email">ErrNoAvatarURL</code> error as the second argument. The <code class="email">ErrNoAvatarURL</code> error therefore becomes a part of the interface; it's one of the possible returns from the method and something that users of our code should probably explicitly handle. We mention this in the comments part of the code for the method, which is the only way to communicate such design decisions in Go.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip40" class="calibre1"/>Tip</h3><p class="calibre10">Because the error is initialized immediately using <code class="email">errors.New</code> and stored in the <code class="email">ErrNoAvatarURL</code> variable, only one of these objects will ever be created; passing the pointer of the error as a return is inexpensive. This is unlike Java's checked exceptions which serve a similar purpose where expensive exception objects are created and used as part of the control flow.</p></div><div class="book" title="The auth service and the avatar's implementation"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec004" class="calibre1"/>The auth service and the avatar's implementation</h3></div></div></div><p class="calibre10">The first implementation of <code class="email">Avatar</code> we write will replace the existing functionality where we had hardcoded the avatar URL obtained from the auth service. Let's use a <span class="strong"><strong class="calibre2">Test-driven Development</strong></span> (<span class="strong"><strong class="calibre2">TDD</strong></span>) approach so that we can be sure our code works without having to manually test it. Let's create a new file called <code class="email">avatar_test.go</code> in the <code class="email">chat</code> folder:</p><pre class="programlisting">package main 
import "testing" 
func TestAuthAvatar(t *testing.T) { 
  var authAvatar AuthAvatar 
  client := new(client) 
  url, err := authAvatar.GetAvatarURL(client) 
  if err != ErrNoAvatarURL { 
    t.Error("AuthAvatar.GetAvatarURL should return ErrNoAvatarURL 
    when no value present") 
  } 
  // set a value 
  testUrl := "http://url-to-gravatar/" 
  client.userData = map[string]interface{}{"avatar_url": testUrl} 
  url, err = authAvatar.GetAvatarURL(client) 
  if err != nil { 
    t.Error("AuthAvatar.GetAvatarURL should return no error 
    when value present") 
  } 
  if url != testUrl { 
    t.Error("AuthAvatar.GetAvatarURL should return correct URL") 
  } 
} 
</pre><p class="calibre10">This file contains a test for our as-of-yet, nonexistent <code class="email">AuthAvatar</code> type's <code class="email">GetAvatarURL</code> method. First, it uses a client with no user data and ensures that the <code class="email">ErrNoAvatarURL</code> error is returned. After setting a suitable URL, our test calls the method again this time to assert that it returns the correct value. However, building this code fails because the <code class="email">AuthAvatar</code> type doesn't exist, so we'll declare <code class="email">authAvatar</code> next.</p><p class="calibre10">Before we write our implementation, it's worth noticing that we only declare the <code class="email">authAvatar</code> variable as the <code class="email">AuthAvatar</code> type but never actually assign anything to it so its value remains <code class="email">nil</code>. This is not a mistake; we are actually making use of Go's zero-initialization (or default initialization) capabilities. Since there is no state needed for our object (we will pass <code class="email">client</code> in as an argument), there is no need to waste time and memory on initializing an instance of it. In Go, it is acceptable to call a method on a <code class="email">nil</code> object, provided that the method doesn't try to access a field. When we actually come to writing our implementation, we will look at a way in which we can ensure this is the case.</p><p class="calibre10">Let's head back over to <code class="email">avatar.go</code> and make our test pass. Add the following code at the bottom of the file:</p><pre class="programlisting">type AuthAvatar struct{} 
var UseAuthAvatar AuthAvatar 
func (AuthAvatar) GetAvatarURL(c *client) (string, error) { 
  if url, ok := c.userData["avatar_url"]; ok { 
    if urlStr, ok := url.(string); ok { 
      return urlStr, nil 
    } 
  } 
  return "", ErrNoAvatarURL 
} 
</pre><p class="calibre10">Here, we define our <code class="email">AuthAvatar</code> type as an empty struct and define the implementation of the <code class="email">GetAvatarURL</code> method. We also create a handy variable called <code class="email">UseAuthAvatar</code> that has the <code class="email">AuthAvatar</code> type but which remains of <code class="email">nil</code> value. We can later assign the <code class="email">UseAuthAvatar</code> variable to any field looking for an <code class="email">Avatar</code> interface type.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note0041" class="calibre1"/>Note</h3><p class="calibre10">The <code class="email">GetAvatarURL</code> method we wrote earlier doesn't have a very nice <span class="strong"><strong class="calibre2">line of sight</strong></span>; the happy return is buried within two <code class="email">if</code> blocks. See if you can refactor it so that the last line is <code class="email">return urlStr, nil</code> and the method exits early if the <code class="email">avatar_url</code> field is missing. You can refactor with confidence, since this code is covered by a unit test.</p><p class="calibre10">For a little more on the rationale behind this kind of refactor, refer to the article at <a class="calibre1" href="http://bit.ly/lineofsightgolang">http://bit.ly/lineofsightgolang</a>.</p></div><p class="calibre10">Normally, the receiver of a method (the type defined in parentheses before the name) will be assigned to a variable so that it can be accessed in the body of the method. Since, in our case, we assume the object can have <code class="email">nil</code> value, we can omit a variable name to tell Go to throw away the reference. This serves as an added reminder to ourselves that we should avoid using it.</p><p class="calibre10">The body of our implementation is relatively simple otherwise: we are safely looking for the value of <code class="email">avatar_url</code> and ensuring that it is a string before returning it. If anything fails, we return the <code class="email">ErrNoAvatarURL</code> error, as defined in the interface.</p><p class="calibre10">Let's run the tests by opening a terminal and then navigating to the <code class="email">chat</code> folder and typing the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go test</strong></span>
</pre><p class="calibre10">If all is well, our tests will pass and we will have successfully created our first <code class="email">Avatar</code> implementation.</p></div><div class="book" title="Using an implementation"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec005" class="calibre1"/>Using an implementation</h3></div></div></div><p class="calibre10">When we use an implementation, we could refer to either the helper variables directly or create our own instance of the interface whenever we need the functionality. However, this would defeat the object of the abstraction. Instead, we use the <code class="email">Avatar</code> interface type to indicate where we need the capability.</p><p class="calibre10">For our chat application, we will have a single way to obtain an avatar URL per chat room. So, let's update the <code class="email">room</code> type so it can hold an <code class="email">Avatar</code> object. In <code class="email">room.go</code>, add the following field definition to the <code class="email">room struct</code> type:</p><pre class="programlisting">// avatar is how avatar information will be obtained. 
avatar Avatar 
</pre><p class="calibre10">Update the <code class="email">newRoom</code> function so that we can pass in an <code class="email">Avatar</code> implementation for use; we will just assign this implementation to the new field when we create our <code class="email">room</code> instance:</p><pre class="programlisting">// newRoom makes a new room that is ready to go. 
func newRoom(avatar Avatar) *room { 
  return &amp;room{ 
    forward: make(chan *message), 
    join:    make(chan *client), 
    leave:   make(chan *client), 
    clients: make(map[*client]bool), 
    tracer:  trace.Off(), 
    avatar:  avatar, 
  } 
} 
</pre><p class="calibre10">Building the project now will highlight the fact that the call to <code class="email">newRoom</code> in <code class="email">main.go</code> is broken because we have not provided an <code class="email">Avatar</code> argument; let's update it by passing in our handy <code class="email">UseAuthAvatar</code> variable, as follows:</p><pre class="programlisting">r := newRoom(UseAuthAvatar) 
</pre><p class="calibre10">We didn't have to create an instance of <code class="email">AuthAvatar</code>, so no memory was allocated. In our case, this doesn't result in great saving (since we only have one room for our entire application), but imagine the size of the potential savings if our application has thousands of rooms. The way we named the <code class="email">UseAuthAvatar</code> variable means that the preceding code is very easy to read and it also makes our intention obvious.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip42" class="calibre1"/>Tip</h3><p class="calibre10">Thinking about code readability is important when designing interfaces. Consider a method that takes a Boolean input just passing in true or false hides the real meaning if you don't know the argument names. Consider defining a couple of helper constants, as shown in the following short example:
</p><pre class="programlisting"><code class="email">func move(animated bool) { /* ... */ } </code>
<code class="email">const Animate = true const </code>
<code class="email">DontAnimate = false</code>
</pre><p class="calibre10">
</p><p class="calibre10">Think about which of the following calls to <code class="email">move</code> are easier to understand:
</p><pre class="programlisting">

<code class="email">move(true) </code>
<code class="email"> move(false) </code>
<code class="email"> move(Animate) </code>
<code class="email"> move(DontAnimate) </code>
</pre><p class="calibre10">
</p></div><p class="calibre10">All that is left now is to change <code class="email">client</code> to use our new <code class="email">Avatar</code> interface. In <code class="email">client.go</code>, update the <code class="email">read</code> method, as follows:</p><pre class="programlisting">func (c *client) read() { 
  defer c.socket.Close() 
  for { 
    var msg *message 
    if err := c.socket.ReadJSON(&amp;msg); err != nil { 
      return 
    } 
    msg.When = time.Now() 
    msg.Name = c.userData["name"].(string) 
    msg.AvatarURL, _ = c.room.avatar.GetAvatarURL(c) 
    c.room.forward &lt;- msg 
  } 
} 
</pre><p class="calibre10">Here, we are asking the <code class="email">avatar</code> instance in <code class="email">room</code> to get the avatar URL for us instead of extracting it from <code class="email">userData</code> ourselves.</p><p class="calibre10">When you build and run the application, you will notice that (although we have refactored things a little) the behavior and user experience hasn't changed at all. This is because we told our room to use the <code class="email">AuthAvatar</code> implementation.</p><p class="calibre10">Now let's add another implementation to the room.</p></div><div class="book" title="The Gravatar implementation"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec006" class="calibre1"/>The Gravatar implementation</h3></div></div></div><p class="calibre10">The Gravatar implementation in <code class="email">Avatar</code> will do the same job as the <code class="email">AuthAvatar</code> implementation, except that it will generate a URL for a profile picture hosted on <a class="calibre1" href="https://en.gravatar.com/">https://en.gravatar.com/</a>. Let's start by adding a test to our <code class="email">avatar_test.go</code> file:</p><pre class="programlisting">func TestGravatarAvatar(t *testing.T) { 
  var gravatarAvatar GravatarAvatar 
  client := new(client) 
  client.userData = map[string]interface{}{"email": 
   "MyEmailAddress@example.com"} 
  url, err := gravatarAvatar.GetAvatarURL(client) 
  if err != nil { 
    t.Error("GravatarAvatar.GetAvatarURL should not return an error") 
  } 
  if url != "//www.gravatar.com/avatar/0bc83cb571cd1c50ba6f3e8a78ef1346" { 
    t.Errorf("GravatarAvatar.GetAvatarURL wrongly returned %s", url) 
  } 
} 
</pre><p class="calibre10">Gravatar uses a hash of the e-mail address to generate a unique ID for each profile picture, so we set up a client and ensure <code class="email">userData</code> contains an e-mail address. Next, we call the same <code class="email">GetAvatarURL</code> method, but this time on an object that has the <code class="email">GravatarAvatar</code> type. We then assert that a correct URL was returned. We already know this is the appropriate URL for the specified e-mail address because it is listed as an example in the Gravatar documentation a great strategy to ensure our code is doing what it should be doing.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip43" class="calibre1"/>Tip</h3><p class="calibre10">Remember that all the source code for this book is available for download from the publishers and has also been published on GitHub. You can save time on building the preceding core by copying and pasting bits and pieces from <a class="calibre1" href="https://github.com/matryer/goblueprints">https://github.com/matryer/goblueprints</a>. Hardcoding things such as the base URL is not usually a good idea; we have hardcoded throughout the book to make the code snippets easier to read and more obvious, but you are welcome to extract them as you go along if you like.</p></div><p class="calibre10">Running these tests (with <code class="email">go test</code>) obviously causes errors because we haven't defined our types yet. Let's head back to <code class="email">avatar.go</code> and add the following code while being sure to import the <code class="email">io</code> package:</p><pre class="programlisting">type GravatarAvatar struct{} 
var UseGravatar GravatarAvatar 
func(GravatarAvatar) GetAvatarURL(c *client) (string, error) { 
  if email, ok := c.userData["email"]; ok { 
    if emailStr, ok := email.(string); ok { 
      m := md5.New() 
      io.WriteString(m, strings.ToLower(emailStr)) 
      return fmt.Sprintf("//www.gravatar.com/avatar/%x", m.Sum(nil)), nil 
    } 
  } 
  return "", ErrNoAvatarURL 
} 
</pre><p class="calibre10">We used the same pattern as we did for <code class="email">AuthAvatar</code>: we have an empty struct, a helpful <code class="email">UseGravatar</code> variable, and the <code class="email">GetAvatarURL</code> method implementation itself. In this method, we follow Gravatar's guidelines to generate an MD5 hash from the e-mail address (after we ensured it was lowercase) and append it to the hardcoded base URL using <code class="email">fmt.Sprintf</code>.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note0044" class="calibre1"/>Note</h3><p class="calibre10">The preceding method also suffers from a bad line of sight in code. Can you live with it, or would you want to improve the readability somehow?</p></div><p class="calibre10">It is very easy to achieve hashing in Go thanks to the hard work put in by the writers of the Go standard library. The <code class="email">crypto</code> package has an impressive array of cryptography and hashing capabilities all very easy to use. In our case, we create a new <code class="email">md5</code> hasher and because the hasher implements the <code class="email">io.Writer</code> interface, we can use <code class="email">io.WriteString</code> to write a string of bytes to it. Calling <code class="email">Sum</code> returns the current hash for the bytes written.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip45" class="calibre1"/>Tip</h3><p class="calibre10">You might have noticed that we end up hashing the e-mail address every time we need the avatar URL. This is pretty inefficient, especially at scale, but we should prioritize getting stuff done over optimization. If we need to, we can always come back later and change the way this works.</p></div><p class="calibre10">Running the tests now shows us that our code is working, but we haven't yet included an e-mail address in the <code class="email">auth</code> cookie. We do this by locating the code where we assign to the <code class="email">authCookieValue</code> object in <code class="email">auth.go</code> and updating it to grab the <code class="email">Email</code> value from Gomniauth:</p><pre class="programlisting">authCookieValue := objx.New(map[string]interface{}{ 
  "name":       user.Name(), 
  "avatar_url": user.AvatarURL(), 
  "email":       user.Email(), 
}).MustBase64() 
</pre><p class="calibre10">The final thing we must do is tell our room to use the Gravatar implementation instead of the <code class="email">AuthAvatar</code> implementation. We do this by calling <code class="email">newRoom</code> in <code class="email">main.go</code> and making the following change:</p><pre class="programlisting">r := newRoom(UseGravatar) 
</pre><p class="calibre10">Build and run the chat program once again and head to the browser. Remember, since we have changed the information stored in the cookie, we must sign out and sign back in again in order to see our changes take effect.</p><p class="calibre10">Assuming you have a different image for your Gravatar account, you will notice that the system is now pulling the image from Gravatar instead of the auth provider. Using your browser's inspector or debug tool will show you that the <code class="email">src</code> attribute of the <code class="email">img</code> tag has indeed changed:</p><p class="calibre10">
</p><div class="mediaobject"><img src="../images/00053.jpeg" alt="The Gravatar implementation" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">
</p><p class="calibre10">If you don't have a Gravatar account, you'll most likely see a default placeholder image in place of your profile picture.</p></div></div></div></body></html>