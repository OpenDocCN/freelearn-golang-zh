["```go\npackage main \nimport ( \n  \"errors\" \n) \n// ErrNoAvatar is the error that is returned when the \n// Avatar instance is unable to provide an avatar URL. \nvar ErrNoAvatarURL = errors.New(\"chat: Unable to get an avatar  URL.\") \n// Avatar represents types capable of representing \n// user profile pictures. \ntype Avatar interface { \n  // GetAvatarURL gets the avatar URL for the specified client, \n  // or returns an error if something goes wrong. \n  // ErrNoAvatarURL is returned if the object is unable to get \n  // a URL for the specified client. \n  GetAvatarURL(c *client) (string, error) \n} \n\n```", "```go\npackage main \nimport \"testing\" \nfunc TestAuthAvatar(t *testing.T) { \n  var authAvatar AuthAvatar \n  client := new(client) \n  url, err := authAvatar.GetAvatarURL(client) \n  if err != ErrNoAvatarURL { \n    t.Error(\"AuthAvatar.GetAvatarURL should return ErrNoAvatarURL \n    when no value present\") \n  } \n  // set a value \n  testUrl := \"http://url-to-gravatar/\" \n  client.userData = map[string]interface{}{\"avatar_url\": testUrl} \n  url, err = authAvatar.GetAvatarURL(client) \n  if err != nil { \n    t.Error(\"AuthAvatar.GetAvatarURL should return no error \n    when value present\") \n  } \n  if url != testUrl { \n    t.Error(\"AuthAvatar.GetAvatarURL should return correct URL\") \n  } \n} \n\n```", "```go\ntype AuthAvatar struct{} \nvar UseAuthAvatar AuthAvatar \nfunc (AuthAvatar) GetAvatarURL(c *client) (string, error) { \n  if url, ok := c.userData[\"avatar_url\"]; ok { \n    if urlStr, ok := url.(string); ok { \n      return urlStr, nil \n    } \n  } \n  return \"\", ErrNoAvatarURL \n} \n\n```", "```go\ngo test\n\n```", "```go\n// avatar is how avatar information will be obtained. \navatar Avatar \n\n```", "```go\n// newRoom makes a new room that is ready to go. \nfunc newRoom(avatar Avatar) *room { \n  return &room{ \n    forward: make(chan *message), \n    join:    make(chan *client), \n    leave:   make(chan *client), \n    clients: make(map[*client]bool), \n    tracer:  trace.Off(), \n    avatar:  avatar, \n  } \n} \n\n```", "```go\nr := newRoom(UseAuthAvatar) \n\n```", "```go\nfunc move(animated bool) { /* ... */ } \nconst Animate = true const \nDontAnimate = false\n\n```", "```go\n\nmove(true) \n move(false) \n move(Animate) \n move(DontAnimate) \n\n```", "```go\nfunc (c *client) read() { \n  defer c.socket.Close() \n  for { \n    var msg *message \n    if err := c.socket.ReadJSON(&msg); err != nil { \n      return \n    } \n    msg.When = time.Now() \n    msg.Name = c.userData[\"name\"].(string) \n    msg.AvatarURL, _ = c.room.avatar.GetAvatarURL(c) \n    c.room.forward <- msg \n  } \n} \n\n```", "```go\nfunc TestGravatarAvatar(t *testing.T) { \n  var gravatarAvatar GravatarAvatar \n  client := new(client) \n  client.userData = map[string]interface{}{\"email\": \n   \"MyEmailAddress@example.com\"} \n  url, err := gravatarAvatar.GetAvatarURL(client) \n  if err != nil { \n    t.Error(\"GravatarAvatar.GetAvatarURL should not return an error\") \n  } \n  if url != \"//www.gravatar.com/avatar/0bc83cb571cd1c50ba6f3e8a78ef1346\" { \n    t.Errorf(\"GravatarAvatar.GetAvatarURL wrongly returned %s\", url) \n  } \n} \n\n```", "```go\ntype GravatarAvatar struct{} \nvar UseGravatar GravatarAvatar \nfunc(GravatarAvatar) GetAvatarURL(c *client) (string, error) { \n  if email, ok := c.userData[\"email\"]; ok { \n    if emailStr, ok := email.(string); ok { \n      m := md5.New() \n      io.WriteString(m, strings.ToLower(emailStr)) \n      return fmt.Sprintf(\"//www.gravatar.com/avatar/%x\", m.Sum(nil)), nil \n    } \n  } \n  return \"\", ErrNoAvatarURL \n} \n\n```", "```go\nauthCookieValue := objx.New(map[string]interface{}{ \n  \"name\":       user.Name(), \n  \"avatar_url\": user.AvatarURL(), \n  \"email\":       user.Email(), \n}).MustBase64() \n\n```", "```go\nr := newRoom(UseGravatar) \n\n```"]