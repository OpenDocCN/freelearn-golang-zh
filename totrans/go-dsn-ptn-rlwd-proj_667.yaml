- en: Abstracting the avatar URL process
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象头像 URL 处理过程
- en: Since we have three different ways of obtaining the avatar URL in our application,
    we have reached the point where it would be sensible to learn how to abstract
    the functionality in order to cleanly implement the options. Abstraction refers
    to a process in which we separate the idea of something from its specific implementation.
    The `http.Handler` method is a great example of how a handler will be used along
    with its ins and outs, without being specific about what action is taken by each
    handler.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在应用程序中有三种获取头像 URL 的不同方式，我们已经到了学习如何抽象功能以干净地实现选项的合理阶段。抽象是指将某物的概念与其特定的实现分离的过程。`http.Handler`
    方法是处理程序如何使用及其输入输出的一个很好的例子，而不具体说明每个处理程序采取什么行动。
- en: 'In Go, we start to describe our idea of getting an avatar URL by defining an
    interface. Let''s create a new file called `avatar.go` and insert the following
    code:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，我们通过定义一个接口来描述获取头像 URL 的想法。让我们创建一个名为 `avatar.go` 的新文件，并插入以下代码：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `Avatar` interface describes the `GetAvatarURL` method that a type must
    satisfy in order to be able to get avatar URLs. We took the client as an argument
    so that we know the user for which the URL to be returned. The method returns
    two arguments: a string (which will be the URL if things go well) and an error
    in case something goes wrong.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`Avatar` 接口描述了一个类型必须满足的 `GetAvatarURL` 方法，以便能够获取头像 URL。我们以客户端作为参数，以便我们知道要返回
    URL 的用户。该方法返回两个参数：一个字符串（如果一切顺利将是 URL）和一个错误，如果发生错误。'
- en: One of the things that could go wrong is simply that one of the specific implementations
    of `Avatar` is unable to get the URL. In that case, `GetAvatarURL` will return
    the `ErrNoAvatarURL` error as the second argument. The `ErrNoAvatarURL` error
    therefore becomes a part of the interface; it's one of the possible returns from
    the method and something that users of our code should probably explicitly handle.
    We mention this in the comments part of the code for the method, which is the
    only way to communicate such design decisions in Go.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 可能出错的一件事是 `Avatar` 的某个具体实现无法获取 URL。在这种情况下，`GetAvatarURL` 将作为第二个参数返回 `ErrNoAvatarURL`
    错误。因此，`ErrNoAvatarURL` 错误成为接口的一部分；它是方法可能的返回值之一，也是我们代码的用户可能需要明确处理的东西。我们在方法的注释部分提到这一点，这是在
    Go 中传达此类设计决策的唯一方式。
- en: Tip
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Because the error is initialized immediately using `errors.New` and stored in
    the `ErrNoAvatarURL` variable, only one of these objects will ever be created;
    passing the pointer of the error as a return is inexpensive. This is unlike Java's
    checked exceptions which serve a similar purpose where expensive exception objects
    are created and used as part of the control flow.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于错误立即使用 `errors.New` 初始化并存储在 `ErrNoAvatarURL` 变量中，因此只会创建这些对象中的一个；传递错误指针作为返回值是低成本的。这与
    Java 的 checked exceptions 类似，它们服务于类似的目的，其中创建了昂贵的异常对象，并用作控制流的一部分。
- en: The auth service and the avatar's implementation
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证服务和头像的实现
- en: 'The first implementation of `Avatar` we write will replace the existing functionality
    where we had hardcoded the avatar URL obtained from the auth service. Let''s use
    a **Test-driven Development** (**TDD**) approach so that we can be sure our code
    works without having to manually test it. Let''s create a new file called `avatar_test.go`
    in the `chat` folder:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的 `Avatar` 的第一个实现将替换现有的功能，其中我们硬编码了从认证服务获取的头像 URL。让我们使用 **测试驱动开发**（**TDD**）方法，这样我们就可以确保我们的代码工作，而无需手动测试。让我们在
    `chat` 文件夹中创建一个名为 `avatar_test.go` 的新文件：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This file contains a test for our as-of-yet, nonexistent `AuthAvatar` type's
    `GetAvatarURL` method. First, it uses a client with no user data and ensures that
    the `ErrNoAvatarURL` error is returned. After setting a suitable URL, our test
    calls the method again this time to assert that it returns the correct value.
    However, building this code fails because the `AuthAvatar` type doesn't exist,
    so we'll declare `authAvatar` next.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含对我们目前尚不存在且未定义的 `AuthAvatar` 类型的 `GetAvatarURL` 方法的测试。首先，它使用一个没有用户数据的客户端，并确保返回
    `ErrNoAvatarURL` 错误。在设置一个合适的 URL 后，我们的测试再次调用该方法，这次断言它返回正确的值。然而，构建此代码失败，因为 `AuthAvatar`
    类型不存在，所以我们将声明 `authAvatar`。
- en: Before we write our implementation, it's worth noticing that we only declare
    the `authAvatar` variable as the `AuthAvatar` type but never actually assign anything
    to it so its value remains `nil`. This is not a mistake; we are actually making
    use of Go's zero-initialization (or default initialization) capabilities. Since
    there is no state needed for our object (we will pass `client` in as an argument),
    there is no need to waste time and memory on initializing an instance of it. In
    Go, it is acceptable to call a method on a `nil` object, provided that the method
    doesn't try to access a field. When we actually come to writing our implementation,
    we will look at a way in which we can ensure this is the case.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写实现之前，值得注意的是，我们只声明了`authAvatar`变量为`AuthAvatar`类型，但从未实际分配任何内容给它，因此它的值仍然是`nil`。这并不是一个错误；我们实际上是在利用Go的零初始化（或默认初始化）功能。由于我们的对象不需要状态（我们将`client`作为参数传递），因此没有必要在初始化其实例上浪费时间和内存。在Go中，在`nil`对象上调用方法是可以接受的，只要该方法不尝试访问字段。当我们实际编写实现时，我们将探讨一种确保这种情况的方法。
- en: 'Let''s head back over to `avatar.go` and make our test pass. Add the following
    code at the bottom of the file:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`avatar.go`文件，并使测试通过。在文件底部添加以下代码：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we define our `AuthAvatar` type as an empty struct and define the implementation
    of the `GetAvatarURL` method. We also create a handy variable called `UseAuthAvatar`
    that has the `AuthAvatar` type but which remains of `nil` value. We can later
    assign the `UseAuthAvatar` variable to any field looking for an `Avatar` interface
    type.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的`AuthAvatar`类型定义为空结构体，并定义了`GetAvatarURL`方法的实现。我们还创建了一个方便的变量`UseAuthAvatar`，它具有`AuthAvatar`类型，但保持为`nil`值。我们可以在以后将`UseAuthAvatar`变量分配给任何查找`Avatar`接口类型的字段。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `GetAvatarURL` method we wrote earlier doesn't have a very nice **line of
    sight**; the happy return is buried within two `if` blocks. See if you can refactor
    it so that the last line is `return urlStr, nil` and the method exits early if
    the `avatar_url` field is missing. You can refactor with confidence, since this
    code is covered by a unit test.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前编写的`GetAvatarURL`方法视线不是很好；快乐的返回被埋在两个`if`块中。看看你是否可以重构它，使得最后一行是`return urlStr,
    nil`，如果`avatar_url`字段缺失，则方法提前退出。你可以有信心地重构，因为这段代码被单元测试覆盖。
- en: For a little more on the rationale behind this kind of refactor, refer to the
    article at [http://bit.ly/lineofsightgolang](http://bit.ly/lineofsightgolang).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种重构背后的理由的更多内容，请参阅[http://bit.ly/lineofsightgolang](http://bit.ly/lineofsightgolang)上的文章。
- en: Normally, the receiver of a method (the type defined in parentheses before the
    name) will be assigned to a variable so that it can be accessed in the body of
    the method. Since, in our case, we assume the object can have `nil` value, we
    can omit a variable name to tell Go to throw away the reference. This serves as
    an added reminder to ourselves that we should avoid using it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，方法（在名称之前括号内定义的类型）的接收者将被分配给一个变量，以便在方法体中访问它。由于在我们的情况下，我们假设对象可以具有`nil`值，因此我们可以省略变量名来告诉Go丢弃引用。这作为对我们自己的额外提醒，我们应该避免使用它。
- en: 'The body of our implementation is relatively simple otherwise: we are safely
    looking for the value of `avatar_url` and ensuring that it is a string before
    returning it. If anything fails, we return the `ErrNoAvatarURL` error, as defined
    in the interface.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现体在其他方面相对简单：我们安全地查找`avatar_url`的值，并在返回之前确保它是一个字符串。如果任何东西失败，我们返回接口中定义的`ErrNoAvatarURL`错误。
- en: 'Let''s run the tests by opening a terminal and then navigating to the `chat`
    folder and typing the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过打开终端并导航到`chat`文件夹，然后输入以下内容来运行测试：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If all is well, our tests will pass and we will have successfully created our
    first `Avatar` implementation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们的测试将通过，我们将成功创建我们的第一个`Avatar`实现。
- en: Using an implementation
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用实现
- en: When we use an implementation, we could refer to either the helper variables
    directly or create our own instance of the interface whenever we need the functionality.
    However, this would defeat the object of the abstraction. Instead, we use the
    `Avatar` interface type to indicate where we need the capability.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用实现时，我们可以直接引用辅助变量，或者在我们需要功能时创建接口的任何实例。然而，这将违背抽象的目的。相反，我们使用`Avatar`接口类型来指示我们需要的能力。
- en: 'For our chat application, we will have a single way to obtain an avatar URL
    per chat room. So, let''s update the `room` type so it can hold an `Avatar` object.
    In `room.go`, add the following field definition to the `room struct` type:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的聊天应用，我们将为每个聊天室提供一个获取头像URL的单一方式。因此，让我们更新`room`类型，使其能够包含一个`Avatar`对象。在`room.go`中，向`room
    struct`类型添加以下字段定义：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Update the `newRoom` function so that we can pass in an `Avatar` implementation
    for use; we will just assign this implementation to the new field when we create
    our `room` instance:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`newRoom`函数，以便我们可以传入一个`Avatar`实现用于使用；当我们创建我们的`room`实例时，我们只需将此实现分配给新字段：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Building the project now will highlight the fact that the call to `newRoom`
    in `main.go` is broken because we have not provided an `Avatar` argument; let''s
    update it by passing in our handy `UseAuthAvatar` variable, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建项目将突出显示`main.go`中对`newRoom`的调用是错误的，因为我们没有提供`Avatar`参数；让我们通过传递我们方便的`UseAuthAvatar`变量来更新它，如下所示：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We didn't have to create an instance of `AuthAvatar`, so no memory was allocated.
    In our case, this doesn't result in great saving (since we only have one room
    for our entire application), but imagine the size of the potential savings if
    our application has thousands of rooms. The way we named the `UseAuthAvatar` variable
    means that the preceding code is very easy to read and it also makes our intention
    obvious.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要创建`AuthAvatar`的实例，因此没有分配内存。在我们的情况下，这并不会导致很大的节省（因为我们整个应用程序只有一个房间），但想象一下，如果我们的应用程序有成千上万的房间，潜在节省的大小。我们命名`UseAuthAvatar`变量的方式意味着前面的代码非常易于阅读，同时也使我们的意图非常明显。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Thinking about code readability is important when designing interfaces. Consider
    a method that takes a Boolean input just passing in true or false hides the real
    meaning if you don''t know the argument names. Consider defining a couple of helper
    constants, as shown in the following short example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计接口时考虑代码可读性非常重要。考虑一个接受布尔输入的方法，仅传递true或false会隐藏真实含义，如果你不知道参数名称的话。考虑定义几个辅助常量，如下面的简短示例所示：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Think about which of the following calls to `move` are easier to understand:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下对`move`的调用中哪一个更容易理解：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'All that is left now is to change `client` to use our new `Avatar` interface.
    In `client.go`, update the `read` method, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只是将`client`更改为使用我们的新`Avatar`接口。在`client.go`中，更新`read`方法，如下所示：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we are asking the `avatar` instance in `room` to get the avatar URL for
    us instead of extracting it from `userData` ourselves.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们要求`room`中的`avatar`实例为我们获取头像URL，而不是我们自己从`userData`中提取。
- en: When you build and run the application, you will notice that (although we have
    refactored things a little) the behavior and user experience hasn't changed at
    all. This is because we told our room to use the `AuthAvatar` implementation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建并运行应用程序时，你会注意到（尽管我们做了一些重构）行为和用户体验完全没有改变。这是因为我们告诉我们的房间使用`AuthAvatar`实现。
- en: Now let's add another implementation to the room.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为房间添加另一个实现。
- en: The Gravatar implementation
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Gravatar实现
- en: 'The Gravatar implementation in `Avatar` will do the same job as the `AuthAvatar`
    implementation, except that it will generate a URL for a profile picture hosted
    on [https://en.gravatar.com/](https://en.gravatar.com/). Let''s start by adding
    a test to our `avatar_test.go` file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Avatar`中的Gravatar实现将执行与`AuthAvatar`实现相同的工作，但它将为托管在[https://en.gravatar.com/](https://en.gravatar.com/)上的个人资料图片生成一个URL。让我们首先在我们的`avatar_test.go`文件中添加一个测试：'
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Gravatar uses a hash of the e-mail address to generate a unique ID for each
    profile picture, so we set up a client and ensure `userData` contains an e-mail
    address. Next, we call the same `GetAvatarURL` method, but this time on an object
    that has the `GravatarAvatar` type. We then assert that a correct URL was returned.
    We already know this is the appropriate URL for the specified e-mail address because
    it is listed as an example in the Gravatar documentation a great strategy to ensure
    our code is doing what it should be doing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Gravatar使用电子邮件地址的哈希值来为每个个人资料图片生成一个唯一的ID，因此我们设置了一个客户端并确保`userData`包含一个电子邮件地址。接下来，我们调用相同的`GetAvatarURL`方法，但这次是在具有`GravatarAvatar`类型的对象上。然后我们断言返回了一个正确的URL。因为我们知道这是指定电子邮件地址的正确URL，因为它在Gravatar文档中作为示例列出，这是一个确保我们的代码正在执行其应有的功能的绝佳策略。
- en: Tip
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember that all the source code for this book is available for download from
    the publishers and has also been published on GitHub. You can save time on building
    the preceding core by copying and pasting bits and pieces from [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints).
    Hardcoding things such as the base URL is not usually a good idea; we have hardcoded
    throughout the book to make the code snippets easier to read and more obvious,
    but you are welcome to extract them as you go along if you like.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，本书的所有源代码都可以从出版社下载，并且也已发布在GitHub上。您可以通过复制粘贴[https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)中的部分内容来节省构建先前核心的时间。通常将诸如基本URL之类的信息硬编码不是一个好主意；我们在整本书中硬编码以使代码片段更容易阅读和更明显，但如果您喜欢，您可以在进行过程中提取它们。
- en: 'Running these tests (with `go test`) obviously causes errors because we haven''t
    defined our types yet. Let''s head back to `avatar.go` and add the following code
    while being sure to import the `io` package:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，运行这些测试（使用`go test`）会导致错误，因为我们还没有定义我们的类型。让我们回到`avatar.go`并添加以下代码，同时确保导入`io`包：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We used the same pattern as we did for `AuthAvatar`: we have an empty struct,
    a helpful `UseGravatar` variable, and the `GetAvatarURL` method implementation
    itself. In this method, we follow Gravatar''s guidelines to generate an MD5 hash
    from the e-mail address (after we ensured it was lowercase) and append it to the
    hardcoded base URL using `fmt.Sprintf`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了与`AuthAvatar`相同的模式：我们有一个空的struct，一个有用的`UseGravatar`变量，以及`GetAvatarURL`方法本身的实现。在这个方法中，我们遵循Gravatar的指南，从电子邮件地址（在我们确保它是小写之后）生成MD5哈希，并使用`fmt.Sprintf`将其附加到硬编码的基本URL上。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding method also suffers from a bad line of sight in code. Can you
    live with it, or would you want to improve the readability somehow?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法在代码中也有一个不好的视线问题。您能忍受它，还是想以某种方式提高可读性？
- en: It is very easy to achieve hashing in Go thanks to the hard work put in by the
    writers of the Go standard library. The `crypto` package has an impressive array
    of cryptography and hashing capabilities all very easy to use. In our case, we
    create a new `md5` hasher and because the hasher implements the `io.Writer` interface,
    we can use `io.WriteString` to write a string of bytes to it. Calling `Sum` returns
    the current hash for the bytes written.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go标准库编写者的辛勤工作，在Go中实现哈希非常容易。`crypto`包提供了一系列易于使用的加密和哈希功能。在我们的情况下，我们创建了一个新的`md5`哈希器，因为哈希器实现了`io.Writer`接口，我们可以使用`io.WriteString`将字节字符串写入它。调用`Sum`返回已写入的字节当前哈希。
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You might have noticed that we end up hashing the e-mail address every time
    we need the avatar URL. This is pretty inefficient, especially at scale, but we
    should prioritize getting stuff done over optimization. If we need to, we can
    always come back later and change the way this works.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，每次我们需要头像URL时，我们都会对电子邮件地址进行哈希处理。这在规模较大时效率不高，但我们应该优先考虑完成任务而不是优化。如果我们需要，我们总是可以稍后回来并更改这种方式。
- en: 'Running the tests now shows us that our code is working, but we haven''t yet
    included an e-mail address in the `auth` cookie. We do this by locating the code
    where we assign to the `authCookieValue` object in `auth.go` and updating it to
    grab the `Email` value from Gomniauth:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行测试显示我们的代码正在工作，但我们还没有在`auth`cookie中包含电子邮件地址。我们通过定位到`auth.go`中分配给`authCookieValue`对象的代码，并将其更新为从Gomniauth获取`Email`值来完成这项工作：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The final thing we must do is tell our room to use the Gravatar implementation
    instead of the `AuthAvatar` implementation. We do this by calling `newRoom` in
    `main.go` and making the following change:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的最后一件事是告诉我们的房间使用Gravatar实现而不是`AuthAvatar`实现。我们通过在`main.go`中调用`newRoom`并做出以下更改来完成这项工作：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Build and run the chat program once again and head to the browser. Remember,
    since we have changed the information stored in the cookie, we must sign out and
    sign back in again in order to see our changes take effect.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建并运行聊天程序，然后在浏览器中打开。记住，由于我们更改了存储在cookie中的信息，我们必须注销并重新登录才能看到我们的更改生效。
- en: 'Assuming you have a different image for your Gravatar account, you will notice
    that the system is now pulling the image from Gravatar instead of the auth provider.
    Using your browser''s inspector or debug tool will show you that the `src` attribute
    of the `img` tag has indeed changed:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在Gravatar账户中有不同的图像，您会注意到系统现在是从Gravatar而不是身份验证提供者那里获取图像。使用您浏览器的检查器或调试工具将显示`img`标签的`src`属性确实已更改：
- en: '![The Gravatar implementation](img/00053.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![Gravatar 实现](img/00053.jpeg)'
- en: If you don't have a Gravatar account, you'll most likely see a default placeholder
    image in place of your profile picture.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 Gravatar 账户，你很可能会看到默认占位符图片代替你的个人资料图片。
