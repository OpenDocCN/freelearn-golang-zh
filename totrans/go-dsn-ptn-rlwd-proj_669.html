<html><head></head><body>
<div class="book" title="Uploading an avatar picture">
<div class="book" title="User identification"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec0034" class="calibre1"/>User identification</h2></div></div></div><p class="calibre10">In order to uniquely identify our users, we are going to copy Gravatar's approach by hashing their e-mail address and using the resulting string as an identifier. We will store the user ID in the cookie along with the rest of the user-specific data. This will actually have the added benefit of removing the inefficiency associated with continuous hashing from <code class="email">GravatarAuth</code>.</p><p class="calibre10">In <code class="email">auth.go</code>, replace the code that creates the <code class="email">authCookieValue</code> object with the following code:</p><pre class="programlisting">m := md5.New() 
io.WriteString(m, strings.ToLower(user.Email())) 
userId := fmt.Sprintf("%x", m.Sum(nil)) 
authCookieValue := objx.New(map[string]interface{}{ 
  "userid":      userId, 
  "name":       user.Name(), 
  "avatar_url": user.AvatarURL(), 
  "email":      user.Email(), 
}).MustBase64() 
</pre><p class="calibre10">Here, we have hashed the e-mail address and stored the resulting value in the <code class="email">userid</code> field at the point at which the user logs in. From now on, we can use this value in our Gravatar code instead of hashing the e-mail address for every message. To do this, first, we update the test by removing the following line from <code class="email">avatar_test.go</code>:</p><pre class="programlisting">client.userData = map[string]interface{}{"email":  "MyEmailAddress@example.com"} 
</pre><p class="calibre10">We then replace the preceding line with this line:</p><pre class="programlisting">client.userData = map[string]interface{}{"userid":  "0bc83cb571cd1c50ba6f3e8a78ef1346"} 
</pre><p class="calibre10">We no longer need to set the <code class="email">email</code> field since it is not used; instead, we just have to set an appropriate value to the new <code class="email">userid</code> field. However, if you run <code class="email">go test</code> in a terminal, you will see this test fail.</p><p class="calibre10">To make the test pass, in <code class="email">avatar.go</code>, update the <code class="email">GetAvatarURL</code> method for the <code class="email">GravatarAuth</code> type:</p><pre class="programlisting">func(GravatarAvatar) GetAvatarURL(c *client) (string, error) { 
  if userid, ok := c.userData["userid"]; ok { 
    if useridStr, ok := userid.(string); ok { 
      return "//www.gravatar.com/avatar/" + useridStr, nil 
    } 
  } 
  return "", ErrNoAvatarURL 
} 
</pre><p class="calibre10">This won't change the behavior, but it allows us to make an unexpected optimization, which is a great example of why you shouldn't optimize code too early the inefficiencies that you spot early on may not last long enough to warrant the effort required to fix them.</p></div></div></body></html>