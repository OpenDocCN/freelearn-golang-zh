<html><head></head><body>
<div class="book" title="Uploading an avatar picture">
<div class="book" title="Handling the upload"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec0036" class="calibre1"/>Handling the upload</h2></div></div></div><p class="calibre10">When the user clicks on <span class="strong"><strong class="calibre2">Upload</strong></span> after selecting a file, the browser will send the data for the file as well as the user ID to <code class="email">/uploader</code>, but right now, that data doesn't actually go anywhere. We will implement a new <code class="email">HandlerFunc</code> interface that is capable of receiving the file, reading the bytes that are streamed through the connection, and saving it as a new file on the server. In the <code class="email">chat</code> folder, let's create a new folder called <code class="email">avatars</code> this is where we will save the avatar image files.</p><p class="calibre10">Next, create a new file called <code class="email">upload.go</code> and insert the following code make sure that you add the appropriate package name and imports (which are <code class="email">ioutils</code>, <code class="email">net/http</code>, <code class="email">io</code>, and <code class="email">path</code>):</p><pre class="programlisting">func uploaderHandler(w http.ResponseWriter, req *http.Request) { 
  userId := req.FormValue("userid") 
  file, header, err := req.FormFile("avatarFile") 
  if err != nil { 
    http.Error(w, err.Error(), http.StatusInternalServerError) 
    return 
  } 
  data, err := ioutil.ReadAll(file) 
  if err != nil { 
    http.Error(w, err.Error(), http.StatusInternalServerError) 
    return 
  } 
  filename := path.Join("avatars", userId+path.Ext(header.Filename)) 
  err = ioutil.WriteFile(filename, data, 0777) 
  if err != nil { 
    http.Error(w, err.Error(), http.StatusInternalServerError) 
    return 
  } 
  io.WriteString(w, "Successful") 
} 
</pre><p class="calibre10">Here, first <code class="email">uploaderHandler</code> uses the <code class="email">FormValue</code> method in <code class="email">http.Request</code> to get the user ID that we placed in the hidden input in our HTML form. Then, it gets an <code class="email">io.Reader</code> type capable of reading the uploaded bytes by calling <code class="email">req.FormFile</code>, which returns three arguments. The first argument represents the file itself with the <code class="email">multipart.File</code> interface type, which is also <code class="email">io.Reader</code>. The second is a <code class="email">multipart.FileHeader</code> object that contains the metadata about the file, such as the filename. And finally, the third argument is an error that we hope will have a <code class="email">nil</code> value.</p><p class="calibre10">What do we mean when we say that the <code class="email">multipart.File</code> interface type is also <code class="email">io.Reader</code>? Well, a quick glance at the documentation at <a class="calibre1" href="http://golang.org/pkg/mime/multipart/#File">http://golang.org/pkg/mime/multipart/#File</a> makes it clear that the type is actually just a wrapper interface for a few other more general interfaces. This means that a <code class="email">multipart.File</code> type can be passed to methods that require <code class="email">io.Reader</code>, since any object that implements <code class="email">multipart.File</code> must, therefore, implement <code class="email">io.Reader</code>.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip46" class="calibre1"/>Tip</h3><p class="calibre10">Embedding standard library interfaces, such as the wrapper, to describe new concepts is a great way to make sure your code works in as many contexts as possible. Similarly, you should try to write code that uses the simplest interface type you can find, ideally from the standard library. For example, if you wrote a method that needed you to read the contents of a file, you could ask the user to provide an argument of the type <code class="email">multipart.File</code>. However, if you ask for <code class="email">io.Reader</code> instead, your code will become significantly more flexible because any type that has the appropriate <code class="email">Read</code> method can be passed in, which includes user-defined types as well.</p></div><p class="calibre10">The <code class="email">ioutil.ReadAll</code> method will just keep reading from the specified <code class="email">io.Reader</code> interface until all of the bytes have been received, so this is where we actually receive the stream of bytes from the client. We then use <code class="email">path.Join</code> and <code class="email">path.Ext</code> to build a new filename using <code class="email">userid</code> and copy the extension from the original filename that we can get from <code class="email">multipart.FileHeader</code>.</p><p class="calibre10">We then use the <code class="email">ioutil.WriteFile</code> method to create a new file in the <code class="email">avatars</code> folder. We use <code class="email">userid</code> in the filename to associate the image with the correct user, much in the same way as Gravatar does. The <code class="email">0777</code> value specifies that the new file we create should have complete file permissions, which is a good default setting if you're not sure what other permissions should be set.</p><p class="calibre10">If an error occurs at any stage, our code will write it out to the response along with a 500 status code (since we specify <code class="email">http.StatusInternalServerError</code>), which will help us debug it, or it will write <span class="strong"><strong class="calibre2">Successful</strong></span> if everything went well.</p><p class="calibre10">In order to map this new handler function to <code class="email">/uploader</code>, we need to head back to <code class="email">main.go</code> and add the following line to <code class="email">func main</code>:</p><pre class="programlisting">http.HandleFunc("/uploader", uploaderHandler) 
</pre><p class="calibre10">Now build and run the application and remember to log out and log back in again in order to give our code a chance to upload the <code class="email">auth</code> cookie:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go build -o chat</strong></span>
<span class="strong"><strong class="calibre2">./chat -host=:8080</strong></span>
</pre><p class="calibre10">Open <code class="email">http://localhost:8080/upload</code> and click on <span class="strong"><strong class="calibre2">Choose File</strong></span>, and then select a file from your hard drive and click on <span class="strong"><strong class="calibre2">Upload</strong></span>. Navigate to your <code class="email">chat/avatars</code> folder and you will notice that the file was indeed uploaded and renamed to the value of your <code class="email">userid</code> field.</p></div></div></body></html>