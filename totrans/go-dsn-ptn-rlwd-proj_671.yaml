- en: Handling the upload
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理上传
- en: When the user clicks on **Upload** after selecting a file, the browser will
    send the data for the file as well as the user ID to `/uploader`, but right now,
    that data doesn't actually go anywhere. We will implement a new `HandlerFunc`
    interface that is capable of receiving the file, reading the bytes that are streamed
    through the connection, and saving it as a new file on the server. In the `chat`
    folder, let's create a new folder called `avatars` this is where we will save
    the avatar image files.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在选择了文件后点击**上传**按钮，浏览器会将文件数据和用户ID发送到`/uploader`，但现在，这些数据实际上并没有去任何地方。我们将实现一个新的`HandlerFunc`接口，它能够接收文件，读取通过连接流过的字节，并将其作为新文件保存到服务器上。在`chat`文件夹中，让我们创建一个新的文件夹叫做`avatars`，这是我们将会保存头像图片文件的地方。
- en: 'Next, create a new file called `upload.go` and insert the following code make
    sure that you add the appropriate package name and imports (which are `ioutils`,
    `net/http`, `io`, and `path`):'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`upload.go`的新文件，并插入以下代码，确保添加适当的包名和导入（`ioutils`、`net/http`、`io`和`path`）：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, first `uploaderHandler` uses the `FormValue` method in `http.Request`
    to get the user ID that we placed in the hidden input in our HTML form. Then,
    it gets an `io.Reader` type capable of reading the uploaded bytes by calling `req.FormFile`,
    which returns three arguments. The first argument represents the file itself with
    the `multipart.File` interface type, which is also `io.Reader`. The second is
    a `multipart.FileHeader` object that contains the metadata about the file, such
    as the filename. And finally, the third argument is an error that we hope will
    have a `nil` value.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，首先`uploaderHandler`使用`http.Request`中的`FormValue`方法获取我们在HTML表单中放置的隐藏输入的用户ID。然后，它通过调用`req.FormFile`获取一个能够读取上传字节的`io.Reader`类型，`req.FormFile`返回三个参数。第一个参数代表文件本身，具有`multipart.File`接口类型，它也是`io.Reader`。第二个是一个包含文件元数据的`multipart.FileHeader`对象，例如文件名。最后，第三个参数是一个我们希望其值为`nil`的错误。
- en: What do we mean when we say that the `multipart.File` interface type is also
    `io.Reader`? Well, a quick glance at the documentation at [http://golang.org/pkg/mime/multipart/#File](http://golang.org/pkg/mime/multipart/#File)
    makes it clear that the type is actually just a wrapper interface for a few other
    more general interfaces. This means that a `multipart.File` type can be passed
    to methods that require `io.Reader`, since any object that implements `multipart.File`
    must, therefore, implement `io.Reader`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说`multipart.File`接口类型也是`io.Reader`时，我们是什么意思？嗯，快速浏览一下[http://golang.org/pkg/mime/multipart/#File](http://golang.org/pkg/mime/multipart/#File)文档，就可以清楚地看出，这个类型实际上只是几个更通用接口的包装接口。这意味着`multipart.File`类型可以被传递给需要`io.Reader`的方法，因为任何实现了`multipart.File`的对象都必须实现`io.Reader`。
- en: Tip
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Embedding standard library interfaces, such as the wrapper, to describe new
    concepts is a great way to make sure your code works in as many contexts as possible.
    Similarly, you should try to write code that uses the simplest interface type
    you can find, ideally from the standard library. For example, if you wrote a method
    that needed you to read the contents of a file, you could ask the user to provide
    an argument of the type `multipart.File`. However, if you ask for `io.Reader`
    instead, your code will become significantly more flexible because any type that
    has the appropriate `Read` method can be passed in, which includes user-defined
    types as well.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 将标准库接口（如包装器）嵌入到描述新概念中，是确保你的代码在尽可能多的上下文中工作的一种好方法。同样，你应该尝试编写使用你能找到的最简单接口类型的代码，理想情况下来自标准库。例如，如果你编写了一个需要你读取文件内容的方法，你可以要求用户提供一个`multipart.File`类型的参数。然而，如果你要求`io.Reader`，你的代码将变得更加灵活，因为任何具有适当的`Read`方法的类型都可以传递，包括用户定义的类型。
- en: The `ioutil.ReadAll` method will just keep reading from the specified `io.Reader`
    interface until all of the bytes have been received, so this is where we actually
    receive the stream of bytes from the client. We then use `path.Join` and `path.Ext`
    to build a new filename using `userid` and copy the extension from the original
    filename that we can get from `multipart.FileHeader`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`ioutil.ReadAll`方法会持续从指定的`io.Reader`接口读取，直到接收到所有字节，所以这里我们实际上接收来自客户端的字节流。然后我们使用`path.Join`和`path.Ext`来构建一个新的文件名，使用`userid`并从`multipart.FileHeader`中复制扩展名。'
- en: We then use the `ioutil.WriteFile` method to create a new file in the `avatars`
    folder. We use `userid` in the filename to associate the image with the correct
    user, much in the same way as Gravatar does. The `0777` value specifies that the
    new file we create should have complete file permissions, which is a good default
    setting if you're not sure what other permissions should be set.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`ioutil.WriteFile`方法在`avatars`文件夹中创建一个新文件。我们使用`userid`作为文件名，以便将图像与正确的用户关联起来，这与Gravatar的做法非常相似。`0777`值指定了我们创建的新文件应该具有完整的文件权限，如果你不确定应该设置哪些其他权限，这是一个很好的默认设置。
- en: If an error occurs at any stage, our code will write it out to the response
    along with a 500 status code (since we specify `http.StatusInternalServerError`),
    which will help us debug it, or it will write **Successful** if everything went
    well.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何阶段发生错误，我们的代码将把它写入响应中，并附带一个500状态码（因为我们指定了`http.StatusInternalServerError`），这将帮助我们调试它，或者如果一切顺利，它将写入**成功**。
- en: 'In order to map this new handler function to `/uploader`, we need to head back
    to `main.go` and add the following line to `func main`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个新的处理函数映射到`/uploader`，我们需要回到`main.go`并在`func main`中添加以下行：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now build and run the application and remember to log out and log back in again
    in order to give our code a chance to upload the `auth` cookie:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在构建并运行应用程序，并记得注销并重新登录，以便给我们的代码一个上传`auth` cookie的机会：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Open `http://localhost:8080/upload` and click on **Choose File**, and then select
    a file from your hard drive and click on **Upload**. Navigate to your `chat/avatars`
    folder and you will notice that the file was indeed uploaded and renamed to the
    value of your `userid` field.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`http://localhost:8080/upload`，点击**选择文件**，然后从你的硬盘驱动器中选择一个文件并点击**上传**。导航到你的`chat/avatars`文件夹，你会注意到文件确实已上传，并重命名为你的`userid`字段的值。
