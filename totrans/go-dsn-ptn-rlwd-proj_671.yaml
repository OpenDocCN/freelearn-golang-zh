- en: Handling the upload
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the user clicks on **Upload** after selecting a file, the browser will
    send the data for the file as well as the user ID to `/uploader`, but right now,
    that data doesn't actually go anywhere. We will implement a new `HandlerFunc`
    interface that is capable of receiving the file, reading the bytes that are streamed
    through the connection, and saving it as a new file on the server. In the `chat`
    folder, let's create a new folder called `avatars` this is where we will save
    the avatar image files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new file called `upload.go` and insert the following code make
    sure that you add the appropriate package name and imports (which are `ioutils`,
    `net/http`, `io`, and `path`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, first `uploaderHandler` uses the `FormValue` method in `http.Request`
    to get the user ID that we placed in the hidden input in our HTML form. Then,
    it gets an `io.Reader` type capable of reading the uploaded bytes by calling `req.FormFile`,
    which returns three arguments. The first argument represents the file itself with
    the `multipart.File` interface type, which is also `io.Reader`. The second is
    a `multipart.FileHeader` object that contains the metadata about the file, such
    as the filename. And finally, the third argument is an error that we hope will
    have a `nil` value.
  prefs: []
  type: TYPE_NORMAL
- en: What do we mean when we say that the `multipart.File` interface type is also
    `io.Reader`? Well, a quick glance at the documentation at [http://golang.org/pkg/mime/multipart/#File](http://golang.org/pkg/mime/multipart/#File)
    makes it clear that the type is actually just a wrapper interface for a few other
    more general interfaces. This means that a `multipart.File` type can be passed
    to methods that require `io.Reader`, since any object that implements `multipart.File`
    must, therefore, implement `io.Reader`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Embedding standard library interfaces, such as the wrapper, to describe new
    concepts is a great way to make sure your code works in as many contexts as possible.
    Similarly, you should try to write code that uses the simplest interface type
    you can find, ideally from the standard library. For example, if you wrote a method
    that needed you to read the contents of a file, you could ask the user to provide
    an argument of the type `multipart.File`. However, if you ask for `io.Reader`
    instead, your code will become significantly more flexible because any type that
    has the appropriate `Read` method can be passed in, which includes user-defined
    types as well.
  prefs: []
  type: TYPE_NORMAL
- en: The `ioutil.ReadAll` method will just keep reading from the specified `io.Reader`
    interface until all of the bytes have been received, so this is where we actually
    receive the stream of bytes from the client. We then use `path.Join` and `path.Ext`
    to build a new filename using `userid` and copy the extension from the original
    filename that we can get from `multipart.FileHeader`.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the `ioutil.WriteFile` method to create a new file in the `avatars`
    folder. We use `userid` in the filename to associate the image with the correct
    user, much in the same way as Gravatar does. The `0777` value specifies that the
    new file we create should have complete file permissions, which is a good default
    setting if you're not sure what other permissions should be set.
  prefs: []
  type: TYPE_NORMAL
- en: If an error occurs at any stage, our code will write it out to the response
    along with a 500 status code (since we specify `http.StatusInternalServerError`),
    which will help us debug it, or it will write **Successful** if everything went
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to map this new handler function to `/uploader`, we need to head back
    to `main.go` and add the following line to `func main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now build and run the application and remember to log out and log back in again
    in order to give our code a chance to upload the `auth` cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Open `http://localhost:8080/upload` and click on **Choose File**, and then select
    a file from your hard drive and click on **Upload**. Navigate to your `chat/avatars`
    folder and you will notice that the file was indeed uploaded and renamed to the
    value of your `userid` field.
  prefs: []
  type: TYPE_NORMAL
