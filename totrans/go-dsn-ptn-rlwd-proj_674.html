<html><head></head><body>
<div class="book" title="Uploading an avatar picture">
<div class="book" title="Refactoring and optimizing our code"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch03lvl2sec0039" class="calibre1"/>Refactoring and optimizing our code</h2></div></div></div><p class="calibre10">When we look back at how our <code class="email">Avatar</code> type is used, you will notice that every time someone sends a message, the application makes a call to <code class="email">GetAvatarURL</code>. In our latest implementation, each time the method is called, we iterate over all the files in the <code class="email">avatars</code> folder. For a particularly chatty user, this could mean that we end up iterating over and over again many times a minute. This is an obvious waste of resources and would, at some point very soon, become a scaling problem.</p><p class="calibre10">Instead of getting the avatar URL for every message, we should get it only once when the user first logs in and cache it in the <code class="email">auth</code> cookie. Unfortunately, our <code class="email">Avatar</code> interface type requires that we pass in a <code class="email">client</code> object to the <code class="email">GetAvatarURL</code> method and we do not have such an object at the point at which we are authenticating the user.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip50" class="calibre1"/>Tip</h3><p class="calibre10">So did we make a mistake when we designed our <code class="email">Avatar</code> interface? While this is a natural conclusion to come to, in fact we did the right thing. We designed the solution with the best information we had available at the time and therefore had a working chat application much sooner than if we'd tried to design for every possible future case. Software evolves and almost always changes during the development process and will definitely change throughout the lifetime of the code.</p></div><div class="book" title="Replacing concrete types with interfaces"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec008" class="calibre1"/>Replacing concrete types with interfaces</h3></div></div></div><p class="calibre10">We have concluded that our <code class="email">GetAvatarURL</code> method depends on a type that is not available to us at the point we need it, so what would be a good alternative? We could pass each required field as a separate argument, but this would make our interface brittle, since as soon as an <code class="email">Avatar</code> implementation needs a new piece of information, we'd have to change the method signature. Instead, we will create a new type that will encapsulate the information our <code class="email">Avatar</code> implementations need while conceptually remaining decoupled from our specific case.</p><p class="calibre10">In <code class="email">auth.go</code>, add the following code to the top of the page (underneath the <code class="email">package</code> keyword, of course):</p><pre class="programlisting">import gomniauthcommon "github.com/stretchr/gomniauth/common" 
type ChatUser interface { 
  UniqueID() string 
  AvatarURL() string 
} 
type chatUser struct { 
  gomniauthcommon.User 
  uniqueID string 
} 
func (u chatUser) UniqueID() string { 
  return u.uniqueID 
} 
</pre><p class="calibre10">Here, the <code class="email">import</code> statement imported the <code class="email">common</code> package from Gomniauth and, at the same time, gave it a specific name through which it will be accessed: <code class="email">gomniauthcommon</code>. This isn't entirely necessary since we have no package name conflicts. However, it makes the code easier to understand.</p><p class="calibre10">In the preceding code snippet, we also defined a new interface type called <code class="email">ChatUser</code>, which exposes the information needed in order for our <code class="email">Avatar</code> implementations to generate the correct URLs. Then, we defined an actual implementation called <code class="email">chatUser</code> (notice the lowercase starting letter) that implements the interface. It also makes use of a very interesting feature in Go: type embedding. We actually embedded the <code class="email">gomniauth/common.User</code> interface type, which means that our <code class="email">struct</code> interface implements the interface automatically.</p><p class="calibre10">You may have noticed that we only actually implemented one of the two required methods to satisfy our <code class="email">ChatUser</code> interface. We got away with this because the Gomniauth <code class="email">User</code> interface happens to define the same <code class="email">AvatarURL</code> method. In practice, when we instantiate our <code class="email">chatUser</code> struct provided we set an appropriate value for the implied Gomniauth <code class="email">User</code> field our object implements both Gomniauth's <code class="email">User</code> interface and our own <code class="email">ChatUser</code> interface at the same time.</p></div><div class="book" title="Changing interfaces in a test-driven way"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec009" class="calibre1"/>Changing interfaces in a test-driven way</h3></div></div></div><p class="calibre10">Before we can use our new type, we must update the <code class="email">Avatar</code> interface and appropriate implementations to make use of it. As we will follow TDD practices, we are going to first make these changes in our test file, see the compiler errors when we try to build our code, and see failing tests once we fix those errors before finally making the tests pass.</p><p class="calibre10">Open <code class="email">avatar_test.go</code> and replace <code class="email">TestAuthAvatar</code> with the following code:</p><pre class="programlisting">func TestAuthAvatar(t *testing.T) { 
  var authAvatar AuthAvatar 
  testUser := &amp;gomniauthtest.TestUser{} 
  testUser.On("AvatarURL").Return("", ErrNoAvatarURL) 
  testChatUser := &amp;chatUser{User: testUser} 
  url, err := authAvatar.GetAvatarURL(testChatUser) 
  if err != ErrNoAvatarURL { 
    t.Error("AuthAvatar.GetAvatarURL should return ErrNoAvatarURL 
     when no value present") 
  } 
  testUrl := "http://url-to-gravatar/" 
  testUser = &amp;gomniauthtest.TestUser{} 
  testChatUser.User = testUser 
  testUser.On("AvatarURL").Return(testUrl, nil) 
  url, err = authAvatar.GetAvatarURL(testChatUser) 
  if err != nil { 
    t.Error("AuthAvatar.GetAvatarURL should return no error 
    when value present") 
  } 
  if url != testUrl { 
    t.Error("AuthAvatar.GetAvatarURL should return correct URL") 
  } 
} 
</pre><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip51" class="calibre1"/>Tip</h3><p class="calibre10">You will also need to import the <code class="email">gomniauth/test</code> package as <code class="email">gomniauthtest</code>, like we did in the last section.</p></div><p class="calibre10">Using our new interface before we have defined it is a good way to check the sanity of our thinking, which is another advantage of practicing TDD. In this new test, we create <code class="email">TestUser</code> provided by Gomniauth and embed it into a <code class="email">chatUser</code> type. We then pass the new <code class="email">chatUser</code> type into our <code class="email">GetAvatarURL</code> calls and make the same assertions about output as we always have done.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip52" class="calibre1"/>Tip</h3><p class="calibre10">Gomniauth's <code class="email">TestUser</code> type is interesting as it makes use of the <code class="email">Testify</code> package's mocking capabilities. Refer to <a class="calibre1" href="https://github.com/stretchr/testify">https://github.com/stretchr/testify</a> for more information.</p><p class="calibre10">The <code class="email">On</code> and <code class="email">Return</code> methods allow us to tell <code class="email">TestUser</code> what to do when specific methods are called. In the first case, we tell the <code class="email">AvatarURL</code> method to return the error, and in the second case, we ask it to return the <code class="email">testUrl</code> value, which simulates the two possible outcomes we are covering in this test.</p></div><p class="calibre10">Updating the other two tests is much simpler because they rely only on the <code class="email">UniqueID</code> method, the value of which we can control directly.</p><p class="calibre10">Replace the other two tests in <code class="email">avatar_test.go</code> with the following code:</p><pre class="programlisting">func TestGravatarAvatar(t *testing.T) { 
  var gravatarAvatar GravatarAvatar 
  user := &amp;chatUser{uniqueID: "abc"} 
  url, err := gravatarAvatar.GetAvatarURL(user) 
  if err != nil { 
    t.Error("GravatarAvatar.GetAvatarURL should not return an error") 
  } 
  if url != "//www.gravatar.com/avatar/abc" { 
    t.Errorf("GravatarAvatar.GetAvatarURL wrongly returned %s", url) 
  } 
} 
func TestFileSystemAvatar(t *testing.T) { 
  // make a test avatar file 
  filename := path.Join("avatars", "abc.jpg") 
  ioutil.WriteFile(filename, []byte{}, 0777) 
  defer func() { os.Remove(filename) }() 
  var fileSystemAvatar FileSystemAvatar 
  user := &amp;chatUser{uniqueID: "abc"} 
  url, err := fileSystemAvatar.GetAvatarURL(user) 
  if err != nil { 
    t.Error("FileSystemAvatar.GetAvatarURL should not return an error") 
  } 
  if url != "/avatars/abc.jpg" { 
    t.Errorf("FileSystemAvatar.GetAvatarURL wrongly returned %s", url) 
  } 
} 
</pre><p class="calibre10">Of course, this test code won't even compile because we are yet to update our <code class="email">Avatar</code> interface. In <code class="email">avatar.go</code>, update the <code class="email">GetAvatarURL</code> signature in the <code class="email">Avatar</code> interface type to take a <code class="email">ChatUser</code> type rather than a <code class="email">client</code> type:</p><pre class="programlisting">GetAvatarURL(ChatUser) (string, error) 
</pre><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip53" class="calibre1"/>Tip</h3><p class="calibre10">Note that we are using the <code class="email">ChatUser</code> interface (with the starting letter in uppercase) rather than our internal <code class="email">chatUser</code> implementation struct after all, we want to be flexible about the types our <code class="email">GetAvatarURL</code> methods accept.</p></div><p class="calibre10">Trying to build this will reveal that we now have broken implementations because all the <code class="email">GetAvatarURL</code> methods are still asking for a <code class="email">client</code> object.</p></div><div class="book" title="Fixing the existing implementations"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec0010" class="calibre1"/>Fixing the existing implementations</h3></div></div></div><p class="calibre10">Changing an interface like the one we have is a good way to automatically find the parts of our code that have been affected because they will cause compiler errors. Of course, if we were writing a package that other people would use, we would have to be far stricter about changing the interfaces like this, but we haven't released our v1 yet, so it's fine.</p><p class="calibre10">We are now going to update the three implementation signatures to satisfy the new interface and change the method bodies to make use of the new type. Replace the implementation for <code class="email">FileSystemAvatar</code> with the following:</p><pre class="programlisting">func (FileSystemAvatar) GetAvatarURL(u ChatUser) (string, error) { 
  if files, err := ioutil.ReadDir("avatars"); err == nil { 
    for _, file := range files { 
      if file.IsDir() { 
        continue 
      } 
      if match, _ := path.Match(u.UniqueID()+"*", file.Name()); 
      match { 
        return "/avatars/" + file.Name(), nil 
      } 
    } 
  } 
  return "", ErrNoAvatarURL 
} 
</pre><p class="calibre10">The key change here is that we no longer access the <code class="email">userData</code> field on the client, and just call <code class="email">UniqueID</code> directly on the <code class="email">ChatUser</code> interface instead.</p><p class="calibre10">Next, we update the <code class="email">AuthAvatar</code> implementation with the following code:</p><pre class="programlisting">func (AuthAvatar) GetAvatarURL(u ChatUser) (string, error) { 
  url := u.AvatarURL() 
  if len(url) == 0 { 
    return "", ErrNoAvatarURL 
  } 
  return url, nil 
} 
</pre><p class="calibre10">Our new design proves to be much simpler, it's always a good thing if we can reduce the amount of code required. The preceding code makes a call to get the <code class="email">AvatarURL</code> value, and provided it isn't empty, we return it; otherwise, we return the <code class="email">ErrNoAvatarURL</code> error.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip54" class="calibre1"/>Tip</h3><p class="calibre10">Note how the expected flow of the code is indented to one level, while error cases are nested inside <code class="email">if</code> blocks. While you can't stick to this practice 100% of the time, it's a worthwhile endeavor. Being able to quickly scan the code (when reading it) to see the normal flow of execution down a single column allows you to understand the code much quicker. Compare this to code that has lots of <code class="email">if...else</code> nested blocks, which takes a lot more unpicking to understand.</p></div><p class="calibre10">Finally, update the <code class="email">GravatarAvatar</code> implementation:</p><pre class="programlisting">func (GravatarAvatar) GetAvatarURL(u ChatUser) (string, error) { 
  return "//www.gravatar.com/avatar/" + u.UniqueID(), nil 
} 
</pre></div><div class="book" title="Global variables versus fields"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec0011" class="calibre1"/>Global variables versus fields</h3></div></div></div><p class="calibre10">So far, we have assigned the <code class="email">Avatar</code> implementation to the <code class="email">room</code> type, which enables us to use different avatars for different rooms. However, this has exposed an issue: when our users sign in, there is no concept of which room they are headed to so we cannot know which <code class="email">Avatar</code> implementation to use. Because our application only supports a single room, we are going to look at another approach to select implementations: the use of global variables.</p><p class="calibre10">A global variable is simply a variable that is defined outside any type definition and is accessible from every part of the package (and from outside the package if it's exported). For a simple configuration, such as which type of <code class="email">Avatar</code> implementation to use, global variables are an easy and simple solution. Underneath the <code class="email">import</code> statements in <code class="email">main.go</code>, add the following line:</p><pre class="programlisting">// set the active Avatar implementation 
var avatars Avatar = UseFileSystemAvatar 
</pre><p class="calibre10">This defines <code class="email">avatars</code> as a global variable that we can use when we need to get the avatar URL for a particular user.</p></div><div class="book" title="Implementing our new design"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec0012" class="calibre1"/>Implementing our new design</h3></div></div></div><p class="calibre10">We need to change the code that calls <code class="email">GetAvatarURL</code> for every message to just access the value that we put into the <code class="email">userData</code> cache (via the <code class="email">auth</code> cookie). Change the line where <code class="email">msg.AvatarURL</code> is assigned, as follows:</p><pre class="programlisting">if avatarUrl, ok := c.userData["avatar_url"]; ok { 
  msg.AvatarURL = avatarUrl.(string) 
} 
</pre><p class="calibre10">Find the code inside <code class="email">loginHandler</code> in <code class="email">auth.go</code> where we call <code class="email">provider.GetUser</code> and replace it, down to where we set the <code class="email">authCookieValue</code> object, with the following code:</p><pre class="programlisting">user, err := provider.GetUser(creds) 
if err != nil { 
  log.Fatalln("Error when trying to get user from", provider, "-", err) 
} 
chatUser := &amp;chatUser{User: user} 
m := md5.New() 
io.WriteString(m, strings.ToLower(user.Email())) 
chatUser.uniqueID = fmt.Sprintf("%x", m.Sum(nil)) 
avatarURL, err := avatars.GetAvatarURL(chatUser) 
if err != nil { 
  log.Fatalln("Error when trying to GetAvatarURL", "-", err) 
} 
</pre><p class="calibre10">Here, we created a new <code class="email">chatUser</code> variable while setting the <code class="email">User</code> field (which represents the embedded interface) to the <code class="email">User</code> value returned from Gomniauth. We then saved the <code class="email">userid</code> MD5 hash to the <code class="email">uniqueID</code> field.</p><p class="calibre10">The call to <code class="email">avatars.GetAvatarURL</code> is where all of our hard work has paid off, as we now get the avatar URL for the user far earlier in the process. Update the <code class="email">authCookieValue</code> line in <code class="email">auth.go</code> to cache the avatar URL in the cookie and remove the e-mail address since it is no longer required:</p><pre class="programlisting">authCookieValue := objx.New(map[string]interface{}{ 
  "userid":     chatUser.uniqueID, 
  "name":       user.Name(), 
  "avatar_url": avatarURL, 
}).MustBase64() 
</pre><p class="calibre10">However expensive the work the <code class="email">Avatar</code> implementation needs to do, such as iterating over files on the filesystem, it is mitigated by the fact that the implementation only does so when the user first logs in and not every time they send a message.</p></div><div class="book" title="Tidying up and testing"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch03lvl3sec0013" class="calibre1"/>Tidying up and testing</h3></div></div></div><p class="calibre10">Finally, we get to snip away at some of the fat that has accumulated during our refactoring process.</p><p class="calibre10">Since we no longer store the <code class="email">Avatar</code> implementation in <code class="email">room</code>, let's remove the field and all references to it from the type. In <code class="email">room.go</code>, delete the <code class="email">avatar Avatar</code> definition from the <code class="email">room</code> struct and update the <code class="email">newRoom</code> method:</p><pre class="programlisting">func newRoom() *room { 
  return &amp;room{ 
    forward: make(chan *message), 
    join:    make(chan *client), 
    leave:   make(chan *client), 
    clients: make(map[*client]bool), 
    tracer:  trace.Off(), 
  } 
} 
</pre><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip55" class="calibre1"/>Tip</h3><p class="calibre10">Remember to use the compiler as your to-do list where possible, and follow the errors to find where you have impacted other code.</p></div><p class="calibre10">In <code class="email">main.go</code>, remove the parameter passed into the <code class="email">newRoom</code> function call since we are using our global variable instead of this one.</p><p class="calibre10">After this exercise, the end user experience remains unchanged. Usually when refactoring the code, it is the internals that are modified while the public-facing interface remains stable and unchanged. As you go, remember to re-run the unit tests to make sure you don't break anything as you evolve the code.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip56" class="calibre1"/>Tip</h3><p class="calibre10">It's usually a good idea to run tools such as <code class="email">golint</code> and <code class="email">go vet</code> against your code as well in order to make sure it follows good practices and doesn't contain any Go faux pas, such as missing comments or badly named functions. There are a few deliberately left in for you to fix yourself.</p></div></div></div></div></body></html>