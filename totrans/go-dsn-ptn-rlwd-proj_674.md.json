["```go\nimport gomniauthcommon \"github.com/stretchr/gomniauth/common\" \ntype ChatUser interface { \n  UniqueID() string \n  AvatarURL() string \n} \ntype chatUser struct { \n  gomniauthcommon.User \n  uniqueID string \n} \nfunc (u chatUser) UniqueID() string { \n  return u.uniqueID \n} \n\nChatUser, which exposes the information needed in order for our Avatar implementations to generate the correct URLs. Then, we defined an actual implementation called chatUser (notice the lowercase starting letter) that implements the interface. It also makes use of a very interesting feature in Go: type embedding. We actually embedded the gomniauth/common.User interface type, which means that our struct interface implements the interface automatically.\n```", "```go\nfunc TestAuthAvatar(t *testing.T) { \n  var authAvatar AuthAvatar \n  testUser := &gomniauthtest.TestUser{} \n  testUser.On(\"AvatarURL\").Return(\"\", ErrNoAvatarURL) \n  testChatUser := &chatUser{User: testUser} \n  url, err := authAvatar.GetAvatarURL(testChatUser) \n  if err != ErrNoAvatarURL { \n    t.Error(\"AuthAvatar.GetAvatarURL should return ErrNoAvatarURL \n     when no value present\") \n  } \n  testUrl := \"http://url-to-gravatar/\" \n  testUser = &gomniauthtest.TestUser{} \n  testChatUser.User = testUser \n  testUser.On(\"AvatarURL\").Return(testUrl, nil) \n  url, err = authAvatar.GetAvatarURL(testChatUser) \n  if err != nil { \n    t.Error(\"AuthAvatar.GetAvatarURL should return no error \n    when value present\") \n  } \n  if url != testUrl { \n    t.Error(\"AuthAvatar.GetAvatarURL should return correct URL\") \n  } \n} \n\n```", "```go\nfunc TestGravatarAvatar(t *testing.T) { \n  var gravatarAvatar GravatarAvatar \n  user := &chatUser{uniqueID: \"abc\"} \n  url, err := gravatarAvatar.GetAvatarURL(user) \n  if err != nil { \n    t.Error(\"GravatarAvatar.GetAvatarURL should not return an error\") \n  } \n  if url != \"//www.gravatar.com/avatar/abc\" { \n    t.Errorf(\"GravatarAvatar.GetAvatarURL wrongly returned %s\", url) \n  } \n} \nfunc TestFileSystemAvatar(t *testing.T) { \n  // make a test avatar file \n  filename := path.Join(\"avatars\", \"abc.jpg\") \n  ioutil.WriteFile(filename, []byte{}, 0777) \n  defer func() { os.Remove(filename) }() \n  var fileSystemAvatar FileSystemAvatar \n  user := &chatUser{uniqueID: \"abc\"} \n  url, err := fileSystemAvatar.GetAvatarURL(user) \n  if err != nil { \n    t.Error(\"FileSystemAvatar.GetAvatarURL should not return an error\") \n  } \n  if url != \"/avatars/abc.jpg\" { \n    t.Errorf(\"FileSystemAvatar.GetAvatarURL wrongly returned %s\", url) \n  } \n} \n\n```", "```go\nGetAvatarURL(ChatUser) (string, error) \n\n```", "```go\nfunc (FileSystemAvatar) GetAvatarURL(u ChatUser) (string, error) { \n  if files, err := ioutil.ReadDir(\"avatars\"); err == nil { \n    for _, file := range files { \n      if file.IsDir() { \n        continue \n      } \n      if match, _ := path.Match(u.UniqueID()+\"*\", file.Name()); \n      match { \n        return \"/avatars/\" + file.Name(), nil \n      } \n    } \n  } \n  return \"\", ErrNoAvatarURL \n} \n\n```", "```go\nfunc (AuthAvatar) GetAvatarURL(u ChatUser) (string, error) { \n  url := u.AvatarURL() \n  if len(url) == 0 { \n    return \"\", ErrNoAvatarURL \n  } \n  return url, nil \n} \n\n```", "```go\nfunc (GravatarAvatar) GetAvatarURL(u ChatUser) (string, error) { \n  return \"//www.gravatar.com/avatar/\" + u.UniqueID(), nil \n} \n\n```", "```go\n// set the active Avatar implementation \nvar avatars Avatar = UseFileSystemAvatar \n\n```", "```go\nif avatarUrl, ok := c.userData[\"avatar_url\"]; ok { \n  msg.AvatarURL = avatarUrl.(string) \n} \n\n```", "```go\nuser, err := provider.GetUser(creds) \nif err != nil { \n  log.Fatalln(\"Error when trying to get user from\", provider, \"-\", err) \n} \nchatUser := &chatUser{User: user} \nm := md5.New() \nio.WriteString(m, strings.ToLower(user.Email())) \nchatUser.uniqueID = fmt.Sprintf(\"%x\", m.Sum(nil)) \navatarURL, err := avatars.GetAvatarURL(chatUser) \nif err != nil { \n  log.Fatalln(\"Error when trying to GetAvatarURL\", \"-\", err) \n} \n\n```", "```go\nauthCookieValue := objx.New(map[string]interface{}{ \n  \"userid\":     chatUser.uniqueID, \n  \"name\":       user.Name(), \n  \"avatar_url\": avatarURL, \n}).MustBase64() \n\n```", "```go\nfunc newRoom() *room { \n  return &room{ \n    forward: make(chan *message), \n    join:    make(chan *client), \n    leave:   make(chan *client), \n    clients: make(map[*client]bool), \n    tracer:  trace.Off(), \n  } \n} \n\n```"]