- en: Refactoring and optimizing our code
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码重构和优化
- en: When we look back at how our `Avatar` type is used, you will notice that every
    time someone sends a message, the application makes a call to `GetAvatarURL`.
    In our latest implementation, each time the method is called, we iterate over
    all the files in the `avatars` folder. For a particularly chatty user, this could
    mean that we end up iterating over and over again many times a minute. This is
    an obvious waste of resources and would, at some point very soon, become a scaling
    problem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回顾我们的 `Avatar` 类型是如何被使用的时候，你会注意到，每次有人发送消息时，应用程序都会调用 `GetAvatarURL` 方法。在我们的最新实现中，每次调用该方法时，我们都会遍历
    `avatars` 文件夹中的所有文件。对于一个特别健谈的用户来说，这可能意味着我们每分钟会重复多次遍历。这显然是资源的浪费，并且很快就会成为一个可扩展性问题。
- en: Instead of getting the avatar URL for every message, we should get it only once
    when the user first logs in and cache it in the `auth` cookie. Unfortunately,
    our `Avatar` interface type requires that we pass in a `client` object to the
    `GetAvatarURL` method and we do not have such an object at the point at which
    we are authenticating the user.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该为每条消息获取头像 URL，而应该只在用户首次登录时获取一次，并将其缓存到 `auth` 甜饼中。不幸的是，我们的 `Avatar` 接口类型要求我们将
    `client` 对象传递给 `GetAvatarURL` 方法，而在我们验证用户身份的点上我们没有这样的对象。
- en: Tip
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: So did we make a mistake when we designed our `Avatar` interface? While this
    is a natural conclusion to come to, in fact we did the right thing. We designed
    the solution with the best information we had available at the time and therefore
    had a working chat application much sooner than if we'd tried to design for every
    possible future case. Software evolves and almost always changes during the development
    process and will definitely change throughout the lifetime of the code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在设计 `Avatar` 接口时犯错误了吗？虽然这是一个自然的结论，但事实上我们做得是对的。我们根据当时可用的最佳信息设计了解决方案，因此比尝试为每个可能的情况设计要早得多地拥有了一个工作的聊天应用程序。软件会进化，几乎总是会在开发过程中发生变化，并且在代码的整个生命周期中肯定会发生变化。
- en: Replacing concrete types with interfaces
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用接口替换具体类型
- en: We have concluded that our `GetAvatarURL` method depends on a type that is not
    available to us at the point we need it, so what would be a good alternative?
    We could pass each required field as a separate argument, but this would make
    our interface brittle, since as soon as an `Avatar` implementation needs a new
    piece of information, we'd have to change the method signature. Instead, we will
    create a new type that will encapsulate the information our `Avatar` implementations
    need while conceptually remaining decoupled from our specific case.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经得出结论，我们的 `GetAvatarURL` 方法依赖于在我们需要它的点上不可用的类型，那么一个好的替代方案是什么？我们可以将每个必需的字段作为单独的参数传递，但这会使我们的接口变得脆弱，因为一旦
    `Avatar` 实现需要新的信息，我们就必须更改方法签名。相反，我们将创建一个新的类型，它将封装 `Avatar` 实现所需的信息，同时在概念上仍然与我们的特定案例解耦。
- en: 'In `auth.go`, add the following code to the top of the page (underneath the
    `package` keyword, of course):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `auth.go` 文件中，将以下代码添加到页面顶部（当然是在 `package` 关键字下方）：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You may have noticed that we only actually implemented one of the two required
    methods to satisfy our `ChatUser` interface. We got away with this because the
    Gomniauth `User` interface happens to define the same `AvatarURL` method. In practice,
    when we instantiate our `chatUser` struct provided we set an appropriate value
    for the implied Gomniauth `User` field our object implements both Gomniauth's
    `User` interface and our own `ChatUser` interface at the same time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们实际上只实现了满足我们的 `ChatUser` 接口所需的两个方法中的一个。我们之所以能够这样做，是因为 Gomniauth 的
    `User` 接口恰好定义了相同的 `AvatarURL` 方法。在实践中，当我们实例化我们的 `chatUser` 结构体，并且为隐含的 Gomniauth
    `User` 字段设置适当的值时，我们的对象同时实现了 Gomniauth 的 `User` 接口和我们的 `ChatUser` 接口。
- en: Changing interfaces in a test-driven way
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以测试驱动的方式更改接口
- en: Before we can use our new type, we must update the `Avatar` interface and appropriate
    implementations to make use of it. As we will follow TDD practices, we are going
    to first make these changes in our test file, see the compiler errors when we
    try to build our code, and see failing tests once we fix those errors before finally
    making the tests pass.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用我们的新类型之前，我们必须更新 `Avatar` 接口及其适当的实现以使用它。由于我们将遵循 TDD 实践，我们将首先在我们的测试文件中进行这些更改，当我们尝试构建代码时，我们会看到编译错误，一旦我们修复了这些错误，我们就会看到失败的测试，最终使测试通过。
- en: 'Open `avatar_test.go` and replace `TestAuthAvatar` with the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `avatar_test.go` 文件，将 `TestAuthAvatar` 替换为以下代码：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You will also need to import the `gomniauth/test` package as `gomniauthtest`,
    like we did in the last section.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要像上一节那样导入`gomniauth/test`包，作为`gomniauthtest`。
- en: Using our new interface before we have defined it is a good way to check the
    sanity of our thinking, which is another advantage of practicing TDD. In this
    new test, we create `TestUser` provided by Gomniauth and embed it into a `chatUser`
    type. We then pass the new `chatUser` type into our `GetAvatarURL` calls and make
    the same assertions about output as we always have done.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义新界面之前使用它是一种检查我们思维是否合理的有效方法，这也是实践TDD的另一个优点。在这个新的测试中，我们创建了Gomniauth提供的`TestUser`，并将其嵌入到`chatUser`类型中。然后我们将新的`chatUser`类型传递给我们的`GetAvatarURL`调用，并对输出做出与以往相同的断言。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Gomniauth's `TestUser` type is interesting as it makes use of the `Testify`
    package's mocking capabilities. Refer to [https://github.com/stretchr/testify](https://github.com/stretchr/testify)
    for more information.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Gomniauth的`TestUser`类型很有趣，因为它利用了`Testify`包的模拟功能。有关更多信息，请参阅[https://github.com/stretchr/testify](https://github.com/stretchr/testify)。
- en: The `On` and `Return` methods allow us to tell `TestUser` what to do when specific
    methods are called. In the first case, we tell the `AvatarURL` method to return
    the error, and in the second case, we ask it to return the `testUrl` value, which
    simulates the two possible outcomes we are covering in this test.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`On`和`Return`方法允许我们告诉`TestUser`在调用特定方法时应该做什么。在第一种情况下，我们告诉`AvatarURL`方法返回错误，在第二种情况下，我们要求它返回`testUrl`值，这模拟了我们在测试中覆盖的两个可能的结果。'
- en: Updating the other two tests is much simpler because they rely only on the `UniqueID`
    method, the value of which we can control directly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 更新其他两个测试要简单得多，因为它们只依赖于`UniqueID`方法，我们可以直接控制其值。
- en: 'Replace the other two tests in `avatar_test.go` with the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下代码替换`avatar_test.go`中的其他两个测试：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Of course, this test code won''t even compile because we are yet to update
    our `Avatar` interface. In `avatar.go`, update the `GetAvatarURL` signature in
    the `Avatar` interface type to take a `ChatUser` type rather than a `client` type:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段测试代码甚至无法编译，因为我们还没有更新我们的`Avatar`接口。在`avatar.go`中，将`Avatar`接口类型中的`GetAvatarURL`签名更新为接受`ChatUser`类型而不是`client`类型：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that we are using the `ChatUser` interface (with the starting letter in
    uppercase) rather than our internal `chatUser` implementation struct after all,
    we want to be flexible about the types our `GetAvatarURL` methods accept.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们最终使用的是`ChatUser`接口（首字母大写），而不是我们内部的`chatUser`实现结构体，因为我们希望我们的`GetAvatarURL`方法接受的类型更加灵活。
- en: Trying to build this will reveal that we now have broken implementations because
    all the `GetAvatarURL` methods are still asking for a `client` object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试构建这个程序将揭示我们现在有损坏的实现，因为所有的`GetAvatarURL`方法仍然要求一个`client`对象。
- en: Fixing the existing implementations
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复现有实现
- en: Changing an interface like the one we have is a good way to automatically find
    the parts of our code that have been affected because they will cause compiler
    errors. Of course, if we were writing a package that other people would use, we
    would have to be far stricter about changing the interfaces like this, but we
    haven't released our v1 yet, so it's fine.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 改变像我们这样的接口是一个自动找到受影响代码部分的好方法，因为它们将导致编译错误。当然，如果我们正在编写其他人会使用的包，我们就必须对这种接口的改变更加严格，但我们还没有发布我们的v1版本，所以这没关系。
- en: 'We are now going to update the three implementation signatures to satisfy the
    new interface and change the method bodies to make use of the new type. Replace
    the implementation for `FileSystemAvatar` with the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更新三个实现签名以满足新接口，并更改方法体以利用新类型。用以下代码替换`FileSystemAvatar`的实现：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The key change here is that we no longer access the `userData` field on the
    client, and just call `UniqueID` directly on the `ChatUser` interface instead.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里关键的改变是我们不再访问客户端的`userData`字段，而是直接在`ChatUser`接口上调用`UniqueID`。
- en: 'Next, we update the `AuthAvatar` implementation with the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们用以下代码更新`AuthAvatar`实现：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our new design proves to be much simpler, it's always a good thing if we can
    reduce the amount of code required. The preceding code makes a call to get the
    `AvatarURL` value, and provided it isn't empty, we return it; otherwise, we return
    the `ErrNoAvatarURL` error.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新设计证明要简单得多，如果我们能减少所需的代码量，那总是好事。前面的代码调用用于获取`AvatarURL`值的函数，如果它不为空，我们就返回它；否则，我们返回`ErrNoAvatarURL`错误。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note how the expected flow of the code is indented to one level, while error
    cases are nested inside `if` blocks. While you can't stick to this practice 100%
    of the time, it's a worthwhile endeavor. Being able to quickly scan the code (when
    reading it) to see the normal flow of execution down a single column allows you
    to understand the code much quicker. Compare this to code that has lots of `if...else`
    nested blocks, which takes a lot more unpicking to understand.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意代码的预期流程缩进了一级，而错误情况被嵌套在`if`块中。虽然你不可能100%坚持这种做法，但这是一种值得努力的事情。能够快速扫描代码（在阅读时）以查看单列中的正常执行流程，可以使你更快地理解代码。将此与具有大量嵌套的`if...else`块的代码进行比较，后者需要更多的时间来理解。
- en: 'Finally, update the `GravatarAvatar` implementation:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新`GravatarAvatar`实现：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Global variables versus fields
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局变量与字段对比
- en: 'So far, we have assigned the `Avatar` implementation to the `room` type, which
    enables us to use different avatars for different rooms. However, this has exposed
    an issue: when our users sign in, there is no concept of which room they are headed
    to so we cannot know which `Avatar` implementation to use. Because our application
    only supports a single room, we are going to look at another approach to select
    implementations: the use of global variables.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将`Avatar`实现分配给了`room`类型，这使得我们可以为不同的房间使用不同的头像。然而，这暴露了一个问题：当我们的用户登录时，没有关于他们要去的房间的概念，因此我们不知道要使用哪个`Avatar`实现。由于我们的应用程序只支持一个房间，我们将探讨另一种选择实现的方法：使用全局变量。
- en: 'A global variable is simply a variable that is defined outside any type definition
    and is accessible from every part of the package (and from outside the package
    if it''s exported). For a simple configuration, such as which type of `Avatar`
    implementation to use, global variables are an easy and simple solution. Underneath
    the `import` statements in `main.go`, add the following line:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量简单来说就是定义在任何类型定义之外，并且可以从包的任何部分（以及如果它被导出，则从包外部）访问的变量。对于像选择哪种`Avatar`实现这样的简单配置，全局变量是一个简单且直接的解决方案。在`main.go`中的`import`语句下方添加以下行：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This defines `avatars` as a global variable that we can use when we need to
    get the avatar URL for a particular user.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`avatars`定义为一个全局变量，我们可以在需要获取特定用户的头像URL时使用。
- en: Implementing our new design
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施我们的新设计
- en: 'We need to change the code that calls `GetAvatarURL` for every message to just
    access the value that we put into the `userData` cache (via the `auth` cookie).
    Change the line where `msg.AvatarURL` is assigned, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改调用每个消息的`GetAvatarURL`的代码，以便仅访问我们放入`userData`缓存（通过`auth`cookie）中的值。更改分配`msg.AvatarURL`的行，如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Find the code inside `loginHandler` in `auth.go` where we call `provider.GetUser`
    and replace it, down to where we set the `authCookieValue` object, with the following
    code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`auth.go`中的`loginHandler`内部找到调用`provider.GetUser`的代码，并将其替换为以下代码，直到设置`authCookieValue`对象：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we created a new `chatUser` variable while setting the `User` field (which
    represents the embedded interface) to the `User` value returned from Gomniauth.
    We then saved the `userid` MD5 hash to the `uniqueID` field.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在设置`User`字段（表示嵌入的接口）为Gomniauth返回的`User`值时创建了新的`chatUser`变量。然后我们将`userid`的MD5哈希保存到`uniqueID`字段。
- en: 'The call to `avatars.GetAvatarURL` is where all of our hard work has paid off,
    as we now get the avatar URL for the user far earlier in the process. Update the
    `authCookieValue` line in `auth.go` to cache the avatar URL in the cookie and
    remove the e-mail address since it is no longer required:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`avatars.GetAvatarURL`是我们所有辛勤工作的回报，因为我们现在在流程的早期就得到了用户的头像URL。将`auth.go`中的`authCookieValue`行更新为在cookie中缓存头像URL，并删除电子邮件地址，因为它不再需要：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: However expensive the work the `Avatar` implementation needs to do, such as
    iterating over files on the filesystem, it is mitigated by the fact that the implementation
    only does so when the user first logs in and not every time they send a message.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 无论`Avatar`实现需要执行的工作多么昂贵，例如在文件系统上迭代文件，由于实现仅在用户首次登录时执行，而不是每次发送消息时都执行，因此这个问题得到了缓解。
- en: Tidying up and testing
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整理和测试
- en: Finally, we get to snip away at some of the fat that has accumulated during
    our refactoring process.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在重构过程中积累的一些冗余代码上进行裁剪。
- en: 'Since we no longer store the `Avatar` implementation in `room`, let''s remove
    the field and all references to it from the type. In `room.go`, delete the `avatar
    Avatar` definition from the `room` struct and update the `newRoom` method:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不再在 `room` 中存储 `Avatar` 实现，让我们从类型中删除该字段及其所有引用。在 `room.go` 中，从 `room` 结构体中删除
    `avatar Avatar` 定义，并更新 `newRoom` 方法：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember to use the compiler as your to-do list where possible, and follow the
    errors to find where you have impacted other code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地将编译器用作你的待办事项列表，并跟随错误找到你影响的其他代码的地方。
- en: In `main.go`, remove the parameter passed into the `newRoom` function call since
    we are using our global variable instead of this one.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.go` 中，由于我们正在使用全局变量而不是这个参数，所以请从 `newRoom` 函数调用中移除传入的参数。
- en: After this exercise, the end user experience remains unchanged. Usually when
    refactoring the code, it is the internals that are modified while the public-facing
    interface remains stable and unchanged. As you go, remember to re-run the unit
    tests to make sure you don't break anything as you evolve the code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这次练习后，最终用户的使用体验保持不变。通常在重构代码时，内部结构会被修改，而面向公众的接口保持稳定和不变。在这个过程中，请记得重新运行单元测试，以确保在代码演变过程中没有破坏任何东西。
- en: Tip
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It's usually a good idea to run tools such as `golint` and `go vet` against
    your code as well in order to make sure it follows good practices and doesn't
    contain any Go faux pas, such as missing comments or badly named functions. There
    are a few deliberately left in for you to fix yourself.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，运行像 `golint` 和 `go vet` 这样的工具来检查你的代码是一个好主意，以确保它遵循良好的实践，并且不包含任何Go语言中的错误，例如缺少注释或函数命名不当。这里故意留下了一些错误供你自己修复。
