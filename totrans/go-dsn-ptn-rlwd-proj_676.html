<html><head></head><body><div class="book" title="Summary" id="515F21-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec0023" class="calibre1"/>Summary</h1></div></div></div><p class="calibre10">In this chapter, we added three different implementations of profile pictures to our chat application. First, we asked the auth service to provide a URL for us to use. We did this using Gomniauth's abstraction of the user resource data, which we then included as part of the user interface every time a user would send a message. Using Go's zero (or default) initialization, we were able to refer to different implementations of our <code class="email">Avatar</code> interface without actually creating any instances.</p><p class="calibre10">We stored data in a cookie for when the user would log in. Given the fact that cookies persist between builds of our code, we added a handy logout feature to help us validate our changes, which we also exposed to our users so that they could log out too. Other small changes to the code and the inclusion of Bootstrap on our chat page dramatically improved the look and feel of our application.</p><p class="calibre10">We used MD5 hashing in Go to implement the <a class="calibre1" href="https://en.gravatar.com/">https://en.gravatar.com/</a> API by hashing the e-mail address that the auth service provided. If the e-mail address is not known to Gravatar, they will deliver a nice default placeholder image for us, which means our user interface will never be broken due to missing images.</p><p class="calibre10">We then built and completed an upload form and associated the server functionality that saved uploaded pictures in the <code class="email">avatars</code> folder. We saw how to expose the saved uploaded pictures to users via the standard library's <code class="email">http.FileServer</code> handler. As this introduced inefficiencies in our design by causing too much filesystem access, we refactored our solution with the help of our unit tests. By moving the <code class="email">GetAvatarURL</code> call to the point at which users log in rather than every time a message is sent, we made our code significantly more scalable.</p><p class="calibre10">Our special <code class="email">ErrNoAvatarURL</code> error type was used as part of our interface design in order to allow us to inform the calling code when it was not possible to obtain an appropriate URL this became particularly useful when we created our <code class="email">Avatars</code> slice type. By implementing the <code class="email">Avatar</code> interface on a slice of <code class="email">Avatar</code> types, we were able to create a new implementation that took turns trying to get a valid URL from each of the different options available, starting with the filesystem, then the auth service, and finally Gravatar. We achieved this with zero impact on how the user would interact with the interface. If an implementation returned <code class="email">ErrNoAvatarURL</code>, we tried the next one.</p><p class="calibre10">Our chat application is ready to go live, so we can invite our friends and have a real conversation. But first, we need to choose a domain name to host it at, something we will look at in the next chapter.</p></div></body></html>