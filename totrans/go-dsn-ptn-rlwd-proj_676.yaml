- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added three different implementations of profile pictures
    to our chat application. First, we asked the auth service to provide a URL for
    us to use. We did this using Gomniauth's abstraction of the user resource data,
    which we then included as part of the user interface every time a user would send
    a message. Using Go's zero (or default) initialization, we were able to refer
    to different implementations of our `Avatar` interface without actually creating
    any instances.
  prefs: []
  type: TYPE_NORMAL
- en: We stored data in a cookie for when the user would log in. Given the fact that
    cookies persist between builds of our code, we added a handy logout feature to
    help us validate our changes, which we also exposed to our users so that they
    could log out too. Other small changes to the code and the inclusion of Bootstrap
    on our chat page dramatically improved the look and feel of our application.
  prefs: []
  type: TYPE_NORMAL
- en: We used MD5 hashing in Go to implement the [https://en.gravatar.com/](https://en.gravatar.com/)
    API by hashing the e-mail address that the auth service provided. If the e-mail
    address is not known to Gravatar, they will deliver a nice default placeholder
    image for us, which means our user interface will never be broken due to missing
    images.
  prefs: []
  type: TYPE_NORMAL
- en: We then built and completed an upload form and associated the server functionality
    that saved uploaded pictures in the `avatars` folder. We saw how to expose the
    saved uploaded pictures to users via the standard library's `http.FileServer`
    handler. As this introduced inefficiencies in our design by causing too much filesystem
    access, we refactored our solution with the help of our unit tests. By moving
    the `GetAvatarURL` call to the point at which users log in rather than every time
    a message is sent, we made our code significantly more scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Our special `ErrNoAvatarURL` error type was used as part of our interface design
    in order to allow us to inform the calling code when it was not possible to obtain
    an appropriate URL this became particularly useful when we created our `Avatars`
    slice type. By implementing the `Avatar` interface on a slice of `Avatar` types,
    we were able to create a new implementation that took turns trying to get a valid
    URL from each of the different options available, starting with the filesystem,
    then the auth service, and finally Gravatar. We achieved this with zero impact
    on how the user would interact with the interface. If an implementation returned
    `ErrNoAvatarURL`, we tried the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Our chat application is ready to go live, so we can invite our friends and have
    a real conversation. But first, we need to choose a domain name to host it at,
    something we will look at in the next chapter.
  prefs: []
  type: TYPE_NORMAL
