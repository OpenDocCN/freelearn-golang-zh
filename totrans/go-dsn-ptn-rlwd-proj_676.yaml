- en: Summary
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added three different implementations of profile pictures
    to our chat application. First, we asked the auth service to provide a URL for
    us to use. We did this using Gomniauth's abstraction of the user resource data,
    which we then included as part of the user interface every time a user would send
    a message. Using Go's zero (or default) initialization, we were able to refer
    to different implementations of our `Avatar` interface without actually creating
    any instances.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在聊天应用程序中添加了三种不同的个人资料图片实现。首先，我们要求认证服务为我们提供一个URL。我们使用Gomniauth对用户资源数据的抽象来完成这项工作，然后我们将其作为用户界面的一部分包含在内，每次用户发送消息时都会这样做。使用Go的零（或默认）初始化，我们能够引用我们的`Avatar`接口的不同实现，而实际上并没有创建任何实例。
- en: We stored data in a cookie for when the user would log in. Given the fact that
    cookies persist between builds of our code, we added a handy logout feature to
    help us validate our changes, which we also exposed to our users so that they
    could log out too. Other small changes to the code and the inclusion of Bootstrap
    on our chat page dramatically improved the look and feel of our application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数据存储在cookie中，以便用户登录时使用。鉴于cookie在我们代码的构建之间持续存在，我们添加了一个方便的注销功能来帮助我们验证我们的更改，我们还将其暴露给我们的用户，以便他们也可以注销。对代码的一些小改动以及Bootstrap在我们的聊天页面上的应用，极大地改善了应用程序的外观和感觉。
- en: We used MD5 hashing in Go to implement the [https://en.gravatar.com/](https://en.gravatar.com/)
    API by hashing the e-mail address that the auth service provided. If the e-mail
    address is not known to Gravatar, they will deliver a nice default placeholder
    image for us, which means our user interface will never be broken due to missing
    images.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Go中使用MD5散列来实现[https://en.gravatar.com/](https://en.gravatar.com/) API，通过散列认证服务提供的电子邮件地址。如果电子邮件地址在Gravatar上未知，他们将为我们提供一个漂亮的默认占位符图像，这意味着我们的用户界面永远不会因为缺少图像而损坏。
- en: We then built and completed an upload form and associated the server functionality
    that saved uploaded pictures in the `avatars` folder. We saw how to expose the
    saved uploaded pictures to users via the standard library's `http.FileServer`
    handler. As this introduced inefficiencies in our design by causing too much filesystem
    access, we refactored our solution with the help of our unit tests. By moving
    the `GetAvatarURL` call to the point at which users log in rather than every time
    a message is sent, we made our code significantly more scalable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们构建并完成了一个上传表单，并将服务器功能关联到`avatars`文件夹中保存上传的图片。我们看到了如何通过标准库的`http.FileServer`处理程序将保存的上传图片暴露给用户。由于这引入了设计中的低效，我们通过单元测试的帮助重构了我们的解决方案。通过将`GetAvatarURL`调用移动到用户登录的点，而不是每次发送消息时，我们使我们的代码的扩展性显著提高。
- en: Our special `ErrNoAvatarURL` error type was used as part of our interface design
    in order to allow us to inform the calling code when it was not possible to obtain
    an appropriate URL this became particularly useful when we created our `Avatars`
    slice type. By implementing the `Avatar` interface on a slice of `Avatar` types,
    we were able to create a new implementation that took turns trying to get a valid
    URL from each of the different options available, starting with the filesystem,
    then the auth service, and finally Gravatar. We achieved this with zero impact
    on how the user would interact with the interface. If an implementation returned
    `ErrNoAvatarURL`, we tried the next one.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特殊的`ErrNoAvatarURL`错误类型被用作我们界面设计的一部分，以便我们能够在无法获取适当的URL时通知调用代码。当我们创建我们的`Avatars`切片类型时，这一点变得特别有用。通过在`Avatar`类型切片上实现`Avatar`接口，我们能够创建一个新的实现，它轮流尝试从不同的选项中获取有效的URL，首先是文件系统，然后是认证服务，最后是Gravatar。我们通过不对用户与界面交互的方式产生任何影响来实现这一点。如果一个实现返回`ErrNoAvatarURL`，我们就尝试下一个。
- en: Our chat application is ready to go live, so we can invite our friends and have
    a real conversation. But first, we need to choose a domain name to host it at,
    something we will look at in the next chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已经准备好上线，因此我们可以邀请我们的朋友进行真正的对话。但首先，我们需要选择一个域名来托管它，这一点我们将在下一章中探讨。
