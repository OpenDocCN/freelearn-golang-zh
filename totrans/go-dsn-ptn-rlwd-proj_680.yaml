- en: Sprinkle
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 撒上
- en: Our first program augments the incoming words with some sugar terms in order
    to improve the odds of finding names that are available. Many companies use this
    approach to keep the core messaging consistent while being able to afford the
    `.com` domain. For example, if we pass in the word `chat`, it might pass out `chatapp`;
    alternatively, if we pass in `talk`, we may get back `talk time`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个程序通过添加一些糖术语来增强传入的单词，以提高找到可用的名称的机会。许多公司使用这种方法来保持核心信息的连贯性，同时能够负担得起 `.com`
    域名。例如，如果我们传入单词 `chat`，它可能会输出 `chatapp`；或者，如果我们传入 `talk`，我们可能会得到 `talk time`。
- en: Go's `math/rand` package allows us to break away from the predictability of
    computers. It gives our program the appearance of intelligence by introducing
    elements of chance into its decision making.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的 `math/rand` 包允许我们摆脱计算机的可预测性。通过将其决策过程中引入随机元素，它使我们的程序看起来具有智能。
- en: 'To make our Sprinkle program work, we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的 Sprinkle 程序工作，我们将：
- en: Define an array of transformations, using a special constant to indicate where
    the original word will appear
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个转换数组，使用一个特殊常量来表示原始单词将出现的位置
- en: Use the `bufio` package to scan the input from `stdin` and `fmt.Println` in
    order to write the output to `stdout`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `bufio` 包从 `stdin` 扫描输入，并使用 `fmt.Println` 将输出写入 `stdout`
- en: Use the `math/rand` package to randomly select a transformation to apply
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `math/rand` 包随机选择一个转换来应用
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: All our programs will reside in the `$GOPATH/src` directory. For example, if
    your GOPATH is `~/Work/projects/go`, you would create your program folders in
    the `~/Work/projects/go/src` folder.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有程序都将驻留在 `$GOPATH/src` 目录下。例如，如果你的 GOPATH 是 `~/Work/projects/go`，你将在 `~/Work/projects/go/src`
    文件夹中创建你的程序文件夹。
- en: 'In the `$GOPATH/src` directory, create a new folder called `sprinkle` and add
    a `main.go` file containing the following code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `$GOPATH/src` 目录下，创建一个名为 `sprinkle` 的新文件夹，并添加一个包含以下代码的 `main.go` 文件：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From now on, it is assumed that you will sort out the appropriate `import` statements
    yourself. If you need assistance, refer to the tips provided in [Appendix](part0227_split_000.html#6OFFM1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "Appendix Appendix. Good Practices for a Stable Go Environment"), *Good Practices
    for a Stable Go Environment*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，假设你将自行整理适当的 `import` 语句。如果你需要帮助，请参阅提供的提示，见[附录](part0227_split_000.html#6OFFM1-9c484ed022e64a0fb0e1aebf8e05d4fd
    "附录 附录。 良好的 Go 环境实践")，*良好的 Go 环境实践*。
- en: 'The preceding code represents our complete Sprinkle program. It defines three
    things: a constant, a variable, and the obligatory `main` function, which serves
    as the entry point to Sprinkle. The `otherWord` constant string is a helpful token
    that allows us to specify where the original word should occur in each of our
    possible transformations. It lets us write code, such as `otherWord+"extra"`,
    which makes it clear that in this particular case, we want to add the word "extra"
    to the end of the original word.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码代表我们的完整 Sprinkle 程序。它定义了三件事：一个常量、一个变量和必需的 `main` 函数，它作为 Sprinkle 的入口点。`otherWord`
    常量字符串是一个有用的标记，允许我们指定在每种可能的转换中原始单词应该出现的位置。它让我们能够编写如 `otherWord+"extra"` 这样的代码，这清楚地表明在这个特定情况下，我们想在原始单词的末尾添加单词
    "extra"。
- en: The possible transformations are stored in the `transforms` variable that we
    declare as a slice of strings. In the preceding code, we defined a few different
    transformations, such as adding `app` to the end of a word or `lets` before it.
    Feel free to add some more; the more creative, the better.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的转换存储在我们声明的字符串切片变量 `transforms` 中。在先前的代码中，我们定义了一些不同的转换，例如在单词末尾添加 `app` 或者在它之前添加
    `lets`。请随意添加更多；越有创意越好。
- en: In the `main` function, the first thing we do is use the current time as a random
    seed. Computers can't actually generate random numbers, but changing the seed
    number of random algorithms gives the illusion that it can. We use the current
    time in nanoseconds because it's different each time the program is run (provided
    the system clock isn't being reset before each run). If we skip this step, the
    numbers generated by the `math/rand` package would be deterministic; they'd be
    the same every time we run the program.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们首先使用当前时间作为随机种子。计算机实际上不能生成随机数，但改变随机算法的种子数字可以给人一种它可以的错觉。我们使用纳秒作为当前时间，因为每次程序运行时它都是不同的（前提是在每次运行之前系统时钟没有被重置）。如果我们跳过这一步，`math/rand`
    包生成的数字将是确定的；每次运行程序时它们都是相同的。
- en: We then create a `bufio.Scanner` object (by calling `bufio.NewScanner`) and
    tell it to read the input from `os.Stdin`, which represents the standard input
    stream. This will be a common pattern in our five programs since we are always
    going to read from the standard *in* and write to the standard *out*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个 `bufio.Scanner` 对象（通过调用 `bufio.NewScanner`），并告诉它从 `os.Stdin` 读取输入，`os.Stdin`
    代表标准输入流。在我们的五个程序中，这将是一个常见的模式，因为我们总是要从标准 *in* 读取并写入标准 *out*。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `bufio.Scanner` object actually takes `io.Reader` as its input source, so
    there is a wide range of types that we could use here. If you were writing unit
    tests for this code, you could specify your own `io.Reader` for the scanner to
    read from, removing the need for you to worry about simulating the standard input
    stream.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`bufio.Scanner` 对象实际上接受 `io.Reader` 作为其输入源，因此我们可以使用多种类型。如果你正在为此代码编写单元测试，你可以为扫描器指定自己的
    `io.Reader` 以供读取，从而无需担心模拟标准输入流。'
- en: As the default case, the scanner allows us to read blocks of bytes separated
    by defined delimiters, such as carriage return and linefeed characters. We can
    specify our own split function for the scanner or use one of the options built
    in the standard library. For example, there is `bufio.ScanWords`, which scans
    individual words by breaking on whitespace rather than linefeeds. Since our design
    specifies that each line must contain a word (or a short phrase), the default
    line-by-line setting is ideal.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为默认情况，扫描器允许我们读取由定义的分隔符分隔的字节块，例如回车和换行字符。我们可以为扫描器指定自己的分割函数，或者使用标准库中内置的选项。例如，有
    `bufio.ScanWords`，它通过在空白处而不是换行处断开来扫描单个单词。由于我们的设计指定每行必须包含一个单词（或短语），因此默认的按行设置是理想的。
- en: A call to the `Scan` method tells the scanner to read the next block of bytes
    (the next line) from the input, and then it returns a `bool` value indicating
    whether it found anything or not. This is how we are able to use it as the condition
    for the `for` loop. While there is content to work on, `Scan` returns `true` and
    the body of the `for` loop is executed; when `Scan` reaches the end of the input,
    it returns `false`, and the loop is broken. The bytes that are selected are stored
    in the `Bytes` method of the scanner, and the handy `Text` method that we use
    converts the `[]byte` slice into a string for us.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `Scan` 方法告诉扫描器从输入中读取下一个字节数组块（下一行），然后它返回一个 `bool` 值，指示是否找到了内容。这就是我们能够将其用作
    `for` 循环条件的原因。当有内容可处理时，`Scan` 返回 `true` 并执行 `for` 循环的主体；当 `Scan` 达到输入的末尾时，它返回
    `false`，循环被中断。所选的字节存储在扫描器的 `Bytes` 方法中，我们使用的方便的 `Text` 方法将 `[]byte` 切片转换为字符串。
- en: Inside the `for` loop (so for each line of input), we use `rand.Intn` to select
    a random item from the `transforms` slice and use `strings.Replace` to insert
    the original word where the `otherWord` string appears. Finally, we use `fmt.Println`
    to print the output to the default standard output stream.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `for` 循环内部（即对于每一行输入），我们使用 `rand.Intn` 从 `transforms` 切片中选择一个随机项，并使用 `strings.Replace`
    在 `otherWord` 字符串出现的位置插入原始单词。最后，我们使用 `fmt.Println` 将输出打印到默认的标准输出流。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `math/rand` package provides insecure random numbers. If you want to write
    code that utilizes random numbers for security purposes, you must use the `crypto/rand`
    package instead.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`math/rand` 包提供不安全的随机数。如果你想要编写利用随机数进行安全目的的代码，你必须使用 `crypto/rand` 包。'
- en: 'Let''s build our program and play with it:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的程序并与之互动：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the program starts running, it will use the default behavior to read the
    user input from the terminal. It uses the default behavior because we haven''t
    piped in any content or specified a source for it to read from. Type `chat` and
    hit return. The scanner in our code notices the linefeed character at the end
    of the word and runs the code that transforms it, outputting the result. For example,
    if you type `chat` a few times, you would see the following output:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序开始运行，它将使用默认行为从终端读取用户输入。它使用默认行为是因为我们没有管道输入任何内容或指定读取源。输入 `chat` 并按回车键。我们代码中的扫描器注意到单词末尾的换行字符，并运行转换代码，输出结果。例如，如果你多次输入
    `chat`，你会看到以下输出：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Sprinkle never exits (meaning the `Scan` method never returns `false` to break
    the loop) because the terminal is still running; in normal execution, the in pipe
    will be closed by whatever program is generating the input. To stop the program,
    hit *Ctrl + C*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Sprinkle 不会退出（这意味着 `Scan` 方法永远不会返回 `false` 来中断循环），因为终端仍在运行；在正常执行中，输入管道将由生成输入的任何程序关闭。要停止程序，请按
    *Ctrl + C*。
- en: 'Before we move on, let''s try to run Sprinkle, specifying a different input
    source. We are going to use the `echo` command to generate some content and pipe
    it to our Sprinkle program using the pipe character:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们尝试运行 Sprinkle，指定一个不同的输入源。我们将使用 `echo` 命令生成一些内容，并通过管道字符将其传递给我们的 Sprinkle
    程序：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The program will randomly transform the word, print it out, and exit since the
    `echo` command generates only one line of input before terminating and closing
    the pipe.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将随机变换单词，打印出来，然后退出，因为 `echo` 命令在终止和关闭管道之前只生成一行输入。
- en: We have successfully completed our first program, which has a very simple but
    useful function, as we will see.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功完成了我们的第一个程序，它具有非常简单但有用的功能，正如我们将看到的。
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As an extra assignment, rather than hardcoding the `transformations` array as
    we have done, see whether you can externalize it via flags or store them in a
    text file or database.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的作业，而不是像我们之前那样硬编码 `transformations` 数组，看看你是否可以通过标志将其外部化，或者将它们存储在文本文件或数据库中。
