<html><head></head><body>
<div class="book" title="Five simple programs">
<div class="book" title="Coolify"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec0042" class="calibre1"/>Coolify</h2></div></div></div><p class="calibre10">Often, domain names for common words, such as <code class="email">chat</code>, are already taken, and a common solution is to play around with the vowels in the words. For example, we might remove <code class="email">a</code> and make it <code class="email">cht</code> (which is actually less likely to be available) or add <code class="email">a</code> to produce <code class="email">chaat</code>. While this clearly has no actual effect on coolness, it has become a popular, albeit slightly dated, way to secure domain names that still sound like the original word.</p><p class="calibre10">Our third program, Coolify, will allow us to play with the vowels of words that come in via the input and write modified versions to the output.</p><p class="calibre10">Create a new folder called <code class="email">coolify</code> alongside <code class="email">sprinkle</code> and <code class="email">domainify</code>, and create the <code class="email">main.go</code> code file with the following code:</p><pre class="programlisting">package main 
const ( 
  duplicateVowel bool   = true 
  removeVowel    bool   = false 
)  
func randBool() bool { 
  return rand.Intn(2) == 0 
} 
func main() { 
  rand.Seed(time.Now().UTC().UnixNano()) 
  s := bufio.NewScanner(os.Stdin) 
  for s.Scan() { 
    word := []byte(s.Text()) 
    if randBool() { 
      var vI int = -1 
      for i, char := range word { 
        switch char { 
        case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U': 
          if randBool() { 
            vI = i 
          } 
        } 
      } 
      if vI &gt;= 0 { 
        switch randBool() { 
        case duplicateVowel: 
          word = append(word[:vI+1], word[vI:]...) 
        case removeVowel: 
          word = append(word[:vI], word[vI+1:]...) 
        } 
      } 
    } 
    fmt.Println(string(word)) 
  } 
} 
</pre><p class="calibre10">While the preceding Coolify code looks very similar to the code of Sprinkle and Domainify, it is slightly more complicated. At the very top of the code, we declare two constants, <code class="email">duplicateVowel</code> and <code class="email">removeVowel</code>, that help make the Coolify code more readable. The <code class="email">switch</code> statement decides whether we duplicate or remove a vowel. Also, using these constants, we are able to express our intent very clearly, rather than use just <code class="email">true</code> or <code class="email">false</code>.</p><p class="calibre10">We then define the <code class="email">randBool</code> helper function that just randomly returns either <code class="email">true</code> or <code class="email">false</code>. This is done by asking the <code class="email">rand</code> package to generate a random number and confirming whether that number comes out as zero. It will be either <code class="email">0</code> or <code class="email">1</code>, so there's a fifty-fifty chance of it being <code class="email">true</code>.</p><p class="calibre10">The <code class="email">main</code> function of Coolify starts the same way as that of Sprinkle and Domainify setting the <code class="email">rand.Seed</code> method and creating a scanner of the standard input stream before executing the loop body for each line of input. We call <code class="email">randBool</code> first to decide whether we are even going to mutate a word or not, so Coolify will only affect half the words passed through it.</p><p class="calibre10">We then iterate over each rune in the string and look for a vowel. If our <code class="email">randBool</code> method returns <code class="email">true</code>, we keep the index of the vowel character in the <code class="email">vI</code> variable. If not, we keep looking through the string for another vowel, which allows us to randomly select a vowel from the words rather than always modify the same one.</p><p class="calibre10">Once we have selected a vowel, we use <code class="email">randBool</code> again to randomly decide what action to take.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note0063" class="calibre1"/>Note</h3><p class="calibre10">This is where the helpful constants come in; consider the following alternative switch statement:
</p><pre class="programlisting">
<code class="email">switch randBool() { </code>
<code class="email">  case true:</code>
<code class="email">    word = append(word[:vI+1], word[vI:]...)</code>
<code class="email">  case false:</code>
<code class="email">    word = append(word[:vI], word[vI+1:]...) }</code>
</pre><p class="calibre10">
</p><p class="calibre10">In the preceding code snippet, it's difficult to tell what is going on because <code class="email">true</code> and <code class="email">false</code> don't express any context. On the other hand, using <code class="email">duplicateVowel</code> and <code class="email">removeVowel</code> tells anyone reading the code what we mean by the result of <code class="email">randBool</code>.</p></div><p class="calibre10">The three dots following the slices cause each item to pass as a separate argument to the <code class="email">append</code> function. This is an idiomatic way of appending one slice to another. Inside the <code class="email">switch</code> case, we do some slice manipulation to either duplicate the vowel or remove it altogether. We are slicing our <code class="email">[]byte</code> slice again and using the <code class="email">append</code> function to build a new one made up of sections of the original word. The following diagram shows which sections of the string we access in our code:</p><p class="calibre10">
</p><div class="mediaobject"><img src="../images/00055.jpeg" alt="Coolify" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">
</p><p class="calibre10">If we take the value <code class="email">blueprints</code> as an example word and assume that our code has selected the first <code class="email">e</code> character as the vowel (so that <code class="email">vI</code> is <code class="email">3</code>), the following table will illustrate what each new slice of the word will represent:</p><div class="informaltable"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/><col class="calibre19"/></colgroup><tbody class="calibre20"><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Code</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Value</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Description</strong></span>
</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<code class="literal">word[:vI+1]</code>
</p>
</td><td class="calibre22">
<p class="calibre23">blue</p>
</td><td class="calibre22">
<p class="calibre23">This describes the slice from the beginning of the word until the selected vowel. The <code class="literal">+1</code> is required because the value following the colon does not include the specified index; rather, it slices up to that value.</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<code class="literal">word[vI:]</code>
</p>
</td><td class="calibre22">
<p class="calibre23">eprints</p>
</td><td class="calibre22">
<p class="calibre23">This describes the slice starting from and including the selected vowel to the end of the slice.</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<code class="literal">word[:vI]</code>
</p>
</td><td class="calibre22">
<p class="calibre23">blu</p>
</td><td class="calibre22">
<p class="calibre23">This describes the slice from the beginning of the word up to, but not including, the selected vowel.</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<code class="literal">word[vI+1:]</code>
</p>
</td><td class="calibre22">
<p class="calibre23">prints</p>
</td><td class="calibre22">
<p class="calibre23">This describes the slice from the item following the selected vowel to the end of the slice.</p>
</td></tr></tbody></table></div><p class="calibre10">After we modify the word, we print it out using <code class="email">fmt.Println</code>.</p><p class="calibre10">Let's build Coolify and play with it to see what it can do:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go build -o coolify</strong></span>
<span class="strong"><strong class="calibre2">./coolify</strong></span>
</pre><p class="calibre10">When Coolify is running, try typing <code class="email">blueprints</code> to see what sort of modifications it comes up with:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">blueprnts</strong></span>
<span class="strong"><strong class="calibre2">bleprints</strong></span>
<span class="strong"><strong class="calibre2">bluepriints</strong></span>
<span class="strong"><strong class="calibre2">blueprnts</strong></span>
<span class="strong"><strong class="calibre2">blueprints</strong></span>
<span class="strong"><strong class="calibre2">bluprints</strong></span>
</pre><p class="calibre10">Let's see how Coolify plays with Sprinkle and Domainify by adding their names to our pipe chain. In the terminal, navigate back (using the <code class="email">cd</code> command) to the parent folder and run the following commands:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">./coolify/coolify | ./sprinkle/sprinkle | ./domainify/domainify</strong></span>
</pre><p class="calibre10">We will first spice up a word with extra pieces and make it cooler by tweaking the vowels before finally transforming it into a valid domain name. Play around by typing in a few words and seeing what suggestions our code makes.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip64" class="calibre1"/>Tip</h3><p class="calibre10">Coolify only works on vowels; as an additional exercise, see whether you can make the code operate on every character it encounters just to see what happens.</p></div></div></div></body></html>