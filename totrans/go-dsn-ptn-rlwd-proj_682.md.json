["```go\npackage main \nconst ( \n  duplicateVowel bool   = true \n  removeVowel    bool   = false \n)  \nfunc randBool() bool { \n  return rand.Intn(2) == 0 \n} \nfunc main() { \n  rand.Seed(time.Now().UTC().UnixNano()) \n  s := bufio.NewScanner(os.Stdin) \n  for s.Scan() { \n    word := []byte(s.Text()) \n    if randBool() { \n      var vI int = -1 \n      for i, char := range word { \n        switch char { \n        case 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U': \n          if randBool() { \n            vI = i \n          } \n        } \n      } \n      if vI >= 0 { \n        switch randBool() { \n        case duplicateVowel: \n          word = append(word[:vI+1], word[vI:]...) \n        case removeVowel: \n          word = append(word[:vI], word[vI+1:]...) \n        } \n      } \n    } \n    fmt.Println(string(word)) \n  } \n} \n\n```", "```go\nswitch randBool() { \n  case true:\n    word = append(word[:vI+1], word[vI:]...)\n  case false:\n    word = append(word[:vI], word[vI+1:]...) }\n\n```", "```go\ntrue and false don't express any context. On the other hand, using duplicateVowel and removeVowel tells anyone reading the code what we mean by the result of randBool.\n```", "```go\ngo build -o coolify\n./coolify\n\n```", "```go\nblueprnts\nbleprints\nbluepriints\nblueprnts\nblueprints\nbluprints\n\n```", "```go\n./coolify/coolify | ./sprinkle/sprinkle | ./domainify/domainify\n\n```"]