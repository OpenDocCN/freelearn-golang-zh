- en: Coolify
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Coolify
- en: Often, domain names for common words, such as `chat`, are already taken, and
    a common solution is to play around with the vowels in the words. For example,
    we might remove `a` and make it `cht` (which is actually less likely to be available)
    or add `a` to produce `chaat`. While this clearly has no actual effect on coolness,
    it has become a popular, albeit slightly dated, way to secure domain names that
    still sound like the original word.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，像 `chat` 这样的常见单词的域名已经被占用，一个常见的解决方案是在单词的元音上玩弄。例如，我们可能会删除 `a` 并将其变为 `cht`（这实际上更不可能可用）或添加
    `a` 以产生 `chaat`。虽然这显然对酷度没有实际影响，但它已经成为一种流行但略过时的方法，以确保听起来像原始单词的域名。
- en: Our third program, Coolify, will allow us to play with the vowels of words that
    come in via the input and write modified versions to the output.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个程序，Coolify，将允许我们玩转通过输入传入的单词的元音，并将修改后的版本写入输出。
- en: 'Create a new folder called `coolify` alongside `sprinkle` and `domainify`,
    and create the `main.go` code file with the following code:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sprinkle` 和 `domainify` 旁边创建一个名为 `coolify` 的新文件夹，并创建一个包含以下代码的 `main.go` 代码文件：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While the preceding Coolify code looks very similar to the code of Sprinkle
    and Domainify, it is slightly more complicated. At the very top of the code, we
    declare two constants, `duplicateVowel` and `removeVowel`, that help make the
    Coolify code more readable. The `switch` statement decides whether we duplicate
    or remove a vowel. Also, using these constants, we are able to express our intent
    very clearly, rather than use just `true` or `false`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的 Coolify 代码看起来与 Sprinkle 和 Domainify 的代码非常相似，但它稍微复杂一些。在代码的最顶部，我们声明了两个常量，`duplicateVowel`
    和 `removeVowel`，这有助于使 Coolify 代码更易于阅读。`switch` 语句决定我们是要复制还是删除元音。此外，使用这些常量，我们能够非常清楚地表达我们的意图，而不是仅仅使用
    `true` 或 `false`。
- en: We then define the `randBool` helper function that just randomly returns either
    `true` or `false`. This is done by asking the `rand` package to generate a random
    number and confirming whether that number comes out as zero. It will be either
    `0` or `1`, so there's a fifty-fifty chance of it being `true`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `randBool` 的辅助函数，它随机返回 `true` 或 `false`。这是通过请求 `rand` 包生成一个随机数并确认该数字是否为零来实现的。它将是
    `0` 或 `1`，因此有五五分的机会是 `true`。
- en: The `main` function of Coolify starts the same way as that of Sprinkle and Domainify
    setting the `rand.Seed` method and creating a scanner of the standard input stream
    before executing the loop body for each line of input. We call `randBool` first
    to decide whether we are even going to mutate a word or not, so Coolify will only
    affect half the words passed through it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Coolify 的 `main` 函数与 Sprinkle 和 Domainify 的 `main` 函数以相同的方式开始，设置 `rand.Seed`
    方法并在执行循环体之前创建标准输入流的扫描器。我们首先调用 `randBool` 来决定我们是否要突变一个单词，因此 Coolify 只会影响通过它的单词的一半。
- en: We then iterate over each rune in the string and look for a vowel. If our `randBool`
    method returns `true`, we keep the index of the vowel character in the `vI` variable.
    If not, we keep looking through the string for another vowel, which allows us
    to randomly select a vowel from the words rather than always modify the same one.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历字符串中的每个 rune 并寻找元音。如果我们的 `randBool` 方法返回 `true`，我们将元音字符的索引保存在 `vI` 变量中。如果不，我们将继续在字符串中寻找另一个元音，这允许我们从单词中随机选择一个元音，而不是总是修改同一个元音。
- en: Once we have selected a vowel, we use `randBool` again to randomly decide what
    action to take.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了一个元音，我们再次使用 `randBool` 来随机决定采取什么行动。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'This is where the helpful constants come in; consider the following alternative
    switch statement:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是有用的常量发挥作用的地方；考虑以下替代的 `switch` 语句：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The three dots following the slices cause each item to pass as a separate argument
    to the `append` function. This is an idiomatic way of appending one slice to another.
    Inside the `switch` case, we do some slice manipulation to either duplicate the
    vowel or remove it altogether. We are slicing our `[]byte` slice again and using
    the `append` function to build a new one made up of sections of the original word.
    The following diagram shows which sections of the string we access in our code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 后面跟着的三个点导致每个项目都作为单独的参数传递给 `append` 函数。这是将一个切片附加到另一个切片的惯用方式。在 `switch` 情况中，我们进行一些切片操作，要么复制元音，要么完全删除它。我们再次对
    `[]byte` 切片进行切片，并使用 `append` 函数构建一个新的切片，它由原始单词的部分组成。以下图表显示了我们在代码中访问的字符串部分：
- en: '![Coolify](img/00055.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Coolify](img/00055.jpeg)'
- en: 'If we take the value `blueprints` as an example word and assume that our code
    has selected the first `e` character as the vowel (so that `vI` is `3`), the following
    table will illustrate what each new slice of the word will represent:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以 `blueprints` 作为示例单词，并假设我们的代码选择了第一个 `e` 字符作为元音（因此 `vI` 是 `3`），以下表格将说明每个新的单词切片将代表什么：
- en: '| **Code** | **Value** | **Description** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **代码** | **值** | **描述** |'
- en: '| `word[:vI+1]` | blue | This describes the slice from the beginning of the
    word until the selected vowel. The `+1` is required because the value following
    the colon does not include the specified index; rather, it slices up to that value.
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `word[:vI+1]` | blue | 这描述了从单词开头到所选元音的切片。`+1` 是必需的，因为冒号后面的值不包括指定的索引；相反，它切片到那个值。
    |'
- en: '| `word[vI:]` | eprints | This describes the slice starting from and including
    the selected vowel to the end of the slice. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `word[vI:]` | eprints | 这描述了从所选元音开始并包括所选元音的切片。 |'
- en: '| `word[:vI]` | blu | This describes the slice from the beginning of the word
    up to, but not including, the selected vowel. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `word[:vI]` | blu | 这描述了从单词开头到所选元音之前的切片。 |'
- en: '| `word[vI+1:]` | prints | This describes the slice from the item following
    the selected vowel to the end of the slice. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `word[vI+1:]` | prints | 这描述了从所选元音之后的项到切片末尾的切片。 |'
- en: After we modify the word, we print it out using `fmt.Println`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 修改完单词后，我们使用 `fmt.Println` 打印它。
- en: 'Let''s build Coolify and play with it to see what it can do:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建 Coolify 并玩玩它，看看它能做什么：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When Coolify is running, try typing `blueprints` to see what sort of modifications
    it comes up with:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Coolify 运行时，尝试输入 `blueprints` 来查看它提出了什么样的修改：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s see how Coolify plays with Sprinkle and Domainify by adding their names
    to our pipe chain. In the terminal, navigate back (using the `cd` command) to
    the parent folder and run the following commands:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Coolify 如何与 Sprinkle 和 Domainify 玩耍，通过将它们的名称添加到我们的管道链中。在终端中，使用 `cd` 命令返回父文件夹，并运行以下命令：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will first spice up a word with extra pieces and make it cooler by tweaking
    the vowels before finally transforming it into a valid domain name. Play around
    by typing in a few words and seeing what suggestions our code makes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过添加额外的部分来丰富一个单词，并通过调整元音使其更加酷，最后将其转换为一个有效的域名。尝试输入几个单词，看看我们的代码会提出什么建议。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Coolify only works on vowels; as an additional exercise, see whether you can
    make the code operate on every character it encounters just to see what happens.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Coolify 只作用于元音；作为额外的练习，看看你能否让代码对遇到的每个字符都进行操作，以查看会发生什么。
