- en: Coolify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, domain names for common words, such as `chat`, are already taken, and
    a common solution is to play around with the vowels in the words. For example,
    we might remove `a` and make it `cht` (which is actually less likely to be available)
    or add `a` to produce `chaat`. While this clearly has no actual effect on coolness,
    it has become a popular, albeit slightly dated, way to secure domain names that
    still sound like the original word.
  prefs: []
  type: TYPE_NORMAL
- en: Our third program, Coolify, will allow us to play with the vowels of words that
    come in via the input and write modified versions to the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder called `coolify` alongside `sprinkle` and `domainify`,
    and create the `main.go` code file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: While the preceding Coolify code looks very similar to the code of Sprinkle
    and Domainify, it is slightly more complicated. At the very top of the code, we
    declare two constants, `duplicateVowel` and `removeVowel`, that help make the
    Coolify code more readable. The `switch` statement decides whether we duplicate
    or remove a vowel. Also, using these constants, we are able to express our intent
    very clearly, rather than use just `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: We then define the `randBool` helper function that just randomly returns either
    `true` or `false`. This is done by asking the `rand` package to generate a random
    number and confirming whether that number comes out as zero. It will be either
    `0` or `1`, so there's a fifty-fifty chance of it being `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function of Coolify starts the same way as that of Sprinkle and Domainify
    setting the `rand.Seed` method and creating a scanner of the standard input stream
    before executing the loop body for each line of input. We call `randBool` first
    to decide whether we are even going to mutate a word or not, so Coolify will only
    affect half the words passed through it.
  prefs: []
  type: TYPE_NORMAL
- en: We then iterate over each rune in the string and look for a vowel. If our `randBool`
    method returns `true`, we keep the index of the vowel character in the `vI` variable.
    If not, we keep looking through the string for another vowel, which allows us
    to randomly select a vowel from the words rather than always modify the same one.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have selected a vowel, we use `randBool` again to randomly decide what
    action to take.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is where the helpful constants come in; consider the following alternative
    switch statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The three dots following the slices cause each item to pass as a separate argument
    to the `append` function. This is an idiomatic way of appending one slice to another.
    Inside the `switch` case, we do some slice manipulation to either duplicate the
    vowel or remove it altogether. We are slicing our `[]byte` slice again and using
    the `append` function to build a new one made up of sections of the original word.
    The following diagram shows which sections of the string we access in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coolify](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we take the value `blueprints` as an example word and assume that our code
    has selected the first `e` character as the vowel (so that `vI` is `3`), the following
    table will illustrate what each new slice of the word will represent:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code** | **Value** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `word[:vI+1]` | blue | This describes the slice from the beginning of the
    word until the selected vowel. The `+1` is required because the value following
    the colon does not include the specified index; rather, it slices up to that value.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `word[vI:]` | eprints | This describes the slice starting from and including
    the selected vowel to the end of the slice. |'
  prefs: []
  type: TYPE_TB
- en: '| `word[:vI]` | blu | This describes the slice from the beginning of the word
    up to, but not including, the selected vowel. |'
  prefs: []
  type: TYPE_TB
- en: '| `word[vI+1:]` | prints | This describes the slice from the item following
    the selected vowel to the end of the slice. |'
  prefs: []
  type: TYPE_TB
- en: After we modify the word, we print it out using `fmt.Println`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build Coolify and play with it to see what it can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When Coolify is running, try typing `blueprints` to see what sort of modifications
    it comes up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how Coolify plays with Sprinkle and Domainify by adding their names
    to our pipe chain. In the terminal, navigate back (using the `cd` command) to
    the parent folder and run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will first spice up a word with extra pieces and make it cooler by tweaking
    the vowels before finally transforming it into a valid domain name. Play around
    by typing in a few words and seeing what suggestions our code makes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Coolify only works on vowels; as an additional exercise, see whether you can
    make the code operate on every character it encounters just to see what happens.
  prefs: []
  type: TYPE_NORMAL
