- en: Synonyms
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同义词
- en: So far, our programs have only modified words, but to really bring our solution
    to life, we need to be able to integrate a third-party API that provides word
    synonyms. This allows us to suggest different domain names while retaining the
    original meaning. Unlike Sprinkle and Domainify, Synonyms will write out more
    than one response for each word given to it. Our architecture of piping programs
    together means this won't be much of a problem; in fact, we do not even have to
    worry about it since each of the three programs is capable of reading multiple
    lines from the input source.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的程序只修改了单词，但为了真正使我们的解决方案生动起来，我们需要能够集成一个提供单词同义词的第三方API。这允许我们在保留原始意义的同时提出不同的域名。与Sprinkle和Domainify不同，Synonyms将为每个给定的单词写出多个响应。我们通过管道连接程序一起的架构意味着这不会成为太大的问题；事实上，我们甚至不必担心它，因为这三个程序中的每一个都能够从输入源中读取多行。
- en: Big Huge Thesaurus, [http://bighugelabs.com/](http://bighugelabs.com/), has
    a very clean and simple API that allows us to make a single HTTP `GET` request
    to look up synonyms.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Big Huge Thesaurus，[http://bighugelabs.com/](http://bighugelabs.com/)，有一个非常干净和简单的API，允许我们通过发送单个HTTP
    `GET`请求来查找同义词。
- en: Tip
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In future, if the API we are using changes or disappears (after all, we're dealing
    with the Internet), you will find some options at [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，如果我们使用的API发生变化或消失（毕竟，我们在处理互联网），你将在[https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)找到一些选项。
- en: Before you can use Big Huge Thesaurus, you'll need an API key, which you can
    get by signing up to the service at [http://words.bighugelabs.com/](http://words.bighugelabs.com/).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够使用Big Huge Thesaurus之前，你需要一个API密钥，你可以通过在[http://words.bighugelabs.com/](http://words.bighugelabs.com/)注册服务来获取。
- en: Using environment variables for configuration
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用环境变量进行配置
- en: Your API key is a sensitive piece of configuration information that you don't
    want to share with others. We could store it as `const` in our code. However,
    this would mean we will not be able to share our code without sharing our key
    (not good, especially if you love open source projects). Additionally, perhaps
    more importantly, you will have to recompile your entire project if the key expires
    or if you want to use a different one (you don't want to get into such a situation).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你的API密钥是一段敏感的配置信息，你不希望与他人分享。我们可以在代码中将它存储为`const`。然而，这意味着如果我们不分享我们的密钥，我们就无法分享我们的代码（这并不好，尤其是如果你喜欢开源项目）。此外，也许更重要的是，如果密钥过期或你想使用另一个密钥，你将不得不重新编译你的整个项目（你不想陷入这样的境地）。
- en: A better solution is using an environment variable to store the key, as this
    will allow you to easily change it if you need to. You could also have different
    keys for different deployments; perhaps you could have one key for development
    or testing and another for production. This way, you can set a specific key for
    a particular execution of code so you can easily switch between keys without having
    to change your system-level settings. Also, different operating systems deal with
    environment variables in similar ways, so they are a perfect choice if you are
    writing cross-platform code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的解决方案是使用环境变量来存储密钥，因为这样你可以在需要时轻松地更改它。你也可以为不同的部署使用不同的密钥；也许你可以为开发和测试使用一个密钥，而为生产使用另一个密钥。这样，你可以为特定的代码执行设置一个特定的密钥，这样你就可以轻松地在密钥之间切换，而无需更改系统级设置。此外，不同的操作系统以类似的方式处理环境变量，所以如果你正在编写跨平台代码，它们是一个完美的选择。
- en: Create a new environment variable called `BHT_APIKEY` and set your API key as
    its value.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`BHT_APIKEY`的新环境变量，并将其值设置为你的API密钥。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For machines running a bash shell, you can modify your `~/.bashrc` file or
    similar to include `export` commands, such as the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行bash shell的机器，你可以修改你的`~/.bashrc`文件或类似的文件，以包含以下`export`命令：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: On Windows machines, you can navigate to the properties of your computer and
    look for **Environment Variables** in the **Advanced** section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows机器上，你可以导航到你的计算机属性，在**高级**部分查找**环境变量**。
- en: Consuming a web API
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消费网络API
- en: 'Making a request for in a web browser shows us what the structure of JSON response
    data looks like when finding synonyms for the word `love`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在网页浏览器中发出请求，显示了当我们寻找单词“爱”的同义词时JSON响应数据的结构：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A real API will return a lot more actual words than what is printed here, but
    the structure is the important thing. It represents an object, where the keys
    describe the types of word (verbs, nouns, and so on). Also, values are objects
    that contain arrays of strings keyed on `syn` or `ant` (for the synonym and antonym,
    respectively); it is the synonyms we are interested in.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的 API 将返回比这里打印的更多实际单词，但结构才是重要的。它代表一个对象，其中键描述了单词的类型（动词、名词等）。此外，值是包含以 `syn`
    或 `ant`（分别代表同义词和反义词）为键的字符串数组的对象；我们感兴趣的是同义词。
- en: 'To turn this JSON string data into something we can use in our code, we must
    decode it into structures of our own using the capabilities found in the `encoding/json`
    package. Because we''re writing something that could be useful outside the scope
    of our project, we will consume the API in a reusable package rather than directly
    in our program code. Create a new folder called `thesaurus` alongside your other
    program folders (in `$GOPATH/src`) and insert the following code into a new `bighuge.go`
    file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此 JSON 字符串数据转换为我们可以用于我们代码中的数据，我们必须使用 `encoding/json` 包中的功能将其解码到我们自己的结构中。因为我们正在编写可能在我们项目范围之外有用的东西，我们将通过可重用的包而不是直接在我们的程序代码中消耗
    API。在你的其他程序文件夹（在 `$GOPATH/src`）旁边创建一个名为 `thesaurus` 的新文件夹，并将以下代码插入一个名为 `bighuge.go`
    的新文件中：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, the `BigHuge` type we define houses the necessary API
    key and provides the `Synonyms` method that will be responsible for doing the
    work of accessing the endpoint, parsing the response, and returning the results.
    The most interesting parts of this code are the `synonyms` and `words` structures.
    They describe the JSON response format in Go terms, namely an object containing
    noun and verb objects, which in turn contain a slice of strings in a variable
    called `Syn`. The tags (strings in backticks following each field definition)
    tell the `encoding/json` package which fields to map to which variables; this
    is required since we have given them different names.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义的 `BigHuge` 类型包含必要的 API 密钥，并提供了一个 `Synonyms` 方法，该方法将负责访问端点、解析响应并返回结果。此代码中最有趣的部分是
    `synonyms` 和 `words` 结构。它们以 Go 术语描述 JSON 响应格式，即包含名词和动词对象的对象，这些对象反过来包含一个名为 `Syn`
    的字符串切片。标签（每个字段定义后面的反引号中的字符串）告诉 `encoding/json` 包将哪些字段映射到哪些变量；这是必需的，因为我们已经给了它们不同的名字。
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Typically in JSON, keys have lowercase names, but we have to use capitalized
    names in our structures so that the `encoding/json` package would also know that
    the fields exist. If we don't, the package would simply ignore the fields. However,
    the types themselves (`synonyms` and `words`) do not need to be exported.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在 JSON 中，键具有小写名称，但我们必须在我们的结构中使用大写名称，这样 `encoding/json` 包也会知道这些字段的存在。如果我们不这样做，包将简单地忽略这些字段。然而，这些类型本身（`synonyms`
    和 `words`）不需要被导出。
- en: The `Synonyms` method takes a `term` argument and uses `http.Get` to make a
    web request to the API endpoint in which the URL contains not only the API key
    value, but also the `term` value itself. If the web request fails for some reason,
    we will make a call to `log.Fatalln`, which will write the error to the standard
    error stream and exit the program with a non-zero exit code (actually an exit
    code of `1`). This indicates that an error has occurred.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Synonyms` 方法接受一个 `term` 参数，并使用 `http.Get` 向包含 API 密钥值以及 `term` 值本身的 API 端点发起网络请求。如果由于某种原因网络请求失败，我们将调用
    `log.Fatalln`，这将错误写入标准错误流，并以非零退出码（实际上是一个退出码为 `1`）退出程序。这表示发生了错误。'
- en: If the web request is successful, we pass the response body (another `io.Reader`)
    to the `json.NewDecoder` method and ask it to decode the bytes into the `data`
    variable that is of our `synonyms` type. We defer the closing of the response
    body in order to keep the memory clean before using Go's built-in `append` function
    to concatenate both `noun` and `verb` synonyms to the `syns` slice that we then
    return.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网络请求成功，我们将响应体（另一个 `io.Reader`）传递给 `json.NewDecoder` 方法，并要求它将字节解码到我们 `synonyms`
    类型的 `data` 变量中。我们延迟关闭响应体，以便在使用 Go 的内置 `append` 函数将 `noun` 和 `verb` 同义词连接到我们随后返回的
    `syns` 切片之前保持内存清洁。
- en: 'Although we have implemented the `BigHuge` thesaurus, it isn''t the only option
    out there, and we can express this by adding a `Thesaurus` interface to our package.
    In the `thesaurus` folder, create a new file called `thesaurus.go` and add the
    following interface definition to the file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经实现了`BigHuge`同义词库，但这并不是唯一的选择，我们可以在我们的包中添加一个`Thesaurus`接口来表达这一点。在`thesaurus`文件夹中，创建一个名为`thesaurus.go`的新文件，并将以下接口定义添加到该文件中：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This simple interface just describes a method that takes a `term` string and
    returns either a slice of strings containing the synonyms or an error (if something
    goes wrong). Our `BigHuge` structure already implements this interface, but now,
    other users could add interchangeable implementations for other services, such
    as [http://www.dictionary.com/](http://www.dictionary.com/) or the Merriam-Webster
    online service.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的界面仅仅描述了一个方法，该方法接受一个`term`字符串，并返回包含同义词的字符串切片或错误（如果发生错误）。我们的`BigHuge`结构已经实现了这个接口，但现在，其他用户可以为其他服务添加可互换的实现，例如[http://www.dictionary.com/](http://www.dictionary.com/)或Merriam-Webster在线服务。
- en: 'Next, we are going to use this new package in a program. Change the directory
    in the terminal back up a level to `$GOPATH/src`, create a new folder called `synonyms`,
    and insert the following code into a new `main.go` file you will place in this
    folder:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在程序中使用这个新包。在终端中，将目录向上移动一级到`$GOPATH/src`，创建一个名为`synonyms`的新文件夹，并将以下代码插入到该文件夹中一个名为`main.go`的新文件中：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now when you manage your imports again, you will have written a complete program
    that is capable of looking up synonyms of words by integrating the Big Huge Thesaurus
    API.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你再次管理你的导入时，你已经编写了一个完整的程序，该程序能够通过整合Big Huge Thesaurus API查找单词的同义词。
- en: In the preceding code, the first thing our `main` function does is that it gets
    the `BHT_APIKEY` environment variable value via the `os.Getenv` call. To protect
    your code, you might consider double-checking it to ensure the value is properly
    set; if not, report the error. For now, we will assume that everything is configured
    properly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们的`main`函数首先通过`os.Getenv`调用获取`BHT_APIKEY`环境变量的值。为了保护你的代码，你可能需要考虑再次检查它以确保值已正确设置；如果没有，报告错误。现在，我们将假设一切配置正确。
- en: Next, the preceding code starts to look a little familiar since it scans each
    line of input again from `os.Stdin` and calls the `Synonyms` method to get a list
    of the replacement words.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，前面的代码开始看起来有些熟悉，因为它再次从`os.Stdin`扫描每一行输入，并调用`Synonyms`方法来获取替换词的列表。
- en: 'Let''s build a program and see what kind of synonyms the API comes back with
    when we input the word `chat`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个程序，看看当我们输入单词`chat`时API会返回什么样的同义词：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The results you get will most likely differ from what we have listed here since
    we're hitting a live API. However, the important thing is that when we provide
    a word or term as an input to the program, it returns a list of synonyms as the
    output, one per line.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到的结果很可能与我们列出的不同，因为我们正在调用一个实时API。然而，重要的是，当我们向程序提供一个单词或术语作为输入时，它返回一个包含同义词的输出列表，每行一个。
- en: Getting domain suggestions
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取域名建议
- en: 'By composing the four programs we have built so far in this chapter, we already
    have a useful tool for suggesting domain names. All we have to do now is to run
    the programs while piping the output to the input in an appropriate way. In a
    terminal, navigate to the parent folder and run the following single line:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 通过组合本章中构建的四个程序，我们已经有了一个有用的工具来建议域名。我们现在需要做的就是以适当的方式将程序的输出管道连接到输入。在终端中，导航到父文件夹，并运行以下单行命令：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because the `synonyms` program is first in our list, it will receive the input
    from the terminal (whatever the user decides to type in). Similarly, because `domainify`
    is last in the chain, it will print its output to the terminal for the user to
    see. Along the way, the lines of words will be piped through other programs, giving
    each of them a chance to do their magic.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`synonyms`程序在我们的列表中排在第一位，它将接收来自终端的输入（无论用户决定输入什么）。同样，由于`domainify`在链中排在最后，它将把输出打印到终端供用户查看。在这个过程中，单词行将通过其他程序进行管道传输，给每个程序一个施展魔法的机会。
- en: 'Type in a few words to see some domain suggestions; for example, when you type
    `chat` and hit return, you may see the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 输入几个单词以查看一些域名建议；例如，当你输入`chat`并按回车键时，你可能看到以下内容：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The number of suggestions you get will actually depend on the number of synonyms.
    This is because it is the only program that generates more lines of output than
    what we input.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你收到的建议数量实际上将取决于同义词的数量。这是因为它是唯一一个生成的输出行数超过我们输入的程序。
- en: 'We still haven''t solved our biggest problem: the fact that we have no idea
    whether the suggested domain names are actually available or not. So we still
    have to sit and type each one of them into a website. In the next section, we
    will address this issue.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然没有解决我们最大的问题：我们根本不知道建议的域名是否真的可用。因此，我们仍然需要坐下来逐个将它们输入到网站上。在下一节中，我们将解决这个问题。
