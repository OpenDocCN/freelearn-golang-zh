<html><head></head><body>
<div class="book" title="Five simple programs">
<div class="book" title="Available"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch04lvl2sec0044" class="calibre1"/>Available</h2></div></div></div><p class="calibre10">Our final program, Available, will connect to a WHOIS server to ask for details about the domains passed to it of course, if no details are returned, we can safely assume that the domain is available for purchase. Unfortunately, the WHOIS specification (see <a class="calibre1" href="http://tools.ietf.org/html/rfc3912">http://tools.ietf.org/html/rfc3912</a>) is very small and contains no information about how a WHOIS server should reply when you ask for details about a domain. This means programmatically parsing the response becomes a messy endeavor. To address this issue for now, we will integrate with only a single WHOIS server, which we can be sure will have <code class="email">No match</code> somewhere in the response when it has no records for the domain.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note0068" class="calibre1"/>Note</h3><p class="calibre10">A more robust solution is to have a WHOIS interface with a well-defined structure for the details and perhaps an error message for cases when the domain doesn't exist with different implementations for different WHOIS servers. As you can imagine, it's quite a project; it is perfect for an open source effort.</p></div><p class="calibre10">Create a new folder called <code class="email">available</code> alongside others and add a <code class="email">main.go</code> file to it containing the following function code:</p><pre class="programlisting">func exists(domain string) (bool, error) { 
  const whoisServer string = "com.whois-servers.net" 
  conn, err := net.Dial("tcp", whoisServer+":43") 
  if err != nil { 
    return false, err 
  } 
  defer conn.Close() 
  conn.Write([]byte(domain + "rn")) 
  scanner := bufio.NewScanner(conn) 
  for scanner.Scan() { 
    if strings.Contains(strings.ToLower(scanner.Text()), "no match") { 
      return false, nil 
    } 
  } 
  return true, nil 
} 
</pre><p class="calibre10">The <code class="email">exists</code> function implements what little there is in the WHOIS specification by opening a connection to port <code class="email">43</code> on the specified <code class="email">whoisServer</code> instance with a call to <code class="email">net.Dial</code>. We then defer the closing of the connection, which means that no matter how the function exits (successful, with an error, or even a panic), <code class="email">Close()</code> will still be called on the <code class="email">conn</code> connection. Once the connection is open, we simply write the domain followed by <code class="email">rn</code> (the carriage return and linefeed characters). This is all that the specification tells us, so we are on our own from now on.</p><p class="calibre10">Essentially, we are looking for some mention of "no match" in the response, and this is how we will decide whether a domain exists or not (<code class="email">exists</code> in this case is actually just asking the WHOIS server whether it has a record for the domain we specified). We use our favorite <code class="email">bufio.Scanner</code> method to help us iterate over the lines in the response. Passing the connection to <code class="email">NewScanner</code> works because <code class="email">net.Conn</code> is actually an <code class="email">io.Reader</code> too. We use <code class="email">strings.ToLower</code> so we don't have to worry about case sensitivity and <code class="email">strings.Contains</code> to check whether any one of the lines contains the <code class="email">no match</code> text. If it does, we return <code class="email">false</code> (since the domain doesn't exist); otherwise, we return <code class="email">true</code>.</p><p class="calibre10">The <code class="email">com.whois-servers.net</code> WHOIS service supports domain names for <code class="email">.com</code> and <code class="email">.net</code>, which is why the Domainify program only adds these types of domains. If you had used a server that had WHOIS information for a wider selection of domains, you could have added support for additional TLDs.</p><p class="calibre10">Let's add a <code class="email">main</code> function that uses our <code class="email">exists</code> function to check whether the incoming domains are available or not. The check mark and cross mark symbols in the following code are optional if your terminal doesn't support them you are free to substitute them with simple <code class="email">Yes</code> and <code class="email">No</code> strings.</p><p class="calibre10">Add the following code to <code class="email">main.go</code>:</p><pre class="programlisting">var marks = map[bool]string{true: "✔", false: "✖"}
func main() {
s := bufio.NewScanner(os.Stdin)
for s.Scan() {
domain := s.Text()
fmt.Print(domain, " ")
exist, err := exists(domain)
if err != nil {
log.Fatalln(err)
}
fmt.Println(marks[!exist])
time.Sleep(1 * time.Second)
}
} 
</pre><div class="informaltable" title="Note"><h3 class="title2"><a id="note0069" class="calibre1"/>Note</h3><p class="calibre10">We can use the check and cross characters in our code happily because all Go code files are UTF-8 compliant the best way to actually get these characters is to search the Web for them and use the copy and paste option to bring them into our code. Otherwise, there are platform-dependent ways to get such special characters.</p></div><p class="calibre10">In the preceding code for the <code class="email">main</code> function, we simply iterate over each line coming in via <code class="email">os.Stdin</code>. This process helps us print out the domain with <code class="email">fmt.Print</code> (but not <code class="email">fmt.Println</code>, as we do not want the linefeed yet), call our <code class="email">exists</code> function to check whether the domain exists or not, and print out the result with <code class="email">fmt.Println</code> (because we <span class="strong"><em class="calibre11">do</em></span> want a linefeed at the end).</p><p class="calibre10">Finally, we use <code class="email">time.Sleep</code> to tell the process to do nothing for a second in order to make sure we take it easy on the WHOIS server.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip70" class="calibre1"/>Tip</h3><p class="calibre10">Most WHOIS servers will be limited in various ways in order to prevent you from taking up too much in terms of resources. So, slowing things down is a sensible way to make sure we don't make the remote servers angry.</p><p class="calibre10">Consider what this also means for unit tests. If a unit test were actually making real requests to a remote WHOIS server, every time your tests run, you will be clocking up statistics against your IP address. A much better approach would be to stub the WHOIS server to simulate responses.</p></div><p class="calibre10">The <code class="email">marks</code> map at the top is a nice way to map the <code class="email">bool</code> response from <code class="email">exists</code> to human-readable text, allowing us to just print the response in a single line using <code class="email">fmt.Println(marks[!exist])</code>. We are saying <span class="strong"><em class="calibre11">not exist</em></span> because our program is checking whether the domain is available or not (logically, the opposite of whether it exists in the WHOIS server or not).</p><p class="calibre10">After fixing the import statements for the main.go file, we can try out Available to see whether the domain names are available or not by typing the following command:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go build -o available</strong></span>
<span class="strong"><strong class="calibre2">./available</strong></span>
</pre><p class="calibre10">Once Available is running, type in some domain names and see the result appear on the next line:</p><p class="calibre10">
</p><div class="mediaobject"><img src="../images/00056.jpeg" alt="Available" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">
</p><p class="calibre10">As you can see, for domains that are not available, we get a little cross mark next to them; however, when we make up a domain name using random numbers, we see that it is indeed available.</p></div></div></body></html>