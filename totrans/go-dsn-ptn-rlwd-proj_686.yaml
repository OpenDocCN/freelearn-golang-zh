- en: One program to rule them all
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个程序统治一切
- en: Running our solution by piping programs together is an elegant form of architecture,
    but it doesn't have a very elegant interface. Specifically, whenever we want to
    run our solution, we have to type the long, messy line where each program is listed
    and separated by pipe characters. In this section, we are going to write a Go
    program that uses the `os/exec` package to run each subprogram while piping the
    output from one to the input of the next, as per our design.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将程序管道连接起来运行我们的解决方案是一种优雅的架构形式，但它没有非常优雅的界面。具体来说，每次我们想要运行我们的解决方案时，我们必须输入一个长而混乱的行，其中每个程序都列出来，并由管道字符分隔。在本节中，我们将编写一个Go程序，该程序使用`os/exec`包来运行每个子程序，并将一个程序的输出管道连接到下一个程序的输入，正如我们的设计所要求的。
- en: Create a new folder called `domainfinder` alongside the other five programs
    and create another new folder called `lib` inside this folder. The `lib` folder
    is where we will keep builds of our subprograms, but we don't want to copy and
    paste them every time we make a change. Instead, we will write a script that builds
    the subprograms and copies the binaries to the `lib` folder for us.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他五个程序旁边创建一个名为`domainfinder`的新文件夹，并在该文件夹内创建另一个名为`lib`的新文件夹。`lib`文件夹是我们将保存子程序构建的地方，但我们不想每次更改时都复制粘贴。相反，我们将编写一个脚本来构建子程序并将二进制文件复制到`lib`文件夹中。
- en: 'Create a new file called `build.sh` on Unix machines or `build.bat` for Windows
    and insert into it the following code:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix机器上创建一个名为`build.sh`的新文件或在Windows上创建一个名为`build.bat`的新文件，并将以下代码插入到其中：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding script simply builds all our subprograms (including `domainfinder`,
    which we are yet to write), telling `go build` to place them in our `lib` folder.
    Be sure to give execution rights to the new script by doing `chmod +x build.sh`
    or something similar. Run this script from a terminal and look inside the `lib`
    folder to ensure that it has indeed placed the binaries for our subprograms.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本简单地构建了我们的所有子程序（包括我们尚未编写的`domainfinder`），告诉`go build`将它们放置在我们的`lib`文件夹中。确保通过执行`chmod
    +x build.sh`或类似操作为新脚本赋予执行权限。从终端运行此脚本，并检查`lib`文件夹以确保它确实放置了我们的子程序的二进制文件。
- en: Tip
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't worry about the `no buildable Go source files` error for now; it's just
    Go telling us that the `domainfinder` program doesn't have any `.go` files to
    build.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不必担心`没有可构建的Go源文件`错误；这只是Go告诉我们`domainfinder`程序没有`.go`文件可以构建。
- en: 'Create a new file called `main.go` inside `domainfinder` and insert the following
    code into the file:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在`domainfinder`目录内创建一个名为`main.go`的新文件，并将以下代码插入到该文件中：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `os/exec` package gives us everything we need to work with to run external
    programs or commands from within Go programs. First, our `cmdChain` slice contains
    `*exec.Cmd` commands in the order in which we want to join them together.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`os/exec`包为我们提供了在Go程序中运行外部程序或命令所需的一切。首先，我们的`cmdChain`切片包含我们想要连接的`*exec.Cmd`命令的顺序。'
- en: At the top of the `main` function, we tie the `Stdin` (standard in stream) of
    the first program with the `os.Stdin` stream of this program and the `Stdout`
    (standard out stream) of the last program with the `os.Stdout` stream of this
    program. This means that, like before, we will be taking input through the standard
    input stream and writing output to the standard output stream.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数的顶部，我们将第一个程序的`Stdin`（标准输入流）与该程序的`os.Stdin`流绑定，并将最后一个程序的`Stdout`（标准输出流）与该程序的`os.Stdout`流绑定。这意味着，就像之前一样，我们将通过标准输入流获取输入并将输出写入标准输出流。
- en: Our next block of code is where we join the subprograms together by iterating
    over each item and setting its `Stdin` to the `Stdout` stream of the program before
    it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的代码块是通过迭代每个项目并将它的`Stdin`设置为之前程序的`Stdout`流来连接子程序的。
- en: 'The following table shows each program with a description of where it gets
    its input from and where its output goes:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了每个程序及其输入来源和输出去向的描述：
- en: '| **Program** | **Input (Stdin)** | **Output (Stdout)** |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| **程序** | **输入（标准输入）** | **输出（标准输出）** |'
- en: '| synonyms | The same `Stdin` as `domainfinder` | sprinkle |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| synonyms | 与`domainfinder`相同的`Stdin` | sprinkle |'
- en: '| sprinkle | synonyms | coolify |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| sprinkle | synonyms | coolify |'
- en: '| coolify | sprinkle | domainify |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| coolify | sprinkle | domainify |'
- en: '| domainify | coolify | available |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| domainify | coolify | available |'
- en: '| available | domainify | The same `Stdout` as `domainfinder` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| available | domainify | 与`domainfinder`相同的`Stdout` |'
- en: We then iterate over each command calling the `Start` method, which runs the
    program in the background (as opposed to the `Run` method, which will block our
    code until the subprogram exists which would be no good since we will have to
    run five programs at the same time). If anything goes wrong, we bail with `log.Fatalln`;
    however, if the program starts successfully, we defer a call to kill the process.
    This helps us ensure the subprograms exit when our `main` function exits, which
    will be when the `domainfinder` program ends.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历每个调用`Start`方法的命令，该方法在后台运行程序（与`Run`方法相反，它将阻塞我们的代码直到子程序结束，这会不好，因为我们必须同时运行五个程序）。如果发生任何错误，我们使用`log.Fatalln`退出；然而，如果程序成功启动，我们将推迟调用以终止进程。这有助于我们确保子程序在我们`main`函数退出时退出，这将是`domainfinder`程序结束时。
- en: Once all the programs start running, we iterate over every command again and
    wait for it to finish. This is to ensure that `domainfinder` doesn't exit early
    and kill off all the subprograms too soon.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有程序开始运行，我们再次遍历每个命令并等待其完成。这是为了确保`domainfinder`不会提前退出并过早地终止所有子程序。
- en: Run the `build.sh` or `build.bat` script again and notice that the `domainfinder`
    program has the same behavior as we have seen before, with a much more elegant
    interface.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行`build.sh`或`build.bat`脚本，注意`domainfinder`程序的行为与我们之前看到的一样，但界面更加优雅。
- en: 'The following screenshot shows the output from our programs when we type `clouds`;
    we have found quite a few available domain name options:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了当我们输入`clouds`时我们程序的输出；我们找到了相当多的可用域名选项：
- en: '![One program to rule them all](img/00059.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![一个程序统治一切](img/00059.jpeg)'
