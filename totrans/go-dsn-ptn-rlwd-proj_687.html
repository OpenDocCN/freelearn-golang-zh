<html><head></head><body><div class="book" title="Summary" id="54VHA1-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec0027" class="calibre1"/>Summary</h1></div></div></div><p class="calibre10">In this chapter, we learned how five small command-line programs can, when composed together, produce powerful results while remaining modular. We avoided tightly coupling our programs so they could still be useful in their own right. For example, we can use our Available program just to check whether the domain names we manually enter are available or not, or we can use our <code class="email">synonyms</code> program just as a command-line thesaurus.</p><p class="calibre10">We learned how standard streams could be used to build different flows of these types of programs and how the redirection of standard input and standard output lets us play around with different flows very easily.</p><p class="calibre10">We learned how simple it is in Go to consume a JSON RESTful API web service when we wanted to get the synonyms from Big Huge Thesaurus. We also consumed a non-HTTP API when we opened a connection to the WHOIS server and wrote data over raw TCP.</p><p class="calibre10">We saw how the <code class="email">math/rand</code> package can bring a little variety and unpredictability by allowing us to use pseudo random numbers and decisions in our code, which means that each time we run our program, we will get different results.</p><p class="calibre10">Finally, we built our <code class="email">domainfinder</code> super program that composes all the subprograms together, giving our solution a simple, clean, and elegant interface.</p><p class="calibre10">In the next chapter, we will take some ideas we have learned so far one step further by exploring how to connect programs using messaging queue technologies allowing them to distributed across many machines to achieve large scale.</p></div></body></html>