- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how five small command-line programs can, when composed
    together, produce powerful results while remaining modular. We avoided tightly
    coupling our programs so they could still be useful in their own right. For example,
    we can use our Available program just to check whether the domain names we manually
    enter are available or not, or we can use our `synonyms` program just as a command-line
    thesaurus.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how standard streams could be used to build different flows of these
    types of programs and how the redirection of standard input and standard output
    lets us play around with different flows very easily.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how simple it is in Go to consume a JSON RESTful API web service
    when we wanted to get the synonyms from Big Huge Thesaurus. We also consumed a
    non-HTTP API when we opened a connection to the WHOIS server and wrote data over
    raw TCP.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how the `math/rand` package can bring a little variety and unpredictability
    by allowing us to use pseudo random numbers and decisions in our code, which means
    that each time we run our program, we will get different results.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we built our `domainfinder` super program that composes all the subprograms
    together, giving our solution a simple, clean, and elegant interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take some ideas we have learned so far one step
    further by exploring how to connect programs using messaging queue technologies
    allowing them to distributed across many machines to achieve large scale.
  prefs: []
  type: TYPE_NORMAL
