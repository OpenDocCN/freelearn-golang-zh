<html><head></head><body>
<div class="book" title="Chapter&#xA0;5.&#xA0; Building Distributed Systems and Working with Flexible Data" id="55U1S1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="The system design"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec0028" class="calibre1"/>The system design</h1></div></div></div><p class="calibre10">Having a basic design sketched out is often useful, especially in distributed systems where many components will be communicating with each other in different ways. We don't want to spend too long on this stage because our design is likely to evolve as we get stuck into the details, but we will look at a high-level outline so that we can discuss the constituents and how they fit together:</p><p class="calibre10">
</p><div class="mediaobject"><img src="../images/00060.jpeg" alt="The system design" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">
</p><p class="calibre10">The preceding diagram shows the basic overview of the system we are going to build:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Twitter is the social media network we all know and love.</li><li class="listitem">Twitter's streaming API allows long-running connections where tweet data is streamed as quickly as possible.</li><li class="listitem"><code class="email">twittervotes</code> is a program we will write that pulls the relevant tweet data via the Twitter API, decides what is being voted for (rather, which options are mentioned in the tweet body), and then pushes the vote into NSQ.</li><li class="listitem">NSQ is an open source, real-time distributed messaging platform designed to operate at scale, built and maintained by Bit.ly. NSQ carries the message across its instances, making it available to anyone who has expressed an interest in the vote data.</li><li class="listitem"><code class="email">counter</code> is a program we will write that listens out for votes on the messaging queue and periodically saves the results in the MongoDB database. It receives the vote messages from NSQ and keeps an in-memory tally of the results, periodically pushing an update to persist the data.</li><li class="listitem">MongoDB is an open source document database designed to operate at scale.</li><li class="listitem"><code class="email">web</code> is a web server program that will expose the live results that we will write in the next chapter.</li></ul></div><p class="calibre10">It could be argued that a single Go program could be written that reads the tweets, counts the votes, and pushes them to a user interface, but such a solution, while being a great proof of concept, would be very limited in scale. In our design, any one of the components can be horizontally scaled as the demand for that particular capability increases. If we have relatively few polls but lots of people viewing the data, we can keep the <code class="email">twittervotes</code> and <code class="email">counter</code> instances down and add more <code class="email">web</code> and MongoDB nodes or vice versa if the situation is reversed.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note0073" class="calibre1"/>Note</h3><p class="calibre10">Another key advantage to our design is redundancy; since we can have many instances of our components working at the same time, if one of our boxes disappears (due to a system crash or a power cut, for example), the others can pick up the slack. Modern architectures often distribute such a system over the geographical expanse in order to protect from local natural disasters too. All of these options are available for use if we build our solution in this way.</p></div><p class="calibre10">We chose specific technologies in this chapter because of their links to Go (NSQ, for example, is written entirely in Go) and the availability of well-tested drivers and packages. Conceptually, however, you can drop in a variety of alternatives as you see fit.</p></div></div></body></html>