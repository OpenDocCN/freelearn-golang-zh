- en: The system design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having a basic design sketched out is often useful, especially in distributed
    systems where many components will be communicating with each other in different
    ways. We don''t want to spend too long on this stage because our design is likely
    to evolve as we get stuck into the details, but we will look at a high-level outline
    so that we can discuss the constituents and how they fit together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The system design](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram shows the basic overview of the system we are going to
    build:'
  prefs: []
  type: TYPE_NORMAL
- en: Twitter is the social media network we all know and love.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twitter's streaming API allows long-running connections where tweet data is
    streamed as quickly as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`twittervotes` is a program we will write that pulls the relevant tweet data
    via the Twitter API, decides what is being voted for (rather, which options are
    mentioned in the tweet body), and then pushes the vote into NSQ.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NSQ is an open source, real-time distributed messaging platform designed to
    operate at scale, built and maintained by Bit.ly. NSQ carries the message across
    its instances, making it available to anyone who has expressed an interest in
    the vote data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`counter` is a program we will write that listens out for votes on the messaging
    queue and periodically saves the results in the MongoDB database. It receives
    the vote messages from NSQ and keeps an in-memory tally of the results, periodically
    pushing an update to persist the data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB is an open source document database designed to operate at scale.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web` is a web server program that will expose the live results that we will
    write in the next chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It could be argued that a single Go program could be written that reads the
    tweets, counts the votes, and pushes them to a user interface, but such a solution,
    while being a great proof of concept, would be very limited in scale. In our design,
    any one of the components can be horizontally scaled as the demand for that particular
    capability increases. If we have relatively few polls but lots of people viewing
    the data, we can keep the `twittervotes` and `counter` instances down and add
    more `web` and MongoDB nodes or vice versa if the situation is reversed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another key advantage to our design is redundancy; since we can have many instances
    of our components working at the same time, if one of our boxes disappears (due
    to a system crash or a power cut, for example), the others can pick up the slack.
    Modern architectures often distribute such a system over the geographical expanse
    in order to protect from local natural disasters too. All of these options are
    available for use if we build our solution in this way.
  prefs: []
  type: TYPE_NORMAL
- en: We chose specific technologies in this chapter because of their links to Go
    (NSQ, for example, is written entirely in Go) and the availability of well-tested
    drivers and packages. Conceptually, however, you can drop in a variety of alternatives
    as you see fit.
  prefs: []
  type: TYPE_NORMAL
