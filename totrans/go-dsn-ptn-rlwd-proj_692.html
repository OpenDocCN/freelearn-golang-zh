<html><head></head><body>
<div class="book" title="Installing the environment">
<div class="book" title="Introducing NSQ"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec0047" class="calibre1"/>Introducing NSQ</h2></div></div></div><p class="calibre10">NSQ is a messaging queue that allows one program to send messages or events to another or to many other programs running either locally on the same machine or on different nodes connected by a network. NSQ guarantees the delivery of each message at least once, which means that it keeps undelivered messages cached until all interested parties have received them. This means that even if we stop our <code class="email">counter</code> program, we won't miss any votes. You can contrast this capability with fire-and-forget message queues, where information is deemed out of date, and is, therefore, forgotten if it isn't delivered in time and when the sender of the messages doesn't care whether the consumer received them or not.</p><p class="calibre10">A message queue abstraction allows you to have different components of a system running in different places, provided that they have network connectivity to the queue. Your programs are decoupled from others; instead, your designs start to care about the ins and outs of specialized micro services rather than flow of data through a monolithic program.</p><p class="calibre10">NSQ transfers raw bytes, which means that it is up to us how we encode data into these bytes. For example, we could encode the data as JSON or in a binary format depending on our needs. In our case, we are going to send the vote option as a string without any additional encoding, since we are only sharing a single data field.</p><p class="calibre10">We first need to get NSQ installed and running:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open <a class="calibre1" href="http://nsq.io/deployment/installing.html">http://nsq.io/deployment/installing.html</a> in a browser (or search <code class="email">install nsq</code>) and follow the instructions for your environment. You can either download precompiled binaries or build your own from the source. If you have homebrew installed, installing NSQ is as simple as typing the following:<pre class="programlisting">
<span class="strong"><strong class="calibre2">brew install nsq</strong></span>
</pre></li><li class="listitem" value="2">Once you have installed NSQ, you will need to add the <code class="email">bin</code> folder to your <code class="email">PATH</code> environment variable so that the tools are available in a terminal.</li><li class="listitem" value="3">To validate that NSQ is properly installed, open a terminal and run <code class="email">nsqlookupd</code>; if the program successfully starts, you should see output similar to the following:<pre class="programlisting">
<span class="strong"><strong class="calibre2">nsqlookupd v0.2.27 (built w/go1.3)</strong></span>
<span class="strong"><strong class="calibre2">TCP: listening on [::]:4160</strong></span>
<span class="strong"><strong class="calibre2">HTTP: listening on [::]:4161</strong></span>
</pre><p class="calibre29">We are going to use the default ports to interact with NSQ, so take note of the TCP and HTTP ports listed in the output, as we will be referring to them in our code.</p></li><li class="listitem" value="4">Press <span class="strong"><em class="calibre11">Ctrl + C</em></span> to stop the process for now; we'll start them properly later.</li></ol><div class="calibre12"/></div><p class="calibre10">The key tools from the NSQ installation that we are going to use are <code class="email">nsqlookupd</code> and <code class="email">nsqd</code>. The <code class="email">nsqlookupd</code> program is a daemon that manages topology information about the distributed NSQ environment; it keeps track of all the <code class="email">nsqd</code> producers for specific topics and provides interfaces for clients to query such information. The <code class="email">nsqd</code> program is a daemon that does the heavy lifting for NSQ, such as receiving, queuing, and delivering messages from and to interested parties.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note0075" class="calibre1"/>Note</h3><p class="calibre10">For more information and background on NSQ, visit <a class="calibre1" href="http://nsq.io/">http://nsq.io/</a>.</p></div><div class="book" title="NSQ driver for Go"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch05lvl3sec0017" class="calibre1"/>NSQ driver for Go</h3></div></div></div><p class="calibre10">The NSQ tools themselves are written in Go, so it is logical that the Bit.ly team already has a Go package that makes interacting with NSQ very easy. We will need to use it, so in a terminal, you can get it using <code class="email">go get</code>:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go get github.com/bitly/go-nsq</strong></span>
</pre></div></div></div></body></html>