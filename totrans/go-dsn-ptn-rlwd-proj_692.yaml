- en: Introducing NSQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NSQ is a messaging queue that allows one program to send messages or events
    to another or to many other programs running either locally on the same machine
    or on different nodes connected by a network. NSQ guarantees the delivery of each
    message at least once, which means that it keeps undelivered messages cached until
    all interested parties have received them. This means that even if we stop our
    `counter` program, we won't miss any votes. You can contrast this capability with
    fire-and-forget message queues, where information is deemed out of date, and is,
    therefore, forgotten if it isn't delivered in time and when the sender of the
    messages doesn't care whether the consumer received them or not.
  prefs: []
  type: TYPE_NORMAL
- en: A message queue abstraction allows you to have different components of a system
    running in different places, provided that they have network connectivity to the
    queue. Your programs are decoupled from others; instead, your designs start to
    care about the ins and outs of specialized micro services rather than flow of
    data through a monolithic program.
  prefs: []
  type: TYPE_NORMAL
- en: NSQ transfers raw bytes, which means that it is up to us how we encode data
    into these bytes. For example, we could encode the data as JSON or in a binary
    format depending on our needs. In our case, we are going to send the vote option
    as a string without any additional encoding, since we are only sharing a single
    data field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to get NSQ installed and running:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open [http://nsq.io/deployment/installing.html](http://nsq.io/deployment/installing.html)
    in a browser (or search `install nsq`) and follow the instructions for your environment.
    You can either download precompiled binaries or build your own from the source.
    If you have homebrew installed, installing NSQ is as simple as typing the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once you have installed NSQ, you will need to add the `bin` folder to your `PATH`
    environment variable so that the tools are available in a terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To validate that NSQ is properly installed, open a terminal and run `nsqlookupd`;
    if the program successfully starts, you should see output similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are going to use the default ports to interact with NSQ, so take note of
    the TCP and HTTP ports listed in the output, as we will be referring to them in
    our code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press *Ctrl + C* to stop the process for now; we'll start them properly later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The key tools from the NSQ installation that we are going to use are `nsqlookupd`
    and `nsqd`. The `nsqlookupd` program is a daemon that manages topology information
    about the distributed NSQ environment; it keeps track of all the `nsqd` producers
    for specific topics and provides interfaces for clients to query such information.
    The `nsqd` program is a daemon that does the heavy lifting for NSQ, such as receiving,
    queuing, and delivering messages from and to interested parties.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information and background on NSQ, visit [http://nsq.io/](http://nsq.io/).
  prefs: []
  type: TYPE_NORMAL
- en: NSQ driver for Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The NSQ tools themselves are written in Go, so it is logical that the Bit.ly
    team already has a Go package that makes interacting with NSQ very easy. We will
    need to use it, so in a terminal, you can get it using `go get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
