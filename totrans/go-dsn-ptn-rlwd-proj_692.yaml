- en: Introducing NSQ
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍NSQ
- en: NSQ is a messaging queue that allows one program to send messages or events
    to another or to many other programs running either locally on the same machine
    or on different nodes connected by a network. NSQ guarantees the delivery of each
    message at least once, which means that it keeps undelivered messages cached until
    all interested parties have received them. This means that even if we stop our
    `counter` program, we won't miss any votes. You can contrast this capability with
    fire-and-forget message queues, where information is deemed out of date, and is,
    therefore, forgotten if it isn't delivered in time and when the sender of the
    messages doesn't care whether the consumer received them or not.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: NSQ是一个消息队列，允许一个程序向另一个或多个程序发送消息或事件，这些程序可以运行在同一台机器上的本地，也可以运行在通过网络连接的不同节点上。NSQ保证至少发送每条消息一次，这意味着它将未发送的消息缓存起来，直到所有感兴趣方都收到它们。这意味着即使我们停止我们的`counter`程序，我们也不会错过任何投票。您可以与此类fire-and-forget消息队列的能力进行对比，其中信息被视为过时，因此如果信息没有及时送达，发送者不关心接收者是否收到信息，那么信息就会被遗忘。
- en: A message queue abstraction allows you to have different components of a system
    running in different places, provided that they have network connectivity to the
    queue. Your programs are decoupled from others; instead, your designs start to
    care about the ins and outs of specialized micro services rather than flow of
    data through a monolithic program.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 消息队列抽象允许系统中的不同组件在不同的地方运行，前提是它们与队列有网络连接。您的程序与其他程序解耦；相反，您的设计开始关注专用微服务的输入输出，而不是通过单体程序的数据流。
- en: NSQ transfers raw bytes, which means that it is up to us how we encode data
    into these bytes. For example, we could encode the data as JSON or in a binary
    format depending on our needs. In our case, we are going to send the vote option
    as a string without any additional encoding, since we are only sharing a single
    data field.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: NSQ传输原始字节，这意味着如何将这些字节编码成数据取决于我们。例如，根据我们的需求，可以将数据编码为JSON或二进制格式。在我们的例子中，我们将以字符串形式发送投票选项，而不进行任何额外的编码，因为我们只共享一个数据字段。
- en: 'We first need to get NSQ installed and running:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要安装并运行NSQ：
- en: 'Open [http://nsq.io/deployment/installing.html](http://nsq.io/deployment/installing.html)
    in a browser (or search `install nsq`) and follow the instructions for your environment.
    You can either download precompiled binaries or build your own from the source.
    If you have homebrew installed, installing NSQ is as simple as typing the following:'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开[http://nsq.io/deployment/installing.html](http://nsq.io/deployment/installing.html)（或搜索`install
    nsq`）并遵循适合您环境的说明。您可以选择下载预编译的二进制文件或从源代码构建。如果您已安装homebrew，安装NSQ就像输入以下内容一样简单：
- en: '[PRE0]'
  id: totrans-6
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once you have installed NSQ, you will need to add the `bin` folder to your `PATH`
    environment variable so that the tools are available in a terminal.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装NSQ后，您需要将`bin`文件夹添加到您的`PATH`环境变量中，以便在终端中可用这些工具。
- en: 'To validate that NSQ is properly installed, open a terminal and run `nsqlookupd`;
    if the program successfully starts, you should see output similar to the following:'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证NSQ是否正确安装，请打开终端并运行`nsqlookupd`；如果程序成功启动，您应该看到类似以下输出的内容：
- en: '[PRE1]'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are going to use the default ports to interact with NSQ, so take note of
    the TCP and HTTP ports listed in the output, as we will be referring to them in
    our code.
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用默认端口与NSQ进行交互，因此请注意输出中列出的TCP和HTTP端口，因为我们在代码中会引用它们。
- en: Press *Ctrl + C* to stop the process for now; we'll start them properly later.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl + C*停止当前进程；我们稍后会正确启动它们。
- en: The key tools from the NSQ installation that we are going to use are `nsqlookupd`
    and `nsqd`. The `nsqlookupd` program is a daemon that manages topology information
    about the distributed NSQ environment; it keeps track of all the `nsqd` producers
    for specific topics and provides interfaces for clients to query such information.
    The `nsqd` program is a daemon that does the heavy lifting for NSQ, such as receiving,
    queuing, and delivering messages from and to interested parties.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从NSQ安装中使用的关键工具是`nsqlookupd`和`nsqd`。`nsqlookupd`程序是一个管理分布式NSQ环境拓扑信息的守护进程；它跟踪特定主题的所有`nsqd`生产者，并为客户端提供查询此类信息的接口。`nsqd`程序是一个守护进程，负责NSQ的重负载工作，例如接收、排队和向感兴趣方发送消息。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information and background on NSQ, visit [http://nsq.io/](http://nsq.io/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于NSQ的信息和背景，请访问[http://nsq.io/](http://nsq.io/)。
- en: NSQ driver for Go
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Go语言的NSQ驱动程序
- en: 'The NSQ tools themselves are written in Go, so it is logical that the Bit.ly
    team already has a Go package that makes interacting with NSQ very easy. We will
    need to use it, so in a terminal, you can get it using `go get`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: NSQ 工具本身是用 Go 语言编写的，因此 Bit.ly 团队已经有一个 Go 包，使得与 NSQ 交互变得非常简单。我们需要使用它，所以在一个终端中，你可以使用
    `go get` 命令来获取它：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
