- en: Authorization with Twitter
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Twitter进行授权
- en: 'In order to use the streaming API, we will need authentication credentials
    from Twitter''s Application Management console, much in the same way we did for
    our Gomniauth service providers in Chapter 3, *Three Ways to Implement Profile
    Pictures*. Head over to [https://apps.twitter.com](https://apps.twitter.com) and
    create a new app called something like `SocialPoll` (the names have to be unique,
    so you can have some fun here; the choice of name doesn''t affect the code either
    way). When your app has been created, visit the **API Keys** tab and locate the
    **Your access token** section, where you need to create a new access token. After
    a short delay, refresh the page and note that you, in fact, have two sets of keys
    and secrets: an API key and a secret and an access token and the corresponding
    secret. Following good coding practices, we are going to set these values as environment
    variables so that our program can have access to them without us having to hardcode
    them in our source files. The keys we will use in this chapter are as follows:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用流式API，我们需要从Twitter的应用管理控制台获取认证凭据，这与我们在第三章“三种实现头像的方法”中为Gomniauth服务提供商所做的方式非常相似。请访问[https://apps.twitter.com](https://apps.twitter.com)并创建一个名为“SocialPoll”之类的应用（名称必须是唯一的，所以你可以在这里玩点花样；名称的选择也不会影响代码）。当你的应用创建完成后，访问**API密钥**标签页并找到**你的访问令牌**部分，在那里你需要创建一个新的访问令牌。稍作等待后刷新页面，你会注意到你实际上有两套密钥和密钥：一个API密钥和一个密钥以及一个访问令牌和相应的密钥。遵循良好的编码实践，我们将把这些值设置为环境变量，这样我们的程序就可以访问它们，而无需在我们源文件中硬编码它们。我们将在本章中使用以下密钥：
- en: '`SP_TWITTER_KEY`'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SP_TWITTER_KEY`'
- en: '`SP_TWITTER_SECRET`'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SP_TWITTER_SECRET`'
- en: '`SP_TWITTER_ACCESSTOKEN`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SP_TWITTER_ACCESSTOKEN`'
- en: '`SP_TWITTER_ACCESSSECRET`'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SP_TWITTER_ACCESSSECRET`'
- en: 'You may set the environment variables however you like, but since the app relies
    on them in order to work, creating a new file called `setup.sh` (for bash shells)
    or `setup.bat` (on Windows) is a good idea since you can check such files into
    your source code repository. Insert the following code in `setup.sh` by copying
    the appropriate values from the Twitter app page:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随意设置环境变量，但由于应用依赖于它们才能工作，创建一个名为`setup.sh`（用于bash shell）或`setup.bat`（在Windows上）的新文件是个好主意，因为你可以将这些文件存入源代码仓库。在`setup.sh`中插入以下代码，通过从Twitter应用页面复制适当的值：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On Windows, the code will look something like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，代码看起来可能如下所示：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Run the file with the source or call commands to have the values set appropriately,
    or add them to your `.bashrc` or `C:\cmdauto.cmd` files to save you from running
    them every time you open a new terminal window.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用源代码运行该文件或调用命令以适当地设置值，或者将它们添加到`.bashrc`或`C:\cmdauto.cmd`文件中，这样你就不必每次打开新的终端窗口时都运行它们。
- en: If you're not sure how to do this, just search for `Setting environment variables
    on Linux` or something similar, and the Internet will help you.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定如何操作，只需搜索“在Linux上设置环境变量”或类似的内容，互联网会提供帮助。
- en: Extracting the connection
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取连接
- en: The Twitter streaming API supports HTTP connections that stay open for a long
    time, and given the design of our solution, we are going to need to access the
    `net.Conn` object in order to close it from outside of the goroutine in which
    requests occur. We can achieve this by providing our own `dial` method to an `http.Transport`
    object that we will create.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Twitter流式API支持长时间保持打开的HTTP连接，鉴于我们的解决方案设计，我们需要访问`net.Conn`对象以便从发生请求的goroutine外部关闭它。我们可以通过为我们将创建的`http.Transport`对象提供一个自定义的`dial`方法来实现这一点。
- en: 'Create a new file called `twitter.go` inside `twittervotes` (which is where
    all things Twitter-related will live), and insert the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在`twittervotes`（所有与Twitter相关的内容都将存储在这里）内部创建一个名为`twitter.go`的新文件，并插入以下代码：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our bespoke `dial` function first ensures that `conn` is closed and then opens
    a new connection, keeping the `conn` variable updated with the current connection.
    If a connection dies (Twitter's API will do this from time to time) or is closed
    by us, we can redial without worrying about zombie connections.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定制的`dial`函数首先确保`conn`被关闭，然后打开一个新的连接，同时保持`conn`变量更新为当前连接。如果连接死亡（Twitter的API会不时这样做）或被我们关闭，我们可以重新拨号而不用担心僵尸连接。
- en: 'We will periodically close the connection ourselves and initiate a new one
    because we want to reload the options from the database at regular intervals.
    To do this, we need a function that closes the connection and also closes `io.ReadCloser`,
    which we will use to read the body of the responses. Add the following code to
    `twitter.go`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定期自己关闭连接并启动一个新的连接，因为我们想定期从数据库中重新加载选项。为此，我们需要一个函数来关闭连接并关闭`io.ReadCloser`，我们将使用它来读取响应体。将以下代码添加到`twitter.go`中：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we can call `closeConn` at any time in order to break the ongoing connection
    with Twitter and tidy things up. In most cases, our code will load the options
    from the database again and open a new connection right away, but if we're shutting
    the program down (in response to a *Ctrl + C* hit), then we can call `closeConn`
    just before we exit.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在任何时候调用`closeConn`来断开与Twitter的持续连接并整理事物。在大多数情况下，我们的代码将再次从数据库中加载选项并立即打开一个新的连接，但如果我们正在关闭程序（响应于*Ctrl
    + C*的按键），那么我们可以在退出之前调用`closeConn`。
- en: Reading environment variables
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取环境变量
- en: 'Next, we are going to write a function that will read the environment variables
    and set up the `OAuth` objects we''ll need in order to authenticate the requests.
    Add the following code to the `twitter.go` file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个函数来读取环境变量并设置我们需要的`OAuth`对象，以便对请求进行身份验证。将以下代码添加到`twitter.go`文件中：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we define a `struct` type to store the environment variables that we need
    to authenticate with Twitter. Since we don't need to use the type elsewhere, we
    define it inline and create a variable called `ts` of this anonymous type (that's
    why we have the somewhat unusual `var ts struct...` code). We then use Joe Shaw's
    `envdecode` package to pull in these environment variables for us. You will need
    to run `go get github.com/joeshaw/envdecode` and also import the `log` package.
    Our program will try to load appropriate values for all the fields marked `required`
    and return an error if it fails to do so, which reminds people that the program
    won't work without Twitter credentials.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义一个`struct`类型来存储我们需要用于Twitter身份验证的环境变量。由于我们不需要在其他地方使用该类型，我们将其定义在内联，并创建一个名为`ts`的匿名类型变量（这就是为什么我们有`var
    ts struct...`代码的某些不寻常之处）。然后，我们使用Joe Shaw的`envdecode`包来为我们提取这些环境变量。您需要运行`go get
    github.com/joeshaw/envdecode`并导入`log`包。我们的程序将尝试加载所有标记为`required`的字段的适当值，如果失败则返回错误，这提醒人们程序没有Twitter凭证将无法工作。
- en: The strings inside the back ticks alongside each field in `struct` are called
    tags and are available through a reflection interface, which is how `envdecode`
    knows which variables to look for. We added the `required` argument to this package,
    which indicates that it is an error for any of the environment variables to be
    missing (or empty).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在`struct`中每个字段旁边的反引号内的字符串被称为标签，并且可以通过反射接口访问，这就是`envdecode`知道要查找哪些变量的方式。我们向这个包中添加了`required`参数，这表示如果任何环境变量缺失（或为空）都是错误。
- en: Once we have the keys, we use them to create `oauth.Credentials` and an `oauth.Client`
    object from Gary Burd's `go-oauth` package, which will allow us to authorize requests
    with Twitter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了密钥，我们就使用它们从Gary Burd的`go-oauth`包中创建`oauth.Credentials`和`oauth.Client`对象，这将允许我们使用Twitter授权请求。
- en: 'Now that we have the ability to control the underlying connection and authorize
    requests, we are ready to write the code that will actually build the authorized
    request and return the response. In `twitter.go`, add the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了控制底层连接和授权请求的能力，我们准备编写实际构建授权请求并返回响应的代码。在`twitter.go`中添加以下代码：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We use `sync.Once` to ensure our initialization code gets run only once despite
    the number of times we call `makeRequest`. After calling the `setupTwitterAuth`
    method, we create a new `http.Client` function using an `http.Transport` function
    that uses our custom `dial` method. We then set the appropriate headers required
    for authorization with Twitter by encoding the specified `params` object that
    will contain the options we are querying for.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`sync.Once`来确保初始化代码只运行一次，尽管我们多次调用`makeRequest`。在调用`setupTwitterAuth`方法之后，我们使用一个`http.Transport`函数创建一个新的`http.Client`函数，该函数使用我们自定义的`dial`方法。然后，我们通过编码包含我们查询选项的指定`params`对象，设置与Twitter进行授权所需的适当头信息。
