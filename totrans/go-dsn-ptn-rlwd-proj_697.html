<html><head></head><body>
<div class="book" title="Reading votes from Twitter">
<div class="book" title="Reading from MongoDB"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec0051" class="calibre1"/>Reading from MongoDB</h2></div></div></div><p class="calibre10">In order to load the polls, and therefore the options to search Twitter for, we need to connect to and query MongoDB. In <code class="email">main.go</code>, add the two functions <code class="email">dialdb</code> and <code class="email">closedb</code>:</p><pre class="programlisting">var db *mgo.Session 
func dialdb() error { 
  var err error 
  log.Println("dialing mongodb: localhost") 
  db, err = mgo.Dial("localhost") 
  return err 
} 
func closedb() { 
  db.Close() 
  log.Println("closed database connection") 
} 
</pre><p class="calibre10">These two functions will connect to and disconnect from the locally running MongoDB instance using the <code class="email">mgo</code> package and store <code class="email">mgo.Session</code> (the database connection object) in a global variable called <code class="email">db</code>.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip78" class="calibre1"/>Tip</h3><p class="calibre10">As an additional assignment, see whether you can find an elegant way to make the location of the MongoDB instance configurable so that you don't need to run it locally.</p></div><p class="calibre10">Assuming MongoDB is running and our code is able to connect, we need to load the poll objects and extract all the options from the documents, which we will then use to search Twitter. Add the following <code class="email">loadOptions</code> function to <code class="email">main.go</code>:</p><pre class="programlisting">type poll struct { 
  Options []string 
} 
func loadOptions() ([]string, error) { 
  var options []string 
  iter := db.DB("ballots").C("polls").Find(nil).Iter() 
  var p poll 
  for iter.Next(&amp;p) { 
    options = append(options, p.Options...) 
  } 
  iter.Close() 
  return options, iter.Err() 
} 
</pre><p class="calibre10">Our poll document contains more than just <code class="email">Options</code>, but our program doesn't care about anything else, so there's no need for us to bloat our <code class="email">poll</code> struct. We use the <code class="email">db</code> variable to access the <code class="email">polls</code> collection from the <code class="email">ballots</code> database and call the <code class="email">mgo</code> package's fluent <code class="email">Find</code> method, passing <code class="email">nil</code> (meaning no filtering).</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note0079" class="calibre1"/>Note</h3><p class="calibre10">A fluent interface (first coined by Eric Evans and Martin Fowler) refers to an API design that aims to make the code more readable by allowing you to chain method calls together. This is achieved by each method returning the context object itself so that another method can be called directly afterwards. For example, <code class="email">mgo</code> allows you to write queries such as this:
<code class="email">query := col.Find(q).Sort("field").Limit(10).Skip(10)</code>
</p></div><p class="calibre10">We then get an iterator by calling the <code class="email">Iter</code> method, which allows us to access each poll one by one. This is a very memory-efficient way of reading the poll data because it only ever uses a single <code class="email">poll</code> object. If we were to use the <code class="email">All</code> method instead, the amount of memory we'd use would depend on the number of polls we had in our database, which could be out of our control.</p><p class="calibre10">When we have a poll, we use the <code class="email">append</code> method to build up the <code class="email">options</code> slice. Of course, with millions of polls in the database, this slice too would grow large and unwieldy. For that kind of scale, we would probably run multiple <code class="email">twittervotes</code> programs, each dedicated to a portion of the poll data. A simple way to do this would be to break polls into groups based on the letters the titles begin with, such as group A-N and O-Z. A somewhat more sophisticated approach would be to add a field to the <code class="email">poll</code> document, grouping it up in a more controlled manner, perhaps based on the stats for the other groups so that we are able to balance the load across many <code class="email">twittervotes</code> instances.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip80" class="calibre1"/>Tip</h3><p class="calibre10">The <code class="email">append</code> built-in function is actually a <code class="email">variadic</code> function, which means you can pass multiple elements for it to append. If you have a slice of the correct type, you can add <code class="email">...</code> to the end, which simulates the passing of each item of the slice as a different argument.</p></div><p class="calibre10">Finally, we close the iterator and clean up any used memory before returning the options and any errors that occurred while iterating (by calling the <code class="email">Err</code> method in the <code class="email">mgo.Iter</code> object).</p></div></div></body></html>