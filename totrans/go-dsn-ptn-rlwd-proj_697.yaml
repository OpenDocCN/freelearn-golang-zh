- en: Reading from MongoDB
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 MongoDB 读取
- en: 'In order to load the polls, and therefore the options to search Twitter for,
    we need to connect to and query MongoDB. In `main.go`, add the two functions `dialdb`
    and `closedb`:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载投票，以及因此搜索推特所需的选项，我们需要连接到并查询 MongoDB。在 `main.go` 中添加两个函数 `dialdb` 和 `closedb`：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These two functions will connect to and disconnect from the locally running
    MongoDB instance using the `mgo` package and store `mgo.Session` (the database
    connection object) in a global variable called `db`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数将使用 `mgo` 包连接到并断开与本地运行的 MongoDB 实例的连接，并将 `mgo.Session`（数据库连接对象）存储在名为 `db`
    的全局变量中。
- en: Tip
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As an additional assignment, see whether you can find an elegant way to make
    the location of the MongoDB instance configurable so that you don't need to run
    it locally.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为附加任务，看看你是否能找到一个优雅的方法来使 MongoDB 实例的位置可配置，这样你就不需要本地运行它。
- en: 'Assuming MongoDB is running and our code is able to connect, we need to load
    the poll objects and extract all the options from the documents, which we will
    then use to search Twitter. Add the following `loadOptions` function to `main.go`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 MongoDB 正在运行并且我们的代码能够连接，我们需要加载投票对象并从文档中提取所有选项，然后我们将使用这些选项来搜索推特。将以下 `loadOptions`
    函数添加到 `main.go` 中：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our poll document contains more than just `Options`, but our program doesn't
    care about anything else, so there's no need for us to bloat our `poll` struct.
    We use the `db` variable to access the `polls` collection from the `ballots` database
    and call the `mgo` package's fluent `Find` method, passing `nil` (meaning no filtering).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的投票文档包含的不仅仅是 `选项`，但我们的程序对其他任何内容都不关心，因此我们不需要膨胀我们的 `poll` 结构体。我们使用 `db` 变量从
    `ballots` 数据库访问 `polls` 集合，并调用 `mgo` 包的流畅 `Find` 方法，传递 `nil`（表示没有过滤）。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A fluent interface (first coined by Eric Evans and Martin Fowler) refers to
    an API design that aims to make the code more readable by allowing you to chain
    method calls together. This is achieved by each method returning the context object
    itself so that another method can be called directly afterwards. For example,
    `mgo` allows you to write queries such as this: `query := col.Find(q).Sort("field").Limit(10).Skip(10)`'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 流畅式接口（最初由 Eric Evans 和 Martin Fowler 提出）是指一种旨在通过允许你链式调用方法来使代码更易读的 API 设计。这是通过每个方法返回上下文对象本身来实现的，以便可以直接调用另一个方法。例如，`mgo`
    允许你编写如下查询：`query := col.Find(q).Sort("field").Limit(10).Skip(10)`
- en: We then get an iterator by calling the `Iter` method, which allows us to access
    each poll one by one. This is a very memory-efficient way of reading the poll
    data because it only ever uses a single `poll` object. If we were to use the `All`
    method instead, the amount of memory we'd use would depend on the number of polls
    we had in our database, which could be out of our control.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用 `Iter` 方法来获取一个迭代器，这允许我们逐个访问每个投票。这是一种非常节省内存的读取投票数据的方式，因为它只使用单个 `poll`
    对象。如果我们使用 `All` 方法，我们将使用的内存量将取决于我们数据库中的投票数量，这可能超出了我们的控制范围。
- en: When we have a poll, we use the `append` method to build up the `options` slice.
    Of course, with millions of polls in the database, this slice too would grow large
    and unwieldy. For that kind of scale, we would probably run multiple `twittervotes`
    programs, each dedicated to a portion of the poll data. A simple way to do this
    would be to break polls into groups based on the letters the titles begin with,
    such as group A-N and O-Z. A somewhat more sophisticated approach would be to
    add a field to the `poll` document, grouping it up in a more controlled manner,
    perhaps based on the stats for the other groups so that we are able to balance
    the load across many `twittervotes` instances.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个投票时，我们使用 `append` 方法来构建 `options` 切片。当然，随着数据库中数百万个投票的增长，这个切片也会变得很大且难以管理。对于这种规模，我们可能会运行多个
    `twittervotes` 程序，每个程序都专门处理投票数据的一部分。一种简单的方法是将投票根据标题开头的字母分组，例如 A-N 组和 O-Z 组。一种稍微复杂的方法是在
    `poll` 文档中添加一个字段，以更受控的方式对其进行分组，可能基于其他组的统计数据，这样我们就能在许多 `twittervotes` 实例之间平衡负载。
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `append` built-in function is actually a `variadic` function, which means
    you can pass multiple elements for it to append. If you have a slice of the correct
    type, you can add `...` to the end, which simulates the passing of each item of
    the slice as a different argument.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`append` 内置函数实际上是一个 `可变参数` 函数，这意味着你可以传递多个元素给它来追加。如果你有一个正确类型的切片，你可以在末尾添加 `...`，这模拟了将切片的每个项目作为不同的参数传递。'
- en: Finally, we close the iterator and clean up any used memory before returning
    the options and any errors that occurred while iterating (by calling the `Err`
    method in the `mgo.Iter` object).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在返回选项以及迭代过程中发生的任何错误（通过在`mgo.Iter`对象中调用`Err`方法）之前关闭迭代器并清理任何已使用的内存。
