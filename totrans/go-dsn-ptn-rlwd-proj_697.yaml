- en: Reading from MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to load the polls, and therefore the options to search Twitter for,
    we need to connect to and query MongoDB. In `main.go`, add the two functions `dialdb`
    and `closedb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These two functions will connect to and disconnect from the locally running
    MongoDB instance using the `mgo` package and store `mgo.Session` (the database
    connection object) in a global variable called `db`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an additional assignment, see whether you can find an elegant way to make
    the location of the MongoDB instance configurable so that you don't need to run
    it locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming MongoDB is running and our code is able to connect, we need to load
    the poll objects and extract all the options from the documents, which we will
    then use to search Twitter. Add the following `loadOptions` function to `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Our poll document contains more than just `Options`, but our program doesn't
    care about anything else, so there's no need for us to bloat our `poll` struct.
    We use the `db` variable to access the `polls` collection from the `ballots` database
    and call the `mgo` package's fluent `Find` method, passing `nil` (meaning no filtering).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A fluent interface (first coined by Eric Evans and Martin Fowler) refers to
    an API design that aims to make the code more readable by allowing you to chain
    method calls together. This is achieved by each method returning the context object
    itself so that another method can be called directly afterwards. For example,
    `mgo` allows you to write queries such as this: `query := col.Find(q).Sort("field").Limit(10).Skip(10)`'
  prefs: []
  type: TYPE_NORMAL
- en: We then get an iterator by calling the `Iter` method, which allows us to access
    each poll one by one. This is a very memory-efficient way of reading the poll
    data because it only ever uses a single `poll` object. If we were to use the `All`
    method instead, the amount of memory we'd use would depend on the number of polls
    we had in our database, which could be out of our control.
  prefs: []
  type: TYPE_NORMAL
- en: When we have a poll, we use the `append` method to build up the `options` slice.
    Of course, with millions of polls in the database, this slice too would grow large
    and unwieldy. For that kind of scale, we would probably run multiple `twittervotes`
    programs, each dedicated to a portion of the poll data. A simple way to do this
    would be to break polls into groups based on the letters the titles begin with,
    such as group A-N and O-Z. A somewhat more sophisticated approach would be to
    add a field to the `poll` document, grouping it up in a more controlled manner,
    perhaps based on the stats for the other groups so that we are able to balance
    the load across many `twittervotes` instances.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `append` built-in function is actually a `variadic` function, which means
    you can pass multiple elements for it to append. If you have a slice of the correct
    type, you can add `...` to the end, which simulates the passing of each item of
    the slice as a different argument.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we close the iterator and clean up any used memory before returning
    the options and any errors that occurred while iterating (by calling the `Err`
    method in the `mgo.Iter` object).
  prefs: []
  type: TYPE_NORMAL
