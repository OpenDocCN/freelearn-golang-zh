["```go\ntype tweet struct { \n  Text string \n} \n\n```", "```go\nfunc readFromTwitter(votes chan<- string) { \n  options, err := loadOptions() \n  if err != nil { \n    log.Println(\"failed to load options:\", err) \n    return \n  } \n  u, err := url.Parse(\"https://stream.twitter.com/1.1/statuses\n  /filter.json\") \n  if err != nil { \n    log.Println(\"creating filter request failed:\", err) \n    return \n  } \n  query := make(url.Values) \n  query.Set(\"track\", strings.Join(options, \",\")) \n  req, err := http.NewRequest(\"POST\",u.String(),strings.NewReader\n  (query.Encode())) \n  if err != nil { \n    log.Println(\"creating filter request failed:\", err) \n    return \n  } \n  resp, err := makeRequest(req, query) \n  if err != nil { \n    log.Println(\"making request failed:\", err) \n    return \n  } \n  reader := resp.Body \n  decoder := json.NewDecoder(reader) \n  for { \n    var t tweet \n    if err := decoder.Decode(&t); err != nil { \n      break \n    } \n    for _, option := range options { \n      if strings.Contains( \n        strings.ToLower(t.Text), \n        strings.ToLower(option), \n      ) { \n        log.Println(\"vote:\", option) \n        votes <- option \n      } \n    } \n  } \n} \n\n```", "```go\n `fmt.Println(reflect.TypeOf(true).Size()) = 1` \n\n```", "```go\nfmt.Println(reflect.TypeOf(struct{}{}).Size()) = 0\n\n```", "```go\nfunc startTwitterStream(stopchan <-chan struct{}, votes chan<- string) <-chan struct{} { \n  stoppedchan := make(chan struct{}, 1) \n  go func() { \n    defer func() { \n      stoppedchan <- struct{}{} \n    }() \n    for { \n      select { \n      case <-stopchan: \n        log.Println(\"stopping Twitter...\") \n        return \n      default: \n        log.Println(\"Querying Twitter...\") \n        readFromTwitter(votes) \n        log.Println(\"  (waiting)\") \n        time.Sleep(10 * time.Second) // wait before\n         reconnecting \n      } \n    } \n  }() \n  return stoppedchan \n} \n\n```"]