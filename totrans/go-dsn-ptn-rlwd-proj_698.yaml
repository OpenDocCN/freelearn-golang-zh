- en: Reading from Twitter
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Twitter 读取
- en: 'Now we are able to load the options and make authorized requests to the Twitter
    API. We are ready to write the code that initiates the connection and continuously
    reads from the stream until either we call our `closeConn` method or Twitter closes
    the connection for one reason or another. The structure contained in the stream
    is a complex one, containing all kinds of information about the tweet who made
    it and when and even what links or mentions of users occur in the body (refer
    to Twitter''s API documentation for more details). However, we are only interested
    in the tweet text itself; so, don''t worry about all the other noise and add the
    following structure to `twitter.go`:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够加载选项并授权请求 Twitter API。我们准备好编写初始化连接并持续从流中读取代码，直到我们调用 `closeConn` 方法或由于某种原因
    Twitter 关闭连接。流中包含的结构很复杂，包含有关推文是谁、何时发布以及正文中的链接或用户提及的各种信息（更多详细信息请参阅 Twitter 的 API
    文档）。然而，我们只对推文文本本身感兴趣；所以，不用担心所有其他噪音，并将以下结构添加到 `twitter.go` 中：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'This may feel incomplete, but think about how clear it makes our intentions
    to other programmers who might see our code: a tweet has some text, and that is
    all we care about.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能感觉不完整，但想想它如何使其他可能看到我们代码的程序员对我们的意图更加清晰：推文有一些文本，这就是我们关心的全部。
- en: 'Using this new structure, in `twitter.go`, add the following `readFromTwitter`
    function that takes a send only channel called `votes`; this is how this function
    will inform the rest of our program that it has noticed a vote on Twitter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个新的结构，在 `twitter.go` 文件中，添加以下名为 `readFromTwitter` 的函数，该函数接收一个只读通道 `votes`；这就是该函数如何通知我们程序的其他部分它已经注意到
    Twitter 上的投票：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, after loading the options from all the polls data (by
    calling the `loadOptions` function), we use `url.Parse` to create a `url.URL`
    object that describes the appropriate endpoint on Twitter. We build a `url.Values`
    object called `query` and set the options as a comma-separated list. As per the
    API, we make a new `POST` request using the encoded `url.Values` object as the
    body and pass it to `makeRequest` along with the query object itself. If all is
    well, we make a new `json.Decoder` from the body of the request and keep reading
    inside an infinite `for` loop by calling the `Decode` method. If there is an error
    (probably due to the connection being closed), we simply break the loop and exit
    the function. If there is a tweet to read, it will be decoded into the `t` variable,
    which will give us access to the `Text` property (the 140 characters of the tweet
    itself). We then iterate over all the possible options, and if the tweet has mentioned
    it, we send it on the `votes` channel. This technique also allows a tweet to contain
    many votes at the same time, something you may or may not decide to change based
    on the rules of the election.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在通过调用 `loadOptions` 函数加载所有投票数据选项之后，我们使用 `url.Parse` 创建一个 `url.URL` 对象，该对象描述了
    Twitter 上适当的端点。我们构建一个名为 `query` 的 `url.Values` 对象，并将选项作为逗号分隔的列表设置。根据 API，我们使用编码后的
    `url.Values` 对象作为正文，并通过 `makeRequest` 函数将其与查询对象本身一起传递。如果一切顺利，我们从请求的正文创建一个新的 `json.Decoder`，并通过调用
    `Decode` 方法在一个无限循环中持续读取。如果出现错误（可能是由于连接被关闭），我们只需中断循环并退出函数。如果有要读取的推文，它将被解码到 `t`
    变量中，这将使我们能够访问 `Text` 属性（推文本身的 140 个字符）。然后我们遍历所有可能的选项，如果推文提到了它，我们就通过 `votes` 通道发送它。这种技术还允许推文同时包含多个投票，您可能或可能不会根据选举规则决定是否更改这一点。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `votes` channel is send-only (which means we cannot receive on it), since
    it is of the `chan<- string` type. Think of the little arrow that tells us which
    way messages will flow: either into the channel (`chan<-`) or out of it (`<-chan`).
    This is a great way to express intent to other programmers or our future selves-it''s
    clear that we never intend to read votes using our `readFromTwitter` function;
    rather, we will only send them on that channel.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`votes` 通道是单向发送的（这意味着我们不能从它接收），因为它属于 `chan<- string` 类型。想想那个小箭头告诉我们消息将如何流动：要么进入通道（`chan<-`），要么从它流出（`<-chan`）。这是向其他程序员或我们未来的自己表达意图的绝佳方式——很明显，我们永远不会打算使用
    `readFromTwitter` 函数读取投票；相反，我们只会将它们发送到该通道。'
- en: Terminating the program whenever `Decode` returns an error doesn't provide a
    very robust solution. This is because the Twitter API documentation states that
    the connection will drop from time to time, and clients should consider this when
    consuming the services. And remember, we are going to terminate the connection
    periodically too, so we need to think about a way to reconnect once the connection
    is dropped.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Decode`返回错误时终止程序不是一个非常健壮的解决方案。这是因为Twitter API文档指出，连接有时会断开，客户端在消费服务时应考虑这一点。并且记住，我们也会定期终止连接，因此我们需要考虑一种在连接断开时重新连接的方法。
- en: Signal channels
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信号通道
- en: A great use of channels in Go is to signal events between code running in different
    goroutines. We are going to see a real-world example of this when we write our
    next function.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中使用通道的一个很好的用途是在不同goroutine运行的代码之间传递事件信号。当我们编写下一个函数时，我们将看到这个真实世界的例子。
- en: 'The purpose of the function is to start a goroutine that continually calls
    the `readFromTwitter` function (with the specified `votes` channel to receive
    the votes on) until we signal that we want it to stop. And once it has stopped,
    we want to be notified through another signal channel. The return of the function
    will be a channel of `struct{}`: a signal channel.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的目的是启动一个goroutine，该goroutine会持续调用`readFromTwitter`函数（使用指定的`votes`通道接收投票），直到我们发出停止信号。一旦停止，我们希望通过另一个信号通道得到通知。函数的返回值将是一个`struct{}`类型的通道：一个信号通道。
- en: Signal channels have some interesting properties that are worth taking a closer
    look at. Firstly, the type sent down the channels is an empty `struct{}`, instances
    of which actually take up zero bytes, since it has no fields. So, `struct{}{}`
    is a great memory-efficient option for signaling events. Some people use `bool`
    types, which are also fine, although `true` and `false` both take up a byte of
    memory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 信号通道有一些有趣的特性值得仔细研究。首先，通过通道发送的类型是一个空的`struct{}`，其实例实际上占用零字节，因为它没有字段。所以，`struct{}{}`是一个很好的内存高效选项，用于信号事件。有些人使用`bool`类型，这也是可以的，尽管`true`和`false`都占用一个字节的内存。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Head over to [http://play.golang.org](http://play.golang.org) and try this out
    for yourself.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[http://play.golang.org](http://play.golang.org)并亲自尝试一下。
- en: 'The size of `bool` is one:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool`类型的大小为1：'
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'On the other hand, the size of `struct{}{}` is zero:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`struct{}{}`的大小为零：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The signal channels also have a buffer size of 1, which means that execution
    will not get blocked until something reads the signal from the channel.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 信号通道也有一个缓冲大小为1，这意味着执行将不会阻塞，直到有东西从通道中读取信号。
- en: 'We are going to employ two signal channels in our code: one that we pass into
    our function that tells our goroutine that it should stop and another (provided
    by the function) that signals once the stopping is complete.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在代码中使用两个信号通道：一个是我们传递给函数的，告诉我们的goroutine应该停止，另一个（由函数提供）在停止完成后发出信号。
- en: 'In `twitter.go`, add the following function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在`twitter.go`中添加以下函数：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, the first argument, `stopchan`, is a channel of type
    `<-chan struct{}`, a receive-only signal channel. It is this channel that, outside
    the code, will signal on, which will tell our goroutine to stop. Remember that
    it''s receive-only inside this function; the actual channel itself will be capable
    of sending. The second argument is the `votes` channel on which votes will be
    sent. The return type of our function is also a signal channel of type `<-chan
    struct{}`: a receive-only channel that we will use to indicate that we have stopped.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第一个参数`stopchan`是一个类型为`<-chan struct{}`的通道，这是一个只读的信号通道。这个通道将在代码外部发出信号，告诉我们的goroutine停止。记住，在这个函数内部它是只读的；实际的通道本身将能够发送。第二个参数是`votes`通道，投票将通过这个通道发送。我们函数的返回类型也是一个信号通道，类型为`<-chan
    struct{}`：一个只读通道，我们将用它来指示我们已经停止。
- en: These channels are necessary because our function triggers its own goroutine
    and immediately returns; so without this, calling code would have no idea whether
    the spawned code was still running or not.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通道是必要的，因为我们的函数触发了自己的goroutine并立即返回；如果没有这些，调用代码将无法知道生成的代码是否仍在运行。
- en: The first thing we do in the `startTwitterStream` function is make our `stoppedchan`
    argument, and defer the sending of `struct{}{}` to indicate that we have finished
    when our function exits. Note that `stoppedchan` is a normal channel, so even
    though it is returned as receive-only, we will be able to send it from within
    this function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startTwitterStream`函数中，我们首先创建我们的`stoppedchan`参数，并在函数退出时延迟发送`struct{}{}`以表示我们已经完成。请注意，`stoppedchan`是一个普通通道，尽管它作为只读返回，但我们可以在这个函数内部发送它。
- en: We then start an infinite `for` loop in which we select from one of two channels.
    The first is `stopchan` (the first argument), which would indicate that it was
    time to stop and return (thus triggering the deferred signaling on `stoppedchan`).
    If that hasn't happened, we will call `readFromTwitter` (passing in the `votes`
    channel), which will go and load the options from the database and open the connection
    to Twitter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们启动一个无限`for`循环，从中选择两个通道中的一个。第一个是`stopchan`（第一个参数），这会表明是时候停止并返回了（从而触发`stoppedchan`上的延迟信号）。如果还没有发生这种情况，我们将调用`readFromTwitter`（传递`votes`通道），这将去加载数据库中的选项并打开到Twitter的连接。
- en: When the Twitter connection dies, our code will return, where we sleep for 10
    seconds using the `time.Sleep` function. This is to give the Twitter API rest
    in case it closed the connection due to overuse. Once we've rested, we re-enter
    the loop and check on `stopchan` again to see whether calling code wants us to
    stop or not.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当Twitter连接断开时，我们的代码将返回，我们使用`time.Sleep`函数暂停10秒钟。这是为了让Twitter API休息，以防它因为过度使用而关闭了连接。一旦我们休息好了，我们就重新进入循环，再次检查`stopchan`，看看调用代码是否想要我们停止。
- en: To make this flow clear, we are logging out key statements that will not only
    help us debug our code, but also let us peek into the inner workings of this somewhat
    complicated mechanism.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个流程更清晰，我们记录了一些关键语句，这不仅有助于我们调试代码，还能让我们窥视这个相对复杂的机制的内部工作原理。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Signal channels are a great solution for simple cases where all code lives inside
    a single package. If you need to cross API boundaries, the context package is
    the recommended way to deal with deadlines, cancelation and, stopping since it
    was promoted to the standard library in Go 1.7.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 信号通道是针对所有代码都位于单个包内的简单情况的一个很好的解决方案。如果你需要跨越API边界，那么在Go 1.7中将上下文包提升为标准库后，它就成为了处理截止日期、取消和停止的推荐方式。
