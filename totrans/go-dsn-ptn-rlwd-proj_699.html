<html><head></head><body>
<div class="book" title="Reading votes from Twitter">
<div class="book" title="Publishing to NSQ"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec0053" class="calibre1"/>Publishing to NSQ</h2></div></div></div><p class="calibre10">Once our code successfully notices votes on Twitter and sends them down the <code class="email">votes</code> channel, we need a way to publish them into an NSQ topic; after all, this is the point of the <code class="email">twittervotes</code> program.</p><p class="calibre10">We will write a function called <code class="email">publishVotes</code>, which will take the <code class="email">votes</code> channel, this time of type <code class="email">&lt;-chan string</code> (a receive only channel), and publish each string that is received from it.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note0085" class="calibre1"/>Note</h3><p class="calibre10">In our previous functions, the <code class="email">votes</code> channel was of type <code class="email">chan&lt;- string</code>, but this time, it's of the type <code class="email">&lt;-chan string</code>. You might think this is a mistake or even that it means that we cannot use the same channel for both, but you would be wrong. The channel we create later will be made with <code class="email">make(chan string)</code>, neither receive nor only send, and can act in both cases. The reason for using the <code class="email">&lt;-</code> operator on a channel in arguments is to make the intent of what the channel will be used for clear, or in the case where it is the return type, to prevent users from accidentally sending on channels intended for receiving or vice versa. The compiler will actually produce an error if they use such a channel incorrectly.</p></div><p class="calibre10">Once the <code class="email">votes</code> channel is closed (this is how the external code will tell our function to stop working), we will stop publishing and send a signal down the returned stop signal channel.</p><p class="calibre10">Add the <code class="email">publishVotes</code> function to <code class="email">main.go</code>:</p><pre class="programlisting">func publishVotes(votes &lt;-chan string) &lt;-chan struct{} { 
  stopchan := make(chan struct{}, 1) 
  pub, _ := nsq.NewProducer("localhost:4150",
   nsq.NewConfig()) 
  go func() { 
    for vote := range votes { 
      pub.Publish("votes", []byte(vote)) // publish vote 
    } 
    log.Println("Publisher: Stopping") 
    pub.Stop() 
    log.Println("Publisher: Stopped") 
    stopchan &lt;- struct{}{} 
  }() 
  return stopchan 
} 
</pre><p class="calibre10">Again, the first thing we do is create <code class="email">stopchan</code>, which we later return, this time not deferring the signaling but doing it inline by sending <code class="email">struct{}{}</code> down <code class="email">stopchan</code>.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note0086" class="calibre1"/>Note</h3><p class="calibre10">The difference in how we handle <code class="email">stopchan</code> is to show alternative options. Within one code base, you should pick a style you like and stick with it until a standard emerges within the community; in which case, we should all go with that. It is also possible to close <code class="email">stopchan</code> rather than send anything down it, which will also unblock the code waiting on that channel. But once a channel is closed, it cannot be reopened.</p></div><p class="calibre10">We then create an NSQ producer by calling <code class="email">NewProducer</code> and connecting to the default NSQ port on <code class="email">localhost</code> using a default configuration. We start a goroutine, which uses another great built-in feature of the Go language that lets us continually pull values from a channel (in our case, the <code class="email">votes</code> channel) just by doing a normal <code class="email">for...range</code> operation on it. Whenever the channel has no values, execution will be blocked until one comes down the line. If the <code class="email">votes</code> channel is closed, the <code class="email">for</code> loop will exit.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip87" class="calibre1"/>Tip</h3><p class="calibre10">To learn more about the power of channels in Go, it is highly recommended that you seek out blog posts and videos by John Graham-Cumming, in particular, one entitled <span class="strong"><em class="calibre11">A Channel Compendium</em></span> that he presented at Gophercon 2014 and which contains a brief history of channels, including their origin (interestingly, John was also the guy who successfully petitioned the British government to officially apologize for its treatment of the late, great Alan Turing).</p></div><p class="calibre10">When the loop exits (after the <code class="email">votes</code> channel is closed), the publisher is stopped, following which the <code class="email">stopchan</code> signal is sent.Â Did anything stand-out as unusual in the <code class="email">publishVotes</code> function? We are breaking a cardinal rule of Go by ignoring an error (assigning it to an underscore variables; therefore dismissing it). As an additional exercise, catch the error and deal with it in a way that seems suitable.</p></div></div></body></html>