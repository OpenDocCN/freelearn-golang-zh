- en: Publishing to NSQ
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布到NSQ
- en: Once our code successfully notices votes on Twitter and sends them down the
    `votes` channel, we need a way to publish them into an NSQ topic; after all, this
    is the point of the `twittervotes` program.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的代码成功注意到Twitter上的投票并发送它们到`votes`通道，我们需要一种方法将它们发布到NSQ主题；毕竟，这是`twittervotes`程序的目的。
- en: We will write a function called `publishVotes`, which will take the `votes`
    channel, this time of type `<-chan string` (a receive only channel), and publish
    each string that is received from it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个名为`publishVotes`的函数，该函数将接受一个`votes`通道，这次通道类型为`<-chan string`（一个只接收通道），并发布从它接收到的每个字符串。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In our previous functions, the `votes` channel was of type `chan<- string`,
    but this time, it's of the type `<-chan string`. You might think this is a mistake
    or even that it means that we cannot use the same channel for both, but you would
    be wrong. The channel we create later will be made with `make(chan string)`, neither
    receive nor only send, and can act in both cases. The reason for using the `<-`
    operator on a channel in arguments is to make the intent of what the channel will
    be used for clear, or in the case where it is the return type, to prevent users
    from accidentally sending on channels intended for receiving or vice versa. The
    compiler will actually produce an error if they use such a channel incorrectly.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的函数中，`votes`通道的类型是`chan<- string`，但这次，它的类型是`<-chan string`。你可能会认为这是一个错误，甚至认为这意味着我们不能使用同一个通道，但你错了。我们稍后创建的通道将通过`make(chan
    string)`创建，既不是接收也不是只发送，可以在这两种情况下使用。在参数中使用`<-`操作符的原因是为了使通道将要被用于什么目的意图清晰，或者在它是返回类型的情况下，防止用户意外地向用于接收的通道发送或反之亦然。如果他们错误地使用这样的通道，编译器实际上会生成一个错误。
- en: Once the `votes` channel is closed (this is how the external code will tell
    our function to stop working), we will stop publishing and send a signal down
    the returned stop signal channel.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`votes`通道关闭（这是外部代码通知我们的函数停止工作的方式），我们将停止发布并发送一个信号到返回的停止信号通道。
- en: 'Add the `publishVotes` function to `main.go`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 将`publishVotes`函数添加到`main.go`中：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Again, the first thing we do is create `stopchan`, which we later return, this
    time not deferring the signaling but doing it inline by sending `struct{}{}` down
    `stopchan`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们首先创建`stopchan`，稍后将其返回，这次不是延迟信号，而是通过在`stopchan`上发送`struct{}{}`来直接执行信号。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The difference in how we handle `stopchan` is to show alternative options. Within
    one code base, you should pick a style you like and stick with it until a standard
    emerges within the community; in which case, we should all go with that. It is
    also possible to close `stopchan` rather than send anything down it, which will
    also unblock the code waiting on that channel. But once a channel is closed, it
    cannot be reopened.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理`stopchan`的方式差异是为了展示替代选项。在一个代码库中，你应该选择一个你喜欢的风格并坚持下去，直到社区中出现一个标准；在这种情况下，我们都应该遵循那个标准。关闭`stopchan`而不是向其发送任何内容也是可能的，这将同样解除在该通道上等待的代码的阻塞。但一旦通道关闭，就无法重新打开。
- en: We then create an NSQ producer by calling `NewProducer` and connecting to the
    default NSQ port on `localhost` using a default configuration. We start a goroutine,
    which uses another great built-in feature of the Go language that lets us continually
    pull values from a channel (in our case, the `votes` channel) just by doing a
    normal `for...range` operation on it. Whenever the channel has no values, execution
    will be blocked until one comes down the line. If the `votes` channel is closed,
    the `for` loop will exit.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`NewProducer`创建一个NSQ生产者，并使用默认配置连接到`localhost`上的默认NSQ端口。我们启动一个goroutine，它使用Go语言的一个出色的内置功能，允许我们通过在通道上执行正常的`for...range`操作来持续地从通道（在我们的情况下，是`votes`通道）中拉取值。每当通道没有值时，执行将被阻塞，直到有值到来。如果`votes`通道关闭，`for`循环将退出。
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To learn more about the power of channels in Go, it is highly recommended that
    you seek out blog posts and videos by John Graham-Cumming, in particular, one
    entitled *A Channel Compendium* that he presented at Gophercon 2014 and which
    contains a brief history of channels, including their origin (interestingly, John
    was also the guy who successfully petitioned the British government to officially
    apologize for its treatment of the late, great Alan Turing).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于Go中通道的强大功能，强烈建议你寻找John Graham-Cumming的博客文章和视频，特别是他在2014年Gophercon上展示的题为*Channel
    Compendium*的文章，其中包含通道的简要历史，包括它们的起源（有趣的是，John也是成功请愿英国政府正式为对已故伟大的艾伦·图灵的待遇道歉的人）。
- en: When the loop exits (after the `votes` channel is closed), the publisher is
    stopped, following which the `stopchan` signal is sent. Did anything stand-out
    as unusual in the `publishVotes` function? We are breaking a cardinal rule of
    Go by ignoring an error (assigning it to an underscore variables; therefore dismissing
    it). As an additional exercise, catch the error and deal with it in a way that
    seems suitable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环退出（在`votes`通道关闭之后），发布者被停止，随后发送`stopchan`信号。在`publishVotes`函数中，有什么异常情况引起你的注意吗？我们正在违反Go语言的一个基本规则，即忽略一个错误（将其赋值给下划线变量；因此忽略它）。作为一个额外的练习，尝试捕获这个错误并以一种合适的方式处理它。
