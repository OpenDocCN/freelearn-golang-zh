- en: Gracefully starting and stopping programs
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优雅地启动和停止程序
- en: When our program is terminated, we want to do a few things before actually exiting,
    namely closing our connection to Twitter and stopping the NSQ publisher (which
    actually deregisters its interest in the queue). To achieve this, we have to override
    the default *Ctrl + C* behavior.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的程序终止时，我们希望在真正退出之前做一些事情，即关闭我们与Twitter的连接并停止NSQ发布者（它实际上注销了对队列的兴趣）。为了实现这一点，我们必须覆盖默认的
    *Ctrl + C* 行为。
- en: Tip
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The upcoming code blocks all go inside the `main` function; they are broken
    up so that we can discuss each section before continuing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的代码块都放在 `main` 函数内部；它们被拆分，这样我们可以在继续之前讨论每个部分。
- en: 'Add the following code inside the `main` function:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数内部添加以下代码：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we create a stop `bool` with an associated `sync.Mutex` function so that
    we can access it from many goroutines at the same time. We then create two more
    signal channels, `stopChan` and `signalChan`, and use `signal.Notify` to ask Go
    to send the signal down `signalChan` when someone tries to halt the program (either
    with the `SIGINT` interrupt or the `SIGTERM` termination POSIX signals). The `stopChan`
    function is how we indicate that we want our processes to terminate, and we pass
    it as an argument to `startTwitterStream` later.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个带有相关 `sync.Mutex` 函数的 `stop` `bool`，这样我们就可以同时从许多goroutine中访问它。然后我们创建另外两个信号通道，`stopChan`
    和 `signalChan`，并使用 `signal.Notify` 来请求Go在有人尝试停止程序时（无论是使用 `SIGINT` 中断还是 `SIGTERM`
    终止POSIX信号）将信号发送到 `signalChan`。`stopChan` 函数是我们表示我们希望我们的进程终止的方式，我们将其作为参数传递给后面的
    `startTwitterStream`。
- en: We then run a goroutine that blocks waiting for the signal by trying to read
    from `signalChan`; this is what the `<-` operator does in this case (it's trying
    to read from the channel). Since we don't care about the type of signal, we don't
    bother capturing the object returned on the channel. Once a signal is received,
    we set `stop` to `true` and close the connection. Only when one of the specified
    signals is sent will the rest of the goroutine code run, which is how we are able
    to perform teardown code before exiting the program.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们运行一个goroutine，通过尝试从 `signalChan` 读取来阻塞等待信号；这就是 `<-` 操作符在这个情况下的作用（它正在尝试从通道读取）。由于我们不关心信号的类型，所以我们不费心捕获通道返回的对象。一旦收到信号，我们将
    `stop` 设置为 `true` 并关闭连接。只有当发送了指定的信号之一时，goroutine的其余代码才会运行，这就是我们能够在退出程序之前执行拆卸代码的原因。
- en: 'Add the following piece of code (inside the main function) to open and defer
    the closing of the database connection:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在主函数内部添加以下代码片段以打开并延迟关闭数据库连接：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since the `readFromTwitter` method reloads the options from the database each
    time and because we want to keep our program updated without having to restart
    it, we are going to introduce one final goroutine. This goroutine will simply
    call `closeConn` every minute, causing the connection to die and cause `readFromTwitter`
    to be called all over again. Insert the following code at the bottom of the `main`
    function to start all of these processes and then wait for them to gracefully
    stop:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `readFromTwitter` 方法每次都会从数据库重新加载选项，而且我们希望在不重新启动程序的情况下保持程序更新，因此我们将引入一个最后的goroutine。这个goroutine将简单地每分钟调用一次
    `closeConn`，导致连接死亡并再次调用 `readFromTwitter`。在 `main` 函数底部插入以下代码以启动所有这些进程，然后等待它们优雅地停止：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, we make the `votes` channel that we have been talking about throughout
    this section, which is a simple channel of strings. Note that it is neither a
    send (`chan<-`) nor a receive (`<-chan`) channel; in fact, making such channels
    makes little sense. We then call `publishVotes`, passing in the `votes` channel
    for it to receive from and capturing the returned stop signal channel as `publisherStoppedChan`.
    Similarly, we call `startTwitterStream`, passing in our `stopChan` function from
    the beginning of the `main` function and the `votes` channel for it to send to
    while capturing the resulting stop signal channel as `twitterStoppedChan`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建本节中一直在讨论的 `votes` 通道，它是一个简单的字符串通道。请注意，它既不是发送 (`chan<-`) 通道，也不是接收 (`<-chan`)
    通道；实际上，创建这样的通道几乎没有意义。然后我们调用 `publishVotes`，传入 `votes` 通道以便它接收，并捕获返回的停止信号通道作为 `publisherStoppedChan`。同样，我们调用
    `startTwitterStream`，传入 `main` 函数开头的 `stopChan` 函数以及它要发送到的 `votes` 通道，并捕获结果停止信号通道作为
    `twitterStoppedChan`。
- en: We then start our refresher goroutine, which immediately enters an infinite
    `for` loop before sleeping for a minute and closing the connection via the call
    to `closeConn`. If the stop `bool` has been set to true (in that previous goroutine),
    we will break the loop and exit; otherwise, we will loop around and wait another
    minute before closing the connection again. The use of `stoplock` is important
    because we have two goroutines that might try to access the stop variable at the
    same time, but we want to avoid collisions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们启动我们的刷新goroutine，它立即进入一个无限`for`循环，在休眠一分钟并通过调用`closeConn`关闭连接之前。如果停止`bool`变量已被设置为true（在之前的goroutine中），我们将退出循环并退出；否则，我们将循环回来，再等待一分钟，然后再次关闭连接。使用`stoplock`是很重要的，因为我们有两个goroutine可能会同时尝试访问停止变量，但我们想避免冲突。
- en: Once the goroutine has started, we block `twitterStoppedChan` by attempting
    to read from it. When successful (which means the signal was sent on `stopChan`),
    we close the `votes` channel, which will cause the publisher's `for...range` loop
    to exit and the publisher itself to stop, after which the signal will be sent
    on `publisherStoppedChan`, which we wait for before exiting.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦goroutine启动，我们通过尝试从`twitterStoppedChan`读取来阻塞它。当成功时（这意味着在`stopChan`上发送了信号），我们关闭`votes`通道，这将导致发布者的`for...range`循环退出，并使发布者本身停止，之后将在`publisherStoppedChan`上发送信号，我们在退出之前等待这个信号。
