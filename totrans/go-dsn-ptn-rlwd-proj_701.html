<html><head></head><body>
<div class="book" title="Reading votes from Twitter">
<div class="book" title="Testing"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch05lvl2sec0055" class="calibre1"/>Testing</h2></div></div></div><p class="calibre10">To make sure our program works, we need to do two things: first, we need to create a poll in the database, and second, we need to peer inside the messaging queue to see whether the messages are indeed being generated by <code class="email">twittervotes</code>.</p><p class="calibre10">In a terminal, run the <code class="email">mongo</code> command to open a database shell that allows us to interact with MongoDB. Then, enter the following commands to add a test poll:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">&gt; use ballots</strong></span>
<span class="strong"><strong class="calibre2">switched to db ballots</strong></span>
<span class="strong"><strong class="calibre2">&gt; db.polls.insert({"title":"Test poll","options":
     ["happy","sad","fail","win"]})</strong></span>
</pre><p class="calibre10">The preceding commands add a new item to the <code class="email">polls</code> collection in the <code class="email">ballots</code> database. We are using some common words for options that are likely to be mentioned by people on Twitter so that we can observe real tweets being translated into messages. You might notice that our poll object is missing the <code class="email">results</code> field; this is fine since we are dealing with unstructured data where documents do not have to adhere to a strict schema. The <code class="email">counter</code> program we are going to write in the next section will add and maintain the <code class="email">results</code> data for us later.</p><p class="calibre10">Press <span class="strong"><em class="calibre11">CtrlÂ </em></span>+<span class="strong"><em class="calibre11"> C</em></span> to exit the MongoDB shell and type the following command:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">nsq_tail --topic="votes" --lookupd-http-
     address=localhost:4161</strong></span>
</pre><p class="calibre10">The <code class="email">nsq_tail</code> tool connects to the specified messaging queue topic and outputs any messages that it notices. This is where we will validate that our <code class="email">twittervotes</code> program is sending messages.</p><p class="calibre10">In a separate terminal window, let's build and run the <code class="email">twittervotes</code> program:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go build -o twittervotes</strong></span>
<span class="strong"><strong class="calibre2">./twittervotes</strong></span>
</pre><p class="calibre10">Now switch back to the window running <code class="email">nsq_tail</code> and note that messages are indeed being generated in response to live Twitter activity.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip89" class="calibre1"/>Tip</h3><p class="calibre10">If you don't see much activity, try to look up trending hash tags on Twitter and add another poll containing these options.</p></div></div></div></body></html>