<html><head></head><body>
<div class="book" title="Counting votes">
<div class="book" title="Consuming messages in NSQ"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec0057" class="calibre1"/>Consuming messages in NSQ</h2></div></div></div><p class="calibre10">In order to count the votes, we need to consume the messages in the <code class="email">votes</code> topic in NSQ, and we'll need a place to store them. Add the following variables to the <code class="email">main</code> function:</p><pre class="programlisting">var counts map[string]int 
var countsLock sync.Mutex 
</pre><p class="calibre10">A map and a lock (<code class="email">sync.Mutex</code>) is a common combination in Go because we will have multiple goroutines trying to access the same map, and we need to avoid corrupting it by trying to modify or read it at the same time.</p><p class="calibre10">Add the following code to the <code class="email">main</code> function:</p><pre class="programlisting">log.Println("Connecting to nsq...") 
q, err := nsq.NewConsumer("votes", "counter", nsq.NewConfig()) 
if err != nil { 
  fatal(err) 
  return 
} 
</pre><p class="calibre10">The <code class="email">NewConsumer</code> function allows us to set up an object that will listen on the <code class="email">votes</code> NSQ topic, so when <code class="email">twittervotes</code> publishes a vote on that topic, we can handle it in this program. If <code class="email">NewConsumer</code> returns an error, we'll use our <code class="email">fatal</code> function to record it and return.</p><p class="calibre10">Next, we are going to add the code that handles messages (votes) from NSQ:</p><pre class="programlisting">q.AddHandler(nsq.HandlerFunc(func(m *nsq.Message) error { 
  countsLock.Lock() 
  defer countsLock.Unlock() 
  if counts == nil { 
    counts = make(map[string]int) 
  } 
  vote := string(m.Body) 
  counts[vote]++ 
  return nil 
})) 
</pre><p class="calibre10">We call the <code class="email">AddHandler</code> method on <code class="email">nsq.Consumer</code> and pass it a function that will be called for every message received on the <code class="email">votes</code> topic.</p><p class="calibre10">When a vote comes in, the first thing we do is lock the <code class="email">countsLock</code> mutex. Next, we defer the unlocking of the mutex for when the function exits. This allows us to be sure that while <code class="email">NewConsumer</code> is running, we are the only ones allowed to modify the map; others will have to wait until our function exits before they can use it. Calls to the <code class="email">Lock</code> method block execution while the lock is in place, and it only continues when the lock is released by a call to <code class="email">Unlock</code>. This is why it's vital that every <code class="email">Lock</code> call has an <code class="email">Unlock</code> counterpart; otherwise, we will deadlock our program.</p><p class="calibre10">Every time we receive a vote, we check whether <code class="email">counts</code> is <code class="email">nil</code> and make a new map if it is because once the database has been updated with the latest results, we want to reset everything and start at zero. Finally, we increase the <code class="email">int</code> value by one for the given key and return <code class="email">nil</code>, indicating no errors.</p><p class="calibre10">Although we have created our NSQ consumer and added our handler function, we still need to connect to the NSQ service, which we will do by adding the following code:</p><pre class="programlisting">if err := q.ConnectToNSQLookupd("localhost:4161");
 err !=nil { 
  fatal(err) 
  return 
} 
</pre><div class="informaltable" title="Note"><h3 class="title2"><a id="note0091" class="calibre1"/>Note</h3><p class="calibre10">It is important to note that we are actually connecting to the HTTP port of the <code class="email">nsqlookupd</code> instance rather than NSQ instances; this abstraction means that our program doesn't need to know <span class="strong"><em class="calibre11">where</em></span> the messages are coming from in order to consume them. If we fail to connect to the server (for instance, if we forget to start it), we'll get an error, which we report to our fatal function before immediately returning.</p></div></div></div></body></html>