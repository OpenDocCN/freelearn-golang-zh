- en: Consuming messages in NSQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to count the votes, we need to consume the messages in the `votes`
    topic in NSQ, and we''ll need a place to store them. Add the following variables
    to the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A map and a lock (`sync.Mutex`) is a common combination in Go because we will
    have multiple goroutines trying to access the same map, and we need to avoid corrupting
    it by trying to modify or read it at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `NewConsumer` function allows us to set up an object that will listen on
    the `votes` NSQ topic, so when `twittervotes` publishes a vote on that topic,
    we can handle it in this program. If `NewConsumer` returns an error, we'll use
    our `fatal` function to record it and return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to add the code that handles messages (votes) from NSQ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We call the `AddHandler` method on `nsq.Consumer` and pass it a function that
    will be called for every message received on the `votes` topic.
  prefs: []
  type: TYPE_NORMAL
- en: When a vote comes in, the first thing we do is lock the `countsLock` mutex.
    Next, we defer the unlocking of the mutex for when the function exits. This allows
    us to be sure that while `NewConsumer` is running, we are the only ones allowed
    to modify the map; others will have to wait until our function exits before they
    can use it. Calls to the `Lock` method block execution while the lock is in place,
    and it only continues when the lock is released by a call to `Unlock`. This is
    why it's vital that every `Lock` call has an `Unlock` counterpart; otherwise,
    we will deadlock our program.
  prefs: []
  type: TYPE_NORMAL
- en: Every time we receive a vote, we check whether `counts` is `nil` and make a
    new map if it is because once the database has been updated with the latest results,
    we want to reset everything and start at zero. Finally, we increase the `int`
    value by one for the given key and return `nil`, indicating no errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we have created our NSQ consumer and added our handler function, we
    still need to connect to the NSQ service, which we will do by adding the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to note that we are actually connecting to the HTTP port of
    the `nsqlookupd` instance rather than NSQ instances; this abstraction means that
    our program doesn't need to know *where* the messages are coming from in order
    to consume them. If we fail to connect to the server (for instance, if we forget
    to start it), we'll get an error, which we report to our fatal function before
    immediately returning.
  prefs: []
  type: TYPE_NORMAL
