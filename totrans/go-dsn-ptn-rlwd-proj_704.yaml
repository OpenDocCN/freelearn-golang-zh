- en: Consuming messages in NSQ
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 NSQ 中消费消息
- en: 'In order to count the votes, we need to consume the messages in the `votes`
    topic in NSQ, and we''ll need a place to store them. Add the following variables
    to the `main` function:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计数投票，我们需要在 NSQ 的 `votes` 主题中消费消息，并且我们需要一个地方来存储它们。将以下变量添加到 `main` 函数中：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A map and a lock (`sync.Mutex`) is a common combination in Go because we will
    have multiple goroutines trying to access the same map, and we need to avoid corrupting
    it by trying to modify or read it at the same time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 映射和锁（`sync.Mutex`）在 Go 中是一种常见的组合，因为我们会有多个 goroutine 尝试访问同一个映射，我们需要避免在同时尝试修改或读取时破坏它。
- en: 'Add the following code to the `main` function:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `main` 函数中：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `NewConsumer` function allows us to set up an object that will listen on
    the `votes` NSQ topic, so when `twittervotes` publishes a vote on that topic,
    we can handle it in this program. If `NewConsumer` returns an error, we'll use
    our `fatal` function to record it and return.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewConsumer` 函数允许我们设置一个对象，该对象将监听 `votes` NSQ 主题，因此当 `twittervotes` 在该主题上发布投票时，我们可以在本程序中处理它。如果
    `NewConsumer` 返回错误，我们将使用我们的 `fatal` 函数记录它并返回。'
- en: 'Next, we are going to add the code that handles messages (votes) from NSQ:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加处理来自 NSQ 的消息（投票）的代码：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We call the `AddHandler` method on `nsq.Consumer` and pass it a function that
    will be called for every message received on the `votes` topic.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `nsq.Consumer` 上调用 `AddHandler` 方法，并传递一个函数，该函数将在接收到 `votes` 主题上的每条消息时被调用。
- en: When a vote comes in, the first thing we do is lock the `countsLock` mutex.
    Next, we defer the unlocking of the mutex for when the function exits. This allows
    us to be sure that while `NewConsumer` is running, we are the only ones allowed
    to modify the map; others will have to wait until our function exits before they
    can use it. Calls to the `Lock` method block execution while the lock is in place,
    and it only continues when the lock is released by a call to `Unlock`. This is
    why it's vital that every `Lock` call has an `Unlock` counterpart; otherwise,
    we will deadlock our program.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当收到投票时，我们首先做的事情是锁定 `countsLock` 互斥锁。然后，我们将互斥锁的解锁推迟到函数退出时。这确保了在 `NewConsumer`
    运行期间，我们是我们唯一被允许修改映射的人；其他人必须等待我们的函数退出后才能使用它。在互斥锁存在的情况下，对 `Lock` 方法的调用会阻塞执行，只有当通过调用
    `Unlock` 释放锁时才会继续。这就是为什么每个 `Lock` 调用都必须有一个 `Unlock` 对应项如此重要的原因；否则，我们的程序将发生死锁。
- en: Every time we receive a vote, we check whether `counts` is `nil` and make a
    new map if it is because once the database has been updated with the latest results,
    we want to reset everything and start at zero. Finally, we increase the `int`
    value by one for the given key and return `nil`, indicating no errors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们收到投票时，我们检查 `counts` 是否为 `nil`，如果是，就创建一个新的映射，因为一旦数据库已经更新了最新的结果，我们希望重置一切并从零开始。最后，我们将给定键的
    `int` 值增加一，并返回 `nil`，表示没有错误。
- en: 'Although we have created our NSQ consumer and added our handler function, we
    still need to connect to the NSQ service, which we will do by adding the following
    code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经创建了我们的 NSQ 消费者并添加了我们的处理函数，但我们仍然需要连接到 NSQ 服务，我们将通过添加以下代码来完成：
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to note that we are actually connecting to the HTTP port of
    the `nsqlookupd` instance rather than NSQ instances; this abstraction means that
    our program doesn't need to know *where* the messages are coming from in order
    to consume them. If we fail to connect to the server (for instance, if we forget
    to start it), we'll get an error, which we report to our fatal function before
    immediately returning.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们实际上是在连接到 `nsqlookupd` 实例的 HTTP 端口，而不是 NSQ 实例；这种抽象意味着我们的程序不需要知道消息是从哪里来的，以便消费它们。如果我们无法连接到服务器（例如，如果我们忘记启动它），我们会得到一个错误，我们会在立即返回之前将错误报告给我们的致命函数。
