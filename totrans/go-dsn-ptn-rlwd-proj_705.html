<html><head></head><body>
<div class="book" title="Counting votes">
<div class="book" title="Keeping the database updated"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec0058" class="calibre1"/>Keeping the database updated</h2></div></div></div><p class="calibre10">Our code will listen out for votes and keep a map of the results in the memory, but that information is trapped inside our program so far. Next, we need to add the code that will periodically push the results to the database. Add the following <code class="email">doCount</code> function:</p><pre class="programlisting">func doCount(countsLock *sync.Mutex, counts *map[string]int, pollData *mgo.Collection) { 
  countsLock.Lock() 
  defer countsLock.Unlock() 
  if len(*counts) == 0 { 
    log.Println("No new votes, skipping database update") 
    return 
  } 
  log.Println("Updating database...") 
  log.Println(*counts) 
  ok := true 
  for option, count := range *counts { 
    sel := bson.M{"options": bson.M{"$in":
     []string{option}}} 
    up := bson.M{"$inc": bson.M{"results." +
     option:count}} 
    if _, err := pollData.UpdateAll(sel, up); err != nil { 
      log.Println("failed to update:", err) 
      ok = false 
    } 
  } 
  if ok { 
    log.Println("Finished updating database...") 
    *counts = nil // reset counts 
  } 
}  
</pre><p class="calibre10">When our <code class="email">doCount</code> function runs, the first thing we do is lock <code class="email">countsLock</code> and defer its unlocking. We then check to see whether there are any values in the <code class="email">counts</code> map. If there aren't, we just log that we're skipping the update and wait for next time.</p><p class="calibre10">We are taking all arguments in as pointers (note the <code class="email">*</code> character before the type name) because we want to be sure that we are interacting with the underlying data itself and not a copy of it. For example, the <code class="email">*counts = nil</code> line will actually reset the underlying map to <code class="email">nil</code> rather than just invalidate our local copy of it. If there are some votes, we iterate over the <code class="email">counts</code> map, pulling out the option and the number of votes (since the last update), and use some MongoDB magic to update the results.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note0092" class="calibre1"/>Note</h3><p class="calibre10">MongoDB stores <span class="strong"><strong class="calibre2">BSON</strong></span> (short for <span class="strong"><strong class="calibre2">Binary JSON</strong></span>) documents internally, which are easier to traverse than normal JSON documents, and that is why the <code class="email">mgo</code> package comes with the <code class="email">mgo/bson</code> encoding package. When using <code class="email">mgo</code>, we will often use <code class="email">bson</code> types, such as the <code class="email">bson.M</code> map, to describe concepts for MongoDB.</p></div><p class="calibre10">We first create the selector for our update operation using the <code class="email">bson.M</code> shortcut type, which is similar to creating <code class="email">map[string]interface{}</code> types. The selector we create here will look something like this:</p><pre class="programlisting">{ 
  "options": { 
    "$in": ["happy"] 
  } 
} 
</pre><p class="calibre10">In MongoDB, the preceding BSON specifies that we want to select polls where <code class="email">"happy"</code> is one of the items in the <code class="email">options</code> array.</p><p class="calibre10">Next, we use the same technique to generate the update operation, which looks something like this:</p><pre class="programlisting">{ 
  "$inc": { 
    "results.happy": 3 
  } 
} 
</pre><p class="calibre10">In MongoDB, the preceding BSON specifies that we want to increase the <code class="email">results.happy</code> field by three. If there is no <code class="email">results</code> map in the poll, one will be created, and if there is no <code class="email">happy</code> key inside <code class="email">results</code>, zero will be assumed.</p><p class="calibre10">We then call the <code class="email">UpdateAll</code> method in our <code class="email">pollsData</code> query to issue the command to the database, which will in turn update every poll that matches the selector (contrast this to the <code class="email">Update</code> method, which will update only one). If something goes wrong, we report it and set the <code class="email">ok</code> Boolean to <code class="email">false</code>. If all goes well, we set the <code class="email">counts</code> map to nil, since we want to reset the counter.</p><p class="calibre10">We are going to specify <code class="email">updateDuration</code> as a constant at the top of the file, which will make it easy for us to change when we are testing our program. Add the following code above the <code class="email">main</code> function:</p><pre class="programlisting">const updateDuration = 1 * time.Second 
</pre><p class="calibre10">Next, we will add <code class="email">time.Ticker</code> and make sure our <code class="email">doCount</code> function gets called in the same <code class="email">select</code> block that we use when responding to <span class="strong"><em class="calibre11">Ctrl + C</em></span>.</p></div></div></body></html>