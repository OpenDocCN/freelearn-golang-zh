["```go\nfunc doCount(countsLock *sync.Mutex, counts *map[string]int, pollData *mgo.Collection) { \n  countsLock.Lock() \n  defer countsLock.Unlock() \n  if len(*counts) == 0 { \n    log.Println(\"No new votes, skipping database update\") \n    return \n  } \n  log.Println(\"Updating database...\") \n  log.Println(*counts) \n  ok := true \n  for option, count := range *counts { \n    sel := bson.M{\"options\": bson.M{\"$in\":\n     []string{option}}} \n    up := bson.M{\"$inc\": bson.M{\"results.\" +\n     option:count}} \n    if _, err := pollData.UpdateAll(sel, up); err != nil { \n      log.Println(\"failed to update:\", err) \n      ok = false \n    } \n  } \n  if ok { \n    log.Println(\"Finished updating database...\") \n    *counts = nil // reset counts \n  } \n}  \n\n```", "```go\n{ \n  \"options\": { \n    \"$in\": [\"happy\"] \n  } \n} \n\n```", "```go\n{ \n  \"$inc\": { \n    \"results.happy\": 3 \n  } \n} \n\n```", "```go\nconst updateDuration = 1 * time.Second \n\n```"]