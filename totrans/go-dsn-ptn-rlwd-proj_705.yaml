- en: Keeping the database updated
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持数据库更新
- en: 'Our code will listen out for votes and keep a map of the results in the memory,
    but that information is trapped inside our program so far. Next, we need to add
    the code that will periodically push the results to the database. Add the following
    `doCount` function:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码将监听投票并保持内存中的结果映射，但到目前为止，这些信息被限制在我们的程序内部。接下来，我们需要添加将结果定期推送到数据库的代码。添加以下 `doCount`
    函数：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When our `doCount` function runs, the first thing we do is lock `countsLock`
    and defer its unlocking. We then check to see whether there are any values in
    the `counts` map. If there aren't, we just log that we're skipping the update
    and wait for next time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 `doCount` 函数运行时，我们首先锁定 `countsLock` 并延迟其解锁。然后我们检查 `counts` 映射中是否有任何值。如果没有，我们只是记录跳过更新并等待下一次。
- en: We are taking all arguments in as pointers (note the `*` character before the
    type name) because we want to be sure that we are interacting with the underlying
    data itself and not a copy of it. For example, the `*counts = nil` line will actually
    reset the underlying map to `nil` rather than just invalidate our local copy of
    it. If there are some votes, we iterate over the `counts` map, pulling out the
    option and the number of votes (since the last update), and use some MongoDB magic
    to update the results.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有参数作为指针接收（注意类型名前的 `*` 字符），因为我们想确保我们正在与底层数据本身交互，而不是它的副本。例如，`*counts = nil`
    行实际上会将底层映射重置为 `nil`，而不是仅仅使我们的本地副本无效。如果有一些投票，我们将遍历 `counts` 映射，提取选项和自上次更新以来的投票数，并使用一些
    MongoDB 魔法来更新结果。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: MongoDB stores **BSON** (short for **Binary JSON**) documents internally, which
    are easier to traverse than normal JSON documents, and that is why the `mgo` package
    comes with the `mgo/bson` encoding package. When using `mgo`, we will often use
    `bson` types, such as the `bson.M` map, to describe concepts for MongoDB.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 在内部存储 **BSON**（即 **Binary JSON**）文档，这些文档比普通的 JSON 文档更容易遍历，这也是为什么 `mgo`
    包附带 `mgo/bson` 编码包的原因。当使用 `mgo` 时，我们经常会使用 `bson` 类型，例如 `bson.M` 映射，来描述 MongoDB
    的概念。
- en: 'We first create the selector for our update operation using the `bson.M` shortcut
    type, which is similar to creating `map[string]interface{}` types. The selector
    we create here will look something like this:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 `bson.M` 简化类型创建更新操作的选择器，这类似于创建 `map[string]interface{}` 类型。我们创建的选择器将看起来像这样：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In MongoDB, the preceding BSON specifies that we want to select polls where
    `"happy"` is one of the items in the `options` array.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MongoDB 中，前面的 BSON 指定我们想要选择 `"happy"` 是 `options` 数组中项之一的投票。
- en: 'Next, we use the same technique to generate the update operation, which looks
    something like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用相同的技巧来生成更新操作，其外观可能如下所示：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In MongoDB, the preceding BSON specifies that we want to increase the `results.happy`
    field by three. If there is no `results` map in the poll, one will be created,
    and if there is no `happy` key inside `results`, zero will be assumed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MongoDB 中，前面的 BSON 指定我们想要增加 `results.happy` 字段三个值。如果投票中没有 `results` 映射，将创建一个，如果
    `results` 中没有 `happy` 键，则假定为零。
- en: We then call the `UpdateAll` method in our `pollsData` query to issue the command
    to the database, which will in turn update every poll that matches the selector
    (contrast this to the `Update` method, which will update only one). If something
    goes wrong, we report it and set the `ok` Boolean to `false`. If all goes well,
    we set the `counts` map to nil, since we want to reset the counter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在 `pollsData` 查询中调用 `UpdateAll` 方法向数据库发出命令，这将反过来更新所有匹配选择器的投票（与 `Update`
    方法形成对比，它只会更新一个）。如果出现问题，我们将报告它并将 `ok` 布尔值设置为 `false`。如果一切顺利，我们将 `counts` 映射设置为
    `nil`，因为我们想重置计数器。
- en: 'We are going to specify `updateDuration` as a constant at the top of the file,
    which will make it easy for us to change when we are testing our program. Add
    the following code above the `main` function:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在文件顶部将 `updateDuration` 设置为一个常量，这样在测试程序时我们可以很容易地更改它。在 `main` 函数上方添加以下代码：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Next, we will add `time.Ticker` and make sure our `doCount` function gets called
    in the same `select` block that we use when responding to *Ctrl + C*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加 `time.Ticker` 并确保我们的 `doCount` 函数在响应 *Ctrl + C* 时被调用相同的 `select` 块。
