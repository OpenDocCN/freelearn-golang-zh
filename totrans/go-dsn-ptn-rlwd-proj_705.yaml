- en: Keeping the database updated
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our code will listen out for votes and keep a map of the results in the memory,
    but that information is trapped inside our program so far. Next, we need to add
    the code that will periodically push the results to the database. Add the following
    `doCount` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When our `doCount` function runs, the first thing we do is lock `countsLock`
    and defer its unlocking. We then check to see whether there are any values in
    the `counts` map. If there aren't, we just log that we're skipping the update
    and wait for next time.
  prefs: []
  type: TYPE_NORMAL
- en: We are taking all arguments in as pointers (note the `*` character before the
    type name) because we want to be sure that we are interacting with the underlying
    data itself and not a copy of it. For example, the `*counts = nil` line will actually
    reset the underlying map to `nil` rather than just invalidate our local copy of
    it. If there are some votes, we iterate over the `counts` map, pulling out the
    option and the number of votes (since the last update), and use some MongoDB magic
    to update the results.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MongoDB stores **BSON** (short for **Binary JSON**) documents internally, which
    are easier to traverse than normal JSON documents, and that is why the `mgo` package
    comes with the `mgo/bson` encoding package. When using `mgo`, we will often use
    `bson` types, such as the `bson.M` map, to describe concepts for MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create the selector for our update operation using the `bson.M` shortcut
    type, which is similar to creating `map[string]interface{}` types. The selector
    we create here will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In MongoDB, the preceding BSON specifies that we want to select polls where
    `"happy"` is one of the items in the `options` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the same technique to generate the update operation, which looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In MongoDB, the preceding BSON specifies that we want to increase the `results.happy`
    field by three. If there is no `results` map in the poll, one will be created,
    and if there is no `happy` key inside `results`, zero will be assumed.
  prefs: []
  type: TYPE_NORMAL
- en: We then call the `UpdateAll` method in our `pollsData` query to issue the command
    to the database, which will in turn update every poll that matches the selector
    (contrast this to the `Update` method, which will update only one). If something
    goes wrong, we report it and set the `ok` Boolean to `false`. If all goes well,
    we set the `counts` map to nil, since we want to reset the counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to specify `updateDuration` as a constant at the top of the file,
    which will make it easy for us to change when we are testing our program. Add
    the following code above the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will add `time.Ticker` and make sure our `doCount` function gets called
    in the same `select` block that we use when responding to *Ctrl + C*.
  prefs: []
  type: TYPE_NORMAL
