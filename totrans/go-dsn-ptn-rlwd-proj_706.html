<html><head></head><body>
<div class="book" title="Counting votes">
<div class="book" title="Responding to Ctrl + C"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec0059" class="calibre1"/>Responding to Ctrl + C</h2></div></div></div><p class="calibre10">The last thing to do before our program is ready is set up a select block that periodically calls <code class="email">doCount</code> and be sure that our <code class="email">main</code> function waits for operations to complete before exiting, like we did in our <code class="email">twittervotes</code> program. Add the following code at the end of the <code class="email">main</code> function:</p><pre class="programlisting">ticker := time.NewTicker(updateDuration)
 termChan := make(chan os.Signal, 1) 
signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM,syscall.SIGHUP) 
for { 
  select { 
  case &lt;-ticker.C:
   doCount(&amp;countsLock, &amp;counts,pollData)  case &lt;- termChan:ticker.Stop() 
    q.Stop() 
  case &lt;-q.StopChan: 
    // finished 
    return 
  } 
} 
</pre><p class="calibre10">The<code class="email"> time.Ticker</code> function is a type that gives us a channel (via the <code class="email">C</code> field) on which the current time is sent at the specified interval (in our case, <code class="email">updateDuration</code>). We use this in a <code class="email">select</code> block to call our <code class="email">doCount</code> function while <code class="email">termChan</code> and <code class="email">q.StopChan</code> are quiet.</p><p class="calibre10">To handle termination, we have employed a slightly different tactic than before. We trap the termination event, which will cause a signal to go down <code class="email">termChan</code> when we hit <span class="strong"><em class="calibre11">Ctrl</em></span> + <span class="strong"><em class="calibre11">C</em></span>. Next, we start an infinite loop, inside which we use the <code class="email">select</code> structure to allow us to run the code if we receive something on either <code class="email">termChan</code> or <code class="email">StopChan</code> of the consumer.</p><p class="calibre10">In fact, we will only ever get a <code class="email">termChan</code> signal first in response to a <span class="strong"><em class="calibre11">Ctrl</em></span> + <span class="strong"><em class="calibre11">C</em></span> press, at which point we stop <code class="email">time.Ticker</code> and ask the consumer to stop listening for votes. Execution then re-enters the loop and blocks until the consumer reports that it has indeed stopped by signaling on its <code class="email">StopChan</code> function. When that happens, we're done and we exit, at which point our deferred statement runs, which, if you remember, tidies up the database session.</p></div></div></body></html>