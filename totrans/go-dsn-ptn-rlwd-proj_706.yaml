- en: Responding to Ctrl + C
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应 Ctrl + C
- en: 'The last thing to do before our program is ready is set up a select block that
    periodically calls `doCount` and be sure that our `main` function waits for operations
    to complete before exiting, like we did in our `twittervotes` program. Add the
    following code at the end of the `main` function:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的程序准备就绪之前要做的最后一件事是设置一个 `select` 块，该块定期调用 `doCount`，并确保我们的 `main` 函数在退出之前等待操作完成，就像我们在
    `twittervotes` 程序中所做的那样。在 `main` 函数的末尾添加以下代码：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `time.Ticker` function is a type that gives us a channel (via the `C` field)
    on which the current time is sent at the specified interval (in our case, `updateDuration`).
    We use this in a `select` block to call our `doCount` function while `termChan`
    and `q.StopChan` are quiet.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`time.Ticker` 函数是一种类型，它为我们提供了一个通道（通过 `C` 字段），在指定的间隔（在我们的例子中，是 `updateDuration`）发送当前时间。我们使用这个通道在
    `select` 块中调用我们的 `doCount` 函数，同时 `termChan` 和 `q.StopChan` 处于安静状态。'
- en: To handle termination, we have employed a slightly different tactic than before.
    We trap the termination event, which will cause a signal to go down `termChan`
    when we hit *Ctrl* + *C*. Next, we start an infinite loop, inside which we use
    the `select` structure to allow us to run the code if we receive something on
    either `termChan` or `StopChan` of the consumer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理终止，我们采用了与之前略有不同的策略。我们捕获了终止事件，当我们按下 *Ctrl* + *C* 时，这会导致一个信号传到 `termChan`。接下来，我们启动一个无限循环，在这个循环中，我们使用
    `select` 结构来允许我们在接收到消费者 `termChan` 或 `StopChan` 上的任何信号时运行代码。
- en: In fact, we will only ever get a `termChan` signal first in response to a *Ctrl*
    + *C* press, at which point we stop `time.Ticker` and ask the consumer to stop
    listening for votes. Execution then re-enters the loop and blocks until the consumer
    reports that it has indeed stopped by signaling on its `StopChan` function. When
    that happens, we're done and we exit, at which point our deferred statement runs,
    which, if you remember, tidies up the database session.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们只有在按下 *Ctrl* + *C* 后才会首先收到 `termChan` 信号，此时我们停止 `time.Ticker` 并要求消费者停止监听投票。然后执行重新进入循环并阻塞，直到消费者通过在其
    `StopChan` 函数上发出信号来报告它确实已经停止。当这种情况发生时，我们就完成了，然后退出，此时我们的延迟语句执行，如果你还记得，它会清理数据库会话。
