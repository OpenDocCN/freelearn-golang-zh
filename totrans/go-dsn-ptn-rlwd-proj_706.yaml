- en: Responding to Ctrl + C
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last thing to do before our program is ready is set up a select block that
    periodically calls `doCount` and be sure that our `main` function waits for operations
    to complete before exiting, like we did in our `twittervotes` program. Add the
    following code at the end of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `time.Ticker` function is a type that gives us a channel (via the `C` field)
    on which the current time is sent at the specified interval (in our case, `updateDuration`).
    We use this in a `select` block to call our `doCount` function while `termChan`
    and `q.StopChan` are quiet.
  prefs: []
  type: TYPE_NORMAL
- en: To handle termination, we have employed a slightly different tactic than before.
    We trap the termination event, which will cause a signal to go down `termChan`
    when we hit *Ctrl* + *C*. Next, we start an infinite loop, inside which we use
    the `select` structure to allow us to run the code if we receive something on
    either `termChan` or `StopChan` of the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we will only ever get a `termChan` signal first in response to a *Ctrl*
    + *C* press, at which point we stop `time.Ticker` and ask the consumer to stop
    listening for votes. Execution then re-enters the loop and blocks until the consumer
    reports that it has indeed stopped by signaling on its `StopChan` function. When
    that happens, we're done and we exit, at which point our deferred statement runs,
    which, if you remember, tidies up the database session.
  prefs: []
  type: TYPE_NORMAL
