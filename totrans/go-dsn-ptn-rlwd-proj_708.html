<html><head></head><body><div class="book" title="Summary" id="5AMKM1-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec0033" class="calibre1"/>Summary</h1></div></div></div><p class="calibre10">In this chapter, we covered a lot of ground. We learned different techniques to gracefully shut down programs using signaling channels, which is especially important when our code has some work to do before it can exit. We saw that deferring the reporting of fatal errors at the start of our program can give our other deferred functions a chance to execute before the process ends.</p><p class="calibre10">We also discovered how easy it is to interact with MongoDB using the <code class="email">mgo</code> package and how to use BSON types when describing concepts for the database. The <code class="email">bson.M</code> alternative to <code class="email">map[string]interface{}</code> helps us keep our code more concise while still providing all the flexibility we need when working with unstructured or schemaless data.</p><p class="calibre10">We learned about message queues and how they allow us to break apart the components of a system into isolated and specialized micro-services. We started an instance of NSQ by first running the <code class="email">nsqlookupd</code> lookup daemon before running a single <code class="email">nsqd</code> instance and connecting them via a TCP interface. We were then able to publish votes to the queue in <code class="email">twittervotes</code> and connect to the lookup daemon to run a handler function for every vote sent in our <code class="email">counter</code> program.</p><p class="calibre10">While our solution is actually performing a pretty simple task, the architecture we have put together in this chapter is capable of doing some pretty great things.</p><p class="calibre10">We eliminated the need for our <code class="email">twittervotes</code> and counter programs to run on the same machine-as long as they can both connect to the appropriate NSQ, they will function as expected regardless of where they are running.</p><p class="calibre10">We can distribute our MongoDB and NSQ nodes across many physical machines, which would mean our system is capable of gigantic scale-whenever resources start running low, we can add new boxes to cope with the demand.</p><p class="calibre10">When we add other applications that need to query and read the results from polls, we can be sure that our database services are highly available and capable of delivering.</p><p class="calibre10">We can spread our database across geographical expanses, replicating data for backup so we don't lose anything when disaster strikes.</p><p class="calibre10">We can build a multinode, fault-tolerant NSQ environment, which means that when our <code class="email">twittervotes</code> program learns of interesting tweets, there will always be some place to send the data.</p><p class="calibre10">We can write many more programs that generate votes from different sources; the only requirement is that they know how to put messages into NSQ.</p><p class="calibre10">In the next chapter, we will build a RESTful data service of our own, through which we will expose the functionality of our social polling application. We will also build a web interface that lets users create their own polls and have the results visualized.</p></div></body></html>