- en: Summary
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot of ground. We learned different techniques
    to gracefully shut down programs using signaling channels, which is especially
    important when our code has some work to do before it can exit. We saw that deferring
    the reporting of fatal errors at the start of our program can give our other deferred
    functions a chance to execute before the process ends.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的内容。我们学习了使用信号通道优雅地关闭程序的不同技术，这在我们的代码在退出前需要做一些工作的情况下尤为重要。我们看到，在程序开始时推迟报告致命错误可以给我们的其他延迟函数一个在进程结束前执行的机会。
- en: We also discovered how easy it is to interact with MongoDB using the `mgo` package
    and how to use BSON types when describing concepts for the database. The `bson.M`
    alternative to `map[string]interface{}` helps us keep our code more concise while
    still providing all the flexibility we need when working with unstructured or
    schemaless data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还发现了使用`mgo`包与MongoDB交互是多么容易，以及如何在描述数据库概念时使用BSON类型。`bson.M`作为`map[string]interface{}`的替代方案，帮助我们使代码更加简洁，同时在处理非结构化或无模式数据时仍然提供我们需要的所有灵活性。
- en: We learned about message queues and how they allow us to break apart the components
    of a system into isolated and specialized micro-services. We started an instance
    of NSQ by first running the `nsqlookupd` lookup daemon before running a single
    `nsqd` instance and connecting them via a TCP interface. We were then able to
    publish votes to the queue in `twittervotes` and connect to the lookup daemon
    to run a handler function for every vote sent in our `counter` program.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了消息队列及其如何使我们能够将系统的组件分解成独立的和专业的微服务。我们首先通过运行`nsqlookupd`查找守护进程来启动NSQ的一个实例，然后再运行单个`nsqd`实例，并通过TCP接口将它们连接起来。然后，我们能够向`twittervotes`中的队列发布投票，并连接到查找守护进程，以便在我们的`counter`程序中为每个发送的投票运行处理函数。
- en: While our solution is actually performing a pretty simple task, the architecture
    we have put together in this chapter is capable of doing some pretty great things.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的解决方案实际上执行的是一个相当简单的任务，但我们在本章中构建的架构能够完成一些相当了不起的事情。
- en: We eliminated the need for our `twittervotes` and counter programs to run on
    the same machine-as long as they can both connect to the appropriate NSQ, they
    will function as expected regardless of where they are running.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们消除了`twittervotes`和计数器程序必须在同一台机器上运行的必要性——只要它们都能连接到适当的NSQ，无论它们在哪里运行，它们都将按预期工作。
- en: We can distribute our MongoDB and NSQ nodes across many physical machines, which
    would mean our system is capable of gigantic scale-whenever resources start running
    low, we can add new boxes to cope with the demand.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的MongoDB和NSQ节点分布到许多物理机器上，这意味着我们的系统具有巨大的可扩展性——当资源开始不足时，我们可以添加新的盒子来应对需求。
- en: When we add other applications that need to query and read the results from
    polls, we can be sure that our database services are highly available and capable
    of delivering.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加需要查询和读取投票结果的其他应用程序时，我们可以确信我们的数据库服务是高度可用且能够交付的。
- en: We can spread our database across geographical expanses, replicating data for
    backup so we don't lose anything when disaster strikes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将数据库扩展到地理范围，复制数据以进行备份，这样在灾难发生时就不会丢失任何东西。
- en: We can build a multinode, fault-tolerant NSQ environment, which means that when
    our `twittervotes` program learns of interesting tweets, there will always be
    some place to send the data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建一个多节点、容错性的NSQ环境，这意味着当我们的`twittervotes`程序发现有趣的推文时，总会有一个地方可以发送数据。
- en: We can write many more programs that generate votes from different sources;
    the only requirement is that they know how to put messages into NSQ.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写许多更多从不同来源生成投票的程序；唯一的要求是它们知道如何将消息放入NSQ。
- en: In the next chapter, we will build a RESTful data service of our own, through
    which we will expose the functionality of our social polling application. We will
    also build a web interface that lets users create their own polls and have the
    results visualized.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将构建我们自己的RESTful数据服务，通过这个服务我们将公开我们的社交投票应用程序的功能。我们还将构建一个网络界面，让用户创建他们自己的投票并可视化结果。
