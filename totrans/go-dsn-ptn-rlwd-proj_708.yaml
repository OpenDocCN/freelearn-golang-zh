- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of ground. We learned different techniques
    to gracefully shut down programs using signaling channels, which is especially
    important when our code has some work to do before it can exit. We saw that deferring
    the reporting of fatal errors at the start of our program can give our other deferred
    functions a chance to execute before the process ends.
  prefs: []
  type: TYPE_NORMAL
- en: We also discovered how easy it is to interact with MongoDB using the `mgo` package
    and how to use BSON types when describing concepts for the database. The `bson.M`
    alternative to `map[string]interface{}` helps us keep our code more concise while
    still providing all the flexibility we need when working with unstructured or
    schemaless data.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about message queues and how they allow us to break apart the components
    of a system into isolated and specialized micro-services. We started an instance
    of NSQ by first running the `nsqlookupd` lookup daemon before running a single
    `nsqd` instance and connecting them via a TCP interface. We were then able to
    publish votes to the queue in `twittervotes` and connect to the lookup daemon
    to run a handler function for every vote sent in our `counter` program.
  prefs: []
  type: TYPE_NORMAL
- en: While our solution is actually performing a pretty simple task, the architecture
    we have put together in this chapter is capable of doing some pretty great things.
  prefs: []
  type: TYPE_NORMAL
- en: We eliminated the need for our `twittervotes` and counter programs to run on
    the same machine-as long as they can both connect to the appropriate NSQ, they
    will function as expected regardless of where they are running.
  prefs: []
  type: TYPE_NORMAL
- en: We can distribute our MongoDB and NSQ nodes across many physical machines, which
    would mean our system is capable of gigantic scale-whenever resources start running
    low, we can add new boxes to cope with the demand.
  prefs: []
  type: TYPE_NORMAL
- en: When we add other applications that need to query and read the results from
    polls, we can be sure that our database services are highly available and capable
    of delivering.
  prefs: []
  type: TYPE_NORMAL
- en: We can spread our database across geographical expanses, replicating data for
    backup so we don't lose anything when disaster strikes.
  prefs: []
  type: TYPE_NORMAL
- en: We can build a multinode, fault-tolerant NSQ environment, which means that when
    our `twittervotes` program learns of interesting tweets, there will always be
    some place to send the data.
  prefs: []
  type: TYPE_NORMAL
- en: We can write many more programs that generate votes from different sources;
    the only requirement is that they know how to put messages into NSQ.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build a RESTful data service of our own, through
    which we will expose the functionality of our social polling application. We will
    also build a web interface that lets users create their own polls and have the
    results visualized.
  prefs: []
  type: TYPE_NORMAL
