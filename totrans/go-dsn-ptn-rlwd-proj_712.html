<html><head></head><body>
<div class="book" title="Sharing data between handlers" id="5CJLQ1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Context keys"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec0060" class="calibre1"/>Context keys</h2></div></div></div><p class="calibre10">Setting a value in a context object requires us to use a key, and while it might seem obvious that the value argument is of type <code class="email">interface{}</code>, which means we can (but not necessarily should) store anything we like, it might surprise you to learn the type of the key:</p><pre class="programlisting">func WithValue(parent Context, key, val interface{}) Context 
</pre><p class="calibre10">The key is also an <code class="email">interface{}</code>. This means we are not restricted to using only strings as the key, which is good news when you consider how disparate code might well attempt to set values with the same name in the same context, which would create problems.</p><p class="calibre10">Instead, a pattern of a more stable way of keying values is emerging from the Go community (and is already used in some places inside the standard library). We are going to create a simple (private) <code class="email">struct</code> for our keys and a helper method in order to get the value out of the context.</p><p class="calibre10">Add the essential minimal <code class="email">main.go</code> file inside a new <code class="email">api</code> folder:</p><pre class="programlisting">package main 
func main(){} 
</pre><p class="calibre10">Add a new type called <code class="email">contextKey</code>:</p><pre class="programlisting">type contextKey struct { 
  name string 
} 
</pre><p class="calibre10">This structure contains only the name of the key, but pointers to it will remain unique even if the <code class="email">name</code> field is the same in two keys. Next, we are going to add a key to store our API key value in:</p><pre class="programlisting">var contextKeyAPIKey = &amp;contextKey{"api-key"} 
</pre><p class="calibre10">It is good practice to group related variables together with a common prefix; in our case, we can start the name all of our context key types with the <code class="email">contextKey</code> prefix. Here, we have created a key called <code class="email">contextKeyAPIKey</code>, which is a pointer to a <code class="email">contextKey</code> type, setting the name as <code class="email">api-key</code>.</p><p class="calibre10">Next, we are going to write a helper that will, given a context, extract the key:</p><pre class="programlisting">func APIKey(ctx context.Context) (string, bool) {
 key, ok := ctx.Value(contextKeyAPIKey).(string)
 return key, ok
}
</pre><p class="calibre10">The function takes <code class="email">context.Context</code> and returns the API key string along with an <code class="email">ok</code> bool indicating whether the key was successfully obtained and cast to a string or not. If the key is missing, or if it's the wrong type, the second return argument will be false, but our code will not panic.</p><p class="calibre10">Note that <code class="email">contextKey</code> and <code class="email">contextKeyAPIKey</code> are internal (they start with a lowercase letter) but <code class="email">APIKey</code> will be exported. In <code class="email">main</code> packages, this doesn't really matter, but if you were writing a package, it's nice to know that the complexity of how you are storing and extracting data from a context is hidden from users.</p></div></div></body></html>