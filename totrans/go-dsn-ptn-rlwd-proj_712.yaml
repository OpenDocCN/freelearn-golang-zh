- en: Context keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting a value in a context object requires us to use a key, and while it
    might seem obvious that the value argument is of type `interface{}`, which means
    we can (but not necessarily should) store anything we like, it might surprise
    you to learn the type of the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The key is also an `interface{}`. This means we are not restricted to using
    only strings as the key, which is good news when you consider how disparate code
    might well attempt to set values with the same name in the same context, which
    would create problems.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, a pattern of a more stable way of keying values is emerging from the
    Go community (and is already used in some places inside the standard library).
    We are going to create a simple (private) `struct` for our keys and a helper method
    in order to get the value out of the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the essential minimal `main.go` file inside a new `api` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new type called `contextKey`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This structure contains only the name of the key, but pointers to it will remain
    unique even if the `name` field is the same in two keys. Next, we are going to
    add a key to store our API key value in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is good practice to group related variables together with a common prefix;
    in our case, we can start the name all of our context key types with the `contextKey`
    prefix. Here, we have created a key called `contextKeyAPIKey`, which is a pointer
    to a `contextKey` type, setting the name as `api-key`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to write a helper that will, given a context, extract the
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The function takes `context.Context` and returns the API key string along with
    an `ok` bool indicating whether the key was successfully obtained and cast to
    a string or not. If the key is missing, or if it's the wrong type, the second
    return argument will be false, but our code will not panic.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `contextKey` and `contextKeyAPIKey` are internal (they start with
    a lowercase letter) but `APIKey` will be exported. In `main` packages, this doesn't
    really matter, but if you were writing a package, it's nice to know that the complexity
    of how you are storing and extracting data from a context is hidden from users.
  prefs: []
  type: TYPE_NORMAL
