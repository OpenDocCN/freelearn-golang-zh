- en: Context keys
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文键
- en: 'Setting a value in a context object requires us to use a key, and while it
    might seem obvious that the value argument is of type `interface{}`, which means
    we can (but not necessarily should) store anything we like, it might surprise
    you to learn the type of the key:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文对象中设置值需要我们使用一个键，虽然值参数的类型为 `interface{}` 可能看起来很明显，这意味着我们可以（但不一定应该）存储任何我们喜欢的东西，但了解键的类型可能会让你感到惊讶：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The key is also an `interface{}`. This means we are not restricted to using
    only strings as the key, which is good news when you consider how disparate code
    might well attempt to set values with the same name in the same context, which
    would create problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字也是一个 `interface{}`。这意味着我们不仅限于使用字符串作为键，当你考虑到代码可能试图在相同上下文中使用相同名称设置值时，这是一个好消息，因为这可能会引起问题。
- en: Instead, a pattern of a more stable way of keying values is emerging from the
    Go community (and is already used in some places inside the standard library).
    We are going to create a simple (private) `struct` for our keys and a helper method
    in order to get the value out of the context.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，从 Go 社区中正在出现一种更稳定的键值模式（并且已经在标准库的一些地方使用）。我们将为我们的键创建一个简单的（私有）`struct`，并添加一个辅助方法来从上下文中获取值。
- en: 'Add the essential minimal `main.go` file inside a new `api` folder:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的 `api` 文件夹内添加必要的最小 `main.go` 文件：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add a new type called `contextKey`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为 `contextKey` 的新类型：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This structure contains only the name of the key, but pointers to it will remain
    unique even if the `name` field is the same in two keys. Next, we are going to
    add a key to store our API key value in:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构只包含键的名称，但即使两个键的 `name` 字段相同，指向它的指针也将保持唯一。接下来，我们将添加一个键来存储我们的 API 密钥值：
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It is good practice to group related variables together with a common prefix;
    in our case, we can start the name all of our context key types with the `contextKey`
    prefix. Here, we have created a key called `contextKeyAPIKey`, which is a pointer
    to a `contextKey` type, setting the name as `api-key`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将相关的变量组合在一起是一个好习惯，使用一个共同的名称前缀；在我们的情况下，我们可以从 `contextKey` 前缀开始命名我们所有的上下文键类型。在这里，我们创建了一个名为
    `contextKeyAPIKey` 的键，它是一个指向 `contextKey` 类型的指针，名称设置为 `api-key`。
- en: 'Next, we are going to write a helper that will, given a context, extract the
    key:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编写一个辅助函数，它将根据上下文提取键：
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The function takes `context.Context` and returns the API key string along with
    an `ok` bool indicating whether the key was successfully obtained and cast to
    a string or not. If the key is missing, or if it's the wrong type, the second
    return argument will be false, but our code will not panic.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受 `context.Context` 并返回 API 密钥字符串以及一个 `ok` 布尔值，指示键是否成功获取并转换为字符串。如果键缺失或类型错误，第二个返回参数将为
    false，但我们的代码不会崩溃。
- en: Note that `contextKey` and `contextKeyAPIKey` are internal (they start with
    a lowercase letter) but `APIKey` will be exported. In `main` packages, this doesn't
    really matter, but if you were writing a package, it's nice to know that the complexity
    of how you are storing and extracting data from a context is hidden from users.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`contextKey` 和 `contextKeyAPIKey` 是内部的（它们以小写字母开头），但 `APIKey` 将被导出。在 `main`
    包中，这并不重要，但如果你正在编写一个包，了解你存储和从上下文中提取数据的方式的复杂性对用户是隐藏的。
