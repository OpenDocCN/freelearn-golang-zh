<html><head></head><body>
<div class="book" title="Wrapping handler functions" id="5DI6C1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="API keys"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec0061" class="calibre1"/>API keys</h2></div></div></div><p class="calibre10">Most web APIs require clients to register an API key for their application, which they are asked to send along with every request. Such keys have many purposes, ranging from simply identifying which app the requests are coming from to addressing authorization concerns in situations where some apps are only able to do limited things based on what a user has allowed. While we don't actually need to implement API keys for our application, we are going to ask clients to provide one, which will allow us to add an implementation later, while keeping the interface constant.</p><p class="calibre10">We are going to add our first <code class="email">HandlerFunc</code> wrapper function called <code class="email">withAPIKey</code> to the bottom of <code class="email">main.go</code>:</p><pre class="programlisting">func withAPIKey(fn http.HandlerFunc) http.HandlerFunc { 
  return func(w http.ResponseWriter, r *http.Request) { 
    key := r.URL.Query().Get("key") 
    if !isValidAPIKey(key) { 
      respondErr(w, r, http.StatusUnauthorized, "invalid
       API key") 
      return 
    } 
    ctx := context.WithValue(r.Context(),
     contextKeyAPIKey, key) 
    fn(w, r.WithContext(ctx)) 
  } 
} 
</pre><p class="calibre10">As you can see, our <code class="email">withAPIKey</code> function both takes an <code class="email">http.HandlerFunc</code> type as an argument and returns one; this is what we mean by wrapping in this context. The <code class="email">withAPIKey</code> function relies on a number of other functions that we are yet to write, but you can clearly see what's going on. Our function immediately returns a new <code class="email">http.HandlerFunc</code> type that performs a check for the <code class="email">key</code> query parameter by calling <code class="email">isValidAPIKey</code>. If the key is deemed invalid (by the return of <code class="email">false</code>), we respond with an <code class="email">invalid API key</code> error; otherwise, we put the key into the context and call the next handler. To use this wrapper, we simply pass an <code class="email">http.HandlerFunc</code> type into this function in order to enable the <code class="email">key</code> parameter check. Since it returns an <code class="email">http.HandlerFunc</code> type too, the result can then be passed on to other wrappers or given directly to the <code class="email">http.HandleFunc</code> function to actually register it as the handler for a particular path pattern.</p><p class="calibre10">Let's add our <code class="email">isValidAPIKey</code> function next:</p><pre class="programlisting">func isValidAPIKey(key string) bool { 
  return key == "abc123" 
} 
</pre><p class="calibre10">For now, we are simply going to hardcode the API key as <code class="email">abc123</code>; anything else will return <code class="email">false</code> and therefore be considered invalid. Later, we can modify this function to consult a configuration file or database to check the authenticity of a key without affecting how we use the <code class="email">isValidAPIKey</code> method or the <code class="email">withAPIKey</code> wrapper.</p></div></div></body></html>