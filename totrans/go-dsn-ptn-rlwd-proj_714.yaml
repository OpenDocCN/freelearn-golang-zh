- en: API keys
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API密钥
- en: Most web APIs require clients to register an API key for their application,
    which they are asked to send along with every request. Such keys have many purposes,
    ranging from simply identifying which app the requests are coming from to addressing
    authorization concerns in situations where some apps are only able to do limited
    things based on what a user has allowed. While we don't actually need to implement
    API keys for our application, we are going to ask clients to provide one, which
    will allow us to add an implementation later, while keeping the interface constant.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Web API要求客户端为其应用程序注册一个API密钥，并在每次请求时发送。这些密钥有多种用途，从简单地识别请求来自哪个应用程序，到在有些应用程序只能根据用户允许的内容做有限操作的情况下解决授权问题。虽然我们实际上不需要为我们的应用程序实现API密钥，但我们要求客户端提供一个，这样我们就可以在保持接口不变的情况下稍后添加实现。
- en: 'We are going to add our first `HandlerFunc` wrapper function called `withAPIKey`
    to the bottom of `main.go`:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向`main.go`的底部添加第一个名为`withAPIKey`的`HandlerFunc`包装函数：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, our `withAPIKey` function both takes an `http.HandlerFunc` type
    as an argument and returns one; this is what we mean by wrapping in this context.
    The `withAPIKey` function relies on a number of other functions that we are yet
    to write, but you can clearly see what's going on. Our function immediately returns
    a new `http.HandlerFunc` type that performs a check for the `key` query parameter
    by calling `isValidAPIKey`. If the key is deemed invalid (by the return of `false`),
    we respond with an `invalid API key` error; otherwise, we put the key into the
    context and call the next handler. To use this wrapper, we simply pass an `http.HandlerFunc`
    type into this function in order to enable the `key` parameter check. Since it
    returns an `http.HandlerFunc` type too, the result can then be passed on to other
    wrappers or given directly to the `http.HandleFunc` function to actually register
    it as the handler for a particular path pattern.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的`withAPIKey`函数既接受一个`http.HandlerFunc`类型的参数，也返回一个；这就是我们在这种情况下所说的包装。`withAPIKey`函数依赖于我们尚未编写的其他多个函数，但您可以清楚地看到正在发生什么。我们的函数立即返回一个新的`http.HandlerFunc`类型，通过调用`isValidAPIKey`来执行对`key`查询参数的检查。如果密钥被认为无效（通过返回`false`），我们响应一个`invalid
    API key`错误；否则，我们将密钥放入上下文中并调用下一个处理器。要使用这个包装器，我们只需将一个`http.HandlerFunc`类型传递给这个函数，以便启用`key`参数检查。由于它也返回一个`http.HandlerFunc`类型，因此结果可以传递给其他包装器或直接传递给`http.HandleFunc`函数，以便将其注册为特定路径模式的处理器。
- en: 'Let''s add our `isValidAPIKey` function next:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们添加我们的`isValidAPIKey`函数：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For now, we are simply going to hardcode the API key as `abc123`; anything else
    will return `false` and therefore be considered invalid. Later, we can modify
    this function to consult a configuration file or database to check the authenticity
    of a key without affecting how we use the `isValidAPIKey` method or the `withAPIKey`
    wrapper.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只是将API密钥硬编码为`abc123`；任何其他内容都将返回`false`，因此被视为无效。稍后，我们可以修改这个函数，通过咨询配置文件或数据库来检查密钥的真实性，而不会影响我们使用`isValidAPIKey`方法或`withAPIKey`包装器的方式。
