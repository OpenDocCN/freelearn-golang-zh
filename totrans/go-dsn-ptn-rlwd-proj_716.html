<html><head></head><body><div class="book" title="Injecting dependencies" id="5EGMU1-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec0037" class="calibre1"/>Injecting dependencies</h1></div></div></div><p class="calibre10">Now that we can be sure that a request has a valid API key and is CORS-compliant, we must consider how handlers will connect to the database. One option is to have each handler dial its own connection, but this isn't very <span class="strong"><strong class="calibre2">DRY</strong></span> (<span class="strong"><strong class="calibre2">Don't Repeat Yourself</strong></span>) and leaves room for potentially erroneous code, such as code that forgets to close a database session once it is finished with it. It also means that if we wanted to change how we connected to the database (perhaps we want to use a domain name instead of a hardcoded IP address), we might have to modify our code in many places, rather than one.</p><p class="calibre10">Instead, we will create a new type that encapsulates all the dependencies for our handlers and construct it with a database connection in <code class="email">main.go</code>.</p><p class="calibre10">Create a new type called <code class="email">Server</code>:</p><pre class="programlisting">// Server is the API server. 
type Server struct { 
  db *mgo.Session 
} 
</pre><p class="calibre10">Our handler functions will be methods of this server, which is how they will be able to access the database session.</p></div></body></html>