<html><head></head><body><div class="book" title="Understanding the request" id="5GDO21-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec0039" class="calibre1"/>Understanding the request</h1></div></div></div><p class="calibre10">The <code class="email">http.Request</code> object gives us access to every piece of information we might need about the underlying HTTP request; therefore, it is worth glancing through the <code class="email">net/http</code> documentation to really get a feel for its power. Examples include, but are not limited to, the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The URL, path, and query string</li><li class="listitem">The HTTP method</li><li class="listitem">Cookies</li><li class="listitem">Files</li><li class="listitem">Form values</li><li class="listitem">The referrer and user agent of requester</li><li class="listitem">Basic authentication details</li><li class="listitem">The request body</li><li class="listitem">The header information</li></ul></div><p class="calibre10">There are a few things it doesn't address, which we need to either solve ourselves or look to an external package to help us with. URL path parsing is one such example – while we can access a path (such as <code class="email">/people/1/books/2</code>) as a string via the <code class="email">http.Request</code> type's <code class="email">URL.Path</code> field, there is no easy way to pull out the data encoded in the path, such as the people ID of <code class="email">1</code> or the book ID of  <code class="email">2</code>.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note0097" class="calibre1"/>Note</h3><p class="calibre10">A few projects do a good job of addressing this problem, such as Goweb or Gorillz's <code class="email">mux</code> package. They let you map path patterns that contain placeholders for values that they then pull out of the original string and make available to your code. For example, you can map a pattern of <code class="email">/users/{userID}/comments/{commentID}</code>, which will map paths such as <code class="email">/users/1/comments/2</code>. In your handler code, you can then get the values by the names placed inside the curly braces rather than having to parse the path yourself.</p></div><p class="calibre10">Since our needs are simple, we are going to knock together a simple path-parsing utility; we can always use a different package later if we have to, but that would mean adding a dependency to our project.</p><p class="calibre10">Create a new file called <code class="email">path.go</code> and insert the following code:</p><pre class="programlisting">package main 
import ( 
  "strings" 
) 
const PathSeparator = "/" 
type Path struct { 
  Path string 
  ID   string 
} 
func NewPath(p string) *Path { 
  var id string 
  p = strings.Trim(p, PathSeparator) 
  s := strings.Split(p, PathSeparator) 
  if len(s) &gt; 1 { 
    id = s[len(s)-1] 
    p = strings.Join(s[:len(s)-1], PathSeparator) 
  } 
  return &amp;Path{Path: p, ID: id} 
} 
func (p *Path) HasID() bool { 
  return len(p.ID) &gt; 0 
} 
</pre><p class="calibre10">This simple parser provides a <code class="email">NewPath</code> function that parses the specified path string and returns a new instance of the <code class="email">Path</code> type. Leading and trailing slashes are trimmed (using <code class="email">strings.Trim</code>) and the remaining path is split (using <code class="email">strings.Split</code>) by the <code class="email">PathSeparator</code> constant, which is just a forward slash. If there is more than one segment (<code class="email">len(s) &gt; 1</code>), the last one is considered to be the ID. We re-slice the slice of strings to select the last item for the ID using <code class="email">s[len(s)-1]</code> and the rest of the items for the remainder of the path using <code class="email">s[:len(s)-1]</code>. On the same lines, we also rejoin the path segments with the <code class="email">PathSeparator</code> constant to form a single string containing the path without the ID.</p><p class="calibre10">This supports any <code class="email">collection/id</code> pair, which is all we need for our API. The following table shows the state of the <code class="email">Path</code> type for the given original path string:</p><div class="informaltable"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/><col class="calibre19"/><col class="calibre19"/></colgroup><tbody class="calibre20"><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Original path string</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Path</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">ID</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">HasID</strong></span>
</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<code class="literal">/</code>
</p>
</td><td class="calibre22">
<p class="calibre23">
<code class="literal">/</code>
</p>
</td><td class="calibre22">
<p class="calibre23">
<code class="literal">nil</code>
</p>
</td><td class="calibre22">
<p class="calibre23">
<code class="literal">false</code>
</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<code class="literal">/people/</code>
</p>
</td><td class="calibre22">
<p class="calibre23">
<code class="literal">people</code>
</p>
</td><td class="calibre22">
<p class="calibre23">
<code class="literal">nil</code>
</p>
</td><td class="calibre22">
<p class="calibre23">
<code class="literal">false</code>
</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<code class="literal">/people/1/</code>
</p>
</td><td class="calibre22">
<p class="calibre23">
<code class="literal">people</code>
</p>
</td><td class="calibre22">
<p class="calibre23">
<code class="literal">1</code>
</p>
</td><td class="calibre22">
<p class="calibre23">
<code class="literal">true</code>
</p>
</td></tr></tbody></table></div></div></body></html>