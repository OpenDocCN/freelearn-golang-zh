- en: Understanding the request
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解请求
- en: 'The `http.Request` object gives us access to every piece of information we
    might need about the underlying HTTP request; therefore, it is worth glancing
    through the `net/http` documentation to really get a feel for its power. Examples
    include, but are not limited to, the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.Request`对象为我们提供了访问底层HTTP请求可能需要的每一块信息的途径；因此，浏览`net/http`文档以真正了解其强大功能是值得的。以下是一些示例，但不仅限于以下内容：'
- en: The URL, path, and query string
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL、路径和查询字符串
- en: The HTTP method
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP方法
- en: Cookies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 饼干
- en: Files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件
- en: Form values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单值
- en: The referrer and user agent of requester
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求者的来源和用户代理
- en: Basic authentication details
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本认证详情
- en: The request body
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求体
- en: The header information
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标头信息
- en: There are a few things it doesn't address, which we need to either solve ourselves
    or look to an external package to help us with. URL path parsing is one such example
    – while we can access a path (such as `/people/1/books/2`) as a string via the `http.Request`
    type's `URL.Path` field, there is no easy way to pull out the data encoded in
    the path, such as the people ID of `1` or the book ID of  `2`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它没有解决一些问题，我们需要自己解决或者寻找外部包来帮助我们。URL路径解析就是这样一个问题——虽然我们可以通过`http.Request`类型的`URL.Path`字段以字符串的形式访问路径（如`/people/1/books/2`），但没有简单的方法可以提取路径中编码的数据，如`1`的人ID或`2`的书籍ID。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A few projects do a good job of addressing this problem, such as Goweb or Gorillz's `mux`
    package. They let you map path patterns that contain placeholders for values that
    they then pull out of the original string and make available to your code. For
    example, you can map a pattern of `/users/{userID}/comments/{commentID}`, which
    will map paths such as `/users/1/comments/2`. In your handler code, you can then
    get the values by the names placed inside the curly braces rather than having
    to parse the path yourself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目很好地解决了这个问题，例如Goweb或Gorillz的`mux`包。它们允许你映射包含占位符的路径模式，然后从原始字符串中提取这些值，并将它们提供给你的代码。例如，你可以映射一个模式`/users/{userID}/comments/{commentID}`，这将映射路径，如`/users/1/comments/2`。在你的处理代码中，你可以通过花括号内放置的名称来获取值，而不是自己解析路径。
- en: Since our needs are simple, we are going to knock together a simple path-parsing
    utility; we can always use a different package later if we have to, but that would
    mean adding a dependency to our project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的需求很简单，我们将构建一个简单的路径解析实用程序；如果我们必须使用不同的包，我们总是可以这样做，但这意味着要向我们的项目中添加依赖。
- en: 'Create a new file called `path.go` and insert the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`path.go`的新文件，并插入以下代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This simple parser provides a `NewPath` function that parses the specified path
    string and returns a new instance of the `Path` type. Leading and trailing slashes
    are trimmed (using `strings.Trim`) and the remaining path is split (using `strings.Split`)
    by the `PathSeparator` constant, which is just a forward slash. If there is more
    than one segment (`len(s) > 1`), the last one is considered to be the ID. We re-slice
    the slice of strings to select the last item for the ID using `s[len(s)-1]` and
    the rest of the items for the remainder of the path using `s[:len(s)-1]`. On the
    same lines, we also rejoin the path segments with the `PathSeparator` constant
    to form a single string containing the path without the ID.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的解析器提供了一个`NewPath`函数，它解析指定的路径字符串，并返回`Path`类型的新实例。首尾斜杠被修剪（使用`strings.Trim`），剩余的路径通过`PathSeparator`常量（即正斜杠）进行分割。如果有多个段（`len(s)
    > 1`），最后一个被认为是ID。我们重新切片字符串以选择ID的最后一项，使用`s[len(s)-1]`，并使用`s[:len(s)-1]`选择路径剩余部分。同样，我们使用`PathSeparator`常量重新连接路径段，形成一个不包含ID的单个字符串。
- en: 'This supports any `collection/id` pair, which is all we need for our API. The
    following table shows the state of the `Path` type for the given original path
    string:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这支持任何`collection/id`对，这正是我们API所需要的。以下表格显示了给定原始路径字符串的`Path`类型的状态：
- en: '| **Original path string** | **Path** | **ID** | **HasID** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **原始路径字符串** | **路径** | **ID** | **是否有ID** |'
- en: '| `/` | `/` | `nil` | `false` |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `/` | `/` | `nil` | `false` |'
- en: '| `/people/` | `people` | `nil` | `false` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `/people/` | `people` | `nil` | `false` |'
- en: '| `/people/1/` | `people` | `1` | `true` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `/people/1/` | `people` | `1` | `true` |'
