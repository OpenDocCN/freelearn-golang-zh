- en: Serving our API with one function
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用一个函数来提供我们的 API
- en: A web service is nothing more than a simple Go program that binds to a specific
    HTTP address and port and serves requests, so we get to use all our command-line
    tool writing knowledge and techniques.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网络服务不过是一个简单的 Go 程序，它绑定到特定的 HTTP 地址和端口，并处理请求，因此我们可以使用我们所有的命令行工具编写知识和技巧。
- en: Tip
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We also want to ensure that our `main` function is as simple and modest as possible,
    which is always a goal of coding, especially in Go.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望确保我们的 `main` 函数尽可能简单和谦逊，这始终是编码的目标，尤其是在 Go 中。
- en: 'Before writing our `main` function, let''s look at a few design goals of our
    API program:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的 `main` 函数之前，让我们看看我们的 API 程序的一些设计目标：
- en: We should be able to specify the HTTP address and port to which our API listens
    and the address of the MongoDB instances without having to recompile the program
    (through command-line flags)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该能够指定我们的 API 监听的 HTTP 地址和端口以及 MongoDB 实例的地址，而无需重新编译程序（通过命令行标志）
- en: We want the program to gracefully shut down when we terminate it, allowing the
    in-flight requests (requests that are still being processed when the termination
    signal is sent to our program) to complete
  id: totrans-6
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们希望程序在终止时能够优雅地关闭，允许正在处理的请求（在向我们的程序发送终止信号时仍在处理的请求）完成
- en: We want the program to log out status updates and report errors properly
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望程序能够记录状态更新并正确报告错误
- en: 'Atop the `main.go` file, replace the `main` function placeholder with the following
    code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main.go` 文件顶部，将 `main` 函数占位符替换为以下代码：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This function is the entirety of our API `main` function. The first thing we
    do is specify two command-line flags, `addr` and `mongo`, with some sensible defaults
    and ask the `flag` package to parse them. We then attempt to dial the MongoDB
    database at the specified address. If we are unsuccessful, we abort with a call
    to `log.Fatalln`. Assuming the database is running and we are able to connect,
    we store the reference in the  `db` variable before deferring the closing of the
    connection. This ensures that our program properly disconnects and tidies up after
    itself when it ends.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数就是我们的 API `main` 函数的全部内容。我们首先指定两个命令行标志，`addr` 和 `mongo`，并设置一些合理的默认值，然后要求
    `flag` 包解析它们。然后我们尝试在指定的地址上拨号连接 MongoDB 数据库。如果我们不成功，我们将通过调用 `log.Fatalln` 来中止。假设数据库正在运行并且我们能够连接，我们在延迟关闭连接之前将引用存储在
    `db` 变量中。这确保了我们的程序在结束时能够正确断开连接并清理。
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We create our server and specify the database dependency. We are calling our
    server `s`, which some people think is a bad practice because it's difficult to
    read code referring to a single letter variable and know what it is. However,
    since the scope of this variable is so small, we can be sure that its use will
    be very near to its definition, removing the potential for confusion.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建我们的服务器并指定数据库依赖项。我们称我们的服务器为 `s`，有些人认为这是一种不好的做法，因为很难阅读只使用单个字母变量的代码并知道它是什么。然而，由于这个变量的作用域非常小，我们可以确信它的使用将非常接近其定义，从而消除了混淆的可能性。
- en: We then create a new `http.ServeMux` object, which is a request multiplexer
    provided by the Go standard library, and register a single handler for all requests
    that begin with the `/polls/` path. Note that the `handlePolls` handler is a method
    on our server, and this is how it will be able to access the database.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的 `http.ServeMux` 对象，这是 Go 标准库提供的一个请求多路复用器，并为以 `/polls/` 路径开始的请求注册一个单独的处理程序。请注意，`handlePolls`
    处理程序是我们服务器上的一个方法，这就是它将如何能够访问数据库。
