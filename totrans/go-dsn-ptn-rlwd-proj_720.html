<html><head></head><body>
<div class="book" title="Serving our API with one function" id="5HC8K1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Using handler function wrappers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec0063" class="calibre1"/>Using handler function wrappers</h2></div></div></div><p class="calibre10">It is when we call <code class="email">HandleFunc</code> on the <code class="email">ServeMux</code> handler that we are making use of our handler function wrappers with this line:</p><pre class="programlisting">withCORS(withAPIKey(handlePolls)) 
</pre><p class="calibre10">Since each function takes an <code class="email">http.HandlerFunc</code> type as an argument and also returns one, we are able to chain the execution just by nesting the function calls, as we have done previously. So when a request comes in with a path prefix of <code class="email">/polls/</code>, the program will take the following execution path:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">The <code class="email">withCORS</code> function is called, which sets the appropriate header.</li><li class="listitem" value="2">The <code class="email">withAPIKey</code> function is called next, which checks the request for an API key and aborts if it's invalid or else calls the next handler function.</li><li class="listitem" value="3">The <code class="email">handlePolls</code> function is then called, which may use the helper functions in <code class="email">respond.go</code> to write a response to the client.</li><li class="listitem" value="4">Execution goes back to <code class="email">withAPIKey</code>, which exits.</li><li class="listitem" value="5">Execution finally goes back to <code class="email">withCORS</code>, which exits.</li></ol><div class="calibre12"/></div></div></div></body></html>