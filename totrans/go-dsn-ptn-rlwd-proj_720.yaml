- en: Using handler function wrappers
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用处理器函数包装器
- en: 'It is when we call `HandleFunc` on the `ServeMux` handler that we are making
    use of our handler function wrappers with this line:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`ServeMux`处理器上调用`HandleFunc`时，我们就在使用这个函数调用嵌套来利用我们的处理器函数包装器，如下所示：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since each function takes an `http.HandlerFunc` type as an argument and also
    returns one, we are able to chain the execution just by nesting the function calls,
    as we have done previously. So when a request comes in with a path prefix of `/polls/`,
    the program will take the following execution path:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个函数都接受一个`http.HandlerFunc`类型的参数并返回一个，我们能够通过嵌套函数调用链式执行，就像我们之前所做的那样。所以当一个带有路径前缀`/polls/`的请求到来时，程序将采取以下执行路径：
- en: The `withCORS` function is called, which sets the appropriate header.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用了`withCORS`函数，该函数设置了适当的头信息。
- en: The `withAPIKey` function is called next, which checks the request for an API
    key and aborts if it's invalid or else calls the next handler function.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来调用`withAPIKey`函数，该函数检查请求中是否有API密钥，如果无效则中止，否则调用下一个处理器函数。
- en: The `handlePolls` function is then called, which may use the helper functions
    in `respond.go` to write a response to the client.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后调用`handlePolls`函数，该函数可能使用`respond.go`中的辅助函数向客户端写入响应。
- en: Execution goes back to `withAPIKey`, which exits.
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行返回到`withAPIKey`，然后退出。
- en: Execution finally goes back to `withCORS`, which exits.
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行最终返回到`withCORS`，然后退出。
