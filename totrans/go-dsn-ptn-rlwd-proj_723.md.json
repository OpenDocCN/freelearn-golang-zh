["```go\nfunc (s *Server) handlePolls(w http.ResponseWriter,\n r *http.Request) { \n  switch r.Method { \n    case \"GET\": \n    s.handlePollsGet(w, r) \n    return \n    case \"POST\": \n    s.handlePollsPost(w, r) \n    return \n    case \"DELETE\": \n    s.handlePollsDelete(w, r) \n    return \n  } \n  // not found \n  respondHTTPErr(w, r, http.StatusNotFound) \n} \n\n```", "```go\nfunc (s *Server) handlePollsGet(w http.ResponseWriter,\n r *http.Request) { \n  respondErr(w, r, http.StatusInternalServerError,\n   errors.New(\"not    \n  implemented\")) \n} \nfunc (s *Server) handlePollsPost(w http.ResponseWriter,\n r *http.Request) { \n  respondErr(w, r, http.StatusInternalServerError,\n   errors.New(\"not   \n   implemented\")) \n} \nfunc (s *Server) handlePollsDelete(w http.ResponseWriter,\n  r *http.Request) { \n  respondErr(w, r, http.StatusInternalServerError,\n   errors.New(\"not  \n   implemented\")) \n} \n\n```", "```go\nfunc (s *Server) handlePollsGet(w http.ResponseWriter,\n r *http.Request) { \n  session := s.db.Copy() \n  defer session.Close() \n  c := session.DB(\"ballots\").C(\"polls\") \n  var q *mgo.Query \n  p := NewPath(r.URL.Path) \n  if p.HasID() { \n    // get specific poll \n    q = c.FindId(bson.ObjectIdHex(p.ID)) \n  } else { \n    // get all polls \n    q = c.Find(nil) \n  } \n  var result []*poll \n  if err := q.All(&result); err != nil { \n    respondErr(w, r, http.StatusInternalServerError, err) \n    return \n  } \n  respond(w, r, http.StatusOK, &result) \n} \n\n```", "```go\n> use ballots\nswitched to db ballots\n> db.polls.insert({\"title\":\"Test  poll\",\"options\":\n     [\"one\",\"two\",\"three\"]})\n> db.polls.insert({\"title\":\"Test poll  two\",\"options\":\n     [\"four\",\"five\",\"six\"]})\n\n```", "```go\ngo build -o api\n./api\n\n```", "```go\nfunc (s *Server) handlePollsPost(w http.ResponseWriter, \n r *http.Request) { \n  session := s.db.Copy() \n  defer session.Close() \n  c := session.DB(\"ballots\").C(\"polls\") \n  var p poll \n  if err := decodeBody(r, &p); err != nil { \n    respondErr(w, r, http.StatusBadRequest, \"failed to\n     read poll from request\", err) \n    return \n  } \n  apikey, ok := APIKey(r.Context()) \n  if ok { \n    p.APIKey = apikey \n  } \n  p.ID = bson.NewObjectId() \n  if err := c.Insert(p); err != nil { \n    respondErr(w, r, http.StatusInternalServerError,\n     \"failed to insert \n    poll\", err) \n    return \n  } \n  w.Header().Set(\"Location\", \"polls/\"+p.ID.Hex()) \n  respond(w, r, http.StatusCreated, nil) \n} \n\n```", "```go\nfunc (s *Server) handlePollsDelete(w http.ResponseWriter, \n  r *http.Request) { \n  session := s.db.Copy() \n  defer session.Close() \n  c := session.DB(\"ballots\").C(\"polls\") \n  p := NewPath(r.URL.Path) \n  if !p.HasID() { \n    respondErr(w, r, http.StatusMethodNotAllowed,\n      \"Cannot delete all polls.\") \n    return \n  } \n  if err := c.RemoveId(bson.ObjectIdHex(p.ID)); err != nil { \n    respondErr(w, r, http.StatusInternalServerError,\n     \"failed to delete poll\", err) \n    return \n  } \n  respond(w, r, http.StatusOK, nil) // ok \n} \n\n```", "```go\ncase \"OPTIONS\": \n  w.Header().Add(\"Access-Control-Allow-Methods\", \"DELETE\") \n  respond(w, r, http.StatusOK, nil) \n  return \n\n```"]