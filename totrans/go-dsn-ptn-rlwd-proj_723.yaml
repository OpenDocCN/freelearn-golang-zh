- en: Many operations with a single handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because our simple path-parsing solution cares only about the path, we have
    to do some extra work when looking at the kind of RESTful operation the client
    is making. Specifically, we need to consider the HTTP method so that we know how
    to handle the request. For example, a `GET` call to our `/polls/` path should
    read polls, where a `POST` call would create a new one. Some frameworks solve
    this problem for you by allowing you to map handlers based on more than the path,
    such as the HTTP method or the presence of specific headers in the request. Since
    our case is ultra simple, we are going to use a simple `switch` case. In `polls.go`,
    add the `handlePolls` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We switch on the HTTP method and branch our code depending on whether it is `GET`, `POST`,
    or `DELETE`. If the HTTP method is something else, we just respond with a `404
    http.StatusNotFound` error. To make this code compile, you can add the following
    function stubs underneath the `handlePolls` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we learned how to manually parse elements of the requests (the
    HTTP method) and make decisions in code. This is great for simple cases, but it's
    worth looking at packages such as Gorilla's `mux` package for some more powerful
    ways of solving these problems. Nevertheless, keeping external dependencies to
    a minimum is a core philosophy of writing good and contained Go code.
  prefs: []
  type: TYPE_NORMAL
- en: Reading polls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now it''s time to implement the functionality of our web service. Add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The very first thing we do in each of our sub handler functions is create a
    copy of the database session that will allow us to interact with MongoDB. We then
    use `mgo` to create an object referring to the `polls` collection in the database
    – if you remember, this is where our polls live.
  prefs: []
  type: TYPE_NORMAL
- en: We then build up an `mgo.Query` object by parsing the path. If an ID is present,
    we use the `FindId` method on the `polls` collection; otherwise, we pass `nil`
    to the `Find` method, which indicates that we want to select all the polls. We
    are converting the ID from a string to a `bson.ObjectId` type with the `ObjectIdHex`
    method so that we can refer to the polls with their numerical (hex) identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `All` method expects to generate a collection of  `poll` objects,
    we define the result as `[]*poll` or a slice of pointers to poll types. Calling
    the `All` method on the query will cause `mgo` to use its connection to MongoDB
    to read all the polls and populate the `result` object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For small scale, such as a small number of polls, this approach is fine, but
    as the polls grow, we will need to consider a more sophisticated approach. We
    can page the results by iterating over them using the `Iter` method on the query
    and using the `Limit` and `Skip` methods, so we do not try to load too much data
    into the memory or present too much information to users in one go.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added some functionality, let's try out our API for the first
    time. If you are using the same MongoDB instance that we set up in the previous
    chapter, you should already have some data in the `polls` collection; to see our
    API working properly, you should ensure there are at least two polls in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to add other polls to the database, in a terminal, run the `mongo`
    command to open a database shell that will allow you to interact with MongoDB.
    Then, enter the following commands to add some test polls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In a terminal, navigate to your `api` folder and build and run the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now make a `GET` request to the `/polls/` endpoint by navigating to `http://localhost:8080/polls/?key=abc123`
    in your browser; remember to include the trailing slash. The result will be an
    array of polls in the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: Copy and paste one of the IDs from the polls list and insert it before the `?`
    character in the browser to access the data for a specific poll, for example, `http://localhost:8080/polls/5415b060a02cd4adb487c3ae?key=abc123`.
    Note that instead of returning all the polls, it only returns one.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Test the API key functionality by removing or changing the key parameter to
    see what the error looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have also noticed that although we are only returning a single poll,
    this poll value is still nested inside an array. This is a deliberate design decision
    made for two reasons: the first and most important reason is that nesting makes
    it easier for users of the API to write code to consume the data. If users are
    always expecting a JSON array, they can write strong types that describe that
    expectation rather than having one type for single polls and another for collections
    of polls. As an API designer, this is your decision to make. The second reason
    we left the object nested in an array is that it makes the API code simpler, allowing
    us to just change the `mgo.Query` object and leave the rest of the code the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a poll
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Clients should be able to make a `POST` request to `/polls/` in order to create
    a poll. Let''s add the following code inside the `POST` case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After we get a copy of the database session like earlier, we attempt to decode
    the body of the request that, according to RESTful principles, should contain
    a representation of the poll object the client wants to create. If an error occurs,
    we use the `respondErr` helper to write the error to the user and immediately
    exit from the function. We then generate a new unique ID for the poll and use
    the `mgo` package's `Insert` method to send it into the database. We then set
    the `Location` header of the response and respond with a `201 http.StatusCreated`
    message, pointing to the URL from which the newly created poll may be accessed.
    Some APIs return the object instead of providing a link to it; there is no concrete
    standard so it's up to you as the designer.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a poll
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final piece of functionality we are going to include in our API is the
    ability to delete polls. By making a request with the `DELETE` HTTP method to
    the URL of a poll (such as`/polls/5415b060a02cd4adb487c3ae`), we want to be able
    to remove the poll from the database and return a `200 Success` response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `GET` case, we parse the path, but this time, we respond with
    an error if the path does not contain an ID. For now, we don't want people to
    be able to delete all polls with one request, and so we use the suitable `StatusMethodNotAllowed`
    code. Then, using the same collection we used in the previous cases, we call `RemoveId`,
    passing the ID in the path after converting it into a `bson.ObjectId` type. Assuming
    things go well, we respond with an `http.StatusOK` message with no body.
  prefs: []
  type: TYPE_NORMAL
- en: CORS support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order for our `DELETE` capability to work over CORS, we must do a little
    extra work to support the way CORS browsers handle some HTTP methods such as `DELETE`.
    A CORS browser will actually send a preflight request (with an HTTP method of
    `OPTIONS`), asking for permission to make a `DELETE` request (listed in the `Access-Control-Request-Method`
    request header), and the API must respond appropriately in order for the request
    to work. Add another case in the `switch` statement for `OPTIONS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If the browser asks for permission to send a `DELETE` request, the API will
    respond by setting the `Access-Control-Allow-Methods` header to `DELETE`, thus
    overriding the default `*` value that we set in our `withCORS` wrapper handler.
    In the real world, the value for the `Access-Control-Allow-Methods` header will
    change in response to the request made, but since `DELETE` is the only case we
    are supporting, we can hardcode it for now.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The details of CORS are out of the scope of this book, but it is recommended
    that you research the particulars online if you intend to build truly accessible
    web services and APIs. Head over to [http://enable-cors.org/](http://enable-cors.org/)
    to get started.
  prefs: []
  type: TYPE_NORMAL
