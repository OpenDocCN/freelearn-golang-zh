- en: Many operations with a single handler
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单个处理器的许多操作
- en: 'Because our simple path-parsing solution cares only about the path, we have
    to do some extra work when looking at the kind of RESTful operation the client
    is making. Specifically, we need to consider the HTTP method so that we know how
    to handle the request. For example, a `GET` call to our `/polls/` path should
    read polls, where a `POST` call would create a new one. Some frameworks solve
    this problem for you by allowing you to map handlers based on more than the path,
    such as the HTTP method or the presence of specific headers in the request. Since
    our case is ultra simple, we are going to use a simple `switch` case. In `polls.go`,
    add the `handlePolls` function:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的简单路径解析解决方案只关心路径，当查看客户端正在进行的 RESTful 操作类型时，我们必须做一些额外的工作。具体来说，我们需要考虑 HTTP
    方法，这样我们才知道如何处理请求。例如，对 `/polls/` 路径的 `GET` 调用应该读取投票，而 `POST` 调用将创建一个新的投票。一些框架通过允许你根据路径之外的内容来映射处理器来解决此问题，例如
    HTTP 方法或请求中存在特定头。由于我们的案例非常简单，我们将使用简单的 `switch` 语句。在 `polls.go` 中添加 `handlePolls`
    函数：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We switch on the HTTP method and branch our code depending on whether it is `GET`, `POST`,
    or `DELETE`. If the HTTP method is something else, we just respond with a `404
    http.StatusNotFound` error. To make this code compile, you can add the following
    function stubs underneath the `handlePolls` handler:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开启 HTTP 方法，并根据它是 `GET`、`POST` 还是 `DELETE` 来分支我们的代码。如果 HTTP 方法是其他内容，我们只需响应一个
    `404 http.StatusNotFound` 错误。为了使这段代码能够编译，你可以在 `handlePolls` 处理器下面添加以下函数占位符：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In this section, we learned how to manually parse elements of the requests (the
    HTTP method) and make decisions in code. This is great for simple cases, but it's
    worth looking at packages such as Gorilla's `mux` package for some more powerful
    ways of solving these problems. Nevertheless, keeping external dependencies to
    a minimum is a core philosophy of writing good and contained Go code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何手动解析请求（HTTP 方法）的元素并在代码中做出决策。这对于简单情况来说很好，但值得看看像 Gorilla 的 `mux` 包这样的包，它们提供了一些更强大的解决这些问题的方法。然而，将外部依赖降到最低是编写良好且封装良好的
    Go 代码的核心哲学。
- en: Reading polls
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取投票
- en: 'Now it''s time to implement the functionality of our web service. Add the following
    code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现我们的网络服务功能了。添加以下代码：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The very first thing we do in each of our sub handler functions is create a
    copy of the database session that will allow us to interact with MongoDB. We then
    use `mgo` to create an object referring to the `polls` collection in the database
    – if you remember, this is where our polls live.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们每个子处理器函数中做的第一件事是创建数据库会话的副本，这将允许我们与 MongoDB 交互。然后我们使用 `mgo` 创建一个指向数据库中 `polls`
    集合的对象——如果你还记得，这就是我们的投票所在的地方。
- en: We then build up an `mgo.Query` object by parsing the path. If an ID is present,
    we use the `FindId` method on the `polls` collection; otherwise, we pass `nil`
    to the `Find` method, which indicates that we want to select all the polls. We
    are converting the ID from a string to a `bson.ObjectId` type with the `ObjectIdHex`
    method so that we can refer to the polls with their numerical (hex) identifiers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过解析路径来构建一个 `mgo.Query` 对象。如果存在 ID，我们就在 `polls` 集合上使用 `FindId` 方法；否则，我们将
    `nil` 传递给 `Find` 方法，这表示我们想要选择所有投票。我们使用 `ObjectIdHex` 方法将 ID 从字符串转换为 `bson.ObjectId`
    类型，这样我们就可以用它们的数值（十六进制）标识符来引用投票。
- en: Since the `All` method expects to generate a collection of  `poll` objects,
    we define the result as `[]*poll` or a slice of pointers to poll types. Calling
    the `All` method on the query will cause `mgo` to use its connection to MongoDB
    to read all the polls and populate the `result` object.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `All` 方法期望生成一个 `poll` 对象的集合，我们定义结果为 `[]*poll` 或指向 poll 类型的切片。在查询上调用 `All`
    方法将导致 `mgo` 使用其连接到 MongoDB 来读取所有投票并填充 `result` 对象。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For small scale, such as a small number of polls, this approach is fine, but
    as the polls grow, we will need to consider a more sophisticated approach. We
    can page the results by iterating over them using the `Iter` method on the query
    and using the `Limit` and `Skip` methods, so we do not try to load too much data
    into the memory or present too much information to users in one go.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小规模，例如少量投票，这种方法是可行的，但随着投票数量的增加，我们需要考虑更复杂的方法。我们可以通过在查询上使用 `Iter` 方法迭代它们，并使用
    `Limit` 和 `Skip` 方法来分页结果，这样我们就不试图将太多数据加载到内存中，或者一次性向用户展示太多信息。
- en: Now that we have added some functionality, let's try out our API for the first
    time. If you are using the same MongoDB instance that we set up in the previous
    chapter, you should already have some data in the `polls` collection; to see our
    API working properly, you should ensure there are at least two polls in the database.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了一些功能，让我们第一次尝试我们的API。如果你使用的是我们在上一章中设置的同一个MongoDB实例，你应该已经在`polls`集合中有一些数据；为了确保API正常工作，你应该确保数据库中至少有两个投票。
- en: 'If you need to add other polls to the database, in a terminal, run the `mongo`
    command to open a database shell that will allow you to interact with MongoDB.
    Then, enter the following commands to add some test polls:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要向数据库添加其他投票，在终端中运行`mongo`命令以打开一个数据库外壳，这将允许你与MongoDB交互。然后，输入以下命令以添加一些测试投票：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In a terminal, navigate to your `api` folder and build and run the project:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，导航到你的`api`文件夹，构建并运行项目：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now make a `GET` request to the `/polls/` endpoint by navigating to `http://localhost:8080/polls/?key=abc123`
    in your browser; remember to include the trailing slash. The result will be an
    array of polls in the JSON format.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过在浏览器中导航到`http://localhost:8080/polls/?key=abc123`来对该`/polls/`端点发起`GET`请求；请记住包括尾随斜杠。结果将是JSON格式的投票数组。
- en: Copy and paste one of the IDs from the polls list and insert it before the `?`
    character in the browser to access the data for a specific poll, for example, `http://localhost:8080/polls/5415b060a02cd4adb487c3ae?key=abc123`.
    Note that instead of returning all the polls, it only returns one.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并粘贴投票列表中的一个ID，将其插入到浏览器中的`?`字符之前，以访问特定投票的数据，例如，`http://localhost:8080/polls/5415b060a02cd4adb487c3ae?key=abc123`。请注意，它不会返回所有投票，而只返回一个。
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Test the API key functionality by removing or changing the key parameter to
    see what the error looks like.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通过删除或更改密钥参数来测试API密钥功能，看看错误是什么样子。
- en: 'You might have also noticed that although we are only returning a single poll,
    this poll value is still nested inside an array. This is a deliberate design decision
    made for two reasons: the first and most important reason is that nesting makes
    it easier for users of the API to write code to consume the data. If users are
    always expecting a JSON array, they can write strong types that describe that
    expectation rather than having one type for single polls and another for collections
    of polls. As an API designer, this is your decision to make. The second reason
    we left the object nested in an array is that it makes the API code simpler, allowing
    us to just change the `mgo.Query` object and leave the rest of the code the same.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到，尽管我们只返回一个投票，但这个投票值仍然嵌套在一个数组中。这是出于两个原因的故意设计决策：第一个也是最重要的原因是嵌套使得API的用户编写代码来消费数据变得更加容易。如果用户总是期望一个JSON数组，他们可以编写描述这种期望的强类型，而不是为单个投票和投票集合使用不同的类型。作为API的设计者，这是你的决定。第二个原因是，将对象嵌套在数组中使得API代码更加简单，允许我们只需更改`mgo.Query`对象，而无需更改其余代码。
- en: Creating a poll
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建投票
- en: 'Clients should be able to make a `POST` request to `/polls/` in order to create
    a poll. Let''s add the following code inside the `POST` case:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应该能够向`/polls/`发送`POST`请求以创建投票。让我们在`POST`情况中添加以下代码：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After we get a copy of the database session like earlier, we attempt to decode
    the body of the request that, according to RESTful principles, should contain
    a representation of the poll object the client wants to create. If an error occurs,
    we use the `respondErr` helper to write the error to the user and immediately
    exit from the function. We then generate a new unique ID for the poll and use
    the `mgo` package's `Insert` method to send it into the database. We then set
    the `Location` header of the response and respond with a `201 http.StatusCreated`
    message, pointing to the URL from which the newly created poll may be accessed.
    Some APIs return the object instead of providing a link to it; there is no concrete
    standard so it's up to you as the designer.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取到数据库会话的副本后，我们尝试解码请求的正文，根据RESTful原则，它应该包含客户端想要创建的投票对象的表示。如果发生错误，我们使用`respondErr`辅助函数将错误写入用户，并立即退出函数。然后我们为投票生成一个新的唯一ID，并使用`mgo`包的`Insert`方法将其发送到数据库。然后我们设置响应的`Location`头，并返回一个`201
    http.StatusCreated`消息，指向可以访问新创建投票的URL。一些API返回对象而不是提供链接；没有具体的标准，所以这取决于你作为设计者的选择。
- en: Deleting a poll
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除投票
- en: 'The final piece of functionality we are going to include in our API is the
    ability to delete polls. By making a request with the `DELETE` HTTP method to
    the URL of a poll (such as`/polls/5415b060a02cd4adb487c3ae`), we want to be able
    to remove the poll from the database and return a `200 Success` response:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要包含在我们API中的最后一个功能是删除投票的能力。通过向投票的URL（例如`/polls/5415b060a02cd4adb487c3ae`）发送一个使用`DELETE`
    HTTP方法的请求，我们希望能够从数据库中删除投票并返回一个`200 Success`响应：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Similar to the `GET` case, we parse the path, but this time, we respond with
    an error if the path does not contain an ID. For now, we don't want people to
    be able to delete all polls with one request, and so we use the suitable `StatusMethodNotAllowed`
    code. Then, using the same collection we used in the previous cases, we call `RemoveId`,
    passing the ID in the path after converting it into a `bson.ObjectId` type. Assuming
    things go well, we respond with an `http.StatusOK` message with no body.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与`GET`情况类似，我们解析路径，但这次，如果路径不包含ID，我们将响应一个错误。目前，我们不希望人们能够通过一个请求删除所有投票，因此我们使用合适的`StatusMethodNotAllowed`代码。然后，使用我们在之前案例中使用的相同集合，我们调用`RemoveId`，将路径中的ID转换为`bson.ObjectId`类型后传递。假设一切顺利，我们将以没有主体的`http.StatusOK`消息响应。
- en: CORS support
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CORS支持
- en: 'In order for our `DELETE` capability to work over CORS, we must do a little
    extra work to support the way CORS browsers handle some HTTP methods such as `DELETE`.
    A CORS browser will actually send a preflight request (with an HTTP method of
    `OPTIONS`), asking for permission to make a `DELETE` request (listed in the `Access-Control-Request-Method`
    request header), and the API must respond appropriately in order for the request
    to work. Add another case in the `switch` statement for `OPTIONS`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的`DELETE`功能能够在CORS下工作，我们必须做一些额外的工作来支持CORS浏览器处理某些HTTP方法（如`DELETE`）的方式。一个CORS浏览器实际上会发送一个预检请求（带有`OPTIONS`
    HTTP方法），请求允许发送一个`DELETE`请求（列在`Access-Control-Request-Method`请求头中），并且API必须适当地响应，以便请求能够工作。在`switch`语句中添加另一个针对`OPTIONS`的情况：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the browser asks for permission to send a `DELETE` request, the API will
    respond by setting the `Access-Control-Allow-Methods` header to `DELETE`, thus
    overriding the default `*` value that we set in our `withCORS` wrapper handler.
    In the real world, the value for the `Access-Control-Allow-Methods` header will
    change in response to the request made, but since `DELETE` is the only case we
    are supporting, we can hardcode it for now.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果浏览器请求允许发送一个`DELETE`请求，API将通过设置`Access-Control-Allow-Methods`头为`DELETE`来响应，从而覆盖我们在`withCORS`包装处理程序中设置的默认`*`值。在现实世界中，`Access-Control-Allow-Methods`头的值将根据请求而变化，但由于我们只支持`DELETE`这一种情况，我们可以现在将其硬编码。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The details of CORS are out of the scope of this book, but it is recommended
    that you research the particulars online if you intend to build truly accessible
    web services and APIs. Head over to [http://enable-cors.org/](http://enable-cors.org/)
    to get started.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: CORS的详细内容超出了本书的范围，但如果您打算构建真正可访问的Web服务和API，建议您在网上研究具体细节。前往[http://enable-cors.org/](http://enable-cors.org/)开始学习。
