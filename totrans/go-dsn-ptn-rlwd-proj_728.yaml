- en: Showing the details of a poll
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示投票的详细信息
- en: 'The final page of our app we need to complete is the `view.html` page, where
    users can see the details and live results of the poll. Create a new file called
    `view.html` inside the `public` folder and add the following HTML code to it:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要完成的最后一个页面是`view.html`页面，用户可以在其中看到投票的详细信息和实时结果。在`public`文件夹内创建一个名为`view.html`的新文件，并将以下HTML代码添加到其中：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This page is mostly similar to the other pages; it contains elements to present
    the title of the poll, the options, and a pie chart. We will be mashing up Google''s
    Visualization API with our API to present the results. Underneath the final `div`
    tag in `view.html` (and above the closing `body` tag), add the following `script`
    tags:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这个页面与其他页面大部分相似；它包含用于展示投票标题、选项和饼图的元素。我们将把Google的可视化API与我们的API结合起来以展示结果。在`view.html`的最后一个`div`标签下（在关闭`body`标签之上），添加以下`script`标签：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We include the dependencies we will need in order to power our page, jQuery
    and Bootstrap, and also the Google JavaScript API. The code loads the appropriate
    visualization libraries from Google and waits for the DOM elements to load before
    extracting the poll ID from the URL by splitting it on `poll=`. We then create
    a variable called `update` that represents a function responsible for generating
    the view of the page. This approach is taken to make it easy for us to use `window.setTimeout`
    in order to issue regular calls to update the view. Inside the `update` function,
    we use `$.get` to make a `GET` request to our `/polls/{id}` endpoint, replacing
    `{id}` with the actual ID we extracted from the URL earlier. Once the poll has
    loaded, we update the title on the page and iterate over the options to add them
    to the list. If there are results (remember, in the previous chapter, the `results`
    map was only added to the data as votes started being counted), we create a new
    `google.visualization.PieChart` object and build a `google.visualization.DataTable`
    object containing the results. Calling `draw` on the chart causes it to render
    the data and thus update the chart with the latest numbers. We then use `setTimeout`
    to tell our code to call `update` again in another second.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括了为使页面运行所需的依赖项，jQuery、Bootstrap以及Google JavaScript API。代码从Google加载适当的可视化库，并在从URL中通过`poll=`分割提取出投票ID之前等待DOM元素加载。然后我们创建一个名为`update`的变量，它代表一个负责生成页面视图的函数。采取这种做法是为了让我们能够轻松地使用`window.setTimeout`来定期调用更新视图。在`update`函数内部，我们使用`$.get`向我们的`/polls/{id}`端点发起一个`GET`请求，将`{id}`替换为我们之前从URL中提取的实际ID。一旦投票加载完成，我们就更新页面上的标题并遍历选项将它们添加到列表中。如果有结果（记住，在前一章中，`results`映射仅在开始计票时添加到数据中），我们创建一个新的`google.visualization.PieChart`对象并构建一个包含结果的`google.visualization.DataTable`对象。在图表上调用`draw`会导致它渲染数据，从而用最新的数字更新图表。然后我们使用`setTimeout`告诉我们的代码在另一秒后再次调用`update`。
- en: Finally, we bind to the `click` event of the `delete` button we added to our
    page, and after asking the user whether they are sure, make a `DELETE` request
    to the polls URL and then redirect them back to the home page. It is this request
    that will actually cause the `OPTIONS` request to be made first, asking for permission,
    which is why we added explicit support for it in our `handlePolls` function earlier.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将绑定到我们添加到页面上的`delete`按钮的`click`事件，并在询问用户是否确定后，向投票URL发起一个`DELETE`请求，然后将其重定向回主页。实际上，这个请求会导致首先发起一个`OPTIONS`请求，请求权限，这就是为什么我们在之前的`handlePolls`函数中添加了对它的显式支持。
