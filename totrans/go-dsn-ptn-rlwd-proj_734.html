<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Representing data in code" id="5N3C01-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec0046" class="calibre1"/>Representing data in code</h1></div></div></div><p class="calibre10">We are first going to expose the journeys that users can select from; so, create a new folder called <code class="email">meander</code> in <code class="email">GOPATH</code> and add the following <code class="email">journeys.go</code> code:</p><pre class="programlisting">package meander 
type j struct { 
  Name       string 
  PlaceTypes []string 
} 
var Journeys = []interface{}{ 
  j{Name: "Romantic", PlaceTypes: []string{"park", "bar",  
   "movie_theater", "restaurant", "florist", "taxi_stand"}}, 
  j{Name: "Shopping", PlaceTypes: []string{"department_store",  "cafe", 
   "clothing_store", "jewelry_store", "shoe_store"}}, 
  j{Name: "Night Out", PlaceTypes: []string{"bar", "casino", "food", 
   "bar", "night_club", "bar", "bar", "hospital"}}, 
  j{Name: "Culture", PlaceTypes: []string{"museum", "cafe", "cemetery", 
   "library", "art_gallery"}}, 
  j{Name: "Pamper", PlaceTypes: []string{"hair_care",  "beauty_salon", 
   "cafe", "spa"}}, 
} 
</pre><p class="calibre10">Here, we define an internal type called <code class="email">j</code> inside the <code class="email">meander</code> package, which we then use to describe the journeys by creating instances of them inside the <code class="email">Journeys</code> slice. This approach is an ultra-simple way of representing data in the code without building a dependency on an external data store.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip108" class="calibre1"/>Tip</h3><p class="calibre10">As an additional assignment, why not see if you can keep <code class="email">golint</code> happy throughout this process? Every time you add some code, run <code class="email">golint</code> for the packages and satisfy any suggestions that emerge. It cares a lot about exported items that have no documentation; so adding simple comments in the correct format will keep it happy. To learn more about <code class="email">golint</code>, refer to <a class="calibre1" href="https://github.com/golang/lint">https://github.com/golang/lint</a>.</p></div><p class="calibre10">Of course, this is likely to evolve into just that later, maybe even with the ability for users to create and share their own journeys. Since we are exposing our data via an API, we are free to change the internal implementation without affecting the interface, so this approach is great for a version 1.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip109" class="calibre1"/>Tip</h3><p class="calibre10">We are using a slice of type <code class="email">[]interface{}</code> because we will later implement a general way of exposing public data regardless of the actual types.</p></div><p class="calibre10">A romantic journey consists of a visit first to a park, then a bar, a movie theater, then a restaurant before a visit to a florist, and finally, a taxi ride home; you get the general idea. Feel free to get creative and add others by consulting the supported types in the Google Places API.</p><p class="calibre10">You might have noticed that since we are containing our code inside a package called <code class="email">meander</code> (rather than <code class="email">main</code>), our code can never be run as a tool like the other APIs we have written so far. Create two new folders inside meander so that you have a path that looks like <code class="email">meander/cmd/meander</code>; this will house the actual command-line tool that exposes the <code class="email">meander</code> package's capabilities via an HTTP endpoint.</p><p class="calibre10">Since we are primarily building a package for our meandering project (something that other tools can import and make use of), the code in the root folder is the <code class="email">meander</code> package, and we nest our command (the <code class="email">main</code> package) inside the <code class="email">cmd</code> folder. We include the additional final <code class="email">meander</code> folder to follow good practices where the command name is the same as the folder if we omitted it, our command would be called <code class="email">cmd</code> instead of <code class="email">meander</code>, which would get confusing.</p><p class="calibre10">Inside the <code class="email">cmd/meander</code> folder, add the following code to the <code class="email">main.go</code> file:</p><pre class="programlisting">package main 
func main() { 
  //meander.APIKey = "TODO" 
  http.HandleFunc("/journeys", func(w http.ResponseWriter,
  r *http.Request) { 
    respond(w, r, meander.Journeys) 
  }) 
  http.ListenAndServe(":8080", http.DefaultServeMux) 
} 
func respond(w http.ResponseWriter, r *http.Request, data  []interface{}) error { 
  return json.NewEncoder(w).Encode(data) 
} 
</pre><p class="calibre10">You will recognize this as a simple API endpoint program, mapping to the <code class="email">/journeys</code> endpoint.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip110" class="calibre1"/>Tip</h3><p class="calibre10">You'll have to import the <code class="email">encoding/json</code>, <code class="email">net/http</code>, and <code class="email">runtime</code> packages, along with your own <code class="email">meander</code> package you created earlier.</p></div><p class="calibre10">We set the value of <code class="email">APIKey</code> in the <code class="email">meander</code> package (which is commented out for now, since we are yet to implement it) before calling the familiar <code class="email">HandleFunc</code> function on the <code class="email">net/http</code> package to bind our endpoint, which then just responds with the <code class="email">meander.Journeys</code> variable. We borrow the abstract responding concept from the previous chapter by providing a <code class="email">respond</code> function that encodes the specified data to the <code class="email">http.ResponseWriter</code> type.</p><p class="calibre10">Let's run our API program by navigating to the <code class="email">cmd/meander</code> folder in a terminal and using <code class="email">go run</code>. We don't need to build this into an executable file at this stage since it's just a single file:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">go run main.go</strong></span>
</pre><p class="calibre10">Hit the <code class="email">http://localhost:8080/journeys</code> endpoint, and note that our <code class="email">Journeys</code> data payload is served, which looks like this:</p><pre class="programlisting">[{ 
  Name: "Romantic", 
  PlaceTypes: [ 
    "park", 
    "bar", 
    "movie_theater", 
    "restaurant", 
    "florist", 
    "taxi_stand" 
  ] 
}, ...] 
</pre><p class="calibre10">This is perfectly acceptable, but there is one major flaw: it exposes internals about our implementation. If we changed the <code class="email">PlaceTypes</code> field name to <code class="email">Types</code>, promises made in our API would break, and it's important that we avoid this.</p><p class="calibre10">Projects evolve and change over time, especially successful ones, and as developers, we should do what we can to protect our customers from the impact of the evolution. Abstracting interfaces is a great way to do this, as is taking ownership of the public-facing view of our data objects.</p></div></body></html>