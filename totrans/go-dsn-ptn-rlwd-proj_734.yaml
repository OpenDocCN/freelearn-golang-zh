- en: Representing data in code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码中表示数据
- en: 'We are first going to expose the journeys that users can select from; so, create
    a new folder called `meander` in `GOPATH` and add the following `journeys.go`
    code:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将公开用户可以选择的旅程；因此，在`GOPATH`中创建一个名为`meander`的新文件夹，并添加以下`journeys.go`代码：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we define an internal type called `j` inside the `meander` package, which
    we then use to describe the journeys by creating instances of them inside the
    `Journeys` slice. This approach is an ultra-simple way of representing data in
    the code without building a dependency on an external data store.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`meander`包内部定义了一个名为`j`的内部类型，然后我们通过在`Journeys`切片内部创建其实例来描述旅程。这种方法是在代码中表示数据的一种超简单的方式，而不依赖于外部数据存储。
- en: Tip
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As an additional assignment, why not see if you can keep `golint` happy throughout
    this process? Every time you add some code, run `golint` for the packages and
    satisfy any suggestions that emerge. It cares a lot about exported items that
    have no documentation; so adding simple comments in the correct format will keep
    it happy. To learn more about `golint`, refer to [https://github.com/golang/lint](https://github.com/golang/lint).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的任务，为什么不尝试在整个过程中保持`golint`满意呢？每次添加一些代码时，运行`golint`对包进行检查，并满足出现的任何建议。它非常关注没有文档的导出项；因此，添加正确格式的简单注释将使它保持满意。要了解更多关于`golint`的信息，请参阅[https://github.com/golang/lint](https://github.com/golang/lint)。
- en: Of course, this is likely to evolve into just that later, maybe even with the
    ability for users to create and share their own journeys. Since we are exposing
    our data via an API, we are free to change the internal implementation without
    affecting the interface, so this approach is great for a version 1.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这很可能会演变成那样，也许甚至允许用户创建和分享他们自己的旅程。由于我们通过API公开我们的数据，我们可以自由地更改内部实现而不影响接口，因此这种方法非常适合版本1。
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We are using a slice of type `[]interface{}` because we will later implement
    a general way of exposing public data regardless of the actual types.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用类型`[]interface{}`的切片，因为我们将在以后实现一种通用的公开公共数据的方法，无论实际类型如何。
- en: A romantic journey consists of a visit first to a park, then a bar, a movie
    theater, then a restaurant before a visit to a florist, and finally, a taxi ride
    home; you get the general idea. Feel free to get creative and add others by consulting
    the supported types in the Google Places API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一场浪漫的旅程包括首先参观公园，然后是酒吧，电影院，然后是餐厅，在访问花店之后，最后乘坐出租车回家；你大概能理解这个概念。请自由发挥创意，并参考Google
    Places API支持的类型添加其他内容。
- en: You might have noticed that since we are containing our code inside a package
    called `meander` (rather than `main`), our code can never be run as a tool like
    the other APIs we have written so far. Create two new folders inside meander so
    that you have a path that looks like `meander/cmd/meander`; this will house the
    actual command-line tool that exposes the `meander` package's capabilities via
    an HTTP endpoint.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，由于我们的代码包含在名为`meander`的包中（而不是`main`），我们的代码永远不能像我们迄今为止编写的其他API那样作为工具运行。在`meander`内部创建两个新的文件夹，以便你有类似`meander/cmd/meander`的路径；这将容纳实际通过HTTP端点公开`meander`包功能的命令行工具。
- en: Since we are primarily building a package for our meandering project (something
    that other tools can import and make use of), the code in the root folder is the
    `meander` package, and we nest our command (the `main` package) inside the `cmd`
    folder. We include the additional final `meander` folder to follow good practices
    where the command name is the same as the folder if we omitted it, our command
    would be called `cmd` instead of `meander`, which would get confusing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们主要在构建一个用于我们蜿蜒项目的包（其他工具可以导入并使用），根文件夹中的代码是`meander`包，我们将我们的命令（`main`包）嵌套在`cmd`文件夹内。我们包括额外的最终`meander`文件夹，以遵循良好的实践，如果省略它，我们的命令将被称为`cmd`而不是`meander`，这可能会造成混淆。
- en: 'Inside the `cmd/meander` folder, add the following code to the `main.go` file:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cmd/meander`文件夹内，将以下代码添加到`main.go`文件中：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You will recognize this as a simple API endpoint program, mapping to the `/journeys`
    endpoint.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你会认出这是一个简单的API端点程序，映射到`/journeys`端点。
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You'll have to import the `encoding/json`, `net/http`, and `runtime` packages,
    along with your own `meander` package you created earlier.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你将不得不导入`encoding/json`、`net/http`和`runtime`包，以及你之前创建的自己的`meander`包。
- en: We set the value of `APIKey` in the `meander` package (which is commented out
    for now, since we are yet to implement it) before calling the familiar `HandleFunc`
    function on the `net/http` package to bind our endpoint, which then just responds
    with the `meander.Journeys` variable. We borrow the abstract responding concept
    from the previous chapter by providing a `respond` function that encodes the specified
    data to the `http.ResponseWriter` type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `net/http` 包中的熟悉 `HandleFunc` 函数来绑定我们的端点之前，我们在 `meander` 包中设置了 `APIKey`
    的值（目前它是被注释掉的，因为我们还没有实现它）。然后，它只是简单地响应 `meander.Journeys` 变量。我们通过提供一个 `respond`
    函数，将指定数据编码到 `http.ResponseWriter` 类型，从上一章借用了抽象响应的概念。
- en: 'Let''s run our API program by navigating to the `cmd/meander` folder in a terminal
    and using `go run`. We don''t need to build this into an executable file at this
    stage since it''s just a single file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在终端中导航到 `cmd/meander` 文件夹，并使用 `go run` 来运行我们的 API 程序。在这个阶段，我们不需要将其构建成一个可执行文件，因为它只是一个单独的文件：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Hit the `http://localhost:8080/journeys` endpoint, and note that our `Journeys`
    data payload is served, which looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 `http://localhost:8080/journeys` 端点，并注意我们的 `Journeys` 数据负载是由服务器提供的，其外观如下：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is perfectly acceptable, but there is one major flaw: it exposes internals
    about our implementation. If we changed the `PlaceTypes` field name to `Types`,
    promises made in our API would break, and it''s important that we avoid this.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全是可以接受的，但有一个主要的缺陷：它暴露了我们实现的一些内部信息。如果我们把 `PlaceTypes` 字段名改为 `Types`，我们 API
    中做出的承诺就会失效，因此避免这种情况是非常重要的。
- en: Projects evolve and change over time, especially successful ones, and as developers,
    we should do what we can to protect our customers from the impact of the evolution.
    Abstracting interfaces is a great way to do this, as is taking ownership of the
    public-facing view of our data objects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 项目随着时间的推移会发展和变化，尤其是那些成功的项目，作为开发者，我们应该尽我们所能来保护我们的客户免受项目演变的影响。抽象接口是做这件事的一个很好的方法，同样，负责我们数据对象面向公众的视图也是。
