- en: Representing data in code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are first going to expose the journeys that users can select from; so, create
    a new folder called `meander` in `GOPATH` and add the following `journeys.go`
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define an internal type called `j` inside the `meander` package, which
    we then use to describe the journeys by creating instances of them inside the
    `Journeys` slice. This approach is an ultra-simple way of representing data in
    the code without building a dependency on an external data store.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an additional assignment, why not see if you can keep `golint` happy throughout
    this process? Every time you add some code, run `golint` for the packages and
    satisfy any suggestions that emerge. It cares a lot about exported items that
    have no documentation; so adding simple comments in the correct format will keep
    it happy. To learn more about `golint`, refer to [https://github.com/golang/lint](https://github.com/golang/lint).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is likely to evolve into just that later, maybe even with the
    ability for users to create and share their own journeys. Since we are exposing
    our data via an API, we are free to change the internal implementation without
    affecting the interface, so this approach is great for a version 1.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using a slice of type `[]interface{}` because we will later implement
    a general way of exposing public data regardless of the actual types.
  prefs: []
  type: TYPE_NORMAL
- en: A romantic journey consists of a visit first to a park, then a bar, a movie
    theater, then a restaurant before a visit to a florist, and finally, a taxi ride
    home; you get the general idea. Feel free to get creative and add others by consulting
    the supported types in the Google Places API.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that since we are containing our code inside a package
    called `meander` (rather than `main`), our code can never be run as a tool like
    the other APIs we have written so far. Create two new folders inside meander so
    that you have a path that looks like `meander/cmd/meander`; this will house the
    actual command-line tool that exposes the `meander` package's capabilities via
    an HTTP endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are primarily building a package for our meandering project (something
    that other tools can import and make use of), the code in the root folder is the
    `meander` package, and we nest our command (the `main` package) inside the `cmd`
    folder. We include the additional final `meander` folder to follow good practices
    where the command name is the same as the folder if we omitted it, our command
    would be called `cmd` instead of `meander`, which would get confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `cmd/meander` folder, add the following code to the `main.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You will recognize this as a simple API endpoint program, mapping to the `/journeys`
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You'll have to import the `encoding/json`, `net/http`, and `runtime` packages,
    along with your own `meander` package you created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: We set the value of `APIKey` in the `meander` package (which is commented out
    for now, since we are yet to implement it) before calling the familiar `HandleFunc`
    function on the `net/http` package to bind our endpoint, which then just responds
    with the `meander.Journeys` variable. We borrow the abstract responding concept
    from the previous chapter by providing a `respond` function that encodes the specified
    data to the `http.ResponseWriter` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run our API program by navigating to the `cmd/meander` folder in a terminal
    and using `go run`. We don''t need to build this into an executable file at this
    stage since it''s just a single file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Hit the `http://localhost:8080/journeys` endpoint, and note that our `Journeys`
    data payload is served, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is perfectly acceptable, but there is one major flaw: it exposes internals
    about our implementation. If we changed the `PlaceTypes` field name to `Types`,
    promises made in our API would break, and it''s important that we avoid this.'
  prefs: []
  type: TYPE_NORMAL
- en: Projects evolve and change over time, especially successful ones, and as developers,
    we should do what we can to protect our customers from the impact of the evolution.
    Abstracting interfaces is a great way to do this, as is taking ownership of the
    public-facing view of our data objects.
  prefs: []
  type: TYPE_NORMAL
