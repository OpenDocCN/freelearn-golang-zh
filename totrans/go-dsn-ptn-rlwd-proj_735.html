<html><head></head><body>
<div class="book" title="Representing data in code" id="5N3C01-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Public views of Go structs"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec0071" class="calibre1"/>Public views of Go structs</h2></div></div></div><p class="calibre10">In order to control the public view of structs in Go, we need to invent a way to allow individual <code class="email">journey</code> types to tell us how they want to be exposed. In the root <code class="email">meander</code> folder, create a new file called <code class="email">public.go</code> and add the following code:</p><pre class="programlisting">package meander 
type Facade interface { 
  Public() interface{} 
} 
func Public(o interface{}) interface{} { 
  if p, ok := o.(Facade); ok { 
    return p.Public() 
  } 
  return o 
} 
</pre><p class="calibre10">The <code class="email">Facade</code> interface exposes a single <code class="email">Public</code> method, which will return the public view of a struct. The exported <code class="email">Public</code> function takes any object and checks whether it implements the <code class="email">Facade</code> interface (does it have a <code class="email">Public() interface{}</code> method?); if it is implemented, it calls the method and returns the result otherwise, it just returns the original object untouched. This allows us to pass anything through the <code class="email">Public</code> function before writing the result to the <code class="email">ResponseWriter</code> object, allowing individual structs to control their public appearance.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip111" class="calibre1"/>Tip</h3><p class="calibre10">Normally, single method interfaces such as our <code class="email">Facade</code> are named after the method they describe, such as <code class="email">Reader</code> and <code class="email">Writer</code>. However, <code class="email">Publicer</code> is just confusing, so I deliberately broke the rule.</p></div><p class="calibre10">Let's implement a <code class="email">Public</code> method for our <code class="email">j</code> type by adding the following code to <code class="email">journeys.go</code>:</p><pre class="programlisting">func (j j) Public() interface{} { 
  return map[string]interface{}{ 
    "name":    j.Name, 
    "journey": strings.Join(j.PlaceTypes, "|"), 
  } 
} 
</pre><p class="calibre10">The public view of our <code class="email">j</code> type joins the <code class="email">PlaceTypes</code> field into a single string separated by the pipe character as per our API design.</p><p class="calibre10">Head back to <code class="email">cmd/meander/main.go</code> and replace the <code class="email">respond</code> method with one that makes use of our new <code class="email">Public</code> function:</p><pre class="programlisting">func respond(w http.ResponseWriter, r *http.Request, data []interface{}) error { 
  publicData := make([]interface{}, len(data)) 
  for i, d := range data { 
    publicData[i] = meander.Public(d) 
  } 
  return json.NewEncoder(w).Encode(publicData) 
} 
</pre><p class="calibre10">Here, we iterate over the data slice calling the <code class="email">meander.Public</code> function for each item, building the results into a new slice of the same size. In the case of our <code class="email">j</code> type, its <code class="email">Public</code> method will be called to serve the public view of the data rather than the default view. In a terminal, navigate to the <code class="email">cmd/meander</code> folder again and run <code class="email">go run main.go</code> before hitting <code class="email">http://localhost:8080/journeys</code>. Note that the same data has now changed to a new structure:</p><pre class="programlisting">[{ 
  journey: "park|bar|movie_theater|restaurant|florist|taxi_stand", 
  name: "Romantic" 
}, ...] 
</pre><div class="informaltable" title="Note"><h3 class="title2"><a id="note00112" class="calibre1"/>Note</h3><p class="calibre10">An alternative way of achieving the same result would be to use tags to control the field names, as we have done in previous chapters, and implement your own <code class="email">[]string</code> type that provides a <code class="email">MarshalJSON</code> method which tells the encoder how to marshal your type. Both are perfectly acceptable, but the <code class="email">Facade</code> interface and <code class="email">Public</code> method are probably more expressive (if someone reads the code, isn't it obvious what's going on?) and give us more control.</p></div></div></div></body></html>