- en: Public views of Go structs
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 结构体的公共视图
- en: 'In order to control the public view of structs in Go, we need to invent a way
    to allow individual `journey` types to tell us how they want to be exposed. In
    the root `meander` folder, create a new file called `public.go` and add the following
    code:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制 Go 中结构体的公共视图，我们需要发明一种方法，允许单个 `journey` 类型告诉我们它们希望如何被暴露。在根 `meander` 文件夹中，创建一个名为
    `public.go` 的新文件，并添加以下代码：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `Facade` interface exposes a single `Public` method, which will return the
    public view of a struct. The exported `Public` function takes any object and checks
    whether it implements the `Facade` interface (does it have a `Public() interface{}`
    method?); if it is implemented, it calls the method and returns the result otherwise,
    it just returns the original object untouched. This allows us to pass anything
    through the `Public` function before writing the result to the `ResponseWriter`
    object, allowing individual structs to control their public appearance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '`Facade` 接口公开了一个单一的 `Public` 方法，它将返回结构体的公共视图。导出的 `Public` 函数接受任何对象并检查它是否实现了
    `Facade` 接口（是否有 `Public() interface{}` 方法？）；如果实现了，它将调用该方法并返回结果，否则，它将直接返回原始对象而不做任何修改。这允许我们在将结果写入
    `ResponseWriter` 对象之前通过 `Public` 函数传递任何内容，允许单个结构体控制其公共外观。'
- en: Tip
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Normally, single method interfaces such as our `Facade` are named after the
    method they describe, such as `Reader` and `Writer`. However, `Publicer` is just
    confusing, so I deliberately broke the rule.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，像我们的 `Facade` 这样的单方法接口会以它们描述的方法命名，例如 `Reader` 和 `Writer`。然而，“Publicer”这个名字很令人困惑，所以我故意打破了规则。
- en: 'Let''s implement a `Public` method for our `j` type by adding the following
    code to `journeys.go`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `journeys.go` 中添加以下代码来实现我们的 `j` 类型的 `Public` 方法：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The public view of our `j` type joins the `PlaceTypes` field into a single string
    separated by the pipe character as per our API design.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `j` 类型的公共视图将 `PlaceTypes` 字段合并为一个由管道字符分隔的单个字符串，符合我们的 API 设计。
- en: 'Head back to `cmd/meander/main.go` and replace the `respond` method with one
    that makes use of our new `Public` function:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `cmd/meander/main.go` 并将 `respond` 方法替换为使用我们新的 `Public` 函数的方法：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we iterate over the data slice calling the `meander.Public` function
    for each item, building the results into a new slice of the same size. In the
    case of our `j` type, its `Public` method will be called to serve the public view
    of the data rather than the default view. In a terminal, navigate to the `cmd/meander`
    folder again and run `go run main.go` before hitting `http://localhost:8080/journeys`.
    Note that the same data has now changed to a new structure:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遍历数据切片，对每个项目调用 `meander.Public` 函数，将结果构建成一个新的同大小切片。在我们的 `j` 类型中，其 `Public`
    方法将被调用以提供数据的公共视图，而不是默认视图。在终端中，再次导航到 `cmd/meander` 文件夹，并在按下 `http://localhost:8080/journeys`
    之前运行 `go run main.go`。注意，相同的数据现在已更改为新的结构：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An alternative way of achieving the same result would be to use tags to control
    the field names, as we have done in previous chapters, and implement your own
    `[]string` type that provides a `MarshalJSON` method which tells the encoder how
    to marshal your type. Both are perfectly acceptable, but the `Facade` interface
    and `Public` method are probably more expressive (if someone reads the code, isn't
    it obvious what's going on?) and give us more control.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相同结果的一种替代方法是通过使用标签来控制字段名称，就像我们在前面的章节中所做的那样，并实现你自己的 `[]string` 类型，该类型提供了一个
    `MarshalJSON` 方法，告诉编码器如何序列化你的类型。两者都是完全可以接受的，但 `Facade` 接口和 `Public` 方法可能更具表达性（如果有人阅读代码，这不是很明显吗？）并且给我们更多的控制。
