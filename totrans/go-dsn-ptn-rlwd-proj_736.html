<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Generating random recommendations"><div class="book" id="5O1SI2-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec0047" class="calibre1"/>Generating random recommendations</h1></div></div></div><p class="calibre10">In order to obtain the places from which our code will randomly build up recommendations, we need to query the Google Places API. In the root <code class="email">meander</code> folder, add the following <code class="email">query.go</code> file:</p><pre class="programlisting">package meander 
type Place struct { 
  *googleGeometry `json:"geometry"` 
  Name            string         `json:"name"` 
  Icon            string         `json:"icon"` 
  Photos          []*googlePhoto `json:"photos"` 
  Vicinity        string         `json:"vicinity"` 
} 
type googleResponse struct { 
  Results []*Place `json:"results"` 
} 
type googleGeometry struct { 
  *googleLocation `json:"location"` 
} 
type googleLocation struct { 
  Lat float64 `json:"lat"` 
  Lng float64 `json:"lng"` 
} 
type googlePhoto struct { 
  PhotoRef string `json:"photo_reference"` 
  URL      string `json:"url"` 
} 
</pre><p class="calibre10">This code defines the structures we will need in order to parse the JSON response from the Google Places API into usable objects.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip113" class="calibre1"/>Tip</h3><p class="calibre10">Head over to the Google Places API documentation for an example of the response we are expecting. Refer to <a class="calibre1" href="http://developers.google.com/places/documentation/search">http://developers.google.com/places/documentation/search</a>.</p></div><p class="calibre10">Most of the preceding code will be obvious, but it's worth noting that the <code class="email">Place</code> type embeds the <code class="email">googleGeometry</code> type, which allows us to represent the nested data as per the API while essentially flattening it in our code. We do this with <code class="email">googleLocation</code> inside <code class="email">googleGeometry</code>, which means that we will be able to access the <code class="email">Lat</code> and <code class="email">Lng</code> values directly on a <code class="email">Place</code> object even though they're technically nested in other structures.</p><p class="calibre10">Because we want to control how a <code class="email">Place</code> object appears publically, let's give this type the following <code class="email">Public</code> method:</p><pre class="programlisting">func (p *Place) Public() interface{} { 
  return map[string]interface{}{ 
    "name":     p.Name, 
    "icon":     p.Icon, 
    "photos":   p.Photos, 
    "vicinity": p.Vicinity, 
    "lat":      p.Lat, 
    "lng":      p.Lng, 
  } 
} 
</pre><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip114" class="calibre1"/>Tip</h3><p class="calibre10">Remember to run <code class="email">golint</code> on this code to see which comments need to be added to the exported items.</p></div></div></body></html>