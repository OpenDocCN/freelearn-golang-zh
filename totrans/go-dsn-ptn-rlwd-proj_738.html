<html><head></head><body>
<div class="book" title="Generating random recommendations">
<div class="book" title="Enumerators in Go"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec0073" class="calibre1"/>Enumerators in Go</h2></div></div></div><p class="calibre10">To handle the various cost ranges for our API, it makes sense to use an enumerator (or <span class="strong"><strong class="calibre2">enum</strong></span>) to denote the various values and handle conversions to and from string representations. Go doesn't explicitly provide enumerators as a language feature, but there is a neat way of implementing them, which we will explore in this section.</p><p class="calibre10">A simple flexible checklist to write enumerators in Go is as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Define a new type based on a primitive integer type</li><li class="listitem">Use that type whenever you need users to specify one of the appropriate values</li><li class="listitem">Use the <code class="email">iota</code> keyword to set the values in a <code class="email">const</code> block, disregarding the first zero value</li><li class="listitem">Implement a map of sensible string representations to the values of your enumerator</li><li class="listitem">Implement a <code class="email">String</code> method on the type that returns the appropriate string representation from the map</li><li class="listitem">Implement a <code class="email">ParseType</code> function that converts from a string to your type using the map</li></ul></div><p class="calibre10">Now, we will write an enumerator to represent the cost levels in our API. Create a new file called <code class="email">cost_level.go</code> inside the root <code class="email">meander</code> folder and add the following code:</p><pre class="programlisting">package meander 
type Cost int8 
const ( 
  _ Cost = iota 
  Cost1 
  Cost2 
  Cost3 
  Cost4 
  Cost5 
) 
</pre><p class="calibre10">Here, we define the type of our enumerator, which we have called <code class="email">Cost</code>, and since we need to represent a only few values, we have based it on an <code class="email">int8</code> range. For enumerators where we need larger values, you are free to use any of the integer types that work with <code class="email">iota</code>. The <code class="email">Cost</code> type is now a real type in its own right, and we can use it wherever we need to represent one of the supported values for example, we can specify a <code class="email">Cost</code> type as an argument in functions, or we can use it as the type for a field in a struct.</p><p class="calibre10">We then define a list of constants of that type and use the <code class="email">iota</code> keyword to indicate that we want incrementing values for the constants. By disregarding the first <code class="email">iota</code> value (which is always zero), we indicate that one of the specified constants must be explicitly used rather than the zero value.</p><p class="calibre10">To provide a string representation of our enumerator, we only need to add a <code class="email">String</code> method to the <code class="email">Cost</code> type. This is a useful exercise even if you don't need to use the strings in your code, because whenever you use the print calls from the Go standard library (such as <code class="email">fmt.Println</code>), the numerical values will be used by default. Often, these values are meaningless and will require you to look them up and even count the lines to determine the numerical value for each item.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note00115" class="calibre1"/>Note</h3><p class="calibre10">For more information on the <code class="email">String()</code> method in Go, refer to the <code class="email">Stringer</code> and <code class="email">GoStringer</code> interfaces in the <code class="email">fmt</code> package at <a class="calibre1" href="http://golang.org/pkg/fmt/#Stringer">http://golang.org/pkg/fmt/#Stringer</a>.</p></div><div class="book" title="Test-driven enumerator"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec0026" class="calibre1"/>Test-driven enumerator</h3></div></div></div><p class="calibre10">To ensure that our enumerator code is working correctly, we are going to write unit tests that make some assertions about expected behavior.</p><p class="calibre10">Alongside <code class="email">cost_level.go</code>, add a new file called <code class="email">cost_level_test.go</code> and add the following unit test:</p><pre class="programlisting">package meander_test 
import ( 
  "testing" 
  "github.com/cheekybits/is" 
  "path/to/meander" 
) 
func TestCostValues(t *testing.T) { 
  is := is.New(t) 
  is.Equal(int(meander.Cost1), 1) 
  is.Equal(int(meander.Cost2), 2) 
  is.Equal(int(meander.Cost3), 3) 
  is.Equal(int(meander.Cost4), 4) 
  is.Equal(int(meander.Cost5), 5) 
} 
</pre><p class="calibre10">You will need to run <code class="email">go get</code> in order to get the CheekyBitsÂ <code class="email">is</code> package (from <a class="calibre1" href="https://github.com/cheekybits/is">https://github.com/cheekybits/is</a>).</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip116" class="calibre1"/>Tip</h3><p class="calibre10">The <code class="email">is</code> package is an alternative testing helper package, but this one is ultra-simple and deliberately bare-bones. You get to pick your favorite when you write your own projects or use none at all.</p></div><p class="calibre10">Normally, we wouldn't worry about the actual integer value of constants in our enumerator, but since the Google Places API uses numerical values to represent the same thing, we need to care about the values.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note00117" class="calibre1"/>Note</h3><p class="calibre10">You might have noticed something strange about this test file that breaks from convention. Although it is inside the root <code class="email">meander</code> folder, it is not a part of the <code class="email">meander</code> package; rather, it's in <code class="email">meander_test</code>.</p><p class="calibre10">In Go, this is an error in every case except for tests. Because we are putting our test code into its own package, it means that we no longer have access to the internals of the <code class="email">meander</code> package. Note how we have to use the package prefix. This may seem like a disadvantage, but in fact, it allows us to be sure that we are testing the package as though we were a real user of it. We may only call exported methods and only have visibility into exported types; just like our users. And we cannot mess around with internals to do things that our users cannot; it's a true user test. In testing, sometimes you do need to fiddle with an internal state, in which case your tests would need to be in the same package as the code instead.</p></div><p class="calibre10">Run the tests by running <code class="email">go test</code> in a terminal and note that it passes.</p><p class="calibre10">Let's add another test to make assertions about the string representations for each <code class="email">Cost</code> constant. In <code class="email">cost_level_test.go</code>, add the following unit test:</p><pre class="programlisting">func TestCostString(t *testing.T) { 
  is := is.New(t) 
  is.Equal(meander.Cost1.String(), "$") 
  is.Equal(meander.Cost2.String(), "$$") 
  is.Equal(meander.Cost3.String(), "$$$") 
  is.Equal(meander.Cost4.String(), "$$$$") 
  is.Equal(meander.Cost5.String(), "$$$$$") 
} 
</pre><p class="calibre10">This test asserts that calling the <code class="email">String</code> method for each constant yields the expected value. Running these tests will, of course, fail because we haven't implemented the <code class="email">String</code> method yet.</p><p class="calibre10">Underneath the <code class="email">Cost</code> constants, add the following map and the <code class="email">String</code> method:</p><pre class="programlisting">var costStrings = map[string]Cost{ 
  "$":     Cost1, 
  "$$":    Cost2, 
  "$$$":   Cost3, 
  "$$$$":  Cost4, 
  "$$$$$": Cost5, 
} 
func (l Cost) String() string { 
  for s, v := range costStrings { 
    if l == v { 
      return s 
    } 
  } 
  return "invalid" 
} 
</pre><p class="calibre10">The <code class="email">map[string]Cost</code> variable maps the cost values to the string representation, and the <code class="email">String</code> method iterates over the map to return the appropriate value.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip118" class="calibre1"/>Tip</h3><p class="calibre10">In our case, a simple <code class="email">strings.Repeat("$", int(l))</code> return would work just as well (and wins because it's simpler code); but it often won't; therefore, this section explores the general approach.</p></div><p class="calibre10">Now if we were to print out the <code class="email">Cost3</code> value, we would actually see <code class="email">$$$</code>, which is much more useful than numerical values. As we want to use these strings in our API, we are also going to add a <code class="email">ParseCost</code> method.</p><p class="calibre10">In <code class="email">cost_value_test.go</code>, add the following unit test:</p><pre class="programlisting">func TestParseCost(t *testing.T) { 
  is := is.New(t) 
  is.Equal(meander.Cost1, meander.ParseCost("$")) 
  is.Equal(meander.Cost2, meander.ParseCost("$$")) 
  is.Equal(meander.Cost3, meander.ParseCost("$$$")) 
  is.Equal(meander.Cost4, meander.ParseCost("$$$$")) 
  is.Equal(meander.Cost5, meander.ParseCost("$$$$$")) 
} 
</pre><p class="calibre10">Here, we assert that calling <code class="email">ParseCost</code> will, in fact, yield the appropriate value depending on the input string.</p><p class="calibre10">In <code class="email">cost_value.go</code>, add the following implementation code:</p><pre class="programlisting">func ParseCost(s string) Cost { 
  return costStrings[s] 
} 
</pre><p class="calibre10">Parsing a <code class="email">Cost</code> string is very simple since this is how our map is laid out.</p><p class="calibre10">As we need to represent a range of cost values, let's imagine a <code class="email">CostRange</code> type and write the tests out for how we intend to use it. Add the following tests to <code class="email">cost_value_test.go</code>:</p><pre class="programlisting">func TestParseCostRange(t *testing.T) { 
  is := is.New(t) 
  var l meander.CostRange 
  var err error 
  l, err = meander.ParseCostRange("$$...$$$") 
  is.NoErr(err) 
  is.Equal(l.From, meander.Cost2) 
  is.Equal(l.To, meander.Cost3) 
  l, err = meander.ParseCostRange("$...$$$$$") 
  is.NoErr(err) 
  is.Equal(l.From, meander.Cost1) 
  is.Equal(l.To, meander.Cost5) 
} 
func TestCostRangeString(t *testing.T) { 
  is := is.New(t) 
  r := meander.CostRange{ 
    From: meander.Cost2, 
    To:   meander.Cost4, 
  } 
  is.Equal("$$...$$$$", r.String()) 
} 
</pre><p class="calibre10">We specify that passing in a string with two dollar characters first, followed by three dots and then three dollar characters should create a new <code class="email">meander.CostRange</code> type that has <code class="email">From</code> set to <code class="email">meander.Cost2</code> and <code class="email">To</code> set to <code class="email">meander.Cost3</code>. We also use <code class="email">is.NoErr</code> in order to assert that no error is returned when we parse our strings. The second test does the reverse by testing that the <code class="email">CostRange.String</code> method, which returns the appropriate value.</p><p class="calibre10">To make our tests pass, add the following <code class="email">CostRange</code> type and the associated <code class="email">String</code> and <code class="email">ParseString</code> functions:</p><pre class="programlisting">type CostRange struct { 
  From Cost 
  To   Cost 
} 
func (r CostRange) String() string { 
  return r.From.String() + "..." + r.To.String() 
} 
func ParseCostRange(s string) (CostRange, error) { 
  var r CostRange 
  segs := strings.Split(s, "...") 
  if len(segs) != 2 { 
    return r, errors.New("invalid cost range") 
  } 
  r.From = ParseCost(segs[0]) 
  r.To = ParseCost(segs[1]) 
  return r, nil 
} 
</pre><p class="calibre10">This allows us to convert a string such as <code class="email">$...$$$$$</code> to a structure that contains two <code class="email">Cost</code> values: a <code class="email">From</code> and <code class="email">To</code> set and vice versa. If somebody passes in an invalid cost range (we just perform a simple check on the number of segments after splitting on the dots), then we return an error. You can do additional checking here if you want to, such as ensuring only dots and dollar signs are mentioned in the strings.</p></div></div></div></body></html>