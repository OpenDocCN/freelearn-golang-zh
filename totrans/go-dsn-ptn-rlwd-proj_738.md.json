["```go\npackage meander \ntype Cost int8 \nconst ( \n  _ Cost = iota \n  Cost1 \n  Cost2 \n  Cost3 \n  Cost4 \n  Cost5 \n) \n\n```", "```go\npackage meander_test \nimport ( \n  \"testing\" \n  \"github.com/cheekybits/is\" \n  \"path/to/meander\" \n) \nfunc TestCostValues(t *testing.T) { \n  is := is.New(t) \n  is.Equal(int(meander.Cost1), 1) \n  is.Equal(int(meander.Cost2), 2) \n  is.Equal(int(meander.Cost3), 3) \n  is.Equal(int(meander.Cost4), 4) \n  is.Equal(int(meander.Cost5), 5) \n} \n\n```", "```go\nfunc TestCostString(t *testing.T) { \n  is := is.New(t) \n  is.Equal(meander.Cost1.String(), \"$\") \n  is.Equal(meander.Cost2.String(), \"$$\") \n  is.Equal(meander.Cost3.String(), \"$$$\") \n  is.Equal(meander.Cost4.String(), \"$$$$\") \n  is.Equal(meander.Cost5.String(), \"$$$$$\") \n} \n\n```", "```go\nvar costStrings = map[string]Cost{ \n  \"$\":     Cost1, \n  \"$$\":    Cost2, \n  \"$$$\":   Cost3, \n  \"$$$$\":  Cost4, \n  \"$$$$$\": Cost5, \n} \nfunc (l Cost) String() string { \n  for s, v := range costStrings { \n    if l == v { \n      return s \n    } \n  } \n  return \"invalid\" \n} \n\n```", "```go\nfunc TestParseCost(t *testing.T) { \n  is := is.New(t) \n  is.Equal(meander.Cost1, meander.ParseCost(\"$\")) \n  is.Equal(meander.Cost2, meander.ParseCost(\"$$\")) \n  is.Equal(meander.Cost3, meander.ParseCost(\"$$$\")) \n  is.Equal(meander.Cost4, meander.ParseCost(\"$$$$\")) \n  is.Equal(meander.Cost5, meander.ParseCost(\"$$$$$\")) \n} \n\n```", "```go\nfunc ParseCost(s string) Cost { \n  return costStrings[s] \n} \n\n```", "```go\nfunc TestParseCostRange(t *testing.T) { \n  is := is.New(t) \n  var l meander.CostRange \n  var err error \n  l, err = meander.ParseCostRange(\"$$...$$$\") \n  is.NoErr(err) \n  is.Equal(l.From, meander.Cost2) \n  is.Equal(l.To, meander.Cost3) \n  l, err = meander.ParseCostRange(\"$...$$$$$\") \n  is.NoErr(err) \n  is.Equal(l.From, meander.Cost1) \n  is.Equal(l.To, meander.Cost5) \n} \nfunc TestCostRangeString(t *testing.T) { \n  is := is.New(t) \n  r := meander.CostRange{ \n    From: meander.Cost2, \n    To:   meander.Cost4, \n  } \n  is.Equal(\"$$...$$$$\", r.String()) \n} \n\n```", "```go\ntype CostRange struct { \n  From Cost \n  To   Cost \n} \nfunc (r CostRange) String() string { \n  return r.From.String() + \"...\" + r.To.String() \n} \nfunc ParseCostRange(s string) (CostRange, error) { \n  var r CostRange \n  segs := strings.Split(s, \"...\") \n  if len(segs) != 2 { \n    return r, errors.New(\"invalid cost range\") \n  } \n  r.From = ParseCost(segs[0]) \n  r.To = ParseCost(segs[1]) \n  return r, nil \n} \n\n```"]