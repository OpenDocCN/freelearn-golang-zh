- en: Enumerators in Go
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 中的枚举器
- en: To handle the various cost ranges for our API, it makes sense to use an enumerator
    (or **enum**) to denote the various values and handle conversions to and from
    string representations. Go doesn't explicitly provide enumerators as a language
    feature, but there is a neat way of implementing them, which we will explore in
    this section.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理我们 API 中的各种成本范围，使用枚举器（或 **enum**）来表示各种值并处理字符串表示的转换是有意义的。Go 语言没有明确提供枚举器作为语言特性，但有一个巧妙的方法来实现它们，我们将在本节中探讨。
- en: 'A simple flexible checklist to write enumerators in Go is as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中编写枚举器的简单灵活清单如下：
- en: Define a new type based on a primitive integer type
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于原始整数类型定义一个新的类型
- en: Use that type whenever you need users to specify one of the appropriate values
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要用户指定适当的值时使用该类型
- en: Use the `iota` keyword to set the values in a `const` block, disregarding the
    first zero value
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `iota` 关键字在 `const` 块中设置值，忽略第一个零值
- en: Implement a map of sensible string representations to the values of your enumerator
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的枚举器的值实现一个合理的字符串表示映射
- en: Implement a `String` method on the type that returns the appropriate string
    representation from the map
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类型上实现一个 `String` 方法，从映射中返回适当的字符串表示
- en: Implement a `ParseType` function that converts from a string to your type using
    the map
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个 `ParseType` 函数，使用映射将字符串转换为你的类型
- en: 'Now, we will write an enumerator to represent the cost levels in our API. Create
    a new file called `cost_level.go` inside the root `meander` folder and add the
    following code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个枚举器来表示我们的 API 中的成本级别。在根目录 `meander` 中创建一个名为 `cost_level.go` 的新文件，并添加以下代码：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we define the type of our enumerator, which we have called `Cost`, and
    since we need to represent a only few values, we have based it on an `int8` range.
    For enumerators where we need larger values, you are free to use any of the integer
    types that work with `iota`. The `Cost` type is now a real type in its own right,
    and we can use it wherever we need to represent one of the supported values for
    example, we can specify a `Cost` type as an argument in functions, or we can use
    it as the type for a field in a struct.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了枚举器的类型，我们称之为 `Cost`，由于我们只需要表示几个值，所以我们基于 `int8` 范围。对于需要更大值的枚举器，你可以自由地使用任何与
    `iota` 一起工作的整数类型。`Cost` 类型现在是一个真正的类型，我们可以在需要表示支持的值的地方使用它，例如，我们可以将 `Cost` 类型指定为函数的参数，或者我们可以将其用作结构体字段的类型。
- en: We then define a list of constants of that type and use the `iota` keyword to
    indicate that we want incrementing values for the constants. By disregarding the
    first `iota` value (which is always zero), we indicate that one of the specified
    constants must be explicitly used rather than the zero value.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义该类型的一组常量，并使用 `iota` 关键字来表示我们想要常量的递增值。通过忽略第一个 `iota` 值（它总是零），我们表示必须显式使用指定的常量而不是零值。
- en: To provide a string representation of our enumerator, we only need to add a
    `String` method to the `Cost` type. This is a useful exercise even if you don't
    need to use the strings in your code, because whenever you use the print calls
    from the Go standard library (such as `fmt.Println`), the numerical values will
    be used by default. Often, these values are meaningless and will require you to
    look them up and even count the lines to determine the numerical value for each
    item.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供我们枚举器的字符串表示，我们只需要为 `Cost` 类型添加一个 `String` 方法。即使你不需要在代码中使用这些字符串，这也是一个有用的练习，因为每次你使用
    Go 标准库中的打印调用（如 `fmt.Println`）时，默认情况下将使用数值。通常，这些值没有意义，你需要查找它们，甚至数行来确定每个项目的数值。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the `String()` method in Go, refer to the `Stringer`
    and `GoStringer` interfaces in the `fmt` package at [http://golang.org/pkg/fmt/#Stringer](http://golang.org/pkg/fmt/#Stringer).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Go 中 `String()` 方法的详细信息，请参阅 `fmt` 包中的 `Stringer` 和 `GoStringer` 接口，网址为
    [http://golang.org/pkg/fmt/#Stringer](http://golang.org/pkg/fmt/#Stringer)。
- en: Test-driven enumerator
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试驱动的枚举器
- en: To ensure that our enumerator code is working correctly, we are going to write
    unit tests that make some assertions about expected behavior.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的枚举器代码正常工作，我们将编写单元测试来对预期的行为进行断言。
- en: 'Alongside `cost_level.go`, add a new file called `cost_level_test.go` and add
    the following unit test:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `cost_level.go` 旁边添加一个名为 `cost_level_test.go` 的新文件，并添加以下单元测试：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You will need to run `go get` in order to get the CheekyBits `is` package (from
    [https://github.com/cheekybits/is](https://github.com/cheekybits/is)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要运行 `go get` 命令来获取 CheekyBits 的 `is` 包（来自 [https://github.com/cheekybits/is](https://github.com/cheekybits/is)）。
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `is` package is an alternative testing helper package, but this one is ultra-simple
    and deliberately bare-bones. You get to pick your favorite when you write your
    own projects or use none at all.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`is` 包是一个可选的测试辅助包，但这个包非常简单，故意保持基础。当你编写自己的项目或完全不用时，你可以选择你喜欢的。'
- en: Normally, we wouldn't worry about the actual integer value of constants in our
    enumerator, but since the Google Places API uses numerical values to represent
    the same thing, we need to care about the values.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不会担心枚举器中常量的实际整数值，但鉴于 Google Places API 使用数值来表示相同的内容，我们需要关注这些值。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might have noticed something strange about this test file that breaks from
    convention. Although it is inside the root `meander` folder, it is not a part
    of the `meander` package; rather, it's in `meander_test`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到这个测试文件有些奇怪，它打破了常规。尽管它位于根目录 `meander` 文件夹内，但它不是 `meander` 包的一部分；相反，它在
    `meander_test` 中。
- en: In Go, this is an error in every case except for tests. Because we are putting
    our test code into its own package, it means that we no longer have access to
    the internals of the `meander` package. Note how we have to use the package prefix.
    This may seem like a disadvantage, but in fact, it allows us to be sure that we
    are testing the package as though we were a real user of it. We may only call
    exported methods and only have visibility into exported types; just like our users.
    And we cannot mess around with internals to do things that our users cannot; it's
    a true user test. In testing, sometimes you do need to fiddle with an internal
    state, in which case your tests would need to be in the same package as the code
    instead.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，这除了测试之外都是一种错误。因为我们把测试代码放入了自己的包中，这意味着我们不再能够访问 `meander` 包的内部。注意我们如何使用包前缀。这看起来可能像是一个缺点，但实际上，它允许我们确信我们正在像真实用户一样测试这个包。我们只能调用导出方法，并且只能看到导出类型；就像我们的用户一样。我们无法对内部进行操作来做用户无法做的事情；这是一个真正的用户测试。在测试中，有时你需要调整内部状态，在这种情况下，你的测试需要与代码在同一个包中。
- en: Run the tests by running `go test` in a terminal and note that it passes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在终端中运行 `go test` 来运行测试，并注意它通过了。
- en: 'Let''s add another test to make assertions about the string representations
    for each `Cost` constant. In `cost_level_test.go`, add the following unit test:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加另一个测试来断言每个 `Cost` 常量的字符串表示形式。在 `cost_level_test.go` 文件中，添加以下单元测试：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This test asserts that calling the `String` method for each constant yields
    the expected value. Running these tests will, of course, fail because we haven't
    implemented the `String` method yet.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试断言对每个常量调用 `String` 方法会得到预期的值。当然，运行这些测试会失败，因为我们还没有实现 `String` 方法。
- en: 'Underneath the `Cost` constants, add the following map and the `String` method:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Cost` 常量下方，添加以下映射和 `String` 方法：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `map[string]Cost` variable maps the cost values to the string representation,
    and the `String` method iterates over the map to return the appropriate value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`map[string]Cost` 变量将成本值映射到字符串表示形式，而 `String` 方法遍历映射以返回适当的值。'
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In our case, a simple `strings.Repeat("$", int(l))` return would work just as
    well (and wins because it's simpler code); but it often won't; therefore, this
    section explores the general approach.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，一个简单的 `strings.Repeat("$", int(l))` 返回值就能起到同样的作用（并且因为代码更简单而获胜）；但通常不会这样；因此，本节探讨了通用方法。
- en: Now if we were to print out the `Cost3` value, we would actually see `$$$`,
    which is much more useful than numerical values. As we want to use these strings
    in our API, we are also going to add a `ParseCost` method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们打印出 `Cost3` 的值，实际上会看到 `$$$`，这比数值更有用。因为我们想在我们的 API 中使用这些字符串，我们也将添加一个 `ParseCost`
    方法。
- en: 'In `cost_value_test.go`, add the following unit test:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `cost_value_test.go` 文件中，添加以下单元测试：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we assert that calling `ParseCost` will, in fact, yield the appropriate
    value depending on the input string.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们断言调用 `ParseCost` 将根据输入字符串产生适当的值。
- en: 'In `cost_value.go`, add the following implementation code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `cost_value.go` 文件中，添加以下实现代码：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Parsing a `Cost` string is very simple since this is how our map is laid out.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 解析 `Cost` 字符串非常简单，因为我们的映射就是这样布局的。
- en: 'As we need to represent a range of cost values, let''s imagine a `CostRange`
    type and write the tests out for how we intend to use it. Add the following tests
    to `cost_value_test.go`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要表示一系列的成本值，让我们想象一个`CostRange`类型，并编写我们打算如何使用它的测试。将以下测试添加到`cost_value_test.go`中：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We specify that passing in a string with two dollar characters first, followed
    by three dots and then three dollar characters should create a new `meander.CostRange`
    type that has `From` set to `meander.Cost2` and `To` set to `meander.Cost3`. We
    also use `is.NoErr` in order to assert that no error is returned when we parse
    our strings. The second test does the reverse by testing that the `CostRange.String`
    method, which returns the appropriate value.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定，首先传入一个包含两个美元符号的字符串，然后是三个点，最后是三个美元符号，这将创建一个新的`meander.CostRange`类型，其中`From`设置为`meander.Cost2`，`To`设置为`meander.Cost3`。我们还使用`is.NoErr`来断言在解析我们的字符串时不会返回错误。第二个测试通过测试`CostRange.String`方法来执行相反的操作，该方法返回适当的值。
- en: 'To make our tests pass, add the following `CostRange` type and the associated
    `String` and `ParseString` functions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试通过，添加以下`CostRange`类型以及相关的`String`和`ParseString`函数：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This allows us to convert a string such as `$...$$$$$` to a structure that
    contains two `Cost` values: a `From` and `To` set and vice versa. If somebody
    passes in an invalid cost range (we just perform a simple check on the number
    of segments after splitting on the dots), then we return an error. You can do
    additional checking here if you want to, such as ensuring only dots and dollar
    signs are mentioned in the strings.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们将类似于`$...$$$$$`的字符串转换为包含两个`Cost`值的结构：一个`From`和一个`To`，反之亦然。如果有人传入无效的成本范围（我们只是在点分割后的段数上执行简单的检查），则返回错误。如果您想进行额外的检查，例如确保字符串中只提到点和美元符号，您也可以在这里进行。
