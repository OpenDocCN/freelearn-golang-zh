- en: Enumerators in Go
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To handle the various cost ranges for our API, it makes sense to use an enumerator
    (or **enum**) to denote the various values and handle conversions to and from
    string representations. Go doesn't explicitly provide enumerators as a language
    feature, but there is a neat way of implementing them, which we will explore in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple flexible checklist to write enumerators in Go is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a new type based on a primitive integer type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use that type whenever you need users to specify one of the appropriate values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `iota` keyword to set the values in a `const` block, disregarding the
    first zero value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a map of sensible string representations to the values of your enumerator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a `String` method on the type that returns the appropriate string
    representation from the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a `ParseType` function that converts from a string to your type using
    the map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will write an enumerator to represent the cost levels in our API. Create
    a new file called `cost_level.go` inside the root `meander` folder and add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define the type of our enumerator, which we have called `Cost`, and
    since we need to represent a only few values, we have based it on an `int8` range.
    For enumerators where we need larger values, you are free to use any of the integer
    types that work with `iota`. The `Cost` type is now a real type in its own right,
    and we can use it wherever we need to represent one of the supported values for
    example, we can specify a `Cost` type as an argument in functions, or we can use
    it as the type for a field in a struct.
  prefs: []
  type: TYPE_NORMAL
- en: We then define a list of constants of that type and use the `iota` keyword to
    indicate that we want incrementing values for the constants. By disregarding the
    first `iota` value (which is always zero), we indicate that one of the specified
    constants must be explicitly used rather than the zero value.
  prefs: []
  type: TYPE_NORMAL
- en: To provide a string representation of our enumerator, we only need to add a
    `String` method to the `Cost` type. This is a useful exercise even if you don't
    need to use the strings in your code, because whenever you use the print calls
    from the Go standard library (such as `fmt.Println`), the numerical values will
    be used by default. Often, these values are meaningless and will require you to
    look them up and even count the lines to determine the numerical value for each
    item.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the `String()` method in Go, refer to the `Stringer`
    and `GoStringer` interfaces in the `fmt` package at [http://golang.org/pkg/fmt/#Stringer](http://golang.org/pkg/fmt/#Stringer).
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven enumerator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To ensure that our enumerator code is working correctly, we are going to write
    unit tests that make some assertions about expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alongside `cost_level.go`, add a new file called `cost_level_test.go` and add
    the following unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You will need to run `go get` in order to get the CheekyBitsÂ `is` package (from
    [https://github.com/cheekybits/is](https://github.com/cheekybits/is)).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `is` package is an alternative testing helper package, but this one is ultra-simple
    and deliberately bare-bones. You get to pick your favorite when you write your
    own projects or use none at all.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, we wouldn't worry about the actual integer value of constants in our
    enumerator, but since the Google Places API uses numerical values to represent
    the same thing, we need to care about the values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed something strange about this test file that breaks from
    convention. Although it is inside the root `meander` folder, it is not a part
    of the `meander` package; rather, it's in `meander_test`.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, this is an error in every case except for tests. Because we are putting
    our test code into its own package, it means that we no longer have access to
    the internals of the `meander` package. Note how we have to use the package prefix.
    This may seem like a disadvantage, but in fact, it allows us to be sure that we
    are testing the package as though we were a real user of it. We may only call
    exported methods and only have visibility into exported types; just like our users.
    And we cannot mess around with internals to do things that our users cannot; it's
    a true user test. In testing, sometimes you do need to fiddle with an internal
    state, in which case your tests would need to be in the same package as the code
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests by running `go test` in a terminal and note that it passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another test to make assertions about the string representations
    for each `Cost` constant. In `cost_level_test.go`, add the following unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This test asserts that calling the `String` method for each constant yields
    the expected value. Running these tests will, of course, fail because we haven't
    implemented the `String` method yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Underneath the `Cost` constants, add the following map and the `String` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `map[string]Cost` variable maps the cost values to the string representation,
    and the `String` method iterates over the map to return the appropriate value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our case, a simple `strings.Repeat("$", int(l))` return would work just as
    well (and wins because it's simpler code); but it often won't; therefore, this
    section explores the general approach.
  prefs: []
  type: TYPE_NORMAL
- en: Now if we were to print out the `Cost3` value, we would actually see `$$$`,
    which is much more useful than numerical values. As we want to use these strings
    in our API, we are also going to add a `ParseCost` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `cost_value_test.go`, add the following unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we assert that calling `ParseCost` will, in fact, yield the appropriate
    value depending on the input string.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `cost_value.go`, add the following implementation code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Parsing a `Cost` string is very simple since this is how our map is laid out.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we need to represent a range of cost values, let''s imagine a `CostRange`
    type and write the tests out for how we intend to use it. Add the following tests
    to `cost_value_test.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We specify that passing in a string with two dollar characters first, followed
    by three dots and then three dollar characters should create a new `meander.CostRange`
    type that has `From` set to `meander.Cost2` and `To` set to `meander.Cost3`. We
    also use `is.NoErr` in order to assert that no error is returned when we parse
    our strings. The second test does the reverse by testing that the `CostRange.String`
    method, which returns the appropriate value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our tests pass, add the following `CostRange` type and the associated
    `String` and `ParseString` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to convert a string such as `$...$$$$$` to a structure that
    contains two `Cost` values: a `From` and `To` set and vice versa. If somebody
    passes in an invalid cost range (we just perform a simple check on the number
    of segments after splitting on the dots), then we return an error. You can do
    additional checking here if you want to, such as ensuring only dots and dollar
    signs are mentioned in the strings.'
  prefs: []
  type: TYPE_NORMAL
