<html><head></head><body>
<div class="book" title="Generating random recommendations">
<div class="book" title="Querying the Google Places API"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec0074" class="calibre1"/>Querying the Google Places API</h2></div></div></div><p class="calibre10">Now that we are capable of representing the results of the API, we need a way to represent and initiate the actual query. Add the following structure to <code class="email">query.go</code>:</p><pre class="programlisting">type Query struct { 
  Lat          float64 
  Lng          float64 
  Journey      []string 
  Radius       int 
  CostRangeStr string 
} 
</pre><p class="calibre10">This structure contains all the information we will need in order to build up the query, all of which will actually come from the URL parameters in the requests from the client. Next, add the following <code class="email">find</code> method, which will be responsible for making the actual request to Google's servers:</p><pre class="programlisting">func (q *Query) find(types string) (*googleResponse, error) { 
  u :=  "https://maps.googleapis.com/maps/api/place/nearbysearch/json" 
  vals := make(url.Values) 
  vals.Set("location", fmt.Sprintf("%g,%g", q.Lat, q.Lng)) 
  vals.Set("radius", fmt.Sprintf("%d", q.Radius)) 
  vals.Set("types", types) 
  vals.Set("key", APIKey) 
  if len(q.CostRangeStr) &gt; 0 { 
    r, err := ParseCostRange(q.CostRangeStr) 
    if err != nil { 
      return nil, err 
    } 
    vals.Set("minprice", fmt.Sprintf("%d", int(r.From)-1)) 
    vals.Set("maxprice", fmt.Sprintf("%d", int(r.To)-1)) 
  } 
  res, err := http.Get(u + "?" + vals.Encode()) 
  if err != nil { 
    return nil, err 
  } 
  defer res.Body.Close() 
  var response googleResponse 
  if err := json.NewDecoder(res.Body).Decode(&amp;response); err != nil { 
    return nil, err 
  } 
  return &amp;response, nil 
} 
</pre><p class="calibre10">First, we build the request URL as per the Google Places API specification by appending the <code class="email">url.Values</code> encoded string of the data for <code class="email">lat</code>, <code class="email">lng</code>, <code class="email">radius</code>, and, of course, the <code class="email">APIKey</code> values.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note00119" class="calibre1"/>Note</h3><p class="calibre10">The <code class="email">url.Values</code> type is actually a <code class="email">map[string][]string</code> type, which is why we use <code class="email">make</code> rather than <code class="email">new</code>.</p></div><p class="calibre10">The <code class="email">types</code> value we specify as an argument represents the kind of business to look for. If there is <code class="email">CostRangeStr</code>, we parse it and set the <code class="email">minprice</code> and <code class="email">maxprice</code> values before finally calling <code class="email">http.Get</code> to actually make the request. If the request is successful, we defer the closing of the response body and use a <code class="email">json.Decoder</code> method to decode the JSON that comes back from the API into our <code class="email">googleResponse</code> type.</p></div></div></body></html>