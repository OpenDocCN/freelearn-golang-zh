<html><head></head><body>
<div class="book" title="Generating random recommendations">
<div class="book" title="Building recommendations"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch07lvl2sec0075" class="calibre1"/>Building recommendations</h2></div></div></div><p class="calibre10">Next, we need to write a method that will allow us to make many calls to find for the different steps in a journey. Underneath the <code class="email">find</code> method, add the following <code class="email">Run</code> method to the <code class="email">Query</code> struct:</p><pre class="programlisting">// Run runs the query concurrently, and returns the results. 
func (q *Query) Run() []interface{} { 
  rand.Seed(time.Now().UnixNano()) 
  var w sync.WaitGroup 
  var l sync.Mutex 
  places := make([]interface{}, len(q.Journey)) 
  for i, r := range q.Journey { 
    w.Add(1) 
    go func(types string, i int) { 
      defer w.Done() 
      response, err := q.find(types) 
      if err != nil { 
        log.Println("Failed to find places:", err) 
        return 
      } 
      if len(response.Results) == 0 { 
        log.Println("No places found for", types) 
        return 
      } 
      for _, result := range response.Results { 
        for _, photo := range result.Photos { 
          photo.URL =    
            "https://maps.googleapis.com/maps/api/place/photo?" + 
            "maxwidth=1000&amp;photoreference=" + photo.PhotoRef + "&amp;key=" 
             + APIKey 
        } 
      } 
      randI := rand.Intn(len(response.Results)) 
      l.Lock() 
      places[i] = response.Results[randI] 
      l.Unlock() 
    }(r, i) 
  } 
  w.Wait() // wait for everything to finish 
  return places 
} 
</pre><p class="calibre10">The first thing we do is set the random seed to the current time in nanoseconds since January 1, 1970 UTC. This ensures that every time we call the <code class="email">Run</code> method and use the <code class="email">rand</code> package, the results will be different. If we don't do this, our code would suggest the same recommendations every time, which defeats the object.</p><p class="calibre10">Since we need to make many requests to Google and since we want to make sure this is as quick as possible we are going to run all the queries at the same time by making concurrent calls to our <code class="email">Query.find</code> method. So next, we create <code class="email">sync.WaitGroup</code> and a map to hold the selected places along with a <code class="email">sync.Mutex</code> method to allow many goroutines to safely access the map concurrently.</p><p class="calibre10">We then iterate over each item in the <code class="email">Journey</code> slice, which might be <code class="email">bar</code>, <code class="email">cafe</code>, or <code class="email">movie_theater</code>. For each item, we add <code class="email">1</code> to the <code class="email">WaitGroup</code> object and start a goroutine. Inside the routine, we first defer the <code class="email">w.Done</code> call, informing the <code class="email">WaitGroup</code> object that this request has completed before calling our <code class="email">find</code> method to make the actual request. Assuming no errors occurred and it was indeed able to find some places, we iterate over the results and build up a usable URL for any photos that might be present. According to the Google Places API, we are given a <code class="email">photoreference</code> key, which we can use in another API call to get the actual image. To save our clients from having to have knowledge of the Google Places API at all, we build the complete URL for them.</p><p class="calibre10">We then lock the map locker and with a call to <code class="email">rand.Intn</code>, pick one of the options at random and insert it into the right position in the <code class="email">places</code> slice before unlocking <code class="email">sync.Mutex</code>.</p><p class="calibre10">Finally, we wait for all goroutines to complete with a call to <code class="email">w.Wait</code> before returning the places.</p></div></div></body></html>