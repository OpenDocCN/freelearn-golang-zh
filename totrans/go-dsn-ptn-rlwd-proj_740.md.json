["```go\n// Run runs the query concurrently, and returns the results. \nfunc (q *Query) Run() []interface{} { \n  rand.Seed(time.Now().UnixNano()) \n  var w sync.WaitGroup \n  var l sync.Mutex \n  places := make([]interface{}, len(q.Journey)) \n  for i, r := range q.Journey { \n    w.Add(1) \n    go func(types string, i int) { \n      defer w.Done() \n      response, err := q.find(types) \n      if err != nil { \n        log.Println(\"Failed to find places:\", err) \n        return \n      } \n      if len(response.Results) == 0 { \n        log.Println(\"No places found for\", types) \n        return \n      } \n      for _, result := range response.Results { \n        for _, photo := range result.Photos { \n          photo.URL =    \n            \"https://maps.googleapis.com/maps/api/place/photo?\" + \n            \"maxwidth=1000&photoreference=\" + photo.PhotoRef + \"&key=\" \n             + APIKey \n        } \n      } \n      randI := rand.Intn(len(response.Results)) \n      l.Lock() \n      places[i] = response.Results[randI] \n      l.Unlock() \n    }(r, i) \n  } \n  w.Wait() // wait for everything to finish \n  return places \n} \n\n```"]