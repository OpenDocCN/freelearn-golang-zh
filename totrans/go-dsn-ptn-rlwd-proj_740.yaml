- en: Building recommendations
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建推荐
- en: 'Next, we need to write a method that will allow us to make many calls to find
    for the different steps in a journey. Underneath the `find` method, add the following
    `Run` method to the `Query` struct:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写一个方法，使我们能够对旅程中的不同步骤进行多次调用。在`find`方法下面，向`Query`结构体添加以下`Run`方法：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first thing we do is set the random seed to the current time in nanoseconds
    since January 1, 1970 UTC. This ensures that every time we call the `Run` method
    and use the `rand` package, the results will be different. If we don't do this,
    our code would suggest the same recommendations every time, which defeats the
    object.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是将随机种子设置为自1970年1月1日UTC以来的当前纳秒时间。这确保了每次我们调用`Run`方法并使用`rand`包时，结果都会不同。如果我们不这样做，我们的代码每次都会提出相同的建议，这违背了我们的初衷。
- en: Since we need to make many requests to Google and since we want to make sure
    this is as quick as possible we are going to run all the queries at the same time
    by making concurrent calls to our `Query.find` method. So next, we create `sync.WaitGroup` and
    a map to hold the selected places along with a `sync.Mutex` method to allow many
    goroutines to safely access the map concurrently.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要向谷歌发送许多请求，并且我们希望确保这尽可能快，我们将通过并发调用我们的`Query.find`方法来同时运行所有查询。因此，接下来，我们创建`sync.WaitGroup`和一个映射来保存选定的地点，以及一个`sync.Mutex`方法，以允许许多goroutine安全地并发访问映射。
- en: We then iterate over each item in the `Journey` slice, which might be `bar`,
    `cafe`, or `movie_theater`. For each item, we add `1` to the `WaitGroup` object
    and start a goroutine. Inside the routine, we first defer the `w.Done` call, informing
    the `WaitGroup` object that this request has completed before calling our `find`
    method to make the actual request. Assuming no errors occurred and it was indeed
    able to find some places, we iterate over the results and build up a usable URL
    for any photos that might be present. According to the Google Places API, we are
    given a `photoreference` key, which we can use in another API call to get the
    actual image. To save our clients from having to have knowledge of the Google
    Places API at all, we build the complete URL for them.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历`Journey`切片中的每个项目，该项目可能是`bar`、`cafe`或`movie_theater`。对于每个项目，我们向`WaitGroup`对象添加`1`并启动一个goroutine。在例程内部，我们首先调用`defer
    w.Done`，通知`WaitGroup`对象在调用我们的`find`方法进行实际请求之前，这个请求已经完成。假设没有错误发生，并且确实找到了一些地点，我们遍历结果并为可能存在的任何照片构建一个可用的URL。根据谷歌地点API，我们得到了一个`photoreference`键，我们可以使用它来在另一个API调用中获取实际图像。为了使我们的客户不必了解谷歌地点API，我们为他们构建完整的URL。
- en: We then lock the map locker and with a call to `rand.Intn`, pick one of the
    options at random and insert it into the right position in the `places` slice
    before unlocking `sync.Mutex`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们锁定映射锁，通过调用`rand.Intn`随机选择一个选项，并在解锁`sync.Mutex`之前将其插入到`places`切片的正确位置。
- en: Finally, we wait for all goroutines to complete with a call to `w.Wait` before
    returning the places.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在返回地点之前，通过调用`w.Wait`等待所有goroutine完成。
