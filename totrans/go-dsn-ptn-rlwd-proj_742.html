<html><head></head><body>
<div class="book" title="Generating random recommendations">
<div class="book" title="CORS"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch07lvl2sec0077" class="calibre1"/>CORS</h2></div></div></div><p class="calibre10">The final piece of the first version of our API will be to implement CORS, as we did in the previous chapter. See if you can solve this problem yourself before reading on about the solution in the next section.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip120" class="calibre1"/>Tip</h3><p class="calibre10">If you are going to tackle this yourself, remember that your aim is to set the <code class="email">Access-Control-Allow-Origin</code> response header to <code class="email">*</code>. Also, consider the <code class="email">http.HandlerFunc</code> wrapping we did in the previous chapter. The best place for this code is probably in the <code class="email">cmd/meander</code>Â program, since that is what exposes the functionality through an HTTP endpoint.</p></div><p class="calibre10">In <code class="email">main.go</code>, add the following <code class="email">cors</code> function:</p><pre class="programlisting">func cors(f http.HandlerFunc) http.HandlerFunc { 
  return func(w http.ResponseWriter, r *http.Request) { 
    w.Header().Set("Access-Control-Allow-Origin", "*") 
    f(w, r) 
  } 
} 
</pre><p class="calibre10">This familiar pattern takes in an <code class="email">http.HandlerFunc</code> type and returns a new one that sets the appropriate header before calling the passed-in function. Now, we can modify our code to make sure that the <code class="email">cors</code> function gets called for both of our endpoints. Update the appropriate lines in the <code class="email">main</code> function:</p><pre class="programlisting">func main() { 
  meander.APIKey = "YOUR_API_KEY" 
  http.HandleFunc("/journeys", cors(func(w http.ResponseWriter,
  r *http.Request) 
  { 
    respond(w, r, meander.Journeys) 
  })) 
  http.HandleFunc("/recommendations", cors(func(w http.ResponseWriter, 
  r *http.Request) { 
    q := &amp;meander.Query{ 
      Journey: strings.Split(r.URL.Query().Get("journey"), "|"), 
    } 
    var err error 
    q.Lat, err = strconv.ParseFloat(r.URL.Query().Get("lat"), 64) 
    if err != nil { 
      http.Error(w, err.Error(), http.StatusBadRequest) 
      return 
    } 
    q.Lng, err = strconv.ParseFloat(r.URL.Query().Get("lng"), 64) 
    if err != nil { 
      http.Error(w, err.Error(), http.StatusBadRequest) 
      return 
    } 
    q.Radius, err = strconv.Atoi(r.URL.Query().Get("radius")) 
    if err != nil { 
      http.Error(w, err.Error(), http.StatusBadRequest) 
      return 
    } 
    q.CostRangeStr = r.URL.Query().Get("cost") 
    places := q.Run() 
    respond(w, r, places) 
  })) 
  log.Println("serving meander API on :8080") 
  http.ListenAndServe(":8080", http.DefaultServeMux) 
} 
</pre><p class="calibre10">Now, calls to our API will be allowed from any domain without a cross-origin error occurring.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip121" class="calibre1"/>Tip</h3><p class="calibre10">Can you see a way to smarten up the code by removing the multiple calls to <code class="email">r.URL.Query()</code>? Perhaps do this once and cache the result in a local variable. Then, you can avoid parsing the query many times.</p></div></div></div></body></html>