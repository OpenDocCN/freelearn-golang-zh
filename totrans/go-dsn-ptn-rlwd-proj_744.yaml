- en: Summary
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we built an API that consumes and abstracts the Google Places
    API to provide a fun and interesting way of letting users plan their days and
    evenings.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个API，它消费并抽象了Google Places API，为用户提供了一种有趣且有趣的方式来规划他们的白天和晚上。
- en: We started by writing some simple and short user stories that described what
    we wanted to achieve at a really high level without trying to design the implementation
    up front. In order to parallelize the project, we agreed upon the meeting point
    of the project as the API design, and we built toward it (as would our partners).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始编写了一些简单而简短的用户故事，描述了我们想要在非常高的层面上实现的目标，而没有试图事先设计实现。为了并行化项目，我们同意将项目会议点定在API设计上，并朝着这个方向构建（正如我们的合作伙伴所做的那样）。
- en: We embedded data directly in the code, avoiding the need to investigate, design,
    and implement a data store in the early stages of a project. By caring about how
    that data is accessed (via the API endpoint) instead, we allowed our future selves
    to completely change how and where the data is stored without breaking any apps
    that have been written with our API.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接在代码中嵌入数据，避免了在项目早期阶段调查、设计和实现数据存储的需求。通过关注数据是如何被访问的（通过API端点），我们允许未来的自己完全改变数据的存储方式和位置，而不会破坏任何使用我们的API编写的应用程序。
- en: We implemented the `Facade` interface, which allows our structs and other types
    to provide public representations of them without revealing messy or sensitive
    details about our implementation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了`Facade`接口，它允许我们的结构体和其他类型提供它们的公共表示，而不透露关于我们实现混乱或敏感的细节。
- en: Our foray into enumerators gave us a useful starting point to build enumerated
    types, even though there is no official support for them in the language. The
    `iota` keyword that we used lets us specify constants of our own numerical type,
    with incrementing values. The common `String` method that we implemented showed
    us how to make sure that our enumerated types don't become obscure numbers in
    our logs. At the same time, we also saw a real-world example of TDD and red/green
    programming, where we wrote unit tests that first fail but which we then go on
    to make pass by writing the implementation code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的枚举器探索为我们提供了一个有用的起点来构建枚举类型，尽管语言中没有官方支持。我们使用的`iota`关键字让我们可以指定我们自己的数值类型的常量，具有递增的值。我们实现的常见`String`方法向我们展示了如何确保我们的枚举类型不会在我们的日志中变成晦涩的数字。同时，我们也看到了一个真实世界的TDD和红/绿编程的例子，我们编写了首先失败的单元测试，然后通过编写实现代码使它们通过。
- en: In the next chapter, we are going to take a break from web services in order
    to build a backup tool for our code, where we'll explore how easy Go makes it
    for us to interact with the local filesystem.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将暂时放下网络服务，以构建我们的代码备份工具，我们将探索Go如何使我们轻松地与本地文件系统交互。
