- en: The project structure
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目结构
- en: It is common in Go solutions to have, in a single project, both a package that
    allows other Go programmers to use your capabilities and a command-line tool that
    allows end users to use your programs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 解决方案中，在单个项目中同时拥有一个允许其他 Go 程序员使用你的功能的包和一个允许最终用户使用你的程序的命令行工具是很常见的。
- en: As we saw in the last chapter, a convention to structure such projects is emerging
    whereby we have the package in the main project project folder and the command-line
    tool inside a subfolder called `cmd` or `cmds` if you have multiple commands.
    Because all packages are equal in Go (regardless of the directory tree), you can
    import the package from the command subpackages, knowing you'll never need to
    import the commands from the project package (which is illegal as you can't have
    cyclical dependencies). This may seem like an unnecessary abstraction, but it
    is actually quite a common pattern and can be seen in the standard Go tool chain
    with examples such as `gofmt` and `goimports`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，一种结构此类项目的惯例正在出现，即我们将包放在主项目文件夹中，将命令行工具放在名为 `cmd` 或 `cmds` 的子文件夹中（如果你有多个命令）。因为所有包在
    Go 中都是平等的（无论目录树如何），你可以从命令子包中导入包，知道你永远不需要从项目包中导入命令（这是非法的，因为你不能有循环依赖）。这看起来可能像是一种不必要的抽象，但实际上这是一种相当常见的模式，可以在标准
    Go 工具链中看到，例如 `gofmt` 和 `goimports` 的例子。
- en: 'For example, for our project, we are going to write a package called `backup`
    and two command-line tools: the daemon and the user interaction tool. We will
    structure our project in the following way:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于我们的项目，我们将编写一个名为 `backup` 的包和两个命令行工具：守护程序和用户交互工具。我们将以以下方式组织我们的项目：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The reason we don't just put code directly inside the `cmd` folder (even if
    we only had one command) is that when `go install` builds projects, it uses the
    name of the folder as the command name, and it wouldn't be very useful if all
    of our tools were called `cmd`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有直接将代码放在 `cmd` 文件夹中（即使我们只有一个命令）的原因是，当 `go install` 构建项目时，它使用文件夹的名称作为命令名称，如果我们的所有工具都叫做
    `cmd`，那就不会很有用。
