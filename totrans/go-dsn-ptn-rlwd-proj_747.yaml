- en: The project structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is common in Go solutions to have, in a single project, both a package that
    allows other Go programmers to use your capabilities and a command-line tool that
    allows end users to use your programs.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the last chapter, a convention to structure such projects is emerging
    whereby we have the package in the main project project folder and the command-line
    tool inside a subfolder called `cmd` or `cmds` if you have multiple commands.
    Because all packages are equal in Go (regardless of the directory tree), you can
    import the package from the command subpackages, knowing you'll never need to
    import the commands from the project package (which is illegal as you can't have
    cyclical dependencies). This may seem like an unnecessary abstraction, but it
    is actually quite a common pattern and can be seen in the standard Go tool chain
    with examples such as `gofmt` and `goimports`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for our project, we are going to write a package called `backup`
    and two command-line tools: the daemon and the user interaction tool. We will
    structure our project in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason we don't just put code directly inside the `cmd` folder (even if
    we only had one command) is that when `go install` builds projects, it uses the
    name of the folder as the command name, and it wouldn't be very useful if all
    of our tools were called `cmd`.
  prefs: []
  type: TYPE_NORMAL
