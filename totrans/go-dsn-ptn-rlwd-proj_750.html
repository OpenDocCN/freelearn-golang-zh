<html><head></head><body>
<div class="book" title="The backup package">
<div class="book" title="Testing interfaces by implementing them"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec0081" class="calibre1"/>Testing interfaces by implementing them</h2></div></div></div><p class="calibre10">Now that we have the interface for our <code class="email">Archiver</code> types, we are going to implement one that uses the ZIP file format.</p><p class="calibre10">Add the following <code class="email">struct</code> definition to <code class="email">archiver.go</code>:</p><pre class="programlisting">type zipper struct{} 
</pre><p class="calibre10">We are not going to export this type, which might make you jump to the conclusion that users outside of the package won't be able to make use of it. In fact, we are going to provide them with an instance of the type for them to use in order to save them from having to worry about creating and managing their own types.</p><p class="calibre10">Add the following exported implementation:</p><pre class="programlisting">// Zip is an Archiver that zips and unzips files. 
var ZIP Archiver = (*zipper)(nil) 
</pre><p class="calibre10">This curious snippet of Go voodoo is actually a very interesting way of exposing the intent to the compiler without using any memory (literally 0 bytes). We are defining a variable called <code class="email">ZIP</code> of type <code class="email">Archiver</code>, so from outside the package, it's pretty clear that we can use that variable wherever <code class="email">Archiver</code> is needed if you want to zip things. Then, we assign it with <code class="email">nil</code> cast to the type <code class="email">*zipper</code>. We know that <code class="email">nil</code> takes no memory, but since it's cast to a <code class="email">zipper</code> pointer, and given that our <code class="email">zipper</code> struct has no state, it's an appropriate way of solving a problem, which hides the complexity of code (and indeed the actual implementation) from outside users. There is no reason anybody outside of the package needs to know about our <code class="email">zipper</code> type at all, which frees us up to change the internals without touching the externals at any time: the true power of interfaces.</p><p class="calibre10">Another handy side benefit to this trick is that the compiler will now be checking whether our zipper type properly implements the <code class="email">Archiver</code> interface or not, so if you try to build this code, you'll get a compiler error:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">./archiver.go:10: cannot use (*zipper)(nil) (type *zipper) as type 
    Archiver in assignment:</strong></span>
<span class="strong"><strong class="calibre2">  *zipper does not implement Archiver (missing Archive method)</strong></span>
</pre><p class="calibre10">We see that our <code class="email">zipper</code> type does not implement the <code class="email">Archive</code> method as mandated in the interface.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip124" class="calibre1"/>Tip</h3><p class="calibre10">You can also use the <code class="email">Archive</code> method in test code to ensure that your types implement the interfaces they should. If you don't need to use the variable, you can always throw it away using an underscore and you'll still get the compiler help:</p><p class="calibre10">
<code class="email">var _ Interface = (*Implementation)(nil)</code>
</p></div><p class="calibre10">To make the compiler happy, we are going to add the implementation of the <code class="email">Archive</code> method for our <code class="email">zipper</code> type.</p><p class="calibre10">Add the following code to <code class="email">archiver.go</code>:</p><pre class="programlisting">func (z *zipper) Archive(src, dest string) error { 
  if err := os.MkdirAll(filepath.Dir(dest), 0777); err != nil { 
    return err 
  } 
  out, err := os.Create(dest) 
  if err != nil { 
    return err 
  } 
  defer out.Close() 
  w := zip.NewWriter(out) 
  defer w.Close() 
  return filepath.Walk(src, func(path string, info os.FileInfo, err error) 
  error { 
    if info.IsDir() { 
      return nil // skip 
    } 
    if err != nil { 
      return err 
    } 
    in, err := os.Open(path) 
    if err != nil { 
      return err 
    } 
    defer in.Close() 
    f, err := w.Create(path) 
    if err != nil { 
      return err 
    } 
    _, err = io.Copy(f, in) 
    if err != nil { 
      return err 
    } 
    return nil 
  }) 
} 
</pre><p class="calibre10">You will also have to import the <code class="email">archive/zip</code> package from the Go standard library. In our <code class="email">Archive</code> method, we take the following steps to prepare writing to a ZIP file:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Use <code class="email">os.MkdirAll</code> to ensure that the destination directory exists. The <code class="email">0777</code> code represents the file permissions with which you may need to create any missing directories</li><li class="listitem">Use <code class="email">os.Create</code> to create a new file as specified by the <code class="email">dest</code> path</li><li class="listitem">If the file is created without an error, defer the closing of the file with <code class="email">defer out.Close()</code></li><li class="listitem">Use <code class="email">zip.NewWriter</code> to create a new <code class="email">zip.Writer</code> type that will write to the file we just created and defer the closing of the writer</li></ul></div><p class="calibre10">Once we have a <code class="email">zip.Writer</code> type ready to go, we use the <code class="email">filepath.Walk</code> function to iterate over the source directory, <code class="email">src</code>.</p><p class="calibre10">The <code class="email">filepath.Walk</code> function takes two arguments: the root path and a callback function to be called for every item (files and folders) it encounters while iterating over the filesystem.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip125" class="calibre1"/>Tip</h3><p class="calibre10">Functions are first class types in Go, which means you can use them as argument types as well as global functions and methods. The <code class="email">filepath.Walk</code> function specifies the second argument type as <code class="email">filepath.WalkFunc</code>, which is a function with a specific signature. As long as we adhere to the signature (correct input and return arguments) we can write inline functions rather than worrying about the <code class="email">filepath.WalkFunc</code> type at all.</p><p class="calibre10">Taking a quick look at the Go source code tell us that the signature for <code class="email">filepath.WalkFunc</code> matches the function we are passing inÂ <code class="email">func(path string, info os.FileInfo, err error) error</code>
</p></div><p class="calibre10">The <code class="email">filepath.Walk</code> function is recursive, so it will travel deep into subfolders too. The callback function itself takes three arguments: the full path of the file, the <code class="email">os.FileInfo</code> object that describes the file or folder itself, and an error (it also returns an error in case something goes wrong). If any calls to the callback function result in an error (other than the special <code class="email">SkipDir</code> error value) being returned, the operation will be aborted and <code class="email">filepath.Walk</code> returns that error. We simply pass this up to the caller of <code class="email">Archive</code> and let them worry about it, since there's nothing more we can do.</p><p class="calibre10">For each item in the tree, our code takes the following steps:</p><div class="book"><ul class="itemizedlist"><li class="listitem">If the <code class="email">info.IsDir</code> method tells us that the item is a folder, we just return <code class="email">nil</code>, effectively skipping it. There is no reason to add folders to ZIP archives because the path of the files will encode that information for us.</li><li class="listitem">If an error is passed in (via the third argument), it means something went wrong when trying to access information about the file. This is uncommon, so we just return the error, which will eventually be passed out to the caller of <code class="email">Archive</code>. As the implementor of <code class="email">filepath.Walk</code>, you aren't forced to abort the operation here; you are free to do whatever makes sense in your individual case.</li><li class="listitem">Use <code class="email">os.Open</code> to open the source file for reading, and if successful, defer its closing.</li><li class="listitem">Call <code class="email">Create</code> on the <code class="email">ZipWriter</code> object to indicate that we want to create a new compressed file and give it the full path of the file, which includes the directories it is nested inside.</li><li class="listitem">Use <code class="email">io.Copy</code> to read all of the bytes from the source file and write them through the <code class="email">ZipWriter</code> object to the ZIP file we opened earlier.</li><li class="listitem">Return <code class="email">nil</code> to indicate no errors.</li></ul></div><p class="calibre10">This chapter will not cover unit testing or <span class="strong"><strong class="calibre2">Test-driven Development</strong></span> (<span class="strong"><strong class="calibre2">TDD</strong></span>) practices, but feel free to write a test to ensure that our implementation does what it is meant to do.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip126" class="calibre1"/>Tip</h3><p class="calibre10">Since we are writing a package, spend some time commenting on the exported pieces so far. You can use <code class="email">golint</code> to help you find anything you may have missed.</p></div></div></div></body></html>