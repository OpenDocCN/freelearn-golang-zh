["```go\ntype zipper struct{} \n\n```", "```go\n// Zip is an Archiver that zips and unzips files. \nvar ZIP Archiver = (*zipper)(nil) \n\nZIP of type Archiver, so from outside the package, it's pretty clear that we can use that variable wherever Archiver is needed if you want to zip things. Then, we assign it with nil cast to the type *zipper. We know that nil takes no memory, but since it's cast to a zipper pointer, and given that our zipper struct has no state, it's an appropriate way of solving a problem, which hides the complexity of code (and indeed the actual implementation) from outside users. There is no reason anybody outside of the package needs to know about our zipper type at all, which frees us up to change the internals without touching the externals at any time: the true power of interfaces.\n```", "```go\n./archiver.go:10: cannot use (*zipper)(nil) (type *zipper) as type \n    Archiver in assignment:\n *zipper does not implement Archiver (missing Archive method)\n\n```", "```go\nfunc (z *zipper) Archive(src, dest string) error { \n  if err := os.MkdirAll(filepath.Dir(dest), 0777); err != nil { \n    return err \n  } \n  out, err := os.Create(dest) \n  if err != nil { \n    return err \n  } \n  defer out.Close() \n  w := zip.NewWriter(out) \n  defer w.Close() \n  return filepath.Walk(src, func(path string, info os.FileInfo, err error) \n  error { \n    if info.IsDir() { \n      return nil // skip \n    } \n    if err != nil { \n      return err \n    } \n    in, err := os.Open(path) \n    if err != nil { \n      return err \n    } \n    defer in.Close() \n    f, err := w.Create(path) \n    if err != nil { \n      return err \n    } \n    _, err = io.Copy(f, in) \n    if err != nil { \n      return err \n    } \n    return nil \n  }) \n} \n\n```"]