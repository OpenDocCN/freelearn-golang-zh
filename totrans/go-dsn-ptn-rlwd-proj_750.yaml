- en: Testing interfaces by implementing them
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过实现接口来测试接口
- en: Now that we have the interface for our `Archiver` types, we are going to implement
    one that uses the ZIP file format.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `Archiver` 类型的接口，我们将实现一个使用 ZIP 文件格式的类型。
- en: 'Add the following `struct` definition to `archiver.go`:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下 `struct` 定义添加到 `archiver.go` 中：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are not going to export this type, which might make you jump to the conclusion
    that users outside of the package won't be able to make use of it. In fact, we
    are going to provide them with an instance of the type for them to use in order
    to save them from having to worry about creating and managing their own types.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会导出这个类型，这可能会让你得出结论，包外部的用户无法使用它。实际上，我们将为他们提供一个类型的实例，以便他们可以使用，从而避免他们必须担心创建和管理自己的类型。
- en: 'Add the following exported implementation:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下导出实现：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Another handy side benefit to this trick is that the compiler will now be checking
    whether our zipper type properly implements the `Archiver` interface or not, so
    if you try to build this code, you''ll get a compiler error:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧的另一个实用的副作用是，编译器现在将检查我们的 `zipper` 类型是否正确实现了 `Archiver` 接口，所以如果你尝试构建这段代码，你会得到编译器错误：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We see that our `zipper` type does not implement the `Archive` method as mandated
    in the interface.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们的 `zipper` 类型没有实现接口中规定的 `Archive` 方法。
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'You can also use the `Archive` method in test code to ensure that your types
    implement the interfaces they should. If you don''t need to use the variable,
    you can always throw it away using an underscore and you''ll still get the compiler
    help:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在测试代码中使用 `Archive` 方法来确保你的类型实现了它们应该实现的接口。如果你不需要使用这个变量，你总是可以用下划线将其丢弃，你仍然会得到编译器的帮助：
- en: '`var _ Interface = (*Implementation)(nil)`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`var _ Interface = (*Implementation)(nil)`'
- en: To make the compiler happy, we are going to add the implementation of the `Archive`
    method for our `zipper` type.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让编译器满意，我们将为我们的 `zipper` 类型添加 `Archive` 方法的实现。
- en: 'Add the following code to `archiver.go`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `archiver.go` 中：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will also have to import the `archive/zip` package from the Go standard
    library. In our `Archive` method, we take the following steps to prepare writing
    to a ZIP file:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须从 Go 标准库中导入 `archive/zip` 包。在我们的 `Archive` 方法中，我们采取以下步骤来准备写入 ZIP 文件：
- en: Use `os.MkdirAll` to ensure that the destination directory exists. The `0777`
    code represents the file permissions with which you may need to create any missing
    directories
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `os.MkdirAll` 确保目标目录存在。`0777` 代码表示创建任何缺失目录所需的文件权限
- en: Use `os.Create` to create a new file as specified by the `dest` path
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `os.Create` 根据指定的 `dest` 路径创建一个新的文件
- en: If the file is created without an error, defer the closing of the file with
    `defer out.Close()`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件创建没有错误，使用 `defer out.Close()` 延迟关闭文件
- en: Use `zip.NewWriter` to create a new `zip.Writer` type that will write to the
    file we just created and defer the closing of the writer
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `zip.NewWriter` 创建一个新的 `zip.Writer` 类型，该类型将写入我们刚刚创建的文件，并延迟关闭写入器
- en: Once we have a `zip.Writer` type ready to go, we use the `filepath.Walk` function
    to iterate over the source directory, `src`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了准备好的 `zip.Writer` 类型，我们使用 `filepath.Walk` 函数遍历源目录 `src`。
- en: 'The `filepath.Walk` function takes two arguments: the root path and a callback
    function to be called for every item (files and folders) it encounters while iterating
    over the filesystem.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`filepath.Walk` 函数接受两个参数：根路径和回调函数，该函数将在遍历文件系统时对每个遇到的项（文件和文件夹）进行调用。'
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Functions are first class types in Go, which means you can use them as argument
    types as well as global functions and methods. The `filepath.Walk` function specifies
    the second argument type as `filepath.WalkFunc`, which is a function with a specific
    signature. As long as we adhere to the signature (correct input and return arguments)
    we can write inline functions rather than worrying about the `filepath.WalkFunc`
    type at all.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是 Go 中的第一类类型，这意味着你可以将它们用作参数类型，以及全局函数和方法。`filepath.Walk` 函数指定第二个参数类型为 `filepath.WalkFunc`，这是一个具有特定签名的函数。只要我们遵守签名（正确的输入和返回参数），我们就可以编写内联函数，而无需担心
    `filepath.WalkFunc` 类型。
- en: Taking a quick look at the Go source code tell us that the signature for `filepath.WalkFunc`
    matches the function we are passing in `func(path string, info os.FileInfo, err
    error) error`
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看 Go 源代码告诉我们，`filepath.WalkFunc` 的签名与我们要传递的函数 `func(path string, info os.FileInfo,
    err error) error` 匹配
- en: 'The `filepath.Walk` function is recursive, so it will travel deep into subfolders
    too. The callback function itself takes three arguments: the full path of the
    file, the `os.FileInfo` object that describes the file or folder itself, and an
    error (it also returns an error in case something goes wrong). If any calls to
    the callback function result in an error (other than the special `SkipDir` error
    value) being returned, the operation will be aborted and `filepath.Walk` returns
    that error. We simply pass this up to the caller of `Archive` and let them worry
    about it, since there''s nothing more we can do.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`filepath.Walk` 函数是递归的，所以它也会深入到子文件夹中。回调函数本身接受三个参数：文件的完整路径、描述文件或文件夹本身的 `os.FileInfo`
    对象，以及一个错误（如果发生错误，它也会返回一个错误）。如果回调函数的任何调用返回错误（除了特殊的 `SkipDir` 错误值），则操作将被终止，`filepath.Walk`
    返回该错误。我们只是将这个错误传递给 `Archive` 的调用者，让他们来处理，因为我们已经无能为力了。'
- en: 'For each item in the tree, our code takes the following steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于树中的每个项目，我们的代码执行以下步骤：
- en: If the `info.IsDir` method tells us that the item is a folder, we just return
    `nil`, effectively skipping it. There is no reason to add folders to ZIP archives
    because the path of the files will encode that information for us.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `info.IsDir` 方法告诉我们该项是一个文件夹，我们就返回 `nil`，实际上跳过了它。没有必要将文件夹添加到ZIP存档中，因为文件的路径会为我们编码这些信息。
- en: If an error is passed in (via the third argument), it means something went wrong
    when trying to access information about the file. This is uncommon, so we just
    return the error, which will eventually be passed out to the caller of `Archive`.
    As the implementor of `filepath.Walk`, you aren't forced to abort the operation
    here; you are free to do whatever makes sense in your individual case.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传递了错误（通过第三个参数），这意味着在尝试访问文件信息时出了问题。这种情况很少见，所以我们只是返回错误，这个错误最终会被传递给 `Archive`
    的调用者。作为 `filepath.Walk` 的实现者，你在这里不需要强制终止操作；你可以自由地根据你自己的情况做任何合理的事情。
- en: Use `os.Open` to open the source file for reading, and if successful, defer
    its closing.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `os.Open` 打开源文件进行读取，如果成功，则延迟关闭它。
- en: Call `Create` on the `ZipWriter` object to indicate that we want to create a
    new compressed file and give it the full path of the file, which includes the
    directories it is nested inside.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `ZipWriter` 对象上调用 `Create` 来表示我们想要创建一个新的压缩文件，并给出文件的完整路径，包括它嵌套在内的目录。
- en: Use `io.Copy` to read all of the bytes from the source file and write them through
    the `ZipWriter` object to the ZIP file we opened earlier.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `io.Copy` 读取源文件中的所有字节，并通过 `ZipWriter` 对象将它们写入我们之前打开的ZIP文件。
- en: Return `nil` to indicate no errors.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 `nil` 来表示没有错误。
- en: This chapter will not cover unit testing or **Test-driven Development** (**TDD**)
    practices, but feel free to write a test to ensure that our implementation does
    what it is meant to do.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将不会涵盖单元测试或**测试驱动开发**（**TDD**）实践，但你可以自由地编写测试来确保我们的实现确实做了它应该做的事情。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Since we are writing a package, spend some time commenting on the exported pieces
    so far. You can use `golint` to help you find anything you may have missed.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在编写一个包，花些时间注释一下到目前为止导出的部分。你可以使用 `golint` 来帮助你找到可能遗漏的任何内容。
