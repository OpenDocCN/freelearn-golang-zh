- en: Testing interfaces by implementing them
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the interface for our `Archiver` types, we are going to implement
    one that uses the ZIP file format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `struct` definition to `archiver.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We are not going to export this type, which might make you jump to the conclusion
    that users outside of the package won't be able to make use of it. In fact, we
    are going to provide them with an instance of the type for them to use in order
    to save them from having to worry about creating and managing their own types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following exported implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Another handy side benefit to this trick is that the compiler will now be checking
    whether our zipper type properly implements the `Archiver` interface or not, so
    if you try to build this code, you''ll get a compiler error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We see that our `zipper` type does not implement the `Archive` method as mandated
    in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also use the `Archive` method in test code to ensure that your types
    implement the interfaces they should. If you don''t need to use the variable,
    you can always throw it away using an underscore and you''ll still get the compiler
    help:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var _ Interface = (*Implementation)(nil)`'
  prefs: []
  type: TYPE_NORMAL
- en: To make the compiler happy, we are going to add the implementation of the `Archive`
    method for our `zipper` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `archiver.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also have to import the `archive/zip` package from the Go standard
    library. In our `Archive` method, we take the following steps to prepare writing
    to a ZIP file:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `os.MkdirAll` to ensure that the destination directory exists. The `0777`
    code represents the file permissions with which you may need to create any missing
    directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `os.Create` to create a new file as specified by the `dest` path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the file is created without an error, defer the closing of the file with
    `defer out.Close()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `zip.NewWriter` to create a new `zip.Writer` type that will write to the
    file we just created and defer the closing of the writer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have a `zip.Writer` type ready to go, we use the `filepath.Walk` function
    to iterate over the source directory, `src`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `filepath.Walk` function takes two arguments: the root path and a callback
    function to be called for every item (files and folders) it encounters while iterating
    over the filesystem.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions are first class types in Go, which means you can use them as argument
    types as well as global functions and methods. The `filepath.Walk` function specifies
    the second argument type as `filepath.WalkFunc`, which is a function with a specific
    signature. As long as we adhere to the signature (correct input and return arguments)
    we can write inline functions rather than worrying about the `filepath.WalkFunc`
    type at all.
  prefs: []
  type: TYPE_NORMAL
- en: Taking a quick look at the Go source code tell us that the signature for `filepath.WalkFunc`
    matches the function we are passing inÂ `func(path string, info os.FileInfo, err
    error) error`
  prefs: []
  type: TYPE_NORMAL
- en: 'The `filepath.Walk` function is recursive, so it will travel deep into subfolders
    too. The callback function itself takes three arguments: the full path of the
    file, the `os.FileInfo` object that describes the file or folder itself, and an
    error (it also returns an error in case something goes wrong). If any calls to
    the callback function result in an error (other than the special `SkipDir` error
    value) being returned, the operation will be aborted and `filepath.Walk` returns
    that error. We simply pass this up to the caller of `Archive` and let them worry
    about it, since there''s nothing more we can do.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each item in the tree, our code takes the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `info.IsDir` method tells us that the item is a folder, we just return
    `nil`, effectively skipping it. There is no reason to add folders to ZIP archives
    because the path of the files will encode that information for us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an error is passed in (via the third argument), it means something went wrong
    when trying to access information about the file. This is uncommon, so we just
    return the error, which will eventually be passed out to the caller of `Archive`.
    As the implementor of `filepath.Walk`, you aren't forced to abort the operation
    here; you are free to do whatever makes sense in your individual case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `os.Open` to open the source file for reading, and if successful, defer
    its closing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `Create` on the `ZipWriter` object to indicate that we want to create a
    new compressed file and give it the full path of the file, which includes the
    directories it is nested inside.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `io.Copy` to read all of the bytes from the source file and write them through
    the `ZipWriter` object to the ZIP file we opened earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return `nil` to indicate no errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will not cover unit testing or **Test-driven Development** (**TDD**)
    practices, but feel free to write a test to ensure that our implementation does
    what it is meant to do.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we are writing a package, spend some time commenting on the exported pieces
    so far. You can use `golint` to help you find anything you may have missed.
  prefs: []
  type: TYPE_NORMAL
