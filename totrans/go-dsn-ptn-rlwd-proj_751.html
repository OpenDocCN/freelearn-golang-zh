<html><head></head><body>
<div class="book" title="The backup package">
<div class="book" title="Has the filesystem changed?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec0082" class="calibre1"/>Has the filesystem changed?</h2></div></div></div><p class="calibre10">One of the biggest problems our backup system has is deciding whether a folder has changed or not in a cross-platform, predictable, and reliable way. After all, there's no point in creating a backup if nothing is different from the previous backup. A few things spring to mind when we think about this problem: should we just check the last modified date on the top-level folder? Should we use system notifications to be informed whenever a file we care about changes? There are problems with both of these approaches, and it turns out it's not a simple problem to solve.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip127" class="calibre1"/>Tip</h3><p class="calibre10">Check out the <code class="email">fsnotify</code> project at <a class="calibre1" href="https://fsnotify.org">https://fsnotify.org</a> (project source: <a class="calibre1" href="https://github.com/fsnotify">https://github.com/fsnotify</a>). The authors are attempting to build a cross-platform package for subscription to filesystem events. At the time of writing this, the project is still in its infancy and it not a viable option for this chapter, but in the future, it could well become the standard solution for filesystem events.</p></div><p class="calibre10">We are, instead, going to generate an MD5 hash made up of all of the information that we care about when considering whether something has changed or not.</p><p class="calibre10">Looking at the <code class="email">os.FileInfo</code> type, we can see that we can find out a lot of information about a file or folder:</p><pre class="programlisting">type FileInfo interface { 
  Name() string       // base name of the file 
  Size() int64        // length in bytes for regular files;  
                         system-dependent for others 
  Mode() FileMode     // file mode bits 
  ModTime() time.Time // modification time 
  IsDir() bool        // abbreviation for Mode().IsDir() 
  Sys() interface{}   // underlying data source (can return nil) 
} 
</pre><p class="calibre10">To ensure we are aware of a variety of changes to any file in a folder, the hash will be made up of the filename and path (so if they rename a file, the hash will be different), size (if a file changes size, it's obviously different), the last modified date, whether the item is a file or folder, and the file mode bits. Even though we won't be archiving the folders, we still care about their names and the tree structure of the folder.</p><p class="calibre10">Create a new file called <code class="email">dirhash.go</code> and add the following function:</p><pre class="programlisting">package backup 
import ( 
  "crypto/md5" 
  "fmt" 
  "io" 
  "os" 
  "path/filepath" 
) 
func DirHash(path string) (string, error) { 
  hash := md5.New() 
  err := filepath.Walk(path, func(path string, info os.FileInfo, err error) 
  error { 
    if err != nil { 
      return err 
    } 
    io.WriteString(hash, path) 
    fmt.Fprintf(hash, "%v", info.IsDir()) 
    fmt.Fprintf(hash, "%v", info.ModTime()) 
    fmt.Fprintf(hash, "%v", info.Mode()) 
    fmt.Fprintf(hash, "%v", info.Name()) 
    fmt.Fprintf(hash, "%v", info.Size()) 
    return nil 
  }) 
  if err != nil { 
    return "", err 
  } 
  return fmt.Sprintf("%x", hash.Sum(nil)), nil 
} 
</pre><p class="calibre10">We first create a new <code class="email">hash.Hash</code> function that knows how to calculate MD5s before using <code class="email">filepath.Walk</code> again to iterate over all of the files and folders inside the specified path directory. For each item, assuming there are no errors, we write the differential information to the hash generator using <code class="email">io.WriteString</code>, which lets us write a string to <code class="email">io.Writer</code> and <code class="email">fmt.Fprintf</code>, which does the same but exposes formatting capabilities at the same time, allowing us to generate the default value format for each item using the <code class="email">%v</code> format verb.</p><p class="calibre10">Once each file has been processed, and assuming no errors occurred, we then use <code class="email">fmt.Sprintf</code> to generate the result string. The <code class="email">Sum</code> method in <code class="email">hash.Hash</code> calculates the final hash value with the specified values appended. In our case, we do not want to append anything since we've already added all of the information we care about, so we just pass <code class="email">nil</code>. The <code class="email">%x</code> format verb indicates that we want the value to be represented in hex (base 16) with lowercase letters. This is the usual way of representing an MD5 hash.</p></div></div></body></html>