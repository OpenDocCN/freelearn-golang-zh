- en: Has the filesystem changed?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the biggest problems our backup system has is deciding whether a folder
    has changed or not in a cross-platform, predictable, and reliable way. After all,
    there''s no point in creating a backup if nothing is different from the previous
    backup. A few things spring to mind when we think about this problem: should we
    just check the last modified date on the top-level folder? Should we use system
    notifications to be informed whenever a file we care about changes? There are
    problems with both of these approaches, and it turns out it''s not a simple problem
    to solve.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Check out the `fsnotify` project at [https://fsnotify.org](https://fsnotify.org)
    (project source: [https://github.com/fsnotify](https://github.com/fsnotify)).
    The authors are attempting to build a cross-platform package for subscription
    to filesystem events. At the time of writing this, the project is still in its
    infancy and it not a viable option for this chapter, but in the future, it could
    well become the standard solution for filesystem events.'
  prefs: []
  type: TYPE_NORMAL
- en: We are, instead, going to generate an MD5 hash made up of all of the information
    that we care about when considering whether something has changed or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the `os.FileInfo` type, we can see that we can find out a lot of
    information about a file or folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To ensure we are aware of a variety of changes to any file in a folder, the
    hash will be made up of the filename and path (so if they rename a file, the hash
    will be different), size (if a file changes size, it's obviously different), the
    last modified date, whether the item is a file or folder, and the file mode bits.
    Even though we won't be archiving the folders, we still care about their names
    and the tree structure of the folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `dirhash.go` and add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We first create a new `hash.Hash` function that knows how to calculate MD5s
    before using `filepath.Walk` again to iterate over all of the files and folders
    inside the specified path directory. For each item, assuming there are no errors,
    we write the differential information to the hash generator using `io.WriteString`,
    which lets us write a string to `io.Writer` and `fmt.Fprintf`, which does the
    same but exposes formatting capabilities at the same time, allowing us to generate
    the default value format for each item using the `%v` format verb.
  prefs: []
  type: TYPE_NORMAL
- en: Once each file has been processed, and assuming no errors occurred, we then
    use `fmt.Sprintf` to generate the result string. The `Sum` method in `hash.Hash`
    calculates the final hash value with the specified values appended. In our case,
    we do not want to append anything since we've already added all of the information
    we care about, so we just pass `nil`. The `%x` format verb indicates that we want
    the value to be represented in hex (base 16) with lowercase letters. This is the
    usual way of representing an MD5 hash.
  prefs: []
  type: TYPE_NORMAL
