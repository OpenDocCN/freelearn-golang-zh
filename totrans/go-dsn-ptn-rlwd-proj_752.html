<html><head></head><body>
<div class="book" title="The backup package">
<div class="book" title="Checking for changes and initiating a backup"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch08lvl2sec0083" class="calibre1"/>Checking for changes and initiating a backup</h2></div></div></div><p class="calibre10">Now that we have the ability to hash a folder and perform a backup, we are going to put the two together in a new type called <code class="email">Monitor</code>. The <code class="email">Monitor</code> type will have a map of paths with their associated hashes, a reference to any <code class="email">Archiver</code> type (of course, we'll use <code class="email">backup.ZIP</code> for now), and a destination string representing where to put the archives.</p><p class="calibre10">Create a new file called <code class="email">monitor.go</code> and add the following definition:</p><pre class="programlisting">type Monitor struct { 
  Paths       map[string]string 
  Archiver    Archiver 
  Destination string 
} 
</pre><p class="calibre10">In order to trigger a check for changes, we are going to add the following <code class="email">Now</code> method:</p><pre class="programlisting">func (m *Monitor) Now() (int, error) { 
  var counter int 
  for path, lastHash := range m.Paths { 
    newHash, err := DirHash(path) 
    if err != nil { 
      return counter, err 
    } 
    if newHash != lastHash { 
      err := m.act(path) 
      if err != nil { 
        return counter, err 
      } 
      m.Paths[path] = newHash // update the hash 
      counter++ 
    } 
  } 
  return counter, nil 
} 
</pre><p class="calibre10">The <code class="email">Now</code> method iterates over every path in the map and generates the latest hash of that folder. If the hash does not match the hash from the map (generated the last time it checked), then it is considered to have changed and needs backing up again. We do this with a call to the as-yet-unwritten <code class="email">act</code> method before then updating the hash in the map with this new hash.</p><p class="calibre10">To give our users a high-level indication of what happened when they called <code class="email">Now</code>, we are also maintaining a counter, which we increment every time we back up a folder. We will use this later to keep our end users up to date on what the system is doing without bombarding them with information:</p><pre class="programlisting">m.act undefined (type *Monitor has no field or method act) 
</pre><p class="calibre10">The compiler is helping us again and reminding us that we have yet to add the <code class="email">act</code> method:</p><pre class="programlisting">func (m *Monitor) act(path string) error { 
  dirname := filepath.Base(path) 
  filename := fmt.Sprintf("%d.zip", time.Now().UnixNano()) 
  return m.Archiver.Archive(path, filepath.Join(m.Destination,  dirname, filename)) 
} 
</pre><p class="calibre10">Because we have done the heavy lifting in our ZIP <code class="email">Archiver</code> type, all we have to do here is generate a filename, decide where the archive will go, and call the <code class="email">Archive</code> method.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip128" class="calibre1"/>Tip</h3><p class="calibre10">If the <code class="email">Archive</code> method returns an error, the <code class="email">act</code> method and then the <code class="email">Now</code> method will each return it. This mechanism of passing errors up the chain is very common in Go and allows you to either handle cases where you can do something useful to recover or else defer the problem to somebody else.</p></div><p class="calibre10">The <code class="email">act</code> method in the preceding code uses <code class="email">time.Now().UnixNano()</code> to generate a timestamp filename and hardcodes the <code class="email">.zip</code> extension.</p><div class="book" title="Hardcoding is OK for a short while"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec0028" class="calibre1"/>Hardcoding is OK for a short while</h3></div></div></div><p class="calibre10">Hardcoding the file extension like we have is OK in the beginning, but if you think about it, we have blended concerns a little here. If we change the <code class="email">Archiver</code> implementation to use RAR or a compression format of our making, the <code class="email">.zip</code> extension would no longer be appropriate.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip129" class="calibre1"/>Tip</h3><p class="calibre10">Before reading on, think about what steps you might take to avoid this hardcoding. Where does the filename extension decision live? What changes would you need to make in order to avoid hardcoding?</p></div><p class="calibre10">The right place for the filename extensions decision is probably in the <code class="email">Archiver</code> interface, since it knows the kind of archiving it will be doing. So we could add an <code class="email">Ext()</code> string method and access that from our <code class="email">act</code> method. But we can add a little extra power with not much extra work by allowing <code class="email">Archiver</code> authors to specify the entire filename format rather than just the extension instead.</p><p class="calibre10">Back in <code class="email">archiver.go</code>, update the <code class="email">Archiver</code> interface definition:</p><pre class="programlisting">type Archiver interface { 
  DestFmt() string 
  Archive(src, dest string) error 
} 
</pre><p class="calibre10">Our <code class="email">zipper</code> type needs to now implement this:</p><pre class="programlisting">func (z *zipper) DestFmt() string { 
  return "%d.zip" 
} 
</pre><p class="calibre10">Now that we can ask our <code class="email">act</code> method to get the whole format string from the <code class="email">Archiver</code> interface, update the <code class="email">act</code> method:</p><pre class="programlisting">func (m *Monitor) act(path string) error { 
  dirname := filepath.Base(path) 
  filename := fmt.Sprintf(m.Archiver.DestFmt(), time.Now().UnixNano()) 
  return m.Archiver.Archive(path, filepath.Join(m.Destination, dirname, 
  filename)) 
} 
</pre></div></div></div></body></html>