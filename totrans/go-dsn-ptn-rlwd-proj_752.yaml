- en: Checking for changes and initiating a backup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have the ability to hash a folder and perform a backup, we are going
    to put the two together in a new type called `Monitor`. The `Monitor` type will
    have a map of paths with their associated hashes, a reference to any `Archiver`
    type (of course, we'll use `backup.ZIP` for now), and a destination string representing
    where to put the archives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `monitor.go` and add the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to trigger a check for changes, we are going to add the following
    `Now` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Now` method iterates over every path in the map and generates the latest
    hash of that folder. If the hash does not match the hash from the map (generated
    the last time it checked), then it is considered to have changed and needs backing
    up again. We do this with a call to the as-yet-unwritten `act` method before then
    updating the hash in the map with this new hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give our users a high-level indication of what happened when they called
    `Now`, we are also maintaining a counter, which we increment every time we back
    up a folder. We will use this later to keep our end users up to date on what the
    system is doing without bombarding them with information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler is helping us again and reminding us that we have yet to add the
    `act` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Because we have done the heavy lifting in our ZIP `Archiver` type, all we have
    to do here is generate a filename, decide where the archive will go, and call
    the `Archive` method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the `Archive` method returns an error, the `act` method and then the `Now`
    method will each return it. This mechanism of passing errors up the chain is very
    common in Go and allows you to either handle cases where you can do something
    useful to recover or else defer the problem to somebody else.
  prefs: []
  type: TYPE_NORMAL
- en: The `act` method in the preceding code uses `time.Now().UnixNano()` to generate
    a timestamp filename and hardcodes the `.zip` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Hardcoding is OK for a short while
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hardcoding the file extension like we have is OK in the beginning, but if you
    think about it, we have blended concerns a little here. If we change the `Archiver`
    implementation to use RAR or a compression format of our making, the `.zip` extension
    would no longer be appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before reading on, think about what steps you might take to avoid this hardcoding.
    Where does the filename extension decision live? What changes would you need to
    make in order to avoid hardcoding?
  prefs: []
  type: TYPE_NORMAL
- en: The right place for the filename extensions decision is probably in the `Archiver`
    interface, since it knows the kind of archiving it will be doing. So we could
    add an `Ext()` string method and access that from our `act` method. But we can
    add a little extra power with not much extra work by allowing `Archiver` authors
    to specify the entire filename format rather than just the extension instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `archiver.go`, update the `Archiver` interface definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `zipper` type needs to now implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can ask our `act` method to get the whole format string from the
    `Archiver` interface, update the `act` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
