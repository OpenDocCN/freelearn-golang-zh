- en: Checking for changes and initiating a backup
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查更改并启动备份
- en: Now that we have the ability to hash a folder and perform a backup, we are going
    to put the two together in a new type called `Monitor`. The `Monitor` type will
    have a map of paths with their associated hashes, a reference to any `Archiver`
    type (of course, we'll use `backup.ZIP` for now), and a destination string representing
    where to put the archives.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了对文件夹进行哈希处理和执行备份的能力，我们将这两个功能结合在一个新的类型`Monitor`中。`Monitor`类型将包含路径及其相关哈希的映射，对任何`Archiver`类型的引用（当然，我们现在将使用`backup.ZIP`），以及表示存档位置的字符串。
- en: 'Create a new file called `monitor.go` and add the following definition:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`monitor.go`的新文件，并添加以下定义：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to trigger a check for changes, we are going to add the following
    `Now` method:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了触发更改检查，我们将添加以下`Now`方法：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Now` method iterates over every path in the map and generates the latest
    hash of that folder. If the hash does not match the hash from the map (generated
    the last time it checked), then it is considered to have changed and needs backing
    up again. We do this with a call to the as-yet-unwritten `act` method before then
    updating the hash in the map with this new hash.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`Now`方法遍历映射中的每个路径，并生成该文件夹的最新哈希值。如果哈希值与上次检查时生成的哈希值不匹配，则认为它已更改，需要再次备份。我们在调用尚未编写的`act`方法之前这样做，然后使用这个新哈希值更新映射中的哈希值。'
- en: 'To give our users a high-level indication of what happened when they called
    `Now`, we are also maintaining a counter, which we increment every time we back
    up a folder. We will use this later to keep our end users up to date on what the
    system is doing without bombarding them with information:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给用户一个关于他们调用`Now`时发生什么的概述，我们还在维护一个计数器，每次我们备份一个文件夹时，我们都会增加这个计数器。我们将在以后使用这个计数器来让我们的最终用户了解系统正在做什么，而不会用信息轰炸他们：
- en: '[PRE2]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The compiler is helping us again and reminding us that we have yet to add the
    `act` method:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器再次帮助我们，并提醒我们尚未添加`act`方法：
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because we have done the heavy lifting in our ZIP `Archiver` type, all we have
    to do here is generate a filename, decide where the archive will go, and call
    the `Archive` method.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在ZIP `Archiver`类型中完成了繁重的工作，我们在这里只需要生成一个文件名，决定存档将放在哪里，然后调用`Archive`方法。
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If the `Archive` method returns an error, the `act` method and then the `Now`
    method will each return it. This mechanism of passing errors up the chain is very
    common in Go and allows you to either handle cases where you can do something
    useful to recover or else defer the problem to somebody else.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Archive`方法返回一个错误，`act`方法和`Now`方法将分别返回它。这种将错误向上传递的机制在Go中非常常见，它允许你处理可以采取一些有用措施来恢复的情况，或者将问题推迟给其他人。
- en: The `act` method in the preceding code uses `time.Now().UnixNano()` to generate
    a timestamp filename and hardcodes the `.zip` extension.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的`act`方法使用`time.Now().UnixNano()`生成一个时间戳文件名，并硬编码了`.zip`扩展名。
- en: Hardcoding is OK for a short while
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬编码在短时间内是可以的
- en: Hardcoding the file extension like we have is OK in the beginning, but if you
    think about it, we have blended concerns a little here. If we change the `Archiver`
    implementation to use RAR or a compression format of our making, the `.zip` extension
    would no longer be appropriate.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，像我们这样硬编码文件扩展名是可以的，但如果你仔细想想，我们在某种程度上混合了关注点。如果我们改变`Archiver`实现以使用RAR或我们制作的压缩格式，`.zip`扩展名就不再合适了。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Before reading on, think about what steps you might take to avoid this hardcoding.
    Where does the filename extension decision live? What changes would you need to
    make in order to avoid hardcoding?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续阅读之前，考虑一下你可能会采取哪些步骤来避免硬编码。文件名扩展名的决策在哪里？你需要做出哪些更改才能避免硬编码？
- en: The right place for the filename extensions decision is probably in the `Archiver`
    interface, since it knows the kind of archiving it will be doing. So we could
    add an `Ext()` string method and access that from our `act` method. But we can
    add a little extra power with not much extra work by allowing `Archiver` authors
    to specify the entire filename format rather than just the extension instead.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 决定文件扩展名的正确位置可能是在`Archiver`接口中，因为它知道将要进行的归档类型。因此，我们可以添加一个`Ext()`字符串方法，并从我们的`act`方法中访问它。但我们可以通过允许`Archiver`作者指定整个文件名格式而不是仅仅扩展名来增加一些额外的功能，而无需做太多额外的工作。
- en: 'Back in `archiver.go`, update the `Archiver` interface definition:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在`archiver.go`中，更新`Archiver`接口定义：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our `zipper` type needs to now implement this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`zipper`类型现在需要实现以下内容：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that we can ask our `act` method to get the whole format string from the
    `Archiver` interface, update the `act` method:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以让我们的`act`方法从`Archiver`接口获取整个格式化字符串，更新`act`方法：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
