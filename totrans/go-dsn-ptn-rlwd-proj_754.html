<html><head></head><body>
<div class="book" title="The user command-line tool">
<div class="book" title="Persisting small data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch08lvl2sec0084" class="calibre1"/>Persisting small data</h2></div></div></div><p class="calibre10">In order to keep track of the paths and the hashes that we generate, we will need some kind of data storage mechanism that ideally works even when we stop and start our programs. We have lots of choices here: everything from a text file to a full horizontally scalable database solution. The Go ethos of simplicity tells us that building-in a database dependency to our little backup program would not be a great idea; rather, we should ask what the simplest way in which we can solve this problem is.</p><p class="calibre10">The <code class="email">github.com/matryer/filedb</code> package is an experimental solution for just this kind of problem. It lets you interact with the filesystem as though it were a very simple, schemaless database. It takes its design lead from packages such as <code class="email">mgo</code> and can be used in cases where data querying needs are very simple. In <code class="email">filedb</code>, a database is a folder, and a collection is a file where each line represents a different record. Of course, this could all change as the <code class="email">filedb</code> project evolves, but the interface, hopefully, won't.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note00130" class="calibre1"/>Note</h3><p class="calibre10">Adding dependencies such as this to a Go project should be done very carefully because over time, dependencies go stale, change beyond their initial scope, or disappear altogether in some cases. While it sounds counterintuitive, you should consider whether copying and pasting a few files into your project is a better solution than relying on an external dependency. Alternatively, consider vendoring the dependency by copying the entire package into the <code class="email">vendor</code> folder of your command. This is akin to storing a snapshot of the dependency that you know works for your tool.</p></div><p class="calibre10">Add the following code to the end of the <code class="email">main</code> function:</p><pre class="programlisting">db, err := filedb.Dial(*dbpath) 
if err != nil { 
  fatalErr = err 
  return 
} 
defer db.Close() 
col, err := db.C("paths") 
if err != nil { 
  fatalErr = err 
  return 
} 
</pre><p class="calibre10">Here, we use the <code class="email">filedb.Dial</code> function to connect with the <code class="email">filedb</code> database. In actuality, nothing much happens here except specifying where the database is, since there are no real database servers to connect to (although this might change in the future, which is why such provisions exist in the interface). If that was successful, we defer the closing of the database. Closing the database does actually do something, since files may be open that need to be cleaned up.</p><p class="calibre10">Following the <code class="email">mgo</code> pattern, next we specify a collection using the <code class="email">C</code> method and keep a reference to it in the <code class="email">col</code> variable. If an error occurs at any point, we assign it to the <code class="email">fatalErr</code> variable and return.</p><p class="calibre10">To store data, we are going to define a type called <code class="email">path</code>, which will store the full path and the last hash value and use JSON encoding to store this in our <code class="email">filedb</code> database. Add the following <code class="email">struct</code> definition above the <code class="email">main</code> function:</p><pre class="programlisting">type path struct { 
  Path string 
  Hash string 
} 
</pre></div></div></body></html>