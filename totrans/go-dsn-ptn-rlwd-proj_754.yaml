- en: Persisting small data
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化小数据
- en: 'In order to keep track of the paths and the hashes that we generate, we will
    need some kind of data storage mechanism that ideally works even when we stop
    and start our programs. We have lots of choices here: everything from a text file
    to a full horizontally scalable database solution. The Go ethos of simplicity
    tells us that building-in a database dependency to our little backup program would
    not be a great idea; rather, we should ask what the simplest way in which we can
    solve this problem is.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪我们生成的路径和哈希值，我们需要一种数据存储机制，理想情况下这种机制即使在我们的程序停止和启动时也能正常工作。在这里我们有多种选择：从文本文件到完整的水平可扩展数据库解决方案。Go的简洁理念告诉我们，在我们的小型备份程序中内置数据库依赖并不是一个好主意；相反，我们应该考虑以最简单的方式解决这个问题。
- en: The `github.com/matryer/filedb` package is an experimental solution for just
    this kind of problem. It lets you interact with the filesystem as though it were
    a very simple, schemaless database. It takes its design lead from packages such
    as `mgo` and can be used in cases where data querying needs are very simple. In
    `filedb`, a database is a folder, and a collection is a file where each line represents
    a different record. Of course, this could all change as the `filedb` project evolves,
    but the interface, hopefully, won't.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/matryer/filedb`包正是针对这类问题的一个实验性解决方案。它允许你以非常简单、无模式的数据库的方式与文件系统交互。它从`mgo`等包中吸取设计灵感，可以在数据查询需求非常简单的情况下使用。在`filedb`中，数据库是一个文件夹，集合是一个文件，其中每一行代表一个不同的记录。当然，随着`filedb`项目的演变，这一切都可能改变，但接口，希望不会。'
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Adding dependencies such as this to a Go project should be done very carefully
    because over time, dependencies go stale, change beyond their initial scope, or
    disappear altogether in some cases. While it sounds counterintuitive, you should
    consider whether copying and pasting a few files into your project is a better
    solution than relying on an external dependency. Alternatively, consider vendoring
    the dependency by copying the entire package into the `vendor` folder of your
    command. This is akin to storing a snapshot of the dependency that you know works
    for your tool.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go项目中添加此类依赖应该非常谨慎，因为随着时间的推移，依赖项可能会过时，超出其初始范围，或者在某些情况下完全消失。虽然听起来有些反直觉，但你应该考虑将几个文件复制粘贴到你的项目中是否比依赖外部依赖项更好。或者，考虑通过将整个包复制到命令的`vendor`文件夹中来维护依赖项。这类似于存储一个已知对你的工具有效的依赖项快照。
- en: 'Add the following code to the end of the `main` function:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数的末尾添加以下代码：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we use the `filedb.Dial` function to connect with the `filedb` database.
    In actuality, nothing much happens here except specifying where the database is,
    since there are no real database servers to connect to (although this might change
    in the future, which is why such provisions exist in the interface). If that was
    successful, we defer the closing of the database. Closing the database does actually
    do something, since files may be open that need to be cleaned up.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`filedb.Dial`函数与`filedb`数据库建立连接。实际上，这里并没有发生太多事情，只是指定了数据库的位置，因为没有真正的数据库服务器需要连接（尽管这可能在将来改变，这就是为什么接口中存在这样的规定）。如果连接成功，我们将延迟关闭数据库。关闭数据库实际上确实会做一些事情，因为可能有一些文件是打开的，需要清理。
- en: Following the `mgo` pattern, next we specify a collection using the `C` method
    and keep a reference to it in the `col` variable. If an error occurs at any point,
    we assign it to the `fatalErr` variable and return.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 按照`mgo`模式，接下来我们使用`C`方法指定一个集合，并在`col`变量中保持对其的引用。如果在任何点上发生错误，我们将将其分配给`fatalErr`变量并返回。
- en: 'To store data, we are going to define a type called `path`, which will store
    the full path and the last hash value and use JSON encoding to store this in our
    `filedb` database. Add the following `struct` definition above the `main` function:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储数据，我们将定义一个名为`path`的类型，它将存储完整路径和最后一个哈希值，并使用JSON编码将此存储在我们的`filedb`数据库中。在`main`函数上方添加以下`struct`定义：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
