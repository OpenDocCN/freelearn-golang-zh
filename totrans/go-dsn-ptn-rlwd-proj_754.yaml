- en: Persisting small data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to keep track of the paths and the hashes that we generate, we will
    need some kind of data storage mechanism that ideally works even when we stop
    and start our programs. We have lots of choices here: everything from a text file
    to a full horizontally scalable database solution. The Go ethos of simplicity
    tells us that building-in a database dependency to our little backup program would
    not be a great idea; rather, we should ask what the simplest way in which we can
    solve this problem is.'
  prefs: []
  type: TYPE_NORMAL
- en: The `github.com/matryer/filedb` package is an experimental solution for just
    this kind of problem. It lets you interact with the filesystem as though it were
    a very simple, schemaless database. It takes its design lead from packages such
    as `mgo` and can be used in cases where data querying needs are very simple. In
    `filedb`, a database is a folder, and a collection is a file where each line represents
    a different record. Of course, this could all change as the `filedb` project evolves,
    but the interface, hopefully, won't.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding dependencies such as this to a Go project should be done very carefully
    because over time, dependencies go stale, change beyond their initial scope, or
    disappear altogether in some cases. While it sounds counterintuitive, you should
    consider whether copying and pasting a few files into your project is a better
    solution than relying on an external dependency. Alternatively, consider vendoring
    the dependency by copying the entire package into the `vendor` folder of your
    command. This is akin to storing a snapshot of the dependency that you know works
    for your tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the end of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `filedb.Dial` function to connect with the `filedb` database.
    In actuality, nothing much happens here except specifying where the database is,
    since there are no real database servers to connect to (although this might change
    in the future, which is why such provisions exist in the interface). If that was
    successful, we defer the closing of the database. Closing the database does actually
    do something, since files may be open that need to be cleaned up.
  prefs: []
  type: TYPE_NORMAL
- en: Following the `mgo` pattern, next we specify a collection using the `C` method
    and keep a reference to it in the `col` variable. If an error occurs at any point,
    we assign it to the `fatalErr` variable and return.
  prefs: []
  type: TYPE_NORMAL
- en: 'To store data, we are going to define a type called `path`, which will store
    the full path and the last hash value and use JSON encoding to store this in our
    `filedb` database. Add the following `struct` definition above the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
