<html><head></head><body>
<div class="book" title="The user command-line tool">
<div class="book" title="Parsing arguments"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch08lvl2sec0085" class="calibre1"/>Parsing arguments</h2></div></div></div><p class="calibre10">When we call <code class="email">flag.Args</code> (as opposed to <code class="email">os.Args</code>), we receive a slice of arguments excluding the flags. This allows us to mix flag arguments and non-flag arguments in the same tool.</p><p class="calibre10">We want our tool to be able to be used in the following ways:</p><div class="book"><ul class="itemizedlist"><li class="listitem">To add a path:</li></ul></div><pre class="programlisting">
<span class="strong"><strong class="calibre2">backup -db=/path/to/db add {path} [paths...]</strong></span>
</pre><div class="book"><ul class="itemizedlist"><li class="listitem">To remove a path:</li></ul></div><pre class="programlisting">
<span class="strong"><strong class="calibre2">backup -db=/path/to/db remove {path} [paths...]</strong></span>
</pre><div class="book"><ul class="itemizedlist"><li class="listitem">To list all paths:</li></ul></div><pre class="programlisting">
<span class="strong"><strong class="calibre2">backup -db=/path/to/db list</strong></span>
</pre><p class="calibre10">To achieve this, since we have already dealt with flags, we must check the first (non-flag) argument.</p><p class="calibre10">Add the following code to the <code class="email">main</code> function:</p><pre class="programlisting">switch strings.ToLower(args[0]) { 
case "list": 
case "add": 
case "remove": 
} 
</pre><p class="calibre10">Here, we simply switch on the first argument after setting it to lowercase (if the user types <code class="email">backup LIST</code>, we still want it to work).</p><div class="book" title="Listing the paths"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec0029" class="calibre1"/>Listing the paths</h3></div></div></div><p class="calibre10">To list the paths in the database, we are going to use a <code class="email">ForEach</code> method on the path's <code class="email">col</code> variable. Add the following code to the list case:</p><pre class="programlisting">var path path 
col.ForEach(func(i int, data []byte) bool { 
  err := json.Unmarshal(data, &amp;path) 
  if err != nil { 
    fatalErr = err 
    return true 
  } 
  fmt.Printf("= %s\n", path) 
  return false 
}) 
</pre><p class="calibre10">We pass in a callback function to <code class="email">ForEach</code>, which will be called for every item in that collection. We then unmarshal it from JSON into our <code class="email">path</code> type, and just print it out using <code class="email">fmt.Printf</code>. We return <code class="email">false</code> as per the <code class="email">filedb</code> interface, which tells us that returning <code class="email">true</code> would stop iterating and that we want to make sure we list them all.</p><div class="book" title="String representations for your own types"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch08lvl4sec000" class="calibre1"/>String representations for your own types</h4></div></div></div><p class="calibre10">If you print structs in Go in this way, using the <code class="email">%s</code> format verbs, you can get some messy results that are difficult for users to read. If, however, the type implements a <code class="email">String()</code> string method, it will be used instead, and we can use this to control what gets printed. Below the path struct, add the following method:</p><pre class="programlisting">func (p path) String() string { 
  return fmt.Sprintf("%s [%s]", p.Path, p.Hash) 
} 
</pre><p class="calibre10">This tells the <code class="email">path</code> type how it should represent itself as a string.</p></div></div><div class="book" title="Adding paths"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec0030" class="calibre1"/>Adding paths</h3></div></div></div><p class="calibre10">To add a path, or many paths, we are going to iterate over the remaining arguments and call the <code class="email">InsertJSON</code> method for each one. Add the following code to the <code class="email">add</code> case:</p><pre class="programlisting">if len(args[1:]) == 0 { 
  fatalErr = errors.New("must specify path to add") 
  return 
} 
for _, p := range args[1:] { 
  path := &amp;path{Path: p, Hash: "Not yet archived"} 
  if err := col.InsertJSON(path); err != nil { 
    fatalErr = err 
    return 
  } 
  fmt.Printf("+ %s\n", path) 
} 
</pre><p class="calibre10">If the user hasn't specified any additional arguments, for example if they just called <code class="email">backup add</code> without typing any paths, we will return a fatal error. Otherwise, we do the work and print out the path string (prefixed with a <code class="email">+</code> symbol) to indicate that it was successfully added. By default, we'll set the hash to the <code class="email">Not yet archived</code> string literal this is an invalid hash but serves the dual purposes of letting the user know that it hasn't yet been archived as well as indicating as such to our code (given that a hash of the folder will never equal that string).</p></div><div class="book" title="Removing paths"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch08lvl3sec0031" class="calibre1"/>Removing paths</h3></div></div></div><p class="calibre10">To remove a path, or many paths, we use the <code class="email">RemoveEach</code> method for the path's collection. Add the following code to the <code class="email">remove</code> case:</p><pre class="programlisting">var path path 
col.RemoveEach(func(i int, data []byte) (bool, bool) { 
  err := json.Unmarshal(data, &amp;path) 
  if err != nil { 
    fatalErr = err 
    return false, true 
  } 
  for _, p := range args[1:] { 
    if path.Path == p { 
      fmt.Printf("- %s\n", path) 
      return true, false 
    } 
  } 
  return false, false 
}) 
</pre><p class="calibre10">The callback function we provide to <code class="email">RemoveEach</code> expects us to return two bool types: the first one indicates whether the item should be removed or not, and the second one indicates whether we should stop iterating or not.</p></div></div></div></body></html>