- en: Parsing arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we call `flag.Args` (as opposed to `os.Args`), we receive a slice of arguments
    excluding the flags. This allows us to mix flag arguments and non-flag arguments
    in the same tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want our tool to be able to be used in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove a path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To list all paths:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To achieve this, since we have already dealt with flags, we must check the first
    (non-flag) argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply switch on the first argument after setting it to lowercase (if
    the user types `backup LIST`, we still want it to work).
  prefs: []
  type: TYPE_NORMAL
- en: Listing the paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To list the paths in the database, we are going to use a `ForEach` method on
    the path''s `col` variable. Add the following code to the list case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We pass in a callback function to `ForEach`, which will be called for every
    item in that collection. We then unmarshal it from JSON into our `path` type,
    and just print it out using `fmt.Printf`. We return `false` as per the `filedb`
    interface, which tells us that returning `true` would stop iterating and that
    we want to make sure we list them all.
  prefs: []
  type: TYPE_NORMAL
- en: String representations for your own types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you print structs in Go in this way, using the `%s` format verbs, you can
    get some messy results that are difficult for users to read. If, however, the
    type implements a `String()` string method, it will be used instead, and we can
    use this to control what gets printed. Below the path struct, add the following
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This tells the `path` type how it should represent itself as a string.
  prefs: []
  type: TYPE_NORMAL
- en: Adding paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a path, or many paths, we are going to iterate over the remaining arguments
    and call the `InsertJSON` method for each one. Add the following code to the `add`
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If the user hasn't specified any additional arguments, for example if they just
    called `backup add` without typing any paths, we will return a fatal error. Otherwise,
    we do the work and print out the path string (prefixed with a `+` symbol) to indicate
    that it was successfully added. By default, we'll set the hash to the `Not yet
    archived` string literal this is an invalid hash but serves the dual purposes
    of letting the user know that it hasn't yet been archived as well as indicating
    as such to our code (given that a hash of the folder will never equal that string).
  prefs: []
  type: TYPE_NORMAL
- en: Removing paths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To remove a path, or many paths, we use the `RemoveEach` method for the path''s
    collection. Add the following code to the `remove` case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The callback function we provide to `RemoveEach` expects us to return two bool
    types: the first one indicates whether the item should be removed or not, and
    the second one indicates whether we should stop iterating or not.'
  prefs: []
  type: TYPE_NORMAL
