- en: Caching data
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存数据
- en: We can now query all existing paths and update the `Paths` map, which is a useful
    technique to increase the speed of a program, especially given slow or disconnected
    data stores. By loading the data into a cache (in our case, the `Paths` map),
    we can access it at lightning speed without having to consult the files each time
    we need information.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以查询所有现有路径并更新 `Paths` 映射，这是一种有用的技术，可以增加程序的速度，尤其是在面对缓慢或断开连接的数据存储时。通过将数据加载到缓存中（在我们的例子中是
    `Paths` 映射），我们可以在需要信息时无需每次都咨询文件，以闪电般的速度访问它。
- en: 'Add the following code to the body of the `main` function:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `main` 函数的主体中：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using the `ForEach` method again allows us to iterate over all the paths in
    the database. We unmarshal the JSON bytes into the same `path` structure as we
    used in our other program and set the values in the `Paths` map. Assuming that
    nothing goes wrong, we do a final check to make sure there is at least one path,
    and if not, we return with an error.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用 `ForEach` 方法允许我们在数据库中遍历所有路径。我们将 JSON 字节反序列化到与我们在其他程序中使用的相同 `path` 结构中，并在
    `Paths` 映射中设置值。假设一切顺利，我们进行最后的检查以确保至少有一条路径，如果没有，我们返回错误。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One limitation to our program is that it will not dynamically add paths once
    it has started. The daemon would need to be restarted. If this bothers you, you
    can always build in a mechanism that updates the `Paths` map periodically or uses
    some other kind of configuration management.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序的一个限制是，一旦开始运行，它将不会动态添加路径。守护进程需要重启。如果您觉得这很麻烦，您总是可以构建一个机制，定期更新 `Paths` 映射或使用其他类型的配置管理。
