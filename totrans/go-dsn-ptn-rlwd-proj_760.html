<html><head></head><body>
<div class="book" title="The daemon backup tool">
<div class="book" title="Infinite loops"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch08lvl2sec0089" class="calibre1"/>Infinite loops</h2></div></div></div><p class="calibre10">The next thing we need to do is perform a check on the hashes right away to see whether anything needs archiving before entering into an infinite timed loop where we perform the check again at regular, specified intervals.</p><p class="calibre10">An infinite loop sounds like a bad idea; in fact, to some, it sounds like a bug. However, since we're talking about an infinite loop within this program, and since infinite loops can be easily broken with a simple <code class="email">break</code> command, they're not as dramatic as they might sound. When we mix an infinite loop with a select statement that has no default case, we are able to run the code in a manageable way without gobbling up CPU cycles as we wait for something to happen. The execution will be blocked until one of the two channels receive data.</p><p class="calibre10">In Go, to write an infinite loop is as simple as running this:</p><pre class="programlisting">for {} 
</pre><p class="calibre10">The instructions inside the braces get executed over and over again, as quickly as the machine running the code can execute them. Again, this sounds like a bad plan unless you're careful about what you're asking it to do. In our case, we are immediately initiating a <code class="email">select</code> case on the two channels that will block safely until one of the channels has something interesting to say.</p><p class="calibre10">Add the following code:</p><pre class="programlisting">check(m, col) 
signalChan := make(chan os.Signal, 1) 
signal.Notify(signalChan, syscall.SIGINT, syscall.SIGTERM) 
for { 
  select { 
  case &lt;-time.After(*interval): 
    check(m, col) 
  case &lt;-signalChan: 
    // stop 
    fmt.Println() 
    log.Printf("Stopping...") 
    return 
  } 
} 
</pre><p class="calibre10">Of course, as responsible programmers, we care about what happens when the user terminates our programs. So after a call to the <code class="email">check</code> method (which doesn't yet exist), we make a signal channel and use <code class="email">signal.Notify</code> to ask for the termination signal to be given to the channel rather than it being handled automatically. In our infinite <code class="email">for</code> loop, we select two possibilities: either the <code class="email">timer</code> channel sends a message or the termination signal channel sends a message. If it's the <code class="email">timer</code> channel message, we call <code class="email">check</code> again; if it's <code class="email">signalChan</code>, we go about terminating the program; otherwise, we'll loop back and wait.</p><p class="calibre10">The <code class="email">time.After</code> function returns a channel that will send a signal (actually, the current time) after the specified time has elapsed. Since we are using <code class="email">flag.Duration</code>, we can pass this (deferenced via <code class="email">*</code>) as the <code class="email">time.Duration</code> argument directly into the function. Using <code class="email">flag.Duration</code> also means that users can specify time durations in a human readable way, such asÂ <code class="email">10s</code> for 10 seconds or <code class="email">1m</code> for a minute.</p><p class="calibre10">Finally, we return from the main function, causing the deferred statements to execute, such as closing the database connection.</p></div></div></body></html>