- en: Infinite loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next thing we need to do is perform a check on the hashes right away to
    see whether anything needs archiving before entering into an infinite timed loop
    where we perform the check again at regular, specified intervals.
  prefs: []
  type: TYPE_NORMAL
- en: An infinite loop sounds like a bad idea; in fact, to some, it sounds like a
    bug. However, since we're talking about an infinite loop within this program,
    and since infinite loops can be easily broken with a simple `break` command, they're
    not as dramatic as they might sound. When we mix an infinite loop with a select
    statement that has no default case, we are able to run the code in a manageable
    way without gobbling up CPU cycles as we wait for something to happen. The execution
    will be blocked until one of the two channels receive data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, to write an infinite loop is as simple as running this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The instructions inside the braces get executed over and over again, as quickly
    as the machine running the code can execute them. Again, this sounds like a bad
    plan unless you're careful about what you're asking it to do. In our case, we
    are immediately initiating a `select` case on the two channels that will block
    safely until one of the channels has something interesting to say.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, as responsible programmers, we care about what happens when the
    user terminates our programs. So after a call to the `check` method (which doesn''t
    yet exist), we make a signal channel and use `signal.Notify` to ask for the termination
    signal to be given to the channel rather than it being handled automatically.
    In our infinite `for` loop, we select two possibilities: either the `timer` channel
    sends a message or the termination signal channel sends a message. If it''s the
    `timer` channel message, we call `check` again; if it''s `signalChan`, we go about
    terminating the program; otherwise, we''ll loop back and wait.'
  prefs: []
  type: TYPE_NORMAL
- en: The `time.After` function returns a channel that will send a signal (actually,
    the current time) after the specified time has elapsed. Since we are using `flag.Duration`,
    we can pass this (deferenced via `*`) as the `time.Duration` argument directly
    into the function. Using `flag.Duration` also means that users can specify time
    durations in a human readable way, such asÂ `10s` for 10 seconds or `1m` for a
    minute.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we return from the main function, causing the deferred statements to
    execute, such as closing the database connection.
  prefs: []
  type: TYPE_NORMAL
