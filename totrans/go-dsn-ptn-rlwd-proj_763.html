<html><head></head><body><div class="book" title="Summary" id="5UNGG1-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch08lvl1sec0054" class="calibre1"/>Summary</h1></div></div></div><p class="calibre10">In this chapter, we successfully built a very simple backup system for your code projects. You can see how simple it would be to extend or modify the behavior of these programs. The scope for potential problems that you could go on to solve is limitless.</p><p class="calibre10">Rather than having a local archive destination folder like we did in the previous section, imagine mounting a network storage device and using that instead. Suddenly, you have off-site (or at least off-machine) backups of these vital files. You can easily set a Dropbox folder as the archive destination, which would mean that not only do you get access to the snapshots yourself, but a copy is also stored in the cloud and can even be shared with other users.</p><p class="calibre10">Extending the <code class="email">Archiver</code> interface to support <code class="email">Restore</code> operations (which would just use the <code class="email">encoding/zip</code> package to unzip the files) allows you to build tools that can peer inside the archives and access the changes of individual files, much like Time Machine on a Mac allows you to do. Indexing the files gives you the complete search across the entire history of your code, much like GitHub does.</p><p class="calibre10">Since the filenames are timestamps, you could have backupd retiring old archives to less active storage mediums or summarized the changes into a daily dump.</p><p class="calibre10">Obviously, backup software exists, is well tested, and is used throughout the world, and it may be a smart move to focus on solving problems that haven't been solved yet. But when it requires such little effort to write small programs to get things done, it is often worth doing because of the control it gives you. When you write the code, you can get exactly what you want without compromise, and it's down to each individual to make that call.</p><p class="calibre10">Specifically, in this chapter, we explored how easy Go's standard library makes it to interact with the filesystem: opening files for reading, creating new files, and making directories. The <code class="email">os</code> package mixed in with the powerful types from the <code class="email">io</code> package, blended further with capabilities such as <code class="email">encoding/zip</code> and others, gives a clear example of how extremely simple Go interfaces can be composed to deliver very powerful results.</p></div></body></html>