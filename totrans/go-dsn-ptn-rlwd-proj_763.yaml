- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we successfully built a very simple backup system for your
    code projects. You can see how simple it would be to extend or modify the behavior
    of these programs. The scope for potential problems that you could go on to solve
    is limitless.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than having a local archive destination folder like we did in the previous
    section, imagine mounting a network storage device and using that instead. Suddenly,
    you have off-site (or at least off-machine) backups of these vital files. You
    can easily set a Dropbox folder as the archive destination, which would mean that
    not only do you get access to the snapshots yourself, but a copy is also stored
    in the cloud and can even be shared with other users.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the `Archiver` interface to support `Restore` operations (which would
    just use the `encoding/zip` package to unzip the files) allows you to build tools
    that can peer inside the archives and access the changes of individual files,
    much like Time Machine on a Mac allows you to do. Indexing the files gives you
    the complete search across the entire history of your code, much like GitHub does.
  prefs: []
  type: TYPE_NORMAL
- en: Since the filenames are timestamps, you could have backupd retiring old archives
    to less active storage mediums or summarized the changes into a daily dump.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, backup software exists, is well tested, and is used throughout the
    world, and it may be a smart move to focus on solving problems that haven't been
    solved yet. But when it requires such little effort to write small programs to
    get things done, it is often worth doing because of the control it gives you.
    When you write the code, you can get exactly what you want without compromise,
    and it's down to each individual to make that call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, we explored how easy Go''s standard library
    makes it to interact with the filesystem: opening files for reading, creating
    new files, and making directories. The `os` package mixed in with the powerful
    types from the `io` package, blended further with capabilities such as `encoding/zip`
    and others, gives a clear example of how extremely simple Go interfaces can be
    composed to deliver very powerful results.'
  prefs: []
  type: TYPE_NORMAL
