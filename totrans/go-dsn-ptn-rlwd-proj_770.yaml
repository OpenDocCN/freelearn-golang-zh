- en: Deploying simple applications to Google App Engine
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将简单应用程序部署到 Google App Engine
- en: 'To truly understand the power of Google App Engine''s NoOps promise, we are
    going to deploy this simple application to the cloud. Back in the terminal, stop
    the server by hitting *Ctrl*+*C* and run the following command:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正理解 Google App Engine 无操作（NoOps）承诺的力量，我们将把这个简单的应用程序部署到云端。回到终端，通过按 *Ctrl*+*C*
    停止服务器，然后运行以下命令：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Your application will be packaged and uploaded to Google''s servers. Once it''s
    finished, you should see something like the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序将被打包并上传到 Google 的服务器。一旦完成，你应该会看到以下类似的内容：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It really is as simple as that.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是这么简单。
- en: You can prove this by navigating to the endpoint you get for free with every
    Google App Engine application, remembering to replace the application ID with
    your own: `https://YOUR_APPLICATION_ID_HERE.appspot.com/`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过导航到每个 Google App Engine 应用程序免费获得的端点来证明这一点，记得用你自己的应用程序 ID 替换：`https://YOUR_APPLICATION_ID_HERE.appspot.com/`。
- en: You will see the same output as earlier (the font may render differently since
    Google's servers will make assumptions about the content type that the local dev
    server doesn't).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到与之前相同的输出（字体渲染可能会有所不同，因为 Google 的服务器会对内容类型做出假设，而本地开发服务器不会）。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The application is being served over HTTP/2 and is already capable of pretty
    massive scale, and all we did was write a `config` file and a few lines of code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序正在通过 HTTP/2 提供，并且已经能够处理相当大规模的流量，而我们所做的只是编写了一个 `config` 文件和几行代码。
