<html><head></head><body>
<div class="book" title="Google Cloud Datastore" id="60KHK1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Denormalizing data"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec0097" class="calibre1"/>Denormalizing data</h2></div></div></div><p class="calibre10">Developers with experience of relational databases (RDBMS) will often aim to reduce data redundancy (trying to have each piece of data appear only once in their database) by <span class="strong"><strong class="calibre2">normalizing</strong></span> data, spreading it across many tables, and adding references (foreign keys) before joining it back via a query to build a complete picture. In schemaless and NoSQL databases, we tend to do the opposite. We <span class="strong"><strong class="calibre2">denormalize</strong></span> data so that each document contains the complete picture it needs, making read times extremely fast since it only needs to go and get a single thing.</p><p class="calibre10">For example, consider how we might model tweets in a relational database such as MySQL or Postgres:</p><p class="calibre10">
</p><div class="mediaobject"><img src="../images/00066.jpeg" alt="Denormalizing data" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">
</p><p class="calibre10">A tweet itself contains only its unique ID, a foreign key reference to the Users table representing the author of the tweet, and perhaps many URLs that were mentioned in <code class="email">TweetBody</code>.</p><p class="calibre10">One nice feature of this design is that a user can change their Name or AvatarURL and it will be reflected in all of their tweets, past and future, something you wouldn't get for free in a denormalized world.</p><p class="calibre10">However, in order to present a tweet to the user, we must load the tweet itself, look up (via a join) the user to get their name and avatar URL, and then load the associated data from the URLs table in order to show a preview of any links. At scale, this becomes difficult because all three tables of data might well be physically separated from each other, which means lots of things need to happen in order to build up this complete picture.</p><p class="calibre10">Consider what a denormalized design would look like instead:</p><p class="calibre10">
</p><div class="mediaobject"><img src="../images/00067.jpeg" alt="Denormalizing data" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre10">
</p><p class="calibre10">We still have the same three buckets of data, except that now our tweet contains everything it needs in order to render to the user without having to look up data from anywhere else. The hardcore relational database designers out there are realizing what this means by now, and it is no doubt making them feel uneasy.</p><p class="calibre10">Following this approach means that:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Data is repeated - <code class="email">AvatarURL</code> in User is repeated as <code class="email">UserAvatarURL</code> in the tweet (waste of space, right?)</li><li class="listitem">If the user changes their <code class="email">AvatarURL</code>, <code class="email">UserAvatarURL</code> in the tweet will be out of date</li></ul></div><p class="calibre10">Database design, at the end of the day, comes down to physics. We are deciding that our tweet is going to be read far more times than it is going to be written, so we'd rather take the pain upfront and take a hit in storage. There's nothing wrong with repeated data as long as there is an understanding about which set is the master set and which is duplicated for speed.</p><p class="calibre10">Changing data is an interesting topic in itself, but let's think about a few reasons why we might be OK with the trade-offs.</p><p class="calibre10">Firstly, the speed benefit to reading tweets is probably worth the unexpected behavior of changes to master data not being reflected in historical documents; it would be perfectly acceptable to decide to live with this emerged functionality for that reason.</p><p class="calibre10">Secondly, we might decide that it makes sense to keep a snapshot of data at a specific moment in time. For example, imagine if someone tweets asking whether people like their profile picture. If the picture changed, the tweet context would be lost. For a more serious example, consider what might happen if you were pointing to a row in an Addresses table for an order delivery and the address later changed. Suddenly, the order might look like it was shipped to a different place.</p><p class="calibre10">Finally, storage is becoming increasingly cheaper, so the need for normalizing data to save space is lessened. Twitter even goes as far as copying the entire tweet document for each of your followers. 100 followers on Twitter means that your tweet will be copied at least 100 times, maybe more for redundancy. This sounds like madness to relational database enthusiasts, but Twitter is making smart trade-offs based on its user experience; they'll happily spend a lot of time writing a tweet and storing it many times to ensure that when you refresh your feed, you don't have to wait very long to get updates.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note00137" class="calibre1"/>Note</h3><p class="calibre10">If you want to get a sense of the scale of this, check out the Twitter API and look at what a tweet document consists of. It's a lot of data. Then, go and look at how many followers Lady Gaga has. This has become known in some circles as "the Lady Gaga problem" and is addressed by a variety of different technologies and techniques that are out of the scope of this chapter.</p></div><p class="calibre10">Now that we have an understanding of good NoSQL design practices, let's implement the types, functions, and methods required to drive the data part of our API.</p></div></div></body></html>