- en: Denormalizing data
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据去规范化
- en: Developers with experience of relational databases (RDBMS) will often aim to
    reduce data redundancy (trying to have each piece of data appear only once in
    their database) by **normalizing** data, spreading it across many tables, and
    adding references (foreign keys) before joining it back via a query to build a
    complete picture. In schemaless and NoSQL databases, we tend to do the opposite.
    We **denormalize** data so that each document contains the complete picture it
    needs, making read times extremely fast since it only needs to go and get a single
    thing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有关系数据库（RDBMS）经验的开发者通常会通过**规范化**数据来减少数据冗余（试图让每条数据只在其数据库中显示一次），将数据分散到许多表中，并在连接之前添加引用（外键），然后通过查询将其连接起来以构建一个完整的画面。在无模式和NoSQL数据库中，我们倾向于做相反的事情。我们**去规范化**数据，以便每个文档都包含它需要的完整画面，这使得读取时间非常快，因为它只需要获取一个单一的事物。
- en: 'For example, consider how we might model tweets in a relational database such
    as MySQL or Postgres:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑我们如何在MySQL或Postgres等关系数据库中建模推文：
- en: '![Denormalizing data](img/00066.jpeg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![数据去规范化](img/00066.jpeg)'
- en: A tweet itself contains only its unique ID, a foreign key reference to the Users
    table representing the author of the tweet, and perhaps many URLs that were mentioned
    in `TweetBody`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一条推文本身只包含其唯一的ID，一个指向表示推文作者的Users表的键外参照，以及可能被提及在`TweetBody`中的许多URL。
- en: One nice feature of this design is that a user can change their Name or AvatarURL
    and it will be reflected in all of their tweets, past and future, something you
    wouldn't get for free in a denormalized world.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计的一个优点是，用户可以更改他们的姓名或AvatarURL，这将反映在他们过去和未来的所有推文中，这在去规范化世界中是免费得不到的。
- en: However, in order to present a tweet to the user, we must load the tweet itself,
    look up (via a join) the user to get their name and avatar URL, and then load
    the associated data from the URLs table in order to show a preview of any links.
    At scale, this becomes difficult because all three tables of data might well be
    physically separated from each other, which means lots of things need to happen
    in order to build up this complete picture.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了向用户展示一条推文，我们必须加载推文本身，通过连接查找用户以获取他们的姓名和头像URL，然后从URL表加载相关数据以显示链接的预览。在规模上，这变得很困难，因为所有三个数据表可能都物理上彼此分离，这意味着需要发生很多事情才能构建出这个完整的画面。
- en: 'Consider what a denormalized design would look like instead:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下去规范化设计会是什么样子：
- en: '![Denormalizing data](img/00067.jpeg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![数据去规范化](img/00067.jpeg)'
- en: We still have the same three buckets of data, except that now our tweet contains
    everything it needs in order to render to the user without having to look up data
    from anywhere else. The hardcore relational database designers out there are realizing
    what this means by now, and it is no doubt making them feel uneasy.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有三个相同的数据桶，但现在我们的推文包含了渲染给用户所需的所有内容，无需从其他地方查找数据。现在，那些硬核的关系数据库设计者已经开始意识到这意味着什么，这无疑让他们感到不安。
- en: 'Following this approach means that:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法意味着：
- en: Data is repeated - `AvatarURL` in User is repeated as `UserAvatarURL` in the
    tweet (waste of space, right?)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据是重复的 - 用户表中的`AvatarURL`在推文中重复为`UserAvatarURL`（浪费空间，对吧？）
- en: If the user changes their `AvatarURL`, `UserAvatarURL` in the tweet will be
    out of date
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户更改他们的`AvatarURL`，推文中的`UserAvatarURL`将过时
- en: Database design, at the end of the day, comes down to physics. We are deciding
    that our tweet is going to be read far more times than it is going to be written,
    so we'd rather take the pain upfront and take a hit in storage. There's nothing
    wrong with repeated data as long as there is an understanding about which set
    is the master set and which is duplicated for speed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，数据库设计归结为物理。我们决定我们的推文将被阅读得比写入得多，所以我们宁愿在前期承受痛苦，在存储上做出牺牲。只要理解哪个集合是主集，哪个是为了速度而复制的，重复的数据就没有问题。
- en: Changing data is an interesting topic in itself, but let's think about a few
    reasons why we might be OK with the trade-offs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数据更改本身是一个有趣的话题，但让我们考虑一下我们可能接受权衡的几个原因。
- en: Firstly, the speed benefit to reading tweets is probably worth the unexpected
    behavior of changes to master data not being reflected in historical documents;
    it would be perfectly acceptable to decide to live with this emerged functionality
    for that reason.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，读取推文的速度优势可能值得意外行为，即主数据的变化没有反映在历史文档中；出于这个原因，决定接受这种出现的功能是完全可以接受的。
- en: Secondly, we might decide that it makes sense to keep a snapshot of data at
    a specific moment in time. For example, imagine if someone tweets asking whether
    people like their profile picture. If the picture changed, the tweet context would
    be lost. For a more serious example, consider what might happen if you were pointing
    to a row in an Addresses table for an order delivery and the address later changed.
    Suddenly, the order might look like it was shipped to a different place.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可能会决定在特定时间点保留数据的快照是有意义的。例如，想象一下如果有人发推文询问人们是否喜欢他们的个人资料图片。如果图片改变了，推文上下文就会丢失。对于更严重的例子，考虑一下如果你在指向一个订单交付的地址表中的行，而地址后来发生了变化，可能会发生什么。突然之间，订单可能看起来像是要运送到不同的地方。
- en: Finally, storage is becoming increasingly cheaper, so the need for normalizing
    data to save space is lessened. Twitter even goes as far as copying the entire
    tweet document for each of your followers. 100 followers on Twitter means that
    your tweet will be copied at least 100 times, maybe more for redundancy. This
    sounds like madness to relational database enthusiasts, but Twitter is making
    smart trade-offs based on its user experience; they'll happily spend a lot of
    time writing a tweet and storing it many times to ensure that when you refresh
    your feed, you don't have to wait very long to get updates.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，存储正变得越来越便宜，因此为了节省空间而进行数据规范化的需求减少了。Twitter甚至走得更远，为你的每个关注者复制整个推文文档。Twitter上有100个关注者意味着你的推文至少会被复制100次，可能更多以增加冗余。这对于关系型数据库爱好者来说听起来像是疯狂，但Twitter正在基于其用户体验做出明智的权衡；他们愿意花很多时间撰写推文并多次存储，以确保当你刷新你的信息流时，你不必等待很长时间才能获取更新。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to get a sense of the scale of this, check out the Twitter API and
    look at what a tweet document consists of. It's a lot of data. Then, go and look
    at how many followers Lady Gaga has. This has become known in some circles as
    "the Lady Gaga problem" and is addressed by a variety of different technologies
    and techniques that are out of the scope of this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解这个规模的感受，请查看Twitter API并查看推文文档由什么组成。这是一大批数据。然后，去看看Lady Gaga有多少关注者。这在某些圈子中已经成为“Lady
    Gaga问题”，并且通过各种不同的技术和方法来解决，这些技术和方法超出了本章的范围。
- en: Now that we have an understanding of good NoSQL design practices, let's implement
    the types, functions, and methods required to drive the data part of our API.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了良好的NoSQL设计实践，让我们来实现驱动我们API数据部分的类型、函数和方法。
