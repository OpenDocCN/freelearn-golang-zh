- en: Putting data into Google Cloud Datastore
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据放入 Google Cloud Datastore
- en: 'Before we save data into Datastore, we want to ensure that our question is
    valid. Add the following method underneath the Question struct definition:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将数据保存到 Datastore 之前，我们想确保我们的问题是有效的。在 `Question` 结构定义下方添加以下方法：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `OK` function will return an error if something is wrong with the question,
    or else it will return `nil`. In this case, we just check to make sure the question
    has at least 10 characters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果问题有误，`OK` 函数将返回一个错误，否则将返回 `nil`。在这种情况下，我们只是确保问题至少有 10 个字符。
- en: 'To persist this data in the data store, we are going to add a method to the
    `Question` struct itself. At the bottom of `questions.go`, add the following code:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在数据存储中持久化这些数据，我们将在 `Question` 结构本身中添加一个方法。在 `questions.go` 的底部添加以下代码：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Create` method takes a pointer to `Question` as the receiver, which is
    important because we want to make changes to the fields.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '`Create` 方法接收一个指向 `Question` 的指针作为接收者，这很重要，因为我们想修改字段。'
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the receiver was `(q Question)` without `*`, we would get a copy of the question
    rather than a pointer to it, and any changes we made to it would only affect our
    local copy and not the original `Question` struct itself.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接收者没有 `*` 而是 `(q Question)`，我们将得到问题的副本而不是指向它的指针，我们对其所做的任何更改都只会影响我们的本地副本，而不会影响原始的
    `Question` 结构本身。
- en: The first thing we do is use `log` (from the [https://godoc.org/google.golang.org/appengine/log](https://godoc.org/google.golang.org/appengine/log) package)
    to write a debug statement saying we are saving the question. When you run your
    code in a development environment, you will see this appear in the terminal; in
    production, it goes into a dedicated logging service provided by Google Cloud
    Platform.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 `log`（来自 [https://godoc.org/google.golang.org/appengine/log](https://godoc.org/google.golang.org/appengine/log)
    包）写入一个调试语句，说明我们正在保存问题。当你在一个开发环境中运行你的代码时，你将在终端看到这个输出；在生产环境中，它将进入由 Google Cloud
    Platform 提供的专用日志服务中。
- en: If the key is `nil` (that means this is a new question), we assign an incomplete
    key to the field, which informs Datastore that we want it to generate a key for
    us. The three arguments we pass are `context.Context` (which we must pass to all
    datastore functions and methods), a string describing the kind of entity, and
    the parent key; in our case, this is `nil`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果键是 `nil`（这意味着这是一个新问题），我们将一个不完整的键分配给字段，这会通知 Datastore 我们希望它为我们生成一个键。我们传递的三个参数是
    `context.Context`（我们必须将其传递给所有数据存储函数和方法）、描述实体类型的字符串和父键；在我们的情况下，这是 `nil`。
- en: Once we know there is a key in place, we call a method (which we will add later)
    to get or create `User` from an App Engine user and set it to the question and
    then set the `CTime` field (created time) to `time.Now`, timestamping the point
    at which the question was asked.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道有一个键在位，我们调用一个方法（我们稍后会添加）从 App Engine 用户获取或创建 `User` 并将其设置到问题中，然后设置 `CTime`
    字段（创建时间）为 `time.Now`，标记问题被提出的时间点。
- en: One we have our `Question` function in good shape, we call `datastore.Put` to
    actually place it inside the data store. As usual, the first argument is `context.Context`,
    followed by the question key and the question entity itself.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的 `Question` 函数处于良好状态，我们调用 `datastore.Put` 将其实际放入数据存储中。像往常一样，第一个参数是 `context.Context`，然后是问题键和问题实体本身。
- en: 'Since Google Cloud Datastore treats keys as separate and distinct from entities,
    we have to do a little extra work if we want to keep them together in our own
    code. The `datastore.Put` method returns two arguments: the complete key and `error`.
    The key argument is actually useful because we''re sending in an incomplete key
    and asking the data store to create one for us, which it does during the put operation.
    If successful, it returns a new `datastore.Key` object to us, representing the
    completed key, which we then store in our `Key` field in the `Question` object.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Google Cloud Datastore 将键视为独立且与实体不同的，如果我们想在我们的代码中将它们放在一起，我们就必须做一些额外的工作。`datastore.Put`
    方法返回两个参数：完整的键和 `error`。键参数实际上是有用的，因为我们发送了一个不完整的键并要求数据存储为我们创建一个，它在 put 操作期间完成。如果成功，它返回一个新的
    `datastore.Key` 对象给我们，代表完整的键，然后我们将其存储在 `Question` 对象的 `Key` 字段中。
- en: If all is well, we return `nil`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们返回 `nil`。
- en: 'Add another helper to update an existing question:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 添加另一个辅助方法来更新现有的问题：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This method is very similar except that it doesn't set the `CTime` or `User`
    fields, as they will already have been set.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法非常相似，只是它没有设置 `CTime` 或 `User` 字段，因为它们已经设置好了。
