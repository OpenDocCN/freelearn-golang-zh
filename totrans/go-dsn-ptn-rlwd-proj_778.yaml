- en: Google App Engine users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another service we are going to make use of is the Google App Engine Users API,
    which provides the authentication of Google accounts (and Google Apps accounts).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `users.go` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `Question` struct, we have `Key` and a few fields that make up
    the `User` entity. This struct represents an object that belongs to our application
    that describes a user; we will have one for every authenticated user in our system,
    but this isn't the same user object that we'll get from the Users API.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the [https://godoc.org/google.golang.org/appengine/user](https://godoc.org/google.golang.org/appengine/user)Â package
    and calling the `user.Current(context.Context)` function will return either nil
    (if no user is authenticated) or a `user.User` object. This object belongs to
    the Users API and isn't suitable for our data store, so we need to write a helper
    function that will translate the App Engine user into our `User`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Watch out that `goimports` doesn't automatically import `os/user` instead; sometimes
    it's best if you handle imports manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `users.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We get the currently authenticated user by calling `user.Current`, and if it
    is `nil`, we return with an error. This means that the user is not logged in and
    the operation cannot complete. Our web package will be checking and ensuring that
    users are logged in for us, so by the time they hit an API endpoint, we'll expect
    them to be authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new `appUser` variable (which is of our `User` type) and set
    `datastore.Key`. This time, we aren't making an incomplete key; instead, we are
    using `datastore.NewKey` and specifying a string ID, matching the User API ID.
    This key predictability means that not only will there only be one `User` entity
    per authenticated user in our application, but it also allows us to load a `User`
    entity without having to use a query.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we had the App Engine User ID as a field instead, we would need to do a query
    to find the record we are interested in. Querying is a more expensive operation
    compared to a direct `Get` method, so this approach is always preferred if you
    can do it.
  prefs: []
  type: TYPE_NORMAL
- en: We then call `datastore.Get` to attempt to load the `User` entity. If this is
    the first time the user has logged in, there will be no entity and the returned
    error will be the special `datastore.ErrNoSuchEntity` variable. If that's the
    case, we set the appropriate fields and use `datastore.Put` to save it. Otherwise,
    we just return the loaded `User`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we are checking for early returns in this function. This is to ensure
    that it is easy to read the execution flow of our code without having to follow
    it in and out of indented blocks. I call this the line of sight of code and have
    written about it on my blog at [https://medium.com/@matryer](https://medium.com/@matryer).
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we''ll use Gravatar again for avatar pictures, so add the following
    helper function to the bottom of `users.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
