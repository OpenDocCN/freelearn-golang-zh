- en: Google App Engine users
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google App Engine 用户
- en: Another service we are going to make use of is the Google App Engine Users API,
    which provides the authentication of Google accounts (and Google Apps accounts).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用另一个服务是 Google App Engine Users API，它提供 Google 帐户（和 Google Apps 帐户）的认证。
- en: 'Create a new file called `users.go` and add the following code:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `users.go` 的新文件，并添加以下代码：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Similar to the `Question` struct, we have `Key` and a few fields that make up
    the `User` entity. This struct represents an object that belongs to our application
    that describes a user; we will have one for every authenticated user in our system,
    but this isn't the same user object that we'll get from the Users API.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Question` 结构体类似，我们有 `Key` 和一些组成 `User` 实体的字段。此结构体代表属于我们应用程序的对象，描述了一个用户；在我们的系统中，我们将为每个认证用户有一个，但这不是我们从
    Users API 获得的用户对象。
- en: Importing the [https://godoc.org/google.golang.org/appengine/user](https://godoc.org/google.golang.org/appengine/user) package
    and calling the `user.Current(context.Context)` function will return either nil
    (if no user is authenticated) or a `user.User` object. This object belongs to
    the Users API and isn't suitable for our data store, so we need to write a helper
    function that will translate the App Engine user into our `User`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 [https://godoc.org/google.golang.org/appengine/user](https://godoc.org/google.golang.org/appengine/user)
    包并调用 `user.Current(context.Context)` 函数将返回 nil（如果没有用户认证）或 `user.User` 对象。此对象属于
    Users API，不适合我们的数据存储，因此我们需要编写一个辅助函数，将 App Engine 用户转换为我们的 `User`。
- en: Tip
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Watch out that `goimports` doesn't automatically import `os/user` instead; sometimes
    it's best if you handle imports manually.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `goimports` 不会自动导入 `os/user`；有时最好手动处理导入。
- en: 'Add the following code to `users.go`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `users.go`：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We get the currently authenticated user by calling `user.Current`, and if it
    is `nil`, we return with an error. This means that the user is not logged in and
    the operation cannot complete. Our web package will be checking and ensuring that
    users are logged in for us, so by the time they hit an API endpoint, we'll expect
    them to be authenticated.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 `user.Current` 来获取当前认证的用户，如果它是 `nil`，则返回错误。这意味着用户未登录，操作无法完成。我们的 web 包将为我们检查并确保用户已登录，因此当他们到达
    API 端点时，我们期望他们已经认证。
- en: We then create a new `appUser` variable (which is of our `User` type) and set
    `datastore.Key`. This time, we aren't making an incomplete key; instead, we are
    using `datastore.NewKey` and specifying a string ID, matching the User API ID.
    This key predictability means that not only will there only be one `User` entity
    per authenticated user in our application, but it also allows us to load a `User`
    entity without having to use a query.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个新的 `appUser` 变量（它属于我们的 `User` 类型）并设置 `datastore.Key`。这次，我们不是创建一个不完整的键；相反，我们使用
    `datastore.NewKey` 并指定一个字符串 ID，与 User API ID 匹配。这个键的可预测性意味着在我们的应用程序中，每个认证用户将只有一个
    `User` 实体，同时也允许我们无需使用查询即可加载 `User` 实体。
- en: Tip
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If we had the App Engine User ID as a field instead, we would need to do a query
    to find the record we are interested in. Querying is a more expensive operation
    compared to a direct `Get` method, so this approach is always preferred if you
    can do it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 App Engine 用户 ID 作为字段，我们就需要执行查询以找到我们感兴趣的记录。与直接 `Get` 方法相比，查询是一个更昂贵的操作，因此如果可能，我们始终首选这种方法。
- en: We then call `datastore.Get` to attempt to load the `User` entity. If this is
    the first time the user has logged in, there will be no entity and the returned
    error will be the special `datastore.ErrNoSuchEntity` variable. If that's the
    case, we set the appropriate fields and use `datastore.Put` to save it. Otherwise,
    we just return the loaded `User`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后调用 `datastore.Get` 来尝试加载 `User` 实体。如果这是用户第一次登录，将不会有实体，返回的错误将是特殊的 `datastore.ErrNoSuchEntity`
    变量。如果是这种情况，我们设置适当的字段，并使用 `datastore.Put` 来保存它。否则，我们只需返回加载的 `User`。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we are checking for early returns in this function. This is to ensure
    that it is easy to read the execution flow of our code without having to follow
    it in and out of indented blocks. I call this the line of sight of code and have
    written about it on my blog at [https://medium.com/@matryer](https://medium.com/@matryer).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在该函数中检查了早期返回。这是为了确保在不跟随代码的缩进块进进出出的情况下，代码的执行流程易于阅读。我称之为代码的视线，并在我的博客 [https://medium.com/@matryer](https://medium.com/@matryer)
    上写了一些关于它的内容。
- en: 'For now, we''ll use Gravatar again for avatar pictures, so add the following
    helper function to the bottom of `users.go`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将再次使用Gravatar来处理头像图片，因此请将以下辅助函数添加到`users.go`文件的底部：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
