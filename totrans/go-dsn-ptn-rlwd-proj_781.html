<html><head></head><body>
<div class="book" title="Transactions in Google Cloud Datastore">
<div class="book" title="Using transactions to maintain counters"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec00102" class="calibre1"/>Using transactions to maintain counters</h2></div></div></div><p class="calibre10">Our <code class="email">Question</code> struct has a field called <code class="email">AnswerCount</code>, where we intend to store an integer that represents the number of answers that a question has solicited.</p><p class="calibre10">First, let's look at what can happen if we don't use a transaction to keep track of the <code class="email">AnswerCount</code> field by tracking the concurrent activity of answers 4 and 5 of a question:</p><div class="informaltable"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/><col class="calibre19"/><col class="calibre19"/></colgroup><tbody class="calibre20"><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Step</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Answer 4</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Answer 5</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Question.AnswerCount</strong></span>
</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">1</p>
</td><td class="calibre22">
<p class="calibre23">Load question</p>
</td><td class="calibre22">
<p class="calibre23">Load question</p>
</td><td class="calibre22">
<p class="calibre23">3</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">2</p>
</td><td class="calibre22">
<p class="calibre23">AnswerCount=3</p>
</td><td class="calibre22">
<p class="calibre23">AnswerCount=3</p>
</td><td class="calibre22">
<p class="calibre23">3</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">3</p>
</td><td class="calibre22">
<p class="calibre23">AnswerCount++</p>
</td><td class="calibre22">
<p class="calibre23">AnswerCount++</p>
</td><td class="calibre22">
<p class="calibre23">3</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">4</p>
</td><td class="calibre22">
<p class="calibre23">AnswerCount=4</p>
</td><td class="calibre22">
<p class="calibre23">AnswerCount=4</p>
</td><td class="calibre22">
<p class="calibre23">3</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">5</p>
</td><td class="calibre22">
<p class="calibre23">Save the answer and question</p>
</td><td class="calibre22">
<p class="calibre23">Save the answer and question</p>
</td><td class="calibre22">
<p class="calibre23">4</p>
</td></tr></tbody></table></div><p class="calibre10">You can see from the table that without locking Question, AnswerCount would end up being 4 instead of 5 if the answers came in at the same time. Locking with a transaction will look more like this:</p><div class="informaltable"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/><col class="calibre19"/><col class="calibre19"/></colgroup><tbody class="calibre20"><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Step</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Answer 4</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Answer 5</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Question.AnswerCount</strong></span>
</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">1</p>
</td><td class="calibre22">
<p class="calibre23">Lock the question</p>
</td><td class="calibre22">
<p class="calibre23">Lock the question</p>
</td><td class="calibre22">
<p class="calibre23">3</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">2</p>
</td><td class="calibre22">
<p class="calibre23">AnswerCount=3</p>
</td><td class="calibre22">
<p class="calibre23">Waiting for unlock</p>
</td><td class="calibre22">
<p class="calibre23">3</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">3</p>
</td><td class="calibre22">
<p class="calibre23">AnswerCount++</p>
</td><td class="calibre22">
<p class="calibre23">Waiting for unlock</p>
</td><td class="calibre22">
<p class="calibre23">3</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">4</p>
</td><td class="calibre22">
<p class="calibre23">Save the answer and question</p>
</td><td class="calibre22">
<p class="calibre23">Waiting for unlock</p>
</td><td class="calibre22">
<p class="calibre23">4</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">5</p>
</td><td class="calibre22">
<p class="calibre23">Release lock</p>
</td><td class="calibre22">
<p class="calibre23">Waiting for unlock</p>
</td><td class="calibre22">
<p class="calibre23">4</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">6</p>
</td><td class="calibre22">
<p class="calibre23">Finished</p>
</td><td class="calibre22">
<p class="calibre23">Lock the question</p>
</td><td class="calibre22">
<p class="calibre23">4</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">7</p>
</td><td class="calibre22">
</td><td class="calibre22">
<p class="calibre23">AnswerCount=4</p>
</td><td class="calibre22">
<p class="calibre23">4</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">8</p>
</td><td class="calibre22">
</td><td class="calibre22">
<p class="calibre23">AnswerCount++</p>
</td><td class="calibre22">
<p class="calibre23">4</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">9</p>
</td><td class="calibre22">
</td><td class="calibre22">
<p class="calibre23">Save the answer and question</p>
</td><td class="calibre22">
<p class="calibre23">5</p>
</td></tr></tbody></table></div><p class="calibre10">In this case, whichever answer obtains the lock first will perform its operation, and the other operation will wait before continuing. This is likely to slow down the operation (since it has to wait for the other one to finish), but that's a price worth paying in order to get the numbers right.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip144" class="calibre1"/>Tip</h3><p class="calibre10">It's best to keep the amount of work inside a transaction as small as possible because you are essentially blocking other people while the transaction is underway. Outside of transactions, Google Cloud Datastore is extremely fast because it isn't making the same kinds of guarantees.</p></div><p class="calibre10">In code, we use the <code class="email">datastore.RunInTransaction</code> function. Add the following to <code class="email">answers.go</code>:</p><pre class="programlisting">func (a *Answer) Create(ctx context.Context, questionKey *datastore.Key) error { 
  a.Key = datastore.NewIncompleteKey(ctx, "Answer", questionKey) 
  user, err := UserFromAEUser(ctx) 
  if err != nil { 
    return err 
  } 
  a.User = user.Card() 
  a.CTime = time.Now() 
  err = datastore.RunInTransaction(ctx, func(ctx context.Context) error { 
    q, err := GetQuestion(ctx, questionKey) 
    if err != nil { 
      return err 
    } 
    err = a.Put(ctx) 
    if err != nil { 
      return err 
    } 
    q.AnswersCount++ 
    err = q.Update(ctx) 
    if err != nil { 
      return err 
    } 
    return nil 
  }, &amp;datastore.TransactionOptions{XG: true}) 
  if err != nil { 
    return err 
  } 
  return nil 
} 
</pre><p class="calibre10">We first create a new incomplete key (using the <code class="email">Answer</code> kind) and set the parent as the question key. This will mean that the question will become the ancestor to all these answers.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip145" class="calibre1"/>Tip</h3><p class="calibre10">Ancestor keys are special in Google Cloud Datastore, and it is recommended that you read about the nuances behind them in the documentation on the Google Cloud Platform website.</p></div><p class="calibre10">Using our <code class="email">UserFromAEUser</code> function, we get the user who is answering the question and set <code class="email">UserCard</code> inside <code class="email">Answer</code> before setting <code class="email">CTime</code> to the current time, as done earlier.</p><p class="calibre10">Then, we start our transaction by calling the <code class="email">datastore.RunInTransaction</code> function that takes a context as well as a function where the transactional code will go. There is a third argument, which is a set of <code class="email">datastore.TransactionOptions</code> that we need to use in order to set <code class="email">XG</code> to <code class="email">true</code>, which informs the data store that we'll be performing a transaction across entity groups (both <code class="email">Answer</code> and <code class="email">Question</code> kinds).</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip146" class="calibre1"/>Tip</h3><p class="calibre10">When it comes to writing your own functions and designing your own APIs, it is highly recommended that you place any function arguments at the end; otherwise, inline function blocks such as the ones in the preceding code obscure the fact that there is another argument afterwards. It's quite difficult to realize that the <code class="email">TransactionOptions</code> object is an argument being passed into the <code class="email">RunInTransaction</code> function, and I suspect somebody on the Google team regrets this decision.</p></div><p class="calibre10">Transactions work by providing a new context for us to use, which means that code inside the transaction function looks the same, as if it weren't in a transaction. This is a nice piece of API design (and it means that we can forgive the function for not being the final argument).</p><p class="calibre10">Inside the transaction function, we use our <code class="email">GetQuestion</code> helper to load the question. Loading data inside the transaction function is what obtains a lock on it. We then put the answer to save it, update the <code class="email">AnswerCount</code> integer, and update the question. If all is well (provided none of these steps returns an error), the answer will be saved and <code class="email">AnswerCount</code> will increase by one.</p><p class="calibre10">If we do return an error from our transaction function, the other operations are canceled and the error is returned. If that happens, we'll just return that error from our <code class="email">Answer.Create</code> method and let the user try again.</p><p class="calibre10">Next, we are going to add our <code class="email">GetAnswer</code> helper, which is similar to our <code class="email">GetQuestion</code> function:</p><pre class="programlisting">func GetAnswer(ctx context.Context, answerKey *datastore.Key)  
(*Answer, error) { 
  var answer Answer 
  err := datastore.Get(ctx, answerKey, &amp;answer) 
  if err != nil { 
    return nil, err 
  } 
  answer.Key = answerKey 
  return &amp;answer, nil 
} 
</pre><p class="calibre10">Now we are going to add our <code class="email">Put</code> helper method in <code class="email">answers.go</code>:</p><pre class="programlisting">func (a *Answer) Put(ctx context.Context) error { 
  var err error 
  a.Key, err = datastore.Put(ctx, a.Key, a) 
  if err != nil { 
    return err 
  } 
  return nil 
} 
</pre><p class="calibre10">These two functions are very similar to the <code class="email">GetQuestion</code> and <code class="email">Question.Put</code> methods, but let's resist the temptation of abstracting it and drying up the code for now.</p></div></div></body></html>