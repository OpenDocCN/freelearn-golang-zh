- en: Using transactions to maintain counters
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事务维护计数器
- en: Our `Question` struct has a field called `AnswerCount`, where we intend to store
    an integer that represents the number of answers that a question has solicited.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Question`结构体有一个名为`AnswerCount`的字段，我们打算在其中存储一个整数，表示一个问题所吸引的答案数量。
- en: 'First, let''s look at what can happen if we don''t use a transaction to keep
    track of the `AnswerCount` field by tracking the concurrent activity of answers
    4 and 5 of a question:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如果我们不使用事务来跟踪问题的答案4和5的并发活动以跟踪`AnswerCount`字段会发生什么：
- en: '| **Step** | **Answer 4** | **Answer 5** | **Question.AnswerCount** |'
  id: totrans-3
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **答案4** | **答案5** | **Question.AnswerCount** |'
- en: '| 1 | Load question | Load question | 3 |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 加载问题 | 加载问题 | 3 |'
- en: '| 2 | AnswerCount=3 | AnswerCount=3 | 3 |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 2 | AnswerCount=3 | AnswerCount=3 | 3 |'
- en: '| 3 | AnswerCount++ | AnswerCount++ | 3 |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| 3 | AnswerCount++ | AnswerCount++ | 3 |'
- en: '| 4 | AnswerCount=4 | AnswerCount=4 | 3 |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 4 | AnswerCount=4 | AnswerCount=4 | 3 |'
- en: '| 5 | Save the answer and question | Save the answer and question | 4 |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 保存答案和问题 | 保存答案和问题 | 4 |'
- en: 'You can see from the table that without locking Question, AnswerCount would
    end up being 4 instead of 5 if the answers came in at the same time. Locking with
    a transaction will look more like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从表中看到，如果没有锁定`Question`，当答案同时到达时，`AnswerCount`将最终为4而不是5。使用事务进行锁定将看起来像这样：
- en: '| **Step** | **Answer 4** | **Answer 5** | **Question.AnswerCount** |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **答案4** | **答案5** | **Question.AnswerCount** |'
- en: '| 1 | Lock the question | Lock the question | 3 |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 锁定问题 | 锁定问题 | 3 |'
- en: '| 2 | AnswerCount=3 | Waiting for unlock | 3 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 2 | AnswerCount=3 | 等待解锁 | 3 |'
- en: '| 3 | AnswerCount++ | Waiting for unlock | 3 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 3 | AnswerCount++ | 等待解锁 | 3 |'
- en: '| 4 | Save the answer and question | Waiting for unlock | 4 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 保存答案和问题 | 等待解锁 | 4 |'
- en: '| 5 | Release lock | Waiting for unlock | 4 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 释放锁 | 等待解锁 | 4 |'
- en: '| 6 | Finished | Lock the question | 4 |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 完成 | 锁定问题 | 4 |'
- en: '| 7 |  | AnswerCount=4 | 4 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 7 |  | AnswerCount=4 | 4 |'
- en: '| 8 |  | AnswerCount++ | 4 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 8 |  | AnswerCount++ | 4 |'
- en: '| 9 |  | Save the answer and question | 5 |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 9 |  | 保存答案和问题 | 5 |'
- en: In this case, whichever answer obtains the lock first will perform its operation,
    and the other operation will wait before continuing. This is likely to slow down
    the operation (since it has to wait for the other one to finish), but that's a
    price worth paying in order to get the numbers right.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，首先获得锁的答案将执行其操作，而另一个操作将在继续之前等待。这可能会减慢操作速度（因为它必须等待另一个操作完成），但为了得到正确的数字，这是值得付出的代价。
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's best to keep the amount of work inside a transaction as small as possible
    because you are essentially blocking other people while the transaction is underway.
    Outside of transactions, Google Cloud Datastore is extremely fast because it isn't
    making the same kinds of guarantees.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将事务内的工作量保持得尽可能小，因为当事务进行时，您实际上是在阻止其他人。在事务之外，Google Cloud Datastore非常快，因为它不提供相同类型的保证。
- en: 'In code, we use the `datastore.RunInTransaction` function. Add the following
    to `answers.go`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们使用`datastore.RunInTransaction`函数。将以下内容添加到`answers.go`中：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We first create a new incomplete key (using the `Answer` kind) and set the parent
    as the question key. This will mean that the question will become the ancestor
    to all these answers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的不完整键（使用`Answer`类型），并将父键设置为问题键。这意味着问题将成为所有这些答案的祖先。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Ancestor keys are special in Google Cloud Datastore, and it is recommended that
    you read about the nuances behind them in the documentation on the Google Cloud
    Platform website.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Google Cloud Datastore中，祖先键是特殊的，建议您在Google Cloud Platform网站上阅读有关其细微之处的文档。
- en: Using our `UserFromAEUser` function, we get the user who is answering the question
    and set `UserCard` inside `Answer` before setting `CTime` to the current time,
    as done earlier.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`UserFromAEUser`函数，我们获取回答问题的用户，并在将`CTime`设置为当前时间之前，在`Answer`内部设置`UserCard`，就像之前做的那样。
- en: Then, we start our transaction by calling the `datastore.RunInTransaction` function
    that takes a context as well as a function where the transactional code will go.
    There is a third argument, which is a set of `datastore.TransactionOptions` that
    we need to use in order to set `XG` to `true`, which informs the data store that
    we'll be performing a transaction across entity groups (both `Answer` and `Question`
    kinds).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用`datastore.RunInTransaction`函数开始我们的事务，该函数接受一个上下文以及一个事务代码将执行的函数。还有一个第三个参数，即一组`datastore.TransactionOptions`，我们需要使用它来将`XG`设置为`true`，这会通知数据存储我们将执行跨实体组（`Answer`和`Question`类型）的事务。
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When it comes to writing your own functions and designing your own APIs, it
    is highly recommended that you place any function arguments at the end; otherwise,
    inline function blocks such as the ones in the preceding code obscure the fact
    that there is another argument afterwards. It's quite difficult to realize that
    the `TransactionOptions` object is an argument being passed into the `RunInTransaction`
    function, and I suspect somebody on the Google team regrets this decision.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到编写自己的函数和设计自己的API时，强烈建议将任何函数参数放在末尾；否则，像前面代码中的内联函数块一样，会掩盖后面还有另一个参数的事实。很难意识到`TransactionOptions`对象是传递给`RunInTransaction`函数的参数，我怀疑谷歌团队中有人后悔这个决定。
- en: Transactions work by providing a new context for us to use, which means that
    code inside the transaction function looks the same, as if it weren't in a transaction.
    This is a nice piece of API design (and it means that we can forgive the function
    for not being the final argument).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 事务通过为我们提供一个新上下文来工作，这意味着事务函数内部的代码看起来是一样的，就像它不在事务中一样。这是一项很好的API设计（这也意味着我们可以原谅该函数不是最终参数）。
- en: Inside the transaction function, we use our `GetQuestion` helper to load the
    question. Loading data inside the transaction function is what obtains a lock
    on it. We then put the answer to save it, update the `AnswerCount` integer, and
    update the question. If all is well (provided none of these steps returns an error),
    the answer will be saved and `AnswerCount` will increase by one.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在事务函数内部，我们使用我们的`GetQuestion`辅助函数来加载问题。在事务函数内部加载数据是获取其锁的方式。然后我们保存答案，更新`AnswerCount`整数，并更新问题。如果一切顺利（假设这些步骤中没有返回错误），答案将被保存，`AnswerCount`将增加一。
- en: If we do return an error from our transaction function, the other operations
    are canceled and the error is returned. If that happens, we'll just return that
    error from our `Answer.Create` method and let the user try again.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从事务函数返回错误，其他操作将被取消，并返回错误。如果发生这种情况，我们只需从我们的`Answer.Create`方法返回该错误，并让用户再次尝试。
- en: 'Next, we are going to add our `GetAnswer` helper, which is similar to our `GetQuestion`
    function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加我们的`GetAnswer`辅助函数，它与我们的`GetQuestion`函数类似：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we are going to add our `Put` helper method in `answers.go`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在`answers.go`中添加我们的`Put`辅助方法：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These two functions are very similar to the `GetQuestion` and `Question.Put`
    methods, but let's resist the temptation of abstracting it and drying up the code
    for now.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数与`GetQuestion`和`Question.Put`方法非常相似，但现在让我们抵制抽象化并简化代码的诱惑。
