<html><head></head><body><div class="book" title="Querying in Google Cloud Datastore" id="64EJS1-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec0060" class="calibre1"/>Querying in Google Cloud Datastore</h1></div></div></div><p class="calibre10">So far, we have only been putting and getting single objects into and out of Google Cloud Datastore. When we display a list of answers to a question, we want to load all of these answers in a single operation, which we can do with <code class="email">datastore.Query</code>.</p><p class="calibre10">The querying interface is a fluent API, where each method returns the same object or a modified object, allowing you to chain calls together. You can use it to build up a query consisting of ordering, limits, ancestors, filters, and so on. We will use it to write a function that will load all the answers for a given question, showing the most popular (those with a higher <code class="email">Score</code> value) first.</p><p class="calibre10">Add the following function to <code class="email">answers.go</code>:</p><pre class="programlisting">func GetAnswers(ctx context.Context, questionKey *datastore.Key)  
([]*Answer, error) { 
  var answers []*Answer 
  answerKeys, err := datastore.NewQuery("Answer"). 
    Ancestor(questionKey). 
    Order("-Score"). 
    Order("-CTime"). 
    GetAll(ctx, &amp;answers) 
  for i, answer := range answers { 
    answer.Key = answerKeys[i] 
  } 
  if err != nil { 
    return nil, err 
  } 
  return answers, nil 
} 
</pre><p class="calibre10">We first create an empty slice of pointers to <code class="email">Answer</code> and use <code class="email">datastore.NewQuery</code> to start building a query. The <code class="email">Ancestor</code> method indicates that we're looking only for answers that belong to the specific question, where the <code class="email">Order</code> method calls specify that we want to first order by descending <code class="email">Score</code> and then by the newest first. The <code class="email">GetAll</code> method performs the operation, which takes in a pointer to our slice (where the results will go) and returns a new slice containing all the keys.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip147" class="calibre1"/>Tip</h3><p class="calibre10">The order of the keys returned will match the order of the entities in the slice. This is how we know which key corresponds to each item.</p></div><p class="calibre10">Since we are keeping keys and the entity fields together, we range over the answers and assign <code class="email">answer.Key</code> to the corresponding <code class="email">datastore.Key</code> argument returned from <code class="email">GetAll</code>.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note00148" class="calibre1"/>Note</h3><p class="calibre10">We are keeping our API simple for the first version by not implementing paging, but ideally you would need to; otherwise, as the number of questions and answers grows, you will end up trying to deliver everything in a single request, which would overwhelm the user and maybe the servers.</p></div><p class="calibre10">If we had a step in our application of authorizing the answer (to protect it from spam or inappropriate content), we might want to add an additional filter for <code class="email">Authorized</code> to be <code class="email">true</code>, in which case we could do this:</p><pre class="programlisting">datastore.NewQuery("Answer"). 
 Filter("Authorized =", true) 
</pre><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip149" class="calibre1"/>Tip</h3><p class="calibre10">For more information on querying and filtering, consult the Google Cloud Datastore API documentation online.</p></div><p class="calibre10">Another place where we need to query data is when we show the top questions on the home page of our app. Our first version of top questions will just show those questions that have the most answers; we consider them to be the most interesting, but you could change this functionality in the future without breaking the API to order by score or even question views.</p><p class="calibre10">We will build <code class="email">Query</code> on the <code class="email">Question</code> kind and use the <code class="email">Order</code> method to first order by the number of answers (with the highest first), followed by time (also, highest/latest first). We will also use the <code class="email">Limit</code> method to make sure we only select the top 25 questions for this API. Later, if we implement paging, we can even make this dynamic.</p><p class="calibre10">In <code class="email">questions.go</code>, add the <code class="email">TopQuestions</code> function:</p><pre class="programlisting">func TopQuestions(ctx context.Context) ([]*Question, error) { 
  var questions []*Question 
  questionKeys, err := datastore.NewQuery("Question"). 
    Order("-AnswersCount"). 
    Order("-CTime"). 
    Limit(25). 
    GetAll(ctx, &amp;questions) 
  if err != nil { 
    return nil, err 
  } 
  for i := range questions { 
    questions[i].Key = questionKeys[i] 
  } 
  return questions, nil 
} 
</pre><p class="calibre10">This code is similar to loading the answers, and we end up returning a slice of <code class="email">Question</code> objects or an error.</p></div></body></html>