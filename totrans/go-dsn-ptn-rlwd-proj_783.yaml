- en: Querying in Google Cloud Datastore
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Google Cloud Datastore 中的查询
- en: So far, we have only been putting and getting single objects into and out of
    Google Cloud Datastore. When we display a list of answers to a question, we want
    to load all of these answers in a single operation, which we can do with `datastore.Query`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是在 Google Cloud Datastore 中进行单个对象的存取操作。当我们显示一个问题的答案列表时，我们希望一次性加载所有这些答案，这可以通过
    `datastore.Query` 实现。
- en: The querying interface is a fluent API, where each method returns the same object
    or a modified object, allowing you to chain calls together. You can use it to
    build up a query consisting of ordering, limits, ancestors, filters, and so on.
    We will use it to write a function that will load all the answers for a given
    question, showing the most popular (those with a higher `Score` value) first.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 查询接口是一个流畅的 API，其中每个方法都返回相同的对象或修改后的对象，允许你将调用链在一起。你可以用它来构建包含排序、限制、祖先、过滤器等的查询。我们将用它来编写一个函数，该函数将加载给定问题的所有答案，首先显示最受欢迎的（那些
    `Score` 值较高的）。
- en: 'Add the following function to `answers.go`:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下函数添加到 `answers.go` 中：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We first create an empty slice of pointers to `Answer` and use `datastore.NewQuery`
    to start building a query. The `Ancestor` method indicates that we're looking
    only for answers that belong to the specific question, where the `Order` method
    calls specify that we want to first order by descending `Score` and then by the
    newest first. The `GetAll` method performs the operation, which takes in a pointer
    to our slice (where the results will go) and returns a new slice containing all
    the keys.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个指向 `Answer` 的指针空切片，并使用 `datastore.NewQuery` 开始构建查询。`Ancestor` 方法表示我们只查找属于特定问题的答案，其中
    `Order` 方法的调用指定我们首先按降序 `Score` 排序，然后按最新排序。`GetAll` 方法执行操作，它接收一个指向我们的切片的指针（结果将放入其中）并返回一个包含所有键的新切片。
- en: Tip
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The order of the keys returned will match the order of the entities in the slice.
    This is how we know which key corresponds to each item.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的键的顺序将与切片中实体的顺序相匹配。这就是我们知道哪个键对应于每个项目的方式。
- en: Since we are keeping keys and the entity fields together, we range over the
    answers and assign `answer.Key` to the corresponding `datastore.Key` argument
    returned from `GetAll`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将键和实体字段一起保存，我们遍历答案并将 `answer.Key` 赋值给 `GetAll` 返回的相应 `datastore.Key` 参数。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are keeping our API simple for the first version by not implementing paging,
    but ideally you would need to; otherwise, as the number of questions and answers
    grows, you will end up trying to deliver everything in a single request, which
    would overwhelm the user and maybe the servers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了第一个版本，我们通过不实现分页来保持我们的 API 简单，但理想情况下你需要这样做；否则，随着问题和答案数量的增长，你最终会尝试在单个请求中发送所有内容，这可能会压倒用户，甚至可能压倒服务器。
- en: 'If we had a step in our application of authorizing the answer (to protect it
    from spam or inappropriate content), we might want to add an additional filter
    for `Authorized` to be `true`, in which case we could do this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们的应用程序中有一个步骤用于授权答案（以保护它免受垃圾邮件或不适当内容的影响），我们可能希望添加一个额外的过滤器，使 `Authorized`
    为 `true`，在这种情况下，我们可以这样做：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For more information on querying and filtering, consult the Google Cloud Datastore
    API documentation online.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 关于查询和过滤的更多信息，请参阅在线的 Google Cloud Datastore API 文档。
- en: Another place where we need to query data is when we show the top questions
    on the home page of our app. Our first version of top questions will just show
    those questions that have the most answers; we consider them to be the most interesting,
    but you could change this functionality in the future without breaking the API
    to order by score or even question views.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要查询数据的地方是当我们显示应用主页上的热门问题时。我们热门问题的第一个版本将只显示那些答案最多的问题；我们认为它们是最有趣的，但你可以将来更改此功能，而不会破坏按分数或甚至按问题查看次数排序的
    API。
- en: We will build `Query` on the `Question` kind and use the `Order` method to first
    order by the number of answers (with the highest first), followed by time (also,
    highest/latest first). We will also use the `Limit` method to make sure we only
    select the top 25 questions for this API. Later, if we implement paging, we can
    even make this dynamic.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `Question` 类别上构建 `Query` 并使用 `Order` 方法首先按答案数量排序（最高的优先），然后按时间排序（也是最高的/最新的优先）。我们还将使用
    `Limit` 方法确保我们只为这个 API 选择前 25 个问题。稍后，如果我们实现分页，我们甚至可以使这个动态化。
- en: 'In `questions.go`, add the `TopQuestions` function:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `questions.go` 中添加 `TopQuestions` 函数：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code is similar to loading the answers, and we end up returning a slice
    of `Question` objects or an error.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码类似于加载答案，我们最终返回一个`Question`对象的切片或一个错误。
