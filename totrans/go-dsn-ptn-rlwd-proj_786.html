<html><head></head><body>
<div class="book" title="Votes" id="65D4E1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Embedding a different view of entities"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec00105" class="calibre1"/>Embedding a different view of entities</h2></div></div></div><p class="calibre10">Now it's time to create our <code class="email">Vote</code> structure, which we'll do inside a new file called <code class="email">votes.go</code>:</p><pre class="programlisting">type Vote struct { 
  Key *datastore.Key `json:"id" datastore:"-"` 
  MTime time.Time `json:"last_modified" datastore:",noindex"` 
  Question QuestionCard `json:"question" datastore:",noindex"` 
  Answer AnswerCard `json:"answer" datastore:",noindex"` 
  User UserCard `json:"user" datastore:",noindex"` 
  Score int `json:"score" datastore:",noindex"` 
} 
</pre><p class="calibre10">A <code class="email">Vote</code> structure contains many of our embeddable card types representing <code class="email">Question</code>, <code class="email">Answer</code> and <code class="email">User</code> casting the vote. It also contains a <code class="email">Score</code> integer, which will be either <code class="email">1</code> or <code class="email">-1</code> (depending on whether they voted up or down). We will also keep track of when they cast their vote (or last changed it) with the <code class="email">MTime</code>
<code class="email">time.Time</code> field.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note00152" class="calibre1"/>Note</h3><p class="calibre10">You can use pointers to the <code class="email">*Card</code> types in the <code class="email">Vote</code> struct if you like. This would save additional copies being made when if you pass the <code class="email">Vote</code> object in and out of functions, but that would mean that any changes made inside these functions would affect the original data rather than just their local copy. In most situations, there isn't much of a performance benefit to using pointers and it might be considered simpler to omit them. This book deliberately mixes both approaches to show you how they work, but you should understand the implications before making a decision.</p></div><p class="calibre10">Like our <code class="email">UserCard</code> method, we are going to add appropriate versions for questions and answers, but this time we are going to be more selective about which fields should be included and which should be left out.</p><p class="calibre10">In <code class="email">questions.go</code>, add the <code class="email">QuestionCard</code> type and the associated helper method:</p><pre class="programlisting">type QuestionCard struct { 
  Key *datastore.Key `json:"id" datastore:",noindex"` 
  Question string `json:"question" datastore:",noindex"` 
  User     UserCard `json:"user" datastore:",noindex"` 
} 
func (q Question) Card() QuestionCard { 
  return QuestionCard{ 
    Key:      q.Key, 
    Question: q.Question, 
    User:     q.User, 
  } 
} 
</pre><p class="calibre10">The <code class="email">QuestionCard</code> type captures the <code class="email">Question</code> string and who asked it (our <code class="email">UserCard</code> method, again), but we are leaving out the <code class="email">CTime</code> and <code class="email">AnswersCount</code> fields.</p><p class="calibre10">Let's add <code class="email">AnswerCard</code> to <code class="email">answers.go</code> next:</p><pre class="programlisting">type AnswerCard struct { 
  Key    *datastore.Key `json:"id" datastore:",noindex"` 
  Answer string         `json:"answer" datastore:",noindex"` 
  User   UserCard       `json:"user" datastore:",noindex"` 
} 
 
func (a Answer) Card() AnswerCard { 
  return AnswerCard{ 
    Key:    a.Key, 
    Answer: a.Answer, 
    User:   a.User, 
  } 
} 
</pre><p class="calibre10">Similarly, we are only capturing the <code class="email">Answer</code> string and <code class="email">User</code> and excluding <code class="email">CTime</code> and <code class="email">Score</code>.</p><p class="calibre10">Deciding which fields to capture and which to omit is entirely dependent on the user experience you wish to provide. We might decide that when we show a vote, we want to show the score of <code class="email">Answer</code> at the time, or we might want to show the current score of <code class="email">Answer</code> regardless of what it was at the time the vote was cast. Perhaps we want to send a push notification to the user who wrote the answer saying something like "Blanca has up-voted your answer to Ernesto's question it now has a score of 15", in which case we would need to grab the <code class="email">Score</code> field too.</p></div></div></body></html>