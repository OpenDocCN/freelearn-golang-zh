- en: Accessing parents via datastore.Key
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过`datastore.Key`访问父级
- en: Our `CastVote` function could require that we know `datastore.Key` for `Question`
    so that we can load it. But one nice feature about ancestor keys is that from
    the key alone, you can access the parent key. This is because the hierarchy of
    keys is maintained in the key itself, a bit like a path.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`CastVote`函数可能需要我们知道`Question`的`datastore.Key`以便加载它。但关于祖先键的一个优点是，仅从键本身就可以访问父键。这是因为键的层次结构被保存在键本身中，有点像路径。
- en: 'Three answers to question 1 might have these keys:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于问题1的三个答案可能包含以下键：
- en: Question,1/Answer,1
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题1/答案1
- en: Question,1/Answer,2
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题1/答案2
- en: Question,1/Answer,3
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题1/答案3
- en: The actual details of how keys work under the hood are kept internal to the
    datastore package and could change at any time. So it is smart to only rely on
    things that the API guarantees such as being able to access the parent via the
    `Parent` method.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，键在底层如何工作的细节被保留在数据存储包内部，并且可能会随时更改。因此，只依赖于API保证的事情是明智的，比如能够通过`Parent`方法访问父级。
