<html><head></head><body>
<div class="book" title="Casting a vote" id="66BL01-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Line of sight in code"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec00107" class="calibre1"/>Line of sight in code</h2></div></div></div><p class="calibre10">The cost of writing a function is relatively low compared to the cost of maintaining it, especially in successful, long-running projects. So it is worth taking the time to ensure the code is readable by our future selves and others.</p><p class="calibre10">Code can be said to have a good line of sight if it is easy to glance at and if it understands the usual, expected flow of the statements (the happy path). In Go, we can achieve this by following a few simple rules when we write code:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Align the happy path to the left edge so that you can scan down a single column and see the expected flow of execution</li><li class="listitem">Don't hide the happy path logic inside a nest of indented braces</li><li class="listitem">Exit early from your function</li><li class="listitem">Indent only to handle errors or edge cases</li><li class="listitem">Extract functions and methods to keep bodies small and readable</li></ul></div><div class="informaltable" title="Note"><h3 class="title2"><a id="note00153" class="calibre1"/>Note</h3><p class="calibre10">There are a few more details to writing good line of sight code, which are outlined and maintained at <a class="calibre1" href="http://bit.ly/lineofsightincode">http://bit.ly/lineofsightincode</a>.</p></div><p class="calibre10">In order to prevent our <code class="email">CastVote</code> function from becoming too big and difficult to follow, we have broken out the core functionality into its own function, which we will now add to <code class="email">votes.go</code>:</p><pre class="programlisting">func castVoteInTransaction(ctx context.Context, answerKey *datastore.Key, question *Question, user *User, score int) (Vote, error) { 
  var vote Vote 
  answer, err := GetAnswer(ctx, answerKey) 
  if err != nil { 
    return vote, err 
  } 
  voteKeyStr := fmt.Sprintf("%s:%s", answerKey.Encode(), user.Key.Encode()) 
  voteKey := datastore.NewKey(ctx, "Vote", voteKeyStr, 0, nil) 
  var delta int // delta describes the change to answer score 
  err = datastore.Get(ctx, voteKey, &amp;vote) 
  if err != nil &amp;&amp; err != datastore.ErrNoSuchEntity { 
    return vote, err 
  } 
  if err == datastore.ErrNoSuchEntity { 
    vote = Vote{ 
      Key:      voteKey, 
      User:     user.Card(), 
      Answer:   answer.Card(), 
      Question: question.Card(), 
      Score:    score, 
    } 
  } else { 
    // they have already voted - so we will be changing 
    // this vote 
    delta = vote.Score * -1 
  } 
  delta += score 
  answer.Score += delta 
  err = answer.Put(ctx) 
  if err != nil { 
    return vote, err 
  } 
  vote.Key = voteKey 
  vote.Score = score 
  vote.MTime = time.Now() 
  err = vote.Put(ctx) 
  if err != nil { 
    return vote, err 
  } 
  return vote, nil 
} 
</pre><p class="calibre10">While this function is long, its line of sight isn't too bad. The happy path flows down the left edge, and we only indent to return early in case of errors and the case where we create a new <code class="email">Vote</code> object. This means that we can easily track what it is doing.</p><p class="calibre10">We take in the answer key, the related question, the user casting the vote and the score, and return a Vote object, or else an error if something goes wrong.</p><p class="calibre10">First, we get the answer which, since we're inside a transaction, will lock it until the transaction is complete (or stops due to an error).</p><p class="calibre10">We then build the key for this vote, which is made up of the keys of both the answer and the user encoded into a single string. This means that only one <code class="email">Vote</code> entity will exist in the data store for each user/answer pair; so a user may only have one vote per answer as per our design.</p><p class="calibre10">We then use the vote key to attempt to load the <code class="email">Vote</code> entity from the data store. Of course, the first time a user votes on a question, no entity will exist, which we can check by seeing whether the error returned from <code class="email">datastore.Get</code> is the special <code class="email">datastore.ErrNoSuchEntity</code> value or not. If it is, we create the new <code class="email">Vote</code> object, setting the appropriate fields.</p><p class="calibre10">We are maintaining a score <code class="email">delta</code> integer, which will represent the number that needs to be added to the answer score after the vote has happened. When it's the first time a user has voted on a question, the delta will be either <code class="email">1</code> or <code class="email">-1</code>. If they are changing their vote from down to up (<code class="email">-1</code> to <code class="email">1</code>), the delta will be <code class="email">2</code>,Â which cancels out the previous vote and adds the new one. We multiply the delta by <code class="email">-1</code> to undo the previous vote if there was one (if <code class="email">err != datastore.ErrNoSuchEntity</code>). This has the nice effect of also not making any difference (<code class="email">delta</code> will be 0) if they happen to cast the same vote twice in either direction.</p><p class="calibre10">Finally, we change the score on the answer and put it back into the data store before updating the final fields in our <code class="email">Vote</code> object and putting that in too. We then return and our <code class="email">CastVote</code> function exits the <code class="email">datastore.RunInTransaction</code> function block, thus releasing Answer and letting others cast their votes on it too.</p></div></div></body></html>