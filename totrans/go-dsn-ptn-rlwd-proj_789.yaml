- en: Line of sight in code
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码的可视范围
- en: The cost of writing a function is relatively low compared to the cost of maintaining
    it, especially in successful, long-running projects. So it is worth taking the
    time to ensure the code is readable by our future selves and others.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 相比于维护成本，编写函数的成本相对较低，尤其是在成功且长期运行的项目中。因此，花时间确保代码对我们未来的自己和他人来说是可读的，这是值得的。
- en: 'Code can be said to have a good line of sight if it is easy to glance at and
    if it understands the usual, expected flow of the statements (the happy path).
    In Go, we can achieve this by following a few simple rules when we write code:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如果易于浏览并且理解语句的常规、预期流程（即“快乐路径”），则可以说具有良好的可读性。在Go语言中，我们可以通过遵循编写代码时的几个简单规则来实现这一点：
- en: Align the happy path to the left edge so that you can scan down a single column
    and see the expected flow of execution
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将“快乐路径”对齐到左侧边缘，以便您可以扫描单列并看到预期的执行流程
- en: Don't hide the happy path logic inside a nest of indented braces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将“快乐路径”逻辑隐藏在缩进的括号嵌套中
- en: Exit early from your function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 早日退出你的函数
- en: Indent only to handle errors or edge cases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅缩进以处理错误或边缘情况
- en: Extract functions and methods to keep bodies small and readable
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取函数和方法以保持代码体小且可读
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are a few more details to writing good line of sight code, which are outlined
    and maintained at [http://bit.ly/lineofsightincode](http://bit.ly/lineofsightincode).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 写出良好的可视范围代码还有一些更多细节，这些细节在[http://bit.ly/lineofsightincode](http://bit.ly/lineofsightincode)中概述并维护。
- en: 'In order to prevent our `CastVote` function from becoming too big and difficult
    to follow, we have broken out the core functionality into its own function, which
    we will now add to `votes.go`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止我们的`CastVote`函数变得太大且难以跟踪，我们已经将核心功能提取到其自己的函数中，我们现在将其添加到`votes.go`中：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While this function is long, its line of sight isn't too bad. The happy path
    flows down the left edge, and we only indent to return early in case of errors
    and the case where we create a new `Vote` object. This means that we can easily
    track what it is doing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个函数很长，但其可视范围并不太差。快乐路径沿着左侧边缘流动，我们只缩进以在出现错误或创建新的`Vote`对象时提前返回。这意味着我们可以轻松跟踪它在做什么。
- en: We take in the answer key, the related question, the user casting the vote and
    the score, and return a Vote object, or else an error if something goes wrong.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接收答案键、相关问题、投掷投票的用户和分数，并返回一个`Vote`对象，或者在出错的情况下返回一个错误。
- en: First, we get the answer which, since we're inside a transaction, will lock
    it until the transaction is complete (or stops due to an error).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们得到答案，由于我们处于事务中，它将锁定直到事务完成（或由于错误而停止）。
- en: We then build the key for this vote, which is made up of the keys of both the
    answer and the user encoded into a single string. This means that only one `Vote`
    entity will exist in the data store for each user/answer pair; so a user may only
    have one vote per answer as per our design.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们构建这个投票的关键字，它由答案和用户的键编码成一个字符串。这意味着对于每个用户/答案对，数据存储中只存在一个`Vote`实体；因此，根据我们的设计，用户对每个答案只能投一票。
- en: We then use the vote key to attempt to load the `Vote` entity from the data
    store. Of course, the first time a user votes on a question, no entity will exist,
    which we can check by seeing whether the error returned from `datastore.Get` is
    the special `datastore.ErrNoSuchEntity` value or not. If it is, we create the
    new `Vote` object, setting the appropriate fields.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用投票键尝试从数据存储中加载`Vote`实体。当然，当用户第一次对一个问题进行投票时，不会存在实体，我们可以通过检查`datastore.Get`返回的错误是否是特殊的`datastore.ErrNoSuchEntity`值来检查这一点。如果是，我们创建新的`Vote`对象，设置适当的字段。
- en: We are maintaining a score `delta` integer, which will represent the number
    that needs to be added to the answer score after the vote has happened. When it's
    the first time a user has voted on a question, the delta will be either `1` or
    `-1`. If they are changing their vote from down to up (`-1` to `1`), the delta
    will be `2`, which cancels out the previous vote and adds the new one. We multiply
    the delta by `-1` to undo the previous vote if there was one (if `err != datastore.ErrNoSuchEntity`).
    This has the nice effect of also not making any difference (`delta` will be 0)
    if they happen to cast the same vote twice in either direction.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们维护一个分数`delta`整数，它将代表在投票发生后需要添加到答案分数上的数字。当用户第一次对一个问题进行投票时，`delta`将是`1`或`-1`。如果他们从反对变为支持（`-1`变为`1`），`delta`将是`2`，这会抵消之前的投票并添加新的投票。我们通过乘以`-1`来撤销之前的投票（如果有的话，如果`err
    != datastore.ErrNoSuchEntity`）。这个操作还有一个很好的效果，即如果他们不小心在两个方向上重复投票相同的票数，那么将不会产生任何差异（`delta`将是0）。
- en: Finally, we change the score on the answer and put it back into the data store
    before updating the final fields in our `Vote` object and putting that in too.
    We then return and our `CastVote` function exits the `datastore.RunInTransaction`
    function block, thus releasing Answer and letting others cast their votes on it
    too.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在答案的分数上进行更改，并将其放回数据存储中，然后在我们的`Vote`对象中更新最终字段并将它也放入其中。然后我们返回，我们的`CastVote`函数退出`datastore.RunInTransaction`函数块，从而释放答案，让其他人也能对其投票。
