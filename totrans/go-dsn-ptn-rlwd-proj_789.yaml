- en: Line of sight in code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The cost of writing a function is relatively low compared to the cost of maintaining
    it, especially in successful, long-running projects. So it is worth taking the
    time to ensure the code is readable by our future selves and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code can be said to have a good line of sight if it is easy to glance at and
    if it understands the usual, expected flow of the statements (the happy path).
    In Go, we can achieve this by following a few simple rules when we write code:'
  prefs: []
  type: TYPE_NORMAL
- en: Align the happy path to the left edge so that you can scan down a single column
    and see the expected flow of execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't hide the happy path logic inside a nest of indented braces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exit early from your function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indent only to handle errors or edge cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract functions and methods to keep bodies small and readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a few more details to writing good line of sight code, which are outlined
    and maintained at [http://bit.ly/lineofsightincode](http://bit.ly/lineofsightincode).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to prevent our `CastVote` function from becoming too big and difficult
    to follow, we have broken out the core functionality into its own function, which
    we will now add to `votes.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: While this function is long, its line of sight isn't too bad. The happy path
    flows down the left edge, and we only indent to return early in case of errors
    and the case where we create a new `Vote` object. This means that we can easily
    track what it is doing.
  prefs: []
  type: TYPE_NORMAL
- en: We take in the answer key, the related question, the user casting the vote and
    the score, and return a Vote object, or else an error if something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: First, we get the answer which, since we're inside a transaction, will lock
    it until the transaction is complete (or stops due to an error).
  prefs: []
  type: TYPE_NORMAL
- en: We then build the key for this vote, which is made up of the keys of both the
    answer and the user encoded into a single string. This means that only one `Vote`
    entity will exist in the data store for each user/answer pair; so a user may only
    have one vote per answer as per our design.
  prefs: []
  type: TYPE_NORMAL
- en: We then use the vote key to attempt to load the `Vote` entity from the data
    store. Of course, the first time a user votes on a question, no entity will exist,
    which we can check by seeing whether the error returned from `datastore.Get` is
    the special `datastore.ErrNoSuchEntity` value or not. If it is, we create the
    new `Vote` object, setting the appropriate fields.
  prefs: []
  type: TYPE_NORMAL
- en: We are maintaining a score `delta` integer, which will represent the number
    that needs to be added to the answer score after the vote has happened. When it's
    the first time a user has voted on a question, the delta will be either `1` or
    `-1`. If they are changing their vote from down to up (`-1` to `1`), the delta
    will be `2`,Â which cancels out the previous vote and adds the new one. We multiply
    the delta by `-1` to undo the previous vote if there was one (if `err != datastore.ErrNoSuchEntity`).
    This has the nice effect of also not making any difference (`delta` will be 0)
    if they happen to cast the same vote twice in either direction.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we change the score on the answer and put it back into the data store
    before updating the final fields in our `Vote` object and putting that in too.
    We then return and our `CastVote` function exits the `datastore.RunInTransaction`
    function block, thus releasing Answer and letting others cast their votes on it
    too.
  prefs: []
  type: TYPE_NORMAL
