- en: Line of sight in code
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The cost of writing a function is relatively low compared to the cost of maintaining
    it, especially in successful, long-running projects. So it is worth taking the
    time to ensure the code is readable by our future selves and others.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Code can be said to have a good line of sight if it is easy to glance at and
    if it understands the usual, expected flow of the statements (the happy path).
    In Go, we can achieve this by following a few simple rules when we write code:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Align the happy path to the left edge so that you can scan down a single column
    and see the expected flow of execution
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't hide the happy path logic inside a nest of indented braces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exit early from your function
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indent only to handle errors or edge cases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract functions and methods to keep bodies small and readable
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a few more details to writing good line of sight code, which are outlined
    and maintained at [http://bit.ly/lineofsightincode](http://bit.ly/lineofsightincode).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to prevent our `CastVote` function from becoming too big and difficult
    to follow, we have broken out the core functionality into its own function, which
    we will now add to `votes.go`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While this function is long, its line of sight isn't too bad. The happy path
    flows down the left edge, and we only indent to return early in case of errors
    and the case where we create a new `Vote` object. This means that we can easily
    track what it is doing.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: We take in the answer key, the related question, the user casting the vote and
    the score, and return a Vote object, or else an error if something goes wrong.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: First, we get the answer which, since we're inside a transaction, will lock
    it until the transaction is complete (or stops due to an error).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: We then build the key for this vote, which is made up of the keys of both the
    answer and the user encoded into a single string. This means that only one `Vote`
    entity will exist in the data store for each user/answer pair; so a user may only
    have one vote per answer as per our design.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: We then use the vote key to attempt to load the `Vote` entity from the data
    store. Of course, the first time a user votes on a question, no entity will exist,
    which we can check by seeing whether the error returned from `datastore.Get` is
    the special `datastore.ErrNoSuchEntity` value or not. If it is, we create the
    new `Vote` object, setting the appropriate fields.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: We are maintaining a score `delta` integer, which will represent the number
    that needs to be added to the answer score after the vote has happened. When it's
    the first time a user has voted on a question, the delta will be either `1` or
    `-1`. If they are changing their vote from down to up (`-1` to `1`), the delta
    will be `2`, which cancels out the previous vote and adds the new one. We multiply
    the delta by `-1` to undo the previous vote if there was one (if `err != datastore.ErrNoSuchEntity`).
    This has the nice effect of also not making any difference (`delta` will be 0)
    if they happen to cast the same vote twice in either direction.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们维护一个分数`delta`整数，它将代表在投票发生后需要添加到答案分数上的数字。当用户第一次对一个问题进行投票时，`delta`将是`1`或`-1`。如果他们从反对变为支持（`-1`变为`1`），`delta`将是`2`，这会抵消之前的投票并添加新的投票。我们通过乘以`-1`来撤销之前的投票（如果有的话，如果`err
    != datastore.ErrNoSuchEntity`）。这个操作还有一个很好的效果，即如果他们不小心在两个方向上重复投票相同的票数，那么将不会产生任何差异（`delta`将是0）。
- en: Finally, we change the score on the answer and put it back into the data store
    before updating the final fields in our `Vote` object and putting that in too.
    We then return and our `CastVote` function exits the `datastore.RunInTransaction`
    function block, thus releasing Answer and letting others cast their votes on it
    too.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在答案的分数上进行更改，并将其放回数据存储中，然后在我们的`Vote`对象中更新最终字段并将它也放入其中。然后我们返回，我们的`CastVote`函数退出`datastore.RunInTransaction`函数块，从而释放答案，让其他人也能对其投票。
