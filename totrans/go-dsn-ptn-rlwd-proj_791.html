<html><head></head><body>
<div class="book" title="Exposing data operations over HTTP">
<div class="book" title="Optional features with type assertions"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec00108" class="calibre1"/>Optional features with type assertions</h2></div></div></div><p class="calibre10">When you use interface types in Go, you can perform type assertions to see whether the objects implement other interfaces, and since you can write interfaces inline, it is possible to very easily find out whether an object implements a specific function.</p><p class="calibre10">If <code class="email">v</code> is <code class="email">interface{}</code>, we can see whether it has the <code class="email">OK</code> method using this pattern:</p><pre class="programlisting">if obj, ok := v.(interface{ OK() error }); ok { 
  // v has OK() method 
} else { 
  // v does not have OK() method 
} 
</pre><p class="calibre10">If the <code class="email">v</code> object implements the method described in the interface, <code class="email">ok</code> will be <code class="email">true</code> and <code class="email">obj</code> will be an object on which the OK method can be called. Otherwise, <code class="email">ok</code> will be false.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note00154" class="calibre1"/>Note</h3><p class="calibre10">One problem with this approach is that it hides the secret functionality from users of the code, so you must either document the function very well in order to make it clear or perhaps promote the method to its own first-class interface and insist that all objects implement it. Remember that we must always seek clear code over clever code. As a side exercise, see whether you can add the interface and use it in the decode signature instead.</p></div><p class="calibre10">We are going to add a function that will help us decode JSON request bodies and, optionally, validate the input. Create a new file called <code class="email">http.go</code> and add the following code:</p><pre class="programlisting">func decode(r *http.Request, v interface{}) error { 
  err := json.NewDecoder(r.Body).Decode(v) 
  if err != nil { 
    return err 
  } 
  if valid, ok := v.(interface { 
    OK() error 
  }); ok { 
    err = valid.OK() 
    if err != nil { 
      return err 
    } 
  } 
  return nil 
} 
</pre><p class="calibre10">The decode function takes <code class="email">http.Request</code> and a destination value called <code class="email">v</code>, which is where the data from the JSON will go. We check whether the <code class="email">OK</code> method is implemented, and if it is, we call it. We expect <code class="email">OK</code> to return nil if the object looks good; otherwise, we expect it to return an error that explains what is wrong. If we get an error, we'll return it and let the calling code deal with it.</p><p class="calibre10">If all is well, we return nil at the bottom of the function.</p></div></div></body></html>