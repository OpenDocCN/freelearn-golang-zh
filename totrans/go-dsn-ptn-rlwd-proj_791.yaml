- en: Optional features with type assertions
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选功能与类型断言
- en: When you use interface types in Go, you can perform type assertions to see whether
    the objects implement other interfaces, and since you can write interfaces inline,
    it is possible to very easily find out whether an object implements a specific
    function.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Go 中使用接口类型时，你可以执行类型断言以查看对象是否实现了其他接口，并且由于你可以内联编写接口，因此可以非常容易地找出对象是否实现了特定函数。
- en: 'If `v` is `interface{}`, we can see whether it has the `OK` method using this
    pattern:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `v` 是 `interface{}`，我们可以使用以下模式查看它是否有 `OK` 方法：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If the `v` object implements the method described in the interface, `ok` will
    be `true` and `obj` will be an object on which the OK method can be called. Otherwise,
    `ok` will be false.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `v` 对象实现了接口中描述的方法，`ok` 将为 `true`，并且 `obj` 将是一个可以调用 OK 方法的对象。否则，`ok` 将为 `false`。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One problem with this approach is that it hides the secret functionality from
    users of the code, so you must either document the function very well in order
    to make it clear or perhaps promote the method to its own first-class interface
    and insist that all objects implement it. Remember that we must always seek clear
    code over clever code. As a side exercise, see whether you can add the interface
    and use it in the decode signature instead.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个问题是它隐藏了代码的秘密功能，因此你必须非常详细地记录该函数，以便使其清晰，或者可能将该方法提升为其自己的第一类接口，并坚持要求所有对象实现它。记住，我们始终寻求清晰的代码而不是巧妙的代码。作为一个辅助练习，看看你是否可以添加接口并在解码签名中使用它。
- en: 'We are going to add a function that will help us decode JSON request bodies
    and, optionally, validate the input. Create a new file called `http.go` and add
    the following code:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个函数，该函数将帮助我们解码 JSON 请求体，并且可选地验证输入。创建一个名为 `http.go` 的新文件，并添加以下代码：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The decode function takes `http.Request` and a destination value called `v`,
    which is where the data from the JSON will go. We check whether the `OK` method
    is implemented, and if it is, we call it. We expect `OK` to return nil if the
    object looks good; otherwise, we expect it to return an error that explains what
    is wrong. If we get an error, we'll return it and let the calling code deal with
    it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 解码函数接受 `http.Request` 和一个名为 `v` 的目标值，其中 JSON 数据将放入。我们检查 `OK` 方法是否实现，如果是，则调用它。我们期望
    `OK` 返回 nil 如果对象看起来良好；否则，我们期望它返回一个错误，解释出了什么问题。如果我们得到一个错误，我们将返回它，并让调用代码处理它。
- en: If all is well, we return nil at the bottom of the function.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们在函数底部返回 nil。
