<html><head></head><body>
<div class="book" title="Exposing data operations over HTTP">
<div class="book" title="Response helpers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec00109" class="calibre1"/>Response helpers</h2></div></div></div><p class="calibre10">We are going to add a pair of helper functions that will make responding to API requests easy. Add the <code class="email">respond</code> function to <code class="email">http.go</code>:</p><pre class="programlisting">func respond(ctx context.Context, w http.ResponseWriter,
 r *http.Request, v interface{}, code int) { 
  var buf bytes.Buffer 
  err := json.NewEncoder(&amp;buf).Encode(v) 
  if err != nil { 
    respondErr(ctx, w, r, err, http.StatusInternalServerError) 
    return 
  } 
  w.Header().Set("Content-Type", 
   "application/json; charset=utf-8") 
  w.WriteHeader(code) 
  _, err = buf.WriteTo(w) 
  if err != nil { 
    log.Errorf(ctx, "respond: %s", err) 
  } 
} 
</pre><p class="calibre10">The respond method contains a <code class="email">context</code>, <code class="email">ResponseWriter</code>, <code class="email">Request</code>, the object to respond with, and a status code. It encodes <code class="email">v</code> into an internal buffer before setting the appropriate headers and writing the response.</p><p class="calibre10">We are using a buffer here because it's possible that the encoding might fail. If it does so but has already started writing the response, the 200 OK header will be sent to the client, which is misleading. Instead, encoding to a buffer lets us be sure that completes without issue before deciding what status code to respond with.</p><p class="calibre10">Now add the <code class="email">respondErr</code> function at the bottom of <code class="email">http.go</code>:</p><pre class="programlisting">func respondErr(ctx context.Context, w http.ResponseWriter,
 r *http.Request, err error, code int) { 
  errObj := struct { 
    Error string `json:"error"` 
  }{ Error: err.Error() } 
  w.Header().Set("Content-Type", "application/json; charset=utf-8") 
  w.WriteHeader(code) 
  err = json.NewEncoder(w).Encode(errObj) 
  if err != nil { 
    log.Errorf(ctx, "respondErr: %s", err) 
  } 
} 
</pre><p class="calibre10">This function writes <code class="email">error</code> wrapped in a struct that embeds the error string as a field called <code class="email">error</code>.</p></div></div></body></html>