<html><head></head><body>
<div class="book" title="Exposing data operations over HTTP">
<div class="book" title="Parsing path parameters"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec00110" class="calibre1"/>Parsing path parameters</h2></div></div></div><p class="calibre10">Some of our API endpoints will need to pull IDs out of the path string, but we don't want to add any dependencies to our project (such as an external router package); instead, we are going to write a simple function that will parse path parameters for us.</p><p class="calibre10">Let's first write a test that will explain how we want our path parsing to work. Create a file called http_test.go and add the following unit test:</p><pre class="programlisting">func TestPathParams(t *testing.T) { 
  r, err := http.NewRequest("GET", "1/2/3/4/5", nil) 
  if err != nil { 
    t.Errorf("NewRequest: %s", err) 
  } 
  params := pathParams(r, "one/two/three/four") 
  if len(params) != 4 { 
    t.Errorf("expected 4 params but got %d: %v", len(params), params) 
  } 
  for k, v := range map[string]string{ 
    "one":   "1", 
    "two":   "2", 
    "three": "3", 
    "four":  "4", 
  } { 
    if params[k] != v { 
      t.Errorf("%s: %s != %s", k, params[k], v) 
    } 
  } 
  params = pathParams(r, "one/two/three/four/five/six") 
  if len(params) != 5 { 
    t.Errorf("expected 5 params but got %d: %v", len(params), params) 
  } 
  for k, v := range map[string]string{ 
    "one":   "1", 
    "two":   "2", 
    "three": "3", 
    "four":  "4", 
    "five":  "5", 
  } { 
    if params[k] != v { 
      t.Errorf("%s: %s != %s", k, params[k], v) 
    } 
  } 
} 
</pre><p class="calibre10">We expect to be able to pass in a pattern and have a map returned that discovers the values from the path in <code class="email">http.Request</code>.</p><p class="calibre10">Run the test (with <code class="email">go test -v</code>) and note that it fails.</p><p class="calibre10">At the bottom of <code class="email">http.go</code>, add the following implementation to make the test pass:</p><pre class="programlisting">func pathParams(r *http.Request,pattern string) map[string]string{ 
  params := map[string]string{} 
  pathSegs := strings.Split(strings.Trim(r.URL.Path, "/"), "/") 
  for i, seg := range strings.Split(strings.Trim(pattern, "/"), "/") { 
    if i &gt; len(pathSegs)-1 { 
      return params 
    } 
    params[seg] = pathSegs[i] 
  } 
  return params 
} 
</pre><p class="calibre10">The function breaks the path from the specific <code class="email">http.Request</code> and builds a map of the values with keys taken from breaking the pattern path. So for a pattern of <code class="email">/questions/id</code> and a path of <code class="email">/questions/123</code>, it would return the following map:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">questions: questions</strong></span>
<span class="strong"><strong class="calibre2">id:        123</strong></span>
</pre><p class="calibre10">Of course, we'd ignore the <code class="email">questions</code> key, but <code class="email">id</code> will be useful.</p></div></div></body></html>