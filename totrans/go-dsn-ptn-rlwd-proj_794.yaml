- en: Exposing functionality via an HTTP API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we have all the tools we need in order to put together our API: helper
    functions to encode and decode data payloads in JSON, path parsing functions,
    and all the entities and data access functionality to persist and query data in
    Google Cloud Datastore.'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP routing in Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The three endpoints we are going to add in order to handle questions are outlined
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP request** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `POST /questions` | Ask a new question |'
  prefs: []
  type: TYPE_TB
- en: '| `GET /questions/{id}` | Get the question with the specific ID |'
  prefs: []
  type: TYPE_TB
- en: '| `GET /questions` | Get the top questions |'
  prefs: []
  type: TYPE_TB
- en: Since our API design is relatively simple, there is no need to bloat out our
    project with an additional dependency to solve routing for us. Instead, we'll
    roll our own very simple adhoc routing using normal Go code. We can use a simple
    `switch` statement to detect which HTTP method was used and our `pathParams` helper
    function to see whether an ID was specified before passing execution to the appropriate
    place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `handle_questions.go` and add the following `http.HandlerFunc`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If the HTTP method is `POST`, then we'll call `handleQuestionCreate`. If it's
    `GET`, then we'll see whether we can extract the ID from the path and call `handleQuestionGet`
    if we can, or `handleTopQuestions` if we cannot.
  prefs: []
  type: TYPE_NORMAL
