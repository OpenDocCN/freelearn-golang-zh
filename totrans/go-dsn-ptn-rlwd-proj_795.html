<html><head></head><body>
<div class="book" title="Exposing data operations over HTTP">
<div class="book" title="Context in Google App Engine"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch09lvl2sec00112" class="calibre1"/>Context in Google App Engine</h2></div></div></div><p class="calibre10">If you remember, all of our calls to App Engine functions took a <code class="email">context.Context</code> object as the first parameter, but what is that and how do we create one?</p><p class="calibre10">
<code class="email">Context</code> is actually an interface that provides cancelation signals, execution deadlines, and request-scoped data throughout a stack of function calls across many components and API boundaries. The Google App Engine SDK for Go uses it throughout its APIs, the details of which are kept internal to the package, which means that we (as users of the SDK) don't have to worry about it. This is a good goal for when you use Context in your own packages; ideally, the complexity should be kept internal and hidden.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note00155" class="calibre1"/>Note</h3><p class="calibre10">You can, and should, learn more about <code class="email">Context</code> through various online resources, starting with the <span class="strong"><em class="calibre11">Go Concurrency Patterns: Context</em></span> blog post at <a class="calibre1" href="https://blog.golang.org/context">https://blog.golang.org/context</a>.</p></div><p class="calibre10">To create a context suitable for App Engine calls, you use the <code class="email">appengine.NewContext</code> function, which takes <code class="email">http.Request</code> as an argument to which the context will belong.</p><p class="calibre10">Underneath the routing code we just added, let's add the handler that will be responsible for creating a question, and we can see how we will create a new context for each request:</p><pre class="programlisting">func handleQuestionCreate(w http.ResponseWriter, r *http.Request) { 
  ctx := appengine.NewContext(r) 
  var q Question 
  err := decode(r, &amp;q) 
  if err != nil { 
    respondErr(ctx, w, r, err, http.StatusBadRequest) 
    return 
  } 
  err = q.Create(ctx) 
  if err != nil { 
    respondErr(ctx, w, r, err, http.StatusInternalServerError) 
    return 
  } 
  respond(ctx, w, r, q, http.StatusCreated) 
} 
</pre><p class="calibre10">We create <code class="email">Context</code> and store it in the <code class="email">ctx</code> variable, which has become somewhat an accepted pattern throughout the Go community. We then decode our Question (which, due to the <code class="email">OK</code> method, will also validate it for us) before calling the <code class="email">Create</code> helper method that we wrote earlier. Every step of the way, we pass our context along.</p><p class="calibre10">If anything goes wrong, we make a call out to our <code class="email">respondErr</code> function, which will write out the response to the client before returning and exiting early from the function.</p><p class="calibre10">If all is well, we respond with <code class="email">Question</code> and a <code class="email">http.StatusCreated</code> status code (201).</p></div></div></body></html>