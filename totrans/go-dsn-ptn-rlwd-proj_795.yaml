- en: Context in Google App Engine
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Google App Engine中的上下文
- en: If you remember, all of our calls to App Engine functions took a `context.Context`
    object as the first parameter, but what is that and how do we create one?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，我们所有的App Engine函数调用都带有一个`context.Context`对象作为第一个参数，但那是什么，我们如何创建一个？
- en: '`Context` is actually an interface that provides cancelation signals, execution
    deadlines, and request-scoped data throughout a stack of function calls across
    many components and API boundaries. The Google App Engine SDK for Go uses it throughout
    its APIs, the details of which are kept internal to the package, which means that
    we (as users of the SDK) don''t have to worry about it. This is a good goal for
    when you use Context in your own packages; ideally, the complexity should be kept
    internal and hidden.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`上下文`实际上是一个接口，它提供取消信号、执行截止时间和在整个函数调用堆栈中跨许多组件和API边界请求范围的数据。Google App Engine的Go
    SDK在其API中使用它，其细节被保留在包内部，这意味着我们（作为SDK的用户）不必担心它。当你在自己的包中使用上下文时，这是一个好的目标；理想情况下，复杂性应该被保留在内部并隐藏起来。'
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can, and should, learn more about `Context` through various online resources,
    starting with the *Go Concurrency Patterns: Context* blog post at [https://blog.golang.org/context](https://blog.golang.org/context).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过各种在线资源了解更多关于`上下文`的信息，从[https://blog.golang.org/context](https://blog.golang.org/context)上的*Go并发模式：上下文*博客文章开始。
- en: To create a context suitable for App Engine calls, you use the `appengine.NewContext`
    function, which takes `http.Request` as an argument to which the context will
    belong.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建适合App Engine调用的上下文，你使用`appengine.NewContext`函数，它接受一个`http.Request`作为参数，上下文将属于该参数。
- en: 'Underneath the routing code we just added, let''s add the handler that will
    be responsible for creating a question, and we can see how we will create a new
    context for each request:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们刚刚添加的路由代码下面，让我们添加一个负责创建问题的处理器，我们可以看到我们将为每个请求创建一个新的上下文：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We create `Context` and store it in the `ctx` variable, which has become somewhat
    an accepted pattern throughout the Go community. We then decode our Question (which,
    due to the `OK` method, will also validate it for us) before calling the `Create`
    helper method that we wrote earlier. Every step of the way, we pass our context
    along.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建`上下文`并将其存储在`ctx`变量中，这在Go社区中已经变成了一种被接受的模式。然后我们在调用我们之前编写的`Create`辅助方法之前，解码我们的问题（由于`OK`方法，它也会为我们验证它）。每一步，我们都传递我们的上下文。
- en: If anything goes wrong, we make a call out to our `respondErr` function, which
    will write out the response to the client before returning and exiting early from
    the function.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何问题，我们调用我们的`respondErr`函数，该函数将在返回并提前退出函数之前向客户端写入响应。
- en: If all is well, we respond with `Question` and a `http.StatusCreated` status
    code (201).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们以`Question`和`http.StatusCreated`状态码（201）响应。
