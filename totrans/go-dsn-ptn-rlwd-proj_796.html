<html><head></head><body>
<div class="book" title="Exposing data operations over HTTP">
<div class="book" title="Decoding key strings"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch09lvl2sec00113" class="calibre1"/>Decoding key strings</h2></div></div></div><p class="calibre10">Since we are exposing the <code class="email">datastore.Key</code> objects as the <code class="email">id</code> field in our objects (via the <code class="email">json</code> field tags), we expect users of our API to pass back these same ID strings when referring to specific objects. This means that we need to decode these strings and turn them back into <code class="email">datastore.Key</code> objects. Luckily, the <code class="email">datastore</code> package provides the answer in the form of the <code class="email">datastore.DecodeKey</code> function.</p><p class="calibre10">At the bottom of <code class="email">handle_questions.go</code>, add the following handle function to get a single question:</p><pre class="programlisting">func handleQuestionGet(w http.ResponseWriter, r *http.Request,
 questionID string) { 
  ctx := appengine.NewContext(r) 
  questionKey, err := datastore.DecodeKey(questionID) 
  if err != nil { 
    respondErr(ctx, w, r, err, http.StatusBadRequest) 
    return 
  } 
  question, err := GetQuestion(ctx, questionKey) 
  if err != nil { 
    if err == datastore.ErrNoSuchEntity { 
      respondErr(ctx, w, r, datastore.ErrNoSuchEntity,
       http.StatusNotFound) 
      return 
    } 
    respondErr(ctx, w, r, err, http.StatusInternalServerError) 
    return 
  } 
  respond(ctx, w, r, question, http.StatusOK) 
} 
</pre><p class="calibre10">After we create Context again, we decode the <code class="email">question ID</code> argument to turn the string back into a <code class="email">datastore.Key</code> object. The <code class="email">question ID</code> string is passed in from our routing handler code, which we added at the top of the file.</p><p class="calibre10">Assuming <code class="email">question ID</code> is a valid key and the SDK was successfully able to turn it into <code class="email">datastore.Key</code>, we call our <code class="email">GetQuestion</code> helper function to load <code class="email">Question</code>. If we get the <code class="email">datastore.ErrNoSuchEntity</code> error, then we respond with a 404 (not found) status; otherwise, we'll report the error with a <code class="email">http.StatusInternalServerError</code> code.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip156" class="calibre1"/>Tip</h3><p class="calibre10">When writing APIs, check out the HTTP status codes and other HTTP standards and see whether you can make use of them. Developers are used to them and your API will feel more natural if it speaks the same language.</p></div><p class="calibre10">If we are able to load the question, we call <code class="email">respond</code> and send it back to the client as JSON.</p><p class="calibre10">Next, we are going to expose the functionality related to answers via a similar API to the one we used for questions:</p><div class="informaltable"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><tbody class="calibre20"><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">HTTP request</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Description</strong></span>
</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<code class="literal">POST /answers</code>
</p>
</td><td class="calibre22">
<p class="calibre23">Submit an answer</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<code class="literal">GET /answers</code>
</p>
</td><td class="calibre22">
<p class="calibre23">Get the answers with the specified question ID</p>
</td></tr></tbody></table></div><p class="calibre10">Create a new file called <code class="email">handle_answers.go</code> and add the routing <code class="email">http.HandlerFunc</code> function:</p><pre class="programlisting">func handleAnswers(w http.ResponseWriter, r *http.Request) { 
  switch r.Method { 
  case "GET": 
    handleAnswersGet(w, r) 
  case "POST": 
    handleAnswerCreate(w, r) 
  default: 
    http.NotFound(w, r) 
  } 
} 
</pre><p class="calibre10">For <code class="email">GET</code> requests, we call <code class="email">handleAnswersGet</code>; for <code class="email">POST</code> requests, we call <code class="email">handleAnswerCreate</code>. By default, we'll respond with a <code class="email">404 Not Found</code> response.</p><div class="book" title="Using query parameters"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec0035" class="calibre1"/>Using query parameters</h3></div></div></div><p class="calibre10">As an alternative to parsing the path, you can just take query parameters from the URL in the request, which we will do when we add the handler that reads answers:</p><pre class="programlisting">func handleAnswersGet(w http.ResponseWriter, r *http.Request) { 
  ctx := appengine.NewContext(r) 
  q := r.URL.Query() 
  questionIDStr := q.Get("question_id") 
  questionKey, err := datastore.DecodeKey(questionIDStr) 
  if err != nil { 
    respondErr(ctx, w, r, err, http.StatusBadRequest) 
    return 
  } 
  answers, err := GetAnswers(ctx, questionKey) 
  if err != nil { 
    respondErr(ctx, w, r, err, http.StatusInternalServerError) 
    return 
  } 
  respond(ctx, w, r, answers, http.StatusOK) 
} 
</pre><p class="calibre10">Here, we use <code class="email">r.URL.Query()</code> to get the <code class="email">http.Values</code> that contains the query parameters and use the Get method to pull out <code class="email">question_id</code>. So, the API call will look like this:</p><pre class="programlisting">/api/answers?question_id=abc123 
</pre><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip157" class="calibre1"/>Tip</h3><p class="calibre10">You should be consistent in your API in the real world. We have used a mix of path parameters and query parameters to show off the differences, but it is recommended that you pick one style and stick to it.</p></div></div><div class="book" title="Anonymous structs for request data"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec0036" class="calibre1"/>Anonymous structs for request data</h3></div></div></div><p class="calibre10">The API for answering a question is to post to <code class="email">/api/answers</code> with a body that contains the answer details as well as the question ID string. This structure is not the same as our internal representation of <code class="email">Answer</code> because the question ID string would need to be decoded into <code class="email">datastore.Key</code>. We could leave the field in and indicate with field tags that it should be omitted from both the JSON and the data store, but there is a cleaner approach.</p><p class="calibre10">We can specify an inline, anonymous structure to hold the new answer, and the best place to do this is inside the handler function that deals with that data this means that we don't need to add a new type to our API, but we can still represent the request data we are expecting.</p><p class="calibre10">At the bottom of <code class="email">handle_answers.go</code>, add the <code class="email">handleAnswerCreate</code> function:</p><pre class="programlisting">func handleAnswerCreate(w http.ResponseWriter, r *http.Request) { 
  ctx := appengine.NewContext(r) 
  var newAnswer struct { 
    Answer 
    QuestionID string `json:"question_id"` 
  } 
  err := decode(r, &amp;newAnswer) 
  if err != nil { 
    respondErr(ctx, w, r, err, http.StatusBadRequest) 
    return 
  } 
  questionKey, err := datastore.DecodeKey(newAnswer.QuestionID) 
  if err != nil { 
    respondErr(ctx, w, r, err, http.StatusBadRequest) 
    return 
  } 
  err = newAnswer.OK() 
  if err != nil { 
    respondErr(ctx, w, r, err, http.StatusBadRequest) 
    return 
  } 
  answer := newAnswer.Answer 
  user, err := UserFromAEUser(ctx) 
  if err != nil { 
    respondErr(ctx, w, r, err, http.StatusBadRequest) 
    return 
  } 
  answer.User = user.Card() 
  err = answer.Create(ctx, questionKey) 
  if err != nil { 
    respondErr(ctx, w, r, err, http.StatusInternalServerError) 
    return 
  } 
  respond(ctx, w, r, answer, http.StatusCreated) 
} 
</pre><p class="calibre10">Look at the somewhat unusual <code class="email">var newAnswer struct</code> line. We are declaring a new variable called <code class="email">newAnswer</code>, which has a type of an anonymous struct (it has no name) that contains <code class="email">QuestionID string</code> and embeds <code class="email">Answer</code>. We can decode the request body into this type, and we will capture any specific <code class="email">Answer</code> fields as well as <code class="email">QuestionID</code>. We then decode the question ID into <code class="email">datastore.Key</code> as we did earlier, validate the answer, and set the <code class="email">User</code> (<code class="email">UserCard</code>) field by getting the currently authenticated user and calling the <code class="email">Card</code> helper method.</p><p class="calibre10">If all is well, we call <code class="email">Create</code>, which will do the work to save the answer to the question.</p><p class="calibre10">Finally, we need to expose the voting functionality in our API.</p></div><div class="book" title="Writing self-similar code"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec0037" class="calibre1"/>Writing self-similar code</h3></div></div></div><p class="calibre10">Our voting API has only a single endpoint, a post to <code class="email">/votes</code>. So, of course, there is no need to do any routing on this method (we could just check the method in the handler itself), but there is something to be said for writing code that is familiar and similar to other code in the same package. In our case, omitting a router might jar a little if somebody else is looking at our code and expects one after seeing the routers for questions and answers.</p><p class="calibre10">So let's add a simple router handler to a new file called <code class="email">handle_votes.go</code>:</p><pre class="programlisting">func handleVotes(w http.ResponseWriter, r *http.Request) { 
  if r.Method != "POST" { 
    http.NotFound(w, r) 
    return 
  } 
  handleVote(w, r) 
} 
</pre><p class="calibre10">Our router just checks the method and exits early if it's not <code class="email">POST</code>, before calling the <code class="email">handleVote</code> function, which we will add next.</p></div><div class="book" title="Validation methods that return an error"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec0038" class="calibre1"/>Validation methods that return an error</h3></div></div></div><p class="calibre10">The <code class="email">OK</code> method that we added to some of our objects is a nice way to add validation methods to our code.</p><p class="calibre10">We want to ensure that the incoming score value is valid (in our case, either <code class="email">-1</code> or <code class="email">1</code>), so we could write a function like this:</p><pre class="programlisting">func validScore(score int) bool { 
  return score == -1 || score == 1 
} 
</pre><p class="calibre10">If we used this function in a few places, we would have to keep repeating the code that explained that the score was not valid. If, however, the function returns an error, you can encapsulate that in one place.</p><p class="calibre10">To <code class="email">votes.go</code>, add the following <code class="email">validScore</code> function:</p><pre class="programlisting">func validScore(score int) error { 
  if score != -1 &amp;&amp; score != 1 { 
    return errors.New("invalid score") 
  } 
  return nil 
} 
</pre><p class="calibre10">In this version, we return <code class="email">nil</code> if the score is valid; otherwise, we return an error that explains what is wrong.</p><p class="calibre10">We will make use of this validation function when we add our <code class="email">handleVote</code> function to <code class="email">handle_votes.go</code>:</p><pre class="programlisting">func handleVote(w http.ResponseWriter, r *http.Request) { 
  ctx := appengine.NewContext(r) 
  var newVote struct { 
    AnswerID string `json:"answer_id"` 
    Score    int    `json:"score"` 
  } 
  err := decode(r, &amp;newVote) 
  if err != nil { 
    respondErr(ctx, w, r, err, http.StatusBadRequest) 
    return 
  } 
  err = validScore(newVote.Score) 
  if err != nil { 
    respondErr(ctx, w, r, err, http.StatusBadRequest) 
    return 
  } 
  answerKey, err := datastore.DecodeKey(newVote.AnswerID) 
  if err != nil { 
    respondErr(ctx, w, r, errors.New("invalid answer_id"), 
    http.StatusBadRequest) 
    return 
  } 
  vote, err := CastVote(ctx, answerKey, newVote.Score) 
  if err != nil { 
    respondErr(ctx, w, r, err, http.StatusInternalServerError) 
    return 
  } 
  respond(ctx, w, r, vote, http.StatusCreated) 
} 
</pre><p class="calibre10">This will look pretty familiar by now, which highlights why we put all the data access logic in a different place to our handlers; the handlers can then focus on HTTP tasks, such as decoding the request and writing the response, and leave the application specifics to the other objects.</p><p class="calibre10">We have also broken down the logic into distinct files, with a pattern of prefixing HTTP handler code with <code class="email">handle_</code>, so we quickly know where to look when we want to work on a specific piece of the project.</p></div></div></div></body></html>