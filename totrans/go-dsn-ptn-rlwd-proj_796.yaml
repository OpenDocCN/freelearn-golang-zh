- en: Decoding key strings
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we are exposing the `datastore.Key` objects as the `id` field in our objects
    (via the `json` field tags), we expect users of our API to pass back these same
    ID strings when referring to specific objects. This means that we need to decode
    these strings and turn them back into `datastore.Key` objects. Luckily, the `datastore`
    package provides the answer in the form of the `datastore.DecodeKey` function.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `handle_questions.go`, add the following handle function to
    get a single question:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After we create Context again, we decode the `question ID` argument to turn
    the string back into a `datastore.Key` object. The `question ID` string is passed
    in from our routing handler code, which we added at the top of the file.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Assuming `question ID` is a valid key and the SDK was successfully able to turn
    it into `datastore.Key`, we call our `GetQuestion` helper function to load `Question`.
    If we get the `datastore.ErrNoSuchEntity` error, then we respond with a 404 (not
    found) status; otherwise, we'll report the error with a `http.StatusInternalServerError`
    code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When writing APIs, check out the HTTP status codes and other HTTP standards
    and see whether you can make use of them. Developers are used to them and your
    API will feel more natural if it speaks the same language.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: If we are able to load the question, we call `respond` and send it back to the
    client as JSON.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to expose the functionality related to answers via a similar
    API to the one we used for questions:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP request** | **Description** |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
- en: '| `POST /answers` | Submit an answer |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
- en: '| `GET /answers` | Get the answers with the specified question ID |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
- en: 'Create a new file called `handle_answers.go` and add the routing `http.HandlerFunc`
    function:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For `GET` requests, we call `handleAnswersGet`; for `POST` requests, we call
    `handleAnswerCreate`. By default, we'll respond with a `404 Not Found` response.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Using query parameters
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an alternative to parsing the path, you can just take query parameters from
    the URL in the request, which we will do when we add the handler that reads answers:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we use `r.URL.Query()` to get the `http.Values` that contains the query
    parameters and use the Get method to pull out `question_id`. So, the API call
    will look like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should be consistent in your API in the real world. We have used a mix of
    path parameters and query parameters to show off the differences, but it is recommended
    that you pick one style and stick to it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous structs for request data
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The API for answering a question is to post to `/api/answers` with a body that
    contains the answer details as well as the question ID string. This structure
    is not the same as our internal representation of `Answer` because the question
    ID string would need to be decoded into `datastore.Key`. We could leave the field
    in and indicate with field tags that it should be omitted from both the JSON and
    the data store, but there is a cleaner approach.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: We can specify an inline, anonymous structure to hold the new answer, and the
    best place to do this is inside the handler function that deals with that data
    this means that we don't need to add a new type to our API, but we can still represent
    the request data we are expecting.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `handle_answers.go`, add the `handleAnswerCreate` function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Look at the somewhat unusual `var newAnswer struct` line. We are declaring a
    new variable called `newAnswer`, which has a type of an anonymous struct (it has
    no name) that contains `QuestionID string` and embeds `Answer`. We can decode
    the request body into this type, and we will capture any specific `Answer` fields
    as well as `QuestionID`. We then decode the question ID into `datastore.Key` as
    we did earlier, validate the answer, and set the `User` (`UserCard`) field by
    getting the currently authenticated user and calling the `Card` helper method.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: If all is well, we call `Create`, which will do the work to save the answer
    to the question.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to expose the voting functionality in our API.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Writing self-similar code
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our voting API has only a single endpoint, a post to `/votes`. So, of course,
    there is no need to do any routing on this method (we could just check the method
    in the handler itself), but there is something to be said for writing code that
    is familiar and similar to other code in the same package. In our case, omitting
    a router might jar a little if somebody else is looking at our code and expects
    one after seeing the routers for questions and answers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s add a simple router handler to a new file called `handle_votes.go`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our router just checks the method and exits early if it's not `POST`, before
    calling the `handleVote` function, which we will add next.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Validation methods that return an error
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `OK` method that we added to some of our objects is a nice way to add validation
    methods to our code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to ensure that the incoming score value is valid (in our case, either
    `-1` or `1`), so we could write a function like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we used this function in a few places, we would have to keep repeating the
    code that explained that the score was not valid. If, however, the function returns
    an error, you can encapsulate that in one place.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'To `votes.go`, add the following `validScore` function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this version, we return `nil` if the score is valid; otherwise, we return
    an error that explains what is wrong.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make use of this validation function when we add our `handleVote` function
    to `handle_votes.go`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will look pretty familiar by now, which highlights why we put all the data
    access logic in a different place to our handlers; the handlers can then focus
    on HTTP tasks, such as decoding the request and writing the response, and leave
    the application specifics to the other objects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: We have also broken down the logic into distinct files, with a pattern of prefixing
    HTTP handler code with `handle_`, so we quickly know where to look when we want
    to work on a specific piece of the project.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将逻辑分解成独立的文件，采用在HTTP处理程序代码前加上`handle_`的前缀模式，这样当我们想要处理项目的特定部分时，可以快速找到所需的位置。
