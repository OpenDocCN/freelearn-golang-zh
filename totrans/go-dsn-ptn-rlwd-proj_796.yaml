- en: Decoding key strings
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解码键字符串
- en: Since we are exposing the `datastore.Key` objects as the `id` field in our objects
    (via the `json` field tags), we expect users of our API to pass back these same
    ID strings when referring to specific objects. This means that we need to decode
    these strings and turn them back into `datastore.Key` objects. Luckily, the `datastore`
    package provides the answer in the form of the `datastore.DecodeKey` function.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们通过 `json` 字段标签将 `datastore.Key` 对象作为我们的对象中的 `id` 字段公开，我们期望我们的API用户在引用特定对象时传递回这些相同的ID字符串。这意味着我们需要解码这些字符串并将它们转换回
    `datastore.Key` 对象。幸运的是，`datastore` 包提供了 `datastore.DecodeKey` 函数作为解决方案。
- en: 'At the bottom of `handle_questions.go`, add the following handle function to
    get a single question:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `handle_questions.go` 文件的底部，添加以下处理函数以获取单个问题：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After we create Context again, we decode the `question ID` argument to turn
    the string back into a `datastore.Key` object. The `question ID` string is passed
    in from our routing handler code, which we added at the top of the file.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们再次创建上下文之后，我们将 `question ID` 参数解码以将其转换回 `datastore.Key` 对象。`question ID` 字符串是从我们添加到文件顶部的路由处理程序代码中传入的。
- en: Assuming `question ID` is a valid key and the SDK was successfully able to turn
    it into `datastore.Key`, we call our `GetQuestion` helper function to load `Question`.
    If we get the `datastore.ErrNoSuchEntity` error, then we respond with a 404 (not
    found) status; otherwise, we'll report the error with a `http.StatusInternalServerError`
    code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `question ID` 是一个有效的键，并且SDK能够成功将其转换为 `datastore.Key`，我们将调用我们的 `GetQuestion`
    辅助函数来加载 `Question`。如果我们得到 `datastore.ErrNoSuchEntity` 错误，我们将以404（未找到）状态响应；否则，我们将使用
    `http.StatusInternalServerError` 代码报告错误。
- en: Tip
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When writing APIs, check out the HTTP status codes and other HTTP standards
    and see whether you can make use of them. Developers are used to them and your
    API will feel more natural if it speaks the same language.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写API时，检查HTTP状态码和其他HTTP标准，看看你是否可以利用它们。开发者已经习惯了这些，如果你的API使用相同的语言，它将感觉更自然。
- en: If we are able to load the question, we call `respond` and send it back to the
    client as JSON.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够加载问题，我们将调用 `respond` 并将其作为JSON发送回客户端。
- en: 'Next, we are going to expose the functionality related to answers via a similar
    API to the one we used for questions:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一个与用于问题的类似API来公开与答案相关的功能：
- en: '| **HTTP request** | **Description** |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP 请求** | **描述** |'
- en: '| `POST /answers` | Submit an answer |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `POST /answers` | 提交答案 |'
- en: '| `GET /answers` | Get the answers with the specified question ID |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `GET /answers` | 根据指定的问题ID获取答案 |'
- en: 'Create a new file called `handle_answers.go` and add the routing `http.HandlerFunc`
    function:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `handle_answers.go` 的新文件，并添加路由 `http.HandlerFunc` 函数：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For `GET` requests, we call `handleAnswersGet`; for `POST` requests, we call
    `handleAnswerCreate`. By default, we'll respond with a `404 Not Found` response.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `GET` 请求，我们调用 `handleAnswersGet`；对于 `POST` 请求，我们调用 `handleAnswerCreate`。默认情况下，我们将响应一个
    `404 Not Found` 错误。
- en: Using query parameters
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用查询参数
- en: 'As an alternative to parsing the path, you can just take query parameters from
    the URL in the request, which we will do when we add the handler that reads answers:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 作为解析路径的替代方案，你可以直接从请求中的URL获取查询参数，当我们在添加读取答案的处理程序时将这样做：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we use `r.URL.Query()` to get the `http.Values` that contains the query
    parameters and use the Get method to pull out `question_id`. So, the API call
    will look like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `r.URL.Query()` 获取包含查询参数的 `http.Values`，并使用 Get 方法提取 `question_id`。因此，API调用将如下所示：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You should be consistent in your API in the real world. We have used a mix of
    path parameters and query parameters to show off the differences, but it is recommended
    that you pick one style and stick to it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的API中，你应该保持一致性。我们使用了路径参数和查询参数的混合来展示它们之间的差异，但建议你选择一种风格并坚持下去。
- en: Anonymous structs for request data
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 请求数据的匿名结构
- en: The API for answering a question is to post to `/api/answers` with a body that
    contains the answer details as well as the question ID string. This structure
    is not the same as our internal representation of `Answer` because the question
    ID string would need to be decoded into `datastore.Key`. We could leave the field
    in and indicate with field tags that it should be omitted from both the JSON and
    the data store, but there is a cleaner approach.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 回答问题的API是通过向 `/api/answers` 发送包含答案细节以及问题ID字符串的正文来实现的。这种结构与我们的内部 `Answer` 表示结构不同，因为问题ID字符串需要解码为
    `datastore.Key`。我们可以保留该字段并使用字段标签指示它应从JSON和数据存储中省略，但有一个更干净的方法。
- en: We can specify an inline, anonymous structure to hold the new answer, and the
    best place to do this is inside the handler function that deals with that data
    this means that we don't need to add a new type to our API, but we can still represent
    the request data we are expecting.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定一个内联的匿名结构来保存新的答案，而最佳位置是在处理该数据的处理函数内部，这意味着我们不需要在我们的API中添加新的类型，但我们仍然可以表示我们期望的请求数据。
- en: 'At the bottom of `handle_answers.go`, add the `handleAnswerCreate` function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `handle_answers.go` 的底部添加 `handleAnswerCreate` 函数：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Look at the somewhat unusual `var newAnswer struct` line. We are declaring a
    new variable called `newAnswer`, which has a type of an anonymous struct (it has
    no name) that contains `QuestionID string` and embeds `Answer`. We can decode
    the request body into this type, and we will capture any specific `Answer` fields
    as well as `QuestionID`. We then decode the question ID into `datastore.Key` as
    we did earlier, validate the answer, and set the `User` (`UserCard`) field by
    getting the currently authenticated user and calling the `Card` helper method.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下有些不寻常的 `var newAnswer struct` 行。我们正在声明一个名为 `newAnswer` 的新变量，它有一个匿名结构体的类型（它没有名字），包含
    `QuestionID string` 并嵌入 `Answer`。我们可以将请求体解码到这个类型中，我们将捕获任何特定的 `Answer` 字段以及 `QuestionID`。然后，我们将问题ID解码为
    `datastore.Key`，就像我们之前做的那样，验证答案，并通过获取当前认证用户并调用 `Card` 辅助方法来设置 `User` (`UserCard`)
    字段。
- en: If all is well, we call `Create`, which will do the work to save the answer
    to the question.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将调用 `Create`，这将执行保存问题的答案的工作。
- en: Finally, we need to expose the voting functionality in our API.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在我们的API中公开投票功能。
- en: Writing self-similar code
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写自相似代码
- en: Our voting API has only a single endpoint, a post to `/votes`. So, of course,
    there is no need to do any routing on this method (we could just check the method
    in the handler itself), but there is something to be said for writing code that
    is familiar and similar to other code in the same package. In our case, omitting
    a router might jar a little if somebody else is looking at our code and expects
    one after seeing the routers for questions and answers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的投票API只有一个端点，即对 `/votes` 的POST请求。因此，当然，在这个方法上不需要进行任何路由（我们可以在处理程序本身中检查方法），但编写熟悉且与其他包中的代码相似的代码是有一定道理的。在我们的情况下，如果有人查看我们的代码并看到问题和答案的路由器后期望有一个路由器，那么省略路由器可能会让人感到有些不习惯。
- en: 'So let''s add a simple router handler to a new file called `handle_votes.go`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们向一个名为 `handle_votes.go` 的新文件添加一个简单的路由处理程序：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our router just checks the method and exits early if it's not `POST`, before
    calling the `handleVote` function, which we will add next.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的路由器只检查方法，在调用我们即将添加的 `handleVote` 函数之前，如果它不是 `POST`，就提前退出。
- en: Validation methods that return an error
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回错误的验证方法
- en: The `OK` method that we added to some of our objects is a nice way to add validation
    methods to our code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到一些对象中的 `OK` 方法是向我们的代码添加验证方法的好方法。
- en: 'We want to ensure that the incoming score value is valid (in our case, either
    `-1` or `1`), so we could write a function like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想确保传入的分数值是有效的（在我们的情况下，是 `-1` 或 `1`），因此我们可以编写一个像这样的函数：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we used this function in a few places, we would have to keep repeating the
    code that explained that the score was not valid. If, however, the function returns
    an error, you can encapsulate that in one place.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在几个地方使用这个函数，我们就必须重复代码来解释分数无效。然而，如果函数返回一个错误，你可以在一个地方封装它。
- en: 'To `votes.go`, add the following `validScore` function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `votes.go` 添加以下 `validScore` 函数：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this version, we return `nil` if the score is valid; otherwise, we return
    an error that explains what is wrong.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，如果分数有效，我们返回 `nil`；否则，我们返回一个错误，解释了哪里出了问题。
- en: 'We will make use of this validation function when we add our `handleVote` function
    to `handle_votes.go`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 `handleVote` 函数添加到 `handle_votes.go` 时，我们将使用此验证函数：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will look pretty familiar by now, which highlights why we put all the data
    access logic in a different place to our handlers; the handlers can then focus
    on HTTP tasks, such as decoding the request and writing the response, and leave
    the application specifics to the other objects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，这看起来相当熟悉，这突出了为什么我们将所有数据访问逻辑放在处理程序之外的原因；处理程序可以专注于HTTP任务，例如解码请求和写入响应，并将应用程序的特定细节留给其他对象。
- en: We have also broken down the logic into distinct files, with a pattern of prefixing
    HTTP handler code with `handle_`, so we quickly know where to look when we want
    to work on a specific piece of the project.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将逻辑分解成独立的文件，采用在HTTP处理程序代码前加上`handle_`的前缀模式，这样当我们想要处理项目的特定部分时，可以快速找到所需的位置。
