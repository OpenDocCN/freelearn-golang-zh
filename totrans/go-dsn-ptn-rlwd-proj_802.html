<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;10.&#xA0; Micro-services in Go with the Go kit Framework" id="6B47Q1-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch32" class="calibre1"/>Chapter 10.   Micro-services in Go with the Go kit Framework  </h1></div></div></div><p class="calibre10">
<span class="strong"><strong class="calibre2">Micro-services</strong></span> are discrete components working together to provide functionality and business logic for a larger application, usually communicating over a network protocol (such as HTTP/2 or some other binary transport) and distributed across many physical machines. Each component is isolated from the others, and they take in well-defined inputs and yield well-defined outputs. Multiple instances of the same service can run across many servers and traffic can be load balanced between them. If designed correctly, it is possible for an individual instance to fail without bringing down the whole system and for new instances to be spun up during runtime to help handle load spikes.</p><p class="calibre10">Go kit (refer to <a class="calibre1" href="https://gokit.io">https://gokit.io</a>) is a distributed programming toolkit for the building of applications with a micro-service architecture founded by Peter Bourgon (<code class="email">@peterbourgon</code> on Twitter) and now maintained by a slice of Gophers in the open. It aims to solve many of the foundational (and sometimes boring) aspects of building such systems as well as encouraging good design patterns, allowing you to focus on the business logic that makes up your product or service.</p><p class="calibre10">Go kit doesn't try to solve every problem from scratch; rather, it integrates with many popular related services to solve <span class="strong"><strong class="calibre2">SOA</strong></span> (<span class="strong"><strong class="calibre2">service-oriented architecture</strong></span>) problems, such as service discovery, metrics, monitoring, logging, load balancing, circuit breaking, and many other important aspects of correctly running micro-services at scale. As we build our service by hand using Go kit, you will notice that we will write a lot of boilerplate or scaffold code in order to get things working.</p><p class="calibre10">For smaller products and services with a small team of developers, you may well decide it is easier to just expose a simple JSON endpoint, but Go kit really shines for larger teams, building substantial systems with many different services, each being run tens or hundreds of times within the architecture. Having consistent logging, instrumentation, distributed tracing, and each item being similar to the next means running and maintaining such a system becomes significantly easier.</p><div class="blockquote"><blockquote class="blockquote1"><p class="calibre13">
<span class="strong"><em class="calibre11">"Go kit is ultimately about encouraging good design practice within a service: SOLID design, or domain-driven-design, or the hexagonal architecture, etc. It's not dogmatically any of those, but tries to make good design/software engineering tractable.” —Peter Bourgon</em></span>
</p></blockquote></div><p class="calibre10">In this chapter, we are going to build some micro-services that address various security challenges (in a project called <code class="email">vault</code>) –upon which we would be able to build further functionality. The business logic will be kept very simple, allowing us to focus on learning the principles around building micro-service systems.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note00159" class="calibre1"/>Note</h3><p class="calibre10">There are some alternatives to Go kit as a technology choice; most of them have a similar approach but with different priorities, syntax, and patterns. Ensure that you look around at other options before embarking on a project, but the principles you learn in this chapter will apply across the board.</p></div><p class="calibre10">Specifically, in this chapter, you will learn:</p><div class="book"><ul class="itemizedlist"><li class="listitem">How to hand code a micro-service using Go kit</li><li class="listitem">What gRPC is and how to use it to build servers and clients</li><li class="listitem">How to use Google's protocol buffers and associated tools to describe services and communicate in a highly efficient binary format</li><li class="listitem">How endpoints in Go kit allow us to write a single service implementation and have it exposed via multiple transport protocols</li><li class="listitem">How Go kits-included subpackages help us solve lots of common problems</li><li class="listitem">How Middleware lets us wrap endpoints to adapt their behavior without touching the implementation itself</li><li class="listitem">How to describe method calls as requests and response messages</li><li class="listitem">How to rate limit our services to protect from surges in traffic</li><li class="listitem">A few other idiomatic Go tips and tricks</li></ul></div><p class="calibre10">Some lines of code in this chapter stretch over many lines; they are written with the overflowing content right-aligned on the next line, as shown in this example:</p><pre class="programlisting">func veryLongFunctionWithLotsOfArguments(one string, two int, three
 http.Handler, four string) (bool, error) { 
  log.Println("first line of the function") 
} 
</pre><p class="calibre10">The first three lines in the preceding snippet should be written as one line. Don't worry; the Go compiler will be kind enough to point out if you get this wrong.</p></div></body></html>