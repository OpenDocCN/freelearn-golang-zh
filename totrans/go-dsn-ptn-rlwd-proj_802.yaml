- en: Chapter 10.  Micro-services in Go with the Go kit Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。使用Go kit框架的Go语言微服务
- en: '**Micro-services** are discrete components working together to provide functionality
    and business logic for a larger application, usually communicating over a network
    protocol (such as HTTP/2 or some other binary transport) and distributed across
    many physical machines. Each component is isolated from the others, and they take
    in well-defined inputs and yield well-defined outputs. Multiple instances of the
    same service can run across many servers and traffic can be load balanced between
    them. If designed correctly, it is possible for an individual instance to fail
    without bringing down the whole system and for new instances to be spun up during
    runtime to help handle load spikes.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务**是离散的组件，它们协同工作，为更大的应用程序提供功能和企业逻辑，通常通过网络协议（如HTTP/2或某些其他二进制传输）进行通信，并分布到许多物理机器上。每个组件与其他组件隔离，它们接受定义良好的输入并产生定义良好的输出。同一服务的多个实例可以在多个服务器上运行，并且可以在它们之间进行流量负载均衡。如果设计得当，单个实例的故障不会导致整个系统崩溃，并且在运行时可以启动新的实例以帮助处理负载峰值。'
- en: Go kit (refer to [https://gokit.io](https://gokit.io)) is a distributed programming
    toolkit for the building of applications with a micro-service architecture founded
    by Peter Bourgon (`@peterbourgon` on Twitter) and now maintained by a slice of
    Gophers in the open. It aims to solve many of the foundational (and sometimes
    boring) aspects of building such systems as well as encouraging good design patterns,
    allowing you to focus on the business logic that makes up your product or service.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go kit（参考[https://gokit.io](https://gokit.io)）是由Peter Bourgon（Twitter上的`@peterbourgon`）创立的用于构建具有微服务架构的应用程序的分布式编程工具包，现在由一群Gophers在开源社区中维护。它旨在解决构建此类系统的基础（有时可能有些枯燥）方面的问题，并鼓励良好的设计模式，使您能够专注于构成您产品或服务的业务逻辑。
- en: Go kit doesn't try to solve every problem from scratch; rather, it integrates
    with many popular related services to solve **SOA** (**service-oriented architecture**)
    problems, such as service discovery, metrics, monitoring, logging, load balancing,
    circuit breaking, and many other important aspects of correctly running micro-services
    at scale. As we build our service by hand using Go kit, you will notice that we
    will write a lot of boilerplate or scaffold code in order to get things working.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Go kit并不试图从头解决每个问题；相反，它集成了许多流行的相关服务来解决**SOA**（**面向服务架构**）问题，如服务发现、度量、监控、日志记录、负载均衡、断路器等许多其他重要方面，以正确地在大规模上运行微服务。随着我们使用Go
    kit手动构建服务，您将注意到我们将编写大量的模板或脚手架代码，以便使一切工作。
- en: For smaller products and services with a small team of developers, you may well
    decide it is easier to just expose a simple JSON endpoint, but Go kit really shines
    for larger teams, building substantial systems with many different services, each
    being run tens or hundreds of times within the architecture. Having consistent
    logging, instrumentation, distributed tracing, and each item being similar to
    the next means running and maintaining such a system becomes significantly easier.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于由小型开发团队开发的小型产品和服务，您可能会决定直接暴露一个简单的JSON端点更为容易，但Go kit在大型团队中表现尤为出色，它们构建了由许多不同服务组成的庞大系统，每个服务在架构中运行数十次或数百次。拥有一致的日志记录、监控、分布式跟踪，以及每个组件都类似，意味着运行和维护此类系统变得显著更容易。
- en: '*"Go kit is ultimately about encouraging good design practice within a service:
    SOLID design, or domain-driven-design, or the hexagonal architecture, etc. It''s
    not dogmatically any of those, but tries to make good design/software engineering
    tractable.” —Peter Bourgon*'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"Go kit的最终目的是在服务内部鼓励良好的设计实践：SOLID设计、领域驱动设计或六边形架构等。它不是教条地遵循任何一种，而是试图使良好的设计/软件工程变得可行。"
    ——Peter Bourgon*'
- en: In this chapter, we are going to build some micro-services that address various
    security challenges (in a project called `vault`) –upon which we would be able
    to build further functionality. The business logic will be kept very simple, allowing
    us to focus on learning the principles around building micro-service systems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一些解决各种安全挑战的微服务（在一个名为`vault`的项目中）——基于这些微服务，我们可以进一步构建更多功能。业务逻辑将保持非常简单，使我们能够专注于学习构建微服务系统的原则。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are some alternatives to Go kit as a technology choice; most of them have
    a similar approach but with different priorities, syntax, and patterns. Ensure
    that you look around at other options before embarking on a project, but the principles
    you learn in this chapter will apply across the board.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为技术选择，Go kit 有一些替代方案；大多数它们有类似的方法，但优先级、语法和模式不同。在开始项目之前，确保你查看其他选项，但本章中你学到的原则将适用于所有情况。
- en: 'Specifically, in this chapter, you will learn:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在本章中，你将学习：
- en: How to hand code a micro-service using Go kit
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Go kit 手动编码一个微服务
- en: What gRPC is and how to use it to build servers and clients
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC 是什么以及如何使用它来构建服务器和客户端
- en: How to use Google's protocol buffers and associated tools to describe services
    and communicate in a highly efficient binary format
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Google 的协议缓冲区和相关工具来描述服务并以高度高效的二进制格式进行通信
- en: How endpoints in Go kit allow us to write a single service implementation and
    have it exposed via multiple transport protocols
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go kit 中的端点如何允许我们编写单个服务实现并通过多种传输协议将其公开
- en: How Go kits-included subpackages help us solve lots of common problems
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go kits 包含的子包如何帮助我们解决许多常见问题
- en: How Middleware lets us wrap endpoints to adapt their behavior without touching
    the implementation itself
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件如何让我们封装端点以适应其行为而不触及实现本身
- en: How to describe method calls as requests and response messages
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将方法调用描述为请求和响应消息
- en: How to rate limit our services to protect from surges in traffic
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何对我们的服务进行速率限制以保护免受流量激增的影响
- en: A few other idiomatic Go tips and tricks
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些其他的 Go 语言的惯用技巧和窍门
- en: 'Some lines of code in this chapter stretch over many lines; they are written
    with the overflowing content right-aligned on the next line, as shown in this
    example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的一些代码行跨越多行；它们是以溢出的内容右对齐在下一行编写的，如下例所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first three lines in the preceding snippet should be written as one line.
    Don't worry; the Go compiler will be kind enough to point out if you get this
    wrong.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的片段中的前三行应写为一行。不用担心；Go 编译器会足够友好地指出如果你做错了这一点。
