<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Protocol buffers"><div class="book" id="6C2OC2-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec0068" class="calibre1"/>Protocol buffers</h1></div></div></div><p class="calibre10">Protocol buffers (called <code class="email">protobuf</code> in code) are a binary serialization format that is very small and extremely quick to encode and decode. You describe data structures in an abstract way using a declarative mini language, and generate source code (in a variety of languages) to make reading and writing the data easy for users.</p><p class="calibre10">You can think of protocol buffers as a modern alternative to XML, except that the definition of the data structure is separated from the content, and the content is in a binary format rather than text.</p><p class="calibre10">It's clear to see the benefits when you look at a real example. If we wanted to represent a person with a name in XML, we could write this:</p><pre class="programlisting">&lt;person&gt; 
  &lt;name&gt;MAT&lt;/name&gt; 
&lt;/person&gt; 
</pre><p class="calibre10">This takes up about 30 bytes (discounting whitespace). Let's see how it would look in JSON:</p><pre class="programlisting">{"name":"MAT"} 
</pre><p class="calibre10">Now we're down to 14 bytes, but the structure is still embedded in the content (the name field is spelled out along with the value).</p><p class="calibre10">The equivalent content in protocol buffers would only take five bytes. The following table shows each byte, along with the first five bytes of the XML and JSON representations for comparison. The <span class="strong"><strong class="calibre2">Description</strong></span> row explains the meaning of the bytes in the<span class="strong"><strong class="calibre2"> Content</strong></span> row, which shows the protocol buffer bytes:</p><div class="informaltable"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/><col class="calibre19"/><col class="calibre19"/><col class="calibre19"/><col class="calibre19"/></colgroup><tbody class="calibre20"><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Byte</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">1</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">2</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">3</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">4</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">5</strong></span>
</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Content</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">0a</p>
</td><td class="calibre22">
<p class="calibre23">03</p>
</td><td class="calibre22">
<p class="calibre23">4d</p>
</td><td class="calibre22">
<p class="calibre23">61</p>
</td><td class="calibre22">
<p class="calibre23">72</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Description</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">Type (string)</p>
</td><td class="calibre22">
<p class="calibre23">Length (3)</p>
</td><td class="calibre22">
<p class="calibre23">M</p>
</td><td class="calibre22">
<p class="calibre23">A</p>
</td><td class="calibre22">
<p class="calibre23">T</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">XML</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">&lt;</p>
</td><td class="calibre22">
<p class="calibre23">p</p>
</td><td class="calibre22">
<p class="calibre23">e</p>
</td><td class="calibre22">
<p class="calibre23">r</p>
</td><td class="calibre22">
<p class="calibre23">s</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">JSON</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">{</p>
</td><td class="calibre22">
<p class="calibre23">"</p>
</td><td class="calibre22">
<p class="calibre23">n</p>
</td><td class="calibre22">
<p class="calibre23">a</p>
</td><td class="calibre22">
<p class="calibre23">m</p>
</td></tr></tbody></table></div><p class="calibre10">The structure definition lives in a special <code class="email">.proto</code> file, separate from the data.</p><p class="calibre10">There are still plenty of cases where XML or JSON would be a better choice than protocol buffers, and file size isn't the only measure when deciding a data format to use, but for fixed schema structures and remote procedure calls or for applications running at a truly massive scale, it's a popular choice for good reasons.</p></div></body></html>