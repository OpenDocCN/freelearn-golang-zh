- en: Protocol buffers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协议缓冲区
- en: Protocol buffers (called `protobuf` in code) are a binary serialization format
    that is very small and extremely quick to encode and decode. You describe data
    structures in an abstract way using a declarative mini language, and generate
    source code (in a variety of languages) to make reading and writing the data easy
    for users.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲区（在代码中称为`protobuf`）是一种非常小且编码和解码极快的二进制序列化格式。您可以使用声明性迷你语言以抽象方式描述数据结构，并生成各种语言的源代码，以便用户轻松读取和写入数据。
- en: You can think of protocol buffers as a modern alternative to XML, except that
    the definition of the data structure is separated from the content, and the content
    is in a binary format rather than text.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将协议缓冲区视为XML的现代替代品，只不过数据结构的定义与内容分开，而内容是以二进制格式而不是文本格式存在的。
- en: 'It''s clear to see the benefits when you look at a real example. If we wanted
    to represent a person with a name in XML, we could write this:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当您查看真实示例时，其优势显而易见。如果我们想用XML表示一个具有名称的人，我们可以这样写：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This takes up about 30 bytes (discounting whitespace). Let''s see how it would
    look in JSON:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这大约占用30个字节（不包括空白）。让我们看看它在JSON中的样子：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we're down to 14 bytes, but the structure is still embedded in the content
    (the name field is spelled out along with the value).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经缩减到14个字节，但结构仍然嵌入在内容中（名称字段与值一起展开）。
- en: 'The equivalent content in protocol buffers would only take five bytes. The
    following table shows each byte, along with the first five bytes of the XML and
    JSON representations for comparison. The **Description** row explains the meaning
    of the bytes in the **Content** row, which shows the protocol buffer bytes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在协议缓冲区中的等效内容只需五个字节。下表显示了每个字节，以及XML和JSON表示的前五个字节，以供比较。**描述**行解释了**内容**行中字节的含义，该行显示了协议缓冲区的字节：
- en: '| **Byte** | **1** | **2** | **3** | **4** | **5** |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| **字节** | **1** | **2** | **3** | **4** | **5** |'
- en: '| **Content** | 0a | 03 | 4d | 61 | 72 |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| **内容** | 0a | 03 | 4d | 61 | 72 |'
- en: '| **Description** | Type (string) | Length (3) | M | A | T |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| **描述** | 类型（字符串） | 长度（3） | M | A | T |'
- en: '| **XML** | < | p | e | r | s |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| **XML** | < | p | e | r | s |'
- en: '| **JSON** | { | " | n | a | m |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **JSON** | { | " | n | a | m |'
- en: The structure definition lives in a special `.proto` file, separate from the
    data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 结构定义位于一个特殊的`.proto`文件中，与数据分开。
- en: There are still plenty of cases where XML or JSON would be a better choice than
    protocol buffers, and file size isn't the only measure when deciding a data format
    to use, but for fixed schema structures and remote procedure calls or for applications
    running at a truly massive scale, it's a popular choice for good reasons.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有许多情况下，XML或JSON比协议缓冲区更合适，决定使用哪种数据格式时，文件大小并不是唯一的衡量标准，但对于固定模式结构和远程过程调用，或者对于真正大规模运行的应用程序，它是一个因合理原因而流行的选择。
