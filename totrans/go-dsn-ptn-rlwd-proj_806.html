<html><head></head><body>
<div class="book" title="Protocol buffers">
<div class="book" title="Protocol buffers language"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch10lvl2sec00117" class="calibre1"/>Protocol buffers language</h2></div></div></div><p class="calibre10">To define our data structure, we are going to use the third version of the protocol buffers language, known as <code class="email">proto3</code>.</p><p class="calibre10">Create a new folder in your <code class="email">$GOPATH</code> called <code class="email">vault</code>, and a subfolder called <code class="email">pb</code> inside that. The <code class="email">pb</code> package is where our protocol buffer definition and the generated source code will live.</p><p class="calibre10">We are going to define a service called <code class="email">Vault</code>, which has two methods,Â <code class="email">Hash</code> and <code class="email">Validate</code>:</p><div class="informaltable"><table border="1" class="calibre17"><colgroup class="calibre18"><col class="calibre19"/><col class="calibre19"/></colgroup><tbody class="calibre20"><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Method</strong></span>
</p>
</td><td class="calibre22">
<p class="calibre23">
<span><strong class="calibre24">Description</strong></span>
</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<code class="literal">Hash</code>
</p>
</td><td class="calibre22">
<p class="calibre23">Generate a secure hash for a given password. The hash can be stored instead of storing the password in plain text.</p>
</td></tr><tr class="calibre21"><td class="calibre22">
<p class="calibre23">
<code class="literal">Validate</code>
</p>
</td><td class="calibre22">
<p class="calibre23">Given a password and a previously generated hash, the Validate method will check to ensure that the password is correct.</p>
</td></tr></tbody></table></div><p class="calibre10">Each service call has a request and response pair, which we will define as well. Inside <code class="email">pb</code>, insert the following code into a new file called <code class="email">vault.proto</code>:</p><pre class="programlisting">syntax = "proto3"; 
package pb; 
service Vault { 
  rpc Hash(HashRequest) returns (HashResponse) {} 
  rpc Validate(ValidateRequest) returns (ValidateResponse) {} 
} 
message HashRequest { 
  string password = 1; 
} 
message HashResponse { 
  string hash = 1; 
  string err = 2; 
} 
message ValidateRequest { 
  string password = 1; 
  string hash = 2; 
} 
message ValidateResponse { 
  bool valid = 1; 
} 
</pre><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip160" class="calibre1"/>Tip</h3><p class="calibre10">Vertical whitespace has been removed to save paper, but you are free to add spaces between each block if you think it improves readability.</p></div><p class="calibre10">The first things we specify in our file are that we are using the <code class="email">proto3</code> syntax and the name of the package for the generated source code is <code class="email">pb</code>.</p><p class="calibre10">The <code class="email">service</code> block defines <code class="email">Vault</code> and the two methods-with <code class="email">HashRequest</code>, <code class="email">HashResponse</code>, <code class="email">ValidateRequest</code>, and <code class="email">ValidateResponse</code> messages defined underneath. The lines beginning with <code class="email">rpc</code> inside the service block indicate that our service consists of two remote procedure calls: <code class="email">Hash</code> and <code class="email">Validate</code>.</p><p class="calibre10">The fields inside a message take the following format:</p><pre class="programlisting">type name = position; 
</pre><p class="calibre10">The <code class="email">type</code> is a string that describes the scalar value type, such as <code class="email">string</code>, <code class="email">bool</code>, <code class="email">double</code>, <code class="email">float</code>, <code class="email">int32</code>, <code class="email">int64</code>, and so on. The <code class="email">name</code> is a human-readable string that describes the field, such as <code class="email">hash</code> and <code class="email">password</code>. The position is an integer that indicates where in the data stream that field appears. This is important because the content is a stream of bytes, and lining up the content to the definition is vital to being able to use the format. Additionally, if we were to add (or even rename) fields later (one of the key design features of protocol buffers), we could do so without breaking components that expect certain fields in a specific order; they would continue to work untouched, ignoring new data and just transparently passing it along.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip161" class="calibre1"/>Tip</h3><p class="calibre10">For a complete list of the supported types as well as a deep dive into the entire language, check out the documentation at <a class="calibre1" href="https://developers.google.com/protocol-buffers/docs/proto3">https://developers.google.com/protocol-buffers/docs/proto3</a>.</p></div><p class="calibre10">Note that each method call has an associated request and response pair. These are the messages that will be sent over the network when the remote method is called.</p><p class="calibre10">Since the Hash method takes a single password string argument, the <code class="email">HashRequest</code> object contains a single password string field. Like normal Go functions, the responses may contain an error, which is why both <code class="email">HashResponse</code> and <code class="email">ValidateResponse</code> have two fields. There is no dedicated <code class="email">error</code> interface in proto3 like there is in Go, so we are going to turn the error into a string instead.</p></div></div></body></html>