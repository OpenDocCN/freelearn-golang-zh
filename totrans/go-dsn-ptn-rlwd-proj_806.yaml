- en: Protocol buffers language
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议缓冲语言
- en: To define our data structure, we are going to use the third version of the protocol
    buffers language, known as `proto3`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义我们的数据结构，我们将使用协议缓冲语言（Protocol Buffers）的第三版，称为 `proto3`。
- en: Create a new folder in your `$GOPATH` called `vault`, and a subfolder called
    `pb` inside that. The `pb` package is where our protocol buffer definition and
    the generated source code will live.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `$GOPATH` 中创建一个名为 `vault` 的新文件夹，并在其中创建一个名为 `pb` 的子文件夹。`pb` 包将包含我们的协议缓冲定义和生成的源代码。
- en: 'We are going to define a service called `Vault`, which has two methods, `Hash`
    and `Validate`:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要定义一个名为 `Vault` 的服务，它包含两个方法，`Hash` 和 `Validate`：
- en: '| **Method** | **Description** |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `Hash` | Generate a secure hash for a given password. The hash can be stored
    instead of storing the password in plain text. |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| `Hash` | 为给定的密码生成一个安全的哈希值。可以存储哈希值而不是存储明文密码。 |'
- en: '| `Validate` | Given a password and a previously generated hash, the Validate
    method will check to ensure that the password is correct. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| `Validate` | 给定一个密码和之前生成的哈希值，`Validate` 方法将检查以确保密码正确。 |'
- en: 'Each service call has a request and response pair, which we will define as
    well. Inside `pb`, insert the following code into a new file called `vault.proto`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务调用都有一个请求和响应对，我们也将定义这些。在 `pb` 中，将以下代码插入一个名为 `vault.proto` 的新文件中：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Vertical whitespace has been removed to save paper, but you are free to add
    spaces between each block if you think it improves readability.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省纸张，已经移除了垂直空白，但如果你认为在每一块之间添加空格可以提高可读性，你可以自由地这样做。
- en: The first things we specify in our file are that we are using the `proto3` syntax
    and the name of the package for the generated source code is `pb`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的文件中，我们首先指定我们使用 `proto3` 语法，并且生成的源代码包名为 `pb`。
- en: 'The `service` block defines `Vault` and the two methods-with `HashRequest`,
    `HashResponse`, `ValidateRequest`, and `ValidateResponse` messages defined underneath.
    The lines beginning with `rpc` inside the service block indicate that our service
    consists of two remote procedure calls: `Hash` and `Validate`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`service` 块定义了 `Vault` 以及其下定义的两个方法——`HashRequest`、`HashResponse`、`ValidateRequest`
    和 `ValidateResponse` 消息。服务块内以 `rpc` 开头的行表示我们的服务由两个远程过程调用组成：`Hash` 和 `Validate`。'
- en: 'The fields inside a message take the following format:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 消息内的字段采用以下格式：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `type` is a string that describes the scalar value type, such as `string`,
    `bool`, `double`, `float`, `int32`, `int64`, and so on. The `name` is a human-readable
    string that describes the field, such as `hash` and `password`. The position is
    an integer that indicates where in the data stream that field appears. This is
    important because the content is a stream of bytes, and lining up the content
    to the definition is vital to being able to use the format. Additionally, if we
    were to add (or even rename) fields later (one of the key design features of protocol
    buffers), we could do so without breaking components that expect certain fields
    in a specific order; they would continue to work untouched, ignoring new data
    and just transparently passing it along.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 是一个描述标量值类型的字符串，例如 `string`、`bool`、`double`、`float`、`int32`、`int64` 等。`name`
    是一个描述字段的易读字符串，例如 `hash` 和 `password`。位置是一个整数，表示该字段在数据流中的位置。这是很重要的，因为内容是字节流，将内容与定义对齐对于能够使用该格式至关重要。此外，如果我们稍后添加（甚至重命名）字段（协议缓冲的一个关键设计特性），我们可以这样做而不会破坏期望在特定顺序中包含某些字段的组件；它们将继续无改动地工作，忽略新数据并透明地传递它。'
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For a complete list of the supported types as well as a deep dive into the entire
    language, check out the documentation at [https://developers.google.com/protocol-buffers/docs/proto3](https://developers.google.com/protocol-buffers/docs/proto3).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取支持的类型完整列表以及深入了解整个语言，请查看[https://developers.google.com/protocol-buffers/docs/proto3](https://developers.google.com/protocol-buffers/docs/proto3)上的文档。
- en: Note that each method call has an associated request and response pair. These
    are the messages that will be sent over the network when the remote method is
    called.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个方法调用都有一个相关的请求和响应对。这些是当远程方法被调用时通过网络发送的消息。
- en: Since the Hash method takes a single password string argument, the `HashRequest`
    object contains a single password string field. Like normal Go functions, the
    responses may contain an error, which is why both `HashResponse` and `ValidateResponse`
    have two fields. There is no dedicated `error` interface in proto3 like there
    is in Go, so we are going to turn the error into a string instead.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哈希方法只接受单个密码字符串参数，`HashRequest` 对象包含一个单独的密码字符串字段。像正常的 Go 函数一样，响应可能包含一个错误，这就是为什么
    `HashResponse` 和 `ValidateResponse` 都有两个字段。在 proto3 中没有像 Go 中那样的专用 `error` 接口，因此我们将错误转换为字符串。
