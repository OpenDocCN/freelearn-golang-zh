<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Building the service" id="6D18U1-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec0069" class="calibre1"/>Building the service</h1></div></div></div><p class="calibre10">At the end of the day, whatever other dark magic is going on in our architecture, it will come down to some Go method being called, doing some work, and returning a result. So the next thing we are going to do is define and implement the Vault service itself.</p><p class="calibre10">Inside the <code class="email">vault</code> folder, add the following code to a new <code class="email">service.go</code> file:</p><pre class="programlisting">// Service provides password hashing capabilities. 
type Service interface { 
  Hash(ctx context.Context, password string) (string,
    error) 
  Validate(ctx context.Context, password, hash string)
    (bool, error) 
} 
</pre><p class="calibre10">This interface defines the service.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip163" class="calibre1"/>Tip</h3><p class="calibre10">You might think that <code class="email">VaultService</code> would be a better name than just <code class="email">Service</code>, but remember that since this is a Go package, it will been seen externally as <code class="email">vault.Service</code>, which reads nicely.</p></div><p class="calibre10">We define our two methods: <code class="email">Hash</code> and <code class="email">Validate</code>. Each takes <code class="email">context.Context</code> as the first argument, followed by normal <code class="email">string</code> arguments. The responses are normal Go types as well: <code class="email">string</code>, <code class="email">bool</code>, and <code class="email">error</code>.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip164" class="calibre1"/>Tip</h3><p class="calibre10">Some libraries may still require the old context dependency, <code class="email">golang.org/x/net/context</code>, rather than the <code class="email">context</code> package that was made available first in Go 1.7. Watch out for errors complaining about mixed use and make sure you're importing the right one.</p></div><p class="calibre10">Part of designing micro-services is being careful about where state is stored. Even though you will implement the methods of a service in a single file, with access to global variables, you should never use them to store the per-request or even per-service state. It's important to remember that each service is likely to be running on many physical machines multiple times, each with no access to the others' global variables.</p><p class="calibre10">In this spirit, we are going to implement our service using an empty <code class="email">struct</code>, essentially a neat idiomatic Go trick to group methods together in order to implement an interface without storing any state in the object itself. To <code class="email">service.go</code>, add the following <code class="email">struct</code>:</p><pre class="programlisting">type vaultService struct{} 
</pre><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip165" class="calibre1"/>Tip</h3><p class="calibre10">If the implementation did require any dependencies (such as a database connection or a configuration object), you could store them inside the struct and use the method receivers in your function bodies.</p></div></div></body></html>