- en: Building the service
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建服务
- en: At the end of the day, whatever other dark magic is going on in our architecture,
    it will come down to some Go method being called, doing some work, and returning
    a result. So the next thing we are going to do is define and implement the Vault
    service itself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，无论我们的架构中正在进行什么其他黑暗魔法，它最终都会归结为某个Go方法被调用，执行一些工作，并返回一个结果。所以接下来我们要做的是定义和实现Vault服务本身。
- en: 'Inside the `vault` folder, add the following code to a new `service.go` file:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vault`文件夹中，向新的`service.go`文件中添加以下代码：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This interface defines the service.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口定义了服务。
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You might think that `VaultService` would be a better name than just `Service`,
    but remember that since this is a Go package, it will been seen externally as
    `vault.Service`, which reads nicely.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为`VaultService`比仅仅`Service`更好，但请记住，由于这是一个Go包，它将在外部被看作`vault.Service`，这听起来很顺耳。
- en: 'We define our two methods: `Hash` and `Validate`. Each takes `context.Context`
    as the first argument, followed by normal `string` arguments. The responses are
    normal Go types as well: `string`, `bool`, and `error`.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个方法：`Hash`和`Validate`。每个方法都将`context.Context`作为第一个参数，后面跟着正常的`string`参数。响应也是正常的Go类型：`string`、`bool`和`error`。
- en: Tip
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Some libraries may still require the old context dependency, `golang.org/x/net/context`,
    rather than the `context` package that was made available first in Go 1.7\. Watch
    out for errors complaining about mixed use and make sure you're importing the
    right one.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一些库可能仍然需要旧的上下文依赖，即`golang.org/x/net/context`，而不是在Go 1.7中首先提供的`context`包。注意查看关于混合使用的错误，并确保你导入的是正确的包。
- en: Part of designing micro-services is being careful about where state is stored.
    Even though you will implement the methods of a service in a single file, with
    access to global variables, you should never use them to store the per-request
    or even per-service state. It's important to remember that each service is likely
    to be running on many physical machines multiple times, each with no access to
    the others' global variables.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 设计微服务的一部分是注意状态存储的位置。即使你将在单个文件中实现服务的各个方法，并且可以访问全局变量，你也绝不应该使用它们来存储每个请求或每个服务的状态。重要的是要记住，每个服务可能将在多个物理机器上多次运行，每个机器都无法访问其他机器的全局变量。
- en: 'In this spirit, we are going to implement our service using an empty `struct`,
    essentially a neat idiomatic Go trick to group methods together in order to implement
    an interface without storing any state in the object itself. To `service.go`,
    add the following `struct`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个精神指导下，我们将使用一个空的`struct`来实现我们的服务，这实际上是一个整洁的Go惯用技巧，用于将方法分组在一起，以便在不存储对象本身任何状态的情况下实现接口。向`service.go`文件中添加以下`struct`：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If the implementation did require any dependencies (such as a database connection
    or a configuration object), you could store them inside the struct and use the
    method receivers in your function bodies.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实现确实需要任何依赖项（例如数据库连接或配置对象），你可以将它们存储在`struct`内部，并在函数体中使用方法接收器。
