- en: Building the service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of the day, whatever other dark magic is going on in our architecture,
    it will come down to some Go method being called, doing some work, and returning
    a result. So the next thing we are going to do is define and implement the Vault
    service itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `vault` folder, add the following code to a new `service.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This interface defines the service.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might think that `VaultService` would be a better name than just `Service`,
    but remember that since this is a Go package, it will been seen externally as
    `vault.Service`, which reads nicely.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define our two methods: `Hash` and `Validate`. Each takes `context.Context`
    as the first argument, followed by normal `string` arguments. The responses are
    normal Go types as well: `string`, `bool`, and `error`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some libraries may still require the old context dependency, `golang.org/x/net/context`,
    rather than the `context` package that was made available first in Go 1.7\. Watch
    out for errors complaining about mixed use and make sure you're importing the
    right one.
  prefs: []
  type: TYPE_NORMAL
- en: Part of designing micro-services is being careful about where state is stored.
    Even though you will implement the methods of a service in a single file, with
    access to global variables, you should never use them to store the per-request
    or even per-service state. It's important to remember that each service is likely
    to be running on many physical machines multiple times, each with no access to
    the others' global variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this spirit, we are going to implement our service using an empty `struct`,
    essentially a neat idiomatic Go trick to group methods together in order to implement
    an interface without storing any state in the object itself. To `service.go`,
    add the following `struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the implementation did require any dependencies (such as a database connection
    or a configuration object), you could store them inside the struct and use the
    method receivers in your function bodies.
  prefs: []
  type: TYPE_NORMAL
