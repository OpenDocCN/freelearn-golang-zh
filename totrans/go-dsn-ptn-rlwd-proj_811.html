<html><head></head><body>
<div class="book" title="Building the service" id="6D18U1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Hashing and validating passwords with bcrypt"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch10lvl2sec00121" class="calibre1"/>Hashing and validating passwords with bcrypt</h2></div></div></div><p class="calibre10">The first method we will implement in our service is <code class="email">Hash</code>. It will take a password and generate a hash. The resulting hash can then be passed (along with a password) to the <code class="email">Validate</code> method later, which will either confirm or deny that the password is correct.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip166" class="calibre1"/>Tip</h3><p class="calibre10">To learn more about the correct way to store passwords in applications, check out the Coda Hale blog post on the subject at <a class="calibre1" href="https://codahale.com/how-to-safely-store-a-password/">https://codahale.com/how-to-safely-store-a-password/</a>.</p></div><p class="calibre10">The point of our service is to ensure that passwords never need to be stored in a database, since that's a security risk if anyone is ever able to get unauthorized access to the database. Instead, you can generate a one-way hash (it cannot be decoded) that can safely be stored, and when users attempt to authenticate, you can perform a check to see whether the password generates the same hash or not. If the hashes match, the passwords are the same; otherwise, they are not.</p><p class="calibre10">The <code class="email">bcrypt</code> package provides methods that do this work for us in a secure and trustworthy way.</p><p class="calibre10">To <code class="email">service.go</code>, add the <code class="email">Hash</code> method:</p><pre class="programlisting">func (vaultService) Hash(ctx context.Context, password
 string) (string, error) { 
  hash, err :=
    bcrypt.GenerateFromPassword([]byte(password),
    bcrypt.DefaultCost) 
  if err != nil { 
    return "", err 
  } 
  return string(hash), nil 
} 
</pre><p class="calibre10">Ensure that you import the appropriate <code class="email">bcrypt</code> package (try <code class="email">golang.org/x/crypto/bcrypt</code>). We are essentially wrapping the <code class="email">GenerateFromPassword</code> function to generate the hash, which we then return provided no errors occurred.</p><p class="calibre10">Note that the receiver in the <code class="email">Hash</code> method is just <code class="email">(vaultService)</code>; we don't capture the variable because there is no way we can store state on an empty <code class="email">struct</code>.</p><p class="calibre10">Next up, let's add the <code class="email">Validate</code> method:</p><pre class="programlisting">func (vaultService) Validate(ctx context.Context,
  password, hash string) (bool, error) { 
  err := bcrypt.CompareHashAndPassword([]byte(hash),
    []byte(password)) 
  if err != nil { 
    return false, nil 
  } 
  return true, nil 
} 
</pre><p class="calibre10">Similar to <code class="email">Hash</code>, we are calling <code class="email">bcrypt.CompareHashAndPassword</code> to determine (in a secure way) whether the password is correct or not. If an error is returned, it means that something is amiss and we return <code class="email">false</code> indicating that. Otherwise, we return <code class="email">true</code> when the password is valid.</p></div></div></body></html>