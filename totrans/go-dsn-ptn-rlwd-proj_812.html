<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Modeling method calls with requests and responses" id="6DVPG1-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec0070" class="calibre1"/>Modeling method calls with requests and responses</h1></div></div></div><p class="calibre10">Since our service will be exposed through various transport protocols, we will need a way to model the requests and responses in and out of our service. We will do this by adding a <code class="email">struct</code> for each type of message our service will accept or return.</p><p class="calibre10">In order for somebody to call the <code class="email">Hash</code> method and then receive the hashed password as a response, we'll need to add the following two structures to <code class="email">service.go</code>:</p><pre class="programlisting">type hashRequest struct { 
  Password string `json:"password"` 
} 
type hashResponse struct { 
  Hash string `json:"hash"` 
  Err  string `json:"err,omitempty"` 
} 
</pre><p class="calibre10">The <code class="email">hashRequest</code> type contains a single field, the password, and the <code class="email">hashResponse</code> has the resulting hash and an <code class="email">Err</code> string field in case something goes wrong.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip167" class="calibre1"/>Tip</h3><p class="calibre10">To model remote method calls, you essentially create a <code class="email">struct</code> for the incoming arguments and a <code class="email">struct</code> for the return arguments.</p></div><p class="calibre10">Before continuing, see whether you can model the same request/response pair for the <code class="email">Validate</code> method. Look at the signature in the <code class="email">Service</code> interface, examine the arguments it accepts, and think about what kind of responses it will need to make.</p><p class="calibre10">We are going to add a helper method (of type <code class="email">http.DecodeRequestFunc</code> from Go kit) that will be able to decode the JSON body of <code class="email">http.Request</code> to <code class="email">service.go</code>:</p><pre class="programlisting">func decodeHashRequest(ctx context.Context, r
 *http.Request) (interface{}, error) { 
  var req hashRequest 
  err := json.NewDecoder(r.Body).Decode(&amp;req) 
  if err != nil { 
    return nil, err 
  } 
  return req, nil 
} 
</pre><p class="calibre10">The signature for <code class="email">decodeHashRequest</code> is dictated by Go kit because it will later use it to decode HTTP requests on our behalf. In this function, we just use <code class="email">json.Decoder</code> to unmarshal the JSON into our <code class="email">hashRequest</code> type.</p><p class="calibre10">Next, we will add the request and response structures as well as a decode helper function for the <code class="email">Validate</code> method:</p><pre class="programlisting">type validateRequest struct { 
  Password string `json:"password"` 
  Hash     string `json:"hash"` 
} 
type validateResponse struct { 
  Valid bool   `json:"valid"` 
  Err   string `json:"err,omitempty"` 
} 
func decodeValidateRequest(ctx context.Context, 
 r *http.Request) (interface{}, error) { 
  var req validateRequest 
  err := json.NewDecoder(r.Body).Decode(&amp;req) 
  if err != nil { 
    return nil, err 
  } 
  return req, nil 
} 
</pre><p class="calibre10">Here, the <code class="email">validateRequest</code> struct takes both <code class="email">Password</code> and <code class="email">Hash</code> strings, since the signature has two input arguments and returns a response containing a <code class="email">bool</code> datatype called <code class="email">Valid</code> or <code class="email">Err</code>.</p><p class="calibre10">The final thing we need to do is encode the response. In this case, we can write a single method to encode both theÂ <code class="email">hashResponse</code> and <code class="email">validateResponse</code> objects.</p><p class="calibre10">Add the following code to <code class="email">service.go</code>:</p><pre class="programlisting">func encodeResponse(ctx context.Context, 
  w http.ResponseWriter, response interface{})
error { 
  return json.NewEncoder(w).Encode(response) 
} 
</pre><p class="calibre10">Our <code class="email">encodeResponse</code> method just asks <code class="email">json.Encoder</code> to do the work for us. Note again that the signature is general since the <code class="email">response</code> type is <code class="email">interface{}</code>; this is because it's a Go kit mechanism for decoding to <code class="email">http.ResponseWriter</code>.</p></div></body></html>