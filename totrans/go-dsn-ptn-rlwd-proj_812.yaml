- en: Modeling method calls with requests and responses
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用请求和响应建模方法调用
- en: Since our service will be exposed through various transport protocols, we will
    need a way to model the requests and responses in and out of our service. We will
    do this by adding a `struct` for each type of message our service will accept
    or return.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的服务将通过各种传输协议公开，我们需要一种方式来模拟服务内部和外部的请求和响应。我们将通过为服务将接受或返回的每种消息类型添加一个 `struct`
    来实现这一点。
- en: 'In order for somebody to call the `Hash` method and then receive the hashed
    password as a response, we''ll need to add the following two structures to `service.go`:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让某人能够调用 `Hash` 方法并接收作为响应的哈希密码，我们需要将以下两个结构体添加到 `service.go` 中：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `hashRequest` type contains a single field, the password, and the `hashResponse`
    has the resulting hash and an `Err` string field in case something goes wrong.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashRequest` 类型包含一个字段，即密码，而 `hashResponse` 包含结果哈希和一个 `Err` 字符串字段，以防出现错误。'
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To model remote method calls, you essentially create a `struct` for the incoming
    arguments and a `struct` for the return arguments.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟远程方法调用，你实际上需要创建一个用于传入参数的 `struct` 和一个用于返回参数的 `struct`。
- en: Before continuing, see whether you can model the same request/response pair
    for the `Validate` method. Look at the signature in the `Service` interface, examine
    the arguments it accepts, and think about what kind of responses it will need
    to make.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，看看你是否可以为 `Validate` 方法建模相同的请求/响应对。查看 `Service` 接口中的签名，检查它接受的参数，并思考它需要做出什么样的响应。
- en: 'We are going to add a helper method (of type `http.DecodeRequestFunc` from
    Go kit) that will be able to decode the JSON body of `http.Request` to `service.go`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个辅助方法（类型为 Go kit 的 `http.DecodeRequestFunc`），它能够将 `http.Request` 的 JSON
    主体解码到 `service.go` 中：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The signature for `decodeHashRequest` is dictated by Go kit because it will
    later use it to decode HTTP requests on our behalf. In this function, we just
    use `json.Decoder` to unmarshal the JSON into our `hashRequest` type.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`decodeHashRequest` 函数的签名由 Go kit 规定，因为它将后来代表我们解码 HTTP 请求。在这个函数中，我们只是使用 `json.Decoder`
    将 JSON 解码到我们的 `hashRequest` 类型中。'
- en: 'Next, we will add the request and response structures as well as a decode helper
    function for the `Validate` method:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加请求和响应结构体以及 `Validate` 方法的解码辅助函数：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the `validateRequest` struct takes both `Password` and `Hash` strings,
    since the signature has two input arguments and returns a response containing
    a `bool` datatype called `Valid` or `Err`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`validateRequest` 结构体同时接受 `Password` 和 `Hash` 字符串，因为签名有两个输入参数，并返回一个包含名为
    `Valid` 或 `Err` 的 `bool` 数据类型的响应。
- en: The final thing we need to do is encode the response. In this case, we can write
    a single method to encode both the `hashResponse` and `validateResponse` objects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是编码响应。在这种情况下，我们可以编写一个单独的方法来编码 `hashResponse` 和 `validateResponse`
    对象。
- en: 'Add the following code to `service.go`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `service.go` 中：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our `encodeResponse` method just asks `json.Encoder` to do the work for us.
    Note again that the signature is general since the `response` type is `interface{}`;
    this is because it's a Go kit mechanism for decoding to `http.ResponseWriter`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `encodeResponse` 方法只是请求 `json.Encoder` 帮我们完成工作。再次注意，签名是通用的，因为 `response`
    类型是 `interface{}`；这是因为它是 Go kit 解码到 `http.ResponseWriter` 的机制。
