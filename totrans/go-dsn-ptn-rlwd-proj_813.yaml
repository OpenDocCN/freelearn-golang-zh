- en: Endpoints in Go kit
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go kit中的端点
- en: 'Endpoints are a special function type in Go kit that represent a single RPC
    method. The definition is inside the `endpoint` package:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 端点是Go kit中的一种特殊函数类型，它代表单个RPC方法。定义在`endpoint`包中：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An endpoint function takes `context.Context` and `request`, and it returns `response`
    or `error`. The `request` and `response` types are `interface{}`, which tells
    us that it is up to the implementation code to deal with the actual types when
    building endpoints.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 端点函数接收`context.Context`和`request`，并返回`response`或`error`。`request`和`response`的类型是`interface{}`，这告诉我们，在构建端点时，处理实际类型是由实现代码来决定的。
- en: 'Endpoints are powerful because, like `http.Handler` (and `http.HandlerFunc`),
    you can wrap them with generalized middleware to solve a myriad of common issues
    that arise when building micro-services: logging, tracing, rate limiting, error
    handling, and more.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 端点之所以强大，是因为，就像`http.Handler`（和`http.HandlerFunc`）一样，你可以用通用中间件包装它们，以解决在构建微服务时出现的各种常见问题：日志记录、跟踪、速率限制、错误处理等。
- en: Go kit solves transporting over various protocols and uses endpoints as a general
    way to jump from their code to ours. For example, the gRPC server will listen
    on a port, and when it receives the appropriate message, it will call the corresponding
    `Endpoint` function. Thanks to Go kit, this will all be transparent to us, as
    we only need to deal in Go code with our `Service` interface.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Go kit解决了在多种协议上的传输问题，并使用端点作为从其代码跳转到我们代码的一般方式。例如，gRPC服务器将在端口上监听，并在接收到适当的消息时调用相应的`Endpoint`函数。多亏了Go
    kit，这一切对我们来说都是透明的，因为我们只需要用Go代码处理我们的`Service`接口。
- en: Making endpoints for service methods
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为服务方法创建端点
- en: In order to turn our service methods into `endpoint.Endpoint` functions, we're
    going to write a function that handles the incoming `hashRequest`, calls the `Hash`
    service method, and depending on the response, builds and returns an appropriate
    `hashResponse` object.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的服务方法转换为`endpoint.Endpoint`函数，我们将编写一个处理传入的`hashRequest`、调用`Hash`服务方法，并根据响应构建并返回适当的`hashResponse`对象的函数。
- en: 'To `service.go`, add the `MakeHashEndpoint` function:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在`service.go`中添加`MakeHashEndpoint`函数：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This function takes `Service` as an argument, which means that we can generate
    an endpoint from any implementation of our `Service` interface. We then use a
    type assertion to specify that the request argument should, in fact, be of type
    `hashRequest`. We call the `Hash` method, passing in the context and `Password`,
    which we get from `hashRequest`. If all is well, we build `hashResponse` with
    the value we got back from the `Hash` method and return it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受`Service`作为参数，这意味着我们可以从我们的`Service`接口的任何实现中生成端点。然后我们使用类型断言来指定请求参数实际上应该是`hashRequest`类型。我们调用`Hash`方法，传入上下文和从`hashRequest`中获取的`Password`。如果一切顺利，我们使用从`Hash`方法返回的值构建`hashResponse`并返回它。
- en: 'Let''s do the same for the `Validate` method:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对`Validate`方法也做同样的处理：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we are doing the same: taking the request and using it to call the method
    before building a response. Note that we never return an error from the `Endpoint`
    function.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们做的是同样的事情：在构建响应之前，使用请求调用方法。请注意，我们从不会从`Endpoint`函数返回错误。
- en: Different levels of error
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误的不同级别
- en: 'There are two main types of errors in Go kit: transport errors (network failure,
    timeouts, dropped connection, and so on) and business logic errors (where the
    infrastructure of making the request and responding was successful, but something
    in the logic or data wasn''t correct).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go kit中，主要有两种错误类型：传输错误（网络故障、超时、断开连接等）和业务逻辑错误（请求和响应的基础设施构建成功，但逻辑或数据中存在不正确之处）。
- en: If the `Hash` method returns an error, we are not going to return it as the
    second argument; instead, we are going to build `hashResponse`, which contains
    the error string (accessible via the `Error` method). This is because the error
    returned from an endpoint is intended to indicate a transport error, and perhaps
    Go kit will be configured to retry the call a few times by some middleware. If
    our service methods return an error, it is considered a business logic error and
    will probably always return the same error for the same input, so it's not worth
    retrying. This is why we wrap the error into the response and return it to the
    client so that they can deal with it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Hash`方法返回错误，我们不会将其作为第二个参数返回；相反，我们将构建`hashResponse`，它包含错误字符串（可通过`Error`方法访问）。这是因为从端点返回的错误旨在指示传输错误，也许Go
    kit将通过某些中间件配置为重试调用几次。如果我们的服务方法返回错误，则认为它是业务逻辑错误，并且对于相同的输入可能会始终返回相同的错误，因此不值得重试。这就是为什么我们将错误包装到响应中并将其返回给客户端，以便他们可以处理它。
- en: Wrapping endpoints into a Service implementation
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将端点包装到服务实现中
- en: Another very useful trick when dealing with endpoints in Go kit is to write
    an implementation of our `vault.Service` interface, which just makes the necessary
    calls to the underlying endpoints.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理Go kit中的端点时，另一个非常有用的技巧是编写我们`vault.Service`接口的实现，这仅仅是对底层端点进行必要的调用。
- en: 'To `service.go`, add the following structure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 向`service.go`添加以下结构：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In order to implement the `vault.Service` interface, we are going to add the
    two methods to our `Endpoints` structure, which will build a request object, make
    the request, and parse the resulting response object into the normal arguments
    to be returned.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现`vault.Service`接口，我们将向我们的`Endpoints`结构中添加两个方法，这些方法将构建一个请求对象，发起请求，并将结果响应对象解析为要返回的正常参数。
- en: 'Add the following `Hash` method:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下`Hash`方法：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We are calling `HashEndpoint` with `hashRequest`, which we create using the
    password argument before caching the general response to `hashResponse` and returning
    the Hash value from it or an error.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`hashRequest`调用`HashEndpoint`，这是我们在缓存`hashResponse`的一般响应之前，使用密码参数创建的。然后从它返回哈希值或错误。
- en: 'We will do this for the Validate method:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为`Validate`方法做同样的事情：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These two methods will allow us to treat the endpoints we have created as though
    they are normal Go methods; very useful for when we actually consume our service
    later in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个方法将使我们能够将我们创建的端点视为普通的Go方法；这对于我们在本章后面实际消费我们的服务时非常有用。
