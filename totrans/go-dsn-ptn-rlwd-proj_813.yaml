- en: Endpoints in Go kit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Endpoints are a special function type in Go kit that represent a single RPC
    method. The definition is inside the `endpoint` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: An endpoint function takes `context.Context` and `request`, and it returns `response`
    or `error`. The `request` and `response` types are `interface{}`, which tells
    us that it is up to the implementation code to deal with the actual types when
    building endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Endpoints are powerful because, like `http.Handler` (and `http.HandlerFunc`),
    you can wrap them with generalized middleware to solve a myriad of common issues
    that arise when building micro-services: logging, tracing, rate limiting, error
    handling, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: Go kit solves transporting over various protocols and uses endpoints as a general
    way to jump from their code to ours. For example, the gRPC server will listen
    on a port, and when it receives the appropriate message, it will call the corresponding
    `Endpoint` function. Thanks to Go kit, this will all be transparent to us, as
    we only need to deal in Go code with our `Service` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Making endpoints for service methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to turn our service methods into `endpoint.Endpoint` functions, we're
    going to write a function that handles the incoming `hashRequest`, calls the `Hash`
    service method, and depending on the response, builds and returns an appropriate
    `hashResponse` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To `service.go`, add the `MakeHashEndpoint` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This function takes `Service` as an argument, which means that we can generate
    an endpoint from any implementation of our `Service` interface. We then use a
    type assertion to specify that the request argument should, in fact, be of type
    `hashRequest`. We call the `Hash` method, passing in the context and `Password`,
    which we get from `hashRequest`. If all is well, we build `hashResponse` with
    the value we got back from the `Hash` method and return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do the same for the `Validate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are doing the same: taking the request and using it to call the method
    before building a response. Note that we never return an error from the `Endpoint`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: Different levels of error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two main types of errors in Go kit: transport errors (network failure,
    timeouts, dropped connection, and so on) and business logic errors (where the
    infrastructure of making the request and responding was successful, but something
    in the logic or data wasn''t correct).'
  prefs: []
  type: TYPE_NORMAL
- en: If the `Hash` method returns an error, we are not going to return it as the
    second argument; instead, we are going to build `hashResponse`, which contains
    the error string (accessible via the `Error` method). This is because the error
    returned from an endpoint is intended to indicate a transport error, and perhaps
    Go kit will be configured to retry the call a few times by some middleware. If
    our service methods return an error, it is considered a business logic error and
    will probably always return the same error for the same input, so it's not worth
    retrying. This is why we wrap the error into the response and return it to the
    client so that they can deal with it.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping endpoints into a Service implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another very useful trick when dealing with endpoints in Go kit is to write
    an implementation of our `vault.Service` interface, which just makes the necessary
    calls to the underlying endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'To `service.go`, add the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In order to implement the `vault.Service` interface, we are going to add the
    two methods to our `Endpoints` structure, which will build a request object, make
    the request, and parse the resulting response object into the normal arguments
    to be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `Hash` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We are calling `HashEndpoint` with `hashRequest`, which we create using the
    password argument before caching the general response to `hashResponse` and returning
    the Hash value from it or an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will do this for the Validate method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These two methods will allow us to treat the endpoints we have created as though
    they are normal Go methods; very useful for when we actually consume our service
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
