<html><head></head><body><div class="book" title="An HTTP server in Go kit" id="6EUA21-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec0071" class="calibre1"/>An HTTP server in Go kit</h1></div></div></div><p class="calibre10">The true value of Go kit becomes apparent when we create an HTTP server for our endpoints to hash and validate.</p><p class="calibre10">Create a new file called <code class="email">server_http.go</code> and add the following code:</p><pre class="programlisting">package vault 
import ( 
  "net/http" 
  httptransport "github.com/go-kit/kit/transport/http" 
  "golang.org/x/net/context" 
) 
func NewHTTPServer(ctx context.Context, endpoints
 Endpoints) http.Handler { 
  m := http.NewServeMux() 
  m.Handle("/hash", httptransport.NewServer( 
    ctx, 
    endpoints.HashEndpoint, 
    decodeHashRequest, 
    encodeResponse, 
  )) 
  m.Handle("/validate", httptransport.NewServer( 
    ctx, 
    endpoints.ValidateEndpoint, 
    decodeValidateRequest, 
    encodeResponse, 
  )) 
  return m 
} 
</pre><p class="calibre10">We are importing the <code class="email">github.com/go-kit/kit/transport/http</code> package and (since we're also importing the <code class="email">net/http</code> package) telling Go that we're going to explicitly refer to this package as <code class="email">httptransport</code>.</p><p class="calibre10">We are using the <code class="email">NewServeMux</code> function from the standard library to build <code class="email">http.Handler</code>Â  interface with simple routing and mapping the <code class="email">/hash</code> and <code class="email">/validate</code> paths. We take the <code class="email">Endpoints</code> object since we want our HTTP server to serve these endpoints, including any middleware that we will add later. Calling <code class="email">httptransport.NewServer</code> is how we get Go kit to give us an HTTP handler for each endpoint. Like most functions, we pass in <code class="email">context.Context</code> as the first argument, which will form the base context for each request. We also pass in the endpoint as well as the decoding and encoding functions that we wrote earlier so that the server knows how to unmarshal and marshal the JSON messages.</p></div></body></html>