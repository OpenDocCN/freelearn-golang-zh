- en: An HTTP server in Go kit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go kit中的HTTP服务器
- en: The true value of Go kit becomes apparent when we create an HTTP server for
    our endpoints to hash and validate.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为我们的端点创建一个用于哈希和验证的HTTP服务器时，Go kit的真实价值才显现出来。
- en: 'Create a new file called `server_http.go` and add the following code:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`server_http.go`的新文件，并添加以下代码：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are importing the `github.com/go-kit/kit/transport/http` package and (since
    we're also importing the `net/http` package) telling Go that we're going to explicitly
    refer to this package as `httptransport`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在导入`github.com/go-kit/kit/transport/http`包，并且（由于我们还在导入`net/http`包）告诉Go我们将显式地引用此包为`httptransport`。
- en: We are using the `NewServeMux` function from the standard library to build `http.Handler` 
    interface with simple routing and mapping the `/hash` and `/validate` paths. We
    take the `Endpoints` object since we want our HTTP server to serve these endpoints,
    including any middleware that we will add later. Calling `httptransport.NewServer`
    is how we get Go kit to give us an HTTP handler for each endpoint. Like most functions,
    we pass in `context.Context` as the first argument, which will form the base context
    for each request. We also pass in the endpoint as well as the decoding and encoding
    functions that we wrote earlier so that the server knows how to unmarshal and
    marshal the JSON messages.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用标准库中的`NewServeMux`函数来构建具有简单路由和将`/hash`和`/validate`路径映射的`http.Handler`接口。我们获取`Endpoints`对象，因为我们希望我们的HTTP服务器能够服务这些端点，包括我们稍后可能添加的任何中间件。调用`httptransport.NewServer`是让Go
    kit为我们每个端点提供HTTP处理器的做法。像大多数函数一样，我们传入`context.Context`作为第一个参数，这将形成每个请求的基本上下文。我们还传入端点以及我们之前编写的解码和编码函数，以便服务器知道如何反序列化和序列化JSON消息。
