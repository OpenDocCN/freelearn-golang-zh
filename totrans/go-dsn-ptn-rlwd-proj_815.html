<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="A gRPC server in Go kit" id="6FSQK1-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec0072" class="calibre1"/>A gRPC server in Go kit</h1></div></div></div><p class="calibre10">Adding a gPRC server using Go kit is almost as easy as adding a JSON/HTTP server, like we did in the last section. In our generated code (in the <code class="email">pb</code> folder), we were given the following <code class="email">pb.VaultServer</code> type:</p><pre class="programlisting">type VaultServer interface { 
  Hash(context.Context, *HashRequest)
    (*HashResponse, error) 
  Validate(context.Context, *ValidateRequest)
    (*ValidateResponse, error) 
} 
</pre><p class="calibre10">This type is very similar to our own <code class="email">Service</code> interface, except that it takes in generated request and response classes rather than raw arguments.</p><p class="calibre10">We'll start by defining a type that will implement the preceding interface. Add the following code to a new file called <code class="email">server_grpc.go</code>:</p><pre class="programlisting">package vault 
import ( 
  "golang.org/x/net/context" 
  grpctransport "github.com/go-kit/kit/transport/grpc" 
) 
type grpcServer struct { 
  hash     grpctransport.Handler 
  validate grpctransport.Handler 
} 
func (s *grpcServer) Hash(ctx context.Context,
 r *pb.HashRequest) (*pb.HashResponse, error) { 
  _, resp, err := s.hash.ServeGRPC(ctx, r) 
  if err != nil { 
    return nil, err 
  } 
  return resp.(*pb.HashResponse), nil 
} 
func (s *grpcServer) Validate(ctx context.Context,
 r *pb.ValidateRequest) (*pb.ValidateResponse, error) { 
  _, resp, err := s.validate.ServeGRPC(ctx, r) 
  if err != nil { 
    return nil, err 
  } 
  return resp.(*pb.ValidateResponse), nil 
} 
</pre><p class="calibre10">Note that you'll need to import <code class="email">github.com/go-kit/kit/transport/grpc</code> as <code class="email">grpctransport</code>, along with the generated <code class="email">pb</code> package.</p><p class="calibre10">The <code class="email">grpcServer</code> struct contains a field for each of the service endpoints, this time of type <code class="email">grpctransport.Handler</code>. Then, we implement the methods of the interface, calling the <code class="email">ServeGRPC</code> method on the appropriate handler. This method will actually serve requests by first decoding them, calling the appropriate endpoint function, getting the response, and encoding it and sending it back to the client who made the request.</p></div></body></html>