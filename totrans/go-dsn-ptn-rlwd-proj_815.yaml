- en: A gRPC server in Go kit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go kit中的gRPC服务器
- en: 'Adding a gPRC server using Go kit is almost as easy as adding a JSON/HTTP server,
    like we did in the last section. In our generated code (in the `pb` folder), we
    were given the following `pb.VaultServer` type:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Go kit添加gPRC服务器几乎与添加JSON/HTTP服务器一样简单，就像我们在上一节中所做的那样。在我们的生成代码（在`pb`文件夹中），我们得到了以下`pb.VaultServer`类型：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This type is very similar to our own `Service` interface, except that it takes
    in generated request and response classes rather than raw arguments.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型与我们自己的`Service`接口非常相似，不同之处在于它接收的是生成的请求和响应类，而不是原始参数。
- en: 'We''ll start by defining a type that will implement the preceding interface.
    Add the following code to a new file called `server_grpc.go`:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个类型，该类型将实现前面的接口。将以下代码添加到一个名为`server_grpc.go`的新文件中：
- en: '[PRE1]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that you'll need to import `github.com/go-kit/kit/transport/grpc` as `grpctransport`,
    along with the generated `pb` package.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您需要将`github.com/go-kit/kit/transport/grpc`导入为`grpctransport`，以及生成的`pb`包。
- en: The `grpcServer` struct contains a field for each of the service endpoints,
    this time of type `grpctransport.Handler`. Then, we implement the methods of the
    interface, calling the `ServeGRPC` method on the appropriate handler. This method
    will actually serve requests by first decoding them, calling the appropriate endpoint
    function, getting the response, and encoding it and sending it back to the client
    who made the request.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`grpcServer`结构体包含每个服务端点的字段，这次是`grpctransport.Handler`类型。然后，我们实现接口的方法，在适当的处理器上调用`ServeGRPC`方法。实际上，这个方法会首先解码请求，调用适当的端点函数，获取响应，然后将其编码并发送回发起请求的客户。'
