<html><head></head><body>
<div class="book" title="A gRPC server in Go kit" id="6FSQK1-9c484ed022e64a0fb0e1aebf8e05d4fd">
<div class="book" title="Translating from protocol buffer types to our types"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch10lvl2sec00123" class="calibre1"/>Translating from protocol buffer types to our types</h2></div></div></div><p class="calibre10">You'll notice that we're using the request and response objects from the <code class="email">pb</code> package, but remember that our own endpoints use the structures we added to <code class="email">service.go</code> earlier. We are going to need a method for each type in order to translate to and from our own types.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip168" class="calibre1"/>Tip</h3><p class="calibre10">There's a lot of repetitive typing coming up; feel free to copy and paste this from the GitHub repository at <a class="calibre1" href="https://github.com/matryer/goblueprints">https://github.com/matryer/goblueprints</a> to save your fingers. We're hand coding this manually because it's important to understand all the pieces that make up the service.</p></div><p class="calibre10">To <code class="email">server_grpc.go</code>, add the following function:</p><pre class="programlisting">func EncodeGRPCHashRequest(ctx context.Context,
  r interface{}) (interface{}, error) { 
  req := r.(hashRequest) 
  return &amp;pb.HashRequest{Password: req.Password}, nil 
} 
</pre><p class="calibre10">This function is an <code class="email">EncodeRequestFunc</code> function defined by Go kit, and it is used to translate our own <code class="email">hashRequest</code> type into a protocol buffer type that can be used to communicate with the client. It uses <code class="email">interface{}</code> types because it's general, but in our case, we can be sure about the types so we cast the incoming request to <code class="email">hashRequest</code> (our own type) and then build a new <code class="email">pb.HashRequest</code> object using the appropriate fields.</p><p class="calibre10">We are going to do this for both encoding and decoding requests and responses for both hash and validate endpoints. Add the following code to <code class="email">server_grpc.go</code>:</p><pre class="programlisting">func DecodeGRPCHashRequest(ctx context.Context,
 r interface{}) (interface{}, error) { 
  req := r.(*pb.HashRequest) 
  return hashRequest{Password: req.Password}, nil 
} 
func EncodeGRPCHashResponse(ctx context.Context,
 r interface{}) (interface{}, error) { 
  res := r.(hashResponse) 
  return &amp;pb.HashResponse{Hash: res.Hash, Err: res.Err},
    nil 
} 
func DecodeGRPCHashResponse(ctx context.Context,
 r interface{}) (interface{}, error) { 
  res := r.(*pb.HashResponse) 
  return hashResponse{Hash: res.Hash, Err: res.Err}, nil 
} 
func EncodeGRPCValidateRequest(ctx context.Context,
 r interface{}) (interface{}, error) { 
  req := r.(validateRequest) 
  return &amp;pb.ValidateRequest{Password: req.Password,
    Hash: req.Hash}, nil 
} 
func DecodeGRPCValidateRequest(ctx context.Context,
 r interface{}) (interface{}, error) { 
  req := r.(*pb.ValidateRequest) 
  return validateRequest{Password: req.Password,
    Hash: req.Hash}, nil 
} 
func EncodeGRPCValidateResponse(ctx context.Context,
 r interface{}) (interface{}, error) { 
  res := r.(validateResponse) 
  return &amp;pb.ValidateResponse{Valid: res.Valid}, nil 
} 
func DecodeGRPCValidateResponse(ctx context.Context,
 r interface{}) (interface{}, error) { 
  res := r.(*pb.ValidateResponse) 
  return validateResponse{Valid: res.Valid}, nil 
} 
</pre><p class="calibre10">As you can see, there is a lot of boilerplate coding to do in order to get things working.</p><div class="informaltable" title="Tip"><h3 class="title2"><a id="tip169" class="calibre1"/>Tip</h3><p class="calibre10">Code generation (not covered here) would have great application here, since the code is very predictable and self-similar.</p></div><p class="calibre10">The final thing to do in order to get our gRPC server working is to provide a helper function to create an instance of our <code class="email">grpcServer</code> structure. Underneath the <code class="email">grpcServer</code> struct, add the following code:</p><pre class="programlisting">func NewGRPCServer(ctx context.Context, endpoints
 Endpoints) pb.VaultServer { 
  return &amp;grpcServer{ 
    hash: grpctransport.NewServer( 
      ctx, 
      endpoints.HashEndpoint, 
      DecodeGRPCHashRequest, 
      EncodeGRPCHashResponse, 
    ), 
    validate: grpctransport.NewServer( 
      ctx, 
      endpoints.ValidateEndpoint, 
      DecodeGRPCValidateRequest, 
      EncodeGRPCValidateResponse, 
    ), 
  } 
} 
</pre><p class="calibre10">Like our HTTP server, we take in a base context and the actual <code class="email">Endpoints</code> implementation that we are exposing via the gRPC server. We create and return a new instance of our <code class="email">grpcServer</code> type, setting the handlers for both <code class="email">hash</code> and <code class="email">validate</code> by calling <code class="email">grpctransport.NewServer</code>. We use our <code class="email">endpoint.Endpoint</code> functions for our service and tell the service which of our encoding/decoding functions to use for each case.</p></div></div></body></html>