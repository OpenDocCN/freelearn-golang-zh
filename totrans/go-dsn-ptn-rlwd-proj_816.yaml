- en: Translating from protocol buffer types to our types
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从协议缓冲区类型转换到我们的类型
- en: You'll notice that we're using the request and response objects from the `pb`
    package, but remember that our own endpoints use the structures we added to `service.go`
    earlier. We are going to need a method for each type in order to translate to
    and from our own types.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们正在使用 `pb` 包中的请求和响应对象，但请记住，我们自己的端点使用我们之前添加到 `service.go` 中的结构。我们将需要一个方法来处理每种类型，以便将它们转换为我们的类型。
- en: Tip
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There's a lot of repetitive typing coming up; feel free to copy and paste this
    from the GitHub repository at [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)
    to save your fingers. We're hand coding this manually because it's important to
    understand all the pieces that make up the service.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来会有很多重复的输入；您可以自由地从 GitHub 仓库 [https://github.com/matryer/goblueprints](https://github.com/matryer/goblueprints)
    复制粘贴以节省您的手指。我们正在手动编码，因为这很重要，需要理解构成服务的所有部分。
- en: 'To `server_grpc.go`, add the following function:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `server_grpc.go` 中添加以下函数：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This function is an `EncodeRequestFunc` function defined by Go kit, and it is
    used to translate our own `hashRequest` type into a protocol buffer type that
    can be used to communicate with the client. It uses `interface{}` types because
    it's general, but in our case, we can be sure about the types so we cast the incoming
    request to `hashRequest` (our own type) and then build a new `pb.HashRequest`
    object using the appropriate fields.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是 Go kit 定义的 `EncodeRequestFunc` 函数，它用于将我们的 `hashRequest` 类型转换为可以用于与客户端通信的协议缓冲区类型。它使用
    `interface{}` 类型，因为它很通用，但在这个情况下，我们可以确信类型，因此我们将传入的请求转换为 `hashRequest`（我们的类型）然后使用适当的字段构建一个新的
    `pb.HashRequest` 对象。
- en: 'We are going to do this for both encoding and decoding requests and responses
    for both hash and validate endpoints. Add the following code to `server_grpc.go`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为此对哈希和验证端点的请求和响应的编码和解码都这样做。将以下代码添加到 `server_grpc.go`：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, there is a lot of boilerplate coding to do in order to get things
    working.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，为了使事情正常工作，我们需要做大量的模板代码编写。
- en: Tip
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Code generation (not covered here) would have great application here, since
    the code is very predictable and self-similar.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 代码生成（此处未涵盖）在这里会有很大的应用，因为代码非常可预测且具有自我相似性。
- en: 'The final thing to do in order to get our gRPC server working is to provide
    a helper function to create an instance of our `grpcServer` structure. Underneath
    the `grpcServer` struct, add the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的 gRPC 服务器正常工作，我们需要提供一个辅助函数来创建我们的 `grpcServer` 结构的实例。在 `grpcServer` 结构体下面添加以下代码：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Like our HTTP server, we take in a base context and the actual `Endpoints` implementation
    that we are exposing via the gRPC server. We create and return a new instance
    of our `grpcServer` type, setting the handlers for both `hash` and `validate`
    by calling `grpctransport.NewServer`. We use our `endpoint.Endpoint` functions
    for our service and tell the service which of our encoding/decoding functions
    to use for each case.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的 HTTP 服务器一样，我们接收一个基本上下文以及通过 gRPC 服务器公开的实际 `Endpoints` 实现。我们通过调用 `grpctransport.NewServer`
    来创建并返回我们 `grpcServer` 类型的新的实例，通过设置 `hash` 和 `validate` 的处理程序。我们使用我们的 `endpoint.Endpoint`
    函数为我们提供服务，并告诉服务使用我们哪些编码/解码函数来处理每个情况。
