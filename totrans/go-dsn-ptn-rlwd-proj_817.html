<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Creating a server command"><div class="book" id="6GRB62-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec0073" class="calibre1"/>Creating a server command</h1></div></div></div><p class="calibre10">So far, all of our service code lives inside the <code class="email">vault</code> package. We are now going to use this package to create a new tool to expose the server functionality.</p><p class="calibre10">Create a new folder in <code class="email">vault</code> called <code class="email">cmd</code>, and inside it create another called <code class="email">vaultd</code>. We are going to put our command code inside the <code class="email">vaultd</code> folder because even though the code will be in the <code class="email">main</code> package, the name of the tool will be <code class="email">vaultd</code> by default. If we just put the command in the <code class="email">cmd</code> folder, the tool would be built into a binary called <code class="email">cmd</code>-which is pretty confusing.</p><div class="informaltable" title="Note"><h3 class="title2"><a id="note00170" class="calibre1"/>Note</h3><p class="calibre10">In Go projects, if the primary use of the package is to be imported into other programs (such as Go kit), then the root level files should make up the package and will have an appropriate package name (not <code class="email">main</code>). If the primary purpose is a command-line tool, such as the Drop command (<a class="calibre1" href="https://github.com/matryer/drop">https://github.com/matryer/drop</a>), then the root files will be in the <code class="email">main</code> package.</p><p class="calibre10">The rationale for this comes down to usability; when importing a package, you want the string the user has to type to be the shortest it can be. Similarly, when using <code class="email">go install</code>, you want the path to be short and sweet.</p></div><p class="calibre10">The tool we are going to build (suffixed with <code class="email">d</code>, indicating that it is a daemon or a background task) will spin up both our gRPC and JSON/HTTP servers. Each will run in their own goroutine, and we will trap any termination signals or errors from the servers, which will cause the termination of our program.</p><p class="calibre10">In Go kit, main functions end up being quite large, which is by design; there is a single function that contains the entirety of your micro-service; from there, you can dig down into the details, but it provides an at-a-glance view of each component.</p><p class="calibre10">We will build up the <code class="email">main</code> function piece by piece inside a new <code class="email">main.go</code> file in the <code class="email">vaultd</code> folder, starting with the fairly big list of imports:</p><pre class="programlisting">import ( 
  "flag" 
  "fmt" 
  "log" 
  "net" 
  "net/http" 
  "os" 
  "os/signal" 
  "syscall" 
  "your/path/to/vault" 
  "your/path/to/vault/pb" 
  "golang.org/x/net/context" 
  "google.golang.org/grpc" 
) 
</pre><p class="calibre10">The <code class="email">your/path/to</code> prefixes should be replaced with the actual route from <code class="email">$GOPATH</code> to where your project is. Pay attention to the context import too; it's quite possible that you just need to type context rather than the import listed here depending on when Go kit transitions to Go 1.7. Finally, the <code class="email">grpc</code> package from Google provides everything we need in order to expose gRPC capabilities over the network.</p><p class="calibre10">Now, we will put together our <code class="email">main</code> function; remember that all the sections following this one go inside the body of the <code class="email">main</code> function:</p><pre class="programlisting">func main() { 
  var ( 
    httpAddr = flag.String("http", ":8080",
      "http listen address") 
    gRPCAddr = flag.String("grpc", ":8081",
      "gRPC listen address") 
  ) 
  flag.Parse() 
  ctx := context.Background() 
  srv := vault.NewService() 
  errChan := make(chan error) 
</pre><p class="calibre10">We use flags to allow the ops team to decide which endpoints we will listen on when exposing the service on the network, but provide sensible defaults of <code class="email">:8080</code> for the JSON/HTTP server and :<code class="email">8081</code> for the gRPC server.</p><p class="calibre10">We then create a new context using the <code class="email">context.Background()</code> function, which returns a non-nil, empty context that has no cancelation or deadline specified and contains no values, perfect for the base context of all of our services. Requests and middleware are free to create new context objects from this one in order to add request-scoped data or deadlines.</p><p class="calibre10">Next, we use our <code class="email">NewService</code> constructor to make a new <code class="email">Service</code> type for us and make a zero-buffer channel, which can take an error should one occur.</p><p class="calibre10">We will now add the code that traps termination signals (such as <span class="strong"><em class="calibre11">Ctrl + C</em></span>) and sends an error down <code class="email">errChan</code>:</p><pre class="programlisting">  go func() { 
    c := make(chan os.Signal, 1) 
    signal.Notify(c, syscall.SIGINT, syscall.SIGTERM) 
    errChan &lt;- fmt.Errorf("%s", &lt;-c) 
  }() 
</pre><p class="calibre10">Here, in a new goroutine, we ask <code class="email">signal.Notify</code> to tell us when we receive the <code class="email">SIGINT</code> or <code class="email">SIGTERM</code> signals. When that happens, the signal will be sent down the <code class="email">c</code> channel, at which point we'll format it as a string (its <code class="email">String()</code> method will be called), and we turn that into an error, which we'll send down <code class="email">errChan</code>, resulting in the termination of the program.</p></div></body></html>