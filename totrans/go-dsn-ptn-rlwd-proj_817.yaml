- en: Creating a server command
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务器命令
- en: So far, all of our service code lives inside the `vault` package. We are now
    going to use this package to create a new tool to expose the server functionality.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的服务代码都位于`vault`包内部。我们现在将使用这个包来创建一个新的工具，以暴露服务器功能。
- en: Create a new folder in `vault` called `cmd`, and inside it create another called
    `vaultd`. We are going to put our command code inside the `vaultd` folder because
    even though the code will be in the `main` package, the name of the tool will
    be `vaultd` by default. If we just put the command in the `cmd` folder, the tool
    would be built into a binary called `cmd`-which is pretty confusing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在`vault`中创建一个新的文件夹名为`cmd`，并在其中创建另一个名为`vaultd`的文件夹。我们将把命令代码放在`vaultd`文件夹中，因为尽管代码将在`main`包中，但工具的名称默认将是`vaultd`。如果我们只是把命令放在`cmd`文件夹中，工具将被构建成一个名为`cmd`的二进制文件，这会很令人困惑。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Go projects, if the primary use of the package is to be imported into other
    programs (such as Go kit), then the root level files should make up the package
    and will have an appropriate package name (not `main`). If the primary purpose
    is a command-line tool, such as the Drop command ([https://github.com/matryer/drop](https://github.com/matryer/drop)),
    then the root files will be in the `main` package.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go项目中，如果包的主要用途是导入到其他程序中（如Go kit），则根级别文件应组成包，并将具有适当的包名（不是`main`）。如果主要目的是命令行工具，如Drop命令（[https://github.com/matryer/drop](https://github.com/matryer/drop)），则根文件将在`main`包中。
- en: The rationale for this comes down to usability; when importing a package, you
    want the string the user has to type to be the shortest it can be. Similarly,
    when using `go install`, you want the path to be short and sweet.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法的原因归结于可用性；当导入一个包时，你希望用户必须输入的字符串尽可能短。同样，当使用`go install`时，你希望路径既短又简洁。
- en: The tool we are going to build (suffixed with `d`, indicating that it is a daemon
    or a background task) will spin up both our gRPC and JSON/HTTP servers. Each will
    run in their own goroutine, and we will trap any termination signals or errors
    from the servers, which will cause the termination of our program.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的工具（后缀为`d`，表示它是一个守护进程或后台任务）将启动我们的gRPC和JSON/HTTP服务器。每个服务器将在自己的goroutine中运行，我们将捕获来自服务器的任何终止信号或错误，这将导致我们的程序终止。
- en: In Go kit, main functions end up being quite large, which is by design; there
    is a single function that contains the entirety of your micro-service; from there,
    you can dig down into the details, but it provides an at-a-glance view of each
    component.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go kit中，主函数最终会变得相当大，这是有意为之的；有一个函数包含了你的整个微服务；从那里，你可以深入了解细节，但它提供了每个组件的快速概览。
- en: 'We will build up the `main` function piece by piece inside a new `main.go`
    file in the `vaultd` folder, starting with the fairly big list of imports:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`vaultd`文件夹中的新`main.go`文件中逐步构建`main`函数，首先是一个相当大的导入列表：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `your/path/to` prefixes should be replaced with the actual route from `$GOPATH`
    to where your project is. Pay attention to the context import too; it's quite
    possible that you just need to type context rather than the import listed here
    depending on when Go kit transitions to Go 1.7\. Finally, the `grpc` package from
    Google provides everything we need in order to expose gRPC capabilities over the
    network.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 应将`your/path/to`前缀替换为从`$GOPATH`到你的项目的实际路由。注意上下文导入；完全有可能在Go kit过渡到Go 1.7时，你只需要输入context而不是这里列出的导入。最后，Google的`grpc`包提供了我们在网络上暴露gRPC能力所需的一切。
- en: 'Now, we will put together our `main` function; remember that all the sections
    following this one go inside the body of the `main` function:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将组合我们的`main`函数；记住，所有跟在后面的部分都应该放在`main`函数的体内：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We use flags to allow the ops team to decide which endpoints we will listen
    on when exposing the service on the network, but provide sensible defaults of
    `:8080` for the JSON/HTTP server and :`8081` for the gRPC server.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用标志来允许运维团队决定在网络上暴露服务时我们将监听哪些端点，但为JSON/HTTP服务器提供合理的默认值`:8080`，为gRPC服务器提供`:8081`。
- en: We then create a new context using the `context.Background()` function, which
    returns a non-nil, empty context that has no cancelation or deadline specified
    and contains no values, perfect for the base context of all of our services. Requests
    and middleware are free to create new context objects from this one in order to
    add request-scoped data or deadlines.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `context.Background()` 函数创建一个新的上下文，该函数返回一个非空、空的上下文，没有指定取消或截止日期，也不包含任何值，非常适合我们所有服务的基上下文。请求和中间件可以自由地从该上下文中创建新的上下文对象，以便添加请求范围的数据或截止日期。
- en: Next, we use our `NewService` constructor to make a new `Service` type for us
    and make a zero-buffer channel, which can take an error should one occur.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用我们的 `NewService` 构造函数为我们创建一个新的 `Service` 类型，并创建一个零缓冲通道，该通道可以接收错误（如果发生的话）。
- en: 'We will now add the code that traps termination signals (such as *Ctrl + C*)
    and sends an error down `errChan`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将添加代码来捕获终止信号（例如 *Ctrl + C*）并将错误发送到 `errChan`：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, in a new goroutine, we ask `signal.Notify` to tell us when we receive
    the `SIGINT` or `SIGTERM` signals. When that happens, the signal will be sent
    down the `c` channel, at which point we'll format it as a string (its `String()`
    method will be called), and we turn that into an error, which we'll send down
    `errChan`, resulting in the termination of the program.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在一个新的goroutine中，我们要求 `signal.Notify` 通知我们何时接收到 `SIGINT` 或 `SIGTERM` 信号。当这种情况发生时，信号将通过
    `c` 通道发送，此时我们将它格式化为字符串（调用其 `String()` 方法），然后将其转换为错误，并将其发送到 `errChan`，从而导致程序终止。
