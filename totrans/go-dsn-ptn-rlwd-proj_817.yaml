- en: Creating a server command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, all of our service code lives inside the `vault` package. We are now
    going to use this package to create a new tool to expose the server functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder in `vault` called `cmd`, and inside it create another called
    `vaultd`. We are going to put our command code inside the `vaultd` folder because
    even though the code will be in the `main` package, the name of the tool will
    be `vaultd` by default. If we just put the command in the `cmd` folder, the tool
    would be built into a binary called `cmd`-which is pretty confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Go projects, if the primary use of the package is to be imported into other
    programs (such as Go kit), then the root level files should make up the package
    and will have an appropriate package name (not `main`). If the primary purpose
    is a command-line tool, such as the Drop command ([https://github.com/matryer/drop](https://github.com/matryer/drop)),
    then the root files will be in the `main` package.
  prefs: []
  type: TYPE_NORMAL
- en: The rationale for this comes down to usability; when importing a package, you
    want the string the user has to type to be the shortest it can be. Similarly,
    when using `go install`, you want the path to be short and sweet.
  prefs: []
  type: TYPE_NORMAL
- en: The tool we are going to build (suffixed with `d`, indicating that it is a daemon
    or a background task) will spin up both our gRPC and JSON/HTTP servers. Each will
    run in their own goroutine, and we will trap any termination signals or errors
    from the servers, which will cause the termination of our program.
  prefs: []
  type: TYPE_NORMAL
- en: In Go kit, main functions end up being quite large, which is by design; there
    is a single function that contains the entirety of your micro-service; from there,
    you can dig down into the details, but it provides an at-a-glance view of each
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build up the `main` function piece by piece inside a new `main.go`
    file in the `vaultd` folder, starting with the fairly big list of imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `your/path/to` prefixes should be replaced with the actual route from `$GOPATH`
    to where your project is. Pay attention to the context import too; it's quite
    possible that you just need to type context rather than the import listed here
    depending on when Go kit transitions to Go 1.7\. Finally, the `grpc` package from
    Google provides everything we need in order to expose gRPC capabilities over the
    network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will put together our `main` function; remember that all the sections
    following this one go inside the body of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We use flags to allow the ops team to decide which endpoints we will listen
    on when exposing the service on the network, but provide sensible defaults of
    `:8080` for the JSON/HTTP server and :`8081` for the gRPC server.
  prefs: []
  type: TYPE_NORMAL
- en: We then create a new context using the `context.Background()` function, which
    returns a non-nil, empty context that has no cancelation or deadline specified
    and contains no values, perfect for the base context of all of our services. Requests
    and middleware are free to create new context objects from this one in order to
    add request-scoped data or deadlines.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use our `NewService` constructor to make a new `Service` type for us
    and make a zero-buffer channel, which can take an error should one occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now add the code that traps termination signals (such as *Ctrl + C*)
    and sends an error down `errChan`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, in a new goroutine, we ask `signal.Notify` to tell us when we receive
    the `SIGINT` or `SIGTERM` signals. When that happens, the signal will be sent
    down the `c` channel, at which point we'll format it as a string (its `String()`
    method will be called), and we turn that into an error, which we'll send down
    `errChan`, resulting in the termination of the program.
  prefs: []
  type: TYPE_NORMAL
