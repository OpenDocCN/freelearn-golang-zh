<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Rate limiting with service middleware"><div class="book" id="6IOCA2-9c484ed022e64a0fb0e1aebf8e05d4fd"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch10lvl1sec0075" class="calibre1"/>Rate limiting with service middleware</h1></div></div></div><p class="calibre10">Now that we have built a complete service, we are going to see how easy it is to add middleware to our endpoints in order to extend the service without touching the actual implementations themselves.</p><p class="calibre10">In real-world services, it is sensible to limit the number of requests it will attempt to handle so that the service doesn't get overwhelmed. This can happen if the process needs more memory than is available, or we might notice performance degradation if it eats up too much of the CPU. In a micro-service architecture, the strategy to solving these problems is to add another node and spread the load, which means that we want each individual instance to be rate limited.</p><p class="calibre10">Since we are providing the client, we should add rate limiting there, which would prevent too many requests from getting on the network. But it is also sensible to add rate limiting to the server in case many clients are trying to access the same services at the same time. Luckily, endpoints in Go kit are used for both the client and server, so we can use the same code to add middleware in both places.</p><p class="calibre10">We are going to add a <span class="strong"><strong class="calibre2">Token Bucket</strong></span>-based rate limiter, which you can read more about at <a class="calibre1" href="https://en.wikipedia.org/wiki/Token_bucket">https://en.wikipedia.org/wiki/Token_bucket</a>. The guys at Juju have written a Go implementation that we can use by importing <code class="email">github.com/juju/ratelimit</code>, and Go kit has middleware built for this very implementation, which will save us a lot of time and effort.</p><p class="calibre10">The general idea is that we have a bucket of tokens, and each request will need a token in order to do its work. If there are no tokens in the bucket, we have reached our limit and the request cannot be completed. Buckets refill over time at a specific interval.</p><p class="calibre10">Import <code class="email">github.com/juju/ratelimit</code> and before we create our <code class="email">hashEndpoint</code>, insert the following code:</p><pre class="programlisting">rlbucket := ratelimit.NewBucket(1*time.Second, 5) 
</pre><p class="calibre10">The <code class="email">NewBucket</code> function creates a new rate limiting bucket that will refill at a rate of one token per second, up to a maximum of five tokens. These numbers are pretty silly for our case, but we want to be able to reach our limits manually during the development.</p><p class="calibre10">Since the Go kit <code class="email">ratelimit</code> package has the same name as the Juju one, we are going to need to import it with a different name:</p><pre class="programlisting">import ratelimitkit "github.com/go-kit/kit/ratelimit"  
</pre></div></body></html>