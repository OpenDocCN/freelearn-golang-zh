- en: Rate limiting with service middleware
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务中间件进行速率限制
- en: Now that we have built a complete service, we are going to see how easy it is
    to add middleware to our endpoints in order to extend the service without touching
    the actual implementations themselves.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了一个完整的服务，我们将看看如何轻松地将中间件添加到我们的端点，以扩展服务而不需要触及实际的实现本身。
- en: In real-world services, it is sensible to limit the number of requests it will
    attempt to handle so that the service doesn't get overwhelmed. This can happen
    if the process needs more memory than is available, or we might notice performance
    degradation if it eats up too much of the CPU. In a micro-service architecture,
    the strategy to solving these problems is to add another node and spread the load,
    which means that we want each individual instance to be rate limited.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的服务中，限制它尝试处理的请求数量是有意义的，这样服务就不会被压垮。这可能发生在进程需要的内存超过可用内存的情况下，或者如果我们注意到性能下降，可能是CPU消耗过多。在微服务架构中，解决这些问题的策略是添加另一个节点并分散负载，这意味着我们希望每个单独的实例都受到速率限制。
- en: Since we are providing the client, we should add rate limiting there, which
    would prevent too many requests from getting on the network. But it is also sensible
    to add rate limiting to the server in case many clients are trying to access the
    same services at the same time. Luckily, endpoints in Go kit are used for both
    the client and server, so we can use the same code to add middleware in both places.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在提供客户端，我们应该在那里添加速率限制，这将防止过多的请求进入网络。但将速率限制添加到服务器也是合理的，以防许多客户端同时尝试访问相同的服务。幸运的是，Go
    kit中的端点既用于客户端也用于服务器，因此我们可以使用相同的代码在两个地方添加中间件。
- en: We are going to add a **Token Bucket**-based rate limiter, which you can read
    more about at [https://en.wikipedia.org/wiki/Token_bucket](https://en.wikipedia.org/wiki/Token_bucket).
    The guys at Juju have written a Go implementation that we can use by importing
    `github.com/juju/ratelimit`, and Go kit has middleware built for this very implementation,
    which will save us a lot of time and effort.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个基于**令牌桶**的速率限制器，你可以通过[https://en.wikipedia.org/wiki/Token_bucket](https://en.wikipedia.org/wiki/Token_bucket)了解更多信息。Juju团队已经编写了一个Go语言的实现，我们可以通过导入`github.com/juju/ratelimit`来使用它，Go
    kit也为此实现构建了中间件，这将为我们节省大量时间和精力。
- en: The general idea is that we have a bucket of tokens, and each request will need
    a token in order to do its work. If there are no tokens in the bucket, we have
    reached our limit and the request cannot be completed. Buckets refill over time
    at a specific interval.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 通用思路是这样的：我们有一个令牌桶，每个请求都需要一个令牌来完成其工作。如果桶中没有令牌，我们就达到了限制，请求无法完成。桶会在特定的时间间隔内自动补充令牌。
- en: 'Import `github.com/juju/ratelimit` and before we create our `hashEndpoint`,
    insert the following code:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 导入`github.com/juju/ratelimit`，在我们创建`hashEndpoint`之前，插入以下代码：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `NewBucket` function creates a new rate limiting bucket that will refill
    at a rate of one token per second, up to a maximum of five tokens. These numbers
    are pretty silly for our case, but we want to be able to reach our limits manually
    during the development.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewBucket`函数创建了一个新的速率限制桶，将以每秒一个令牌的速度补充，最多五个令牌。这些数字对我们来说可能有些荒谬，但我们希望在开发过程中能够手动达到我们的限制。'
- en: 'Since the Go kit `ratelimit` package has the same name as the Juju one, we
    are going to need to import it with a different name:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Go kit的`ratelimit`包与Juju的包同名，我们需要用不同的名称来导入它：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
