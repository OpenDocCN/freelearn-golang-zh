- en: Middleware in Go kit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Endpoint middleware in Go kit is specified by the `endpoint.Middleware` function
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A piece of middleware is simply a function that takes `Endpoint` and returns
    `Endpoint`. Remember that `Endpoint` is also a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This gets a little confusing, but they are the same as the wrappers we built
    for `http.HandlerFunc`. A middleware function returns an `Endpoint` function that
    does something before and/or after calling the `Endpoint` being wrapped. The arguments
    passed into the function that returns the `Middleware` are closured in, which
    means that they are available to the inner code (via closures) without the state
    having to be stored anywhere else.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the `NewTokenBucketLimiter` middleware from Go kit''s `ratelimit`
    package, and if we take a look at the code, we''ll see how it uses closures and
    returns functions to inject a call to the token bucket''s `TakeAvailable` method
    before passing execution to the `next` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A pattern has emerged within Go kit where you obtain the endpoint and then put
    all middleware adaptations inside their own block immediately afterwards. The
    returned function is given the endpoint when it is called, and the same variable
    is overwritten with the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a simple example, consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now do this for our endpoints; update the code inside the main function
    to add the rate limiting middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing much to change here; we're just updating the `hashEndpoint`
    and `validateEndpoint` variables before assigning them to the `vault.Endpoints`
    struct.
  prefs: []
  type: TYPE_NORMAL
