- en: Middleware in Go kit
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go kit 中的中间件
- en: 'Endpoint middleware in Go kit is specified by the `endpoint.Middleware` function
    type:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Go kit 中的 `Endpoint` 中间件是通过 `endpoint.Middleware` 函数类型指定的：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A piece of middleware is simply a function that takes `Endpoint` and returns
    `Endpoint`. Remember that `Endpoint` is also a function:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一段中间件简单来说就是一个接收 `Endpoint` 并返回 `Endpoint` 的函数。记住，`Endpoint` 也是一个函数：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This gets a little confusing, but they are the same as the wrappers we built
    for `http.HandlerFunc`. A middleware function returns an `Endpoint` function that
    does something before and/or after calling the `Endpoint` being wrapped. The arguments
    passed into the function that returns the `Middleware` are closured in, which
    means that they are available to the inner code (via closures) without the state
    having to be stored anywhere else.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点令人困惑，但它们与为我们为 `http.HandlerFunc` 构建的包装器相同。一个中间件函数返回一个 `Endpoint` 函数，该函数在调用被包装的
    `Endpoint` 之前和/或之后执行某些操作。传递给返回 `Middleware` 的函数的参数被闭包，这意味着它们可以通过闭包（无需在其他地方存储状态）在内部代码中使用。
- en: 'We are going to use the `NewTokenBucketLimiter` middleware from Go kit''s `ratelimit`
    package, and if we take a look at the code, we''ll see how it uses closures and
    returns functions to inject a call to the token bucket''s `TakeAvailable` method
    before passing execution to the `next` endpoint:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Go kit 的 `ratelimit` 包中的 `NewTokenBucketLimiter` 中间件，如果我们查看代码，我们会看到它是如何使用闭包和返回函数来在传递执行给
    `next` 端点之前调用令牌桶的 `TakeAvailable` 方法的：
- en: '[PRE2]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A pattern has emerged within Go kit where you obtain the endpoint and then put
    all middleware adaptations inside their own block immediately afterwards. The
    returned function is given the endpoint when it is called, and the same variable
    is overwritten with the result.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go kit 中出现了一种模式，即先获取端点，然后立即在其后创建一个包含所有中间件适配的独立块。当调用返回的函数时，它将端点作为参数传递，并且相同的变量会被覆盖为结果。
- en: 'For a simple example, consider this code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个简单的例子，考虑以下代码：
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will now do this for our endpoints; update the code inside the main function
    to add the rate limiting middleware:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将为我们的端点做这件事；更新主函数内的代码以添加速率限制中间件：
- en: '[PRE4]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's nothing much to change here; we're just updating the `hashEndpoint`
    and `validateEndpoint` variables before assigning them to the `vault.Endpoints`
    struct.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多需要更改的；我们只是在将 `hashEndpoint` 和 `validateEndpoint` 变量赋值给 `vault.Endpoints`
    结构体之前更新它们。
