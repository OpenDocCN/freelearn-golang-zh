- en: Graceful rate limiting
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优雅的速率限制
- en: Rather than returning an error (which is a pretty harsh response), perhaps we
    would prefer the server to just hold onto our request and fulfill it when it can-called
    throttling. For this case, Go kit provides the `NewTokenBucketThrottler` middleware.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是返回一个错误（这是一个相当严厉的响应），我们可能更希望服务器只是保留我们的请求，并在能够完成时履行它——这就是所谓的节流。为此，Go kit 提供了
    `NewTokenBucketThrottler` 中间件。
- en: 'Update the middleware code to use this middleware function instead:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 更新中间件代码以使用此中间件函数：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first argument to `NewTokenBucketThrottler` is the same endpoint as earlier,
    but now we have added a second argument of `time.Sleep`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewTokenBucketThrottler` 的第一个参数与之前相同，但现在我们添加了一个第二个参数 `time.Sleep`。'
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Go kit allows us to customize the behavior by specifying what should happen
    when the delay needs to take place. In our case, we're passing `time.Sleep`, which
    is a function that will ask execution to pause for the specified amount of time.
    You could write your own function here if you wanted to do something different,
    but this works for now.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Go kit 允许我们通过指定在延迟需要发生时应该发生什么来定制行为。在我们的情况下，我们传递了 `time.Sleep`，这是一个将请求执行暂停指定时间的函数。如果你想做不同的事情，你可以在这里编写自己的函数，但现在这个方法可行。
- en: Now repeat the test from earlier, but this time, note that we never get an error-instead,
    the terminal will hang for a second until the request can be fulfilled.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重复之前的测试，但这次，请注意我们永远不会得到一个错误——相反，终端会挂起一秒钟，直到请求能够被满足。
