<html><head></head><body>
<div class="book" title="Chapter&#xA0;11.&#xA0;Deploying Go Applications Using Docker">
<div class="book" title="Using Docker locally">
<div class="book" title="Building a Docker image"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch11lvl2sec00139" class="calibre1"/>Building a Docker image</h2></div></div></div><p class="calibre10">To build the image, in a terminal, navigate to <code class="email">Dockerfile</code> and run the following command:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">docker build -t vaultd</strong></span>
</pre><p class="calibre10">We are using the <code class="email">docker</code> command to build the image. The final dot indicates that we want to build Dockerfile from the current directory. The <code class="email">-t</code> flag specifies that we want to give our image the name of <code class="email">vaultd</code>. This will allow us to refer to it by name rather than a hash that Docker will assign to it.</p><p class="calibre10">If this is the first time you've used Docker, and in particular the <code class="email">scratch</code> base image, then it will take some time to download the required dependencies from Docker Hub depending on your Internet connection. Once that's finished, you will see output similar to the following:</p><pre class="programlisting">
<span class="strong"><strong class="calibre2">Step 1 : FROM scratch</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt;</strong></span>
<span class="strong"><strong class="calibre2">Step 2 : MAINTAINER Your Name &lt;your@email.address&gt;</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt; Using cache</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt; a8667f8f0881</strong></span>
<span class="strong"><strong class="calibre2">Step 3 : ADD vaultd vaultd</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt; 0561c999c1e3</strong></span>
<span class="strong"><strong class="calibre2">Removing intermediate container 4b75fde507df</strong></span>
<span class="strong"><strong class="calibre2">Step 4 : EXPOSE 8080 8081</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt; Running in 8f169f5b3b44</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt; 1d7758c20b3a</strong></span>
<span class="strong"><strong class="calibre2">Removing intermediate container 8f169f5b3b44</strong></span>
<span class="strong"><strong class="calibre2">Step 5 : ENTRYPOINT /vaultd</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt; Running in b5d55d6429be</strong></span>
<span class="strong"><strong class="calibre2"> ---&gt; b7178985dddf</strong></span>
<span class="strong"><strong class="calibre2">Removing intermediate container b5d55d6429be</strong></span>
<span class="strong"><strong class="calibre2">Successfully built b7178985dddf</strong></span>
</pre><p class="calibre10">For each command, a new image is created (you can see the intermediate containers being disposed of along the way) until we end up with the final image.</p><p class="calibre10">Since we are building our binary on our local machine and copying it into the container (with the <code class="email">ADD</code> command), our Docker image ends up being only about 7 MB: pretty small when you consider that it contains everything it needs to run our services.</p></div></div></div></body></html>