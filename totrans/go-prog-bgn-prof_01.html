<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer030">
			<h1 id="_idParaDest-20" class="chapter-number"><a id="_idTextAnchor021"/>1</h1>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor022"/>Variables and Operators</h1>
			<p class="callout-heading"><a id="_idTextAnchor023"/>Overview</p>
			<p class="callout">In this chapter, you will be introduced to various features of Go and gain a basic understanding of what Go code looks like. You will also be provided with a deep understanding of how variables work and will perform exercises and activities to get hands-on and <span class="No-Break">get going.</span></p>
			<p class="callout">By the end of this chapter, you will be able to use variables, packages, and functions in Go. You will also know how to change variable values in Go. Later in this chapter, you will use operators with numbers and design functions <span class="No-Break">using pointers.</span></p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor024"/>Technical requirements</h1>
			<p>For this chapter, you'll require Go version 1.21 or higher. The code for this chapter can be found <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter01"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter01</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor025"/><a id="_idTextAnchor026"/>Introduction to Go</h1>
			<p>Go (or Golang, as it’s often called) is a programming language that’s popular with developers because of how rewarding it is to use<a id="_idIndexMarker000"/> to develop software. It’s also popular with companies because teams of<a id="_idIndexMarker001"/> all sizes can be productive with it. Go has also earned a reputation for consistently delivering software with exceptionally <span class="No-Break">high performance.</span></p>
			<p>Go has an impressive pedigree since it was created by a team from Google with a long history of building great programming languages and operating systems. They created a language that has the feel of a dynamic language such as JavaScript or PHP but with the performance and efficiency of strongly typed languages such as C++ and Java. They wanted a language that was engaging for the programmer but practical in projects with hundreds <span class="No-Break">of developers.</span></p>
			<p>Go is packed with interesting and unique features, such as being compliant with memory safety and channel-based concurrency. We’ll explore these features in this chapter. By doing so, you’ll see that their unique implementation within Go is what makes Go <span class="No-Break">truly special.</span></p>
			<p>Go is written in text files that are then compiled down to machine code and packaged into a single, standalone <a id="_idIndexMarker002"/>executable file. The executable is self-contained, with nothing needed to be installed first to allow it to run. Having a single file makes deploying and distributing Go software hassle-free. When compiling, you can pick one of several target operating systems, including – but not limited to – Windows, Linux, macOS, and Android. With Go, you write your code once and run it anywhere. Complied languages fell out of favor because programmers hated long waits for their code to compile. The Go team knew this and built a lightning-fast compiler that remains fast as <span class="No-Break">projects grow.</span></p>
			<p>Go has a statically typed and type-safe memory model with a garbage collector that automates memory management. This combination protects developers from creating many of the most common bugs and security flaws found in software while still providing excellent performance and efficiency. Dynamically typed languages such as Ruby and Python have become popular in part because programmers felt they could be more productive if they didn’t have to worry about types and memory. The downside of these languages is that they give up performance and memory efficiency and can be more prone to type-mismatch bugs. Go has the same levels of productivity as dynamically typed languages while not giving up performance <span class="No-Break">and efficiency.</span></p>
			<p>A massive shift in computer performance has taken place. Going fast now means you need to be able to do as much work parallel or concurrently as possible. This change is due to the design of modern CPUs, which emphasize more cores over high clock speed. None of the currently popular programming languages have been designed to take advantage of this fact, which makes writing parallel and concurrent code in them error-prone. Go is designed to take advantage of multiple CPU cores, and it removes all the frustration and bug-filled code. Go is designed to allow any developer to easily and safely write parallel and concurrent code that enables them to take advantage of modern multicore CPUs and cloud computing – unlocking high-performance processing and massive scalability without<a id="_idIndexMarker003"/> <span class="No-Break">the dra<a id="_idTextAnchor027"/><a id="_idTextAnchor028"/>ma.</span></p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor029"/>What does Go look like?</h1>
			<p>Let’s take our first look at<a id="_idIndexMarker004"/> some Go code. This code randomly prints a message to the console from a pre-defined list <span class="No-Break">of messa<a id="_idTextAnchor030"/><a id="_idTextAnchor031"/><a id="_idTextAnchor032"/>ges:</span></p>
			<pre class="source-code">
package main
// Import extra functionality from packages
import (
  "err<a id="_idTextAnchor033"/><a id="_idTextAnchor034"/>ors"
  "fmt"
  "log"
  "math/rand"
  "strconv"
  "time"
)// Taken from: https://en.wiktionary.org/wiki/Hello_World#Translations
var helloList = []string{
  "Hello, world",
  "Καλημέρα κόσμε",
  "こんにちは世界",
  "سلام دنیا‎",
  "Привет, мир",
}</pre>			<p>The <strong class="source-inline">main()</strong> function is defined <span class="No-Break">as foll<a id="_idTextAnchor035"/><a id="_idTextAnchor036"/>ows:</span></p>
			<pre class="source-code">
func main() {
  // Seed random number generator using the current time
  rand.NewSource(time.Now().UnixNano())
  // Generate a random number in the range of out list
  index := rand.Intn(len(helloList))
  // Call a function and receive multiple return values
  msg, err := hello(index)
  // Handle any errors
  if err != nil {
    log.Fatal(<a id="_idTextAnchor037"/><a id="_idTextAnchor038"/>err)
  }
  // Print our message to the console
  fmt.Println(msg)
}</pre>			<p>Let’s consider<a id="_idIndexMarker005"/> the <span class="No-Break"><strong class="source-inline">hello()</strong></span><span class="No-Break"> func<a id="_idTextAnchor039"/><a id="_idTextAnchor040"/>tion:</span></p>
			<pre class="source-code">
func hello(index int) (string, error) {
  if index &lt; 0 || index &gt; len(helloList)-1 {
    // Create an error, convert the int type to a string
    return "", errors.New("out of range: " + strconv.Itoa(index))
  }
  return helloList[index], nil
}</pre>			<p>Now, let’s step through this code piece <span class="No-Break">by piece.</span></p>
			<p>At the top of our script is <span class="No-Break">the following:</span></p>
			<pre class="source-code">
package main</pre>			<p>This code is our package declaration. All Go files must start with one of these. If you want to run the code directly, you’ll need to name it <strong class="source-inline">main</strong>. If you don’t name it <strong class="source-inline">main</strong>, then you can use it as a library and import it into other Go code. When creating an importable package, you can give it any name. All Go files in the same directory are considered part of the same<a id="_idIndexMarker006"/> package, which means all the files must have the same <span class="No-Break">package name.</span></p>
			<p>In the following code, we’re importing code <span class="No-Break">from packages:</span></p>
			<pre class="source-code">
// Import extra functionality from packages
import (
  "errors"
  "fmt"
  "log"
  "math/rand"
  "strconv"
  "time"
)</pre>			<p>In this example, the packages are all from Go’s standard library. Go’s standard library is very high-quality and comprehensive. It’s strongly recommended that you maximize your use of it. You can tell if a package isn’t from the standard library because it’ll look like a URL – for <span class="No-Break">example, </span><span class="No-Break"><strong class="source-inline">github.com/fatih/color</strong></span><span class="No-Break">.</span></p>
			<p>Go has a module system that makes using external packages easy. To use a new module, add it to your import path. Go will automatically download it for you the next time you <span class="No-Break">build code.</span></p>
			<p>Imports only apply to the file they’re declared in, which means you must declare the same imports over and over in the same package and project. But fear not – you don’t need to do this by hand. There are many tools and Go editors that automatically add and remove the imports <span class="No-Break">for you:</span></p>
			<pre class="source-code">
// Taken from: https://en.wiktionary.org/wiki/Hello_World#Translations
var helloList = []string{
  "Hello, world",
  "Καλημέρα κόσμε",
  "こんにちは世界",
  "سلام دنیا‎",
  "Привет, мир",
}</pre>			<p>Here, we’re declaring a global variable, which is a list of strings, and initializing it with data. The text or strings in Go support multi-byte UFT-8 encoding, making them safe for any language. The type of list we’re using <a id="_idIndexMarker007"/>here is called a slice. There are three types of lists in Go: slices, arrays, and maps. All three are collections of keys and values, where you use the key to get a <a id="_idIndexMarker008"/>value from the collection. Slice and array collections use a number as the key. The first key is always 0 in slices and arrays. Also, in slices and arrays, the numbers are contiguous, which means there is never a break in the sequence of numbers. With the <strong class="source-inline">map</strong> type, you get to choose the <strong class="source-inline">key</strong> type. You use this when you want to use some other data to look up the value in the map. For example, you could use a book’s ISBN to look up its title <span class="No-Break">and author:</span></p>
			<pre class="source-code">
func main() {
…
}</pre>			<p>Here, we’re declaring a function. A function is some code that runs when called. You can pass data in the form of one or more variables to a function and optionally receive one or more variables back from it. The <strong class="source-inline">main()</strong> function in Go is special. The <strong class="source-inline">main()</strong> function is the entry point of your Go code. There may only be one <strong class="source-inline">main()</strong> function within the <strong class="source-inline">main</strong> package. When your code runs, Go automatically calls <strong class="source-inline">main</strong> to get <span class="No-Break">things started:</span></p>
			<pre class="source-code">
  // Seed random number generator using the current time
  rand.Seed(time.Now().UnixNano())
  // Generate a random number in the range of out list
  index := rand.Intn(len(helloList))</pre>			<p>In the preceding code, we are generating a random number. The first thing we need to do is ensure it’s a good random number; to do that, we must <em class="italic">seed</em> the random number generator. We seed it using the current time formatted to a Unix timestamp with nanoseconds. To get the time, we call the <strong class="source-inline">Now</strong> function in the <strong class="source-inline">time</strong> package. The <strong class="source-inline">Now</strong> function returns a struct type variable. Structs are a collection of properties and functions, a little like objects in other languages. In this case, we are calling the <strong class="source-inline">UnixNano</strong> function on that struct straight away. The <strong class="source-inline">UnixNano</strong> function returns a variable of the <strong class="source-inline">int64</strong> type, which is a 64-bit integer or, more simply, a number. This number is passed into <strong class="source-inline">rand.Seed</strong>. The <strong class="source-inline">rand.Seed</strong> function accepts an <strong class="source-inline">int64</strong> variable as its input. Note that the type of the variable from <strong class="source-inline">time.UnixNano</strong> and <strong class="source-inline">rand.Seed</strong> must be the <a id="_idIndexMarker009"/>same. With that, we’ve successfully seeded the random <span class="No-Break">number generator.</span></p>
			<p>What we want is a number we can use to get a random message. We’ll use <strong class="source-inline">rand.Intn</strong> for this job. This function gives us a random number between 0 and 1, minus the number we pass in. This may sound a bit strange, but it works out perfectly for what we’re trying to do. This is because our list is a slice where the keys start from 0 and increment by 1 for each value. This means the last index is 1 less than the length of <span class="No-Break">the slice.</span></p>
			<p>To show you what this means, here is some <span class="No-Break">sim<a id="_idTextAnchor041"/><a id="_idTextAnchor042"/>ple code:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
)
func main() {
  helloList := []string{
    "Hello, world",
    "Καλημέρα κόσμε",
    "こんにちは世界",
    "سلام دنیا‎",
    "Привет, мир",
  }
  fmt.Println(len(helloList))
  fmt.Println(helloList[len(helloList)-1])
  fmt.Println(helloList[len(helloList)])
}</pre>			<p>This code prints the length of the list <a id="_idIndexMarker010"/>and then uses that length to print the last element. To do that, we must subtract 1; otherwise, we’d get an error, which is what the last <span class="No-Break">lin<a id="_idTextAnchor043"/>e causes:</span></p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/Figure_1.1_B18621.jpg" alt="Figure 1.1: Output displaying an error" width="1670" height="172"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1: Output displaying an error</p>
			<p>Once we’ve generated our random number, we assign it to a variable. We do this with the short variable declaration seen with the <strong class="source-inline">:=</strong> notation, which is a very popular shortcut in Go within a function. It tells the compiler to go ahead and assign that value to the variable and select the appropriate type for that value implicitly. This shortcut is one of the many things that makes Go feel like a dynamically <span class="No-Break">typed language:</span></p>
			<pre class="source-code">
  // Call a function and receive multiple return values
  msg, err := hello(index)</pre>			<p>Then, we use that variable to call a function named <strong class="source-inline">hello</strong>. We’ll look at <strong class="source-inline">hello</strong> in just a moment. The important thing to note is that we’re receiving two values back from the function and we’re able to assign them to two new variables, <strong class="source-inline">msg</strong> and <strong class="source-inline">err</strong>, using the <strong class="source-inline">:=</strong> notation and with <strong class="source-inline">err</strong> as the <span class="No-Break">second value:</span></p>
			<pre class="source-code">
func hello(index int) (string, error) {
…
}</pre>			<p>This code is the definition of the <strong class="source-inline">hello</strong> function; we’re not showing the body for now. A function acts as a unit of logic that’s called when and as often as is needed. When calling a function, the code that calls it stops running and waits for the function to finish running. Functions are a great tool for keeping your code organized and understandable. In the signature of <strong class="source-inline">hello</strong>, we’ve defined that it accepts a single <strong class="source-inline">int</strong> value and that it returns a <strong class="source-inline">string</strong> value and an <strong class="source-inline">error</strong> value. Having <strong class="source-inline">error</strong> as your last return value is a very common thing to have in Go. The code between <strong class="source-inline">{}</strong> is the body of the function. The <a id="_idIndexMarker011"/>following code is what’s run when the <span class="No-Break">function’s called:</span></p>
			<pre class="source-code">
  if index &lt; 0 || index &gt; len(helloList)-1 {
    // Create an error, convert the int type to a string
    return "", errors.New("out of range: " + strconv.Itoa(index))
  }
  return helloList[index], nil</pre>			<p>Here, we are inside the function; the first line of the body is an <strong class="source-inline">if</strong> statement. An <strong class="source-inline">if</strong> statement runs the code inside its <strong class="source-inline">{}</strong> if its Boolean expression is true. The Boolean expression is the logic between <strong class="source-inline">if</strong> and <strong class="source-inline">{</strong>. In this case, we’re testing to see if the passed <strong class="source-inline">index</strong> variable is less than 0 or greater than the largest possible slice <span class="No-Break">index key.</span></p>
			<p>If the Boolean expression were to be true, then our code would return an empty <strong class="source-inline">string</strong> and an <strong class="source-inline">error</strong> value. At this point, the function would stop running, and the code that called the function would continue to run. If the Boolean expression were not true, its code would be skipped over, and our function would return a value from <strong class="source-inline">helloList</strong> and <strong class="source-inline">nil</strong>. In Go, <strong class="source-inline">nil</strong> represents something with no value and <span class="No-Break">no type:</span></p>
			<pre class="source-code">
  // Handle any errors
  if err != nil {
    log.Fatal(err)
  }</pre>			<p>After we’ve run <strong class="source-inline">hello</strong>, the first thing we need to do is check if it ran successfully. We can do this by checking the <strong class="source-inline">error</strong> value stored in <strong class="source-inline">err</strong>. If <strong class="source-inline">err</strong> is not equal to <strong class="source-inline">nil</strong>, then we know we have an error. You will see checks on whether <strong class="source-inline">err</strong> is not equal to <strong class="source-inline">nil</strong> as opposed to checks on whether <strong class="source-inline">err</strong> is equal to <strong class="source-inline">nil</strong>, as this simplifies the checks and logic for the code base. In the case of an error, we call <strong class="source-inline">log.Fatal</strong>, which writes out a logging message and kills our <a id="_idIndexMarker012"/>app. Once the app’s been killed, no more <span class="No-Break">code runs:</span></p>
			<pre class="source-code">
  // Print our message to the console
  fmt.Println(msg)</pre>			<p>If there is no error, then we know that <strong class="source-inline">hello</strong> ran successfully and that the value of <strong class="source-inline">msg</strong> can be trusted to hold a valid value. The final thing we need to do is print the message to the screen via <span class="No-Break">the Terminal.</span></p>
			<p>Here’s how <span class="No-Break">t<a id="_idTextAnchor044"/>hat looks:</span></p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B18621_01_02.jpg" alt="Figure 1.2: Output displaying valid values" width="992" height="342"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2: Output displaying valid values</p>
			<p>In this simple Go program, we’ve been able to cover a lot of key concepts that we’ll explore in full in the <span class="No-Break">coming<a id="_idTextAnchor045"/><a id="_idTextAnchor046"/> chapters.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor047"/>Exercise 1.01 – using variables, packages, and functions to print stars</h2>
			<p>In this exercise, we’ll use some of what we learned about in the preceding example to print a random number, between 1 and 5, of stars (<strong class="source-inline">*</strong>) to the console. This exercise will give you a feel of what <a id="_idIndexMarker013"/>working with Go is like and some practice with using the features<a id="_idIndexMarker014"/> of Go we’ll need going forward. Let’s <span class="No-Break">get</span><span class="No-Break"><a id="_idIndexMarker015"/></span><span class="No-Break"> started:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Now, add the imports we’ll use <a id="_idTextAnchor048"/><a id="_idTextAnchor049"/>in <span class="No-Break">this file:</span><pre class="source-code">
import (
  "fmt"
  "math/rand"
  "strings"
  "time"
)</pre></li>				<li>Create a <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Seed the random <span class="No-Break">number<a id="_idTextAnchor050"/><a id="_idTextAnchor051"/> generator:</span><pre class="source-code">
  rand.Seed(time.Now().UnixNano())</pre></li>				<li>Generate a<a id="_idIndexMarker016"/> random number between 0 and then add 1 to get a number <a id="_idIndexMarker017"/>b<a id="_idTextAnchor052"/><a id="_idTextAnchor053"/>etween 1 <span class="No-Break">and 5:</span><pre class="source-code">
  r := rand.Intn(5) + 1</pre></li>				<li>Use the string repeater to <a id="_idIndexMarker018"/>create a string with the number of <a id="_idTextAnchor054"/><a id="_idTextAnchor055"/>stars <span class="No-Break">we need:</span><pre class="source-code">
  stars := strings.Repeat("*", r)</pre></li>				<li>Print the string with the stars to the console with a new line character at the end and close the <a id="_idTextAnchor056"/><a id="_idTextAnchor057"/><span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
  fmt.Println(stars)
}</pre></li>				<li>Save the file. Then, in the new folder, run <span class="No-Break">the following:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>The following<a id="_idTextAnchor058"/> is <span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B18621_01_03.jpg" alt="Figure 1.3: Output displaying stars" width="1092" height="286"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3: Output displaying stars</p>
			<p>In this exercise, we created a runnable Go program by defining the <strong class="source-inline">main</strong> package with a <strong class="source-inline">main()</strong> function in it. We<a id="_idIndexMarker019"/> used the standard library by adding imports to packages. Those <a id="_idIndexMarker020"/>packages helped us generate a random <a id="_idIndexMarker021"/>number, repeat strings, and wri<a id="_idTextAnchor059"/><a id="_idTextAnchor060"/>te to <span class="No-Break">the console.</span></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor061"/>Activity 1.01 – defining and printing</h2>
			<p>In this activity, we are going to create<a id="_idIndexMarker022"/> a medical form for a doctor’s office to capture a patient’s name, age, and whether they have a <span class="No-Break">peanut allergy:</span></p>
			<ol>
				<li>Create a variable for <span class="No-Break">the following:</span><ol><li class="upper-roman">First name as <span class="No-Break">a string.</span></li><li class="upper-roman">Family name as <span class="No-Break">a string.</span></li><li class="upper-roman">Age as an <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> value.</span></li><li class="upper-roman">Peanut allergy as a <span class="No-Break"><strong class="source-inline">bool</strong></span><span class="No-Break"> value.</span></li></ol></li>
				<li>Ensure they have an <span class="No-Break">initial value.</span></li>
				<li>Print the values to <span class="No-Break">the console.</span></li>
			</ol>
			<p>The following is th<a id="_idTextAnchor062"/>e <span class="No-Break">expected output:</span></p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B18621_01_04.jpg" alt="Figure 1.4: Expected output after assigning the variables" width="1130" height="236"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4: Expected output after assigning the variables</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to all activities in this chapter can be found in the GitHub repository <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter01"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-</span>
<span class="No-Break">Beginner-to-Professional-Second-Edition-/tree/main/Chapter01</span></a></p>
			<p>Next, we’ll start going into detail about what we’ve covered so far, so don’t worry if you are confused or have any <a id="_idIndexMarker023"/>questions about what <a id="_idTextAnchor063"/><a id="_idTextAnchor064"/>you’ve seen <span class="No-Break">so far.</span></p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor065"/>Declaring variables</h1>
			<p>Now that you’ve had a glimpse of Go and completed your first exercise, we’re going to dive deep. Our first stop on our journey <span class="No-Break">is variables.</span></p>
			<p>A variable holds data for <a id="_idIndexMarker024"/>you temporarily so that you can work with it. When you declare a variable, it needs four things: a statement that you are declaring a variable, a name for the variable, the type of data it can hold, and an initial value for it. Fortunately, some of the parts are optional, but that also means there’s more than one way of defining <span class="No-Break">a variable.</span></p>
			<p>Let’s cover all the ways you can<a id="_idTextAnchor066"/><a id="_idTextAnchor067"/> declare <span class="No-Break">a variable.</span></p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor068"/>Declaring a variable using var</h2>
			<p>Using <strong class="source-inline">var</strong> is the foundational way to <a id="_idIndexMarker025"/>declare a variable. Every other way we’ll cover is a variation<a id="_idIndexMarker026"/> of this approach, typically by omitting parts of this definition. A full <strong class="source-inline">var</strong> definition with everything in place looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var foo string = "bar"</pre>			<p>The key parts are <strong class="source-inline">var</strong>, <strong class="source-inline">foo</strong>, <strong class="source-inline">string</strong>, and <strong class="source-inline">= "</strong><span class="No-Break"><strong class="source-inline">bar"</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">var</strong> is our declaration that we are defining <span class="No-Break">a variable</span></li>
				<li><strong class="source-inline">foo</strong> is the name of <span class="No-Break">the variable</span></li>
				<li><strong class="source-inline">string</strong> is the type of <span class="No-Break">the variable</span></li>
				<li><strong class="source-inline">= "bar<a id="_idTextAnchor069"/><a id="_idTextAnchor070"/>"</strong> is its <span class="No-Break">initial value</span></li>
			</ul>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor071"/>Exercise 1.02 – declaring a variable using var</h2>
			<p>In this exercise, we’ll declare two <a id="_idIndexMarker027"/>variables using the full <strong class="source-inline">var</strong> notation. Then, we’ll print <a id="_idIndexMarker028"/>them to the console. You’ll see that you can use the <strong class="source-inline">var</strong> notation anywhere in your code, which isn’t true for all variable declaration notations. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the main package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Add <span class="No-Break">the imports:</span><pre class="source-code">
import (
  "fmt"
)</pre></li>				<li>Declare a variable at the package-level scope. We’ll cover what sco<a id="_idTextAnchor072"/><a id="_idTextAnchor073"/>pes are in <span class="No-Break">detail later:</span><pre class="source-code">
var foo string = "bar"</pre></li>				<li>Cre<a id="_idTextAnchor074"/><a id="_idTextAnchor075"/>ate the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Declare another variable usin<a id="_idTextAnchor076"/><a id="_idTextAnchor077"/>g <strong class="source-inline">var</strong> in <span class="No-Break">our function:</span><pre class="source-code">
  var baz string = "qux"</pre></li>				<li>Print both var<a id="_idTextAnchor078"/><a id="_idTextAnchor079"/>iables to <span class="No-Break">the console:</span><pre class="source-code">
  fmt.Println(foo, baz)</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>				<li>Save the file. Then, in the new folder, run <span class="No-Break">the following:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>The following is <span class="No-Break">the output:</span></p>
			<pre class="console">
bar qux</pre>			<p>In this example, <strong class="source-inline">foo</strong> is declared at the package level while <strong class="source-inline">baz</strong> is declared at the function level. Where a variable<a id="_idIndexMarker029"/> is declared is important because where you declare a variable also limits what notation you can use to <span class="No-Break">declare it.</span></p>
			<p>Next, we’ll look at another<a id="_idIndexMarker030"/> wa<a id="_idTextAnchor080"/><a id="_idTextAnchor081"/>y to use the <span class="No-Break"><strong class="source-inline">var</strong></span><span class="No-Break"> notation.</span></p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor082"/>Declaring multiple variables at once with var</h2>
			<p>We can use a single <strong class="source-inline">var</strong> declaration to define more than one variable using a <strong class="source-inline">var</strong> block or statement. Using this method is common <a id="_idIndexMarker031"/>when declaring package-level<a id="_idIndexMarker032"/> variables. The variables don’t need to be of the same type, and they can all have their own initial values. The notation looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var (
  &lt;name1&gt; &lt;type1&gt; = &lt;value1&gt;
  &lt;name2&gt; &lt;type2&gt; = &lt;value2&gt;
…
  &lt;nameN&gt; &lt;typeN&gt; = &lt;valueN&gt;
)</pre>			<p>You can have multiple of these types of declarations. This is a nice way to group related variables, thereby making your code more readable. You can use this notation in functions, but it’<a id="_idTextAnchor083"/><a id="_idTextAnchor084"/>s rare to see it <span class="No-Break">used there.</span></p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor085"/>Exercise 1.03 – declaring multiple variables at once with var</h2>
			<p>In this exercise, we’ll declare multiple <a id="_idIndexMarker033"/>variables using one <strong class="source-inline">var</strong> statement, each with a different type and initial value. Then, we’ll print the value of each variable to the console. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
<a id="_idTextAnchor086"/><a id="_idTextAnchor087"/>package main</pre></li>				<li>Add <span class="No-Break">the imports:</span><pre class="source-code">
import (
  "fmt"
  "time"<a id="_idTextAnchor088"/><a id="_idTextAnchor089"/>
)</pre></li>				<li>Start the <span class="No-Break"><strong class="source-inline">var</strong></span><span class="No-Break"> declaration:</span><pre class="source-code">
<a id="_idTextAnchor090"/><a id="_idTextAnchor091"/>var (</pre></li>				<li>Define <span class="No-Break">three variab<a id="_idTextAnchor092"/><a id="_idTextAnchor093"/>les:</span><pre class="source-code">
  Debug   bool   = false
  LogLevel  string  = "info"
  startUpTime time.Time = time.Now()</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">var</strong></span><span class="No-Break"> declaration:</span><pre class="source-code">
)</pre></li>				<li>In the <strong class="source-inline">main()</strong> function, print <a id="_idTextAnchor094"/><a id="_idTextAnchor095"/>each variable to <span class="No-Break">the console:</span><pre class="source-code">
func main() {
  fmt.Println(Debug, LogLevel, startUpTime)
}</pre></li>				<li>Save the file. Then, in<a id="_idIndexMarker034"/> the new folder, run <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker035"/></span><span class="No-Break">following:</span><pre class="source-code">
go run <a id="_idTextAnchor096"/>.</pre><p class="list-inset">The following is <span class="No-Break">the output:</span></p></li>			</ol>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/Figure_1.5_B18621.jpg" alt="Figure 1.5: Output displaying three variable values" width="1072" height="66"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5: Output displaying three variable values</p>
			<p>In this exercise, we declared three variables using a single <strong class="source-inline">var</strong> statement. Your output will look different for the <strong class="source-inline">time.Time</strong> variable, but that’s correct. The format is the same, but the time itself <span class="No-Break">is different.</span></p>
			<p>Using the <strong class="source-inline">var</strong> notation like this is a good way to keep your code well organized and save you <span class="No-Break">some typing.</span></p>
			<p>Next, we’ll start removing some <a id="_idIndexMarker036"/>of the opti<a id="_idTextAnchor097"/><a id="_idTextAnchor098"/>onal parts of the <span class="No-Break"><strong class="source-inline">var</strong></span><span class="No-Break"> notation.</span></p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor099"/>Skipping the type or value when declaring variables</h2>
			<p>In real-world code, it’s not common to use the full <strong class="source-inline">var</strong> notation. There are a few cases where you need to define a package-level variable with an initial value and tightly control its type. In those cases, you <a id="_idIndexMarker037"/>need the full notation. It’ll be obvious when this is needed as you’ll have a type mismatch of some kind, so don’t worry too much about this for now. The rest of the time, you’ll remove an optional part or use the short <span class="No-Break">variable declaration.</span></p>
			<p>You don’t need to include both the type and the initial value when declaring a variable. You can use just one or the other; Go works out the rest. If you have a type in the declaration but no initial value, Go uses the zero value for the type you picked. We’ll talk about what a zero value is later in this book. On the other hand, if you have an initial value and no type, Go has a ruleset for how to infer the types that are needed<a id="_idTextAnchor100"/><a id="_idTextAnchor101"/> from the literal value <span class="No-Break">you use.</span></p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor102"/>Exercise 1.04 – skipping the type or value when declaring variables</h2>
			<p>In this exercise, we’ll update our previous exercise so that it skips the optional initial values or type declarations from our variable declaration. Then, we’ll print the values to the console, as we did previously, to show that the result is the same. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main<a id="_idTextAnchor103"/><a id="_idTextAnchor104"/></pre></li>				<li>Import the packages <span class="No-Break">we’ll need:</span><pre class="source-code">
import (
  "fmt"
  "time"
)</pre></li>				<li>Start the <span class="No-Break">multi-variable declaration:</span><pre class="source-code">
var (</pre></li>				<li>The <strong class="source-inline">bool</strong> value in the first exercise has an initial value of false. That’s a <strong class="source-inline">bool</strong> value’s zero value, so we’ll drop the initial value from its declaration as it is set <span class="No-Break">by default:</span><pre class="source-code">
  Debug   bool</pre></li>				<li>The next two variables both<a id="_idIndexMarker038"/> have a non-zero value for their type, so we’<a id="_idTextAnchor105"/><a id="_idTextAnchor106"/>ll drop their <span class="No-Break">type de<a id="_idTextAnchor107"/><a id="_idTextAnchor108"/>claration:</span><pre class="source-code">
  LogLevel  = "info"
  startUpTime = time.Now()</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">var</strong></span><span class="No-Break"> declaration:</span><pre class="source-code">
)</pre></li>				<li>In the <strong class="source-inline">main()</strong> f<a id="_idTextAnchor109"/><a id="_idTextAnchor110"/>unction, print out <span class="No-Break">each variable:</span><pre class="source-code">
func main() {
  fmt.Println(Debug, LogLevel, startUpTime)
}</pre></li>				<li>Save the file. Then, in the new folder, run <span class="No-Break">the following:</span><pre class="source-code">
go ru<a id="_idTextAnchor111"/>n .</pre><p class="list-inset">The following is <span class="No-Break">the output:</span></p></li>			</ol>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/Figure_1.6_B18621.jpg" alt="Figure 1.6: Output displaying variable values despite not mentioning the type while declaring the variables" width="1050" height="66"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6: Output displaying variable values despite not mentioning the type while declaring the variables</p>
			<p>In this exercise, we were able to update the previous code so that it uses a much more compact variable declaration. Declaring variables is something you’ll have to do a lot, and not having to use the<a id="_idIndexMarker039"/> notation makes for a better experience when <span class="No-Break">writing code.</span></p>
			<p>Next, we’ll look at a situation where<a id="_idTextAnchor112"/><a id="_idTextAnchor113"/> you can’t skip any of <span class="No-Break">the parts.</span></p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor114"/>Type inference gone wrong</h2>
			<p>There are times when you’ll need to use all the parts of the declaration – for example, when Go isn’t able to guess the<a id="_idIndexMarker040"/> correct type you need. Let’s <a id="_idTextAnchor115"/><a id="_idTextAnchor116"/>take a look at an example <span class="No-Break">of this:</span></p>
			<pre class="source-code">
package main
import "math/rand"
fun<a id="_idTextAnchor117"/><a id="_idTextAnchor118"/>c main() {
  var seed = 1234456789
  rand.NewSource(seed)
}</pre>			<p>The following is <span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/Figure_1.7_B18621.jpg" alt="Figure 1.7: Output showing an error" width="1545" height="90"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7: Output showing an error</p>
			<p>The issue here is that <strong class="source-inline">rand.NewSource</strong> requires a variable of the <strong class="source-inline">int64</strong> type. Go’s type inference rules interoperate a whole number, such as the one we used as an <strong class="source-inline">int</strong> value. We’ll look at the difference between them in more detail later in this book. To resolve this, we will add <strong class="source-inline">int64</strong> type to the declaration. Here’s how <span class="No-Break">that looks:</span></p>
			<pre class="source-code">
package main
import "math/rand"
func main() {
  var seed int64 = 1234456789
  rand.NewSource(seed)
}</pre>			<p>Next, we’ll look at an <a id="_idIndexMarker041"/>even<a id="_idTextAnchor119"/><a id="_idTextAnchor120"/> quicker way to <span class="No-Break">declare variables.</span></p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor121"/>Short variable declaration</h2>
			<p>When declaring variables in functions and f<a id="_idIndexMarker042"/>unctions only, we can use the <strong class="source-inline">:=</strong> shorthand. This shorthand allows us to make our declarations even shorter. It does this by allowing us to not have to use the <strong class="source-inline">var</strong> keyword and by always inferring the <a id="_idTextAnchor122"/><a id="_idTextAnchor123"/>type from a<a id="_idIndexMarker043"/> required <span class="No-Break">initial value.</span></p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor124"/>Exercise 1.05 – implementing a short variable declaration</h2>
			<p>In this exercise, we’ll update our <a id="_idIndexMarker044"/>previous exercise so that it uses a short variable declaration. Since you can only use a short variable declaration in a function, we’ll move our variable out of the package scope. Where before <strong class="source-inline">Debug</strong> had a type but no initial value, we’ll switch it back so that it has an initial value since that’s required when using a short variable declaration. Finally, we’ll print it to the console. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Import the packages <span class="No-Break">we’ll need:</span><pre class="source-code">
import (
  "fmt"
  "time"
)</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Declare each variable using the<a id="_idTextAnchor125"/><a id="_idTextAnchor126"/> short variable <span class="No-Break">declaration notation:</span><pre class="source-code">
  Debug := false
  LogLevel := "info"
  startUpTime := time.Now(<a id="_idTextAnchor127"/><a id="_idTextAnchor128"/>)</pre></li>				<li>Print the variables to <span class="No-Break">the console:</span><pre class="source-code">
  fmt.Println(Debug, LogLevel, startUpTime)
}</pre></li>				<li>Save the file. Then, in <a id="_idIndexMarker045"/>the new folder, run <span class="No-Break">the following:</span><pre class="source-code">
<a id="_idTextAnchor129"/>go run .</pre></li>			</ol>
			<p>The following is <span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_1.8_B18621.jpg" alt="Figure 1.8: Output displaying the variable values that were printed after using short variable declaration notation" width="1034" height="58"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8: Output displaying the variable values that were printed after using short variable declaration notation</p>
			<p>In this exercise, we updated our previous code to use a very compact way to declare variables when we have an initial value <span class="No-Break">to use.</span></p>
			<p>The <strong class="source-inline">:=</strong> shorthand is very popular with Go developers and the most common way in which variables get defined in real-world Go code. Developers like how it makes their code concise and compact while still being clear as to <span class="No-Break">what’s happening.</span></p>
			<p>Another shortcut is declaring<a id="_idTextAnchor130"/><a id="_idTextAnchor131"/> multiple variables on the <span class="No-Break">same line.</span></p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor132"/>Declaring multiple variables with a short variable declaration</h2>
			<p>It’s possible to declare multiple variables at <a id="_idIndexMarker046"/>the same time using a short variable declaration. They must all be on the same line, and each variable must have a corresponding initial value. The notation looks like <strong class="source-inline">&lt;var1&gt;, &lt;var2&gt;, …, &lt;varN&gt; := &lt;val1&gt;, &lt;val2&gt;, …, &lt;valN&gt;</strong>. The variable names are on the left-hand side of<strong class="source-inline">:=</strong>, separated by <strong class="source-inline">,</strong>. The initial values are on the right-hand side of<strong class="source-inline">:=</strong> again, each separated by <strong class="source-inline">,</strong>. The leftmost variable name gets the leftmost value. There must be an equal number of names <span class="No-Break">and values.</span></p>
			<p>Here is an example that uses our previous <span class="No-Break">exercise’s code:</span></p>
			<pre class="source-code">
package main
imp<a id="_idTextAnchor133"/><a id="_idTextAnchor134"/>ort (
  "fmt"
  "time"
)
func main() {
  Debug, LogLevel, startUpTime := false, "info", time.Now()
  fmt.Println(Debug, LogLevel, startU<a id="_idTextAnchor135"/>pTime)
}</pre>			<p>The following is <span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/Figure_1.9_B18621.jpg" alt="Figure 1.9: Example output displaying the variable values for the program with a variable declaring function" width="1009" height="62"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9: Example output displaying the variable values for the program with a variable declaring function</p>
			<p>Sometimes, you do see real-world code like this. It’s a little hard to read, so it’s not common to see it in terms of literal values. This doesn’t mean this isn’t common, though – it’s very common when calling functions that return multiple values. We’ll cover this in detail when we <a id="_idTextAnchor136"/><a id="_idTextAnchor137"/>look at functions later in <span class="No-Break">this book.</span></p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor138"/>Exercise 1.06 – declaring multiple variables from a function</h2>
			<p>In this exercise, we’ll call a function<a id="_idIndexMarker047"/> that returns multiple<a id="_idIndexMarker048"/> values, and we’ll assign each value to a new variable. Then, we’ll print the values to the console. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Import the packages <span class="No-Break">we’ll need:</span><pre class="source-code">
import (
  "fmt"
  "time"
)</pre></li>				<li>Creat<a id="_idTextAnchor139"/><a id="_idTextAnchor140"/>e a function that returns <span class="No-Break">three values:</span><pre class="source-code">
func getConfig() (bool, string, time.Time) {</pre></li>				<li>In the function, return three<a id="_idTextAnchor141"/><a id="_idTextAnchor142"/> literal values, each separated <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">,</strong></span><span class="No-Break">:</span><pre class="source-code">
  return false, "info", time.Now()</pre></li>				<li>Close <span class="No-Break">the function:</span><pre class="source-code">
}</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Using a short variable declaration, capture the values that were returned fro<a id="_idTextAnchor143"/><a id="_idTextAnchor144"/>m the function’s three <span class="No-Break">new variables:</span><pre class="source-code">
  Debug, LogLevel, startUpTime := getConfig()</pre></li>				<li>Prin<a id="_idTextAnchor145"/><a id="_idTextAnchor146"/>t the three variables to <span class="No-Break">the console:</span><pre class="source-code">
  fmt.Println(Debug, LogLevel, startUpTime)</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>				<li>Save the file. Then, in the<a id="_idIndexMarker049"/> new folder, run <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker050"/></span><span class="No-Break"> followin<a id="_idTextAnchor147"/>g:</span><pre class="source-code">
go run .</pre><p class="list-inset">The following is <span class="No-Break">the output:</span></p></li>			</ol>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/Figure_1.10_B18621.jpg" alt="Figure 1.10: Output displaying the variable values for the program with the variable declaring function" width="1044" height="57"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10: Output displaying the variable values for the program with the variable declaring function</p>
			<p>In this exercise, we were able to call a function that returned multiple values and capture them using a short variable declaration in one line. If we used the <strong class="source-inline">var</strong> notation, it would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
var (
  Debug bool
  LogLevel string
  startUpTime time.Time
)
Debug, LogLevel, startUpTime = getConfig()</pre>			<p>Short variable notation is a big part of how Go has the feel of a <span class="No-Break">dynamic language.</span></p>
			<p>We’re not quite done with <strong class="source-inline">var</strong> yet, though – it<a id="_idTextAnchor148"/><a id="_idTextAnchor149"/> still has a useful trick up <span class="No-Break">its sleeve.</span></p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor150"/>Using var to declare multiple variables in one line</h2>
			<p>While it’s more common to use<a id="_idIndexMarker051"/> a short variable declaration, you can use <strong class="source-inline">var</strong> to define multiple variables on a single line. One limitation of this is that, when<a id="_idIndexMarker052"/> declaring the type, all the values must have the same type. If you use an initial value, then each value infers its type from the literal value s<a id="_idTextAnchor151"/><a id="_idTextAnchor152"/><a id="_idTextAnchor153"/>o that they can differ. Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
  "time"
)
func getConfig() (bool, string, time.Time) {
  return false, "info", time.Now()
}
func main() {
  // Type only
  var start, middle, end float32
  fmt.Println(start, middle, end)
  // Initial value mixed type
  var name, left, right, top, bottom = "one", 1, 1.5, 2, 2.5
  fmt.Println(name, left, right, top, bottom)
  // works with functions also
  var Debug, LogLevel, startUpTime = getConfig()
  fmt.Println(Debug, LogLevel, st<a id="_idTextAnchor154"/>artUpTime)
}</pre>			<p>The following is <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker053"/></span><span class="No-Break">output:</span></p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/Figure_1.11_B18621.jpg" alt="Figure 1.11: Output displaying variable values" width="890" height="112"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11: Output displaying variable values</p>
			<p>Most of these are more compact when using a short variable declaration. This fact means they don’t come up in<a id="_idIndexMarker054"/> real-world code much. The exception is the same type-only example. This notation can be useful when you need many variables of the same type, a<a id="_idTextAnchor155"/><a id="_idTextAnchor156"/>nd you need to control<a id="_idIndexMarker055"/> that <span class="No-Break">type carefully.</span></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor157"/>Non-English variable names</h2>
			<p>Go is a UTF-8 compliant language, which means you can define variables’ names using alphabets other than the Latin alphabet that, for example, English uses. There are some limitations regarding what the name of a<a id="_idIndexMarker056"/> variable can be. The first character of the name must be a letter or <strong class="source-inline">_</strong>. The rest can be a mixture of letters, numbers, and <strong class="source-inline">_</strong>. Let’s have a look at what this <span class="No-Break">looks like:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
  "time"
)
func main() {
  デバッグ := false
  日志级别 := "info"
  ይጀምሩ := time.Now()
  _A1_Μείγμα := "" 
"
  fmt.Println(デバッグ, 日志级别, ይጀምሩ, _A1_Μείγμα)
}</pre>			<p>The following is <span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_1.12_B18621.jpg" alt="Figure 1.12: Output showing variable values" width="910" height="56"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.12: Output showing variable values</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="bold">Languages and language</strong>: Not all programming languages allow you to use UTF-8 characters as variables and function <a id="_idIndexMarker057"/>names. This feature could be one of the reasons why Go has become so popu<a id="_idTextAnchor158"/><a id="_idTextAnchor159"/>lar in Asian countries, particularly <span class="No-Break">in China.</span></p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor160"/>Changing the value of a variable</h1>
			<p>Now that we’ve defined our <a id="_idIndexMarker058"/>variables, let’s see what we can do with them. First, let’s change the value from its initial value. To do that, we’ll use a similar notation to when we set an initi<a id="_idTextAnchor161"/><a id="_idTextAnchor162"/>al value. This looks like <strong class="source-inline">&lt;variable&gt; = &lt;</strong><span class="No-Break"><strong class="source-inline">value&gt;</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor163"/>Exercise 1.07 – changing the value of a variable</h2>
			<p>Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Import the packages <span class="No-Break">we’ll need:</span><pre class="source-code">
import "fmt"</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main(<a id="_idTextAnchor164"/><a id="_idTextAnchor165"/>)</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Declare <span class="No-Break">a variable:</span><pre class="source-code">
  offset := 5</pre></li>				<li>Print the variable to <span class="No-Break">the console:</span><pre class="source-code">
  fmt.Prin<a id="_idTextAnchor166"/><a id="_idTextAnchor167"/>tln(offset)</pre></li>				<li>Change the value of <span class="No-Break">the variable:</span><pre class="source-code">
  offset = 10</pre></li>				<li>Print it to the console again and close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
  fmt.Println(offset)
}</pre></li>				<li>Save the file. Then, in the new folder, run <span class="No-Break">the following:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>The following is the output <a id="_idIndexMarker059"/>before changing the <span class="No-Break">variable’s value:</span></p>
			<pre class="console">
5
10</pre>			<p>In this example, we’ve changed the value of offset from its initial value of <strong class="source-inline">5</strong> to <strong class="source-inline">10</strong>. Anywhere you use a raw value, such as <strong class="source-inline">5</strong> and <strong class="source-inline">10</strong> in our example<a id="_idTextAnchor168"/><a id="_idTextAnchor169"/>, you can use a variable. Here’s how <span class="No-Break">that looks:</span></p>
			<pre class="source-code">
package main
import "fmt"
var defaultOffset = 10
func main() {
  offset := defaultOffset
  fmt.Println(offset)
  offset = offset + defaultOffset
  fmt.Println(offset)
}</pre>			<p>The following is the output after changing the <span class="No-Break">variable’s value:</span></p>
			<pre class="console">
10
20</pre>			<p>Next, we’ll look at how we can ch<a id="_idTextAnchor170"/><a id="_idTextAnchor171"/>ange multiple variables in a <span class="No-Break">one-line statement.</span></p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor172"/>Changing multiple values at once</h2>
			<p>In the same way that you can <a id="_idIndexMarker060"/>declare multiple variables in one line, you can also change the value of more than one variable at a time. The syntax is similar, too; it looks like <strong class="source-inline">&lt;var1<a id="_idTextAnchor173"/><a id="_idTextAnchor174"/>&gt;, &lt;var2&gt;, …, &lt;varN&gt; = &lt;val1&gt;, &lt;val2&gt;, …, &lt;</strong><span class="No-Break"><strong class="source-inline">valN&gt;</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor175"/>Exercise 1.08 – changing multiple values at once</h2>
			<p>In this exercise, we’ll define some variables and use a one-line statement to change their values. Then, we’ll print their new values to the console. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Import the packages <span class="No-Break">we’ll need:</span><pre class="source-code">
import "fmt"</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main<a id="_idTextAnchor176"/><a id="_idTextAnchor177"/>() {</pre></li>				<li>Declare our variables with an <span class="No-Break">initial value:</span><pre class="source-code">
  query, limit, offset := "bat", 10, 0</pre></li>				<li>Change eac<a id="_idTextAnchor178"/><a id="_idTextAnchor179"/>h variable’s values using a <span class="No-Break">one-line statement:</span><pre class="source-code">
  query, limit, offset = "ball", offset, 20</pre></li>				<li>Print the val<a id="_idTextAnchor180"/><a id="_idTextAnchor181"/>ues to the console and close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
  fmt.Println(query, limit, offset)
}</pre></li>				<li>Save the file. Then, in the new folder, run <span class="No-Break">the following:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>The following is the output showing the changed variable values using a <span class="No-Break">single statement:</span></p>
			<pre class="console">
ball 0 20</pre>			<p>In this exercise, we were able to change multiple variables in a single line. This approach would also work when calling functions, just as it does with a variable declaration. You need to be careful with a feature like this to ensure that, first and foremost, your code is easy to read and understand. If using a one-line statement like this makes it hard to know what the code is<a id="_idIndexMarker061"/> doing, then it’s better to take up more lines to write <span class="No-Break">the code.</span></p>
			<p>Next, we’ll look at what operators are and how they can be <a id="_idTextAnchor182"/><a id="_idTextAnchor183"/>used to change your variables in <span class="No-Break">interesting ways.</span></p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor184"/>Operators</h1>
			<p>While variables hold the data for your application, they become truly useful when you start using them to build the logic of your <a id="_idIndexMarker062"/>software. Operators are the tools you use to work with your software’s data. With operators, you can compare data to other data – for example, you can check whether a price is too low or too high in a trading application. You can also use operators to manipulate data. For example, you can use operators to add the costs of all the items in a shopping cart to get the <span class="No-Break">total price.</span></p>
			<p>The following list mentions groups <span class="No-Break">of operators:</span></p>
			<ul>
				<li><strong class="bold">Arithmetic operators</strong>: These are used for<a id="_idIndexMarker063"/> math-related tasks such as addition, subtraction, <span class="No-Break">and multiplication.</span></li>
				<li><strong class="bold">Comparison operators</strong>: These are <a id="_idIndexMarker064"/>used to compare two values; for example, whether they are equal, not equal, less than, or greater than <span class="No-Break">each other.</span></li>
				<li><strong class="bold">Logical operators</strong>: These are<a id="_idIndexMarker065"/> used with Boolean values to see whether they are both true, only one is true, or whether a <strong class="source-inline">bool</strong> value <span class="No-Break">is false.</span></li>
				<li><strong class="bold">Address operators</strong>: We’ll cover <a id="_idIndexMarker066"/>these in detail soon when we look at pointers. These are used to work <span class="No-Break">with them.</span></li>
				<li><strong class="bold">Receive operators</strong>: These are used <a id="_idIndexMarker067"/>when workin<a id="_idTextAnchor185"/><a id="_idTextAnchor186"/>g with Go channels. We’ll cover this later in <span class="No-Break">this book.</span></li>
			</ul>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor187"/>Exercise 1.09 – using operators with numbers</h2>
			<p>In this exercise, we are going to<a id="_idIndexMarker068"/> simulate a restaurant bill. To build our simulation, we’ll need to use mathematic and comparison operators. We’ll start by exploring all the major uses <span class="No-Break">for operators.</span></p>
			<p>In our simulation, we’ll sum everything together and work out the tip based on a percentage. Then, we’ll use a comparison operator to see whether the customer gets a reward. Let’s <span class="No-Break">get started:</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">We have considered the US dollar as the currency for this exercise. You may consider any currency of your choice; the main focus here is <span class="No-Break">the operations.</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Import the packages <span class="No-Break">you’ll need:</span><pre class="source-code">
import "fmt"</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Create a variable to hold the total. For this item on the bill, the customer purchased two items that cost 13 USD. We must use <strong class="source-inline">*</strong> <a id="_idTextAnchor188"/><a id="_idTextAnchor189"/>to do the multiplication. Then, we must print <span class="No-Break">a subtotal:</span><pre class="source-code">
  // Main course
  var total float64 = 2 * 13
  fmt.Println("Sub :", total)</pre></li>				<li>Here, they purchased four items that cost 2.25 USD. We must use multiplication to get the total of these items, use <strong class="source-inline">+</strong> to add it to the prev<a id="_idTextAnchor190"/><a id="_idTextAnchor191"/>ious total value, and then assign that back to <span class="No-Break">the total:</span><pre class="source-code">
  // Drinks
  total = total + (4 * 2.25)
  fmt.Println("Sub :", total)</pre></li>				<li>This customer is getting a<a id="_idIndexMarker069"/> discount <a id="_idTextAnchor192"/><a id="_idTextAnchor193"/>of 5 USD. Here, we use <strong class="source-inline">–</strong> to subtract 5 USD from <span class="No-Break">the total:</span><pre class="source-code">
  // Discount
  total = total - 5
  fmt.Println("Sub :", <a id="_idTextAnchor194"/><a id="_idTextAnchor195"/>total)</pre></li>				<li>Then, we use multiplication to calculate a <span class="No-Break">10% tip:</span><pre class="source-code">
  // 10% Tip
  tip := total * 0.1
  fmt.P<a id="_idTextAnchor196"/><a id="_idTextAnchor197"/>rintln("Tip :", tip)</pre></li>				<li>Finally, we add the tip to <span class="No-Break">the total:</span><pre class="source-code">
  total = total + tip
  fmt.Println("Total:", total)</pre></li>				<li>The bill will be split bet<a id="_idTextAnchor198"/><a id="_idTextAnchor199"/><a id="_idTextAnchor200"/>ween two people. Use <strong class="source-inline">/</strong> to divide the total into <span class="No-Break">two parts:</span><pre class="source-code">
  // Split bill
  split := total / 2
  fmt.Println("Split:", split)</pre></li>				<li>Here, we’ll calculate whether the customer gets a reward. Fir<a id="_idTextAnchor201"/><a id="_idTextAnchor202"/>st, we’ll set <strong class="source-inline">visitCount</strong> and then add 1 USD to <span class="No-Break">this visit:</span><pre class="source-code">
  // Reward every 5th visit
  visitCount := 24
  visitCount = visitCount + 1</pre></li>				<li>Then, we’ll use <strong class="source-inline">%</strong> to<a id="_idTextAnchor203"/><a id="_idTextAnchor204"/> give us any remainder after dividing <strong class="source-inline">visitCount</strong> by <span class="No-Break">5 USD:</span><pre class="source-code">
  remainder := visitCount % 5</pre></li>				<li>The customer gets a<a id="_idIndexMarker070"/> reward on every fifth visit. If the remainder is 0, then this is one of those visit<a id="_idTextAnchor205"/><a id="_idTextAnchor206"/>s. Use the <strong class="source-inline">==</strong> operator to check whether the remainder <span class="No-Break">is 0:</span><pre class="source-code">
  if remainder == 0 <a id="_idTextAnchor207"/><a id="_idTextAnchor208"/>{</pre></li>				<li>If it is, print a message stating that they get <span class="No-Break">a reward:</span><pre class="source-code">
    fmt.Println("With this visit, you've earned a reward.")
  }
}</pre></li>				<li>Save the file. Then, in the new folde<a id="_idTextAnchor209"/>r, run <span class="No-Break">the following:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>The following is <span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B18621_01_13.jpg" alt="Figure 1.13: Output of operators used with numbers" width="1161" height="391"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.13: Output of operators used with numbers</p>
			<p>In this exercise, we used the math and comparison operators with numbers. They allowed us to model a complex situation – calculating a restaurant bill. There are lots of operators and which ones you can use vary with the different types of values. For example, as well as there<a id="_idIndexMarker071"/> being an addition operator for numbers, you can use th<a id="_idTextAnchor210"/><a id="_idTextAnchor211"/>e <strong class="source-inline">+</strong> symbol to join strings together. Here’s this <span class="No-Break">in action:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  givenName := "John"
  familyName := "Smith"
  fullName := givenName + " " + familyName
  fmt.Println("Hello,", fullName)
}</pre>			<p>The following is <span class="No-Break">the output:</span></p>
			<pre class="console">
Hello, John Smith</pre>			<p>For some situations, there are some shortcuts we can make with operators. We’ll go over this in the <span class="No-Break">next section.</span></p>
			<p class="callout-heading">Bitwise operators</p>
			<p class="callout">Go has all the familiar bitwise operators you’d find in programming languages. If you know what bitwise operators are, then<a id="_idIndexMarker072"/> there will be no surprises here for you. If you don’t know what bitwise operato<a id="_idTextAnchor212"/><a id="_idTextAnchor213"/>rs are, don’t worry – they aren’t common in <span class="No-Break">real-world code.</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor214"/>Shorthand operators</h2>
			<p>There are a few shorthand assignment <a id="_idIndexMarker073"/>operators when you want to perform operations on an<a id="_idIndexMarker074"/> existing value with its <span class="No-Break">own value:</span></p>
			<ul>
				<li><strong class="source-inline">--</strong>: Reduce a number <span class="No-Break">by 1</span></li>
				<li><strong class="source-inline">++</strong>: Inc<a id="_idTextAnchor215"/><a id="_idTextAnchor216"/>rease a number <span class="No-Break">by 1</span></li>
				<li><strong class="source-inline">+=</strong>: Add <span class="No-Break">and assign</span></li>
				<li><strong class="source-inline">-=</strong>: Subtract <span class="No-Break">and assign</span></li>
			</ul>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor217"/>Exercise 1.10 – implementing shorthand operators</h2>
			<p>In this exercise, we’ll use some examples <a id="_idIndexMarker075"/>of operator shorthand to show how they can make your code more compact and easier to write. We’ll create some variables and then use shorthand to change them, printing them out as we go. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Import the packages <span class="No-Break">we’ll need:</span><pre class="source-code">
import "fmt"</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> f<a id="_idTextAnchor218"/><a id="_idTextAnchor219"/>unction:</span><pre class="source-code">
func main() {</pre></li>				<li>Create a variable with an <span class="No-Break">initial value:</span><pre class="source-code">
  count := 5</pre></li>				<li>We’ll add to it and t<a id="_idTextAnchor220"/><a id="_idTextAnchor221"/>hen assign the result back to itself. Then, we’ll print <span class="No-Break">it out:</span><pre class="source-code">
  count += 5
  fmt<a id="_idTextAnchor222"/><a id="_idTextAnchor223"/>.Println(count)</pre></li>				<li>Increment the value by 1 and then print <span class="No-Break">it out:</span><pre class="source-code">
  count+<a id="_idTextAnchor224"/><a id="_idTextAnchor225"/>+
  fmt.Println(count)</pre></li>				<li>Decrement it by 1 and then print <span class="No-Break">it out:</span><pre class="source-code">
  count--
  fmt.Println(count)</pre></li>				<li>Subtract<a id="_idTextAnchor226"/><a id="_idTextAnchor227"/> and assign the result back to itself. Print out the <span class="No-Break">new value:</span><pre class="source-code">
  count -= 5
  fmt.Println(count)</pre></li>				<li>Ther<a id="_idTextAnchor228"/><a id="_idTextAnchor229"/>e is also a<a id="_idIndexMarker076"/> shorthand that works with strings. Define <span class="No-Break">a string:</span><pre class="source-code">
  name := "John"</pre></li>				<li>Next, we’<a id="_idTextAnchor230"/><a id="_idTextAnchor231"/>ll append another string to the end of it and then print <span class="No-Break">it out:</span><pre class="source-code">
  name += " Smith"
  fmt.Println("Hello,", name)</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>				<li>Save the file. Then, in the new <a id="_idTextAnchor232"/>folder, run <span class="No-Break">the following:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>The following is <span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B18621_01_14.jpg" alt="Figure 1.14: Output using shorthand operators" width="1212" height="310"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.14: Output using shorthand operators</p>
			<p>In this exercise, we used some shorthand operators. One set focused on modification and then assignment. This type of operation is common, and having these shortcuts makes coding more engaging. The other operators are increment and decrement. These are useful in loops when you need to step over data one at a time. These shortcuts make it clear what you’re doing to anyone who reads <span class="No-Break">your code<a id="_idTextAnchor233"/><a id="_idTextAnchor234"/>.</span></p>
			<p>Next, we’ll look at comparing values to each other <span class="No-Break">in detail.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor235"/>Comparing values</h2>
			<p>Logic in applications is a matter of having your code make a decision. These decisions are made by comparing the values of variables to the rules you define. These rules come in the form of comparisons. We use another set of operators to make these comparisons. The result of <a id="_idIndexMarker077"/>these comparisons is always true or false. You’ll also often need to make lots of these comparisons to make a single decision. To help with that, we have <span class="No-Break">logical operators.</span></p>
			<p>These operators, for the most part, work with two values and always result in a Boolean value. You can only use logical operators with <a id="_idIndexMarker078"/>Boolean values. Let’s take a look at comparison operators and logical operators in <span class="No-Break">more detail.</span></p>
			<p><span class="No-Break"><strong class="bold">Comparison operators</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">==</strong>: True if two values are <span class="No-Break">the same</span></li>
				<li><strong class="source-inline">!=</strong>: True if two values are not <span class="No-Break">the same</span></li>
				<li><strong class="source-inline">&lt;</strong>: True if the left value is less than the <span class="No-Break">right value</span></li>
				<li><strong class="source-inline">&lt;=</strong>: True if the left value is less or equal to the <span class="No-Break">right value</span></li>
				<li><strong class="source-inline">&gt;</strong>: True if the left value is greater than the <span class="No-Break">right value</span></li>
				<li><strong class="source-inline">&gt;=</strong>: True if the left value is greater than or equal to the <span class="No-Break">right value</span></li>
			</ul>
			<p><span class="No-Break"><strong class="bold">Logical operators</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">&amp;&amp;</strong>: True if the left and right<a id="_idIndexMarker079"/> values are <span class="No-Break">both true</span></li>
				<li><strong class="source-inline">||</strong>: True if one or both the left and right values <span class="No-Break">are true</span></li>
				<li><strong class="source-inline">!</strong>: This operator only w<a id="_idTextAnchor236"/><a id="_idTextAnchor237"/>orks with a single value and results in true if the value <span class="No-Break">is false</span></li>
			</ul>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor238"/>Exercise 1.11 – comparing values</h2>
			<p>In this exercise, we’ll use comparison and logical operators to see what Boolean results we get when testing different conditions. We are testing to see what level of membership a user has based on the number of visits <span class="No-Break">they’ve had.</span></p>
			<p>Our membership levels are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Silver</strong>: Between 10 and 20 <span class="No-Break">visits inclusively</span></li>
				<li><strong class="bold">Gold</strong>: Between 21 and 30 <span class="No-Break">visits inclusively</span></li>
				<li><strong class="bold">Platinum</strong>: Over <span class="No-Break">30 visits</span></li>
			</ul>
			<p>Let’s <span class="No-Break">get</span><span class="No-Break"><a id="_idIndexMarker080"/></span><span class="No-Break"> started:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Import the packages <span class="No-Break">we’ll need:</span><pre class="source-code">
import "fmt"</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func <a id="_idTextAnchor239"/><a id="_idTextAnchor240"/>main() {</pre></li>				<li>Define our <strong class="source-inline">visits</strong> variable and initialize it with <span class="No-Break">a value:</span><pre class="source-code">
  visits := 15</pre></li>				<li>Use the equals operator to see whethe<a id="_idTextAnchor241"/><a id="_idTextAnchor242"/>r this is their first visit. Then, print the result to <span class="No-Break">the console:</span><pre class="source-code">
  fmt.Println("First visit   :", visits == 1)</pre></li>				<li>Use <a id="_idTextAnchor243"/><a id="_idTextAnchor244"/>the not equal operator to see whether they are a <span class="No-Break">returning visitor:</span><pre class="source-code">
  fmt.Println("Return visit  :", visits != 1)</pre></li>				<li>Let<a id="_idTextAnchor245"/><a id="_idTextAnchor246"/>’s check whether they are a silver member using the <span class="No-Break">following code:</span><pre class="source-code">
  fmt.Println("Silver member :", visits &gt;= 10 &amp;&amp; visits &lt; 21)</pre></li>				<li>L<a id="_idTextAnchor247"/><a id="_idTextAnchor248"/>et’s check whether they are a gold member using the <span class="No-Break">following code:</span><pre class="source-code">
  fmt.Println("Gold member   :", visits &gt; 20 &amp;&amp; visits &lt;= 30)</pre></li>				<li>Let’s<a id="_idTextAnchor249"/><a id="_idTextAnchor250"/> check whether they are a platinum member using the <span class="No-Break">following code:</span><pre class="source-code">
  fmt.Println("Platinum member :", visits &gt; 30)</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>				<li>Save the file. Then, in the n<a id="_idTextAnchor251"/>ew folder, run <span class="No-Break">the following:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>The following is <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker081"/></span><span class="No-Break">output:</span></p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B18621_01_15.jpg" alt="Figure 1.15: Output displaying the comparison result" width="901" height="227"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.15: Output displaying the comparison result</p>
			<p>In this exercise, we used comparison and logical operators to make decisions about data. You can combine these operators in an unlimited number of ways to express almost any type of logic your software needs <span class="No-Break">to make.</span></p>
			<p>Next, we’ll lo<a id="_idTextAnchor252"/><a id="_idTextAnchor253"/>ok at what happens when you don’t give a variable an <span class="No-Break">initial value.</span></p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor254"/>Zero values</h2>
			<p>The zero value of a variable is the empty or <a id="_idIndexMarker082"/>default value for that variable’s type. Go has a set of rules stating<a id="_idTextAnchor255"/> that the zero values are for all the core types. Let’s take <span class="No-Break">a look:</span></p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B18621_01_16.jpg" alt="Figure 1.16: Variable types and their zero values" width="1350" height="328"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.16: Variable types and their zero values</p>
			<p>There are other types, but they are all derived from these core types, so the same rules <span class="No-Break">still apply.</span></p>
			<p>We<a id="_idTextAnchor256"/><a id="_idTextAnchor257"/>’ll look at the zero<a id="_idIndexMarker083"/> values of some types in the <span class="No-Break">upcoming exercise.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor258"/>Exercise 1.12 – zero values</h2>
			<p>In this example, we’ll define some variables without an initial value. Then, we’ll print out their values. We’re using <strong class="source-inline">fmt.Printf</strong> to help us in this exercise as we can get more detail about a value’s type. <strong class="source-inline">fmt.Printf</strong> uses a template language that allows us to transform passed values. The substitution we’re using is <strong class="source-inline">%#v</strong>. This transformation is a useful tool for showing a variable’s value a<a id="_idTextAnchor259"/>nd type. Some other common substitutions you can try are <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B18621_01_17.jpg" alt="Figure 1.17: Table on substitutions" width="1296" height="507"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.17: Table on substitutions</p>
			<p>When using <strong class="source-inline">fmt.Printf</strong>, you need to add the new line symbol yourself. You can do this by adding <strong class="source-inline">\n</strong> to the end of the string. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Import the packages <span class="No-Break">we’ll need:</span><pre class="source-code">
import (
  "fmt"
  "time"
)</pre></li>				<li>Crea<a id="_idTextAnchor260"/><a id="_idTextAnchor261"/>te the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Declare and print <span class="No-Break">an integer:</span><pre class="source-code">
  var count int
  fm<a id="_idTextAnchor262"/><a id="_idTextAnchor263"/>t.Printf("Count  : %#v \n", count)</pre></li>				<li>Declare and print a <span class="No-Break"><strong class="source-inline">float</strong></span><span class="No-Break"> value:</span><pre class="source-code">
  var discount float64
  fmt.Pr<a id="_idTextAnchor264"/><a id="_idTextAnchor265"/>intf("Discount : %#v \n", discount)</pre></li>				<li>Declare and print a <span class="No-Break"><strong class="source-inline">bool</strong></span><span class="No-Break"> value:</span><pre class="source-code">
  var debug bool
  fmt<a id="_idTextAnchor266"/><a id="_idTextAnchor267"/>.Printf("Debug  : %#v \n", debug)</pre></li>				<li>Declare and <a id="_idIndexMarker084"/>print a <span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break"> v<a id="_idTextAnchor268"/><a id="_idTextAnchor269"/>alue:</span><pre class="source-code">
  var message string
  fmt.Printf("Message : %#v \n", message)</pre></li>				<li>Declare and print a collection <span class="No-Break">of strings:</span><pre class="source-code">
  var emails []string
  fmt.Printf("Emails : %#v \n", emails)</pre></li>				<li>Declare and print a struct (a t<a id="_idTextAnchor270"/><a id="_idTextAnchor271"/>ype composed of other types; we will cover this later in <span class="No-Break">this book):</span><pre class="source-code">
  var startTime time.Time
  fmt.Printf("Start  : %#v \n", startTime)</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>				<li>Save the file. Then, in the new folder, run <span class="No-Break">the following:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>The following is <span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_1.18_B18621.jpg" alt="Figure 1.18: Output showing initial variable values" width="1052" height="198"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.18: Output showing initial variable values</p>
			<p>In this exercise, we defined a variety of variable types without an initial value. Then, we printed them out using <strong class="source-inline">fmt.Printf</strong> to expose more detail about the values. Knowing what the zero values<a id="_idIndexMarker085"/> are and how Go controls them allows you to avoid bugs and write <span class="No-Break">concise code.</span></p>
			<p>Next, we’ll look at what p<a id="_idTextAnchor272"/><a id="_idTextAnchor273"/>ointers are and how they can enable you to write <span class="No-Break">efficient software.</span></p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor274"/>Value versus pointer</h1>
			<p>With values such as <strong class="source-inline">int</strong>, <strong class="source-inline">bool</strong>, and <strong class="source-inline">string</strong>, when you pass them to a function, Go makes a copy of the value, and it’s the copy that’s used in the function. This copying means that a change that’s made <a id="_idIndexMarker086"/>to the value in the function doesn’t affect the value that you used when calling <span class="No-Break">the function.</span></p>
			<p>Passing values by copying tends to<a id="_idIndexMarker087"/> result in code that has fewer bugs. With this method of passing values, Go can use its simple memory management system, called the stack. The downside is that <a id="_idIndexMarker088"/>copying uses up more and more memory as values get passed from function to function. In real-world code, functions tend to be small, and values get passed to lots of functions, so copying by value can sometimes end up using much more memory than <span class="No-Break">is needed.</span></p>
			<p>There is an alternative to copying that uses less memory. Instead of passing a value, we create something called a pointer and then<a id="_idIndexMarker089"/> pass that to functions. A pointer is not a value itself, and you can’t do anything useful with a pointer other than getting a value using it. You can think of a pointer as the address of the value you want, and to get to the value, you must go to the address. If you use a pointer, Go won’t make a copy of the value when passing a pointer to <span class="No-Break">a function.</span></p>
			<p>When creating a pointer to a value, Go can’t manage the value’s memory using the stack. This is because the stack relies on simple scope logic to know when it can reclaim the memory that’s used by a value, and having a pointer to a variable means these rules don’t work. Instead, Go puts the value on the heap. The heap allows the value to exist until no part of your software has <a id="_idIndexMarker090"/>a pointer to it anymore. Go reclaims these values in what it calls its garbage collection process. This process happens periodically in the background, and you don’t need to worry <span class="No-Break">about it.</span></p>
			<p>Having a pointer to a value means that a value is put on the heap, but that’s not the only reason that happens. Working out whether a value needs to be put on<a id="_idIndexMarker091"/> the heap is called escape analysis. There are <a id="_idIndexMarker092"/>times when a value with no pointers is put on the heap, and it’s not always <span class="No-Break">clear why.</span></p>
			<p>You have no direct control over whether a value is put on the stack or the heap. Memory management is not part of Go’s language specification. Memory management is considered an internal implementation detail. This means it could be changed at any time, and that what we’ve spoken about are only general guidelines and not fixed rules and could change at a <span class="No-Break">later date.</span></p>
			<p>While the benefits of using a pointer over a value that gets passed to lots of functions are clear for memory usage, it’s not so clear for CPU usage. When a value gets copied, Go needs CPU cycles to get that memory and then release it later. Using a pointer avoids this CPU usage when passing it to a function. On the other hand, having a value on the heap means that it then needs to be managed by the complex garbage collection process. This process can become a CPU bottleneck in certain situations – for example, if there are lots of values on the heap. When this happens, the garbage collector has to do lots of checking, which uses up CPU cycles. There is no correct answer here, and the best approach is the classic performance optimization one. First, don’t prematurely optimize. When you do have a performance problem, measure before you make a change, and then measure after you’ve made <span class="No-Break">a change.</span></p>
			<p>Beyond performance, you can use pointers to change your code’s design. Sometimes, using pointers allows for a cleaner interface and simplifies your code. For example, if you need to know whether a value is present or not, a non-pointer value always has at least its zero value, which could be valid in your logic. You can use a pointer to allow for an <strong class="source-inline">is not set</strong> state as well as holding a value. This is because pointers, as well as holding the address to a value, can also be <strong class="source-inline">nil</strong>, which means there is no value. In Go, <strong class="source-inline">nil</strong> is a special type that represents something not having <span class="No-Break">a value.</span></p>
			<p>The ability for a pointer to be nil also means that it’s possible to get the value of a pointer when it doesn’t have a value associated with it, which means you’ll get a runtime error. To prevent runtime errors, you can compare a pointer to <strong class="source-inline">nil</strong> before trying to get its value. This looks like <strong class="source-inline">&lt;pointer&gt; != nil</strong>. You can compare pointers with other pointers of the same type, but they only result in true if you are comparing a pointer to itself. No <a id="_idIndexMarker093"/>comparison of the associated values <span class="No-Break">gets made.</span></p>
			<p>Pointers are powerful tools in the language thanks to their efficiency, ability to pass by reference (instead of pass by value) to allow functions to modify the original values, and how they allow for <a id="_idIndexMarker094"/>dynamic memory allocation using the garbage collector. However, with any great tool comes great responsibility. Pointers can be dangerous if misused, such as in the event memory is freed (deallocated) and the pointer becomes a “dangling pointer,” which could lead to undefined behavior if accessed. There is also the potential for memory leaks, unsafe operations due to direct memory access, and concurrency challenges if there are shared pointers that could introduce data races. Overall, Go’s pointers are generall<a id="_idTextAnchor275"/><a id="_idTextAnchor276"/>y straightforward and less error-prone compared to other languages such <span class="No-Break">as C.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor277"/>Getting a pointer</h2>
			<p>To get a pointer, you have a few options. You can declare a variable as being a pointer type using a <strong class="source-inline">var</strong> statement. You<a id="_idIndexMarker095"/> can do this by adding <strong class="source-inline">*</strong> at the front of most types. This notation looks like <strong class="source-inline">var &lt;name&gt; *&lt;type&gt;</strong>. The initial value of a variable that uses this method is <strong class="source-inline">nil</strong>. You can use the built-in <strong class="source-inline">new</strong> function for this. This function is intended to be used to get some memory for a type and return a pointer to that address. The notation looks like <strong class="source-inline">&lt;name&gt; := new(&lt;type&gt;)</strong>. The <strong class="source-inline">new</strong> function can be used with <strong class="source-inline">var</strong> too. You can also get a pointer from an existing variable u<a id="_idTextAnchor278"/><a id="_idTextAnchor279"/>sing <strong class="source-inline">&amp;, which you can read as "address of"</strong>. This looks like <strong class="source-inline">&lt;var1&gt; := &amp;&lt;</strong><span class="No-Break"><strong class="source-inline">var2&gt;.</strong></span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor280"/>Exercise 1.13 – getting a pointer</h2>
			<p>In this exercise, we’ll use each of the methods we can use to get a pointer variable. Then, we’ll print them to the <a id="_idIndexMarker096"/>console using <strong class="source-inline">fmt.Printf</strong> to see what their types and value are. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Import the packages <span class="No-Break">we’ll need:</span><pre class="source-code">
import (
  "fmt"
  "time"
)</pre></li>				<li>Creat<a id="_idTextAnchor281"/><a id="_idTextAnchor282"/>e the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Declare a <a id="_idTextAnchor283"/><a id="_idTextAnchor284"/><a id="_idTextAnchor285"/>pointer using a <span class="No-Break"><strong class="source-inline">var</strong></span><span class="No-Break"> statement:</span><pre class="source-code">
  var count1 *int</pre></li>				<li>Create a variable <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">new</strong></span><span class="No-Break">:</span><pre class="source-code">
  count2 := new(int)</pre></li>				<li>You can’t take<a id="_idTextAnchor286"/><a id="_idTextAnchor287"/> the address of a literal number. Create a temporary variable to hold <span class="No-Break">a n<a id="_idTextAnchor288"/><a id="_idTextAnchor289"/>umber:</span><pre class="source-code">
  countTemp := 5</pre></li>				<li>Using <strong class="source-inline">&amp;</strong>, create a pointer from the <span class="No-Break">existing variable:</span><pre class="source-code">
  count3 := &amp;countTemp</pre></li>				<li>It’s possible to create a pointer from som<a id="_idTextAnchor290"/><a id="_idTextAnchor291"/>e types without a temporary variable. Here, we’re usi<a id="_idTextAnchor292"/><a id="_idTextAnchor293"/>ng our trusty <span class="No-Break"><strong class="source-inline">time</strong></span><span class="No-Break"> struct:</span><pre class="source-code">
  t := &amp;time.Time{}</pre></li>				<li>Print each <a id="_idIndexMarker097"/>out <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">fmt.Printf</strong></span><span class="No-Break">:</span><pre class="source-code">
  fmt.Printf("count1: %#v\n", count1)
  fmt.Printf("count2: %#v\n", count2)
  fmt.Printf("count3: %#v\n", count3)
  fmt.Printf("time : %#v\n", t)</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>				<li>Save the file. Then, in the new folder, run <span class="No-Break">the followin<a id="_idTextAnchor294"/>g:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>The following is <span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B18621_01_19.jpg" alt="Figure 1.19: Output showing pointers" width="1003" height="167"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.19: Output showing pointers</p>
			<p>In this exercise, we looked at three different ways of creating a pointer. Each one is useful, depending on what your code needs. With the <strong class="source-inline">var</strong> statement, the pointer has a value of <strong class="source-inline">nil</strong>, while the others already have a value address associated with them. For the <strong class="source-inline">time</strong> variable, we can see the value, but we can tell it’s a pointer because i<a id="_idTextAnchor295"/><a id="_idTextAnchor296"/>ts output starts <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">&amp;</strong></span><span class="No-Break">.</span></p>
			<p>Next, we’ll see how we can get a value from <span class="No-Break">a pointer.</span></p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor297"/>Getting a value from a pointer</h2>
			<p>In the previous exercise, when we printed out the pointer variables for the <strong class="source-inline">int</strong> pointers to the console, we <a id="_idIndexMarker098"/>either got <strong class="source-inline">nil</strong> or saw a memory address. To get to the value a pointer is associated with, you must dereference the value using <strong class="source-inline">*</strong> in front of the variable name. This looks <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">fmt.Println(*&lt;val&gt;)</strong></span><span class="No-Break">.</span></p>
			<p>Dereferencing a zero or <strong class="source-inline">nil</strong> pointer is a common bug in Go software as the compiler can’t warn you about it, and it happens when the app is running. Therefore, it’s always best practice to check that a pointer is not <strong class="source-inline">nil</strong> before dereferencing it unless you are certain it’s <span class="No-Break">not </span><span class="No-Break"><strong class="source-inline">nil</strong></span><span class="No-Break">.</span></p>
			<p>You don’t always need to dereference – for example, when a property or function is on a struct. Don’t worry too much about when you shouldn’t be dereferencing as<a id="_idTextAnchor298"/><a id="_idTextAnchor299"/> Go gives you clear errors regarding when you can and can’t dereference <span class="No-Break">a value.</span></p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor300"/>Exercise 1.14 – getting a value from a pointer</h2>
			<p>In this exercise, we’ll update our previous exercise to dereference the values from the pointers. We’ll also add <strong class="source-inline">nil</strong> checks to prevent us from getting any errors. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Import the packages <span class="No-Break">we’ll need:</span><pre class="source-code">
import (
  "fmt"
  "time"
)</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
<a id="_idTextAnchor301"/><a id="_idTextAnchor302"/>func main() {</pre></li>				<li>Our pointers are declared in the same way as they <span class="No-Break">were previously:</span><pre class="source-code">
  var count1 *int
  count2 := new(int)
  countTemp := 5
  count3 := &amp;countTemp
  t := &amp;time.Time{}</pre></li>				<li>For counts <a id="_idTextAnchor303"/><a id="_idTextAnchor304"/>1, 2, and 3, we <a id="_idIndexMarker099"/>need to add a <strong class="source-inline">nil</strong> check and add <strong class="source-inline">*</strong> in front of the <span class="No-Break">variable name:</span><pre class="source-code">
  if count1 != nil {
    fmt.Printf("count1: %#v\n", *count1)
  }
  if count2 != nil {
    fmt.Printf("count2: %#v\n", *count2)
  }
  if count3 != nil {
    fmt.Print<a id="_idTextAnchor305"/><a id="_idTextAnchor306"/>f("count3: %#v\n", *count3)
  }</pre></li>				<li>We’ll also add a <strong class="source-inline">nil</strong> check for our <span class="No-Break"><strong class="source-inline">time</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
  if t != nil {</pre></li>				<li>W<a id="_idTextAnchor307"/><a id="_idTextAnchor308"/>e’ll dereference the variable using <strong class="source-inline">*</strong>, just like we did with the <span class="No-Break"><strong class="source-inline">count</strong></span><span class="No-Break"> variables:</span><pre class="source-code">
    fmt.Printf("time : %#v\n", *t)</pre></li>				<li>Here, we’re cal<a id="_idTextAnchor309"/><a id="_idTextAnchor310"/>ling a function on our <strong class="source-inline">time</strong> variable. This time, we don’t need to <span class="No-Break">dereference it:</span><pre class="source-code">
    fmt.Printf("time : %#v\n", t.String())</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">nil</strong></span><span class="No-Break"> check:</span><pre class="source-code">
  }</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>				<li>Save the file. Then, in the new folder, run <span class="No-Break">the following:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>The following is <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker100"/></span><span class="No-Break">output:</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B18621_01_20.jpg" alt="Figure 1.20: Output showing getting values from pointers" width="1008" height="171"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.20: Output showing getting values from pointers</p>
			<p>In this exercise, we used dereferencing to get the values from our pointers. We also used <strong class="source-inline">nil</strong> checks to prevent dereferencing errors. From the output of this exercise, we can see that <strong class="source-inline">count1</strong> was a <strong class="source-inline">nil</strong> value and that we’d have gotten an error if we tried to dereference. <strong class="source-inline">count2</strong> was created using <strong class="source-inline">new</strong>, and its value is a zero value for its type. <strong class="source-inline">count3</strong> also had a value that matched the value of the variable we got the pointer from. With our <strong class="source-inline">time</strong> variable, we were able to dereference the whole struct, which is why our output doesn’t start <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">&amp;</strong></span><span class="No-Break">.</span></p>
			<p>Ne<a id="_idTextAnchor311"/><a id="_idTextAnchor312"/>xt, we’ll look at how using a pointer allows us to change the design of <span class="No-Break">our code.</span></p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor313"/>Function design with pointers</h2>
			<p>We’ll cover functions in more <a id="_idIndexMarker101"/>detail later in this book, but you know enough from what we’ve done so far to see how using a pointer can change how you use a function. A function must be coded to accept pointers, and it’s not something that you can choose whether to do or not. If you have a pointer variable or have passed a pointer of a variable to a function, any changes that are made to the value of the varia<a id="_idTextAnchor314"/><a id="_idTextAnchor315"/>ble in the function also affect the value of the variable outside of <span class="No-Break">the function.</span></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor316"/>Exercise 1.15 – function design with pointers</h2>
			<p>In this exercise, we’ll create two functions: one that accepts a number by value, adds 5 to it, and then prints the number to the console; and another function that accepts a number as a pointer, adds 5 to it, and then prints the number out. We’ll also print the number out after calling each <a id="_idIndexMarker102"/>function to assess what effect it has on the variable that was passed to the function. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Import the packages <span class="No-Break">w<a id="_idTextAnchor317"/><a id="_idTextAnchor318"/>e’ll need:</span><pre class="source-code">
import "fmt"</pre></li>				<li>Create a function that takes an <a id="_idTextAnchor319"/><a id="_idTextAnchor320"/><strong class="source-inline">int</strong> pointer as <span class="No-Break">an argument:</span><pre class="source-code">
func add5Value(count int) <a id="_idTextAnchor321"/><a id="_idTextAnchor322"/>{</pre></li>				<li>Add <strong class="source-inline">5</strong> to the <span class="No-Break">passed number:</span><pre class="source-code">
  count += 5</pre></li>				<li>Print the updated number to <span class="No-Break">the console:</span><pre class="source-code">
  fmt.Println("add5Value   <a id="_idTextAnchor323"/><a id="_idTextAnchor324"/>:", count)</pre></li>				<li>Close <span class="No-Break">the function:</span><pre class="source-code">
}</pre></li>				<li>Create another function that takes <a id="_idTextAnchor325"/><a id="_idTextAnchor326"/>an <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> pointer:</span><pre class="source-code">
func add5Point(count *int) {</pre></li>				<li>Dereference the value and <a id="_idTextAnchor327"/><a id="_idTextAnchor328"/>add <strong class="source-inline">5</strong> <span class="No-Break">to it:</span><pre class="source-code">
  *count += 5</pre></li>				<li>Print out the updated value of <strong class="source-inline">count</strong> and <span class="No-Break">dereference it:</span><pre class="source-code">
  fmt.Println("add5Point   :", *count)</pre></li>				<li>Close<a id="_idTextAnchor329"/><a id="_idTextAnchor330"/> <span class="No-Break">the function:</span><pre class="source-code">
}</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li><a id="_idTextAnchor331"/><a id="_idTextAnchor332"/>Declare an <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
  var count int</pre></li>				<li>Call the first func<a id="_idTextAnchor333"/><a id="_idTextAnchor334"/>tion with <span class="No-Break">the variable:</span><pre class="source-code">
  add5Value(count)</pre></li>				<li>Print the current value of <span class="No-Break">the variable:</span><pre class="source-code">
  fmt.Println("add5Value post:", count)</pre></li>				<li>Call the <a id="_idTextAnchor335"/><a id="_idTextAnchor336"/>second <a id="_idIndexMarker103"/>function. This time, you’ll need to use <strong class="source-inline">&amp;</strong> to pass a p<a id="_idTextAnchor337"/><a id="_idTextAnchor338"/>ointer to <span class="No-Break">the variable:</span><pre class="source-code">
  add5Point(&amp;count)</pre></li>				<li>Print the current value of <span class="No-Break">the variable:</span><pre class="source-code">
  fmt.Println("add5Point post:", count)</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>				<li>Save the fil<a id="_idTextAnchor339"/>e. Then, in the new folder, run <span class="No-Break">the following:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>The following is <span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B18621_01_21.jpg" alt="Figure 1.21: Output displaying the current value of the variable" width="1100" height="232"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.21: Output displaying the current value of the variable</p>
			<p>In this exercise, we showed you how passing values by a pointer can affect the value variables that are passed to them. We saw that, when passing by value, the changes you make to the value in a function do not affect the value of the variable that’s passed to the function, while passing a pointer to a value does change the value of the variable passed to <span class="No-Break">the function.</span></p>
			<p>You can use this fact to overcome awkward design problems and sometimes simplify the design of your code. Passing <a id="_idIndexMarker104"/>values by a pointer has traditionally been shown to be more error-prone, so use this design sparingly. It’s also common to use pointers<a id="_idTextAnchor340"/><a id="_idTextAnchor341"/> in functions to create more efficient code, which Go’s standard library does <span class="No-Break">a lot.</span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor342"/>Activity 1.02 – pointer value swap</h2>
			<p>In this activity, your job is to <a id="_idIndexMarker105"/>finish some code a co-worker started. Here, we have some unfinished code for you to complete. Your task is to fill in the missing code, where the comments are to swap the values of <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>. The <strong class="source-inline">swap</strong> function only accepts pointers and doesn’t <span class="No-Break">return anything:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  a, b := 5, 10
  // call swap here
  fmt.Println(a == 10, b == 5)
}
func swap(a *int, b *int) {
  // swap the values here
}</pre>			<p>Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Call the <strong class="source-inline">swap</strong> function, ensuring you are passing <span class="No-Break">a pointer.</span></li>
				<li>In the <strong class="source-inline">swap</strong> function, assign the values to the other pointer, ensuring you dereference <span class="No-Break">the values.</span></li>
			</ol>
			<p>The following is the <span class="No-Break">expected <a id="_idTextAnchor343"/><a id="_idTextAnchor344"/>output:</span></p>
			<pre class="console">
true true</pre>			<p>Next, we’ll look at how<a id="_idIndexMarker106"/> we can create variables with a <span class="No-Break">fixed value.</span></p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor345"/>Constants</h1>
			<p>Constants are like variables, but you can’t change their initial values. These are useful for situations where the value of a constant doesn’t need to or shouldn’t change when your code is running. You could make the argument that you could hardcode those values into the code and it would<a id="_idIndexMarker107"/> have a similar effect. Experience has shown us that while these values don’t need to change at runtime, they may need to change later. If that happens, it can be an arduous and error-prone task to track down and fix all the hardcoded values. Using a constant is a tiny amount of work now that can save you a great deal of <span class="No-Break">effort later.</span></p>
			<p>Constant declarations are similar to <strong class="source-inline">var</strong> statements. With a constant, the initial value is required. Types are optional and inferred if left out. The initial value can be a literal or a simple statement and can use the values of other constants. Like <strong class="source-inline">var</strong>, you can declare multiple constants in one statement. Here are <span class="No-Break">the notations:</span></p>
			<pre class="source-code">
constant &lt;name&gt; &lt;type&gt; = &lt;value&gt;
constant (
  &lt;<a id="_idTextAnchor346"/><a id="_idTextAnchor347"/>name1&gt; &lt;type1&gt; = &lt;value1&gt;
  &lt;name2&gt; &lt;type2&gt; = &lt;value3&gt;
…
  &lt;nameN&gt; &lt;typeN&gt; = &lt;valueN&gt;
)</pre>			<h2 id="_idParaDest-62"><a id="_idTextAnchor348"/>Exercise 1.16 – constants</h2>
			<p>In this exercise, we have a performance problem: our database server is too slow. We are going to create a custom memory cache. We’ll use Go’s <strong class="source-inline">map</strong> collection type, which will act as the cache. There is a global limit on the number of items that can be in the cache. We’ll use one <strong class="source-inline">map</strong> to help keep track of the number of items in the cache. We have two types of data we<a id="_idIndexMarker108"/> need to cache: books and CDs. Both use the ID, so we need a way to separate the two types of items in the shared cache. We need a way to set and get items from <span class="No-Break">the cache.</span></p>
			<p>We’re going to set the maximum number of items in the cache. We’ll also use constants to add a prefix to differentiate between books and CDs. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Impo<a id="_idTextAnchor349"/><a id="_idTextAnchor350"/>rt the packages <span class="No-Break">we’ll need:</span><pre class="source-code">
import "fmt"</pre></li>				<li>Create a constant that’s our global <span class="No-Break">limit size:</span><pre class="source-code">
const <a id="_idTextAnchor351"/><a id="_idTextAnchor352"/>GlobalLimit = 100</pre></li>				<li>Create a <strong class="source-inline">MaxCacheSize</strong> constant that is 10 times the<a id="_idTextAnchor353"/><a id="_idTextAnchor354"/> global <span class="No-Break">limit size:</span><pre class="source-code">
const MaxCacheSize int = 10 * GlobalLimit</pre></li>				<li>Create our <span class="No-Break">cache prefixes:</span><pre class="source-code">
const (
  CacheKeyBook = "book_"
  CacheKeyCD = "cd_"
)</pre></li>				<li>Declare a <strong class="source-inline">map<a id="_idTextAnchor355"/><a id="_idTextAnchor356"/></strong> value that has a <strong class="source-inline">string</strong> value for a key and a <strong class="source-inline">string</strong> value for its values <a id="_idTextAnchor357"/><a id="_idTextAnchor358"/>as <span class="No-Break">our cache:</span><pre class="source-code">
var cache map[string]string</pre></li>				<li>Create a function to get items from <span class="No-Break">the cache:</span><pre class="source-code">
func cacheGet(ke<a id="_idTextAnchor359"/><a id="_idTextAnchor360"/>y string) string {
  return cache[key]
}</pre></li>				<li>Create a function that sets items in <span class="No-Break">the cache:</span><pre class="source-code">
func cacheSet(key, val string) {</pre></li>				<li>In th<a id="_idTextAnchor361"/><a id="_idTextAnchor362"/>is function, check<a id="_idIndexMarker109"/> out the <strong class="source-inline">MaxCacheSize</strong> constant to stop the cache going over <span class="No-Break">that size:</span><pre class="source-code">
  if len(cache)+1 &gt;= MaxCacheS<a id="_idTextAnchor363"/><a id="_idTextAnchor364"/>ize {
    return
  }
  cache[key] = val
}</pre></li>				<li>Create a<a id="_idIndexMarker110"/> function to get a book from <span class="No-Break">the c<a id="_idTextAnchor365"/><a id="_idTextAnchor366"/>ache:</span><pre class="source-code">
func GetBook(isbn string) string {</pre></li>				<li>Use the book cache prefix to create a <span class="No-Break">unique k<a id="_idTextAnchor367"/><a id="_idTextAnchor368"/>ey:</span><pre class="source-code">
  return cacheGet(CacheKeyBook + isbn)
}</pre></li>				<li>Create a function to add a book to <span class="No-Break">the cache:</span><pre class="source-code">
<a id="_idTextAnchor369"/><a id="_idTextAnchor370"/>func SetBook(isbn string, name string) {</pre></li>				<li>Use the book cache prefix to create a <span class="No-Break">unique k<a id="_idTextAnchor371"/><a id="_idTextAnchor372"/>ey:</span><pre class="source-code">
  cacheSet(CacheKeyBook+isbn, name)
}</pre></li>				<li>Create a function to get CD data from <a id="_idTextAnchor373"/><a id="_idTextAnchor374"/><span class="No-Break">the cache:</span><pre class="source-code">
func GetCD(sku string) string {</pre></li>				<li>Use the <strong class="source-inline">CD</strong> cache prefix to create a <span class="No-Break">unique ke<a id="_idTextAnchor375"/><a id="_idTextAnchor376"/>y:</span><pre class="source-code">
  return cacheGet(CacheKeyCD + sku)
}</pre></li>				<li>Create a function to add CDs to the <span class="No-Break">shared cache:</span><pre class="source-code">
func SetCD(sku string, ti<a id="_idTextAnchor377"/><a id="_idTextAnchor378"/>tle string) {</pre></li>				<li>Use the <strong class="source-inline">CD</strong> cache prefix constant to build a unique key for the <span class="No-Break">shared cache:</span><pre class="source-code">
  cacheSet(CacheKeyCD+sku, title)
}<a id="_idTextAnchor379"/><a id="_idTextAnchor380"/></pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Initialize our c<a id="_idTextAnchor381"/><a id="_idTextAnchor382"/>ache by creating a <span class="No-Break"><strong class="source-inline">map</strong></span><span class="No-Break"> value:</span><pre class="source-code">
  cache = make(map[string]string)</pre></li>				<li>Add a book to <a id="_idTextAnchor383"/><a id="_idTextAnchor384"/><span class="No-Break">the cache:</span><pre class="source-code">
  SetBook("1234-5678", "Get Ready To Go")</pre></li>				<li>Add a <strong class="source-inline">CD</strong> cache prefix to <span class="No-Break">the cache:</span><pre class="source-code">
  <a id="_idTextAnchor385"/><a id="_idTextAnchor386"/>SetCD("1234-5678", "Get Ready To Go Audio Book")</pre></li>				<li>Get and print that <strong class="source-inline">Book</strong> from <span class="No-Break">the ca<a id="_idTextAnchor387"/><a id="_idTextAnchor388"/>che:</span><pre class="source-code">
  fmt.Println("Book :", GetBook("1234-5678"))</pre></li>				<li>Get and print that <strong class="source-inline">CD</strong> from <span class="No-Break">the cache:</span><pre class="source-code">
  fmt.Println("CD :", GetCD("1234-5678"))</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>				<li>Save t<a id="_idTextAnchor389"/>he file. Then, in the new folder, run <span class="No-Break">the following:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>The following is <span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B18621_01_22.jpg" alt="Figure 1.22: Output displaying the Book and CD caches" width="1075" height="138"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.22: Output displaying the Book and CD caches</p>
			<p>In this exercise, we used <a id="_idIndexMarker111"/>constants to define values that don’t need to change while the code is running. We declared then using a variety of notation options, some with the typeset and some without. We declared a single constant and multiple constants in a <span class="No-Break">single stateme<a id="_idTextAnchor390"/><a id="_idTextAnchor391"/>nt.</span></p>
			<p>Next, we’ll look at a variation of constants for values that are more <span class="No-Break">closely related.</span></p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor392"/>Enums</h1>
			<p>Enums are a way of <a id="_idIndexMarker112"/>defining a fixed list of values that are all related. Go doesn’t have a built-in type for enums, but it does provide tools such as <strong class="source-inline">iota</strong> to let you define your own using constants. We’ll explore <span class="No-Break">this now.</span></p>
			<p>For example, in the following code, we have the days of the week defined as constants. This code is a good candidate for Go’s <span class="No-Break"><strong class="source-inline">iota</strong></span><span class="No-Break"> feature:</span></p>
			<pre class="source-code">
…
const (
  Sunday  = 0
  Monday  = 1
  Tuesday = 2
  Wednesday = 3
  Thursday = 4
  Friday  = 5
  Saturday = 6
)
…</pre>			<p>With <strong class="source-inline">iota</strong>, Go helps us manage lists just like this. Using <strong class="source-inline">iota</strong>, the following code is equal to the <span class="No-Break">preceding code:</span></p>
			<pre class="source-code">
…
const (
  Sunday = iota
  Monday
  Tuesday
  Wednesday
  Thursday
  Friday
  Saturday
)
…</pre>			<p>Now, we have <strong class="source-inline">iota</strong> assigning the numbers for us. Using <strong class="source-inline">iota</strong> makes enums easier to create and maintain, especially if you need to add a new value to the middle of the code later. Order matters when using <strong class="source-inline">iota</strong> as it is an identifier that tells the Go compiler to start the first value at 0 and increment by 1 for each subsequent value in the case of this example. With <strong class="source-inline">iota</strong>, you can skip values using <strong class="source-inline">_</strong>, start with a different offset, and even use more <span class="No-Break">complicated calculations.</span></p>
			<p>Next, we’ll <a id="_idTextAnchor393"/><a id="_idTextAnchor394"/>take a detailed look <a id="_idIndexMarker113"/>at Go’s variable scoping rules and how they affect how you <span class="No-Break">write code.</span></p>
			<p><span class="No-Break">Scope</span></p>
			<p>All the variables in Go live in <a id="_idIndexMarker114"/>a scope. The top-level scope is the package scope. A scope can have child scopes within it. There are a few ways a child scope gets defined; the easiest way to think about this is that when you see <strong class="source-inline">{</strong>, you are starting a new child scope, and that child scope ends when you get to a matching <strong class="source-inline">}</strong>. The parent-child relationship is defined when the code compiles, not when the code runs. When accessing a variable, Go looks at the scope the code was defined in. If it can’t find a variable with that name, it looks in the parent scope, then the grandparent scope, all the way until it gets to the package scope. It stops looking once it finds a variable with a matching name or raises an error if it can’t find <span class="No-Break">a match.</span></p>
			<p>To put it another way, when your code uses a variable, Go needs to work out where that variable was defined. It starts its search in the scope of the code using the variable it’s currently running in. If a variable definition using that name is in that scope, then it stops looking and uses the variable definition to complete its work. If it can’t find a variable definition, then it starts walking up the stack of scopes, stopping as soon as it finds a variable with that name. This searching is all done based on a variable name. If a variable with that name is found but is of the wrong type, Go raises <span class="No-Break">an error.</span></p>
			<p>In this example, we have four different scopes, but we define the <strong class="source-inline">level</strong> variable once. This means that no matter where you use <strong class="source-inline">level</strong>, the same variable <span class="No-Break">is used:</span></p>
			<pre class="source-code">
package main
import "fmt"
var level = "pkg"
func main() {
  fmt.Println("Main start :", level)
  if true {
    fmt.Println("Block start :", level)
    funcA()
  }
}
func funcA() {
  fmt.Println("funcA start :", level)
}</pre>			<p>The following is the output displaying variables when <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">level</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Main start : pkg
Block start : pkg
funcA start : pkg</pre>			<p>In this example, we’ve shadowed the <strong class="source-inline">level</strong> variable. This new <strong class="source-inline">level</strong> variable is not related to the <strong class="source-inline">level</strong> variable in the package scope. When we print <strong class="source-inline">level</strong> in the block, the Go runtime stops looking for variables called <strong class="source-inline">level</strong> as soon as it finds the one defined in <strong class="source-inline">main</strong>. This logic<a id="_idIndexMarker115"/> results in a different value getting printed out once that new variable shadows the package variable. You can also see that it’s a diffe<a id="_idTextAnchor395"/><a id="_idTextAnchor396"/>rent variable because it’s a different type, and a variable can’t have its type changed <span class="No-Break">in Go:</span></p>
			<pre class="source-code">
package main
import "fmt"
var level = "pkg"
func main() {
  fmt.Println("Main start :", level)
  // Create a shadow variable
  level := 42
  if true <a id="_idTextAnchor397"/><a id="_idTextAnchor398"/>{
    fmt.Println("Block start :", level)
    funcA()
  }
  fmt.Println("Main end :", level)
}
func funcA() {
  fmt.Println("funcA start :", level)
}</pre>			<p>The following is <span class="No-Break">the output:</span></p>
			<pre class="console">
Main start : pkg
Block start : 42
funcA start : pkg
Main end : 42</pre>			<p>Go’s static scope resolution comes into play when we call <strong class="source-inline">funcA</strong>. That’s why, when <strong class="source-inline">funcA</strong> runs, it still sees the package scope’s <strong class="source-inline">level</strong> variable. The scope resolution doesn’t <a id="_idTextAnchor399"/><a id="_idTextAnchor400"/>pay attention<a id="_idIndexMarker116"/> to where <strong class="source-inline">funcA</strong> <span class="No-Break">gets called.</span></p>
			<p>You can’t access variables defined in a <span class="No-Break">child scope:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  {
    level := "Nest 1"
    fmt.Println("Block end :", level)
  }
  <a id="_idTextAnchor401"/>// Error: undefined: level
  //fmt.Println(<a id="_idTextAnchor402"/><a id="_idTextAnchor403"/>"Main end  :", level)
}</pre>			<p>The following is <a id="_idIndexMarker117"/><span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Figure_1.23_B18621.jpg" alt="Figure 1.23: Output displaying an error" width="1538" height="86"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.23: Output displaying an error</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor404"/>Activity 1.03 – message bug</h2>
			<p>The following code doesn’t <a id="_idIndexMarker118"/>work. T<a id="_idTextAnchor405"/><a id="_idTextAnchor406"/>he person who wrote it can’t fix it, and they’ve asked you to help them. Can you get it <span class="No-Break">to work?</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  count := 5
  if count &gt; 5 {
    message := "Greater than 5"
  } else {
    message := "Not greater than 5"
  }
  fmt.Println(message)
}</pre>			<p>Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Run the code and see what the <span class="No-Break">output is.</span></li>
				<li>The problem is with <strong class="source-inline">message</strong>; make a change to <span class="No-Break">the code.</span></li>
				<li>Rerun the code and see what difference <span class="No-Break">it makes.</span></li>
				<li>Repeat this process until you see the <span class="No-Break">expected output.</span><p class="list-inset">The following is the <span class="No-Break">expected output:</span></p><pre class="source-code">
Not greater than 5</pre></li>			</ol>
			<p>In this activity, we saw that where you define your variables has a big impact on the code. Always think about the scope you need your variables to be in when <span class="No-Break">defini<a id="_idTextAnchor407"/><a id="_idTextAnchor408"/>ng them.</span></p>
			<p>In the next activity, we are going to look at a similar problem that is a <span class="No-Break">bit trickier.</span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor409"/>Activity 1.04 – bad count bug</h2>
			<p>Your friend is back, and they have <a id="_idIndexMarker119"/>another bug in<a id="_idTextAnchor410"/><a id="_idTextAnchor411"/> their code. This code should print <strong class="source-inline">true</strong>, but it’s printing <strong class="source-inline">false</strong>. Can you help them fix <span class="No-Break">the bug?</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  count := 0
  if count &lt; 5 {
    count := 10
    count++
  }
  fmt.Println(count == 11)
}</pre>			<p>Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Run the code and see what the <span class="No-Break">output is.</span></li>
				<li>The problem is with <strong class="source-inline">count</strong>; make a change to <span class="No-Break">the code.</span></li>
				<li>Rerun the code and see what difference <span class="No-Break">it makes.</span></li>
				<li><a id="_idTextAnchor412"/><a id="_idTextAnchor413"/>Repeat this process <a id="_idIndexMarker120"/>until you see the <span class="No-Break">expected output.</span></li>
			</ol>
			<p>The following is the <span class="No-Break">expected output:</span></p>
			<pre class="console">
True</pre>			<h1 id="_idParaDest-66"><a id="_idTextAnchor414"/>Summary</h1>
			<p>In this chapter, we got into the nitty-gritty of variables, including how variables are declared, and all the different notations you can use to declare them. This variety of notation gives you a nice compact notation to use for 90% of your work, while still giving you the power to be very specific when you need to the other 10% of the time. We looked at how to change and update the value of variables after you’ve declared them. Again, Go gives you some great shorthand to help in the most common use cases to make your life easier. All your data ends up in some form of variable. Data is what makes code dynamic and responsive. Without data, your code could only ever do exactly one thing; data unleashes the true power <span class="No-Break">of software.</span></p>
			<p>Now that your application has data, it needs to make choices based on that data. That’s where variable comparison comes in. This helps us see whether something is true or false, bigger or smaller, and so on, and it also helps us make choices based on the results of <span class="No-Break">those comparisons.</span></p>
			<p>We explored how Go decided to implement its variable system by looking at zero values, pointers, and scope logic. At this point, we know that these are the details that can be the difference between delivering bug-free efficient software and not <span class="No-Break">doing so.</span></p>
			<p>We also took a look at how we can declare immutable variables by using constants and how <strong class="source-inline">iota</strong> can help manage lists or related constants to work, such <span class="No-Break">as enums.</span></p>
			<p>In the next chapter, we’ll start to put our variables to work by defining logic and looping over collections <span class="No-Break">of variables.</span></p>
		</div>
	</div></div></body></html>