- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Variables and Operators
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和运算符
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will be introduced to various features of Go and gain a
    basic understanding of what Go code looks like. You will also be provided with
    a deep understanding of how variables work and will perform exercises and activities
    to get hands-on and get going.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解Go的各种特性，并基本了解Go代码的样子。你还将深入了解变量是如何工作的，并通过练习和活动来获得实践经验，从而开始学习。
- en: By the end of this chapter, you will be able to use variables, packages, and
    functions in Go. You will also know how to change variable values in Go. Later
    in this chapter, you will use operators with numbers and design functions using
    pointers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用Go中的变量、包和函数。你还将了解如何在Go中更改变量的值。在本章的后面部分，你将使用数字与运算符一起使用，并使用指针设计函数。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you''ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter01).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要Go版本1.21或更高版本。本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter01)。
- en: Introduction to Go
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go语言简介
- en: Go (or Golang, as it’s often called) is a programming language that’s popular
    with developers because of how rewarding it is to use to develop software. It’s
    also popular with companies because teams of all sizes can be productive with
    it. Go has also earned a reputation for consistently delivering software with
    exceptionally high performance.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Go（或通常称为Golang）是一种编程语言，它因使用它来开发软件的回报而受到开发者的喜爱。它也受到公司的青睐，因为所有规模的团队能够使用它来提高生产力。Go还因其持续提供性能极高的软件而赢得了声誉。
- en: Go has an impressive pedigree since it was created by a team from Google with
    a long history of building great programming languages and operating systems.
    They created a language that has the feel of a dynamic language such as JavaScript
    or PHP but with the performance and efficiency of strongly typed languages such
    as C++ and Java. They wanted a language that was engaging for the programmer but
    practical in projects with hundreds of developers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Go有着令人印象深刻的血统，因为它是由一支来自Google的团队创造的，这支团队有着悠久的构建优秀的编程语言和操作系统的历史。他们创造了一种感觉上类似于JavaScript或PHP这样的动态语言，但具有C++和Java这样的强类型语言的性能和效率。他们希望有一种既吸引程序员又适合有数百名开发者的项目的语言。
- en: Go is packed with interesting and unique features, such as being compliant with
    memory safety and channel-based concurrency. We’ll explore these features in this
    chapter. By doing so, you’ll see that their unique implementation within Go is
    what makes Go truly special.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言包含了许多有趣且独特的特性，例如符合内存安全性和基于通道的并发。在本章中，我们将探讨这些特性。通过这样做，你会发现它们在Go中的独特实现正是使Go真正特殊的原因。
- en: Go is written in text files that are then compiled down to machine code and
    packaged into a single, standalone executable file. The executable is self-contained,
    with nothing needed to be installed first to allow it to run. Having a single
    file makes deploying and distributing Go software hassle-free. When compiling,
    you can pick one of several target operating systems, including – but not limited
    to – Windows, Linux, macOS, and Android. With Go, you write your code once and
    run it anywhere. Complied languages fell out of favor because programmers hated
    long waits for their code to compile. The Go team knew this and built a lightning-fast
    compiler that remains fast as projects grow.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言是用文本文件编写的，然后编译成机器码并打包成一个单一的独立可执行文件。该可执行文件是自包含的，无需先安装任何东西即可运行。拥有单个文件使得部署和分发Go软件变得轻松。在编译时，你可以选择多个目标操作系统之一，包括但不限于Windows、Linux、macOS和Android。使用Go，你只需编写一次代码，就可以在任何地方运行。编译型语言不再受欢迎，因为程序员讨厌等待代码编译的漫长过程。Go团队深知这一点，并构建了一个闪电般的编译器，即使项目规模扩大，编译速度依然很快。
- en: Go has a statically typed and type-safe memory model with a garbage collector
    that automates memory management. This combination protects developers from creating
    many of the most common bugs and security flaws found in software while still
    providing excellent performance and efficiency. Dynamically typed languages such
    as Ruby and Python have become popular in part because programmers felt they could
    be more productive if they didn’t have to worry about types and memory. The downside
    of these languages is that they give up performance and memory efficiency and
    can be more prone to type-mismatch bugs. Go has the same levels of productivity
    as dynamically typed languages while not giving up performance and efficiency.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Go 具有静态类型和类型安全的内存模型，并带有垃圾回收器来自动化内存管理。这种组合保护开发者免受在软件中常见的许多错误和安全漏洞的影响，同时仍然提供出色的性能和效率。动态类型语言，如
    Ruby 和 Python，之所以受欢迎，部分原因是程序员认为，如果他们不必担心类型和内存，他们可以更高效地工作。这些语言的缺点是，它们牺牲了性能和内存效率，并且更容易出现类型不匹配的错误。Go
    在动态类型语言具有相同的生产力水平的同时，并没有放弃性能和效率。
- en: A massive shift in computer performance has taken place. Going fast now means
    you need to be able to do as much work parallel or concurrently as possible. This
    change is due to the design of modern CPUs, which emphasize more cores over high
    clock speed. None of the currently popular programming languages have been designed
    to take advantage of this fact, which makes writing parallel and concurrent code
    in them error-prone. Go is designed to take advantage of multiple CPU cores, and
    it removes all the frustration and bug-filled code. Go is designed to allow any
    developer to easily and safely write parallel and concurrent code that enables
    them to take advantage of modern multicore CPUs and cloud computing – unlocking
    high-performance processing and massive scalability without the drama.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机性能发生了巨大的转变。现在要快速运行，您需要能够尽可能并行或并发地完成更多工作。这种变化是由于现代 CPU 的设计，它强调更多的核心而不是高时钟速度。目前所有流行的编程语言都没有被设计用来利用这一事实，这使得在这些语言中编写并行和并发代码容易出错。Go
    被设计用来利用多个 CPU 核心，并消除了所有挫折和充满错误的代码。Go 被设计成允许任何开发者轻松且安全地编写并行和并发代码，使他们能够利用现代的多核 CPU
    和云计算 – 无需戏剧性地解锁高性能处理和巨大的可扩展性。
- en: What does Go look like?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 看起来是什么样子？
- en: 'Let’s take our first look at some Go code. This code randomly prints a message
    to the console from a pre-defined list of messages:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看一些 Go 代码。以下代码会从预定义的消息列表中随机打印一条消息到控制台：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `main()` function is defined as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数定义如下：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s consider the `hello()` function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑 `hello()` 函数：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let’s step through this code piece by piece.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐行分析这段代码。
- en: 'At the top of our script is the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本顶部是以下内容：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code is our package declaration. All Go files must start with one of these.
    If you want to run the code directly, you’ll need to name it `main`. If you don’t
    name it `main`, then you can use it as a library and import it into other Go code.
    When creating an importable package, you can give it any name. All Go files in
    the same directory are considered part of the same package, which means all the
    files must have the same package name.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是我们的包声明。所有 Go 文件都必须以其中之一开始。如果您想直接运行代码，您需要将其命名为 `main`。如果您不命名为 `main`，那么您可以用它作为库，并将其导入其他
    Go 代码中。当创建可导入的包时，您可以给它任何名称。同一目录下的所有 Go 文件都被视为同一包的一部分，这意味着所有文件都必须有相同的包名。
- en: 'In the following code, we’re importing code from packages:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们正在从包中导入代码：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the packages are all from Go’s standard library. Go’s standard
    library is very high-quality and comprehensive. It’s strongly recommended that
    you maximize your use of it. You can tell if a package isn’t from the standard
    library because it’ll look like a URL – for example, `github.com/fatih/color`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有包都来自 Go 的标准库。Go 的标准库质量很高且功能全面。强烈建议您最大限度地利用它。如果您发现一个包看起来像 URL – 例如，`github.com/fatih/color`，那么这个包就不是来自标准库的。
- en: Go has a module system that makes using external packages easy. To use a new
    module, add it to your import path. Go will automatically download it for you
    the next time you build code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Go 有一个模块系统，使得使用外部包变得简单。要使用一个新的模块，只需将其添加到您的导入路径。下次您构建代码时，Go 会自动为您下载它。
- en: 'Imports only apply to the file they’re declared in, which means you must declare
    the same imports over and over in the same package and project. But fear not –
    you don’t need to do this by hand. There are many tools and Go editors that automatically
    add and remove the imports for you:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 导入只适用于它们声明的文件，这意味着您必须在同一个包和项目中反复声明相同的导入。但不用担心——您不需要手动这样做。有许多工具和 Go 编辑器可以自动为您添加和删除导入：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we’re declaring a global variable, which is a list of strings, and initializing
    it with data. The text or strings in Go support multi-byte UFT-8 encoding, making
    them safe for any language. The type of list we’re using here is called a slice.
    There are three types of lists in Go: slices, arrays, and maps. All three are
    collections of keys and values, where you use the key to get a value from the
    collection. Slice and array collections use a number as the key. The first key
    is always 0 in slices and arrays. Also, in slices and arrays, the numbers are
    contiguous, which means there is never a break in the sequence of numbers. With
    the `map` type, you get to choose the `key` type. You use this when you want to
    use some other data to look up the value in the map. For example, you could use
    a book’s ISBN to look up its title and author:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个全局变量，它是一个字符串列表，并用数据初始化它。Go 中的文本或字符串支持多字节 UTF-8 编码，这使得它们对任何语言都是安全的。我们在这里使用的列表类型被称为切片。Go
    中有三种列表类型：切片、数组和映射。这三种都是键值对的集合，您使用键从集合中获取值。切片和数组集合使用数字作为键。在切片和数组中，第一个键始终是 0。此外，在切片和数组中，数字是连续的，这意味着数字序列中永远不会出现中断。使用
    `map` 类型时，您可以选择 `key` 类型。当您想使用其他数据在映射中查找值时，您会使用它。例如，您可以使用一本书的 ISBN 来查找其标题和作者：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we’re declaring a function. A function is some code that runs when called.
    You can pass data in the form of one or more variables to a function and optionally
    receive one or more variables back from it. The `main()` function in Go is special.
    The `main()` function is the entry point of your Go code. There may only be one
    `main()` function within the `main` package. When your code runs, Go automatically
    calls `main` to get things started:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个函数。函数是当被调用时运行的代码。您可以将一个或多个变量作为数据传递给函数，并可选择从它那里接收一个或多个变量。Go 中的 `main()`
    函数是特殊的。`main()` 函数是 Go 代码的入口点。在 `main` 包中只能有一个 `main()` 函数。当您的代码运行时，Go 会自动调用 `main`
    来开始执行：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we are generating a random number. The first thing we
    need to do is ensure it’s a good random number; to do that, we must *seed* the
    random number generator. We seed it using the current time formatted to a Unix
    timestamp with nanoseconds. To get the time, we call the `Now` function in the
    `time` package. The `Now` function returns a struct type variable. Structs are
    a collection of properties and functions, a little like objects in other languages.
    In this case, we are calling the `UnixNano` function on that struct straight away.
    The `UnixNano` function returns a variable of the `int64` type, which is a 64-bit
    integer or, more simply, a number. This number is passed into `rand.Seed`. The
    `rand.Seed` function accepts an `int64` variable as its input. Note that the type
    of the variable from `time.UnixNano` and `rand.Seed` must be the same. With that,
    we’ve successfully seeded the random number generator.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在生成一个随机数。我们首先需要确保它是一个好的随机数；为了做到这一点，我们必须对随机数生成器进行 *初始化*。我们使用格式化为 Unix
    时间戳（包含纳秒）的当前时间来初始化它。为了获取时间，我们调用 `time` 包中的 `Now` 函数。`Now` 函数返回一个结构体类型的变量。结构体是属性和函数的集合，类似于其他语言中的对象。在这种情况下，我们立即在该结构体上调用
    `UnixNano` 函数。`UnixNano` 函数返回一个 `int64` 类型的变量，这是一个 64 位整数，或者更简单地说，是一个数字。这个数字被传递到
    `rand.Seed`。`rand.Seed` 函数接受一个 `int64` 类型的变量作为其输入。请注意，来自 `time.UnixNano` 和 `rand.Seed`
    的变量的类型必须相同。有了这些，我们就成功地初始化了随机数生成器。
- en: What we want is a number we can use to get a random message. We’ll use `rand.Intn`
    for this job. This function gives us a random number between 0 and 1, minus the
    number we pass in. This may sound a bit strange, but it works out perfectly for
    what we’re trying to do. This is because our list is a slice where the keys start
    from 0 and increment by 1 for each value. This means the last index is 1 less
    than the length of the slice.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的是一个可以用来获取随机消息的数字。我们将使用 `rand.Intn` 来完成这项工作。这个函数给我们一个介于 0 和 1 之间的随机数，减去我们传入的数字。这听起来可能有点奇怪，但它对我们想要做的事情来说非常完美。这是因为我们的列表是一个从
    0 开始，每个值递增 1 的切片。这意味着最后一个索引比切片长度少 1。
- en: 'To show you what this means, here is some simple code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向您展示这意味着什么，这里有一些简单的代码：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code prints the length of the list and then uses that length to print
    the last element. To do that, we must subtract 1; otherwise, we’d get an error,
    which is what the last line causes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打印列表的长度，然后使用这个长度来打印最后一个元素。为了做到这一点，我们必须减去 1；否则，我们会得到一个错误，这就是最后一行引起的问题：
- en: '![Figure 1.1: Output displaying an error](img/Figure_1.1_B18621.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1：显示错误的输出](img/Figure_1.1_B18621.jpg)'
- en: 'Figure 1.1: Output displaying an error'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：显示错误的输出
- en: 'Once we’ve generated our random number, we assign it to a variable. We do this
    with the short variable declaration seen with the `:=` notation, which is a very
    popular shortcut in Go within a function. It tells the compiler to go ahead and
    assign that value to the variable and select the appropriate type for that value
    implicitly. This shortcut is one of the many things that makes Go feel like a
    dynamically typed language:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们生成了随机数，我们就将其分配给一个变量。我们使用与 `:=` 符号一起看到的简短变量声明来做这件事，这在 Go 语言中是一个非常流行的快捷方式，在函数内部使用。它告诉编译器继续将那个值分配给变量，并隐式地选择适合那个值的类型。这个快捷方式是使
    Go 语言感觉像动态类型语言的多件事之一：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we use that variable to call a function named `hello`. We’ll look at
    `hello` in just a moment. The important thing to note is that we’re receiving
    two values back from the function and we’re able to assign them to two new variables,
    `msg` and `err`, using the `:=` notation and with `err` as the second value:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用那个变量来调用一个名为 `hello` 的函数。我们稍后会看看 `hello`。重要的是要注意，我们从函数中接收两个值，并且能够使用 `:=`
    符号将它们分配给两个新变量，`msg` 和 `err`，其中 `err` 作为第二个值：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code is the definition of the `hello` function; we’re not showing the
    body for now. A function acts as a unit of logic that’s called when and as often
    as is needed. When calling a function, the code that calls it stops running and
    waits for the function to finish running. Functions are a great tool for keeping
    your code organized and understandable. In the signature of `hello`, we’ve defined
    that it accepts a single `int` value and that it returns a `string` value and
    an `error` value. Having `error` as your last return value is a very common thing
    to have in Go. The code between `{}` is the body of the function. The following
    code is what’s run when the function’s called:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是 `hello` 函数的定义；我们现在不展示其主体。函数作为一个逻辑单元，在需要时被调用。当调用函数时，调用它的代码会停止运行，等待函数运行完成。函数是保持代码组织和可理解性的优秀工具。在
    `hello` 的签名中，我们定义了它接受一个 `int` 类型的值，并返回一个 `string` 类型的值和一个 `error` 类型的值。在 Go 语言中，将
    `error` 作为最后一个返回值是非常常见的事情。`{}` 之间的代码是函数的主体。以下代码是函数被调用时运行的代码：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are inside the function; the first line of the body is an `if` statement.
    An `if` statement runs the code inside its `{}` if its Boolean expression is true.
    The Boolean expression is the logic between `if` and `{`. In this case, we’re
    testing to see if the passed `index` variable is less than 0 or greater than the
    largest possible slice index key.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们处于函数内部；主体中的第一行是一个 `if` 语句。一个 `if` 语句在其布尔表达式为真时运行其 `{}` 内的代码。布尔表达式是 `if`
    和 `{` 之间的逻辑。在这种情况下，我们正在测试传递的 `index` 变量是否小于 0 或大于可能的最大切片索引键。
- en: 'If the Boolean expression were to be true, then our code would return an empty
    `string` and an `error` value. At this point, the function would stop running,
    and the code that called the function would continue to run. If the Boolean expression
    were not true, its code would be skipped over, and our function would return a
    value from `helloList` and `nil`. In Go, `nil` represents something with no value
    and no type:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果布尔表达式为真，那么我们的代码将返回一个空的 `string` 和一个 `error` 值。此时，函数将停止运行，调用函数的代码将继续运行。如果布尔表达式不为真，其代码将被跳过，我们的函数将从
    `helloList` 返回一个值，并返回 `nil`。在 Go 语言中，`nil` 代表没有值和没有类型的东西：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After we’ve run `hello`, the first thing we need to do is check if it ran successfully.
    We can do this by checking the `error` value stored in `err`. If `err` is not
    equal to `nil`, then we know we have an error. You will see checks on whether
    `err` is not equal to `nil` as opposed to checks on whether `err` is equal to
    `nil`, as this simplifies the checks and logic for the code base. In the case
    of an error, we call `log.Fatal`, which writes out a logging message and kills
    our app. Once the app’s been killed, no more code runs:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行`hello`之后，我们需要做的第一件事是检查它是否成功运行。我们可以通过检查存储在`err`中的`error`值来完成。如果`err`不等于`nil`，那么我们知道我们有一个错误。您将看到对`err`是否不等于`nil`的检查，而不是对`err`是否等于`nil`的检查，因为这简化了代码库的检查和逻辑。在出现错误的情况下，我们调用`log.Fatal`，它会写入日志消息并终止我们的应用程序。一旦应用程序被终止，就没有更多的代码运行：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If there is no error, then we know that `hello` ran successfully and that the
    value of `msg` can be trusted to hold a valid value. The final thing we need to
    do is print the message to the screen via the Terminal.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，那么我们知道`hello`已成功运行，并且`msg`的值可以信赖以包含有效值。我们需要做的最后一件事是通过终端将消息打印到屏幕上。
- en: 'Here’s how that looks:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的样子：
- en: '![Figure 1.2: Output displaying valid values](img/B18621_01_02.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2：显示有效值的输出](img/B18621_01_02.jpg)'
- en: 'Figure 1.2: Output displaying valid values'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：显示有效值的输出
- en: In this simple Go program, we’ve been able to cover a lot of key concepts that
    we’ll explore in full in the coming chapters.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的Go程序中，我们已经能够涵盖许多关键概念，我们将在接下来的章节中详细探讨。
- en: Exercise 1.01 – using variables, packages, and functions to print stars
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.01 – 使用变量、包和函数打印星号
- en: 'In this exercise, we’ll use some of what we learned about in the preceding
    example to print a random number, between 1 and 5, of stars (`*`) to the console.
    This exercise will give you a feel of what working with Go is like and some practice
    with using the features of Go we’ll need going forward. Let’s get started:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用前面示例中学习的一些内容来打印一个介于1和5之间的随机星号（`*`）到控制台。这个练习将让您了解使用Go的感觉，并练习我们将需要继续使用的Go功能。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个`main.go`文件。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将`main`包名添加到文件顶部：
- en: '[PRE14]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, add the imports we’ll use in this file:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加我们将在这个文件中使用的导入：
- en: '[PRE15]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a `main()` function:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main()`函数：
- en: '[PRE16]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Seed the random number generator:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化随机数生成器：
- en: '[PRE17]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Generate a random number between 0 and then add 1 to get a number between 1
    and 5:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个介于0和1之间的随机数，然后加1以得到一个介于1和5之间的数字：
- en: '[PRE18]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use the string repeater to create a string with the number of stars we need:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用字符串重复器创建所需数量的星号字符串：
- en: '[PRE19]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Print the string with the stars to the console with a new line character at
    the end and close the `main()` function:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台打印带有星号的字符串，并在末尾添加换行符，然后关闭`main()`函数：
- en: '[PRE20]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新文件夹中运行以下命令：
- en: '[PRE21]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is the output:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出结果：
- en: '![Figure 1.3: Output displaying stars](img/B18621_01_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3：显示星号的输出](img/B18621_01_03.jpg)'
- en: 'Figure 1.3: Output displaying stars'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：显示星号的输出
- en: In this exercise, we created a runnable Go program by defining the `main` package
    with a `main()` function in it. We used the standard library by adding imports
    to packages. Those packages helped us generate a random number, repeat strings,
    and write to the console.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们通过定义包含`main()`函数的`main`包来创建了一个可运行的Go程序。我们通过添加包导入来使用标准库。这些包帮助我们生成随机数、重复字符串以及写入控制台。
- en: Activity 1.01 – defining and printing
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动练习1.01 – 定义和打印
- en: 'In this activity, we are going to create a medical form for a doctor’s office
    to capture a patient’s name, age, and whether they have a peanut allergy:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将为医生的办公室创建一个医疗表格，以记录病人的姓名、年龄以及他们是否有花生过敏：
- en: 'Create a variable for the following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为以下内容创建变量：
- en: First name as a string.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先以字符串形式输入名字。
- en: Family name as a string.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以字符串形式输入姓氏。
- en: Age as an `int` value.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 年龄作为一个`int`类型的值。
- en: Peanut allergy as a `bool` value.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 花生过敏作为一个`bool`类型的值。
- en: Ensure they have an initial value.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保它们有一个初始值。
- en: Print the values to the console.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值打印到控制台。
- en: 'The following is the expected output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为预期输出：
- en: '![Figure 1.4: Expected output after assigning the variables](img/B18621_01_04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4：分配变量后的预期输出](img/B18621_01_04.jpg)'
- en: 'Figure 1.4: Expected output after assigning the variables'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：分配变量后的预期输出
- en: Note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution to all activities in this chapter can be found in the GitHub repository
    here: [https://github.com/PacktPublishing/Go-Programming-From- Beginner-to-Professional-Second-Edition-/tree/main/Chapter01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter01)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所有活动的解决方案都可以在以下 GitHub 仓库中找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter01)
- en: Next, we’ll start going into detail about what we’ve covered so far, so don’t
    worry if you are confused or have any questions about what you’ve seen so far.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将详细讲解到目前为止我们已经覆盖的内容，所以如果你对之前看到的内容感到困惑或有任何疑问，请不要担心。
- en: Declaring variables
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明变量
- en: Now that you’ve had a glimpse of Go and completed your first exercise, we’re
    going to dive deep. Our first stop on our journey is variables.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经对 Go 有了一定的了解并完成了你的第一个练习，我们将深入探讨。我们旅程的第一个目的地是变量。
- en: 'A variable holds data for you temporarily so that you can work with it. When
    you declare a variable, it needs four things: a statement that you are declaring
    a variable, a name for the variable, the type of data it can hold, and an initial
    value for it. Fortunately, some of the parts are optional, but that also means
    there’s more than one way of defining a variable.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 变量暂时存储数据，以便你可以使用它。当你声明一个变量时，它需要四个要素：一个声明变量的语句、变量的名称、它可以存储的数据类型以及它的初始值。幸运的是，其中一些部分是可选的，但这也意味着定义变量的方式不止一种。
- en: Let’s cover all the ways you can declare a variable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看你可以声明变量的所有方法。
- en: Declaring a variable using var
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 var 声明变量
- en: 'Using `var` is the foundational way to declare a variable. Every other way
    we’ll cover is a variation of this approach, typically by omitting parts of this
    definition. A full `var` definition with everything in place looks like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `var` 是声明变量的基础方法。我们将要讲解的其他所有方法都是这种方法的变体，通常是通过省略定义的一部分。一个完整的 `var` 定义，包含所有要素，看起来像这样：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The key parts are `var`, `foo`, `string`, and `= "``bar"`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 关键部分是 `var`、`foo`、`string` 和 `= "bar"`：
- en: '`var` is our declaration that we are defining a variable'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var` 是我们定义变量的声明'
- en: '`foo` is the name of the variable'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo` 是变量的名称'
- en: '`string` is the type of the variable'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string` 是变量的类型'
- en: '`= "bar"` is its initial value'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`= "bar"` 是其初始值'
- en: Exercise 1.02 – declaring a variable using var
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.02 – 使用 var 声明变量
- en: 'In this exercise, we’ll declare two variables using the full `var` notation.
    Then, we’ll print them to the console. You’ll see that you can use the `var` notation
    anywhere in your code, which isn’t true for all variable declaration notations.
    Let’s get started:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用完整的 `var` 语法声明两个变量。然后，我们将它们打印到控制台。你会发现你可以在代码的任何地方使用 `var` 语法，这不是所有变量声明语法都有的。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个 `main.go` 文件。
- en: 'In `main.go`, add the main package name to the top of the file:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中，将主包名添加到文件顶部：
- en: '[PRE23]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the imports:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加导入：
- en: '[PRE24]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Declare a variable at the package-level scope. We’ll cover what scopes are
    in detail later:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包级作用域中声明一个变量。我们将在稍后详细解释作用域的概念：
- en: '[PRE25]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create the `main()` function:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main()` 函数：
- en: '[PRE26]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Declare another variable using `var` in our function:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的函数中使用 `var` 声明另一个变量：
- en: '[PRE27]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Print both variables to the console:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个变量都打印到控制台：
- en: '[PRE28]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Close the `main()` function:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 `main()` 函数：
- en: '[PRE29]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新文件夹中运行以下命令：
- en: '[PRE30]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is the output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将显示的输出：
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, `foo` is declared at the package level while `baz` is declared
    at the function level. Where a variable is declared is important because where
    you declare a variable also limits what notation you can use to declare it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`foo` 在包级别被声明，而 `baz` 在函数级别被声明。变量声明的位置很重要，因为声明的位置也限制了你可以用来声明变量的语法。
- en: Next, we’ll look at another way to use the `var` notation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看使用 `var` 语法的另一种方法。
- en: Declaring multiple variables at once with var
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 var 一次性声明多个变量
- en: 'We can use a single `var` declaration to define more than one variable using
    a `var` block or statement. Using this method is common when declaring package-level
    variables. The variables don’t need to be of the same type, and they can all have
    their own initial values. The notation looks like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用单个 `var` 声明来定义多个变量，使用 `var` 块或语句。当声明包级变量时，这种方法很常见。变量不需要是同一类型，它们都可以有自己的初始值。这种语法的样子是这样的：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can have multiple of these types of declarations. This is a nice way to
    group related variables, thereby making your code more readable. You can use this
    notation in functions, but it’s rare to see it used there.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以有多个这种类型的声明。这是一种将相关变量分组的好方法，从而使你的代码更易于阅读。你可以在函数中使用这种表示法，但很少在那里看到它。
- en: Exercise 1.03 – declaring multiple variables at once with var
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.03 – 使用 var 同时声明多个变量
- en: 'In this exercise, we’ll declare multiple variables using one `var` statement,
    each with a different type and initial value. Then, we’ll print the value of each
    variable to the console. Let’s get started:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用单个 `var` 语句声明多个变量，每个变量具有不同的类型和初始值。然后，我们将打印每个变量的值到控制台。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个 `main.go` 文件。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 文件中，将 `main` 包名添加到文件顶部：
- en: '[PRE33]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the imports:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加导入：
- en: '[PRE34]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Start the `var` declaration:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始 `var` 声明：
- en: '[PRE35]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define three variables:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义三个变量：
- en: '[PRE36]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Close the `var` declaration:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 `var` 声明：
- en: '[PRE37]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `main()` function, print each variable to the console:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，将每个变量打印到控制台：
- en: '[PRE38]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新的文件夹中，运行以下命令：
- en: '[PRE39]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following is the output:'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为输出：
- en: '![Figure 1.5: Output displaying three variable values](img/Figure_1.5_B18621.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5：显示三个变量值的输出](img/Figure_1.5_B18621.jpg)'
- en: 'Figure 1.5: Output displaying three variable values'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：显示三个变量值的输出
- en: In this exercise, we declared three variables using a single `var` statement.
    Your output will look different for the `time.Time` variable, but that’s correct.
    The format is the same, but the time itself is different.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用单个 `var` 语句声明了三个变量。对于 `time.Time` 变量，你的输出可能会有所不同，但这是正确的。格式是相同的，但时间本身是不同的。
- en: Using the `var` notation like this is a good way to keep your code well organized
    and save you some typing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种 `var` 表示法是一种保持代码井然有序并节省一些输入的好方法。
- en: Next, we’ll start removing some of the optional parts of the `var` notation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始移除 `var` 表示法的一些可选部分。
- en: Skipping the type or value when declaring variables
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在声明变量时跳过类型或值
- en: In real-world code, it’s not common to use the full `var` notation. There are
    a few cases where you need to define a package-level variable with an initial
    value and tightly control its type. In those cases, you need the full notation.
    It’ll be obvious when this is needed as you’ll have a type mismatch of some kind,
    so don’t worry too much about this for now. The rest of the time, you’ll remove
    an optional part or use the short variable declaration.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的代码中，不常见到使用完整的 `var` 表示法。有一些情况需要定义具有初始值并严格控制其类型的包级变量。在这些情况下，你需要完整的表示法。当你需要时，这将是明显的，因为你会有某种类型不匹配，所以现在不必过于担心这个问题。其余时间，你可以删除一个可选部分或使用简短的变量声明。
- en: You don’t need to include both the type and the initial value when declaring
    a variable. You can use just one or the other; Go works out the rest. If you have
    a type in the declaration but no initial value, Go uses the zero value for the
    type you picked. We’ll talk about what a zero value is later in this book. On
    the other hand, if you have an initial value and no type, Go has a ruleset for
    how to infer the types that are needed from the literal value you use.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明变量时，你不需要同时包含类型和初始值。你可以只使用其中一个；Go 会处理其余部分。如果你在声明中有一个类型但没有初始值，Go 会使用你选择的类型的零值。我们将在本书的后面讨论零值是什么。另一方面，如果你有一个初始值但没有类型，Go
    有一个规则集，用于从你使用的字面值中推断所需的类型。
- en: Exercise 1.04 – skipping the type or value when declaring variables
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.04 – 在声明变量时跳过类型或值
- en: 'In this exercise, we’ll update our previous exercise so that it skips the optional
    initial values or type declarations from our variable declaration. Then, we’ll
    print the values to the console, as we did previously, to show that the result
    is the same. Let’s get started:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将更新我们之前的练习，以便跳过变量声明中的可选初始值或类型声明。然后，我们将像之前一样打印值到控制台，以显示结果相同。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个 `main.go` 文件。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 文件中，将 `main` 包名添加到文件顶部：
- en: '[PRE40]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Import the packages we’ll need:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们需要的包：
- en: '[PRE41]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Start the multi-variable declaration:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始多变量声明：
- en: '[PRE42]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `bool` value in the first exercise has an initial value of false. That’s
    a `bool` value’s zero value, so we’ll drop the initial value from its declaration
    as it is set by default:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一项练习中的`bool`值初始值为`false`。这是`bool`值的零值，因此我们将从其声明中省略初始值，因为它默认已设置：
- en: '[PRE43]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The next two variables both have a non-zero value for their type, so we’ll
    drop their type declaration:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下两个变量都有非零的类型值，因此我们将省略它们的类型声明：
- en: '[PRE44]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Close the `var` declaration:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`var`声明：
- en: '[PRE45]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `main()` function, print out each variable:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，打印出每个变量：
- en: '[PRE46]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新文件夹中运行以下命令：
- en: '[PRE47]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following is the output:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为输出：
- en: '![Figure 1.6: Output displaying variable values despite not mentioning the
    type while declaring the variables](img/Figure_1.6_B18621.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6：输出显示变量值，尽管在声明变量时没有提及类型](img/Figure_1.6_B18621.jpg)'
- en: 'Figure 1.6: Output displaying variable values despite not mentioning the type
    while declaring the variables'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6：输出显示变量值，尽管在声明变量时没有提及类型
- en: In this exercise, we were able to update the previous code so that it uses a
    much more compact variable declaration. Declaring variables is something you’ll
    have to do a lot, and not having to use the notation makes for a better experience
    when writing code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们能够更新之前的代码，使其使用更紧凑的变量声明。声明变量是你必须经常做的事情，不需要使用这种表示法可以让编写代码的体验更好。
- en: Next, we’ll look at a situation where you can’t skip any of the parts.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一个你不能跳过任何部分的场景。
- en: Type inference gone wrong
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型推断出错
- en: 'There are times when you’ll need to use all the parts of the declaration –
    for example, when Go isn’t able to guess the correct type you need. Let’s take
    a look at an example of this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要使用声明中的所有部分——例如，当Go无法猜出你需要的正确类型时。让我们看看这个例子：
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following is the output:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出：
- en: '![Figure 1.7: Output showing an error](img/Figure_1.7_B18621.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7：显示错误的输出](img/Figure_1.7_B18621.jpg)'
- en: 'Figure 1.7: Output showing an error'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7：显示错误的输出
- en: 'The issue here is that `rand.NewSource` requires a variable of the `int64`
    type. Go’s type inference rules interoperate a whole number, such as the one we
    used as an `int` value. We’ll look at the difference between them in more detail
    later in this book. To resolve this, we will add `int64` type to the declaration.
    Here’s how that looks:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是`rand.NewSource`需要一个`int64`类型的变量。Go的类型推断规则与整数（如我们用作`int`值的整数）交互操作。我们将在本书的后面更详细地探讨它们之间的区别。为了解决这个问题，我们将向声明中添加`int64`类型。以下是它的样子：
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Next, we’ll look at an even quicker way to declare variables.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一种更快声明变量的方法。
- en: Short variable declaration
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简短变量声明
- en: When declaring variables in functions and functions only, we can use the `:=`
    shorthand. This shorthand allows us to make our declarations even shorter. It
    does this by allowing us to not have to use the `var` keyword and by always inferring
    the type from a required initial value.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当在函数中声明变量时，我们可以使用`:=`简写。这种简写允许我们使我们的声明更短。它是通过允许我们不必使用`var`关键字，并且总是从所需的初始值推断类型来实现的。
- en: Exercise 1.05 – implementing a short variable declaration
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.05 – 实现简短变量声明
- en: 'In this exercise, we’ll update our previous exercise so that it uses a short
    variable declaration. Since you can only use a short variable declaration in a
    function, we’ll move our variable out of the package scope. Where before `Debug`
    had a type but no initial value, we’ll switch it back so that it has an initial
    value since that’s required when using a short variable declaration. Finally,
    we’ll print it to the console. Let’s get started:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将更新之前的练习，使其使用简短的变量声明。由于你只能在函数中使用简短变量声明，我们将把变量移出包作用域。之前`Debug`有类型但没有初始值，我们将将其切换回有初始值，因为使用简短变量声明时需要初始值。最后，我们将将其打印到控制台。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个`main.go`文件。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`文件顶部添加`main`包名：
- en: '[PRE50]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Import the packages we’ll need:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们需要的包：
- en: '[PRE51]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create the `main()` function:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE52]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Declare each variable using the short variable declaration notation:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用简短变量声明符号声明每个变量：
- en: '[PRE53]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Print the variables to the console:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将变量打印到控制台：
- en: '[PRE54]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新文件夹中运行以下命令：
- en: '[PRE55]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The following is the output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出：
- en: '![Figure 1.8: Output displaying the variable values that were printed after
    using short variable declaration notation](img/Figure_1.8_B18621.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: Output displaying the variable values that were printed after using
    short variable declaration notation'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we updated our previous code to use a very compact way to
    declare variables when we have an initial value to use.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The `:=` shorthand is very popular with Go developers and the most common way
    in which variables get defined in real-world Go code. Developers like how it makes
    their code concise and compact while still being clear as to what’s happening.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Another shortcut is declaring multiple variables on the same line.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Declaring multiple variables with a short variable declaration
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s possible to declare multiple variables at the same time using a short variable
    declaration. They must all be on the same line, and each variable must have a
    corresponding initial value. The notation looks like `<var1>, <var2>, …, <varN>
    := <val1>, <val2>, …, <valN>`. The variable names are on the left-hand side of`:=`,
    separated by `,`. The initial values are on the right-hand side of`:=` again,
    each separated by `,`. The leftmost variable name gets the leftmost value. There
    must be an equal number of names and values.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that uses our previous exercise’s code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following is the output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9: Example output displaying the variable values for the program
    with a variable declaring function](img/Figure_1.9_B18621.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.9: Example output displaying the variable values for the program with
    a variable declaring function'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you do see real-world code like this. It’s a little hard to read,
    so it’s not common to see it in terms of literal values. This doesn’t mean this
    isn’t common, though – it’s very common when calling functions that return multiple
    values. We’ll cover this in detail when we look at functions later in this book.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.06 – declaring multiple variables from a function
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll call a function that returns multiple values, and we’ll
    assign each value to a new variable. Then, we’ll print the values to the console.
    Let’s get started:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Import the packages we’ll need:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create a function that returns three values:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the function, return three literal values, each separated by `,`:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Close the function:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create the `main()` function:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Using a short variable declaration, capture the values that were returned from
    the function’s three new variables:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Print the three variables to the console:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Close the `main()` function:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following is the output:'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.10: Output displaying the variable values for the program with the
    variable declaring function](img/Figure_1.10_B18621.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.10: Output displaying the variable values for the program with the
    variable declaring function'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, we were able to call a function that returned multiple values
    and capture them using a short variable declaration in one line. If we used the
    `var` notation, it would look like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Short variable notation is a big part of how Go has the feel of a dynamic language.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: We’re not quite done with `var` yet, though – it still has a useful trick up
    its sleeve.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Using var to declare multiple variables in one line
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While it’s more common to use a short variable declaration, you can use `var`
    to define multiple variables on a single line. One limitation of this is that,
    when declaring the type, all the values must have the same type. If you use an
    initial value, then each value infers its type from the literal value so that
    they can differ. Here’s an example:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following is the output:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11: Output displaying variable values](img/Figure_1.11_B18621.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.11: Output displaying variable values'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Most of these are more compact when using a short variable declaration. This
    fact means they don’t come up in real-world code much. The exception is the same
    type-only example. This notation can be useful when you need many variables of
    the same type, and you need to control that type carefully.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Non-English variable names
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go is a UTF-8 compliant language, which means you can define variables’ names
    using alphabets other than the Latin alphabet that, for example, English uses.
    There are some limitations regarding what the name of a variable can be. The first
    character of the name must be a letter or `_`. The rest can be a mixture of letters,
    numbers, and `_`. Let’s have a look at what this looks like:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The following is the output:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12: Output showing variable values](img/Figure_1.12_B18621.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.12: Output showing variable values'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '**Languages and language**: Not all programming languages allow you to use
    UTF-8 characters as variables and function names. This feature could be one of
    the reasons why Go has become so popular in Asian countries, particularly in China.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Changing the value of a variable
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve defined our variables, let’s see what we can do with them. First,
    let’s change the value from its initial value. To do that, we’ll use a similar
    notation to when we set an initial value. This looks like `<variable> = <``value>`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.07 – changing the value of a variable
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Import the packages we’ll need:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Create the `main()` function:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Declare a variable:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Print the variable to the console:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Change the value of the variable:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Print it to the console again and close the `main()` function:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The following is the output before changing the variable’s value:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In this example, we’ve changed the value of offset from its initial value of
    `5` to `10`. Anywhere you use a raw value, such as `5` and `10` in our example,
    you can use a variable. Here’s how that looks:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The following is the output after changing the variable’s value:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Next, we’ll look at how we can change multiple variables in a one-line statement.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Changing multiple values at once
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the same way that you can declare multiple variables in one line, you can
    also change the value of more than one variable at a time. The syntax is similar,
    too; it looks like `<var1>, <var2>, …, <varN> = <val1>, <val2>, …, <``valN>`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.08 – changing multiple values at once
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll define some variables and use a one-line statement
    to change their values. Then, we’ll print their new values to the console. Let’s
    get started:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Import the packages we’ll need:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Create the `main()` function:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Declare our variables with an initial value:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Change each variable’s values using a one-line statement:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Print the values to the console and close the `main()` function:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The following is the output showing the changed variable values using a single
    statement:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In this exercise, we were able to change multiple variables in a single line.
    This approach would also work when calling functions, just as it does with a variable
    declaration. You need to be careful with a feature like this to ensure that, first
    and foremost, your code is easy to read and understand. If using a one-line statement
    like this makes it hard to know what the code is doing, then it’s better to take
    up more lines to write the code.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at what operators are and how they can be used to change your
    variables in interesting ways.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While variables hold the data for your application, they become truly useful
    when you start using them to build the logic of your software. Operators are the
    tools you use to work with your software’s data. With operators, you can compare
    data to other data – for example, you can check whether a price is too low or
    too high in a trading application. You can also use operators to manipulate data.
    For example, you can use operators to add the costs of all the items in a shopping
    cart to get the total price.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list mentions groups of operators:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '**Arithmetic operators**: These are used for math-related tasks such as addition,
    subtraction, and multiplication.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comparison operators**: These are used to compare two values; for example,
    whether they are equal, not equal, less than, or greater than each other.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool` value is false.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Address operators**: We’ll cover these in detail soon when we look at pointers.
    These are used to work with them.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Receive operators**: These are used when working with Go channels. We’ll
    cover this later in this book.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise 1.09 – using operators with numbers
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we are going to simulate a restaurant bill. To build our simulation,
    we’ll need to use mathematic and comparison operators. We’ll start by exploring
    all the major uses for operators.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'In our simulation, we’ll sum everything together and work out the tip based
    on a percentage. Then, we’ll use a comparison operator to see whether the customer
    gets a reward. Let’s get started:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: We have considered the US dollar as the currency for this exercise. You may
    consider any currency of your choice; the main focus here is the operations.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Import the packages you’ll need:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Create the `main()` function:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Create a variable to hold the total. For this item on the bill, the customer
    purchased two items that cost 13 USD. We must use `*` to do the multiplication.
    Then, we must print a subtotal:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Here, they purchased four items that cost 2.25 USD. We must use multiplication
    to get the total of these items, use `+` to add it to the previous total value,
    and then assign that back to the total:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This customer is getting a discount of 5 USD. Here, we use `–` to subtract
    5 USD from the total:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Then, we use multiplication to calculate a 10% tip:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Finally, we add the tip to the total:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The bill will be split between two people. Use `/` to divide the total into
    two parts:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Here, we’ll calculate whether the customer gets a reward. First, we’ll set
    `visitCount` and then add 1 USD to this visit:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Then, we’ll use `%` to give us any remainder after dividing `visitCount` by
    5 USD:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The customer gets a reward on every fifth visit. If the remainder is 0, then
    this is one of those visits. Use the `==` operator to check whether the remainder
    is 0:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'If it is, print a message stating that they get a reward:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The following is the output:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13: Output of operators used with numbers](img/B18621_01_13.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.13: Output of operators used with numbers'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, we used the math and comparison operators with numbers. They
    allowed us to model a complex situation – calculating a restaurant bill. There
    are lots of operators and which ones you can use vary with the different types
    of values. For example, as well as there being an addition operator for numbers,
    you can use the `+` symbol to join strings together. Here’s this in action:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The following is the output:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: For some situations, there are some shortcuts we can make with operators. We’ll
    go over this in the next section.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise operators
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Go has all the familiar bitwise operators you’d find in programming languages.
    If you know what bitwise operators are, then there will be no surprises here for
    you. If you don’t know what bitwise operators are, don’t worry – they aren’t common
    in real-world code.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Shorthand operators
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few shorthand assignment operators when you want to perform operations
    on an existing value with its own value:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '`--`: Reduce a number by 1'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`++`: Increase a number by 1'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+=`: Add and assign'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-=`: Subtract and assign'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise 1.10 – implementing shorthand operators
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll use some examples of operator shorthand to show how
    they can make your code more compact and easier to write. We’ll create some variables
    and then use shorthand to change them, printing them out as we go. Let’s get started:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Import the packages we’ll need:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Create the `main()` function:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Create a variable with an initial value:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We’ll add to it and then assign the result back to itself. Then, we’ll print
    it out:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Increment the value by 1 and then print it out:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Decrement it by 1 and then print it out:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Subtract and assign the result back to itself. Print out the new value:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'There is also a shorthand that works with strings. Define a string:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Next, we’ll append another string to the end of it and then print it out:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Close the `main()` function:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The following is the output:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14: Output using shorthand operators](img/B18621_01_14.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.14: Output using shorthand operators'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we used some shorthand operators. One set focused on modification
    and then assignment. This type of operation is common, and having these shortcuts
    makes coding more engaging. The other operators are increment and decrement. These
    are useful in loops when you need to step over data one at a time. These shortcuts
    make it clear what you’re doing to anyone who reads your code.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at comparing values to each other in detail.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Comparing values
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logic in applications is a matter of having your code make a decision. These
    decisions are made by comparing the values of variables to the rules you define.
    These rules come in the form of comparisons. We use another set of operators to
    make these comparisons. The result of these comparisons is always true or false.
    You’ll also often need to make lots of these comparisons to make a single decision.
    To help with that, we have logical operators.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: These operators, for the most part, work with two values and always result in
    a Boolean value. You can only use logical operators with Boolean values. Let’s
    take a look at comparison operators and logical operators in more detail.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '**Comparison operators**:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '`==`: True if two values are the same'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!=`: True if two values are not the same'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<`: True if the left value is less than the right value'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<=`: True if the left value is less or equal to the right value'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>`: True if the left value is greater than the right value'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>=`: True if the left value is greater than or equal to the right value'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logical operators**:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '`&&`: True if the left and right values are both true'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`||`: True if one or both the left and right values are true'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!`: This operator only works with a single value and results in true if the
    value is false'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise 1.11 – comparing values
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we’ll use comparison and logical operators to see what Boolean
    results we get when testing different conditions. We are testing to see what level
    of membership a user has based on the number of visits they’ve had.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'Our membership levels are as follows:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '**Silver**: Between 10 and 20 visits inclusively'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gold**: Between 21 and 30 visits inclusively'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platinum**: Over 30 visits'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s get started:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Import the packages we’ll need:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Create the `main()` function:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Define our `visits` variable and initialize it with a value:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Use the equals operator to see whether this is their first visit. Then, print
    the result to the console:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Use the not equal operator to see whether they are a returning visitor:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Let’s check whether they are a silver member using the following code:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Let’s check whether they are a gold member using the following code:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Let’s check whether they are a platinum member using the following code:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Close the `main()` function:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The following is the output:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.15: Output displaying the comparison result](img/B18621_01_15.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.15: Output displaying the comparison result'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we used comparison and logical operators to make decisions
    about data. You can combine these operators in an unlimited number of ways to
    express almost any type of logic your software needs to make.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at what happens when you don’t give a variable an initial value.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Zero values
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The zero value of a variable is the empty or default value for that variable’s
    type. Go has a set of rules stating that the zero values are for all the core
    types. Let’s take a look:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.16: Variable types and their zero values](img/B18621_01_16.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.16: Variable types and their zero values'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: There are other types, but they are all derived from these core types, so the
    same rules still apply.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at the zero values of some types in the upcoming exercise.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.12 – zero values
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we’ll define some variables without an initial value. Then,
    we’ll print out their values. We’re using `fmt.Printf` to help us in this exercise
    as we can get more detail about a value’s type. `fmt.Printf` uses a template language
    that allows us to transform passed values. The substitution we’re using is `%#v`.
    This transformation is a useful tool for showing a variable’s value and type.
    Some other common substitutions you can try are as follows:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.17: Table on substitutions](img/B18621_01_17.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.17: Table on substitutions'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `fmt.Printf`, you need to add the new line symbol yourself. You
    can do this by adding `\n` to the end of the string. Let’s get started:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Import the packages we’ll need:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Create the `main()` function:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Declare and print an integer:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Declare and print a `float` value:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Declare and print a `bool` value:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Declare and print a `string` value:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Declare and print a collection of strings:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Declare and print a struct (a type composed of other types; we will cover this
    later in this book):'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Close the `main()` function:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The following is the output:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.18: Output showing initial variable values](img/Figure_1.18_B18621.jpg)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.18: Output showing initial variable values'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we defined a variety of variable types without an initial
    value. Then, we printed them out using `fmt.Printf` to expose more detail about
    the values. Knowing what the zero values are and how Go controls them allows you
    to avoid bugs and write concise code.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at what pointers are and how they can enable you to write efficient
    software.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: Value versus pointer
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With values such as `int`, `bool`, and `string`, when you pass them to a function,
    Go makes a copy of the value, and it’s the copy that’s used in the function. This
    copying means that a change that’s made to the value in the function doesn’t affect
    the value that you used when calling the function.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Passing values by copying tends to result in code that has fewer bugs. With
    this method of passing values, Go can use its simple memory management system,
    called the stack. The downside is that copying uses up more and more memory as
    values get passed from function to function. In real-world code, functions tend
    to be small, and values get passed to lots of functions, so copying by value can
    sometimes end up using much more memory than is needed.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative to copying that uses less memory. Instead of passing
    a value, we create something called a pointer and then pass that to functions.
    A pointer is not a value itself, and you can’t do anything useful with a pointer
    other than getting a value using it. You can think of a pointer as the address
    of the value you want, and to get to the value, you must go to the address. If
    you use a pointer, Go won’t make a copy of the value when passing a pointer to
    a function.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: When creating a pointer to a value, Go can’t manage the value’s memory using
    the stack. This is because the stack relies on simple scope logic to know when
    it can reclaim the memory that’s used by a value, and having a pointer to a variable
    means these rules don’t work. Instead, Go puts the value on the heap. The heap
    allows the value to exist until no part of your software has a pointer to it anymore.
    Go reclaims these values in what it calls its garbage collection process. This
    process happens periodically in the background, and you don’t need to worry about
    it.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Having a pointer to a value means that a value is put on the heap, but that’s
    not the only reason that happens. Working out whether a value needs to be put
    on the heap is called escape analysis. There are times when a value with no pointers
    is put on the heap, and it’s not always clear why.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: You have no direct control over whether a value is put on the stack or the heap.
    Memory management is not part of Go’s language specification. Memory management
    is considered an internal implementation detail. This means it could be changed
    at any time, and that what we’ve spoken about are only general guidelines and
    not fixed rules and could change at a later date.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: While the benefits of using a pointer over a value that gets passed to lots
    of functions are clear for memory usage, it’s not so clear for CPU usage. When
    a value gets copied, Go needs CPU cycles to get that memory and then release it
    later. Using a pointer avoids this CPU usage when passing it to a function. On
    the other hand, having a value on the heap means that it then needs to be managed
    by the complex garbage collection process. This process can become a CPU bottleneck
    in certain situations – for example, if there are lots of values on the heap.
    When this happens, the garbage collector has to do lots of checking, which uses
    up CPU cycles. There is no correct answer here, and the best approach is the classic
    performance optimization one. First, don’t prematurely optimize. When you do have
    a performance problem, measure before you make a change, and then measure after
    you’ve made a change.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Beyond performance, you can use pointers to change your code’s design. Sometimes,
    using pointers allows for a cleaner interface and simplifies your code. For example,
    if you need to know whether a value is present or not, a non-pointer value always
    has at least its zero value, which could be valid in your logic. You can use a
    pointer to allow for an `is not set` state as well as holding a value. This is
    because pointers, as well as holding the address to a value, can also be `nil`,
    which means there is no value. In Go, `nil` is a special type that represents
    something not having a value.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: The ability for a pointer to be nil also means that it’s possible to get the
    value of a pointer when it doesn’t have a value associated with it, which means
    you’ll get a runtime error. To prevent runtime errors, you can compare a pointer
    to `nil` before trying to get its value. This looks like `<pointer> != nil`. You
    can compare pointers with other pointers of the same type, but they only result
    in true if you are comparing a pointer to itself. No comparison of the associated
    values gets made.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: Pointers are powerful tools in the language thanks to their efficiency, ability
    to pass by reference (instead of pass by value) to allow functions to modify the
    original values, and how they allow for dynamic memory allocation using the garbage
    collector. However, with any great tool comes great responsibility. Pointers can
    be dangerous if misused, such as in the event memory is freed (deallocated) and
    the pointer becomes a “dangling pointer,” which could lead to undefined behavior
    if accessed. There is also the potential for memory leaks, unsafe operations due
    to direct memory access, and concurrency challenges if there are shared pointers
    that could introduce data races. Overall, Go’s pointers are generally straightforward
    and less error-prone compared to other languages such as C.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Getting a pointer
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get a pointer, you have a few options. You can declare a variable as being
    a pointer type using a `var` statement. You can do this by adding `*` at the front
    of most types. This notation looks like `var <name> *<type>`. The initial value
    of a variable that uses this method is `nil`. You can use the built-in `new` function
    for this. This function is intended to be used to get some memory for a type and
    return a pointer to that address. The notation looks like `<name> := new(<type>)`.
    The `new` function can be used with `var` too. You can also get a pointer from
    an existing variable using `&, which you can read as "address of"`. This looks
    like `<var1> := &<``var2>.`
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.13 – getting a pointer
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll use each of the methods we can use to get a pointer
    variable. Then, we’ll print them to the console using `fmt.Printf` to see what
    their types and value are. Let’s get started:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Import the packages we’ll need:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Create the `main()` function:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Declare a pointer using a `var` statement:'
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Create a variable using `new`:'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-524
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'You can’t take the address of a literal number. Create a temporary variable
    to hold a number:'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-526
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Using `&`, create a pointer from the existing variable:'
  id: totrans-527
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-528
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'It’s possible to create a pointer from some types without a temporary variable.
    Here, we’re using our trusty `time` struct:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-530
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Print each out using `fmt.Printf`:'
  id: totrans-531
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Close the `main()` function:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-536
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The following is the output:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.19: Output showing pointers](img/B18621_01_19.jpg)'
  id: totrans-538
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.19: Output showing pointers'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we looked at three different ways of creating a pointer. Each
    one is useful, depending on what your code needs. With the `var` statement, the
    pointer has a value of `nil`, while the others already have a value address associated
    with them. For the `time` variable, we can see the value, but we can tell it’s
    a pointer because its output starts with `&`.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll see how we can get a value from a pointer.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: Getting a value from a pointer
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercise, when we printed out the pointer variables for the
    `int` pointers to the console, we either got `nil` or saw a memory address. To
    get to the value a pointer is associated with, you must dereference the value
    using `*` in front of the variable name. This looks like `fmt.Println(*<val>)`.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: Dereferencing a zero or `nil` pointer is a common bug in Go software as the
    compiler can’t warn you about it, and it happens when the app is running. Therefore,
    it’s always best practice to check that a pointer is not `nil` before dereferencing
    it unless you are certain it’s not `nil`.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: You don’t always need to dereference – for example, when a property or function
    is on a struct. Don’t worry too much about when you shouldn’t be dereferencing
    as Go gives you clear errors regarding when you can and can’t dereference a value.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.14 – getting a value from a pointer
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll update our previous exercise to dereference the values
    from the pointers. We’ll also add `nil` checks to prevent us from getting any
    errors. Let’s get started:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Import the packages we’ll need:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Create the `main()` function:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Our pointers are declared in the same way as they were previously:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'For counts 1, 2, and 3, we need to add a `nil` check and add `*` in front of
    the variable name:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'We’ll also add a `nil` check for our `time` variable:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'We’ll dereference the variable using `*`, just like we did with the `count`
    variables:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Here, we’re calling a function on our `time` variable. This time, we don’t
    need to dereference it:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Close the `nil` check:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Close the `main()` function:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The following is the output:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.20: Output showing getting values from pointers](img/B18621_01_20.jpg)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.20: Output showing getting values from pointers'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we used dereferencing to get the values from our pointers.
    We also used `nil` checks to prevent dereferencing errors. From the output of
    this exercise, we can see that `count1` was a `nil` value and that we’d have gotten
    an error if we tried to dereference. `count2` was created using `new`, and its
    value is a zero value for its type. `count3` also had a value that matched the
    value of the variable we got the pointer from. With our `time` variable, we were
    able to dereference the whole struct, which is why our output doesn’t start with
    `&`.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at how using a pointer allows us to change the design of our
    code.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: Function design with pointers
  id: totrans-576
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll cover functions in more detail later in this book, but you know enough
    from what we’ve done so far to see how using a pointer can change how you use
    a function. A function must be coded to accept pointers, and it’s not something
    that you can choose whether to do or not. If you have a pointer variable or have
    passed a pointer of a variable to a function, any changes that are made to the
    value of the variable in the function also affect the value of the variable outside
    of the function.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.15 – function design with pointers
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll create two functions: one that accepts a number by
    value, adds 5 to it, and then prints the number to the console; and another function
    that accepts a number as a pointer, adds 5 to it, and then prints the number out.
    We’ll also print the number out after calling each function to assess what effect
    it has on the variable that was passed to the function. Let’s get started:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Import the packages we’ll need:'
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Create a function that takes an `int` pointer as an argument:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Add `5` to the passed number:'
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Print the updated number to the console:'
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Close the function:'
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Create another function that takes an `int` pointer:'
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Dereference the value and add `5` to it:'
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Print out the updated value of `count` and dereference it:'
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Close the function:'
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Create the `main()` function:'
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Declare an `int` variable:'
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Call the first function with the variable:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Print the current value of the variable:'
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Call the second function. This time, you’ll need to use `&` to pass a pointer
    to the variable:'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Print the current value of the variable:'
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Close the `main()` function:'
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'The following is the output:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.21: Output displaying the current value of the variable](img/B18621_01_21.jpg)'
  id: totrans-618
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.21: Output displaying the current value of the variable'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we showed you how passing values by a pointer can affect the
    value variables that are passed to them. We saw that, when passing by value, the
    changes you make to the value in a function do not affect the value of the variable
    that’s passed to the function, while passing a pointer to a value does change
    the value of the variable passed to the function.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: You can use this fact to overcome awkward design problems and sometimes simplify
    the design of your code. Passing values by a pointer has traditionally been shown
    to be more error-prone, so use this design sparingly. It’s also common to use
    pointers in functions to create more efficient code, which Go’s standard library
    does a lot.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: Activity 1.02 – pointer value swap
  id: totrans-622
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, your job is to finish some code a co-worker started. Here,
    we have some unfinished code for you to complete. Your task is to fill in the
    missing code, where the comments are to swap the values of `a` and `b`. The `swap`
    function only accepts pointers and doesn’t return anything:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Follow these steps:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: Call the `swap` function, ensuring you are passing a pointer.
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `swap` function, assign the values to the other pointer, ensuring you
    dereference the values.
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Next, we’ll look at how we can create variables with a fixed value.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  id: totrans-631
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constants are like variables, but you can’t change their initial values. These
    are useful for situations where the value of a constant doesn’t need to or shouldn’t
    change when your code is running. You could make the argument that you could hardcode
    those values into the code and it would have a similar effect. Experience has
    shown us that while these values don’t need to change at runtime, they may need
    to change later. If that happens, it can be an arduous and error-prone task to
    track down and fix all the hardcoded values. Using a constant is a tiny amount
    of work now that can save you a great deal of effort later.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: 'Constant declarations are similar to `var` statements. With a constant, the
    initial value is required. Types are optional and inferred if left out. The initial
    value can be a literal or a simple statement and can use the values of other constants.
    Like `var`, you can declare multiple constants in one statement. Here are the
    notations:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Exercise 1.16 – constants
  id: totrans-635
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we have a performance problem: our database server is too
    slow. We are going to create a custom memory cache. We’ll use Go’s `map` collection
    type, which will act as the cache. There is a global limit on the number of items
    that can be in the cache. We’ll use one `map` to help keep track of the number
    of items in the cache. We have two types of data we need to cache: books and CDs.
    Both use the ID, so we need a way to separate the two types of items in the shared
    cache. We need a way to set and get items from the cache.'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to set the maximum number of items in the cache. We’ll also use
    constants to add a prefix to differentiate between books and CDs. Let’s get started:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Import the packages we’ll need:'
  id: totrans-641
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Create a constant that’s our global limit size:'
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Create a `MaxCacheSize` constant that is 10 times the global limit size:'
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-646
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Create our cache prefixes:'
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-648
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Declare a `map` value that has a `string` value for a key and a `string` value
    for its values as our cache:'
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-650
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Create a function to get items from the cache:'
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-652
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Create a function that sets items in the cache:'
  id: totrans-653
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-654
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'In this function, check out the `MaxCacheSize` constant to stop the cache going
    over that size:'
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-656
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Create a function to get a book from the cache:'
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-658
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Use the book cache prefix to create a unique key:'
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Create a function to add a book to the cache:'
  id: totrans-661
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Use the book cache prefix to create a unique key:'
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-664
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Create a function to get CD data from the cache:'
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Use the `CD` cache prefix to create a unique key:'
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-668
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Create a function to add CDs to the shared cache:'
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-670
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'Use the `CD` cache prefix constant to build a unique key for the shared cache:'
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Create the `main()` function:'
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Initialize our cache by creating a `map` value:'
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Add a book to the cache:'
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Add a `CD` cache prefix to the cache:'
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Get and print that `Book` from the cache:'
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-682
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Get and print that `CD` from the cache:'
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Close the `main()` function:'
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-686
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'The following is the output:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.22: Output displaying the Book and CD caches](img/B18621_01_22.jpg)'
  id: totrans-690
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.22: Output displaying the Book and CD caches'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we used constants to define values that don’t need to change
    while the code is running. We declared then using a variety of notation options,
    some with the typeset and some without. We declared a single constant and multiple
    constants in a single statement.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at a variation of constants for values that are more closely
    related.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  id: totrans-694
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enums are a way of defining a fixed list of values that are all related. Go
    doesn’t have a built-in type for enums, but it does provide tools such as `iota`
    to let you define your own using constants. We’ll explore this now.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following code, we have the days of the week defined as
    constants. This code is a good candidate for Go’s `iota` feature:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'With `iota`, Go helps us manage lists just like this. Using `iota`, the following
    code is equal to the preceding code:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: Now, we have `iota` assigning the numbers for us. Using `iota` makes enums easier
    to create and maintain, especially if you need to add a new value to the middle
    of the code later. Order matters when using `iota` as it is an identifier that
    tells the Go compiler to start the first value at 0 and increment by 1 for each
    subsequent value in the case of this example. With `iota`, you can skip values
    using `_`, start with a different offset, and even use more complicated calculations.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll take a detailed look at Go’s variable scoping rules and how they
    affect how you write code.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: All the variables in Go live in a scope. The top-level scope is the package
    scope. A scope can have child scopes within it. There are a few ways a child scope
    gets defined; the easiest way to think about this is that when you see `{`, you
    are starting a new child scope, and that child scope ends when you get to a matching
    `}`. The parent-child relationship is defined when the code compiles, not when
    the code runs. When accessing a variable, Go looks at the scope the code was defined
    in. If it can’t find a variable with that name, it looks in the parent scope,
    then the grandparent scope, all the way until it gets to the package scope. It
    stops looking once it finds a variable with a matching name or raises an error
    if it can’t find a match.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: To put it another way, when your code uses a variable, Go needs to work out
    where that variable was defined. It starts its search in the scope of the code
    using the variable it’s currently running in. If a variable definition using that
    name is in that scope, then it stops looking and uses the variable definition
    to complete its work. If it can’t find a variable definition, then it starts walking
    up the stack of scopes, stopping as soon as it finds a variable with that name.
    This searching is all done based on a variable name. If a variable with that name
    is found but is of the wrong type, Go raises an error.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have four different scopes, but we define the `level` variable
    once. This means that no matter where you use `level`, the same variable is used:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'The following is the output displaying variables when using `level`:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'In this example, we’ve shadowed the `level` variable. This new `level` variable
    is not related to the `level` variable in the package scope. When we print `level`
    in the block, the Go runtime stops looking for variables called `level` as soon
    as it finds the one defined in `main`. This logic results in a different value
    getting printed out once that new variable shadows the package variable. You can
    also see that it’s a different variable because it’s a different type, and a variable
    can’t have its type changed in Go:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'The following is the output:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Go’s static scope resolution comes into play when we call `funcA`. That’s why,
    when `funcA` runs, it still sees the package scope’s `level` variable. The scope
    resolution doesn’t pay attention to where `funcA` gets called.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: 'You can’t access variables defined in a child scope:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'The following is the output:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.23: Output displaying an error](img/Figure_1.23_B18621.jpg)'
  id: totrans-717
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.23: Output displaying an error'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: Activity 1.03 – message bug
  id: totrans-719
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following code doesn’t work. The person who wrote it can’t fix it, and they’ve
    asked you to help them. Can you get it to work?
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Follow these steps:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and see what the output is.
  id: totrans-723
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The problem is with `message`; make a change to the code.
  id: totrans-724
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rerun the code and see what difference it makes.
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process until you see the expected output.
  id: totrans-726
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  id: totrans-727
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-728
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: In this activity, we saw that where you define your variables has a big impact
    on the code. Always think about the scope you need your variables to be in when
    defining them.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: In the next activity, we are going to look at a similar problem that is a bit
    trickier.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: Activity 1.04 – bad count bug
  id: totrans-731
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your friend is back, and they have another bug in their code. This code should
    print `true`, but it’s printing `false`. Can you help them fix the bug?
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'Follow these steps:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and see what the output is.
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The problem is with `count`; make a change to the code.
  id: totrans-736
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rerun the code and see what difference it makes.
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process until you see the expected output.
  id: totrans-738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Summary
  id: totrans-741
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got into the nitty-gritty of variables, including how variables
    are declared, and all the different notations you can use to declare them. This
    variety of notation gives you a nice compact notation to use for 90% of your work,
    while still giving you the power to be very specific when you need to the other
    10% of the time. We looked at how to change and update the value of variables
    after you’ve declared them. Again, Go gives you some great shorthand to help in
    the most common use cases to make your life easier. All your data ends up in some
    form of variable. Data is what makes code dynamic and responsive. Without data,
    your code could only ever do exactly one thing; data unleashes the true power
    of software.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: Now that your application has data, it needs to make choices based on that data.
    That’s where variable comparison comes in. This helps us see whether something
    is true or false, bigger or smaller, and so on, and it also helps us make choices
    based on the results of those comparisons.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: We explored how Go decided to implement its variable system by looking at zero
    values, pointers, and scope logic. At this point, we know that these are the details
    that can be the difference between delivering bug-free efficient software and
    not doing so.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: We also took a look at how we can declare immutable variables by using constants
    and how `iota` can help manage lists or related constants to work, such as enums.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll start to put our variables to work by defining logic
    and looping over collections of variables.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
