- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command and Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll use branching logic and loops to demonstrate how logic
    can be controlled and selectively run. With these tools, you’ll have control of
    what you do and don’t want to run based on the values of variables.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to implement branching logic using
    `if`, `else`, and `else if`; use `switch` statements to simplify complex branching
    logic; create looping logic using a `for` loop; loop over complex data collections
    using `range`; use `continue` and `break` to take control of the flow of loops;
    and use `goto` statements to jump to a labeled statement within a function.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you''ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter02).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at variables and values and how we can temporarily
    store data in a variable and make changes to that data. We’re now going to look
    at how we can use that data to run logic in code, or not, selectively. “Logic”
    refers to the sequence of instructions that control how your program operates
    or processes data. This logic allows you to control how data flows through your
    software. You can react to and perform different operations based on the values
    in your variables.
  prefs: []
  type: TYPE_NORMAL
- en: The logic could be for validating your user’s inputs. If we were writing code
    to manage a bank account and the user asked to withdraw some money, we could check
    that they asked for a valid amount of money. We would check that they had enough
    money in their account. If the validation were successful, we would use logic
    to update their balance, transfer the money, and show a success message. If the
    validation failed, we’d show a message explaining what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: If your software is a virtual world, then logic is the physical law of that
    world. Like the physical laws of our world, those laws must be followed and can’t
    be broken. If you create a law with a flaw in it, then your virtual world won’t
    run smoothly and could even explode.
  prefs: []
  type: TYPE_NORMAL
- en: Another form of logic is a loop; using loops allows you to execute the same
    code multiple times. A common way to use loops is to iterate over a collection
    of data. For our imaginary banking software, we would use a loop to step through
    a user’s transactions to display them to the user on request.
  prefs: []
  type: TYPE_NORMAL
- en: Loops and logic allow the software to have complex behavior that responds to
    changing and dynamic data.
  prefs: []
  type: TYPE_NORMAL
- en: if statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An `if` statement is the most basic form of logic in Go. An `if` statement
    either will or will not run a block of code based on a Boolean expression. The
    notation looks like this: `if <boolean expression> { <code` `block> }`.'
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean expression can be simple code that results in a Boolean value. The
    code block can be any logic that you could also put in a function and are confined
    to the code block of that function. The code block runs when the Boolean expression
    is true. You can only use `if` statements within the scope of a function. In Go,
    the concept of “function scope” refers to the visibility and accessibility of
    variables and statements within a function. .
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.01 – a simple if statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll use an `if` statement to control whether certain code
    will or will not run. We’ll define an `int` value that will be hardcoded, but
    in a real-world application, this could be user input. We’ll then check whether
    the value is an odd or even number using the `%` operator, also known as a modulus
    expression, on the variable. The modulus gives you the amount remaining after
    division. We’ll use the modulus to get the remainder after dividing by 2\. If
    we get a remainder of 0, then we know the number is even. If the remainder is
    1, then we know the number is odd. The modulus results in an `int` value, so we
    use `==` (comparison operator) to get a `true` or `false` Boolean value:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define an `int` variable with an initial value. We are setting it to 5 here,
    which is an odd number, but we could also set it to 6, which is an even number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `if` statement that uses a modulus expression, then check whether
    the result is equal to 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the Boolean expression results in `true`, that means the number is even.
    We then print that it’s even to the console using the `fmt` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now do the same for odd numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close `main`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file, and in the new folder, run the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we used logic to run code selectively. Using logic to control
    which code runs lets you create flows through your code. This allows you to have
    code that reacts to its data. These flows allow you to be able to reason about
    what the code is doing with your data, making it easier to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Try changing the value of the input to 6 to see how the even block gets executed
    instead of the odd block.
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, we’ll explore how we can improve this code and make it more
    efficient.
  prefs: []
  type: TYPE_NORMAL
- en: if else statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercise, we did two evaluations. One evaluation was to check
    whether the number was even and the other was to see whether it was odd. As we
    know, a number can only ever be odd or even. With this knowledge, we can use deduction
    to know that if a number is not even, then it must be odd.
  prefs: []
  type: TYPE_NORMAL
- en: Using deductive logic such as this is common in programming in order to make
    programs more efficient by not having to do unnecessary work.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can represent this kind of logic using an `if else` statement. The notation
    looks like this: `if <boolean expression> { <code block> } else { <code block>
    }`. The `if else` statement builds on the `if` statement and gives us a second
    block. The second block only runs if the first block doesn’t run; both blocks
    can’t run together.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.02 – using an if else statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll update our previous exercise to use an `if` `else`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define an `int` variable with an initial value, and we’ll give it a different
    value this time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an `if` statement that uses a modulus expression, and then check whether
    the result is equal to 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, we are not closing the code block but starting a new `else` code
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close `main`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file, and in the new folder, run the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we were able to simplify our previous code by using an `if
    else` statement. As well as making the code more efficient, it also makes the
    code easier to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, we’ll demonstrate how we can add as many code blocks as we
    want while still only letting one execute.
  prefs: []
  type: TYPE_NORMAL
- en: else if statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`if else` solves the problem of running code for only one or two possible logical
    outcomes. With that covered, what if our preceding exercise’s code was intended
    to only work for non-negative numbers? We’d need something that could evaluate
    more than one Boolean expression but only execute one of the code blocks; that
    is, the code block for negative numbers, even numbers, or odd numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In that case, we can’t use an `if else` statement on its own; however, we could
    cover it with another extension to `if` statements. In this extension, you can
    give the `else` statement its own Boolean expression. This is how the notation
    looks: `if <boolean expression> { <code block> } else if <boolean expression>
    { <code block> }`. You can also combine it with a final `else` statement at the
    end, which would look like this: `if <boolean expression> { <code block> } else
    if <boolean expression> { <code block> } else { <code block> }`. After the initial
    `if` statement, you can have as many `else if` statements as you need. Go evaluates
    Boolean expressions from the top of statements and works its way through each
    Boolean expression until one results in `true` or it finds an `else` instance.
    If there is no `else` instance and none of the Boolean expressions results in
    `true`, then no block is executed and Go moves on. When Go gets a Boolean `true`
    result, it executes the code block for that statement only, and it then stops
    evaluating any Boolean expressions of the `if` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.03 – using an else if statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll update our previous exercise. We’re going to add a
    check for negative numbers. This check must run before the even and odd checks,
    as only one of the code blocks can run:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define an `int` variable with an initial value, and we’ll give it a negative
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our first Boolean expression is to check for negative numbers. If we find a
    negative number, we’ll print a message saying that they are not allowed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to move our even check to an `else` `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `else` statement stays the same, and we then close `main`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file, and in the new folder, run the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we added even more complex logic to our `if` statement. We
    added an `else if` statement to it, which allowed complex evaluation. This addition
    took what is usually a simple fork in the road that gives you many roads to go
    down but still with the restriction of only going down one of them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, we’ll use a subtle but powerful feature of `if` statements
    that lets you keep your code nice and tidy.
  prefs: []
  type: TYPE_NORMAL
- en: initial if statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s common to need to call a function but not care too much about the returned
    value. Often, you’ll want to check that it executed correctly and then discard
    the returned value; for example, sending an email, writing to a file, or inserting
    data into a database: most of the time, if these types of operations execute successfully,
    you don’t need to worry about the variables they return. Unfortunately, the variables
    don’t go anywhere as they are still in scope.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop these unwanted variables from hanging around, we can use what we know
    about scope rules to get rid of them. The best way to check for errors is to use
    `initial` statements on `if` statements. The notation looks like this: `if <initial
    statement>; <boolean expression> { <code block> }`. The initial statement is in
    the same section as the Boolean expression, with `;` to divide them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go only allows what it calls simple statements in the initial statement section,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assignment and short variable assignments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expressions such as math or logic expressions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sending statements for working with channels, which we’ll cover later in [*Chapter
    17*](B18621_17.xhtml#_idTextAnchor1790) where we focus on concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Increment and decrement expressions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A common mistake is trying to define a variable using `var`. That’s not allowed;
    you can use a short assignment in its place.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.04 – implementing initial if statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to continue to build on our previous exercises.
    We’re going to add even more rules about which numbers can be checked as to whether
    they are odd or even. With so many rules, putting them all in a single Boolean
    expression is hard to understand. We’ll move all the validation logic to a function
    that returns an error. This is a built-in Go type used for errors. If the value
    of the error is `nil`, then everything is okay. If not, you have an error, and
    you need to deal with it. We’ll call the function in our initial statement and
    then check for errors:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to do the validation. This function takes a single integer
    and returns an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define some rules, and if any are `true`, we return a new error using the
    `New` function in the `errors` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the input passes all the checks, return `nil`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create our `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a variable with a value of `21`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the function using the initial statement; use the short variable assignment
    to capture the returned error. In the Boolean expression, check that the error
    is not equal to `nil` using `!=`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The rest is the same as before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file, and in the new folder, run the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the expected output, which displays an error statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we used an initial statement to define and initialize a variable.
    That variable can be used in the Boolean expression and the related code block.
    Once the `if` statement completes, the variable goes out of scope and is reclaimed
    by Go’s memory management system.
  prefs: []
  type: TYPE_NORMAL
- en: Expression switch statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it’s possible to add as many `else if` statements to an `if` statement
    as you want, at some point, it’ll get hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this happens, you can use Go’s logic alternative: `switch`. For situations
    where you would need a big `if` statement, `switch` can be a more compact alternative.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The notation for `switch` is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The *initial* statement works the same in `switch` as it does in the preceding
    `if` statements. The expression is not the same because `if` is a Boolean expression.
    You can have more than just a Boolean in this expression. The `cases` are where
    you check to see whether the statements get executed. Statements are like code
    blocks in `if` statements, but with no need for the curly braces here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the initial statement and expression are optional. To have just the expression,
    it would look like this: `switch <expression> {…`. To have only the initial statement,
    you would write `switch <initial statment>; {…`. You can leave them both off,
    and you’ll end up with `switch {…`. When the expression is missing, it’s as if
    you put the value of `true` there.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two main ways of using `case` expressions. They can be used just like
    `if` statements or Boolean expressions where you use logic to control whether
    the statements get executed. The alternative is to put a literal value there.
    In this case, the value is compared to the value in the `switch` expression. If
    they match, then the statements run. You can have as many case expressions as
    you want by separating them with `,`. The case expressions get checked from the
    top case and then from left to right if a case has multiple expressions.
  prefs: []
  type: TYPE_NORMAL
- en: When a case matches, only its statements are run, which is different from many
    other languages. To get the fall-through behavior found in those languages, a
    `fallthrough` statement must be added to the end of each case where you want that
    behavior. If you call `fallthrough` before the end of the case, it will fall through
    at that moment and move on to the next case.
  prefs: []
  type: TYPE_NORMAL
- en: An optional `default` case can be added anywhere in a `switch` statement, but
    it’s best practice to add it to the end. The `default` case works just like using
    an `else` statement in an `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: This form of `switch` statement is called an *expression* `switch` statement.
    There is also another form of `switch` statement, called a *type* `switch` statement,
    which we’ll look at in [*Chapter 4*](B18621_04.xhtml#_idTextAnchor715).
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.05 – using a switch statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we need to create a program that prints a particular message
    based on the day someone was born. We are using the `time` package for the set
    of days of the week constants. We’ll use a `switch` statement to make a more compact
    logic structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the `main` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the `fmt` and `time` packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a variable that is the day of the week someone was born. Use the constants
    from the `time` package to do it. We’ll set it to Monday, but it could be any
    day:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `switch` statement that uses the variable as its expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Each `case` expression will try to match its expression value against the `switch`
    expression value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll use the `default` case here as a form of validation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file, and in the new folder, run the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we used `switch` to create a compact logic structure that
    matches lots of different possible values to give a specific message to our users.
    It’s quite common to see `switch` statements used with a constant as we did here,
    using the day-of-the-week constants from the `time` package.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll use the `case` feature that lets us match multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.06 – switch statements and multiple case values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to print out a message that tells us whether
    the day someone was born was a weekday or at the weekend. We only need two cases
    as each case can support checking multiple values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the `main` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the `fmt` and `time` packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define our `dayBorn` variable using one of the `time` package’s constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`switch` starts the same by using the variable as the expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, for `case`, we have weekday constants. Go checks each one against
    the `switch` expression, starting from the left, and sweeps through each one by
    one. Once Go gets a match, it stops evaluating and runs the statements for that
    case only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, it does the same for weekend days:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use `default` for validation again and close out the `switch` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file, and in the new folder, run the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we used cases with multiple values. This allowed a very compact
    logic structure that could evaluate 7 days of the week with validation checking
    in a few lines of code. It makes the intention of the logic clear, which, in turn,
    makes it easier to change and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at using more complex logic in `case` expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you’ll see code that doesn’t evaluate anything in the `switch` statement
    but does checks in the `case` expression.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.07 – expressionless switch statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s not always possible to be able to match values using the value of the `switch`
    expression. Sometimes, you’ll need to match on multiple variables. Other times,
    you’ll need to match on something more complicated than an equality check. For
    example, you may need to check whether a number is in a specific range. In these
    cases, `switch` is still helpful in building compact logic statements, as `case`
    allows the same range of expressions that you have in `if` Boolean expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, let’s build a simple `switch` expression that checks whether
    a day is at the weekend to show what can be done in `case`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load the `main` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the `fmt` and `time` packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `switch` expression is using the initial statement to define our variable.
    The expression is left empty as we won’t be using it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`case` is using some complex logic to check whether the day is at the weekend:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `default` statement and close the `switch` expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file, and in the new folder, run the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we learned that you can use complex logic in a case expression
    when a simple switch statement match is not enough. This still offers a more compact
    and easier way to manage a logic statement than if you have more than a couple
    of cases.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll leave logic structures behind and start to look at ways in which
    we can run the same statements multiple times to make processing data easier.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In real-world applications, you’re often going to need to run the same logic
    repeatedly. It’s common to have to deal with multiple inputs and give multiple
    outputs. Loops are the simplest way of repeating your logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go only has one looping statement, `for`, but it’s a flexible one. There are
    two distinct forms: the first is used a lot for ordered collections such as arrays
    and slices, which we’ll cover more later. The sort of loop used for ordered collections
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `initial` statement is just like the one found in `if` and `switch` statements.
    An `initial` statement runs before everything else and allows the same simple
    statements that we defined before. The condition is checked before each loop to
    see whether the statements should be run or whether the loop should stop. As with
    an `initial` statement, `condition` also allows simple statements. A `post` statement
    is run after the statements are run at the end of each loop and allows you to
    run simple statements. The `post` statement is mostly used for incrementing things
    such as loop counters, which get evaluated on the next loop by `condition`. The
    statements are any Go code you want to run as part of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: '`initial`, `condition`, and `post` statements are all optional, and it’s possible
    to write a `for` loop like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This form would result in a loop that would run forever, also known as an infinite
    loop, unless a `break` statement is used to stop the loop manually. In addition
    to `break`, there is also a `continue` statement that can be used to skip the
    remainder of an individual run of a loop but doesn’t stop the whole loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another form a `for` loop can take is when reading from a source of data that
    returns a Boolean when there is more data to read. Examples of this include when
    reading from databases, files, command-line inputs, and network sockets. This
    form looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This form is just a simplified version of the form used to read from an ordered
    list but without the logic needed to control the loop yourself, as the source
    you’re using is built to work easily in `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other form that a `for` loop takes is when looping over unordered data
    collections such as maps. We’ll cover what maps are in more detail in a later
    chapter. When looping over these, you’ll use a `range` statement in your loop.
    With maps, the form looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 2.08 – using a for i loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll use the three parts of a `for` loop to create a variable
    and use a variable in the loop. We’ll be able to see how the variable changes
    after each iteration of the loop by printing out its value to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a package as `main` and add the import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `for` loop that defines an `i` variable with an initial value of `0`
    in the `initial` statement section. In the clause, check that `i` is less than
    `5`. In the `post` statement, increment `i` by `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the body of the loop, print out the value of `i`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close `main`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file, and in the new folder, run the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we used a variable that only exists in a `for` loop. We set
    up the variable, checked its value, modified it, and output it. Using a loop such
    as this is very common when working with ordered, numerically indexed collections
    such as arrays and slices. In this instance, we hardcoded the value for when to
    stop looping; however, when looking over arrays and slices, that value would be
    determined dynamically from the size of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll use a `for i` loop to work with a slice.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.09 – looping over arrays and slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we’ll loop over a collection of strings. We’ll be using a
    slice, but the loop logic will also be the same set of arrays. We’ll define a
    collection; we’ll then create a loop that uses the collection to control when
    to stop looping and a variable to keep track of where we are in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way the index of arrays and slices works means that there are never any
    gaps in the number, and the first number is always 0\. The built-in function,
    `len`, is used to get the length of any collection. We’ll use it as part of the
    condition to check when we’ve reached the end of the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a variable that is a slice of *strings* and initialize it with data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will cover `collection` and `string` in more detail in the next chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `initial` and `post` statements for the loop are the same as before; the
    difference is in the `condition` statement, where we use `len` to check whether
    we are at the end of the collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The rest is the same as before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file, and in the new folder, run the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we covered how to iterate over objects via indexing. Now,
    we will look at alternative ways of looping through objects using a `range` loop.
  prefs: []
  type: TYPE_NORMAL
- en: range loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `array` and `slice` types always have the number of an index, and that number
    always starts at `0`. The `for i` loop we’ve seen so far is the most common choice
    you’ll see in real-world code for these types.
  prefs: []
  type: TYPE_NORMAL
- en: The other collection type, `map`, doesn’t give the same guarantee. That means
    you need to use `range`. You’ll use `range` instead of the `condition` statement
    of a `for` loop, and, on each loop, `range` yields both a key and a value of an
    element in the collection, then moves on to the next element.
  prefs: []
  type: TYPE_NORMAL
- en: With a `range` loop, you don’t need to define a condition to stop the loop as
    `range` takes care of that for us.
  prefs: []
  type: TYPE_NORMAL
- en: Callout map order
  prefs: []
  type: TYPE_NORMAL
- en: The order of items is randomized to stop developers from relying on the order
    of the elements in a map, which means you can use it as a form of pseudo-data
    randomization if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.10 – looping over a map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to create a `map` type that has a string for
    its key and a string for the values. We’ll cover `map` types in more detail in
    a later chapter, so don’t worry if you don’t quite get what `map` types are yet.
    We’ll then use `range` in the `for` loop to iterate over the map. We’ll then write
    out the key and value data to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `map` type with a `string` key and a `string` value of the `strings`
    variable and initialize it with the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `range` to get the `key` and `value` variables for an array element and
    assign them to variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print out the `key` and `value` variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the loop and `main`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file, and in the new folder, run the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the expected output, displaying a map that has a string for
    its key and a string for the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we used `range` in a `for` loop to allow us to read out all
    the data from a `map` collection. `map` types don’t give guarantees like arrays
    and slices do about starting at zero and having no gaps had we used an integer
    for the map keys. `range` also controls when to stop a loop.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t need the `key` or the `value` variable, you can use `_` as the
    variable name to tell the compiler you don’t want it.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 2.01 – looping over map data using range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose you have been provided with the data in the following table. You have
    to find the word with the maximum count and print the word and its count using
    the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Word and count data to perform the activity](img/B18621_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Word and count data to perform the activity'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The preceding words are from the song *Never Gonna Give You Up*, sung by Rick
    Astley.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to solve the activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Put the words into a map like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a loop and use `range` to capture the word and the count.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep track of the word with the highest count using a variable for what the
    highest count is and its associated word.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the variables out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output, displaying the most popular word with
    its count value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter02/Activity02.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter02/Activity02.01)'
  prefs: []
  type: TYPE_NORMAL
- en: Activity 2.02 – implementing FizzBuzz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When interviewing for a programming job, you’ll be asked to do some coding exercises.
    These questions have you writing something from scratch and will have several
    rules to follow. To give you an idea of what that looks like, we’ll run you through
    a classic one, *FizzBuzz*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a program that prints out the numbers from 1 to 100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the number is a multiple of 3, print “Fizz”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the number is a multiple of 5, print “Buzz”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the number is a multiple of 3 and 5, print “FizzBuzz”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some tips:'
  prefs: []
  type: TYPE_NORMAL
- en: You can convert a number to a string using `strconv.Itoa()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first number to evaluate must be 1, and the last number to evaluate must
    be 100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These steps will help you to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a loop that does 100 iterations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have a variable that keeps count of the number of loops so far.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the loop, use that count and check whether it’s divisible by 3 or 5 using
    `%`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Think carefully about how you’ll deal with the “FizzBuzz” case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Considering that the output is too big to be displayed here, only a part of
    it will be visible in *Figure 2**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: The FizzBuzz output](img/B18621_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: The FizzBuzz output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter02/Activity02.02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter02/Activity02.02)'
  prefs: []
  type: TYPE_NORMAL
- en: This activity can show you how `switch` statements can improve upon and tame
    `if else` statements that start to get too big.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at how we can take manual control of a loop by skipping iterations
    or stopping the loop.
  prefs: []
  type: TYPE_NORMAL
- en: break and continue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are going to be times when you need to skip a single loop or stop a loop
    from running altogether. It’s possible to do this with variables and `if` statements,
    but there is an easier way.
  prefs: []
  type: TYPE_NORMAL
- en: The `continue` keyword stops the execution of the current loop and starts a
    new loop. The `post` loop logic runs, and the loop `condition` statement gets
    evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: The `break` keyword also stops the execution of the current loop and stops any
    new loops from running.
  prefs: []
  type: TYPE_NORMAL
- en: Use `continue` when you want to skip a single item in a collection; for instance,
    perhaps it’s okay if one of the items in a collection is invalid, but the rest
    may be okay to process. Use `break` when you need to stop processing when there
    are any errors in the data and there’s no value in processing the rest of the
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have an example that generates a random number between `0` and `8`.
    The loop skips on a number divisible by `3` and stops on a number divisible by
    `2`. It also prints out the `i` variable for each loop to help us see that `continue`
    and `break` are stopping the execution of the rest of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.11 – using break and continue to control loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll use `continue` and `break` in a loop to show you how
    you can take control of it. We’re going to create a loop that keeps going forever.
    This means we have to stop it with `break` manually. We’ll also randomly skip
    loops with `continue`. We’ll do this skipping by generating a random number, and
    if that number is divisible by 3, we’ll skip the rest of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an empty `for` loop. This will loop forever if you don’t stop it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `Intn` from the `rand` package to pick a random number between 0 and 8:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the random number is divisible by 3, print `"Skip"` and skip the rest of
    the loop using `continue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the random number is divisible by 2, then print `"Stop"` and stop the loop
    using `break`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the number is neither of those things, then print the number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the loop and `main`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file, and in the new folder, run the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the expected output displaying random numbers, `Skip`, and
    `Stop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we created a `for` loop that would loop forever, and we then
    used `continue` and `break` to override normal loop behavior to take control of
    it ourselves. The ability to do this can allow us to reduce the number of nested
    `if` statements and variables needed to prevent logic from running when it shouldn’t.
    Using `break` and `continue` helps to clean up your code and make it easier to
    work on.
  prefs: []
  type: TYPE_NORMAL
- en: If you use an empty `for` loop like this, the loop continues forever, and you
    must use `break` to prevent an infinite loop. An infinite loop is a loop in your
    code that never stops. Once you get an infinite loop, you’ll need a way to kill
    your application; how you do that will depend on your operating system. If you
    are running your app in a terminal, closing the terminal normally does the trick.
    Don’t panic – it happens to us all – your system may slow down, but it won’t do
    it any harm.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll work on some activities to test out all your new knowledge about
    logic and loops.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 2.03 – bubble sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we’ll sort a given slice of numbers by swapping the values.
    This sorting technique is known as the *bubble sort* technique. Go has built-in
    sorting algorithms in the `sort` package but we don’t want you to use them; we
    want you to use the logic and loops you’ve just learned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a slice with unsorted numbers in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print this slice to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort the values using swapping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, print the now sorted numbers to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And here are some tips:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do an in-place swap in Go like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can create a new slice with this code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can add to the end of a slice like so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter02/Activity02.03](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter02/Activity02.03)'
  prefs: []
  type: TYPE_NORMAL
- en: goto statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There may come a time when you want to skip certain logic within a function
    and go to a certain location within the function using the `goto` keyword. This
    may be accomplished using a label within the function and will result in a compilation
    error if attempting to use the `goto` label outside of the function scope.
  prefs: []
  type: TYPE_NORMAL
- en: '`goto` statements are a way of adapting the Go control flow; however, they
    need to be used with caution as they can lead to difficulties in understanding
    function control flow and decrease code readability if used improperly. `goto`
    statements are used within the Go standard library in some cases, such as the
    `math` package, to make logic easier to read and reduce the need for unnecessary
    variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2.12 – using goto statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll use `goto` in a function to show you how you can take
    control of it. We’re going to create a loop that keeps looping forever. This means
    we will have to stop it and exit manually under certain custom criteria. As with
    the previous exercise, we’ll be generating a random number, and if that number
    is divisible by 2, we’ll terminate the flow and go to our labeled statement:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an empty `for` loop. This will loop forever if you don’t stop it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `Intn` from the `rand` package to pick a random number between 0 and 8:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the random number is divisible by 3, print `"Skip"` and skip the rest of
    the loop using `continue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the random number is divisible by 2, then print `"Stop"` and stop the loop
    using the `goto` keyword with the `STOP` custom-defined label to go to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the number is neither of those things, then print the number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `goto` label named `STOP`, then print `"goto` `label reached"`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file, and in the new folder, run the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the expected output displaying random numbers, `Skip`, and
    `Stop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we created a `for` loop that would loop forever, and we then
    used `goto` to override normal loop behavior to take control of it ourselves and
    terminate the forever loop under certain criteria. The ability to do this can
    allow us to adapt a control flow to suit our needs. Using `goto` in the case of
    this example is not difficult to understand the change in function logic to “go
    to” other areas of the function logic; however, in more complicated examples,
    `goto` can lead to challenges with code readability.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll summarize what we have learned from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed logic and loops. These are the foundational building
    blocks to build complex software. They allow you to have data flow through your
    code. They let you deal with collections of data by letting you execute the same
    logic on every element of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to define the rules and laws of your code is the starting point of
    codifying the real world in software. If you are creating banking software and
    the bank has rules about what you can and can’t do with money, then you can also
    define those rules in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Logic and loops are essential tools that you’ll use to build all your software.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at Go’s type system and the core types it has
    available.
  prefs: []
  type: TYPE_NORMAL
