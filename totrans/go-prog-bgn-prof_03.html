<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer048">
			<h1 id="_idParaDest-96" class="chapter-number"><a id="_idTextAnchor568"/>3</h1>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor569"/> Core Types</h1>
			<p class="callout-heading"><a id="_idTextAnchor570"/>Overview</p>
			<p class="callout">This chapter aims to show you how to use Go’s basic core types to design your software’s data. We’ll work through each type to show what they are useful for and how to use them in your software. Understanding these core types provides you with the foundation required to learn how to create complex <span class="No-Break">data designs.</span></p>
			<p class="callout">By the end of this chapter, you will be able to create variables of different types for Go programs and assign values to variables of different types. You will learn how to identify and pick a suitable type for any programming situation. You will also write a program to measure password complexity and implement empty <span class="No-Break">value types.</span></p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor571"/>Technical requirements</h1>
			<p>For this chapter, you'll require Go version 1.21 or higher. The code for this chapter can be found <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter03"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter03</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor572"/><a id="_idTextAnchor573"/>Introduction</h1>
			<p>In the previous chapter, we learned how to use <strong class="source-inline">if</strong>, <strong class="source-inline">if</strong>-<strong class="source-inline">else</strong>, <strong class="source-inline">else-if</strong>, <strong class="source-inline">switch</strong>, <strong class="source-inline">case</strong>, <strong class="source-inline">continue</strong>, <strong class="source-inline">break</strong>, and <strong class="source-inline">goto</strong> <span class="No-Break">in Go.</span></p>
			<p>Go is a strongly typed language, and <a id="_idIndexMarker190"/>all data is assigned a type. That type is fixed and can’t be changed. What you can and can’t do with your data is constrained by the types you assign. Understanding exactly what defines every one of Go’s core types is critical to success with the <span class="No-Break">Go language.</span></p>
			<p>In later chapters, we’ll talk about Go’s more complex types, but those types are built on the core types defined in <span class="No-Break">this chapter.</span></p>
			<p>Go’s core types are well-thought-out and easy to understand once you understand the details. Having to understand the details means Go’s type system is not always intuitive. For example, Go’s most common number type, <strong class="source-inline">int</strong>, may be either 32 bits or 64 bits in size depending on the computer used to compile <span class="No-Break">the code.</span></p>
			<p>Types are needed to make data easier for humans to work with. Computers only think about data in binary. Binary is hard for people to work with. By adding a layer of abstraction to binary data and labelling it <a id="_idIndexMarker191"/>as a number or some text, humans have an easier time reasoning about it. Reducing the cognitive load allows people to build more complex software because they’re not overwhelmed by managing the details of the <span class="No-Break">binary data.</span></p>
			<p>Programming languages need to <a id="_idIndexMarker192"/>define what a number is or what a text is for. A programming language defines what you can call a number, and it defines what operations you can use on a number. For example, can a whole number such as 10 and a floating-point number such as 3.14 both be stored as the same type? While it seems obvious that you can multiply numbers, can you multiply text? As we progress through this chapter, we’ll clearly define what the rules are for each type and what operations you can use with each <span class="No-Break">of them.</span></p>
			<p>The way data is stored is also a large part of what defines a type. To allow for the building of efficient software, Go places limits on how large some of its types can be. For example, the largest amount of storage for a number in Go’s core types is 64 bits of memory. This allows for any number up to 18,446,744,073,709,551,615. Understanding these types of limitations is critical in building <span class="No-Break">bug-free code.</span></p>
			<p>The things that define a type are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>The kind of data that you can store <span class="No-Break">in it</span></li>
				<li>What operations you can use <span class="No-Break">with it</span></li>
				<li>What those operations do <span class="No-Break">to it</span></li>
				<li>How much memory it <span class="No-Break">can use</span></li>
			</ul>
			<p>This chapter gives you the knowledge and confidence to use Go’s type system correctly in <span class="No-Break">your cod<a id="_idTextAnchor574"/><a id="_idTextAnchor575"/>e.</span></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor576"/>True and false</h1>
			<p>True and false logic is represented using the Boolean type, <strong class="source-inline">bool</strong>. Use this type when you need an on/off switch in <a id="_idIndexMarker193"/>your code. The value of a <strong class="source-inline">bool</strong> instance can only ever be <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. The zero value of a <strong class="source-inline">bool</strong> instance is <strong class="source-inline">false</strong>. A “zero value” refers to the default value that a variable takes when it’s declared without an explicit <span class="No-Break">initial value.</span></p>
			<p>When using a comparison operator such as <strong class="source-inline">==</strong> or <strong class="source-inline">&gt;</strong>, the result of that comparison is a <span class="No-Break"><strong class="source-inline">bool</strong></span><span class="No-Break"> value.</span></p>
			<p>In this code example, we use comparison operators on two numbers. You’ll see that the result is a <span class="No-Break"><strong class="source-inline">bool</strong></span><span class="No-Break"> value:</span></p>
			<pre class="source-code">
package m<a id="_idTextAnchor577"/><a id="_idTextAnchor578"/>ain
import "fmt"
func main() {
  fmt.Println(10 &gt; 5)
  fmt.Println(10 == 5)
}</pre>			<p>Running the preceding code shows the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
true
fa<a id="_idTextAnchor579"/><a id="_idTextAnchor580"/>lse</pre>			<h2 id="_idParaDest-101"><a id="_idTextAnchor581"/>Exercise 3.01 – Program to measure password complexity</h2>
			<p>An online portal creates user accounts for its users and accepts passwords that are only 8 to 15 characters long. In this <a id="_idIndexMarker194"/>exercise, we write a program for the portal to display whether the password entered meets the character requirements. The character requirements are <span class="No-Break">as foll<a id="_idTextAnchor582"/><a id="_idTextAnchor583"/>ows:</span></p>
			<ul>
				<li>Have a <span class="No-Break">lowercase letter</span></li>
				<li>Have an <span class="No-Break">uppercase letter</span></li>
				<li>Have <span class="No-Break">a number</span></li>
				<li>Have <span class="No-Break">a symbol</span></li>
				<li>Be 8 or more <span class="No-Break">characters long</span></li>
			</ul>
			<p>To do this exercise, we’re going to use a few new features. Don’t worry if you don’t quite understand what they are doing; we’ll cover them in detail in the next chapter. Consider this a <a id="_idIndexMarker195"/>sneak peek. We’ll explain what everything is as we go, but your main focus should be on the <span class="No-Break">Boolean logic:</span></p>
			<ol>
				<li>Create a new folder and add a <span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break"> file.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the main package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Now add the imports we’ll use in <span class="No-Break">this file:</span><pre class="source-code">
import (
  "fmt"
  "unicode"
)</pre></li>				<li>Create a function that takes a string argument and returns a <span class="No-Break"><strong class="source-inline">bool</strong></span><span class="No-Break"> v<a id="_idTextAnchor584"/>alue:</span><pre class="source-code">
func passwordChecker(pw string) bool {</pre></li>				<li>Convert the password string into a <strong class="source-inline">rune</strong> type, which is safe for multi-byte (<span class="No-Break">UTF-8) charac<a id="_idTextAnchor585"/>ters:</span><pre class="source-code">
  pwR := []rune(pw)</pre><p class="list-inset">We’ll talk more about <strong class="source-inline">rune</strong> later in <span class="No-Break">this chapter.</span></p></li>				<li>Count the number of multi-byte characters using <strong class="source-inline">len</strong>. This code results in a <strong class="source-inline">bool</strong> result that can be used in the <span class="No-Break"><strong class="source-inline">if</strong></span><span class="No-Break"> state<a id="_idTextAnchor586"/><a id="_idTextAnchor587"/>ment:</span><pre class="source-code">
  if len(pwR) &lt; 8 {
    return false
  }</pre></li>				<li>Define some <strong class="source-inline">bool</strong> variables. We’ll check these at <span class="No-Break">the e<a id="_idTextAnchor588"/><a id="_idTextAnchor589"/>nd:</span><pre class="source-code">
  hasUpper := false
  hasLower := false
  hasNumber := false
  hasSymbol := false</pre></li>				<li>Loop over the<a id="_idIndexMarker196"/> multi-byte characters one at <span class="No-Break">a t<a id="_idTextAnchor590"/>ime:</span><pre class="source-code">
  for _, v := range pwR {</pre></li>				<li>Using the <strong class="source-inline">unicode</strong> package, check whether this character is uppercase. This function returns a <strong class="source-inline">bool</strong> value that we can use directly in the <span class="No-Break"><strong class="source-inline">if</strong></span><span class="No-Break"> statem<a id="_idTextAnchor591"/>ent:</span><pre class="source-code">
   if unicode.IsUpper(v) {</pre></li>				<li>If it is, we’ll set the <strong class="source-inline">hasUpper</strong> <strong class="source-inline">bool</strong> variable <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">tru<a id="_idTextAnchor592"/>e</strong></span><span class="No-Break">:</span><pre class="source-code">
     hasUpper = true
   }</pre></li>				<li>Do the same thing for <span class="No-Break">lowercase le<a id="_idTextAnchor593"/><a id="_idTextAnchor594"/>tters:</span><pre class="source-code">
   if unicode.IsLower(v) {
     hasLower = true
   }</pre></li>				<li>Also do it <span class="No-Break">for nu<a id="_idTextAnchor595"/><a id="_idTextAnchor596"/>mbers:</span><pre class="source-code">
   if unicode.IsNumber(v) {
     hasNumber = true
   }</pre></li>				<li>For symbols, we’ll also accept punctuation. Use the <strong class="source-inline">or</strong> operator, which works with Booleans, to result in <strong class="source-inline">true</strong> if either of these functions <span class="No-Break">returns<a id="_idTextAnchor597"/><a id="_idTextAnchor598"/> </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">:</span><pre class="source-code">
   if unicode.IsPunct(v) || unicode.IsSymbol(v) {
     hasSymbol = true
   }
  }</pre></li>				<li>To pass all our checks, all our variables must be <strong class="source-inline">true</strong>. Here, we combine multiple <strong class="source-inline">and</strong> operators<a id="_idIndexMarker197"/> to create a one-line statement that checks all <span class="No-Break">four var<a id="_idTextAnchor599"/>iables:</span><pre class="source-code">
  return hasUpper &amp;&amp; hasLower &amp;&amp; hasNumber &amp;&amp; hasSymbol</pre></li>				<li>Close <span class="No-Break">the function:</span><pre class="source-code">
}</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Call the <strong class="source-inline">passwordChecker()</strong> function with an invalid password. As this returns a <strong class="source-inline">bool</strong> value, it can be used directly in an <span class="No-Break"><strong class="source-inline">if</strong></span><span class="No-Break"> sta<a id="_idTextAnchor600"/><a id="_idTextAnchor601"/>tement:</span><pre class="source-code">
  if passwordChecker("") {
    fmt.Println("password good")
  } else {
    fmt.Println("password bad")
  }</pre></li>				<li>Now, call the function with a <span class="No-Break">valid password:</span><pre class="source-code">
  if passwor<a id="_idTextAnchor602"/>dC<a id="_idTextAnchor603"/>hecker("This!I5A") {
    fmt.Println("password good")
  } else {
    fmt.Println("password bad")
  }</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>				<li>Save the file in the new <a id="_idIndexMarker198"/>folder and then run <span class="No-Break">the following:</span><pre class="source-code">
go run main.go</pre></li>			</ol>
			<p>Running the preceding code displays the <span class="No-Break">following output:</span></p>
			<pre class="console">
password bad
password good</pre>			<p>In this exercise, we highlighted a variety of ways that <strong class="source-inline">bool</strong> values manifest themselves in the code. <strong class="source-inline">bool</strong> values are critical to giving your code the ability to make a choice and be dynamic and responsive. Without <strong class="source-inline">bool</strong>, your code would have a hard time <span class="No-Break">doing anything.</span></p>
			<p>Next, we’ll take a look at numbers and how Go <span class="No-Break">categoriz<a id="_idTextAnchor604"/><a id="_idTextAnchor605"/>es them.</span></p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor606"/>Numbers</h1>
			<p>Go has two distinct <a id="_idIndexMarker199"/>number types – integers, also known as whole numbers and floating-point numbers. The floating-point number type allows whole numbers and numbers that contain fractions of a <span class="No-Break">whole number.</span></p>
			<p>1, 54, and 5,436 are examples of whole numbers. 1.5, 52.25, 33.333, and 64,567.00001 are all examples of <span class="No-Break">floating-point numbers.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The default and empty value for all number types <span class="No-Break">is 0.</span></p>
			<p>Next, we’ll start our number journey by looking <span class="No-Break">at <a id="_idTextAnchor607"/><a id="_idTextAnchor608"/>integers.</span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor609"/>Integers</h2>
			<p>Integer types are<a id="_idIndexMarker200"/> classified in two ways, based on the <span class="No-Break">following conditions:</span></p>
			<ul>
				<li>Whether or not they can store <span class="No-Break">negative numbers</span></li>
				<li>The smallest and largest numbers they <span class="No-Break">can store</span></li>
			</ul>
			<p>Types that <a id="_idIndexMarker201"/>can store negative<a id="_idIndexMarker202"/> numbers are called signed integers. Types that can’t store negative numbers are called unsigned integers. How big and small a number <a id="_idIndexMarker203"/>each type can store is determined by how many bytes of internal storage <span class="No-Break">they have.</span></p>
			<p>Here is an excerpt from the Go language specification with all the relevant <span class="No-Break">in<a id="_idTextAnchor610"/>teger types:</span></p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B18621_03_1.jpg" alt="Figure 3.1: Go language specification with relevant integer types" width="1138" height="506"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: Go language specification with relevant integer types</p>
			<p>There are also the following special <span class="No-Break">int<a id="_idTextAnchor611"/>eger types:</span></p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B18621_03_2.jpg" alt="Figure 3.2: Special integer types" width="588" height="149"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2: Special integer types</p>
			<p><strong class="source-inline">uint</strong> and <strong class="source-inline">int</strong> are either 32 or 64 bits, depending on whether you compile your code for a 32-bit system or a 64-bit system. It’s rare nowadays to run applications on a 32-bit system, as most systems nowadays <span class="No-Break">are 64-bit.</span></p>
			<p>An <strong class="source-inline">int</strong> type on a 64-bit system is not an <strong class="source-inline">int64</strong> type. While these two types are identical, they are not the same integer type, and you can’t use them together. If Go allowed this, there would be problems when the same code gets compiled for a 32-bit machine, so keeping them separate ensures that the code <span class="No-Break">is reliable.</span></p>
			<p>This incompatibility is not just an <strong class="source-inline">int</strong> type problem; you can’t use any of the integer <span class="No-Break">types together.</span></p>
			<p>Picking the correct integer<a id="_idIndexMarker204"/> type to use when defining a variable is easy – use <strong class="source-inline">int</strong>. When writing code for an application, <strong class="source-inline">int</strong> does the job the majority of the time. Only think about using the other types when using an <strong class="source-inline">int</strong> type is causing a problem. The sorts of problems you see with <strong class="source-inline">int</strong> tend to be related to <span class="No-Break">memory usage.</span></p>
			<p>For example, let’s say you have an app that’s running out of memory. The app uses a massive number of integers, but these integers are never negative and won’t go over 255. One possible fix is to switch from using <strong class="source-inline">int</strong> to using <strong class="source-inline">uint8</strong>. Doing this cuts its memory usage from 64 bits (8 bytes) per number to 8 bits (1 byte) <span class="No-Break">per number.</span></p>
			<p>We can show this by creating a collection of both types and then asking Go how much heap memory it is using. The output may vary on your computer, but the effect should be similar. This code creates a collection of <strong class="source-inline">int</strong> or <strong class="source-inline">int8</strong> numbers. It then adds 10 million values to the collection. Once that’s done, it uses the runtime package to give us a reading of how much heap memory is being used. We can convert that reading to MB and then p<a id="_idTextAnchor612"/><a id="_idTextAnchor613"/>rint <span class="No-Break">it out:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
  "runtime"
)
func main() {
  var list []int
  //var list []int8
  for i := 0; i &lt; 10000000; i++ {
    list = append(list, 100)
  }
  var m runtime.MemStats
  runtime.ReadMemStats(&amp;m)
  fmt.Printf("TotalAlloc (Heap) = %v MiB\n", m.TotalAlloc/1024/1024)
}</pre>			<p>Here’s the output <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
TotalAlloc (Heap) = 403 MiB</pre>			<p>And here’s the output <a id="_idIndexMarker205"/><span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">int8</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
TotalAlloc (Heap) = 54 MiB</pre>			<p>We saved a good amount of memory here, but we need 10 million values to make it worthwhile. Hopefully, now you are convinced that it’s okay to start with <strong class="source-inline">int</strong> and only worry about performance when it’s <span class="No-Break">a problem.</span></p>
			<p>Next, we’ll look at <span class="No-Break">floating-p<a id="_idTextAnchor614"/><a id="_idTextAnchor615"/>oint numbers.</span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor616"/>Floating-point numbers</h2>
			<p>Go has two <a id="_idIndexMarker206"/>floating-point number types, <strong class="source-inline">float32</strong> and <strong class="source-inline">float64</strong>. The bigger <strong class="source-inline">float64</strong> allows for more precision in numbers. <strong class="source-inline">float32</strong> has 32 bits of storage and <strong class="source-inline">float64</strong> has 64 bits of storage. Floats split their storage between whole numbers (everything to the left of the decimal point) and decimal numbers (everything to the<a id="_idIndexMarker207"/> right of the decimal point). How much space is used for the whole number or the decimal numbers varies according to the number being stored. For example, 9,999.9 would use more storage for the whole numbers, while 9.9999 would use more storage for the decimal numbers. With <strong class="source-inline">float64</strong>’s bigger space for storage, it can store more whole numbers and/or more decimal numbers th<a id="_idTextAnchor617"/><a id="_idTextAnchor618"/>an <span class="No-Break"><strong class="source-inline">float32</strong></span><span class="No-Break"> can.</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor619"/>Exercise 3.02 – Floating-point number accuracy</h2>
			<p>In this exercise, we’re going to compare what happens when we do some divisions on numbers that don’t divide<a id="_idIndexMarker208"/> equally. We’ll be dividing 100 by 3. One way of representing the result is 33 ⅓. Computers, for the most part, can’t compute fractions like this. Instead, they use a decimal representation, which is 33.3 recurring, where the 3 after the decimal point repeats forever. If we let the computer do that it uses up all the memory, which is not <span class="No-Break">very helpful.</span></p>
			<p>Luckily for us, we don’t need to worry about this happening as the floating-point types have storage limits. The downside is that this leads to a number that doesn’t reflect the true result; the result has a certain amount of inaccuracy. Your tolerance for inaccuracy needs and how much storage space you want to give to your floating-point numbers must be <span class="No-Break">balanced out:</span></p>
			<ol>
				<li>Create a new folder and add a <span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break"> file.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the main package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Now add the imports we’ll use in <span class="No-Break">this file:</span><pre class="source-code">
import "fmt"</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Declare an <strong class="source-inline">int</strong> variable and initialize it with<a id="_idTextAnchor620"/> a value <span class="No-Break">of 100:</span><pre class="source-code">
  var a int = 100</pre></li>				<li>Declare a <strong class="source-inline">float32</strong> variable and initialize it with<a id="_idTextAnchor621"/> a value <span class="No-Break">of 100:</span><pre class="source-code">
  var b float32 = 100</pre></li>				<li>Declare a <strong class="source-inline">float64</strong> variable and initialize it with<a id="_idTextAnchor622"/> a value <span class="No-Break">of 100:</span><pre class="source-code">
  var c float64 = 100</pre></li>				<li>Divide each variable by 3 and print the result<a id="_idTextAnchor623"/><a id="_idTextAnchor624"/> to <span class="No-Break">the console:</span><pre class="source-code">
  fmt.Println(a / 3)
  fmt.Println(b / 3)
  fmt.Println(c / 3)
}</pre></li>				<li>Save the file and in the new folder run <span class="No-Break">the following:</span><pre class="source-code">
go run main.go</pre></li>			</ol>
			<p>Running the<a id="_idIndexMarker209"/> preceding code shows the following output displaying <strong class="source-inline">int</strong>-, <strong class="source-inline">float32</strong>-, and <strong class="source-inline">float64</strong>-typed equivalent starting values, divided <span class="No-Break">by 3:</span></p>
			<pre class="console">
33
33.333332
33.333333333333336</pre>			<p>In this exercise, we can see that the computer is not able to give perfect answers to this sort of division. You can also see that when doing this sort of math on integers, you don’t get an error. Go ignores any fractional part of the number, which is usually not what you want. We can also see that <strong class="source-inline">float64</strong> gives a much more precise answer <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">float32</strong></span><span class="No-Break">.</span></p>
			<p>While this limit seems like it would lead to inaccuracy, for real-world business work, it gets the job done well enough the vast majority of the time. Use cases that involve highly precise counts, such as in finance and banking, require you to pay special attention to Go’s numerical types to ensure <span class="No-Break">mathematical accuracy.</span></p>
			<p>Let’s see what happens if we try to get our number back to 100 by multiplying it <span class="No-Break">by 3:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  var a int = 100
  var b float32 = 100
  va<a id="_idTextAnchor625"/><a id="_idTextAnchor626"/>r c float64 = 100
  fmt.Println((a / 3) * 3)
  fmt.Println((b / 3) * 3)
  fmt.Println((c / 3) * 3)
}</pre>			<p>Running the preceding code shows the <span class="No-Break">following output:</span></p>
			<pre class="console">
99
100
100</pre>			<p>In this example, we saw that accuracy is not impacted as much as you’d expect. At first glance, floating-point math can seem simple, but it quickly gets complicated. When defining your floating-point variables, typically <strong class="source-inline">float64</strong> should be your first choice, unless you need to be more <span class="No-Break">memory efficient.</span></p>
			<p>Next, we’ll look at <a id="_idIndexMarker210"/>what happens when you go beyond the limits<a id="_idTextAnchor627"/><a id="_idTextAnchor628"/> of a <span class="No-Break">number type.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor629"/>Overflow and wraparound</h2>
			<p>When you try to initialize a number with a value that’s too big for the type you are using, you get an overflow error. The <a id="_idIndexMarker211"/>highest number you can have in an <strong class="source-inline">int8</strong> type is <a id="_idIndexMarker212"/>127. In the following code, we’ll try to initialize it with 128 <a id="_idTextAnchor630"/><a id="_idTextAnchor631"/>to see <span class="No-Break">what happens:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  var a int8 = 128
  fmt.Println(a)
}</pre>			<p>Running the preceding code gives th<a id="_idTextAnchor632"/>e <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B18621_03_3.jpg" alt="Figure 3.3: Output after initializing with 128" width="1293" height="157"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: Output after initializing with 128</p>
			<p>This error is easy to fix and can’t cause any hidden problems. The real problem is when the compiler can’t catch it. When this happens, the number will “wraparound.” Wraparound means the<a id="_idIndexMarker213"/> number goes from its highest possible value to its lowest possible value. Wraparound can be easy to miss when developing your code and can cause significant<a id="_idIndexMarker214"/> pro<a id="_idTextAnchor633"/><a id="_idTextAnchor634"/>blems for <span class="No-Break">your users.</span></p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor635"/>Exercise 3.03 – Triggering number wraparound</h2>
			<p>In this exercise, we’ll declare two small integer types – <strong class="source-inline">int8</strong> and <strong class="source-inline">uint8</strong>. We’ll initialize them near their highest possible value. Then <a id="_idIndexMarker215"/>we’ll use a loop statement to increment them by 1 per loop, then print their value to the console. We’ll be able to see exactly when <span class="No-Break">they wraparound:</span></p>
			<ol>
				<li>Create a new folder and add a <span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break"> file.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the main package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Now add the imports we’ll use in <span class="No-Break">this file:</span><pre class="source-code">
import "fmt"</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Declare an <strong class="source-inline">int8</strong> variable with an<a id="_idTextAnchor636"/> initial value <span class="No-Break">of 125:</span><pre class="source-code">
  var a int8 = 125</pre></li>				<li>Declare an <strong class="source-inline">uint8</strong> variable with an i<a id="_idTextAnchor637"/>nitial value <span class="No-Break">of 253:</span><pre class="source-code">
  var b uint8 = 253</pre></li>				<li>Create a <strong class="source-inline">for i</strong> loop<a id="_idTextAnchor638"/> that runs <span class="No-Break">five times:</span><pre class="source-code">
  for i := 0; i &lt; 5; i++ {</pre></li>				<li>Increment t<a id="_idTextAnchor639"/><a id="_idTextAnchor640"/>he two variables <span class="No-Break">by 1:</span><pre class="source-code">
    a++
    b++</pre></li>				<li>Print the variables’ <a id="_idIndexMarker216"/>v<a id="_idTextAnchor641"/>alues to <span class="No-Break">the console:</span><pre class="source-code">
    fmt.Println(i, ")", "int8 ", a, "uint8 ", b)</pre></li>				<li>Close <span class="No-Break">the loop:</span><pre class="source-code">
  }</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>				<li>Save the file, and, in <a id="_idIndexMarker217"/>the new folder, run <span class="No-Break">the following:</span><pre class="source-code">
go run main.go</pre><p class="list-inset">Running the preceding code show<a id="_idTextAnchor642"/>s the <span class="No-Break">following output:</span></p></li>			</ol>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B18621_03_4.jpg" alt="Figure 3.4: Output after wraparound" width="1237" height="286"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4: Output after wraparound</p>
			<p>In this exercise, we saw that, for signed integers, you’d end up with a negative number while unsigned integers wrap around to 0. You must always consider the maximum possible value for your variable and be sure to have the appropriate type to support <span class="No-Break">that number.</span></p>
			<p>Next, we’ll look at what you can do when you need a number that’s bigger than the c<a id="_idTextAnchor643"/><a id="_idTextAnchor644"/>ore types can <span class="No-Break">give you.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor645"/>Big numbers</h2>
			<p>If you need a number higher or lower than <strong class="source-inline">int64</strong> or <strong class="source-inline">uint64</strong> can store, you can use the <strong class="source-inline">math/big</strong> package. This<a id="_idIndexMarker218"/> package feels a little awkward to use compared to <a id="_idIndexMarker219"/>dealing with integer types, but you’ll be able to do everything you can generally do wit<a id="_idTextAnchor646"/><a id="_idTextAnchor647"/>h integers using <span class="No-Break">its API.</span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor648"/>Exercise 3.04 – Big numbers</h2>
			<p>In this exercise, we’re going to create a number that’s larger than Go’s core number types can store. To demonstrate this, we’ll use an addition operation. We’ll also do the same to an <strong class="source-inline">int</strong> variable to show the difference. Then, we’ll print the result to <span class="No-Break">the console:</span></p>
			<ol>
				<li>Create a new folder and add a <span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break"> file.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the main package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Now add the imports we’ll use in <span class="No-Break">this file:</span><pre class="source-code">
import (
  "fmt"
  "math"
  "math/big"
)</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Declare an <strong class="source-inline">int</strong> variable and initialize it with <strong class="source-inline">math.MaxInt64</strong>, which is the highest possible value for an <strong class="source-inline">int64</strong> variable in Go and <a id="_idTextAnchor649"/>is defined as <span class="No-Break">a constant:</span><pre class="source-code">
  intA := ma<a id="_idTextAnchor650"/>th.MaxInt64</pre></li>				<li>Add 1 <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break">:</span><pre class="source-code">
  intA = intA + 1</pre></li>				<li>Now we’ll create a <strong class="source-inline">big</strong> <strong class="source-inline">int</strong> variable. This is a custom type and is not based on Go’s <strong class="source-inline">int</strong> type. We’ll also initialize it with Go’s highest<a id="_idTextAnchor651"/> possible <span class="No-Break">number value:</span><pre class="source-code">
  bigA := big.NewInt(math.MaxInt64)</pre></li>				<li>We’ll add 1 to our <strong class="source-inline">big</strong> <strong class="source-inline">int</strong>. You can see <a id="_idTextAnchor652"/>that this <span class="No-Break">feels clumsy:</span><pre class="source-code">
  bigA.Add(bigA, big.NewInt(1))</pre></li>				<li>Print out the max <strong class="source-inline">int</strong> size and the values for ou<a id="_idTextAnchor653"/><a id="_idTextAnchor654"/>r Go <strong class="source-inline">int</strong> and our <span class="No-Break"><strong class="source-inline">big</strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break">:</span><pre class="source-code">
  fmt.Println("MaxInt64: ", math.MaxInt64)
  fmt.Println("Int   :", intA)
  fmt.Println("Big Int : ", bigA.String())</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>				<li>Save the file, and in the <a id="_idIndexMarker220"/>new folder run <span class="No-Break">the following:</span><pre class="source-code">
go run main.go</pre><p class="list-inset">Running the preceding code displ<a id="_idTextAnchor655"/>ays the <span class="No-Break">following output:</span></p></li>			</ol>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B18621_03_5.jpg" alt="Figure 3.5: Output displaying large numbers with Go’s number types" width="1285" height="204"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5: Output displaying large numbers with Go’s number types</p>
			<p>In this exercise, we saw that while <strong class="source-inline">int</strong> has wrapped around, <strong class="source-inline">big.Int</strong> has added the <span class="No-Break">number correctly.</span></p>
			<p>If you have a situation where you have a number whose value is higher than Go can manage, then the <strong class="source-inline">big</strong> package from the standard library is what you need. Next, we’ll look at a special Go number type us<a id="_idTextAnchor656"/><a id="_idTextAnchor657"/>ed to represent <span class="No-Break">raw data.</span></p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor658"/>byte</h1>
			<p>The <strong class="source-inline">byte</strong> type in Go is just an alias for <strong class="source-inline">uint8</strong>, which is a number that has eight bits of storage. In reality, <strong class="source-inline">byte</strong> is a significant type, and you’ll see it in lots of places. A bit is a single binary value – a single on/off switch. Grouping bits into groups of eight was a common standard in early <a id="_idIndexMarker221"/>computing and became a near-universal way to encode data. 8-bits have 256 possible combinations of “off” and “on,” so <strong class="source-inline">uint8</strong> has 256 possible integer values from 0 to 255. All combinations of on and off can are represented with <span class="No-Break">this type.</span></p>
			<p>You’ll see <strong class="source-inline">byte</strong> used when reading and writing data to and from a network connection and when reading and writing data <span class="No-Break">to files.</span></p>
			<p>With this, we’re all done with numbers. Now, let’s look at how G<a id="_idTextAnchor659"/><a id="_idTextAnchor660"/>o stores and <span class="No-Break">manages text.</span></p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor661"/>Text</h1>
			<p>Go uses a single <strong class="source-inline">string</strong> type to <span class="No-Break">represent text.</span></p>
			<p>When you write text to a <strong class="source-inline">string</strong> variable it’s called a string literal. There are two kinds of string<a id="_idIndexMarker222"/> literals <span class="No-Break">in Go:</span></p>
			<ul>
				<li>Raw – defined by wrapping text in a pair <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">`</strong></span></li>
				<li>Interpreted – defined by surrounding the text in a pair <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">"</strong></span></li>
			</ul>
			<p>With raw literals, what ends up in your variable is precisely the text that you see on the screen. With interpreted literals, Go scans what you’ve written and then applies transformations based on its own set <span class="No-Break">of rules.</span></p>
			<p>H<a id="_idTextAnchor662"/><a id="_idTextAnchor663"/>ere’s what that <span class="No-Break">looks like:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  comment1 := `This is the BEST
thing ever!`
  comment2 := `This is the BEST\nthing ever!`
  comment3 := "This is the BEST\nthing ever!"
  fmt.Print(comment1, "\n\n")
  fmt.Print(comment2, "\n\n")
  fmt.Print(comment3, "\n")
}</pre>			<p>Running the preceding <a id="_idIndexMarker223"/>code <a id="_idTextAnchor664"/>gives the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B18621_03_6.jpg" alt="Figure 3.6: Output from printing text" width="1238" height="387"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6: Output from printing text</p>
			<p>In an interpreted string, <strong class="source-inline">\n</strong> represents a new line. In our raw string, <strong class="source-inline">\n</strong> doesn’t do anything to our formatting and is printed out just as we typed it. To get a new line in the raw string, we must add an actual new line to our raw literal. The interpreted string must use <strong class="source-inline">\n</strong> to get a new line, as adding a real new line to an interpreted string is <span class="No-Break">not allowed.</span></p>
			<p>While there are a lot of things you can do with an interpreted string literal, in real-world code, the two you’ll see<a id="_idIndexMarker224"/> most commonly are <strong class="source-inline">\n</strong> for a new line and, occasionally, <strong class="source-inline">\t</strong> for <span class="No-Break">a tab.</span></p>
			<p>Interpreted string literals are the most common kind in real-world code, but raw literals have their place. If you want to copy and paste text that contains a lot of new lines, or <strong class="source-inline">"</strong> or <strong class="source-inline">\</strong> characters, it’s easier to use <span class="No-Break">raw literals.</span></p>
			<p>In the following example, you can see how using raw literals m<a id="_idTextAnchor665"/><a id="_idTextAnchor666"/>akes the code <span class="No-Break">more readable:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  comment1 := `In "Windows" the user directory is "C:\Users\"`
  comment2 := "In \"Windows\" the user directory is \"C:\\Users\\\""
  fmt.Println(comment1)
  fmt.Println(comment2)
}</pre>			<p>Running the preceding code<a id="_idIndexMarker225"/> di<a id="_idTextAnchor667"/>splays the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B18621_03_7.jpg" alt="Figure 3.7: Output from more readable code" width="1277" height="153"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7: Output from more readable code</p>
			<p>One thing you can’t have in a raw literal is a <strong class="source-inline">`</strong> character. If you need a literal with <strong class="source-inline">`</strong> in it, you must use an interpreted <span class="No-Break">string literal.</span></p>
			<p>String literals are just ways of getting text into a <strong class="source-inline">string</strong> variable. Once you have the value in the variable, there are <span class="No-Break">no differences.</span></p>
			<p>Next, we’ll look at how to work saf<a id="_idTextAnchor668"/><a id="_idTextAnchor669"/>ely with <span class="No-Break">multi-byte strings.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor670"/>Rune</h2>
			<p><strong class="source-inline">rune</strong> is a type with<a id="_idIndexMarker226"/> enough storage to store a single UTF-8 multi-byte character. String literals<a id="_idIndexMarker227"/> are encoded using UTF-8. UTF-8 is a massively popular and common multi-byte text encoding standard. The <strong class="source-inline">string</strong> type itself is not limited to UTF-8, as Go also needs to support other text encoding types. <strong class="source-inline">string</strong> not being limited to UTF-8 means there is often an extra step you need to take when working with your strings to <span class="No-Break">prevent bugs.</span></p>
			<p>The different encodings use a different number of bytes to encode text. Legacy standards use one byte to encode a single character. UTF-8 uses up to four bytes to encode a single character. When text is in the <strong class="source-inline">string</strong> type, to allow for this variability, Go stores all strings as a <strong class="source-inline">byte</strong> collection. To be able to safely perform operations with text of any kind of encoding, single- or multi-byte, it should be converted from a <strong class="source-inline">byte</strong> collection <a id="_idIndexMarker228"/>to a <span class="No-Break"><strong class="source-inline">rune</strong></span><span class="No-Break"> collection.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you don’t know the encoding of the text, it’s usually safe to convert it to UTF-8. Also, UTF-8 is backward-compatible with single-byte <span class="No-Break">encoded text.</span></p>
			<p>Go makes it easy to access <a id="_idIndexMarker229"/>the individual bytes of a string, as shown in the <span class="No-Break">following example:</span></p>
			<ol>
				<li>First, we define the package, import our needed libraries,<a id="_idTextAnchor671"/><a id="_idTextAnchor672"/> and create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
package main
import "fmt"
func main() {</pre></li>				<li>We’ll create a string that <a id="_idTextAnchor673"/>contains a <span class="No-Break">multi-byte character:</span><pre class="source-code">
  username := "Sir_King_Über"</pre></li>				<li>We are going to use a <strong class="source-inline">for i</strong> loop to pr<a id="_idTextAnchor674"/>int out each byte of <span class="No-Break">our string:</span><pre class="source-code">
  for <a id="_idTextAnchor675"/><a id="_idTextAnchor676"/>i := 0; i &lt; len(username); i++ {
    fmt.Print(username[i], " ")
  }</pre></li>				<li>Then we will close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>			</ol>
			<p>Running the preceding c<a id="_idTextAnchor677"/>ode gives the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B18621_03_8.jpg" alt="Figure 3.8: Output displaying bytes according to input length" width="1253" height="97"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8: Output displaying bytes according to input length</p>
			<p>The numbers printed out are the byte values of the string. There are only 13 letters in our string. However, it contained a multi-byte character, so we printed out 14 <span class="No-Break">byte values.</span></p>
			<p>Let’s convert our bytes<a id="_idIndexMarker230"/> back into strings. This conversion uses type conversion, which<a id="_idIndexMarker231"/> we’ll cover in <span class="No-Break">detail soon:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main(<a id="_idTextAnchor678"/><a id="_idTextAnchor679"/>) {
  username := "Sir_King_Über"
  for i := 0; i &lt; len(username); i++ {
    fmt.Print(string(username[i]), " ")
  }
}</pre>			<p>Running the preceding <a id="_idTextAnchor680"/>code gives the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B18621_03_9.jpg" alt="Figure 3.9: Output displaying bytes converted to strings" width="1253" height="105"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9: Output displaying bytes converted to strings</p>
			<p>The output is as expected until we get to the <strong class="source-inline">Ü</strong> character. That’s because <strong class="source-inline">Ü</strong> was encoded using more than one byte, and each byte on its own no longer <span class="No-Break">makes sense.</span></p>
			<p>To safely work with individual characters of a multi-byte string, you first must convert the string slice of <strong class="source-inline">byte</strong> types to a slice of <span class="No-Break"><strong class="source-inline">rune</strong></span><span class="No-Break"> types.</span></p>
			<p>Consider the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main()<a id="_idTextAnchor681"/><a id="_idTextAnchor682"/> {
  username := "Sir_King_Über"
  runes := []rune(username)
  for i := 0; i &lt; len(runes); i++ {
    fmt.Print(string(runes[i]), " ")
  }
}</pre>			<p>Running the preceding c<a id="_idTextAnchor683"/>ode gives the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B18621_03_10.jpg" alt="Figure 3.10: Output displaying strings" width="1301" height="111"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10: Output displaying strings</p>
			<p>If we wish to work<a id="_idIndexMarker232"/> with each character in a loop like this, then using <strong class="source-inline">range</strong> would be a better choice. When using <strong class="source-inline">range</strong>, instead of moving one <strong class="source-inline">byte</strong> at a time, it moves<a id="_idIndexMarker233"/> along the string one <strong class="source-inline">rune</strong> at a time. The index is the byte offse<a id="_idTextAnchor684"/><a id="_idTextAnchor685"/>t, and the value is a <span class="No-Break"><strong class="source-inline">rune</strong></span><span class="No-Break"> value.</span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor686"/>Exercise 3.05 – Safely looping over a string</h2>
			<p>In this exercise, we’ll declare a string and initialize it with a multi-byte string value. We’ll then loop over the<a id="_idIndexMarker234"/> string using <strong class="source-inline">range</strong> to give us each character, one at a time. We’ll then print out the byte index and the character to <span class="No-Break">the console:</span></p>
			<ol>
				<li>Create a new folder and add a <span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break"> file.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the main package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Now add the imports we’ll use in <span class="No-Break">this file:</span><pre class="source-code">
import "fmt"</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Declare a <strong class="source-inline">string</strong> variab<a id="_idTextAnchor687"/>le with a multi-byte <span class="No-Break">string value:</span><pre class="source-code">
  logLevel := "デバッグ"</pre></li>				<li>Create a <strong class="source-inline">range</strong> loop that loops over the string, then captu<a id="_idTextAnchor688"/>re <strong class="source-inline">index</strong> and <strong class="source-inline">rune</strong> in <span class="No-Break">the variable:</span><pre class="source-code">
  for index, runeVal := range logLevel {</pre></li>				<li>Print <strong class="source-inline">index</strong> and <strong class="source-inline">rune</strong> to the cons<a id="_idTextAnchor689"/>ole, casting the rune to <span class="No-Break">a string:</span><pre class="source-code">
    fmt.Println(index, string(runeVal))</pre></li>				<li>Close <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker235"/></span><span class="No-Break"> loop:</span><pre class="source-code">
  }</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>				<li>Save the file and in the new folder run <span class="No-Break">the following:</span><pre class="source-code">
go run main.go</pre></li>			</ol>
			<p>Running the precedin<a id="_idTextAnchor690"/>g code gives the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B18621_03_11.jpg" alt="Figure 3.11: Output after safely looping over a string" width="1258" height="242"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11: Output after safely looping over a string</p>
			<p>In this exercise, we demonstrated that looping over a string in a safe, multi-byte way is baked right into the language. Using this method prevents you from getting invalid <span class="No-Break">string data.</span></p>
			<p>Another common way to find bugs is to check how many characters a string has by using <strong class="source-inline">len</strong> directly on it. Here is an example of how mul<a id="_idTextAnchor691"/><a id="_idTextAnchor692"/>ti-byte strings can <span class="No-Break">be mishandled:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  username := "Sir_King_Über"
  // Length of a string
  fmt.Println("Bytes:", len(username))
  fmt.Println("Runes:", len([]rune(username)))
  // Limit to 10 characters
  fmt.Println(string(username[:10]))
  fmt.Println(string([]rune(username)[:10]))
}</pre>			<p>Running the preceding<a id="_idTextAnchor693"/> <a id="_idIndexMarker236"/>code gives the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B18621_03_12.jpg" alt="Figure 3.12: Output displaying bugs after using the len function" width="1333" height="263"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12: Output displaying bugs after using the len function</p>
			<p>You can see that when using <strong class="source-inline">len</strong> directly on a string, you get the wrong answer. Checking the length of data input using <strong class="source-inline">len</strong> in this way would end up with invalid data. For example, if we needed the input to be exactly eight characters long and somebody entered a multi-byte character, using <strong class="source-inline">len</strong> directly on that input would allow them to enter less than <span class="No-Break">eight characters.</span></p>
			<p>When working with strings, be sure to check the <strong class="source-inline">strings</strong> package first. It’s filled with useful tools that may already do what <span class="No-Break">you need.</span></p>
			<p>Next, let’s take a clo<a id="_idTextAnchor694"/><a id="_idTextAnchor695"/>se look at Go<a id="_idTextAnchor696"/>’s special <span class="No-Break"><strong class="source-inline">nil</strong></span><span class="No-Break"> value.</span></p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor697"/>The nil value</h1>
			<p><strong class="source-inline">nil</strong> is not a type but a special <a id="_idIndexMarker237"/>value in Go. It represents an empty value of no type. When working with pointers, maps, and interfaces (we’ll cover these in the next chapter), you need to be sure they are not <strong class="source-inline">nil</strong>. If you try to interact with a <strong class="source-inline">nil</strong> value, your code <span class="No-Break">will crash.</span></p>
			<p>If you can’t be sure whether a value is <strong class="source-inline">nil</strong> <a id="_idTextAnchor698"/><a id="_idTextAnchor699"/><a id="_idTextAnchor700"/>or not, you can check it <span class="No-Break">like this:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  var message [] string
  if message == nil {
    fmt.Println("error, unexpected nil value")
    return
  }
  fmt.Println(message)
}</pre>			<p>Running the <a id="_idIndexMarker238"/>preceding code displays the <span class="No-Break">following output:</span></p>
			<pre class="console">
error, unexpected nil value</pre>			<p>In the preceding example, we declared the <strong class="source-inline">message</strong> variable as a slice of strings, but did not initialize it with any values. A<a id="_idTextAnchor701"/>s such, th<a id="_idTextAnchor702"/>e value of <strong class="source-inline">message</strong> <span class="No-Break">is nil.</span></p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor703"/>Activity 3.01 – Sales tax calculator</h2>
			<p>In this activity, we create a shopping <a id="_idIndexMarker239"/>cart application, where sales tax must be added to calculate <span class="No-Break">the total:</span></p>
			<ol>
				<li>Create a calculator that calculates the sales tax for a <span class="No-Break">single item.</span></li>
				<li>The calculator must take the item’s cost and its sales <span class="No-Break">tax rate.</span></li>
				<li>Sum the sales tax and print the total amount of sales t<a id="_idTextAnchor704"/>ax required for the <span class="No-Break">following items:</span></li>
			</ol>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B18621_03_13.jpg" alt="Figure 3.13: List of items with their sales tax rates" width="643" height="239"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13: List of items with their sales tax rates</p>
			<p>Your output should look <span class="No-Break">like this:</span></p>
			<pre class="console">
Sales Tax Total: 0.1329</pre>			<p class="callout-heading">Note</p>
			<p class="callout"> The solution for this activity<a id="_idIndexMarker240"/> can be found in<a id="_idTextAnchor705"/><a id="_idTextAnchor706"/> the GitHub repository folder for this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter03/Activity03.01"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter03/Activity03.01</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor707"/>Activity 3.02 – Loan calculator</h2>
			<p>In this activity, we <a id="_idIndexMarker241"/>must create a loan calculator for an online financial advisor platform. Our calcu<a id="_idTextAnchor708"/><a id="_idTextAnchor709"/>lator should have the <span class="No-Break">following rules:</span></p>
			<ol>
				<li>A good credit score is a score of 450 <span class="No-Break">or above.</span></li>
				<li>For a good credit score, your interest rate <span class="No-Break">is 15%.</span></li>
				<li>If your score is less than good, your interest rate <span class="No-Break">is 20%.</span></li>
				<li>For a good credit score, your monthly payments can be no more than 20% of your <span class="No-Break">monthly income.</span></li>
				<li>If your credit score is not at least good, your monthly payment can be no more than 10% of your <span class="No-Break">monthly income.</span></li>
				<li>If a credit score, monthly income, loan amount, or loan term is less than 0, return <span class="No-Break">an error.</span></li>
				<li>If the term of the loan is not divisible by 12 months, return <span class="No-Break">an error.</span></li>
				<li>The interest payment will be a simple calculation of the loan amount * interest rate * <span class="No-Break">loan term.</span></li>
				<li>After doing these calculations, display the following details to <span class="No-Break">the user:</span><pre class="source-code">
Applicant X
-----------
Credit Score : X
Income : X
Loan Amount : X
Loan Term : X
Monthly Payment : X
Rate : X
Total Cost : X
Appr<a id="_idTextAnchor710"/>oved : X</pre></li>			</ol>
			<p>This <a id="_idTextAnchor711"/>is the<a id="_idIndexMarker242"/> <span class="No-Break">expected output:</span></p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B18621_03_14.jpg" alt="Figure 3.14: Output of loan calculator" width="1237" height="1032"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14: Output of loan calculator</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found i<a id="_idTextAnchor712"/><a id="_idTextAnchor713"/>n <span class="No-Break">the </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter03/Activity03.02"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter03/Activity03.02</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor714"/>Summary</h1>
			<p>In this chapter, we took a big step in working with Go’s type system. We took the time to define what types are and why they are needed. We then explored each of the core types in Go. We started with the simple <strong class="source-inline">bool</strong> type, and we were able to show how critical it is to everything we do in our code. We then moved on to the number types. Go has lots of types for numbers, reflecting the control that Go likes to give developers when it comes to memory usage and accuracy. After numbers, we looked at how strings work and how they are closely related to the rune type. With the advent of multi-byte characters, it’s easy to make a mess of your text data. Go has provided powerful built-in features to help you get it right. Lastly, we looked at <strong class="source-inline">nil</strong> and how you use it <span class="No-Break">within Go.</span></p>
			<p>The concepts you’ve learned in this chapter have armed you with the knowledge needed to tackle Go’s more complex types, such as collections and structs. We’ll be looking at these complex types in the <span class="No-Break">next chapter.</span></p>
		</div>
	</div></div></body></html>