- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Core Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 核心类型
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter aims to show you how to use Go’s basic core types to design your
    software’s data. We’ll work through each type to show what they are useful for
    and how to use them in your software. Understanding these core types provides
    you with the foundation required to learn how to create complex data designs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在向你展示如何使用Go的基本核心类型来设计你的软件数据。我们将逐一处理每种类型，展示它们有什么用以及如何在软件中使用它们。理解这些核心类型为你提供了学习如何创建复杂数据设计所需的基础。
- en: By the end of this chapter, you will be able to create variables of different
    types for Go programs and assign values to variables of different types. You will
    learn how to identify and pick a suitable type for any programming situation.
    You will also write a program to measure password complexity and implement empty
    value types.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够为Go程序创建不同类型的变量，并为不同类型的变量分配值。你将学习如何识别和选择任何编程情况下的合适类型。你还将编写一个程序来测量密码复杂度并实现空值类型。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you''ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter03](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter03).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要Go版本1.21或更高版本。本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter03](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter03)。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we learned how to use `if`, `if`-`else`, `else-if`,
    `switch`, `case`, `continue`, `break`, and `goto` in Go.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何在Go中使用`if`、`if-else`、`else-if`、`switch`、`case`、`continue`、`break`和`goto`。
- en: Go is a strongly typed language, and all data is assigned a type. That type
    is fixed and can’t be changed. What you can and can’t do with your data is constrained
    by the types you assign. Understanding exactly what defines every one of Go’s
    core types is critical to success with the Go language.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Go是一种强类型语言，所有数据都被分配了一个类型。这个类型是固定的，不能更改。你可以对你的数据做什么，不能做什么是由你分配的类型所决定的。准确理解定义Go每个核心类型的每一个方面对于在Go语言中取得成功至关重要。
- en: In later chapters, we’ll talk about Go’s more complex types, but those types
    are built on the core types defined in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将讨论Go的更复杂类型，但这些类型都是基于本章定义的核心类型构建的。
- en: Go’s core types are well-thought-out and easy to understand once you understand
    the details. Having to understand the details means Go’s type system is not always
    intuitive. For example, Go’s most common number type, `int`, may be either 32
    bits or 64 bits in size depending on the computer used to compile the code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你了解了细节，Go的核心类型就考虑得很好，也容易理解。需要理解细节意味着Go的类型系统并不总是直观的。例如，Go最常用的数字类型`int`的大小可能是32位或64位，这取决于编译代码所使用的计算机。
- en: Types are needed to make data easier for humans to work with. Computers only
    think about data in binary. Binary is hard for people to work with. By adding
    a layer of abstraction to binary data and labelling it as a number or some text,
    humans have an easier time reasoning about it. Reducing the cognitive load allows
    people to build more complex software because they’re not overwhelmed by managing
    the details of the binary data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是使数据对人类更容易处理所必需的。计算机只考虑二进制数据。二进制对人类来说很难处理。通过在二进制数据上添加一层抽象并将其标记为数字或某些文本，人类更容易对其进行推理。减少认知负担使得人们能够构建更复杂的软件，因为他们不会被管理二进制数据细节所淹没。
- en: Programming languages need to define what a number is or what a text is for.
    A programming language defines what you can call a number, and it defines what
    operations you can use on a number. For example, can a whole number such as 10
    and a floating-point number such as 3.14 both be stored as the same type? While
    it seems obvious that you can multiply numbers, can you multiply text? As we progress
    through this chapter, we’ll clearly define what the rules are for each type and
    what operations you can use with each of them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言需要定义什么是数字，或者什么是文本。编程语言定义了你可以称为什么样的数字，以及你可以对数字执行哪些操作。例如，一个整数10和一个浮点数3.14是否都可以存储为同一类型？虽然看起来很明显你可以乘以数字，但你能否乘以文本？随着我们进入本章，我们将明确定义每种类型的规则以及你可以对它们执行的操作。
- en: The way data is stored is also a large part of what defines a type. To allow
    for the building of efficient software, Go places limits on how large some of
    its types can be. For example, the largest amount of storage for a number in Go’s
    core types is 64 bits of memory. This allows for any number up to 18,446,744,073,709,551,615\.
    Understanding these types of limitations is critical in building bug-free code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的存储方式也是定义类型的一个重要部分。为了允许构建高效的软件，Go对其某些类型的大小施加了限制。例如，Go核心类型中数字的最大存储量是64位内存。这允许存储任何高达18,446,744,073,709,551,615的数字。理解这些类型的限制对于构建无错误的代码至关重要。
- en: 'The things that define a type are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类型的因素如下：
- en: The kind of data that you can store in it
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以存储的数据类型
- en: What operations you can use with it
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用它的操作
- en: What those operations do to it
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些操作对其产生的影响
- en: How much memory it can use
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以使用的内存量
- en: This chapter gives you the knowledge and confidence to use Go’s type system
    correctly in your code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为你提供了使用Go类型系统的知识，并增强了你在代码中使用它的信心。
- en: True and false
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真和假
- en: True and false logic is represented using the Boolean type, `bool`. Use this
    type when you need an on/off switch in your code. The value of a `bool` instance
    can only ever be `true` or `false`. The zero value of a `bool` instance is `false`.
    A “zero value” refers to the default value that a variable takes when it’s declared
    without an explicit initial value.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布尔类型`bool`表示真和假逻辑。当你需要在代码中实现开/关切换时使用此类型。布尔实例的值只能是`true`或`false`。布尔实例的零值是`false`。“零值”指的是变量在未指定显式初始值时声明的默认值。
- en: When using a comparison operator such as `==` or `>`, the result of that comparison
    is a `bool` value.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用比较运算符如`==`或`>`时，该比较的结果是一个布尔值。
- en: 'In this code example, we use comparison operators on two numbers. You’ll see
    that the result is a `bool` value:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们在两个数字上使用比较运算符。你会看到结果是布尔值`bool`：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running the preceding code shows the following output:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会显示以下输出：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Exercise 3.01 – Program to measure password complexity
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.01 – 测量密码复杂度的程序
- en: 'An online portal creates user accounts for its users and accepts passwords
    that are only 8 to 15 characters long. In this exercise, we write a program for
    the portal to display whether the password entered meets the character requirements.
    The character requirements are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在线门户为用户创建用户账户，并接受长度为8到15个字符的密码。在这个练习中，我们为门户编写一个程序来显示输入的密码是否满足字符要求。字符要求如下：
- en: Have a lowercase letter
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个小写字母
- en: Have an uppercase letter
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个大写字母
- en: Have a number
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个数字
- en: Have a symbol
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个符号
- en: Be 8 or more characters long
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少8个字符长
- en: 'To do this exercise, we’re going to use a few new features. Don’t worry if
    you don’t quite understand what they are doing; we’ll cover them in detail in
    the next chapter. Consider this a sneak peek. We’ll explain what everything is
    as we go, but your main focus should be on the Boolean logic:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个练习，我们将使用一些新特性。如果你不完全理解它们的作用，不要担心；我们将在下一章详细讲解。这可以看作是一个预览。我们将边走边解释每一件事，但你的主要焦点应该是布尔逻辑：
- en: Create a new folder and add a `main.go` file.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个`main.go`文件。
- en: 'In `main.go`, add the main package name to the top of the file:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将主包名添加到文件顶部：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now add the imports we’ll use in this file:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加我们将在此文件中使用的导入：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a function that takes a string argument and returns a `bool` value:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，它接受一个字符串参数并返回一个布尔值：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Convert the password string into a `rune` type, which is safe for multi-byte
    (UTF-8) characters:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将密码字符串转换为`rune`类型，这对于多字节（UTF-8）字符是安全的：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We’ll talk more about `rune` later in this chapter.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在本章后面更详细地讨论`rune`。
- en: 'Count the number of multi-byte characters using `len`. This code results in
    a `bool` result that can be used in the `if` statement:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`len`计算多字节字符的数量。此代码产生一个可用于`if`语句的布尔结果：
- en: '[PRE6]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Define some `bool` variables. We’ll check these at the end:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一些`bool`变量。我们将在最后检查这些变量：
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Loop over the multi-byte characters one at a time:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐个遍历多字节字符：
- en: '[PRE8]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using the `unicode` package, check whether this character is uppercase. This
    function returns a `bool` value that we can use directly in the `if` statement:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`unicode`包检查此字符是否为大写。此函数返回一个布尔值，我们可以直接在`if`语句中使用：
- en: '[PRE9]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If it is, we’ll set the `hasUpper` `bool` variable to `true`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，我们将设置`hasUpper`布尔变量为`true`：
- en: '[PRE10]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Do the same thing for lowercase letters:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于小写字母也做同样的事情：
- en: '[PRE11]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Also do it for numbers:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也对数字做同样的事情：
- en: '[PRE12]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For symbols, we’ll also accept punctuation. Use the `or` operator, which works
    with Booleans, to result in `true` if either of these functions returns `true`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于符号，我们也会接受标点符号。使用`or`运算符，它与布尔值一起工作，如果这两个函数中的任何一个返回`true`，则结果为`true`：
- en: '[PRE13]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To pass all our checks, all our variables must be `true`. Here, we combine
    multiple `and` operators to create a one-line statement that checks all four variables:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了通过所有检查，所有变量都必须是`true`。在这里，我们通过组合多个`and`运算符创建一个检查所有四个变量的单行语句：
- en: '[PRE14]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Close the function:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭函数：
- en: '[PRE15]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create the `main()` function:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE16]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Call the `passwordChecker()` function with an invalid password. As this returns
    a `bool` value, it can be used directly in an `if` statement:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用无效密码调用`passwordChecker()`函数。由于这个函数返回一个`bool`值，可以直接在`if`语句中使用：
- en: '[PRE17]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, call the function with a valid password:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用有效的密码调用函数：
- en: '[PRE18]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Close the `main()` function:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main()`函数：
- en: '[PRE19]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Save the file in the new folder and then run the following:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中保存文件，然后运行以下命令：
- en: '[PRE20]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running the preceding code displays the following output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会显示以下输出：
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this exercise, we highlighted a variety of ways that `bool` values manifest
    themselves in the code. `bool` values are critical to giving your code the ability
    to make a choice and be dynamic and responsive. Without `bool`, your code would
    have a hard time doing anything.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们强调了`bool`值在代码中表现出的各种方式。`bool`值对于赋予你的代码选择能力、动态性和响应性至关重要。没有`bool`，你的代码将很难做任何事情。
- en: Next, we’ll take a look at numbers and how Go categorizes them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨数字以及Go如何对它们进行分类。
- en: Numbers
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: Go has two distinct number types – integers, also known as whole numbers and
    floating-point numbers. The floating-point number type allows whole numbers and
    numbers that contain fractions of a whole number.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Go有两种不同的数字类型——整数，也称为整数和浮点数。浮点数类型允许整数和包含整数分数的数。
- en: 1, 54, and 5,436 are examples of whole numbers. 1.5, 52.25, 33.333, and 64,567.00001
    are all examples of floating-point numbers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 1、54和5,436是整数示例。1.5、52.25、33.333和64,567.00001都是浮点数示例。
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The default and empty value for all number types is 0.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数字类型的默认值和空值都是0。
- en: Next, we’ll start our number journey by looking at integers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从查看整数开始我们的数字之旅。
- en: Integers
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数
- en: 'Integer types are classified in two ways, based on the following conditions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下条件，整数类型有两种分类方式：
- en: Whether or not they can store negative numbers
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是否可以存储负数
- en: The smallest and largest numbers they can store
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以存储的最小和最大数值
- en: Types that can store negative numbers are called signed integers. Types that
    can’t store negative numbers are called unsigned integers. How big and small a
    number each type can store is determined by how many bytes of internal storage
    they have.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可以存储负数的类型称为有符号整数。不能存储负数的类型称为无符号整数。每种类型可以存储的数值大小由它们内部存储的字节数决定。
- en: 'Here is an excerpt from the Go language specification with all the relevant
    integer types:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Go语言规范中所有相关整数类型的摘录：
- en: '![Figure 3.1: Go language specification with relevant integer types](img/B18621_03_1.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1：Go语言规范及相关整数类型](img/B18621_03_1.jpg)'
- en: 'Figure 3.1: Go language specification with relevant integer types'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：Go语言规范及相关整数类型
- en: 'There are also the following special integer types:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有以下特殊整数类型：
- en: '![Figure 3.2: Special integer types](img/B18621_03_2.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2：特殊整数类型](img/B18621_03_2.jpg)'
- en: 'Figure 3.2: Special integer types'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：特殊整数类型
- en: '`uint` and `int` are either 32 or 64 bits, depending on whether you compile
    your code for a 32-bit system or a 64-bit system. It’s rare nowadays to run applications
    on a 32-bit system, as most systems nowadays are 64-bit.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`uint`和`int`类型是32位或64位，这取决于你是否为32位系统或64位系统编译你的代码。如今，在32位系统上运行应用程序的情况很少，因为大多数系统现在都是64位的。'
- en: An `int` type on a 64-bit system is not an `int64` type. While these two types
    are identical, they are not the same integer type, and you can’t use them together.
    If Go allowed this, there would be problems when the same code gets compiled for
    a 32-bit machine, so keeping them separate ensures that the code is reliable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在64位系统上的`int`类型不是`int64`类型。虽然这两个类型是相同的，但它们不是同一整数类型，你不能将它们一起使用。如果Go允许这样做，当相同的代码在32位机器上编译时会出现问题，因此将它们分开可以确保代码的可靠性。
- en: This incompatibility is not just an `int` type problem; you can’t use any of
    the integer types together.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不兼容性不仅仅是`int`类型的问题；你不能将任何整数类型一起使用。
- en: Picking the correct integer type to use when defining a variable is easy – use
    `int`. When writing code for an application, `int` does the job the majority of
    the time. Only think about using the other types when using an `int` type is causing
    a problem. The sorts of problems you see with `int` tend to be related to memory
    usage.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义变量时选择正确的整数类型很容易——使用 `int`。在编写应用程序代码时，`int` 大多数情况下都能完成任务。只有当使用 `int` 类型导致问题时，才考虑使用其他类型。您在
    `int` 类型上遇到的问题通常与内存使用有关。
- en: For example, let’s say you have an app that’s running out of memory. The app
    uses a massive number of integers, but these integers are never negative and won’t
    go over 255\. One possible fix is to switch from using `int` to using `uint8`.
    Doing this cuts its memory usage from 64 bits (8 bytes) per number to 8 bits (1
    byte) per number.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您有一个内存不足的应用程序。该应用程序使用了大量的整数，但这些整数永远不会是负数，并且不会超过 255。一种可能的解决方案是将 `int` 类型切换为
    `uint8` 类型。这样做可以将每个数字的内存使用从 64 位（8 字节）减少到 8 位（1 字节）。
- en: 'We can show this by creating a collection of both types and then asking Go
    how much heap memory it is using. The output may vary on your computer, but the
    effect should be similar. This code creates a collection of `int` or `int8` numbers.
    It then adds 10 million values to the collection. Once that’s done, it uses the
    runtime package to give us a reading of how much heap memory is being used. We
    can convert that reading to MB and then print it out:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建这两种类型的数据集合，然后询问 Go 语言它使用了多少堆内存来展示这一点。输出结果可能因您的计算机而异，但效果应该是相似的。此代码创建了一个包含
    `int` 或 `int8` 类型的数字集合。然后它向集合中添加了 1000 万个值。一旦完成，它使用运行时包来读取正在使用的堆内存量。我们可以将这个读取结果转换为
    MB，然后打印出来：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here’s the output using `int`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `int` 类型的输出：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And here’s the output using `int8`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `int8` 类型的输出：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We saved a good amount of memory here, but we need 10 million values to make
    it worthwhile. Hopefully, now you are convinced that it’s okay to start with `int`
    and only worry about performance when it’s a problem.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里节省了相当多的内存，但我们需要 1000 万个值来使其变得有意义。希望现在您已经相信，从 `int` 类型开始是可行的，只有在出现问题时才需要关注性能。
- en: Next, we’ll look at floating-point numbers.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨浮点数。
- en: Floating-point numbers
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数
- en: Go has two floating-point number types, `float32` and `float64`. The bigger
    `float64` allows for more precision in numbers. `float32` has 32 bits of storage
    and `float64` has 64 bits of storage. Floats split their storage between whole
    numbers (everything to the left of the decimal point) and decimal numbers (everything
    to the right of the decimal point). How much space is used for the whole number
    or the decimal numbers varies according to the number being stored. For example,
    9,999.9 would use more storage for the whole numbers, while 9.9999 would use more
    storage for the decimal numbers. With `float64`’s bigger space for storage, it
    can store more whole numbers and/or more decimal numbers than `float32` can.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言有两种浮点数类型，`float32` 和 `float64`。较大的 `float64` 类型允许在数字中提供更高的精度。`float32`
    类型有 32 位存储空间，而 `float64` 类型有 64 位存储空间。浮点数将它们的存储空间分配给整数部分（小数点左侧的所有内容）和小数部分（小数点右侧的所有内容）。用于整数部分或小数部分的存储空间大小根据存储的数字而变化。例如，9,999.9
    会为整数部分使用更多的存储空间，而 9.9999 会为小数部分使用更多的存储空间。由于 `float64` 类型有更大的存储空间，它可以存储比 `float32`
    类型更多的整数和/或小数。
- en: Exercise 3.02 – Floating-point number accuracy
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.02 – 浮点数精度
- en: In this exercise, we’re going to compare what happens when we do some divisions
    on numbers that don’t divide equally. We’ll be dividing 100 by 3\. One way of
    representing the result is 33 ⅓. Computers, for the most part, can’t compute fractions
    like this. Instead, they use a decimal representation, which is 33.3 recurring,
    where the 3 after the decimal point repeats forever. If we let the computer do
    that it uses up all the memory, which is not very helpful.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将比较当我们对不能整除的数字进行除法运算时会发生什么。我们将用 100 除以 3。表示结果的一种方式是 33 ⅓。大多数情况下，计算机无法计算这样的分数。相反，它们使用十进制表示法，即
    33.3 重复，小数点后的 3 永远重复。如果我们让计算机这样做，它会耗尽所有内存，这并不很有帮助。
- en: 'Luckily for us, we don’t need to worry about this happening as the floating-point
    types have storage limits. The downside is that this leads to a number that doesn’t
    reflect the true result; the result has a certain amount of inaccuracy. Your tolerance
    for inaccuracy needs and how much storage space you want to give to your floating-point
    numbers must be balanced out:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要担心这种情况发生，因为浮点类型有存储限制。缺点是这会导致一个不反映真实结果的数字；结果有一定的误差。你需要对误差的容忍度和你想要给浮点数的存储空间必须得到平衡：
- en: Create a new folder and add a `main.go` file.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个`main.go`文件。
- en: 'In `main.go`, add the main package name to the top of the file:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将主包名添加到文件顶部：
- en: '[PRE25]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now add the imports we’ll use in this file:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加我们将在文件中使用的导入：
- en: '[PRE26]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create the `main()` function:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE27]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Declare an `int` variable and initialize it with a value of 100:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`int`变量并将其初始化为100：
- en: '[PRE28]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Declare a `float32` variable and initialize it with a value of 100:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`float32`变量并将其初始化为100：
- en: '[PRE29]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Declare a `float64` variable and initialize it with a value of 100:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`float64`变量并将其初始化为100：
- en: '[PRE30]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Divide each variable by 3 and print the result to the console:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个变量除以3并将结果打印到控制台：
- en: '[PRE31]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Save the file and in the new folder run the following:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，然后在新的文件夹中运行以下命令：
- en: '[PRE32]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Running the preceding code shows the following output displaying `int`-, `float32`-,
    and `float64`-typed equivalent starting values, divided by 3:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码显示了以下输出，显示了`int`、`float32`和`float64`类型的等效起始值，除以3：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this exercise, we can see that the computer is not able to give perfect answers
    to this sort of division. You can also see that when doing this sort of math on
    integers, you don’t get an error. Go ignores any fractional part of the number,
    which is usually not what you want. We can also see that `float64` gives a much
    more precise answer than `float32`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们可以看到计算机不能给出这种除法的完美答案。你还可以看到，在进行这种整数数学运算时，你不会得到错误。Go会忽略数字的任何分数部分，这通常不是你想要的。我们还可以看到`float64`给出的答案比`float32`更精确。
- en: While this limit seems like it would lead to inaccuracy, for real-world business
    work, it gets the job done well enough the vast majority of the time. Use cases
    that involve highly precise counts, such as in finance and banking, require you
    to pay special attention to Go’s numerical types to ensure mathematical accuracy.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个限制看起来可能会导致不准确，但在现实世界的商业工作中，它大多数时候都能很好地完成任务。涉及高度精确计数的使用案例，例如在金融和银行业，你需要特别注意Go的数值类型，以确保数学准确性。
- en: 'Let’s see what happens if we try to get our number back to 100 by multiplying
    it by 3:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们尝试通过乘以3将我们的数字回到100会发生什么：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Running the preceding code shows the following output:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码显示了以下输出：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, we saw that accuracy is not impacted as much as you’d expect.
    At first glance, floating-point math can seem simple, but it quickly gets complicated.
    When defining your floating-point variables, typically `float64` should be your
    first choice, unless you need to be more memory efficient.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到准确性并没有像你预期的那样受到很大影响。乍一看，浮点数学可能看起来很简单，但它很快就会变得复杂。当你定义浮点变量时，通常`float64`应该是你的首选，除非你需要更高效的内存使用。
- en: Next, we’ll look at what happens when you go beyond the limits of a number type.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看当你超出数字类型的限制时会发生什么。
- en: Overflow and wraparound
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 溢出和回绕
- en: 'When you try to initialize a number with a value that’s too big for the type
    you are using, you get an overflow error. The highest number you can have in an
    `int8` type is 127\. In the following code, we’ll try to initialize it with 128
    to see what happens:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试用一个超出你所用类型范围的值初始化一个数字时，你会得到一个溢出错误。`int8`类型中你能有的最大数字是127。在下面的代码中，我们将尝试用128来初始化它，看看会发生什么：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Running the preceding code gives the following output:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会得到以下输出：
- en: '![Figure 3.3: Output after initializing with 128](img/B18621_03_3.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3：用128初始化后的输出](img/B18621_03_3.jpg)'
- en: 'Figure 3.3: Output after initializing with 128'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：用128初始化后的输出
- en: This error is easy to fix and can’t cause any hidden problems. The real problem
    is when the compiler can’t catch it. When this happens, the number will “wraparound.”
    Wraparound means the number goes from its highest possible value to its lowest
    possible value. Wraparound can be easy to miss when developing your code and can
    cause significant problems for your users.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误很容易修复，不会引起任何隐藏的问题。真正的问题在于编译器无法捕捉到它。当这种情况发生时，数字将“回绕”。回绕意味着数字从其可能的最大值变为可能的最小值。在开发代码时，回绕可能很容易被忽略，并可能给用户造成重大问题。
- en: Exercise 3.03 – Triggering number wraparound
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.03 – 触发数字回绕
- en: 'In this exercise, we’ll declare two small integer types – `int8` and `uint8`.
    We’ll initialize them near their highest possible value. Then we’ll use a loop
    statement to increment them by 1 per loop, then print their value to the console.
    We’ll be able to see exactly when they wraparound:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将声明两种小的整数类型 – `int8`和`uint8`。我们将它们初始化在其可能的最大值附近。然后我们将使用循环语句每次循环增加1，然后打印它们的值到控制台。我们将能够看到它们何时回绕：
- en: Create a new folder and add a `main.go` file.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个`main.go`文件。
- en: 'In `main.go`, add the main package name to the top of the file:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将主包名添加到文件顶部：
- en: '[PRE37]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now add the imports we’ll use in this file:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加我们将在此文件中使用的导入：
- en: '[PRE38]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create the `main()` function:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE39]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Declare an `int8` variable with an initial value of 125:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个初始值为125的`int8`变量：
- en: '[PRE40]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Declare an `uint8` variable with an initial value of 253:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个初始值为253的`uint8`变量：
- en: '[PRE41]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a `for i` loop that runs five times:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个运行五次的`for i`循环：
- en: '[PRE42]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Increment the two variables by 1:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个变量各加1：
- en: '[PRE43]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Print the variables’ values to the console:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将变量的值打印到控制台：
- en: '[PRE44]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Close the loop:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭循环：
- en: '[PRE45]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Close the `main()` function:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main()`函数：
- en: '[PRE46]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Save the file, and, in the new folder, run the following:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并在新文件夹中运行以下命令：
- en: '[PRE47]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Running the preceding code shows the following output:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码会显示以下输出：
- en: '![Figure 3.4: Output after wraparound](img/B18621_03_4.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4：回绕后的输出](img/B18621_03_4.jpg)'
- en: 'Figure 3.4: Output after wraparound'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：回绕后的输出
- en: In this exercise, we saw that, for signed integers, you’d end up with a negative
    number while unsigned integers wrap around to 0\. You must always consider the
    maximum possible value for your variable and be sure to have the appropriate type
    to support that number.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了对于有符号整数，你会得到一个负数，而无符号整数则回绕到0。你必须始终考虑变量的最大可能值，并确保有适当的数据类型来支持这个数字。
- en: Next, we’ll look at what you can do when you need a number that’s bigger than
    the core types can give you.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看当你需要一个比核心类型能提供的更大的数字时你能做什么。
- en: Big numbers
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大数
- en: If you need a number higher or lower than `int64` or `uint64` can store, you
    can use the `math/big` package. This package feels a little awkward to use compared
    to dealing with integer types, but you’ll be able to do everything you can generally
    do with integers using its API.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个比`int64`或`uint64`能存储的数字更高或更低的数字，你可以使用`math/big`包。与处理整数类型相比，这个包使用起来感觉有点笨拙，但你可以使用它的API做所有你通常可以用整数做的事情。
- en: Exercise 3.04 – Big numbers
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.04 – 大数
- en: 'In this exercise, we’re going to create a number that’s larger than Go’s core
    number types can store. To demonstrate this, we’ll use an addition operation.
    We’ll also do the same to an `int` variable to show the difference. Then, we’ll
    print the result to the console:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个比Go的核心数字类型能存储的更大的数字。为了演示这一点，我们将使用加法操作。我们还将对`int`变量做同样的操作以显示差异。然后，我们将打印结果到控制台：
- en: Create a new folder and add a `main.go` file.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个`main.go`文件。
- en: 'In `main.go`, add the main package name to the top of the file:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将主包名添加到文件顶部：
- en: '[PRE48]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now add the imports we’ll use in this file:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加我们将在此文件中使用的导入：
- en: '[PRE49]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create the `main()` function:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE50]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Declare an `int` variable and initialize it with `math.MaxInt64`, which is
    the highest possible value for an `int64` variable in Go and is defined as a constant:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`int`变量，并使用`math.MaxInt64`初始化它，这是Go中`int64`变量的可能最大值，它被定义为常量：
- en: '[PRE51]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add 1 to `int`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`int`加1：
- en: '[PRE52]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now we’ll create a `big` `int` variable. This is a custom type and is not based
    on Go’s `int` type. We’ll also initialize it with Go’s highest possible number
    value:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个`big` `int`变量。这是一个自定义类型，它不是基于Go的`int`类型。我们还将使用Go的最高可能数值初始化它：
- en: '[PRE53]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We’ll add 1 to our `big` `int`. You can see that this feels clumsy:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将向我们的`big` `int`变量加1。你可以看到这感觉有点笨拙：
- en: '[PRE54]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Print out the max `int` size and the values for our Go `int` and our `big`
    `int`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出`int`的最大大小以及我们的Go `int`和`big` `int`的值：
- en: '[PRE55]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Close the `main()` function:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main()`函数：
- en: '[PRE56]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Save the file, and in the new folder run the following:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，然后在新的文件夹中运行以下命令：
- en: '[PRE57]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Running the preceding code displays the following output:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码会显示以下输出：
- en: '![Figure 3.5: Output displaying large numbers with Go’s number types](img/B18621_03_5.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5：使用Go的数字类型显示大数字的输出](img/B18621_03_5.jpg)'
- en: 'Figure 3.5: Output displaying large numbers with Go’s number types'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：使用Go的数字类型显示大数字的输出
- en: In this exercise, we saw that while `int` has wrapped around, `big.Int` has
    added the number correctly.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了虽然`int`已经溢出，但`big.Int`正确地添加了数字。
- en: If you have a situation where you have a number whose value is higher than Go
    can manage, then the `big` package from the standard library is what you need.
    Next, we’ll look at a special Go number type used to represent raw data.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个数值高于Go可以处理的数字的情况，那么你需要使用标准库中的`big`包。接下来，我们将看看用于表示原始数据的特殊Go数字类型。
- en: byte
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: byte
- en: The `byte` type in Go is just an alias for `uint8`, which is a number that has
    eight bits of storage. In reality, `byte` is a significant type, and you’ll see
    it in lots of places. A bit is a single binary value – a single on/off switch.
    Grouping bits into groups of eight was a common standard in early computing and
    became a near-universal way to encode data. 8-bits have 256 possible combinations
    of “off” and “on,” so `uint8` has 256 possible integer values from 0 to 255\.
    All combinations of on and off can are represented with this type.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的`byte`类型只是`uint8`的别名，它是一个有八个存储位的数字。实际上，`byte`是一个重要的类型，你会在很多地方看到它。位是一个单一的二进制值——一个单一的开关。将位分组为八位是早期计算中的常见标准，并成为编码数据的一种几乎通用的方式。8位有256种“关闭”和“开启”的组合，所以`uint8`有从0到255的256个可能的整数值。所有开启和关闭的组合都可以用这种类型表示。
- en: You’ll see `byte` used when reading and writing data to and from a network connection
    and when reading and writing data to files.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在读取和写入网络连接以及读取和写入文件数据时看到`byte`的使用。
- en: With this, we’re all done with numbers. Now, let’s look at how Go stores and
    manages text.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们完成了数字的讨论。现在，让我们看看Go如何存储和管理文本。
- en: Text
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本
- en: Go uses a single `string` type to represent text.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用单个`string`类型来表示文本。
- en: 'When you write text to a `string` variable it’s called a string literal. There
    are two kinds of string literals in Go:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将文本写入一个`string`变量时，它被称为字符串字面量。在Go中，有两种字符串字面量：
- en: Raw – defined by wrapping text in a pair of `` ` ``
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始型 - 通过在文本周围添加一对`` ` ``
- en: Interpreted – defined by surrounding the text in a pair of `"`
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释型 - 通过在文本周围添加一对`"`来定义
- en: With raw literals, what ends up in your variable is precisely the text that
    you see on the screen. With interpreted literals, Go scans what you’ve written
    and then applies transformations based on its own set of rules.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原始字面量，最终出现在你的变量中的正是你在屏幕上看到的文本。使用解释型字面量，Go会扫描你所写的文本，然后根据它自己的规则集应用转换。
- en: 'Here’s what that looks like:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是这样的：
- en: '[PRE58]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Running the preceding code gives the following output:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会得到以下输出：
- en: '![Figure 3.6: Output from printing text](img/B18621_03_6.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6：打印文本的输出](img/B18621_03_6.jpg)'
- en: 'Figure 3.6: Output from printing text'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：打印文本的输出
- en: In an interpreted string, `\n` represents a new line. In our raw string, `\n`
    doesn’t do anything to our formatting and is printed out just as we typed it.
    To get a new line in the raw string, we must add an actual new line to our raw
    literal. The interpreted string must use `\n` to get a new line, as adding a real
    new line to an interpreted string is not allowed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释型字符串中，`\n`表示换行符。在我们的原始字符串中，`\n`不会对我们的格式化产生影响，并且会按照我们输入的方式打印出来。要在原始字符串中得到换行符，我们必须在我们的原始字面量中添加一个实际的新行。解释型字符串必须使用`\n`来得到换行符，因为不允许在解释型字符串中添加真实的新行。
- en: While there are a lot of things you can do with an interpreted string literal,
    in real-world code, the two you’ll see most commonly are `\n` for a new line and,
    occasionally, `\t` for a tab.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以用解释型字符串字面量做很多事情，但在现实世界的代码中，你最常见的两种是`\n`表示换行符，偶尔还有`\t`表示制表符。
- en: Interpreted string literals are the most common kind in real-world code, but
    raw literals have their place. If you want to copy and paste text that contains
    a lot of new lines, or `"` or `\` characters, it’s easier to use raw literals.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 解释型字符串字面量在现实世界的代码中是最常见的类型，但原始字面量也有其位置。如果你想复制和粘贴包含大量换行符或`"`或`\`字符的文本，使用原始字面量会更简单。
- en: 'In the following example, you can see how using raw literals makes the code
    more readable:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，你可以看到使用原始字面量如何使代码更易读：
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Running the preceding code displays the following output:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会显示以下输出：
- en: '![Figure 3.7: Output from more readable code](img/B18621_03_7.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7：更易读代码的输出](img/B18621_03_7.jpg)'
- en: 'Figure 3.7: Output from more readable code'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：更易读代码的输出
- en: One thing you can’t have in a raw literal is a `` ` `` character. If you need
    a literal with `` ` `` in it, you must use an interpreted string literal.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始字面量中，你不能有 `` ` `` 字符。如果你需要一个包含 `` ` `` 的字面量，你必须使用解释过的字符串字面量。
- en: String literals are just ways of getting text into a `string` variable. Once
    you have the value in the variable, there are no differences.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量只是将文本放入 `string` 变量的方式。一旦你有了变量的值，就没有区别了。
- en: Next, we’ll look at how to work safely with multi-byte strings.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何安全地处理多字节字符串。
- en: Rune
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时
- en: '`rune` is a type with enough storage to store a single UTF-8 multi-byte character.
    String literals are encoded using UTF-8\. UTF-8 is a massively popular and common
    multi-byte text encoding standard. The `string` type itself is not limited to
    UTF-8, as Go also needs to support other text encoding types. `string` not being
    limited to UTF-8 means there is often an extra step you need to take when working
    with your strings to prevent bugs.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`rune` 是一种具有足够存储空间以存储单个 UTF-8 多字节字符的类型。字符串字面量使用 UTF-8 编码。UTF-8 是一种非常流行和常见的多字节文本编码标准。`string`
    类型本身并不限于 UTF-8，因为 Go 还需要支持其他文本编码类型。`string` 不限于 UTF-8 意味着在处理字符串时，通常需要额外的一步来防止错误。'
- en: The different encodings use a different number of bytes to encode text. Legacy
    standards use one byte to encode a single character. UTF-8 uses up to four bytes
    to encode a single character. When text is in the `string` type, to allow for
    this variability, Go stores all strings as a `byte` collection. To be able to
    safely perform operations with text of any kind of encoding, single- or multi-byte,
    it should be converted from a `byte` collection to a `rune` collection.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编码使用不同数量的字节来编码文本。旧标准使用一个字节来编码一个字符。UTF-8 使用最多四个字节来编码一个字符。当文本在 `string` 类型中时，为了允许这种可变性，Go
    将所有字符串存储为 `byte` 集合。为了能够安全地对任何类型的文本执行操作，无论是单字节还是多字节，它应该从 `byte` 集合转换为 `rune` 集合。
- en: Note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you don’t know the encoding of the text, it’s usually safe to convert it
    to UTF-8\. Also, UTF-8 is backward-compatible with single-byte encoded text.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道文本的编码，通常将其转换为 UTF-8 是安全的。此外，UTF-8 与单字节编码的文本向后兼容。
- en: 'Go makes it easy to access the individual bytes of a string, as shown in the
    following example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Go 使得访问字符串的各个字节变得容易，如下面的示例所示：
- en: 'First, we define the package, import our needed libraries, and create the `main()`
    function:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义包，导入所需的库，并创建 `main()` 函数：
- en: '[PRE60]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We’ll create a string that contains a multi-byte character:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个包含多字节字符的字符串：
- en: '[PRE61]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We are going to use a `for i` loop to print out each byte of our string:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个 `for i` 循环来打印出我们字符串的每个字节：
- en: '[PRE62]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then we will close the `main()` function:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将关闭 `main()` 函数：
- en: '[PRE63]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Running the preceding code gives the following output:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会得到以下输出：
- en: '![Figure 3.8: Output displaying bytes according to input length](img/B18621_03_8.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8：根据输入长度显示字节的输出](img/B18621_03_8.jpg)'
- en: 'Figure 3.8: Output displaying bytes according to input length'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8：根据输入长度显示字节的输出
- en: The numbers printed out are the byte values of the string. There are only 13
    letters in our string. However, it contained a multi-byte character, so we printed
    out 14 byte values.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出的数字是字符串的字节值。我们的字符串中只有 13 个字母。然而，它包含了一个多字节字符，所以我们打印出了 14 个字节值。
- en: 'Let’s convert our bytes back into strings. This conversion uses type conversion,
    which we’ll cover in detail soon:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的字节转换回字符串。这种转换使用类型转换，我们将在后面详细讨论：
- en: '[PRE64]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Running the preceding code gives the following output:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会得到以下输出：
- en: '![Figure 3.9: Output displaying bytes converted to strings](img/B18621_03_9.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9：显示转换为字符串的字节的输出](img/B18621_03_9.jpg)'
- en: 'Figure 3.9: Output displaying bytes converted to strings'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9：显示转换为字符串的字节的输出
- en: The output is as expected until we get to the `Ü` character. That’s because
    `Ü` was encoded using more than one byte, and each byte on its own no longer makes
    sense.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 输出正如预期，直到我们到达 `Ü` 字符。这是因为 `Ü` 使用了多个字节进行编码，而单独的字节本身不再有意义。
- en: To safely work with individual characters of a multi-byte string, you first
    must convert the string slice of `byte` types to a slice of `rune` types.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Running the preceding code gives the following output:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10: Output displaying strings](img/B18621_03_10.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Output displaying strings'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: If we wish to work with each character in a loop like this, then using `range`
    would be a better choice. When using `range`, instead of moving one `byte` at
    a time, it moves along the string one `rune` at a time. The index is the byte
    offset, and the value is a `rune` value.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3.05 – Safely looping over a string
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll declare a string and initialize it with a multi-byte
    string value. We’ll then loop over the string using `range` to give us each character,
    one at a time. We’ll then print out the byte index and the character to the console:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the main package name to the top of the file:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now add the imports we’ll use in this file:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create the `main()` function:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Declare a `string` variable with a multi-byte string value:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create a `range` loop that loops over the string, then capture `index` and
    `rune` in the variable:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Print `index` and `rune` to the console, casting the rune to a string:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Close the loop:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Close the `main()` function:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Save the file and in the new folder run the following:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Running the preceding code gives the following output:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11: Output after safely looping over a string](img/B18621_03_11.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: Output after safely looping over a string'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we demonstrated that looping over a string in a safe, multi-byte
    way is baked right into the language. Using this method prevents you from getting
    invalid string data.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common way to find bugs is to check how many characters a string has
    by using `len` directly on it. Here is an example of how multi-byte strings can
    be mishandled:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Running the preceding code gives the following output:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12: Output displaying bugs after using the len function](img/B18621_03_12.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.12: Output displaying bugs after using the len function'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: You can see that when using `len` directly on a string, you get the wrong answer.
    Checking the length of data input using `len` in this way would end up with invalid
    data. For example, if we needed the input to be exactly eight characters long
    and somebody entered a multi-byte character, using `len` directly on that input
    would allow them to enter less than eight characters.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: When working with strings, be sure to check the `strings` package first. It’s
    filled with useful tools that may already do what you need.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s take a close look at Go’s special `nil` value.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: The nil value
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`nil` is not a type but a special value in Go. It represents an empty value
    of no type. When working with pointers, maps, and interfaces (we’ll cover these
    in the next chapter), you need to be sure they are not `nil`. If you try to interact
    with a `nil` value, your code will crash.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can’t be sure whether a value is `nil` or not, you can check it like
    this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Running the preceding code displays the following output:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In the preceding example, we declared the `message` variable as a slice of strings,
    but did not initialize it with any values. As such, the value of `message` is
    nil.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Activity 3.01 – Sales tax calculator
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we create a shopping cart application, where sales tax must
    be added to calculate the total:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Create a calculator that calculates the sales tax for a single item.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The calculator must take the item’s cost and its sales tax rate.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sum the sales tax and print the total amount of sales tax required for the
    following items:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.13: List of items with their sales tax rates](img/B18621_03_13.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.13: List of items with their sales tax rates'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Your output should look like this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter03/Activity03.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter03/Activity03.01).'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Activity 3.02 – Loan calculator
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we must create a loan calculator for an online financial
    advisor platform. Our calculator should have the following rules:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: A good credit score is a score of 450 or above.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a good credit score, your interest rate is 15%.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your score is less than good, your interest rate is 20%.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a good credit score, your monthly payments can be no more than 20% of your
    monthly income.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your credit score is not at least good, your monthly payment can be no more
    than 10% of your monthly income.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a credit score, monthly income, loan amount, or loan term is less than 0,
    return an error.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the term of the loan is not divisible by 12 months, return an error.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The interest payment will be a simple calculation of the loan amount * interest
    rate * loan term.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After doing these calculations, display the following details to the user:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This is the expected output:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14: Output of loan calculator](img/B18621_03_14.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.14: Output of loan calculator'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found in the [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter03/Activity03.02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter03/Activity03.02).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a big step in working with Go’s type system. We took
    the time to define what types are and why they are needed. We then explored each
    of the core types in Go. We started with the simple `bool` type, and we were able
    to show how critical it is to everything we do in our code. We then moved on to
    the number types. Go has lots of types for numbers, reflecting the control that
    Go likes to give developers when it comes to memory usage and accuracy. After
    numbers, we looked at how strings work and how they are closely related to the
    rune type. With the advent of multi-byte characters, it’s easy to make a mess
    of your text data. Go has provided powerful built-in features to help you get
    it right. Lastly, we looked at `nil` and how you use it within Go.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在使用 Go 的类型系统中迈出了重要的一步。我们花费时间定义了类型是什么以及为什么需要它们。然后我们探讨了 Go 中的每个核心类型。我们从简单的
    `bool` 类型开始，并展示了它在我们的代码中是多么关键。接着我们转向数字类型。Go 提供了大量的数字类型，反映了 Go 在内存使用和精度方面喜欢给予开发者的控制。在数字之后，我们研究了字符串的工作原理以及它们与
    `rune` 类型的紧密关系。随着多字节字符的出现，很容易让你的文本数据变得一团糟。Go 提供了强大的内置功能来帮助你正确处理。最后，我们探讨了 `nil`
    以及如何在 Go 中使用它。
- en: The concepts you’ve learned in this chapter have armed you with the knowledge
    needed to tackle Go’s more complex types, such as collections and structs. We’ll
    be looking at these complex types in the next chapter.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中你学到的概念为你提供了应对 Go 中更复杂类型（如集合和结构体）所需的知识。我们将在下一章中探讨这些复杂类型。
