<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer065">
			<h1 id="_idParaDest-118" class="chapter-number"><a id="_idTextAnchor715"/>4</h1>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor716"/>Complex Types</h1>
			<p class="callout-heading"><a id="_idTextAnchor717"/>Overview</p>
			<p class="callout">This chapter introduces Go’s more <a id="_idIndexMarker243"/>complex types. This will build on what we learned in the previous chapter regarding Go’s core types. These complex types are indispensable when you build more complex software as they allow you to logically group related data together. This ability to group data makes code easier to understand, maintain, <span class="No-Break">and fix.</span></p>
			<p class="callout">By the end of this chapter, you will be able to use arrays, slices, and maps to group data together. You will learn to create custom types based on the core types. You will also learn to use structs to create structures composed of named fields of any other types and explain the importance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">interface{}</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor718"/>Technical requirements</h1>
			<p>For this chapter, you'll require Go version 1.21 or higher. The code for this chapter can be found at: <a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04</span></a><span class="No-Break">.</span><a id="_idTextAnchor719"/><a id="_idTextAnchor720"/></p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor721"/>Introduction</h1>
			<p>In the previous chapter, we covered Go’s core types. These types are critical to everything you do in Go, but it can be challenging to model more complex data. In modern computer software, we want to be able to group data and logic where possible. We also want to be able to make our logic reflect the real-world solutions <span class="No-Break">we’re building.</span></p>
			<p>If you were building software for cars, you would ideally want a custom type that embodies a car. This type should be named “car” and it should have properties that can store information about what kind of car it is. The logic that affects the car, such as starting and stopping, should be associated with the car type. If we had to manage more than one car, we would need to be able to group all <span class="No-Break">the cars.</span></p>
			<p>In this chapter, we’ll learn about the features in Go that allow us to model the data part of this challenge. Then, in the next chapter, we’ll solve the behavior part. By using custom types, you can extend Go’s core types, and using structs allows you to compose a type made of other types and associate logic with them. Collections let you group data together and allow you to loop over and perform operations <span class="No-Break">on them.</span></p>
			<p>As the complexity of your tasks increases, Go’s complex types help you keep your code easy to understand and maintain. Collections such as arrays, slices, and maps allow you to keep related data grouped together. Go’s <strong class="source-inline">struct</strong> type allows you to create a single type that’s made up of other strings, numbers, and Booleans, giving you the power to build models of complex real-world concepts. Structs also allow you to attach logic to them; this allows you to have the logic that controls your models closely <span class="No-Break">tied together.</span></p>
			<p>When things get complicated with types, we need to know how to use type conversions and assertions to manage type mismatches correctly. We’ll also be looking at Go’s <strong class="source-inline">interface{}</strong> type. This type is almost magical in that it allows you to overcome Go’s struct typing system but in a way that’s <span class="No-Break">still type-safe.</span><a id="_idTextAnchor722"/><a id="_idTextAnchor723"/></p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor724"/>Collection types</h1>
			<p>If you were dealing with a single <a id="_idIndexMarker244"/>email address, you would define a string variable to hold that value for you. Now, think about how you would structure your code if you needed to deal with between 0 and 100 email addresses. You could define a separate variable for each email address, but Go has something else we <span class="No-Break">can use.</span></p>
			<p>When dealing with lots of similar data, we put it in a collection. Go’s collection types are arrays, slices, and maps. Go’s collection types are strongly typed and easy to loop over, but they each have unique qualities that mean they are better suited to different <span class="No-Break">use cases<a id="_idTextAnchor725"/><a id="_idTextAnchor726"/>.</span></p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor727"/>Arrays</h1>
			<p>Go’s most basic collection type is an<a id="_idIndexMarker245"/> array. When you define an array, you must specify what type of data it may contain and how big the array is in the following form: <strong class="source-inline">[&lt;size&gt;]&lt;type&gt;</strong>. For example, <strong class="source-inline">[10]int</strong> is an array of size 10 that contains integers, while <strong class="source-inline">[5]string</strong> is an array of size 5 that contains strings. The key to making this an array is specifying the size. If your definition didn’t have the size, it would seem like it works, but it would not be an array – it’d be a slice. A slice is a different, more flexible, type of collection that we’ll look at after arrays. You can set the element values to be any type, including pointers <span class="No-Break">and arrays.</span></p>
			<p>You can initialize arrays with data using the following form: <strong class="source-inline">[&lt;size&gt;]&lt;type&gt;{&lt;value1&gt;,&lt;value2&gt;,…&lt;valueN&gt;}</strong>. For example, <strong class="source-inline">[5]string{1}</strong> would initialize the array with the first value as 1, while <strong class="source-inline">[5]string{9,9,9,9,9}</strong> would fill the array with the value nine for each element. When initializing with data, you can have Go set the size of the array based on the number of elements you initialize it with. You can take advantage of this by replacing the length number with <strong class="source-inline">...</strong>. For example, <strong class="source-inline">[...]string{9,9,9,9,9}</strong> would create an array of length five because we initialized it with five elements. Just as with all arrays, the length is set at compile time and is not changeable <span class="No-Break">at runtim<a id="_idTextAnchor728"/><a id="_idTextAnchor729"/>e.</span></p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor730"/>Exercise 4.01 – Defining an array</h2>
			<p>In this exercise, we’re <a id="_idIndexMarker246"/>going to define a simple array of size ten that takes integers. Then, we’ll print out the contents. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import "fmt"</pre></li>				<li>Create a function that defines an array and then <span class="No-Break">return <a id="_idTextAnchor731"/><a id="_idTextAnchor732"/>it:</span><pre class="source-code">
func defineArray() [10]int {
  var arr [10]int
  return arr
}</pre></li>				<li>Define a <strong class="source-inline">main</strong> function, call the function, and print the result. We’ll use <strong class="source-inline">fmt.Printf</strong> with <strong class="source-inline">%#v</strong> to get extra details about the value, including <span class="No-Break">its ty<a id="_idTextAnchor733"/><a id="_idTextAnchor734"/>pe:</span><pre class="source-code">
func main() <a id="_idTextAnchor735"/>{
  fmt.Printf("%#v\n", defineArray())
}</pre></li>				<li>Save this. Then, from within the new folder, run <span class="No-Break">the following:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Running the preceding code provides us with the <span class="No-Break">following output:</span></p>
			<pre class="console">
[10]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}</pre>			<p>In this exercise, we’ve defined <a id="_idIndexMarker247"/>an array but haven’t filled it with any data. Since all arrays have a fixed size, when the array was printed out, it contained 10 values. These values are empty values for whatever type the <span class="No-Break">array acce<a id="_idTextAnchor736"/><a id="_idTextAnchor737"/>pts.</span></p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor738"/>Comparing arrays</h2>
			<p>The array’s <a id="_idIndexMarker248"/>length is part of its type definition. If you have two arrays that accept the same type but they’re different sizes, they are not compatible and aren’t comparable with each other. To compare arrays, they must be of both the same length (size) and the <span class="No-Break">same <a id="_idTextAnchor739"/><a id="_idTextAnchor740"/>type.</span></p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor741"/>Exercise 4.02 – Comparing arrays</h2>
			<p>In this exercise, we’ll <a id="_idIndexMarker249"/>compare arrays. First, we’ll define several arrays; some are comparable, while some are not. Then, we’ll run the code and fix any problems that come up. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import "fmt"</pre></li>				<li>Create a function that defines <span class="No-Break">four a<a id="_idTextAnchor742"/><a id="_idTextAnchor743"/>rrays:</span><pre class="source-code">
func compArrays() (bool, bool, bool) {
  var arr1 [5]int
  arr2 := [5]<a id="_idTextAnchor744"/><a id="_idTextAnchor745"/>int{0}
  arr3 := [...]int{0, 0, 0, 0, 0}
  arr4 := [9]int{0, 0, 0, 0, 9}</pre></li>				<li>Compare<a id="_idIndexMarker250"/> the arrays and return the result of the comparison. This closes off <span class="No-Break">this fu<a id="_idTextAnchor746"/><a id="_idTextAnchor747"/>nction:</span><pre class="source-code">
  return arr1 == arr2, arr1 == arr3, arr1 == arr4
}</pre></li>				<li>Define a <strong class="source-inline">main</strong> function so that it prints out <span class="No-Break">the r<a id="_idTextAnchor748"/><a id="_idTextAnchor749"/>esults:</span><pre class="source-code">
func main() {
  comp1, comp2, comp3 := compArrays()
  fmt.Println("[5]int == [5]int{0}       :", comp1)
  fmt.Println("[5]int == [...]int{0, 0, 0, 0, 0}:", comp2)
  fmt.Println("[5]int == [9]int{0, 0, 0, 0, 9} :", comp3)
}</pre></li>				<li>Save and run <span class="No-Break">the code:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Running the preceding code produces the <span class="No-Break">following o<a id="_idTextAnchor750"/>utput:</span></p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B18621_04_1.jpg" alt="Figure 4.1: Array type mismatch error" width="1552" height="128"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1: Array type mismatch error</p>
			<p class="list-inset">You should see an error. This error is telling you that <strong class="source-inline">arr1</strong>, which is a <strong class="source-inline">[5] int</strong> type, and <strong class="source-inline">arr4</strong>, which is a <strong class="source-inline">[9] int</strong> type, are not the same length arrays and therefore are not the same underlying type in Go, meaning they aren’t comparable. Let’s <span class="No-Break">fix that.</span></p>
			<ol>
				<li>Here, we<a id="_idIndexMarker251"/> have <span class="No-Break">the following:</span><pre class="source-code">
  arr4 := [9]int{0, 0, 0, 0, 9}</pre><p class="list-inset">We need to replace this with <span class="No-Break">the following:</span></p><pre class="source-code">  arr4 := [5]int{0, 0, 0, 0, 9}</pre></li>				<li>We also have the <span class="No-Break">following code:</span><pre class="source-code">
  fmt.Println("[5]int == [9]int{0, 0, 0, 0, 9} :", comp3)</pre><p class="list-inset">We need to replace this with <span class="No-Break">the following:</span></p><pre class="source-code">  fmt.Println("[5]int == [5]int{0, 0, 0, 0, 9} :", comp3)</pre></li>				<li>Save and run the code again using the <span class="No-Break">following command:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Running the preceding code produces the <span class="No-Break">following o<a id="_idTextAnchor751"/>utput:</span></p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B18621_04_2.jpg" alt="Figure 4.2: Output without error" width="576" height="110"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2: Output without error</p>
			<p>In our exercise, we defined some arrays, and they were all defined in slightly different ways. At first, we had an error because we tried to compare arrays of different lengths, which, in Go, means they are different types. We fixed that and ran the code again. Then, we could see that even though the first three arrays were defined using different methods, they ended up being the same or equal to each other. The last array, now with its type fixed, had different data contained in it, so it’s not the same or equal to the other arrays. The other collection types, that is, <strong class="source-inline">slice</strong> and <strong class="source-inline">map</strong>, are not comparable in this way. With<a id="_idIndexMarker252"/> maps and slices, you must loop over the contents of the two collections you’re comparing and compare them manually. This ability gives arrays an advantage if comparing data in collections is a hot path, or frequent operation, in <span class="No-Break">you<a id="_idTextAnchor752"/><a id="_idTextAnchor753"/>r code.</span></p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor754"/>Initializing arrays using keys</h2>
			<p>So far, when <a id="_idIndexMarker253"/>we’ve initialized our arrays with data, we’ve let Go<a id="_idIndexMarker254"/> choose the keys for us. Keys refer to the indices or positions used to initialize specific values in an array. By setting values at specific indices using keys, you can initialize an array with desired values at specific positions while leaving other elements at their default values. Go allows you to pick the key you want for your data using <strong class="source-inline">[&lt;size&gt;]&lt;type&gt;{&lt;key1&gt;:&lt;value1&gt;,…&lt;keyN&gt;:&lt;valueN&gt;}</strong>. Go is flexible and lets you set keys with gaps and in any order. This ability to set values with a key is helpful if you’ve defined an array where the numeric keys have a specific meaning, and you want to set a value for a specific key but don’t need to set any of the other values. Using keys when initializing arrays provides greater flexibility and control over the placement of values within <a id="_idTextAnchor755"/><a id="_idTextAnchor756"/><span class="No-Break">an array.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor757"/>Exercise 4.03 – Initializing an array using keys</h2>
			<p>In this exercise, we’ll <a id="_idIndexMarker255"/>initialize a few arrays using some keys to set specific<a id="_idIndexMarker256"/> values. Then, we’ll compare them to each other. After, we’ll print out one of the arrays and look at its contents. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import "fmt"</pre></li>				<li>Create a function that defines <span class="No-Break">th<a id="_idTextAnchor758"/><a id="_idTextAnchor759"/>ree arrays:</span><pre class="source-code">
func compArrays() (bool, bool, [10]int) {
  var arr1 [10]int
  // set key 9 to value 0
  arr2 := [...]int{9: 0}
  // set key 0 to value 1, set key 9 to value 10,
  // and set key 4 to value 5
  arr3 := [10]int{1, 9: 10, 4: 5}</pre></li>				<li>Compare the arrays and return the last one so that we can print it <span class="No-Break">o<a id="_idTextAnchor760"/><a id="_idTextAnchor761"/>ut later:</span><pre class="source-code">
  return arr1 == arr2, arr1 == arr3, arr3
}</pre></li>				<li>Create a <strong class="source-inline">main</strong> function and call <strong class="source-inline">compArrays</strong>. Then, print out <span class="No-Break">t<a id="_idTextAnchor762"/><a id="_idTextAnchor763"/>he results:</span><pre class="source-code">
func main() {
  comp1, comp2, arr3 := compArrays()
  fmt.Println("[10]int == [...]{9:0}       :", comp1)
  fmt.Println("[10]int == [10]int{1, 9: 10, 4: 5}}:", comp2)
  fmt.Println("arr3               :", arr3)
}</pre></li>				<li>Save the<a id="_idIndexMarker257"/> file. Then, in<a id="_idIndexMarker258"/> the new folder, run <span class="No-Break">the following:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Running the preceding code produces the <span class="No-Break">follo<a id="_idTextAnchor764"/>wing output:</span></p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B18621_04_3.jpg" alt="Figure 4.3: Array initialized using keys" width="1266" height="176"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3: Array initialized using keys</p>
			<p>In this exercise, we used keys when initializing the data for an array. For <strong class="source-inline">arr2</strong>, we combined the <strong class="source-inline">...</strong> shortcut with setting a key to make the array length directly relate to the key we set. With <strong class="source-inline">arr3</strong>, we mixed it using keys and without using keys to initialize the array, and we also used the keys out of order when setting key 0 to value 1, key 9 to value 10, and key 4 to value 5. Go’s flexibility <a id="_idIndexMarker259"/>when using keys is strong and makes using arrays in this<a id="_idIndexMarker260"/> <span class="No-Break">way pleasant.</span></p>
			<p>Now that we’ve looked at initializing arrays, let’s take a further look at reading<a id="_idTextAnchor765"/><a id="_idTextAnchor766"/> <span class="No-Break">their values.</span></p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor767"/>Reading from an array</h2>
			<p>So far, we’ve<a id="_idIndexMarker261"/> defined an array and initialized it with some data. Now, let’s read that data out. It’s possible to access a single element of the array using <strong class="source-inline">&lt;array&gt;[&lt;index&gt;]</strong>. For example, this accesses the first element of an array, <strong class="source-inline">arr[0]</strong>. I know 0 is the first element of the array because arrays always use a zero-indexed integer key. The zero index means the first index for an array is always 0 and the last index is always the array’s length <span class="No-Break">minus 1.</span></p>
			<p>The order of items in an array is guaranteed to be stable. Order stability means that an item placed at index 0 is always the first item in <span class="No-Break">the array.</span></p>
			<p>Being able to access specific parts of an array can be helpful in a few ways. It’s often necessary to validate the data in an array by checking either the first and/or last elements. Sometimes, the position of the data in an array is important so that you know you can get, for example, a product’s name from the third index. This positional significance is common when reading <strong class="bold">comma-separated value</strong> (<strong class="bold">CSV</strong>) files<a id="_idIndexMarker262"/> or other similar delimiter-separated value files. CSV is still in common use as it is a popular choice for exporting data from <span class="No-Break">spread<a id="_idTextAnchor768"/><a id="_idTextAnchor769"/>sheet documents.</span><a id="_idTextAnchor770"/></p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor771"/>Exercise 4.04 – Reading a single item from an array</h2>
			<p>In this <a id="_idIndexMarker263"/>exercise, we’ll define an array and initialize it<a id="_idIndexMarker264"/> with some words. Then, we’ll read the words out in the form of a message and print it. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import "fmt"</pre></li>				<li>Create a function that defines an array with words. The order of the w<a id="_idTextAnchor772"/><a id="_idTextAnchor773"/>ords <span class="No-Break">is important:</span><pre class="source-code">
func message() string {
  arr := [...]<a id="_idTextAnchor774"/><a id="_idTextAnchor775"/>string{
   "ready",
   "Get",
   "Go",
   "to",
  }</pre></li>				<li>Now, create <a id="_idIndexMarker265"/>a message by joining the words in a specific <a id="_idIndexMarker266"/>order and returning it. We’re using the <strong class="source-inline">fmt.Sprintln</strong> function here since it allows us to capture the formatted text <a id="_idTextAnchor776"/><a id="_idTextAnchor777"/>before <span class="No-Break">it’s printed:</span><pre class="source-code">
  return fmt.Sprintln(arr[1], arr[0], arr[3], arr[2])
}</pre></li>				<li>Create our <strong class="source-inline">main()</strong> function, call the <strong class="source-inline">message</strong> function, and print it to <span class="No-Break">the co<a id="_idTextAnchor778"/>nsole:</span><pre class="source-code">
func main() {
  fmt.Print(message())
}</pre></li>				<li>Save and run <span class="No-Break">the code:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Running the <a id="_idIndexMarker267"/>preceding code produces<a id="_idIndexMarker268"/> the <span class="No-Break">following output:</span></p>
			<pre class="console">
Get ready to Go</pre>			<p>We now understand how to access specific elements in an array using indices. Next, we will explor<a id="_idTextAnchor779"/><a id="_idTextAnchor780"/>e writing to <span class="No-Break">an array.</span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor781"/>Writing to an array</h2>
			<p>Once an array is <a id="_idIndexMarker269"/>defined, you’re able to make changes to individual elements using its index using <strong class="source-inline">&lt;array&gt;[&lt;index&gt;] = &lt;value&gt;</strong>. This assignment works the same as it does for other types <span class="No-Break">of variables.</span></p>
			<p>In real-world code, you often need to modify the data in your collections after it has been defined ba<a id="_idTextAnchor782"/><a id="_idTextAnchor783"/>sed on inputs <span class="No-Break">or<a id="_idTextAnchor784"/> logic.</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor785"/>Exercise 4.05 – Writing to an array</h2>
			<p>In this exercise, we’ll define an array and initialize it with some words. Then, we’ll make some changes to the words. Finally, we’ll read the words out to form a message and print it. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import "fmt"</pre></li>				<li>Create a function that defines an array with words. The order of <a id="_idTextAnchor786"/><a id="_idTextAnchor787"/>the words <span class="No-Break">is important:</span><pre class="source-code">
func message() string {
  arr := [4]string{"ready", "Get", "Go", "to"}</pre></li>				<li>We’ll change some of the words in the array by assigning new values using an array index. The order this is <a id="_idTextAnchor788"/><a id="_idTextAnchor789"/>done in <span class="No-Break">doesn’t matter:</span><pre class="source-code">
  arr[1] = "It’s"
  arr[0] = "time"</pre></li>				<li>Now, create a message by joining the words in a specif<a id="_idTextAnchor790"/><a id="_idTextAnchor791"/>ic order and <span class="No-Break">return it:</span><pre class="source-code">
  return fmt.Sprintln(arr[1], arr[0], arr[3], arr[2])
}</pre></li>				<li>Create our <strong class="source-inline">main()</strong> function, call the <strong class="source-inline">message</strong> function, and print it to <span class="No-Break">the<a id="_idTextAnchor792"/> console:</span><pre class="source-code">
func main() {
  fmt.Print(message())
}</pre></li>				<li>Save and run <span class="No-Break">the code:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Running the preceding<a id="_idIndexMarker270"/> code produces the <span class="No-Break">following output:</span></p>
			<pre class="console">
It’s time to Go</pre>			<p>You now know the basics when it comes to initializing, reading, and writing to an array using an index. Knowing that arrays contain multiple values, let’s peek at ho<a id="_idTextAnchor793"/><a id="_idTextAnchor794"/>w to loop over <span class="No-Break">an array.</span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor795"/>Looping over an array</h2>
			<p>The most<a id="_idIndexMarker271"/> common way you’ll work with arrays is by using them in loops. Due to the way an array’s indexes work, they are easy to loop over. The index always starts at 0, there are no gaps, and the last element is the array’s length, <span class="No-Break">minus 1.</span></p>
			<p>Because of this, it’s also common to use a loop where we create a variable to represent the index and increment it manually. This type of loop is often called a <strong class="source-inline">for i</strong> loop since <strong class="source-inline">i</strong> is the name that’s given to the index variable. </p>
			<p class="callout-heading">Note </p>
			<p class="callout">You can use a different letter than <strong class="source-inline">i</strong>; however, <strong class="source-inline">i</strong> is very representative of the word index in the case of looping an array and thereby represents idiomatic <span class="No-Break">Go stylistically.</span></p>
			<p>As you’ll <a id="_idIndexMarker272"/>remember from the previous chapter, a <strong class="source-inline">for</strong> loop has three possible parts: the logic that can run before the loop, the logic that runs on each loop interaction to check whether the loop should continue, and the logic that runs at the end of each loop iteration. A <strong class="source-inline">for i</strong> loop looks like this: <strong class="source-inline">i := 0; i &lt; len(arr); i++ {</strong>. What happens is that we define <strong class="source-inline">i</strong> to be zero, which also means <strong class="source-inline">i</strong> only exists in the scope of the loop. Then, <strong class="source-inline">i</strong> is checked on the loop’s iteration to ensure it’s less than the length of the array. We check that it’s less than the length of the array since the length is always 1 more than the last index key. Lastly, we increment <strong class="source-inline">i</strong> by 1 on each loop to let us step over each element in the array, one by one, until we’ve reached the length of <span class="No-Break">the array.</span></p>
			<p>When it comes to the length of an array, it can be tempting to hardcode the value of the last index instead of using <strong class="source-inline">len</strong> since you know the length of your array is always the same. Hardcoding length is a bad idea. Hardcoding would make your code harder to maintain. It’s common for your data to change and evolve. If you ever need to come back and change the size of an array, having hardcoded array lengths introduces hard-to-find bugs and even runtime panics. In Go, a runtime panic is essentially an event that occurs when the program encounters an exceptional situation it cannot or should not recover from. When a panic is triggered, the program will <span class="No-Break">terminate immediately.</span></p>
			<p>Using loops with arrays allows you to repeat the same logic for every element – that is, validating the data, modifying the data, or outputting the data – without having to duplicate the same co<a id="_idTextAnchor796"/><a id="_idTextAnchor797"/>de for <span class="No-Break">multiple variables.</span></p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor798"/>Exercise 4.06 – Looping over an array using a “for i” loop</h2>
			<p>In this exercise, we’ll <a id="_idIndexMarker273"/>define an array and initialize it with some <a id="_idIndexMarker274"/>numbers. We’ll loop over the numbers and do an operation on each one, putting the result in a message. Then, we’ll return the message and print it. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import "fmt"</pre></li>				<li>Create a function. We’ll define an array with data and an<a id="_idTextAnchor799"/><a id="_idTextAnchor800"/> <strong class="source-inline">m</strong> variable before <span class="No-Break">the loop:</span><pre class="source-code">
func message() string {
  m := ""
  arr := [4]int{1,2,3,4}</pre></li>				<li>Define the start of the loop. This manag<a id="_idTextAnchor801"/>es the index and <span class="No-Break">the loop:</span><pre class="source-code">
  for i := 0; i &lt; len(arr); i++ {</pre></li>				<li>Then, write the body of the loop, which does an operation on each element of the array<a id="_idTextAnchor802"/> and adds it to <span class="No-Break">the message<a id="_idTextAnchor803"/>:</span><pre class="source-code">
   arr[i] = arr[i] * arr[i]
   m += fmt.Sprintf("%v: %v\n", i, arr[i])</pre></li>				<li>Now, close the loop, return the mess<a id="_idTextAnchor804"/><a id="_idTextAnchor805"/>age, and close <span class="No-Break">the function:</span><pre class="source-code">
  }
  return m
}</pre></li>				<li>Create our <strong class="source-inline">main</strong> function, call the <strong class="source-inline">message</strong> function, and print it to <span class="No-Break">the console:</span><pre class="source-code">
func main() {
  fmt.Print(message())
}</pre></li>				<li>Save this <a id="_idIndexMarker275"/>code. Then, from the new folder, run<a id="_idIndexMarker276"/> <span class="No-Break">the code:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Running the preceding code produces the following output after looping over the array using the <strong class="source-inline">for i</strong> loop and multiplying the values <span class="No-Break">times themselves:</span></p>
			<pre class="console">
0: 1
1: 4
2: 9
3: 16</pre>			<p>A <strong class="source-inline">for i</strong> loop <a id="_idIndexMarker277"/>is very common, so pay close attention to the <strong class="source-inline">for</strong> loop, and <a id="_idIndexMarker278"/>be sure to understand what each of the three parts <span class="No-Break">is doing.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="bold">Using len in a loop</strong>: In other<a id="_idIndexMarker279"/> languages, it’s not efficient to count the number of elements on each iteration of a loop. In Go, it’s okay. The Go runtime tracks the length of the array internally, so it doesn’t count the items when you call <strong class="source-inline">len</strong>. This feature is also true for the other collecti<a id="_idTextAnchor806"/><a id="_idTextAnchor807"/>on types; that is, slice <span class="No-Break">and map.</span></p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor808"/>Modifying the contents of an array in a loop</h2>
			<p>In addition to<a id="_idIndexMarker280"/> reading from an array in a loop, you can also change the contents of the array in a loop. Working with the data in each element works like working with variables. You use the same <strong class="source-inline">for i</strong> <span class="No-Break">loops too.</span></p>
			<p>Just as with reading data from arrays, being able to change data in collections reduces the amount of code you need to write if each e<a id="_idTextAnchor809"/><a id="_idTextAnchor810"/>lement were a <span class="No-Break">standalone variable.</span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor811"/>Exercise 4.07 – Modifying the contents of an array in a loop</h2>
			<p>In this exercise, we’re going to define an empty array, fill it with data, and then modify that data. Finally, we’ll print the filled and modified array to the console. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import "fmt"</pre></li>				<li>Create a function that fills a<a id="_idTextAnchor812"/><a id="_idTextAnchor813"/>n array with numbers from 1 <span class="No-Break">to 10:</span><pre class="source-code">
func fillArray(arr [10]int) [10]int {
  for i := 0; i &lt; len(arr); i++ {
   arr[i] = i + 1
  }
  return arr
}</pre></li>				<li>Create a function that multiples the number from an array by itself and then <a id="_idTextAnchor814"/><a id="_idTextAnchor815"/>sets the result back to <span class="No-Break">the array:</span><pre class="source-code">
func opArray(arr [10]int) [10]int {<a id="_idTextAnchor816"/><a id="_idTextAnchor817"/>
  for i := 0; i &lt; len(arr); i++ {
    arr[i] = arr[i] * arr[i]
  }
  return arr
}</pre></li>				<li>In our <strong class="source-inline">main()</strong> function, we <a id="_idIndexMarker281"/>need to define our empty array, fill it, modify it, and then<a id="_idTextAnchor818"/><a id="_idTextAnchor819"/> print its contents to <span class="No-Break">the console:</span><pre class="source-code">
func main() {
  var arr [10]int
  arr = fillArray(arr)
  arr = opArray(arr)
  fmt.Println(arr)
}</pre></li>				<li>Save this code. Then, from the new folder, run <span class="No-Break">the code:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Running the <a id="_idIndexMarker282"/>preceding code produces the <span class="No-Break">following output:</span></p>
			<pre class="console">
[1 4 9 16 25 36 49 64 81 100]</pre>			<p>Working with data in arrays is simple once you’ve understood how to use them in a <strong class="source-inline">for i</strong> loop. One nice thing about working with arrays over other collections is their fixed length. With arrays, it’s not possible to accidentally change the size of the array and end up in an infinite loop, which is a loop that can’t end and results in software that runs fo<a id="_idTextAnchor820"/><a id="_idTextAnchor821"/>rever while usin<a id="_idTextAnchor822"/>g lots <span class="No-Break">of resources.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor823"/>Activity 4.01 – Filling an array</h2>
			<p>In this activity, we’re <a id="_idIndexMarker283"/>going to define an array and fill it using a <strong class="source-inline">for i</strong> loop. The following are the steps for <span class="No-Break">this activity:</span></p>
			<ol>
				<li>Create a new <span class="No-Break">Go program.</span></li>
				<li>Define an array with <span class="No-Break">10 elements.</span></li>
				<li>Use a <strong class="source-inline">for i</strong> loop to fill that array with the numbers 1 <span class="No-Break">through 10.</span></li>
				<li>Use <strong class="source-inline">fmt.Println</strong> to print the array to <span class="No-Break">the console.</span></li>
			</ol>
			<p>The expected output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
[1 2 3 4 5 6 7 8 9 10]</pre>			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found in<a id="_idTextAnchor824"/><a id="_idTextAnchor825"/> the GitHub repository folder for this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.01"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.01</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor826"/>Slices</h1>
			<p>Arrays are great, but their rigidity <a id="_idIndexMarker284"/>around size can cause issues. If you wanted to create a function that accepted an array and sorted the data in it, it could only work for one size of an array. That requires you to create a function for each size of an array. This strictness around size makes working with arrays feel like a hassle and unengaging. The flip side of arrays is that they are an efficient way of managing sorted collections of data. Wouldn’t it be great if there were a way to get the efficiency of arrays but with more flexibility? Go gives you this in the form <span class="No-Break">of slices.</span></p>
			<p>A<a id="_idIndexMarker285"/> slice is a thin layer around arrays that lets you have a sorted numeric indexed collection without having to worry about the size. Underneath the thin layer is still a Go array, but Go manages all the details, such as how big an array to use. You use a slice just like you would an array; it only holds values of one type, you can read and write to each element using <strong class="source-inline">[</strong> and <strong class="source-inline">]</strong>, and they are easy to loop over using <strong class="source-inline">for </strong><span class="No-Break"><strong class="source-inline">i</strong></span><span class="No-Break"> loops.</span></p>
			<p>The other thing a slice can do is be easily expanded using the built-in <strong class="source-inline">append</strong> function. This function accepts your slice and the values you’d like to add and returns a new slice with everything merged. It’s common to start with an empty slice and expand it <span class="No-Break">as needed.</span></p>
			<p>Since a slice is a thin layer around an array, this means it’s not a true type like an array. You need to understand how Go uses the hidden array behind a slice. If you don’t, it’ll lead to subtle and <span class="No-Break">difficult-to-debug errors.</span></p>
			<p>In real-world code, you should be using slices as your go-to for all sorted collections. You’ll be more productive because you won’t need to write as much code as you would with an array. Most code you’ll see in real-world projects uses lots of slices and rarely uses arrays. Arrays are only used when the size needs to be exactly a certain length, and even then, slices get used most of the time as they can<a id="_idTextAnchor827"/><a id="_idTextAnchor828"/> be passed around the code <span class="No-Break">more easily.</span></p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor829"/>Exercise 4.08 – Working with slices</h2>
			<p>In this exercise, we’ll show you <a id="_idIndexMarker286"/>how flexible slices are by reading some data from a slice, passing a slice to a function, looping over a slice, reading values from a slice, and appending values to the end of a slice. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import (
  "fmt"
  "os"
)</pre></li>				<li>Create a<a id="_idIndexMarker287"/> function that takes an<a id="_idTextAnchor830"/> <strong class="source-inline">int</strong> argument and returns a <span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break"> slice:</span><pre class="source-code">
func getPassedArgs(minArgs int) []string {</pre></li>				<li>In the function’s body, check if we have the correct number of arguments being passed in through the command line. If not, we exit the program with an error. When we run our program from the command line, Go automatically places all arguments i<a id="_idTextAnchor831"/><a id="_idTextAnchor832"/>nto <strong class="source-inline">os.Args</strong>, which is a slice <span class="No-Break">of strings:</span><pre class="source-code">
  if len(os.Args) &lt; minArgs {
    fmt.Printf("At least %v arguments are needed\n", minArgs)
    os.Exit(1)
  }</pre></li>				<li>The first element of the <strong class="source-inline">os.Args</strong> slice, <strong class="source-inline">os.Args[0]</strong>, is how the code is called and not an argument, so we’ll skip <a id="_idTextAnchor833"/><a id="_idTextAnchor834"/>that and start our <strong class="source-inline">for i</strong> loop at <span class="No-Break">index 1:</span><pre class="source-code">
  var args []string
  for i := 1; i &lt; len(os.Args); i++ {
    args = append(args, os.Args[<a id="_idTextAnchor835"/><a id="_idTextAnchor836"/>i])
  }</pre></li>				<li>Then, we’ll return <span class="No-Break">the arguments:</span><pre class="source-code">
  return args
}</pre></li>				<li>Now, create a function that loops over a slice and finds the longest string. When two words are of the<a id="_idTextAnchor837"/><a id="_idTextAnchor838"/> same length, the first word <span class="No-Break">is returned:</span><pre class="source-code">
func findLongest(args []string) string {
  var longest string
  for i := 0; i &lt; len(args); i++ {
    if len(args[i]) &gt; len(longest) {
      longest = args[i]
       }
  }
  return longest
}</pre></li>				<li>In the <strong class="source-inline">main()</strong> function, we <a id="_idIndexMarker288"/>call the functions and check for errors. If there is an error, we tell the user then terminate the program with <strong class="source-inline">os.Exit(1)</strong>, which also ret<a id="_idTextAnchor839"/><a id="_idTextAnchor840"/>urns error code 1 to the <span class="No-Break">operating system:</span><pre class="source-code">
func main() {  
 if longest := findLongest(getPassedArgs(3)); len(longest) &gt; 0 {
     fmt.Println("The long<a id="_idTextAnchor841"/><a id="_idTextAnchor842"/>est word passed was:", longest)
  } else {<a id="_idTextAnchor843"/>
    fmt.Println("There was an error")
    os.Exit(1)
  }
}</pre></li>				<li>Save the file. Then, in the folder it’s saved in, run the code using the <span class="No-Break">following command:</span><pre class="source-code">
go run . Get ready to Go</pre></li>			</ol>
			<p>Running the<a id="_idIndexMarker289"/> preceding code produces the <span class="No-Break">following output:</span></p>
			<pre class="console">
The longest word passed was: ready</pre>			<p>In this exercise, we were able to see how flexible slices are and, at the same time, how they work just like arrays. This way of working with slices is another reason<a id="_idTextAnchor844"/><a id="_idTextAnchor845"/><a id="_idTextAnchor846"/> why Go has the feel of a <span class="No-Break">dynamic language.</span></p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor847"/>Appending multiple items to a slice</h2>
			<p>The built-in <strong class="source-inline">append</strong> function can <a id="_idIndexMarker290"/>add more than one value to a slice. You <a id="_idIndexMarker291"/>can add as many parameters to <strong class="source-inline">append</strong> as you need since the last parameter is variadic. Since it’s variadic, this means that you can also use the <strong class="source-inline">...</strong> notation to use a slice as the variadic parameter, allowing you to pass an arbitrary number of arguments <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">append</strong></span><span class="No-Break">.</span></p>
			<p>Being able to pass more than one argument to <strong class="source-inline">append</strong> comes up all the time in real-world code, and having it keeps Go code compact by not requiring mu<a id="_idTextAnchor848"/><a id="_idTextAnchor849"/>ltiple calls or <a id="_idTextAnchor850"/>loops to add <span class="No-Break">multiple values.</span></p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor851"/>Exercise 4.09 – Appending multiple items to a slice</h2>
			<p>In this exercise, we’ll use the variadic parameter of <strong class="source-inline">append</strong> to add multiple values in the form of predefined data to a slice. Then, we’ll add a dynamic amount of data based on user input to the same slice. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import (
  "fmt"
  "os"
)<a id="_idTextAnchor852"/><a id="_idTextAnchor853"/></pre></li>				<li>Create a function to safely grab <span class="No-Break">user input:</span><pre class="source-code">
func getPassedArgs() []string {
  var args []string
  for i := 1; i &lt; len(os.Args); i++ {
    args = append(args, os.Args[i])
  }
  return args
}</pre></li>				<li>Create a<a id="_idIndexMarker292"/> function that accepts a slice of strings as a<a id="_idIndexMarker293"/> parameter and returns a slice of str<a id="_idTextAnchor854"/><a id="_idTextAnchor855"/>ings. Then, define a slice of <span class="No-Break"><strong class="source-inline">strings</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
func getLocales(extraLocales []string) []string {
  var locales []string</pre></li>				<li>Ad<a id="_idTextAnchor856"/>d multiple strings to the slice <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">append</strong></span><span class="No-Break">:</span><pre class="source-code">
  locales = append(locales, "en_<a id="_idTextAnchor857"/>US", "fr_FR")</pre></li>				<li>Add more data from <span class="No-Break">the parameter:</span><pre class="source-code">
  locales = append(locales, extraLocales...)</pre></li>				<li>Return <a id="_idTextAnchor858"/><a id="_idTextAnchor859"/>the variable and close the <span class="No-Break">function definition:</span><pre class="source-code">
  return locales
}</pre></li>				<li>In the <strong class="source-inline">main()</strong> function, get the user input, pass<a id="_idTextAnchor860"/><a id="_idTextAnchor861"/> it to our function, and then print <span class="No-Break">the result:</span><pre class="source-code">
func main() {
  locales := getLocales(getPassedArgs())
  fmt.Println("Locales to use:", locales)
}</pre></li>				<li>Save the file. Then, in the folder you created in <em class="italic">st<a id="_idTextAnchor862"/>ep 1</em>, run the code using the <span class="No-Break">following command:</span><pre class="source-code">
go run . fr_CN en_AU</pre></li>			</ol>
			<p>Running the <a id="_idIndexMarker294"/>preceding <a id="_idIndexMarker295"/>code produces the <span class="No-Break">following output:</span></p>
			<pre class="console">
Locales to use: [en_US fr_FR fr_CN en_AU]</pre>			<p>In this exercise, we used two methods of adding multiple values to a slice. You would also use this technique if you needed to join two <span class="No-Break">slices together.</span></p>
			<p>While appending a slice like this to add it to another slice may seem inefficient, the Go runtime can spot when you’re doing an explode in an append and optimizes the call in <a id="_idTextAnchor863"/><a id="_idTextAnchor864"/><a id="_idTextAnchor865"/>the background to ensure no resources <span class="No-Break">get wasted.</span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor866"/>Creating slices from slices and arrays</h2>
			<p>By using a similar notation to accessing a single element in an array or a slice, you can create new slices derived from the contents of arrays and slices. The most common notation is <strong class="source-inline">[&lt;low&gt;:&lt;high&gt;]</strong>. This notation tells Go to create a new slice with the same value type as the source slice or array and to populate the new slice with values by starting at the low index and then going up to, but not including, the high index. Low and high are optional. If you omitted low, then Go defaults to the first element in the source. If you omit high, then it goes all the way to the last value. It’s possible to skip both, and if you do, then the new slice has all the values from <span class="No-Break">the source.</span></p>
			<p>When you create new slices this way, Go doesn’t copy the values. If the source is an array, then that source array is the hidden array for the new slice. If the source is a slice, then the hidden array for the new slice is the same hidden array the source <span class="No-Break">slice uses.</span></p>
			<p>This is an important concept because modifying <em class="italic">ANY</em> slice also changes the underlying array, not a copy of it. Thin<a id="_idTextAnchor867"/><a id="_idTextAnchor868"/>k of a slice as <a id="_idTextAnchor869"/>a “view” of the <span class="No-Break">underlying array.</span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor870"/>Exercise 4.10 – Creating slices from a slice</h2>
			<p>In this exercise, we’ll use the <a id="_idIndexMarker296"/>slice range notation to create slices with a variety of initial values. Commonly, in real-world code, you need to work with only a small part of a slice or an array. The <strong class="source-inline">range</strong> notation is a quick and straightforward way of getting only the data you need. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create <a id="_idIndexMarker297"/>a new folder and add a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import "fmt"</pre></li>				<li>Create <a id="_idTextAnchor871"/><a id="_idTextAnchor872"/>a function and define a slice with nine <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> values:</span><pre class="source-code">
func message() string {
  s := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}</pre></li>				<li>We’ll extract the first value, first directly as an <strong class="source-inline">int</strong> value, then as a slice using both low and high, and finally using just high and skipping<a id="_idTextAnchor873"/> low. We’ll write the values to a <span class="No-Break">message string:</span><pre class="source-code">
  m := fmt.Sprintln("First :", s[0], s[0:1], s[:1])</pre></li>				<li>Now, we’ll get the last element. To get the <strong class="source-inline">int</strong> value, we’ll use the length and subtract 1 from the index. We use that same logic when setting the low for the range notation. For high, we can use the length of the slice. Finally, w<a id="_idTextAnchor874"/>e can see we can skip high and get the <span class="No-Break">same result:</span><pre class="source-code">
  m += fmt.Sprintln("Last  :", s[len(s)-1], s[len(s)-1:len(s)], s[len(s)-1:])</pre></li>				<li>Now, let’s get<a id="_idTextAnchor875"/> the first five values and add them to <span class="No-Break">the message:</span><pre class="source-code">
  m += fmt.Sprintln("First 5 :", s[:5])</pre></li>				<li>Next, we’ll get the last<a id="_idTextAnchor876"/> four values and add them to the message <span class="No-Break">as well:</span><pre class="source-code">
  m += fmt.Sprintln("Last 4 :", s[5:])</pre></li>				<li>Finally, we’ll extract five values from the mid<a id="_idTextAnchor877"/>dle of the slice and get them in the <span class="No-Break">message too:</span><pre class="source-code">
  m += fmt.Sprintln("Middle 5:", s[2:7])</pre></li>				<li>The<a id="_idTextAnchor878"/><a id="_idTextAnchor879"/>n, we’ll return the message and close <span class="No-Break">the function:</span><a id="_idTextAnchor880"/><a id="_idTextAnchor881"/><pre class="source-code">
  return m
}</pre></li>				<li>In <strong class="source-inline">main</strong>, we’ll print the <span class="No-Break">message out:</span><pre class="source-code">
func main() {
  fmt.Print(message())
}</pre></li>				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the <span class="No-Break">following command:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Running<a id="_idTextAnchor882"/> the<a id="_idIndexMarker298"/> preceding code produces the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B18621_04_5.jpg" alt="Figure 4.5: Output after creating slices from a slice" width="1042" height="172"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5: Output after creating slices from a slice</p>
			<p>In this exercise, we tried out a few ways to create slices from another slice. You can also use these same techniques on an array as the source. We saw that both start and stop indexes are optional. If you don’t have a start index, it’ll start at the beginning of the source slice or array. If you don’t have a stop index, then it’ll stop at the end of the array. If you skip both start and stop indexes, it’ll make a copy of the slice or array. This trick is useful for turning an array into a slice but not helpful for copying slices <a id="_idTextAnchor883"/><a id="_idTextAnchor884"/>because the two slices share the same <span class="No-Break">hidden array.</span></p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor885"/>Understanding slice internals</h2>
			<p>Slices are great and should be your <a id="_idIndexMarker299"/>go-to when you need an ordered list, but if you don’t know how they work under the hood, they cause <span class="No-Break">hard-to-spot bugs.</span></p>
			<p>An array<a id="_idIndexMarker300"/> is a value type that’s <a id="_idIndexMarker301"/>like a <strong class="source-inline">string</strong> or an <strong class="source-inline">int</strong> type. Value types can be copied and compared to themselves. These value types, once copied, are not connected to their source values. Slices don’t work like value types; they work more like pointers, but they are also <span class="No-Break">not pointers.</span></p>
			<p>The key to staying safe with a slice is to understand that there is a hidden array that stores the values and that making changes to the slice changes the underlying array. These changes may or may not require that the hidden array be replaced with a bigger one. The fact that the management of the hidden array happens in the background is what makes it hard to reason well about what’s going on with <span class="No-Break">your slices.</span></p>
			<p>Slices have three hidden properties: length, a pointer to the hidden array, and wherein the hidden array its starting point is. When you append to a slice, one or all of these properties get updated. Which properties get updated depends on whether the hidden array is full <span class="No-Break">or not.</span></p>
			<p>The size of the hidden array and the size of the slice are not always the same. The size of the slice is its length, which we can find out by using the <strong class="source-inline">len</strong> built-in function. The size of the hidden array is the capacity of the slice. There is also a built-in function that tells you the capacity of a slice; that is, <strong class="source-inline">cap</strong>. When you add a new value to a slice using <strong class="source-inline">append</strong>, one of two things happens: if the slice has extra capacity – that is, the hidden array is not full yet – it adds the value to the hidden array and then updates the slice’s length property. If the hidden array is full, Go creates a new, larger, array. Go then copies all the values from the old array into the new array and adds the new value too. Then, Go updates the slice from pointing to the old array to the new array and updates the length of the slice and, possibly, its <span class="No-Break">starting point.</span></p>
			<p>The starting point only comes into play if the slice is a subset of values from an array or a slice not starting at the first element, as in our example, where we got the last five elements of a slice. The rest of the time, it’ll be the first element in the <span class="No-Break">hidden array.</span></p>
			<p>It’s possible to control the size<a id="_idIndexMarker302"/> of the hidden array when you define a slice. Go’s built-in <strong class="source-inline">make</strong> function allows you to set the length and capacity of a slice when creating it. The syntax looks like this: <strong class="source-inline">make(&lt;sliceType&gt;, &lt;length&gt;, &lt;capacity&gt;)</strong>. When creating a slice using <strong class="source-inline">make<a id="_idTextAnchor886"/><a id="_idTextAnchor887"/></strong>, the capacity is optional, but the length <span class="No-Break">is required.</span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor888"/>Exercise 4.11 – Using make to control the capacity of a slice</h2>
			<p>In this exercise, using<a id="_idIndexMarker303"/> the <strong class="source-inline">make</strong> function, we’ll create several slices and display their length and capacity. Let’s <span class="No-Break">get started:</span><a id="_idTextAnchor889"/><a id="_idTextAnchor890"/><a id="_idTextAnchor891"/><a id="_idTextAnchor892"/><a id="_idTextAnchor893"/><a id="_idTextAnchor894"/></p>
			<ol>
				<li>Create a new folder and add a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
impor<a id="_idTextAnchor895"/>t "fmt"</pre></li>				<li>Create a function that returns three <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> slices:</span><pre class="source-code">
func genSlices() ([]int, <a id="_idTextAnchor896"/>[]int, []int) {</pre></li>				<li>Define a slice using the <span class="No-Break"><strong class="source-inline">var</strong></span><span class="No-Break"> notation:</span><pre class="source-code">
  var s1 <a id="_idTextAnchor897"/>[]int</pre></li>				<li>Define a slice using <strong class="source-inline">make</strong> and set only <span class="No-Break">the length:</span><pre class="source-code">
  s2 := make([]int, 10)</pre></li>				<li>Define a sli<a id="_idTextAnchor898"/>ce that uses both the length and capacity of <span class="No-Break">the slices:</span><pre class="source-code">
  s3 := make([]int, 10, 50)</pre></li>				<li>Return the three slices and close the <span class="No-Break">function definition:</span><pre class="source-code">
  return s1, s2, s3
}</pre></li>				<li>In the <strong class="source-inline">main()</strong> function, call the function we created and capture the returned values. For e<a id="_idTextAnchor899"/><a id="_idTextAnchor900"/>ach slice, print its length and capacity to <span class="No-Break">the console:</span><pre class="source-code">
func main() {
  s1, s2, s3 := genSlices()
  fmt.Printf("s1: len = %v cap = %v\n", len(s1), cap(s1))
  fmt.Printf("s2: len = %v cap = %v\n", len(s2), cap(s2))
  fmt.Printf("s3: len = %v cap = %v\n", len(s3), cap(s3))
}</pre></li>				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the <span class="No-Break">following command:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Ru<a id="_idTextAnchor901"/>nning the preceding code produces the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B18621_04_6.jpg" alt="Figure 4.6: Output displaying slices" width="546" height="106"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6: Output displaying slices</p>
			<p>In this exercise, we <a id="_idIndexMarker304"/>used <strong class="source-inline">make</strong>, <strong class="source-inline">len</strong>, and <strong class="source-inline">cap</strong> to control and displ<a id="_idTextAnchor902"/>ay the length and capacity of a slice when <span class="No-Break">defining one.</span></p>
			<p>If you already know the maximum size your slice will need, setting the capacity upfront can improve performance because Go won’t have<a id="_idTextAnchor903"/><a id="_idTextAnchor904"/> to spend extra resources resizing the <span class="No-Break">underlying array.</span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor905"/>Background behavior of slices</h2>
			<p>Due to the<a id="_idIndexMarker305"/> complexity of what a slice is and how it works, you can’t directly compare slices to one another. If you try, Go gives you an error. You can compare a slice to nil, but <span class="No-Break">that’s it.</span></p>
			<p>A slice is not a value, and it’s not a pointer, so what is it? A slice is a special construct in Go. A slice doesn’t store its own values directly. In the background, it’s using an array that you can’t access directly. What a slice does store is a pointer to that hidden array, its own starting point in that array, how long the slice is, and what the capacity of the slice is. These values provide slices with a window for the hidden array. The window can be the whole hidden array or just a smaller portion of it. The pointer to the hidden array can be shared by more than one slice. This pointer sharing can result in multiple slices that can share the same hidden array, even though not all the slides contain the same data. This means that one of the slices can have more data than the <span class="No-Break">other slices.</span></p>
			<p>When a slice needs to grow beyond its hidden array, it creates a new bigger array, copies the contents from the old array to the new one, and points the slice at the new array. This array swap is why our preceding slices became disconnected. At first, they were pointing to the same hidden array, but when we grow the first slice, the array it’s pointing to changes. This change means that changes to the grown slice no longer affect the other slices since they are still pointing to the old, <span class="No-Break">smaller, array.</span></p>
			<p>If you need to make a copy of a slice and need to be sure they are not connected, you have a few choices. You can use <strong class="source-inline">append</strong> to copy the contents of the source slice into another array or use the built-in <strong class="source-inline">copy</strong> function. When using <strong class="source-inline">copy</strong>, Go won’t change the size of the <a id="_idIndexMarker306"/>destination slice, so be sure<a id="_idTextAnchor906"/><a id="_idTextAnchor907"/> it has enough r<a id="_idTextAnchor908"/>oom for all the elements you want <span class="No-Break">to copy.</span></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor909"/>Exercise 4.12 – Controlling internal slice behavior</h2>
			<p>In this exercise, we’re going <a id="_idIndexMarker307"/>to explore five different ways to copy data from slice to slice and how that has an impact on a slice’s internal behavior. Let’s <span class="No-Break">get start<a id="_idTextAnchor910"/><a id="_idTextAnchor911"/>ed:</span></p>
			<ol>
				<li>Create a new folder and add a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import "fmt"</pre></li>				<li>Create a function that returns three <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> values:</span><pre class="source-code">
func linked() (int, int, int) {</pre></li>				<li>Define an <strong class="source-inline">int</strong> slice, initialized with <span class="No-Break">some data:</span><pre class="source-code">
  s1 := []int{1, 2, 3, 4, 5}</pre></li>				<li>Then, we’ll make a simple variable copy of <span class="No-Break">that slice:</span><pre class="source-code">
  s2 := s1</pre></li>				<li>Create a<a id="_idIndexMarker308"/> new slice by copying all the values from the first slice as part of a slice <span class="No-Break">range operation:</span><pre class="source-code">
  s3 := s1[:]</pre></li>				<li>Change some data in the first slice. Later, we’ll see how this affects the second and <span class="No-Break">third slices:</span><pre class="source-code">
  s1[3] = 99</pre></li>				<li>Return the same index for each slice and close the <span class="No-Break">function definition:</span><pre class="source-code">
  return s1[3], s2[3], s3[3]
}</pre></li>				<li>Create a function that will return two <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> values:</span><pre class="source-code">
func noLink() (int, int) {</pre></li>				<li>Define a slice with some data and do a simple <span class="No-Break">copy again:</span><pre class="source-code">
  s1 := []int{1, 2, 3, 4, 5}
  s2 := s1</pre></li>				<li>This time, we’ll append to the first slice before we do anything else. This operation changes the length and capacity of <span class="No-Break">the slice:</span><pre class="source-code">
  s1 = append(s1, 6)</pre></li>				<li>Then, we’ll change the first slice, return the same indexes from the two slices, and close <span class="No-Break">the function:</span><pre class="source-code">
  s1[3] = 99
  return s1[3], s2[3]
}</pre></li>				<li>In our next function, we’ll be returning two <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> values:</span><pre class="source-code">
func capLinked() (int, int) {</pre></li>				<li>We’ll define our first slice using <strong class="source-inline">make</strong> this time. When doing this, we’ll be setting a capacity that’s larger than <span class="No-Break">its length:</span><pre class="source-code">
  s1 := make([]int, 5, 10)</pre></li>				<li>Let’s fill the first array with the same data <span class="No-Break">as before:</span><pre class="source-code">
  s1[0], s1[1], s1[2], s1[3], s1[4] = 1, 2, 3, 4, 5</pre></li>				<li>Now, we’ll create a new slice by copying the first slice, like we <span class="No-Break">did previously:</span><pre class="source-code">
  s2 := s1</pre></li>				<li>We’ll <a id="_idIndexMarker309"/>append a new value to the first slice, which changes its length but not <span class="No-Break">its capacity:</span><pre class="source-code">
  s1 = append(s1, 6)</pre></li>				<li>Then, we’ll change the first slice, return the same indexes from the two slices, and close <span class="No-Break">the function:</span><pre class="source-code">
  s1[3] = 99
  return s1[3], s2[3]
}</pre></li>				<li>In this function, we’ll use <strong class="source-inline">make</strong> again to set a capacity, but we’ll use <strong class="source-inline">append</strong> to add elements that will go beyond <span class="No-Break">that capacity:</span><pre class="source-code">
func capNoLink() (int, int) {
  s1 := make([]int, 5, 10)
  s1[0], s1[1], s1[2], s1[3], s1[4] = 1, 2, 3, 4, 5
  s2 := s1
  s1 = append(s1, []int{10: 11}...)
  s1[3] = 99
  return s1[3], s2[3]
}</pre></li>				<li>In the next function, we’ll use <strong class="source-inline">copy</strong> to copy the elements from the first slice to the second slice. <strong class="source-inline">copy</strong> returns how many elements were copied from one slice to another, so we’ll return <span class="No-Break">that too:</span><pre class="source-code">
func copyNoLink() (int, int, int) {
  s1 := []int{1, 2, 3, 4, 5}
  s2 := make([]int, len(s1))
  copied := copy(s2, s1)
  s1[3] = 99
  return s1[3], s2[3], copied
}</pre></li>				<li>In the <a id="_idIndexMarker310"/>final function, we’ll use <strong class="source-inline">append</strong> to copy the value into the second slice. Using <strong class="source-inline">append</strong> in this way results in the values being copied into a new <span class="No-Break">hidden array:</span><pre class="source-code">
func appendNoLink() (int, int) {
  s1 := []int{1, 2, 3, 4, 5}
  s2 := append([]int{}, s1...)
  s1[3] = 99
  return s1[3], s2[3]
}</pre></li>				<li>In <strong class="source-inline">main</strong>, we’ll print out all the data we returned and print it to <span class="No-Break">the console:</span><pre class="source-code">
func main() {
  l1, l2, l3 := linked()
  fmt.Println("Linked   :", l1, l2, l3)
  nl1, nl2 := noLink()
  fmt.Println("No Link   :", nl1, nl2)
  cl1, cl2 := capLinked()
  fmt.Println("Cap Link  :", cl1, cl2)
  cnl1, cnl2 := capNoLink()
  fmt.Println("Cap No Link :", cnl1, cnl2)
  copy1, copy2, copied := copyNoLink()
  fmt.Print("Copy No Link: ", copy1, copy2)
  fmt.Printf(" (Number of elements copied %v)\n", copied)
  a1, a2 := appendNoLink()
  fmt.Println("Append No Link:", a1, a2)
}</pre></li>				<li>Save <a id="_idIndexMarker311"/>the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the <span class="No-Break">following command:</span><pre class="source-code">
go r<a id="_idTextAnchor912"/>un .</pre></li>			</ol>
			<p>Running the preceding code produces the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B18621_04_7.jpg" alt="Figure 4.7: Output displaying data" width="1050" height="196"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7: Output displaying data</p>
			<p>In this exercise, we stepped through five different scenarios where we made copies of slice data. In the <strong class="source-inline">Linked</strong> scenario, we made a simple copy of the first slice and then a range copy of it. While the slices themselves are distinct and are no longer the same slices, in reality, it doesn’t make a difference to the data they hold. Each of the slices pointed to the same hidden array, so when we made a change to the first slice, it affected all of <span class="No-Break">the slices.</span></p>
			<p>In the <strong class="source-inline">No Link</strong> scenario, the setup was the same for the first and second slices, but before we made a change to the first slice, we appended a value to it. When we appended this value to it, in the background, Go needed to create a new array to hold the now large number of values. Since we were appending to the first slice, its pointer was to look at the new, bigger slice. The second slice didn’t get its pointer updates. That’s why, when the first slice had its value change, the second slice wasn’t affected. The second slice isn’t pointing to the same hidden array anymore, meaning they are <span class="No-Break">not linked.</span></p>
			<p>For the <strong class="source-inline">Cap Link</strong> scenario, the first slice was defined using <strong class="source-inline">make</strong> and with an oversized capacity. This extra capacity meant that when the first slice had a value appended to it, there was already extra room in the hidden array. This extra capacity means there was no need to replace the hidden array. The effect was that when we updated the value on the first slice, it and the second slice were still pointing to the same hidden array, meaning the change <span class="No-Break">affected both.</span></p>
			<p>In the <strong class="source-inline">Cap No Link</strong> scenario, the setup was the same as the previous scenario, but when we appended values, we appended more values than there was available capacity. Even though there was extra capacity, there was not enough, and the hidden array in the first slice got replaced. The result was that the link between the two <span class="No-Break">slices broke.</span></p>
			<p>In <strong class="source-inline">Copy No Link</strong>, we <a id="_idIndexMarker312"/>used the built-in <strong class="source-inline">copy</strong> function to copy the value for us. While this does copy the values into a new hidden array, <strong class="source-inline">copy</strong> won’t change the length of the slice. This fact means that the destination slice must be the correct length before you do the copy. You don’t see copy much in real-world code; this could be because it’s easy to <span class="No-Break">misuse it.</span></p>
			<p>Lastly, with <strong class="source-inline">Append No Link</strong>, we used <strong class="source-inline">append</strong> to do something similar to <strong class="source-inline">copy</strong> but without having to worry about the length. This method is most commonly seen in real-world code when you need to ensure you get a copy of the values that are not linked to the source. This is easy to understand since <strong class="source-inline">append</strong> gets used a lot, and it’s a one-line solution. There is one slightly more efficient solution that avoids the extra memory allocation of the empty slice in the first argument of <strong class="source-inline">append</strong>. You can reuse the first slice by creating a 0-capacity range copy of it. This alternative looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
  s1 := []int{1, 2, 3, 4, 5}
  s2 := append(s1[:0:0], s1...)</pre>			<p>Can you see something<a id="_idIndexMarker313"/> new here? This uses the seldom-used slice range notation of <strong class="source-inline">&lt;slice&gt;[&lt;low&gt;:&lt;high&gt;:&lt;capacity&gt;]</strong>. With the current Go <a id="_idTextAnchor913"/>compiler, this i<a id="_idTextAnchor914"/>s the most memory-efficient way to copy <span class="No-Break">a slice.</span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor915"/>Map fundamentals</h2>
			<p>While arrays and slices are <a id="_idIndexMarker314"/>similar and can sometimes be interchangeable, Go’s other collection type, <strong class="source-inline">map</strong>, is quite different and is not interchangeable with <strong class="source-inline">array</strong> and <strong class="source-inline">slice</strong>. Go’s <strong class="source-inline">map</strong> type serves a <span class="No-Break">different purpose.</span></p>
			<p>Go’s map is a hashmap in computer science terms. The main difference between a map and the other collection types relates to its key. In an array or slice, the key is a placeholder (the index number), and it has no meaning of its own. It’s only there to act as a counter and has no direct relationship with <span class="No-Break">the value.</span></p>
			<p>With a map, the key is data – data that has a real relationship with the value. For example, you could have a collection of user account records in a map. The key would be the users’ employee IDs. An employee ID is real data and not just an arbitrary placeholder. If someone were to give you their employee ID, you’d be able to look up their account records without needing to loop over the data to find it. With a map, you can set, get, and delete <span class="No-Break">data quickly.</span></p>
			<p>You can access individual elements of a map in the same way as you do with a slice or an array: using <strong class="source-inline">[</strong> and <strong class="source-inline">]</strong>. Maps can have any type that is directly comparable as a key, such as an <strong class="source-inline">int</strong> or a <strong class="source-inline">string</strong> type. You can’t compare slices, so they can’t be keys. A map’s value can be of any type, including pointers, slices, <span class="No-Break">and maps.</span></p>
			<p>You shouldn’t use a map as an ordered list. Even if you were to use an <strong class="source-inline">int</strong> type for a map’s keys, maps are not guaranteed to always start at index 0, and they are not guaranteed to not have any gaps in the keys. This feature could be an advantage, even if you did want <strong class="source-inline">int</strong> keys. If you had sparsely populated data – that is, values with gaps between keys– in a slice or an array, it would contain lots of zero data. In a map, it would only contain the data <span class="No-Break">you set.</span></p>
			<p>To define a map, you use the following <span class="No-Break">notation: </span><span class="No-Break"><strong class="source-inline">map[&lt;key_type&gt;]&lt;value_type&gt;</strong></span></p>
			<p>You can use <strong class="source-inline">make</strong> to create maps, but the arguments for <strong class="source-inline">make</strong> are different when using <strong class="source-inline">make</strong> to create a map. Go can’t create keys for a map, so it’s not possible to create a map of an arbitrary length like you can with a slice. You can suggest a capacity for the compiler to use for your map. Suggesting the capacity for a map is optional, and <strong class="source-inline">map</strong> can’t be used with <strong class="source-inline">cap</strong> to check what its <span class="No-Break">capacity is.</span></p>
			<p>Maps are like slices in that they are not a value and not a pointer. A map is a special construct in Go. You’ll need to take the same care when copying the variable or the values. Since you can’t control or check the capacity of a map, they are even more challenging when you want to know what’s going to happen when you <span class="No-Break">add elements.</span></p>
			<p>Since Go does not help you manage your keys with maps, this means you must specify keys when initializing a map with data. It’s the same notation as the other collection types; that is, <strong class="source-inline">map[&lt;key_type&gt;]&lt;value_type&gt;{&lt;key1&gt;: &lt;value&gt;, … &lt;</strong><span class="No-Break"><strong class="source-inline">keyN&gt;:, &lt;valueN&gt;}</strong></span><span class="No-Break">.</span></p>
			<p>Once defined, you can set values without needing to worry about the length of the map like you do with arrays and slices. Setting a value is just like the other collections; that is, <strong class="source-inline">&lt;map&gt;[&lt;key&gt;] = &lt;value&gt;</strong>. Something that you do need to do before setting the value of a map is to make sure you’ve initialized it first. If you try to set a value of an uninitialized map, it causes a <a id="_idIndexMarker315"/>runtime panic. To avoid this, it’s good practice to avoid defining a map using <strong class="source-inline">var</strong>. If you initialize the map with <a id="_idTextAnchor916"/><a id="_idTextAnchor917"/>data or use <strong class="source-inline">make<a id="_idTextAnchor918"/></strong> to create your maps, you won’t have <span class="No-Break">this problem.</span></p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor919"/>Exercise 4.13 – Creating, reading, and writing a map</h2>
			<p>In this exercise, we’re going to <a id="_idIndexMarker316"/>define a map with some data and then add a new element to it. Finally, we’ll print the map to the console. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a<a id="_idTextAnchor920"/><a id="_idTextAnchor921"/> file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import "fmt"</pre></li>				<li>Create a function that returns a <strong class="source-inline">map</strong> type with <strong class="source-inline">string</strong> keys and <span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break"> values:</span><pre class="source-code">
func getUsers() map[string]string {</pre></li>				<li>Define a <strong class="source-inline">map</strong> type with <strong class="source-inline">string</strong> keys and <strong class="source-inline">string</strong> values and then initialize it with <span class="No-Break">some elements:</span><pre class="source-code">
  users := map[string]string{
    "305": "Sue",
    "204": "Bob",
    "631": "Jake",
  }</pre></li>				<li>Next, we’ll add a new element to the <span class="No-Break"><strong class="source-inline">map</strong></span><span class="No-Break"> type:</span><pre class="source-code">
  users["073"] = "Tracy"</pre></li>				<li>Return the <strong class="source-inline">map</strong> type and close <span class="No-Break">the function:</span><pre class="source-code">
  return users
}</pre></li>				<li>In the <strong class="source-inline">main</strong> function, print the <strong class="source-inline">map</strong> type to <span class="No-Break">the console:</span><pre class="source-code">
func main() {
  fmt.Println("Users:", getUsers())
}</pre></li>				<li>Save the<a id="_idIndexMarker317"/> file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the <span class="No-Break">following command:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Running the preceding code produces the <span class="No-Break">following output:</span></p>
			<pre class="console">
Users: map[073:Tracy 204:Bob 305:Sue 631:Jake]</pre>			<p>In this exercise, we created a map, initialized it with data, and then added a new element. This exercise shows that working with maps is similar to working with arrays and slices. When you should use a map comes down to the kinds of data you’ll store in it and if your access p<a id="_idTextAnchor922"/><a id="_idTextAnchor923"/>attern needs access to individual items rather than a list <span class="No-Break">of items.</span></p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor924"/>Reading from maps</h2>
			<p>You won’t always know <a id="_idIndexMarker318"/>whether a key exists in a map before needing to use it to get a value. When you’re getting a value for a key that doesn’t exist in a map, Go returns the zero value for the map’s value type. Having logic that works with zero values is a valid way to program in Go, but that’s not always possible. If you can’t use zero-value logic, maps can return an extra return value when you need it. The notation looks like this: <strong class="source-inline">&lt;value&gt;, &lt;exists_value&gt; := &lt;map&gt;[&lt;key&gt;]</strong>. Here, <strong class="source-inline">exists_value</strong> is a Boolean value that is <strong class="source-inline">true</strong> if a key exists in the map; otherwise, it’s <strong class="source-inline">false</strong>. This is typically represented with a Boolean value called <strong class="source-inline">ok</strong>. When looping over a map, you should use the <strong class="source-inline">range</strong> keyword and never rely on the order of the items in it. Go doesn’t guarantee the order of items in a map. To ensure no one replies on the order of the elements, Go purposely randomizes the order of them when you range over a map. If you did need to loop over the elements of your map in a specific <a id="_idTextAnchor925"/><a id="_idTextAnchor926"/>order, you’d nee<a id="_idTextAnchor927"/>d to use an array or a slice to assist you <span class="No-Break">with that.</span></p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor928"/>Exercise 4.14 – Reading from a map</h2>
			<p>In this exercise, we’re <a id="_idIndexMarker319"/>going to read from a map using direct access and a loop. We’ll also check to see if a key exists in the map. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and ad<a id="_idTextAnchor929"/><a id="_idTextAnchor930"/><a id="_idTextAnchor931"/><a id="_idTextAnchor932"/><a id="_idTextAnchor933"/><a id="_idTextAnchor934"/><a id="_idTextAnchor935"/><a id="_idTextAnchor936"/>d a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import (
  "fmt"
  "os"
)</pre></li>				<li>Create a function that returns a <strong class="source-inline">map</strong> type with a string key and a <span class="No-Break">string value:</span><pre class="source-code">
func getUsers() map[string]string {</pre></li>				<li>Define a <strong class="source-inline">map</strong> type and initialize it with data. Then, return the <strong class="source-inline">map</strong> type and close <span class="No-Break">the function:</span><pre class="source-code">
  return map[string]string{
   "305": "Sue",
   "204": "Bob",
   "631": "Jake",
   "073": "Tracy",
  }
}</pre></li>				<li>In this function, we’ll accept a string as input. The function will also return a string and <span class="No-Break">a Boolean:</span><pre class="source-code">
func getUser(id string) (string, bool) {</pre></li>				<li>Get a copy of the <strong class="source-inline">users</strong> map from our <span class="No-Break">earlier function:</span><pre class="source-code">
  users := getUsers()</pre></li>				<li>Get a value from the <strong class="source-inline">users</strong> maps using the passed-in ID as the key. Capture both the value and the <span class="No-Break"><strong class="source-inline">exists</strong></span><span class="No-Break"> value:</span><pre class="source-code">
  user, exists := users[id]</pre></li>				<li>Return<a id="_idIndexMarker320"/> both values and close <span class="No-Break">the function:</span><pre class="source-code">
  return user, exists
}</pre></li>				<li>Create a <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Check that at least one argument gets passed in. If <span class="No-Break">not, exit:</span><pre class="source-code">
  if len(os.Args) &lt; 2 {
    fmt.Println("User ID not passed")
    os.Exit(1)
  }</pre></li>				<li>Capture the passed argument and call the <span class="No-Break"><strong class="source-inline">getUser</strong></span><span class="No-Break"> function:</span><pre class="source-code">
  userID := os.Args[1]
  name, exists := getUser(userID)</pre></li>				<li>If the key is not found, print a message, and then print all the users using a <strong class="source-inline">range</strong> loop. After <span class="No-Break">that, exit:</span><pre class="source-code">
  if !exists {
    fmt.Printf("Passed user ID (%v) not found.\nUsers:\n", userID)
    for key, value := range getUsers() {
      fmt.Println("  ID:", key, "Name:", value)
    }
    os.Exit(1)
  }</pre></li>				<li>If everything is okay, print the name <span class="No-Break">we found:</span><pre class="source-code">
  fmt.Println("Name:", name)
}</pre></li>				<li>Save the<a id="_idIndexMarker321"/> file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the <span class="No-Break">following command:</span><pre class="source-code">
go run . 123</pre></li>				<li>Then, run the <span class="No-Break">following command:</span><a id="_idTextAnchor937"/><pre class="source-code">
go run . 305</pre></li>			</ol>
			<p>Running the preceding code produces the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B18621_04_8.jpg" alt="Figure 4.8: Output displaying all the users and the name that was found" width="1134" height="286"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8: Output displaying all the users and the name that was found</p>
			<p>In this exercise, we learned how we can check to see if a key exists in a map. It may look a little strange coming from other languages that require you to check for the existence of a key before getting the value, not after. This way of doing things does mean there is much less chance of runtime errors. If a zero value is not possible in your domain logic, then you can use that fact to check if a <span class="No-Break">key exists.</span></p>
			<p>We used a <strong class="source-inline">range</strong> loop to print all the users in our map nicely. Your output is probably in a different order to the output shown in the preceding screenshot, which is due to Go randomizing the order of the elements in a map when you <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">range</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor938"/>Activity 4.02 – Printing a user’s name based on user input</h2>
			<p>It’s now your turn to<a id="_idIndexMarker322"/> work with maps. We’re going to define a map and create logic to print the data in the map based on the key that’s passed to your app. The following are the steps for <span class="No-Break">this activity:</span></p>
			<ol>
				<li>Create a new <span class="No-Break">Go program.</span></li>
				<li>Define a <strong class="source-inline">map</strong> type with the following <span class="No-Break">key-value pairs:</span><p class="list-inset"><em class="italic">Key</em>: <strong class="source-inline">305</strong>, <span class="No-Break"><em class="italic">Value</em></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">Sue</strong></span></p><p class="list-inset"><em class="italic">Key</em>: <strong class="source-inline">204</strong>, <span class="No-Break"><em class="italic">Value</em></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">Bob</strong></span></p><p class="list-inset"><em class="italic">Key</em>: <strong class="source-inline">631</strong>, <span class="No-Break"><em class="italic">Value</em></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">Jake</strong></span></p><p class="list-inset"><em class="italic">Key</em>: <strong class="source-inline">073</strong>, <span class="No-Break"><em class="italic">Value</em></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">Tracy</strong></span></p></li>
				<li>Using <strong class="source-inline">os.Args</strong>, read a key that’s been passed in and print the corresponding name; for instance, <strong class="source-inline">go run . </strong><span class="No-Break"><strong class="source-inline">073</strong></span><span class="No-Break">.</span></li>
				<li>Correctly handle when no argument gets passed or if the passed argument doesn’t match a value in the <span class="No-Break"><strong class="source-inline">map</strong></span><span class="No-Break"> type.</span></li>
				<li>Print a message to the user with the name in <span class="No-Break">the value.</span></li>
			</ol>
			<p>The expected output<a id="_idIndexMarker323"/> is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Hi, Tracy</pre>			<p class="callout-heading">Note</p>
			<p class="callout">The soluti<a id="_idTextAnchor939"/><a id="_idTextAnchor940"/>on for this activity can be found in the GitHub repository folder for this chapter: <a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.02"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.02</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor941"/>Activity 4.03 – Slicing the week</h2>
			<p>In this activity, we’re <a id="_idIndexMarker324"/>going to create a slice and initialize it with some data. Then, we’re going to modify that slice using what we’ve learned about sub-slices. The following are the steps for <span class="No-Break">this activity:</span></p>
			<ol>
				<li>Create a new <span class="No-Break">Go program.</span></li>
				<li>Create a slice and initialize it with all the days of the week, starting on Monday and ending <span class="No-Break">on Sunday.</span></li>
				<li>Change the slice using slice ranges and append it so that the week now starts on Sunday and ends <span class="No-Break">on Saturday.</span></li>
				<li>Print the slice to <span class="No-Break">the console.</span></li>
			</ol>
			<p>The expected output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
[Sunday Monday Tuesday Wednesday Thursday Friday Saturday]</pre>			<p class="callout-heading">Note</p>
			<p class="callout">The solut<a id="_idTextAnchor942"/><a id="_idTextAnchor943"/>ion for this activity can be found in the GitHub repository folder for this chapter: <a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.03"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.03</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor944"/>Deleting elements from a map</h2>
			<p>If you need to<a id="_idIndexMarker325"/> remove an element from a map, you’ll need to do<a id="_idIndexMarker326"/> something different than you would with an array or a slice. In an array, you can’t remove elements since the length’s fixed; the best you can do is zero out the value. With a slice, you can zero out, but it’s also possible to use a combination of a slice <strong class="source-inline">range</strong> and <strong class="source-inline">append</strong> to cut out one or more elements. With a map, you could zero the value out, but the element still exists, so it causes problems if you’re checking whether a key exists in your logic. You can’t use slice ranges on a map to cut elements <span class="No-Break">out either.</span></p>
			<p>To remove an element, we need to use the built-in <strong class="source-inline">delete</strong> function. The function signature for <strong class="source-inline">delete</strong>, when used with maps, is <strong class="source-inline">delete(&lt;map&gt;, &lt;key&gt;)</strong>. The <strong class="source-inline">delete</strong> fu<a id="_idTextAnchor945"/><a id="_idTextAnchor946"/>nction doesn’t return anything, and if a key doesn’t exist, <span class="No-Break">nothing happens.</span></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor947"/>Exercise 4.15 – Deleting an element from a map</h2>
			<p>In this exercise, we’ll <a id="_idIndexMarker327"/>define a map and then delete an element from<a id="_idIndexMarker328"/> it using user input. Then, we’ll print the now possibly smaller map to the console. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folde<a id="_idTextAnchor948"/><a id="_idTextAnchor949"/>r and add a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import (
  "fmt"
  "os"
)</pre></li>				<li>We’re going to define our <strong class="source-inline">users</strong> map in the <span class="No-Break">package scope:</span><pre class="source-code">
var users = map[string]string{
  "305": "Sue",
  "204": "Bob",
  "631": "Jake",
  "073": "Tracy",
}</pre></li>				<li>Create a <a id="_idIndexMarker329"/>function that deletes from the <strong class="source-inline">users</strong> map <a id="_idIndexMarker330"/>using a passed-in string as <span class="No-Break">the key:</span><pre class="source-code">
func deleteUser(id string){
  delete(users, id)
}</pre></li>				<li>In <strong class="source-inline">main</strong>, we’ll grab the passed-in <strong class="source-inline">userID</strong> value and print the <strong class="source-inline">users</strong> map to <span class="No-Break">the console:</span><pre class="source-code">
func main() {
  if len(os.Args) &lt; 2 {
    fmt.Println("User ID not passed")
    os.Exit(1)
  }
  userID := os.Args[1]
  deleteUser(userID)
  fmt.Println("Users:", users)
}</pre></li>				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the <span class="No-Break">following command:</span><pre class="source-code">
go run . 305</pre></li>			</ol>
			<p>Running the <a id="_idIndexMarker331"/>preceding code produces the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker332"/></span><span class="No-Break"> output:</span></p>
			<pre class="console">
Users: map[073:Tracy 204:Bob 631:Jake]</pre>			<p>In this exercise, we used the built-in <strong class="source-inline">delete</strong> function to totally remove an element from a m<a id="_idTextAnchor950"/><a id="_idTextAnchor951"/>ap. This requirement is unique for maps; you can’t use <strong class="source-inline">delete</strong> on arrays <span class="No-Break">or slices.</span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor952"/>Activity 4.04 – Removing an element from a slice</h2>
			<p>Go doesn’t have<a id="_idIndexMarker333"/> anything built in to remove elements from a slice, but<a id="_idIndexMarker334"/> it’s possible with the techniques you’ve learned. In this activity, we’re going to set up a slice with some data and one element to remove. Then, you need to work out how to do this. There are many ways to get this done, but can you work out the most <span class="No-Break">compact way?</span></p>
			<p>Here are the steps for <span class="No-Break">this activity:</span></p>
			<ol>
				<li>Create a new <span class="No-Break">Go program.</span></li>
				<li>Create a slice with the following elements in the <span class="No-Break">following order:</span><pre class="source-code">
Good
Good
Bad
Good
Good</pre></li>				<li>Write the code to remove the <strong class="source-inline">Bad</strong> element from <span class="No-Break">the slice.</span></li>
				<li>Print the result to <span class="No-Break">the console.</span></li>
			</ol>
			<p>The following is the <span class="No-Break">expected output:</span></p>
			<pre class="console">
[Good Good Good Good]</pre>			<p class="callout-heading">Note<a id="_idTextAnchor953"/><a id="_idTextAnchor954"/></p>
			<p class="callout">The solution for this activity can be found in the GitHub repository folder for this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.04"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.04</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor955"/>Simple custom types</h1>
			<p>You can create custom types <a id="_idIndexMarker335"/>using Go’s simple types as a starting point. The notation is <strong class="source-inline">type &lt;name&gt; &lt;type&gt;</strong>. If we were to create an ID type based on a string, this would look like <strong class="source-inline">type id string</strong>. The custom type acts the same as the type you based it on, including getting the same zero value and having the same abilities to compare with other values of the same type. A custom type is not compatible with its base type, but you ca<a id="_idTextAnchor956"/><a id="_idTextAnchor957"/>n convert your c<a id="_idTextAnchor958"/>ustom type back into the type it’s based on to allow <span class="No-Break">for interaction.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor959"/>Exercise 4.16 – Creating a simple custom type</h2>
			<p>In this exercise, we’ll define a <a id="_idIndexMarker336"/>map and then delete an element from it using user input and a simple custom type. Then, we’ll print the now possibly smaller map to the console. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a n<a id="_idTextAnchor960"/><a id="_idTextAnchor961"/>ew folder and add a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import "fmt"</pre></li>				<li>Define a custom type called <strong class="source-inline">id</strong> based on the <span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break"> type:</span><pre class="source-code">
type id string</pre></li>				<li>Create a function that returns three <span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break"> instances:</span><pre class="source-code">
func getIDs() (id, id, id) {</pre></li>				<li>For <strong class="source-inline">id1</strong>, we’ll initialize it and leave it at its <span class="No-Break">zero value:</span><pre class="source-code">
  var id1 id</pre></li>				<li>For <strong class="source-inline">id2</strong>, we’ll initialize it using a <span class="No-Break">string literal:</span><pre class="source-code">
  var id2 id = "1234-5678"</pre></li>				<li>Finally, for <strong class="source-inline">id3</strong>, we’ll initialize it to zero and then set a <span class="No-Break">value separately:</span><pre class="source-code">
  var id3 id
  id3 = "1234-5678"</pre></li>				<li>Now, return the <strong class="source-inline">id</strong> instances and close <span class="No-Break">the function:</span><pre class="source-code">
  return id1, id2, id3
}</pre></li>				<li>In <strong class="source-inline">main</strong>, call <a id="_idIndexMarker337"/>our function and do <span class="No-Break">some comparisons:</span><pre class="source-code">
func main() {
  id1, id2, id3 := getIDs()
  fmt.Println("id1 == id2    :", id1 == id2)
  fmt.Println("id2 == id3    :", id2 == id3)</pre></li>				<li>For this preceding comparison, we’ll convert the <strong class="source-inline">id</strong> type back into <span class="No-Break">a string:</span><pre class="source-code">
  fmt.Println("id2 == \"1234-5678\":", string(id2) == "1234-5678")
}</pre></li>				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the<a id="_idTextAnchor962"/> <span class="No-Break">following command:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Running the preceding code produces the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B18621_04_9.jpg" alt="Figure 4.9: Output after comparison" width="980" height="118"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9: Output after comparison</p>
			<p>In this exercise, we created a custom type called <strong class="source-inline">id</strong>, set data on it, and then compared it with values of the same type and with its base type <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break">.</span></p>
			<p>Simple custom types are<a id="_idIndexMarker338"/> a foundational part of modeling the data problems you’ll see in the real world. Having types designed to reflect the d<a id="_idTextAnchor963"/><a id="_idTextAnchor964"/>ata you need to work with closely helps keep your code easy to understand <span class="No-Break">and maintain.</span></p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor965"/>Structs</h1>
			<p>Collections are perfect for<a id="_idIndexMarker339"/> grouping values of the same type and purpose together. There is another way of grouping data together in Go for a different purpose. Often, a simple string, number, or Boolean doesn’t fully capture the essence of the data <span class="No-Break">you’ll have.</span></p>
			<p>For example, for our user map, a user was represented by their unique ID and their first name. That is rarely going to be enough detail to be able to work with user records. The data you could capture about a person is almost infinite, such as their given, middle, and family names. Their preferred prefix and suffix, their date of birth, their height, weight, or where they work can also be captured. It would be possible to store this data in multiple maps, all with the same key, but that is hard to work with <span class="No-Break">and maintain.</span></p>
			<p>The ideal thing to do is to collect all these different bits of data into a single data structure that you can design and control. That’s what Go’s <strong class="source-inline">struct</strong> type is: it’s a custom type that you can name and then specify the field properties and <span class="No-Break">their types.</span></p>
			<p>The notation for structs looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
type &lt;name&gt; struct {
  &lt;fieldName1&gt; &lt;type&gt;
  &lt;fieldName2&gt; &lt;type&gt;
  …
  &lt;fieldNameN&gt; &lt;type&gt;
}</pre>			<p>Field names must be unique within a struct. You can use any type for a field, including pointers, collections, and <span class="No-Break">other structs.</span></p>
			<p>You can access a field on a struct using the following notation: <strong class="source-inline">&lt;structValue&gt;.&lt;fieldName&gt;</strong>. To set a value, you use this notation: <strong class="source-inline">&lt;structValue&gt;.&lt;fieldName&gt; = &lt;value&gt;</strong>. To read a value, you use the following notation: <strong class="source-inline">value = &lt;</strong><span class="No-Break"><strong class="source-inline">structValue&gt;.&lt;fieldName&gt;</strong></span><span class="No-Break">.</span></p>
			<p>Structs are the<a id="_idIndexMarker340"/> closest thing that Go has to what are called classes in other languages, but structs have purposely been kept stripped down by Go’s designers. A key difference is that structs don’t have any form of inheritance. The designers of Go feel that inheritance causes more problems than it solves in <span class="No-Break">real-world code.</span></p>
			<p>Once you’ve defined your custom <strong class="source-inline">struct</strong> type, you can use it to create a value.<a id="_idTextAnchor966"/><a id="_idTextAnchor967"/> You have severa<a id="_idTextAnchor968"/>l ways to create values from <strong class="source-inline">struct</strong> types. Let’s take a look at <span class="No-Break">them now.</span></p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor969"/>Exercise 4.17 – Creating struct types and values</h2>
			<p>In this exercise, we’re going to define a<a id="_idIndexMarker341"/> user struct. We’ll define some fields of different types. Then, we’ll create some struct values<a id="_idIndexMarker342"/> using a few different methods. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Creat<a id="_idTextAnchor970"/><a id="_idTextAnchor971"/>e a new folder and add a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import "fmt"</pre></li>				<li>The first thing we’ll do is define our <strong class="source-inline">struct</strong> type. You generally do this in the package scope (outside of any function body). We need to give it a name that’s unique at the <span class="No-Break">package-level scope:</span><pre class="source-code">
type user struct {</pre></li>				<li>We’ll add some fields of different types and then close the <span class="No-Break">struct definition:</span><pre class="source-code">
  name  string
  age   int
  balance float64
  member bool
}</pre></li>				<li>We’ll create a function that returns a slice of our newly defined <span class="No-Break"><strong class="source-inline">struct</strong></span><span class="No-Break"> type:</span><pre class="source-code">
func getUsers() []user {</pre></li>				<li>Our<a id="_idIndexMarker343"/> first user is initialized using this key-value notation. This <a id="_idIndexMarker344"/>notation is the most common form to use when <span class="No-Break">initializing structs:</span><pre class="source-code">
  u1 := user{
   name:  "Tracy",
   age:   51,
   balance: 98.43,
   member: true,
  }</pre></li>				<li>When using the key-value notation, the order of the fields doesn’t matter, and any you leave out will get a zero value for <span class="No-Break">their type:</span><pre class="source-code">
  u2 := user{
   age: 19,
   name: "Nick",
  }</pre></li>				<li>It’s possible to initialize a struct with values only. If you do this, all the fields must be present, and their order must match how you defined them in <span class="No-Break">the struct:</span><pre class="source-code">
  u3 := user{
   "Bob",
   25,
   0,
   false,
  }</pre></li>				<li>This <strong class="source-inline">var</strong> notation will create a struct where all the fields have <span class="No-Break">zero values:</span><pre class="source-code">
  var u4 user</pre></li>				<li>Now, we can set values on the fields using <strong class="source-inline">.</strong> and the <span class="No-Break">field name:</span><pre class="source-code">
  u4.name = "Sue"
  u4.age = 31
  u4.member = true
  u4.balance = 17.09</pre></li>				<li>Now, we <a id="_idIndexMarker345"/>will return the values wrapped in a slice and close <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker346"/></span><span class="No-Break">function:</span><pre class="source-code">
  return []user{u1, u2, u3, u4}
}</pre></li>				<li>In <strong class="source-inline">main</strong>, we’ll get the slice of <strong class="source-inline">users</strong>, loop over it, and print it to <span class="No-Break">the console:</span><pre class="source-code">
func main() {
  users := getUsers()
  for i := 0; i &lt; len(users); i++ {
   fmt.Printf("%v: %#v\n", i, users[i])
  }
}</pre></li>				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code u<a id="_idTextAnchor972"/>sing the <span class="No-Break">following command:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Running the preceding code produces the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer057" class="IMG---Figure">
					<img src="image/B18621_04_10.jpg" alt="Figure 4.10: Output as per the new struct" width="1283" height="142"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10: Output as per the new struct</p>
			<p>In this exercise, you defined a custom <strong class="source-inline">struct</strong> type that contained multiple fields, each of a different type. Then, we created values from that struct using a few different methods. Each of these methods is valid and useful in <span class="No-Break">different contexts.</span></p>
			<p>We defined the<a id="_idIndexMarker347"/> struct at the package scope, and while it’s not typical, you<a id="_idIndexMarker348"/> can define <strong class="source-inline">struct</strong> types in the function scope too. If you do define a <strong class="source-inline">struct</strong> type in a function, it’ll only be valid for use in that function. When defining a type at the package level, it’s available for use throughout <span class="No-Break">the package.</span></p>
			<p>It’s also possible to define and initialize a struct at the same time. If you do this, you can’t reuse the type, but it’s still a useful technique. The notation looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
type &lt;name&gt; struct {
  &lt;fieldName1&gt; &lt;type&gt;
  &lt;fieldName2&gt; &lt;type&gt;
  …
  &lt;fieldNameN&gt; &lt;type&gt;
}{
  &lt;value1&gt;,
  &lt;value2&gt;,
  …
  &lt;valueN&gt;,
}</pre>			<p>You can also initialize using the<a id="_idTextAnchor973"/><a id="_idTextAnchor974"/> key-value notation, but initializing with only the values is the most common when this <span class="No-Break">is done.</span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor975"/>Comparing structs to each other</h2>
			<p>If all a struct’s fields are <a id="_idIndexMarker349"/>comparable types, then the struct is also comparable. So, if your struct is made up of <strong class="source-inline">string</strong> and <strong class="source-inline">int</strong> types, then you can compare whole structs to one another. If your struct has a slice in it, then you can’t. Go is strongly typed, so you can only compare values of the same type, but with structs, there is a little bit of flexibility. If the struct was<a id="_idTextAnchor976"/><a id="_idTextAnchor977"/> defined anonymo<a id="_idTextAnchor978"/>usly and has the same structure as a named struct, then Go allows <span class="No-Break">the comparison.</span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor979"/>Exercise 4.18 – Comparing structs to each other</h2>
			<p>In this exercise, we’ll define a comparable struct and create a value with it. We’ll also define and create values with anonymous structs that have the same structure as our n<a id="_idTextAnchor980"/><a id="_idTextAnchor981"/><a id="_idTextAnchor982"/><a id="_idTextAnchor983"/><a id="_idTextAnchor984"/><a id="_idTextAnchor985"/><a id="_idTextAnchor986"/>amed struct. Finally, we’ll compare them and print the results to the console. Let’s <span class="No-Break">get started:</span><a id="_idTextAnchor987"/><a id="_idTextAnchor988"/><a id="_idTextAnchor989"/><a id="_idTextAnchor990"/><a id="_idTextAnchor991"/></p>
			<ol>
				<li>Create a new folder and add a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it:</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import "fmt"</pre></li>				<li>Let’s define a simple, <span class="No-Break">comparable struct:</span><pre class="source-code">
type point struct {
  x int
  y int
}</pre></li>				<li>Now, we’ll create a function that returns <span class="No-Break">two Booleans:</span><pre class="source-code">
func compare() (bool, bool) {</pre></li>				<li>We’ll now create our first anonymous struct:  <pre class="source-code">
  point1 := struct {
    x int
    y int
  }{
    10,
    10,
  }</pre></li>			</ol>
			<p class="callout-heading">Note  </p>
			<p class="callout">The struct is considered anonymous because the <strong class="source-inline">struct</strong> type does not have a name. <strong class="source-inline">point1</strong> is a variable that contains an instance of the <span class="No-Break">anonymous struct.</span></p>
			<ol>
				<li value="6">With the <a id="_idIndexMarker350"/>second anonymous struct, we’re initializing it to zero and then changing the value <span class="No-Break">after initialization:</span><pre class="source-code">
  point2 := struct {
    x int
    y int
  }{}
  point2.x = 10
  point2.y = 5</pre></li>				<li>The final struct to create uses the named <strong class="source-inline">struct</strong> type we <span class="No-Break">created previously:</span><pre class="source-code">
  point3 := point{10, 10}</pre></li>				<li>Compare them. Then, return and close <span class="No-Break">the function:</span><pre class="source-code">
  return point1 == point2, point1 == point3
}</pre></li>				<li>In <strong class="source-inline">main</strong>, we’ll call our function and print <span class="No-Break">the results:</span><pre class="source-code">
func main() {
  a, b := compare()
  fmt.Println("point1 == point2:", a)
  fmt.Println("point1 == point3:", b)
}</pre></li>				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the cod<a id="_idTextAnchor992"/>e using the <span class="No-Break">following command:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Running the preceding <a id="_idIndexMarker351"/>code produces the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/B18621_04_11.jpg" alt="Figure 4.11: Output comparing structs" width="1017" height="92"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11: Output comparing structs</p>
			<p>In this exercise, we saw that we can work with anonymous struct values in the same way as named <strong class="source-inline">struct</strong> types, including comparing them. With named types, you can only compare structs of the same type. When you compare types in Go, Go compares all the fields to check for a match. Go allows a comparison of these anonymous structs to be made <a id="_idTextAnchor993"/><a id="_idTextAnchor994"/>because the field names and types match. Go is a little flexible with comparing structs <span class="No-Break">like this.</span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor995"/>Struct composition using embedding</h2>
			<p>While inheritance<a id="_idIndexMarker352"/> is not possible with Go structs, the designers of Go did <a id="_idIndexMarker353"/>include an exciting alternative. The alternative is to embed types in <strong class="source-inline">struct</strong> types. Using embedding, you can add fields to a struct from other structs. This composition feature has the effect of letting you add to a struct using other structs as components. Embedding is different than having a field that is a <strong class="source-inline">struct</strong> type. When you embed, the fields from the embedded struct get promoted. Once promoted, a field acts as if it’s defined on the <span class="No-Break">target struct.</span></p>
			<p>To embed a struct, you add it like you would a field, but you don’t specify a name. To do this, you add a <strong class="source-inline">struct</strong> type name to another struct without giving it a field name, which looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
type &lt;name&gt; struct {
  &lt;Type&gt;
}</pre>			<p>Though not common, you can embed any other type into structs. There is nothing to promote, so to access the embedded type, you access it using the type’s name; for example, <strong class="source-inline">&lt;structValue&gt;.&lt;type&gt;</strong>. This way of accessing embedded types by their type name is also true for structs. This means there are two valid ways to work with an embedded struct’s fields: <strong class="source-inline">&lt;structValue&gt;.&lt;fieldName&gt;</strong> or <strong class="source-inline">&lt;structValue&gt;.&lt;type&gt;.&lt;fieldName&gt;</strong>. This ability to access a type by its name also means that the type’s names must be unique between the embedded types and the root field names. When embedding pointer types, the type’s name is the type without the pointer notation, so the name <strong class="source-inline">*&lt;type&gt;</strong> becomes <strong class="source-inline">&lt;type&gt;</strong>. The field is still a pointer, and only the name <span class="No-Break">is different.</span></p>
			<p>When it comes to promotion, if you were to have any overlap with your struct’s field names, Go allows you to embed, but the promotion of the overlapping field doesn’t happen. You can still access the field by going through the type <span class="No-Break">name path.</span></p>
			<p>You can’t use <a id="_idIndexMarker354"/>promotion when ini<a id="_idTextAnchor996"/><a id="_idTextAnchor997"/>tializing struct<a id="_idTextAnchor998"/>s with embedded <a id="_idIndexMarker355"/>types. To initialize the data, you must use the embedded <span class="No-Break">type’s name.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor999"/>Exercise 4.19 – Struct embedding and initialization</h2>
			<p>In this exercise, we’ll <a id="_idIndexMarker356"/>define some structs and custom types. We’ll embed those types into a<a id="_idIndexMarker357"/> struct. Let’s <span class="No-Break">get s<a id="_idTextAnchor1000"/><a id="_idTextAnchor1001"/><a id="_idTextAnchor1002"/><a id="_idTextAnchor1003"/>tarted:</span></p>
			<ol>
				<li>Create a new folder and add a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import "fmt"</pre></li>				<li>Create a custom <strong class="source-inline">string</strong> type <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">name</strong></span><span class="No-Break">:</span><pre class="source-code">
type name string</pre></li>				<li>Create a struct called <strong class="source-inline">location</strong> with two <strong class="source-inline">int</strong> fields; that is, <strong class="source-inline">x</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">y</strong></span><span class="No-Break">:</span><pre class="source-code">
type location struct {
  x int
  y int
}</pre></li>				<li>Create a <strong class="source-inline">size</strong> struct with two <strong class="source-inline">int</strong> fields; that is, <strong class="source-inline">width</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">height</strong></span><span class="No-Break">:</span><pre class="source-code">
type size struct {
  width int
  height int
}</pre></li>				<li>Create <a id="_idIndexMarker358"/>a struct named <strong class="source-inline">dot</strong>. This embeds each of the <a id="_idIndexMarker359"/>preceding structs <span class="No-Break">in it:</span><pre class="source-code">
type dot struct {
  name
  location
  size
}</pre></li>				<li>Create a function that returns a slice <span class="No-Break">of dots:</span><pre class="source-code">
func getDots() []dot {</pre></li>				<li>Our first <strong class="source-inline">dot</strong> instance uses the <strong class="source-inline">var</strong> notation. This will result in all the fields having a <span class="No-Break">zero value:</span><pre class="source-code">
  var dot1 dot</pre></li>				<li>With <strong class="source-inline">dot2</strong>, we’re also initializing with <span class="No-Break">zero values:</span><pre class="source-code">
  dot2 := dot{}</pre></li>				<li>To set the name, we use the type’s name as if it were <span class="No-Break">a field:</span><pre class="source-code">
  dot2.name = "A"</pre></li>				<li>For <strong class="source-inline">size</strong> and <strong class="source-inline">location</strong>, we’ll use the promoted fields to set <span class="No-Break">their value:</span><pre class="source-code">
  dot2.x = 5
  dot2.y = 6
  dot2.width = 10
  dot2.height = 20</pre></li>				<li>When initializing <a id="_idIndexMarker360"/>embedded types, you can’t use promotion. For <strong class="source-inline">name</strong>, the<a id="_idIndexMarker361"/> result is the same, but for <strong class="source-inline">location</strong> and <strong class="source-inline">size</strong>, you need to put more work <span class="No-Break">into this:</span><pre class="source-code">
  dot3 := dot{
   name: "B",
   location: location{
     x: 13,
     y: 27,
   },
   size: size{
     width: 5,
     height: 7,
   },
  }</pre></li>				<li>For <strong class="source-inline">dot4</strong>, we’ll use the type names to <span class="No-Break">set data:</span><pre class="source-code">
  dot4 := dot{}
  dot4.name = "C"
  dot4.location.x = 101
  dot4.location.y = 209
  dot4.size.width = 87
  dot4.size.height = 43</pre></li>				<li>Return all the dots in a slice and then close <span class="No-Break">the function:</span><pre class="source-code">
  return []dot{dot1, dot2, dot3, dot4}
}</pre></li>				<li>In <strong class="source-inline">main</strong>, call <a id="_idIndexMarker362"/>the function. Then, loop over the slice and print it<a id="_idIndexMarker363"/> to <span class="No-Break">the console:</span><pre class="source-code">
func main() {
  dots := getDots()
  for i := 0; i &lt; len(dots); i++ {
    fmt.Printf("dot%v: %#v\n", i+1, dots[i])
  }
}</pre></li>				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>,<a id="_idTextAnchor1004"/> run the code using the <span class="No-Break">following command:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Running the preceding code produces the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/B18621_04_12.jpg" alt="Figure 4.12: Output after struct embedding and initialization" width="1406" height="142"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12: Output after struct embedding and initialization</p>
			<p>In this exercise, we were able to define a complex struct by embedding other types into it. Embedding allows you to reuse common structures by reducing the duplicated code but still giving your struct a <span class="No-Break">flat API.</span></p>
			<p>We may not see much embedding in real-world Go code. It does come up, but the complexity and exception mean that Go developers prefer to have the other structs as <span class="No-Break">named fields.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor1005"/>Activity 4.05 – Creating a locale checker</h2>
			<p>In this activity, we’re going to create a locale validator. A locale<a id="_idIndexMarker364"/> is an internationalization and localization concept that is a combination of both a language and a country or region. We’ll create a struct that represents a locale. After, we’re going to define a list of locales our code supports. Then, we’ll read in some locale code from the command line and print out<a id="_idIndexMarker365"/> whether our code accepts that locale <span class="No-Break">or not.</span></p>
			<p>Here are the steps for <span class="No-Break">this activity:</span></p>
			<ol>
				<li>Create a new <span class="No-Break">Go program.</span></li>
				<li>Define a struct with a field for language and a separate field for country <span class="No-Break">or region.</span></li>
				<li>Create a collection to hold the local definitions for at least five locales; for instance, <strong class="source-inline">en_US</strong>, <strong class="source-inline">en_CN</strong>, <strong class="source-inline">fr_CN</strong>, <strong class="source-inline">fr_FR</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">ru_RU</strong></span><span class="No-Break">.</span></li>
				<li>Read in the locale from the command line; for example, using <strong class="source-inline">os.Args</strong>. Be sure to have error checking and <span class="No-Break">validation working.</span></li>
				<li>Load the passed locale string into a new <span class="No-Break">locale struct.</span></li>
				<li>Use that struct to check whether the passed struct <span class="No-Break">is supported.</span></li>
				<li>Print a message to the console stating whether the locale is supported <span class="No-Break">or not.</span></li>
			</ol>
			<p>The expected output is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/B18621_04_13.jpg" alt="Figure 4.13: Expected output" width="1059" height="142"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure <a id="_idTextAnchor1006"/><a id="_idTextAnchor1007"/>4.13: Expected output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found in the GitHub repository folder for this chapter: <a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.05"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.05</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor1008"/>Type conversions</h2>
			<p>There are times when your types won’t <a id="_idIndexMarker366"/>match up, and with Go’s strict type system, if types are not the same, they can’t interact with one another. In these cases, you have two options. If the two types are compatible, you can do type conversion – that is, you can create a new value by changing one type to another. The notation to do this is <strong class="source-inline">&lt;value&gt;.(&lt;type&gt;)</strong>. When working with strings, we used this notation to cast a string to a slice of runes or bytes and back again. This works because a string is a special type that stores the string’s data as a slice <span class="No-Break">of bytes.</span></p>
			<p><em class="italic">It’s important to note that not all type conversions preserve the original value</em>. When working with numeric type conversion, the numbers can change from their original value. If you convert from a large <strong class="source-inline">int</strong> type (for example, <strong class="source-inline">int64</strong>) into a smaller <strong class="source-inline">int</strong> type (for example, <strong class="source-inline">int8</strong>), it causes the number to overflow. If you were to convert from an unsigned <strong class="source-inline">int</strong> type (for example, <strong class="source-inline">uint64</strong>) into a signed <strong class="source-inline">int</strong> type (for example, <strong class="source-inline">int64</strong>), this overflow happens because unsigned <strong class="source-inline">int</strong> types can store a higher number than a signed <strong class="source-inline">int</strong> type. This overflowing is the same when converting an <strong class="source-inline">int</strong> type into a <strong class="source-inline">float</strong> type since the <strong class="source-inline">float</strong> type splits its storage space between whole numbers and decimals. When converting from a <strong class="source-inline">float</strong> type to an <strong class="source-inline">int</strong> type, the decimal part <span class="No-Break">is truncated.</span></p>
			<p>It’s still perfectly reasonable to do these types of lossy conversions, and they happen all the time in real-world code. If you know that the data you’re dealing with doesn’t cross these thresholds, then there’s no need <span class="No-Break">to worry.</span></p>
			<p>Go does its best to guess at the types that need conversion. This is called implicit type conversion. For example, <strong class="source-inline">math.MaxInt8</strong> is an <strong class="source-inline">int</strong> typ<a id="_idTextAnchor1009"/><a id="_idTextAnchor1010"/>e, and if you tr<a id="_idTextAnchor1011"/>y to assign it to a number other than an <strong class="source-inline">int</strong> type, Go does an implicit type conversion <span class="No-Break">for you.</span></p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor1012"/>Exercise 4.20 – Numeric type conversions</h2>
			<p>In this exercise, we’ll do some numeric type conversions<a id="_idIndexMarker367"/> and intentionally <a id="_idIndexMarker368"/>cause some data issues. Le<a id="_idTextAnchor1013"/><a id="_idTextAnchor1014"/><a id="_idTextAnchor1015"/>t’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import (
  "fmt"
  "math"
)</pre></li>				<li>Create a function that returns <span class="No-Break">a string:</span><pre class="source-code">
func convert() string{</pre></li>				<li>Define some variables to do our work. Go is doing an implicit conversion of the <strong class="source-inline">math.MaxInt8</strong> int into an <span class="No-Break"><strong class="source-inline">int8</strong></span><span class="No-Break"> type:</span><pre class="source-code">
  var i8 int8 = math.MaxInt8
  i := 128
  f64 := 3.14</pre></li>				<li>Here, we’ll convert from a smaller <strong class="source-inline">int</strong> type into a larger <strong class="source-inline">int</strong> type. This is always a <span class="No-Break">safe operation:</span><pre class="source-code">
  m := fmt.Sprintf("int8  = %v &gt; int64  = %v\n", i8, int64(i8))</pre></li>				<li>Now, we’ll convert from an <strong class="source-inline">int</strong> type that’s 1 above <strong class="source-inline">int8</strong>’s maximum size. This will cause an overflow to <strong class="source-inline">int8</strong>’s <span class="No-Break">minimum size:</span><pre class="source-code">
  m += fmt.Sprintf("int   = %v &gt; int8   = %v\n", i, int8(i))</pre></li>				<li>Next, we’ll convert our <strong class="source-inline">int8</strong> type into a <strong class="source-inline">float64</strong> type. This doesn’t cause an overflow and the data <span class="No-Break">is unchanged:</span><pre class="source-code">
  m += fmt.Sprintf("int8  = %v &gt; float32 = %v\n", i8, float64(i8))</pre></li>				<li>Here, we’ll convert a <strong class="source-inline">float</strong> type into an <strong class="source-inline">int</strong> type. All the decimal data is lost but the whole number is kept <span class="No-Break">as is:</span><pre class="source-code">
  m += fmt.Sprintf("float64 = %v &gt; int   = %v\n", f64, int(f64))</pre></li>				<li>Return the message and then close <span class="No-Break">the function:</span><pre class="source-code">
  return m
}</pre></li>				<li>In the <strong class="source-inline">main()</strong> function, call the function and print it to <span class="No-Break">the console:</span><pre class="source-code">
func main() {
  fmt.Print(convert())
}</pre></li>				<li>Save the file. Then, in the folder you created in <em class="italic">step<a id="_idTextAnchor1016"/> 1</em>, run the code using the <span class="No-Break">following co<a id="_idTextAnchor1017"/><a id="_idTextAnchor1018"/>mmand:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Running the preceding <a id="_idIndexMarker369"/>code produces the<a id="_idIndexMarker370"/> <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/B18621_04_14.jpg" alt="Figure 4.14: Output after conversion" width="1006" height="144"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14: Output after conversion</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor1019"/>Type assertions and interface{}</h2>
			<p>We’ve used <strong class="source-inline">fmt.Print</strong> and its siblings<a id="_idIndexMarker371"/> a great deal for writing our code, but how does a function such as <strong class="source-inline">fmt.Print</strong> take any type of value when Go is a strongly typed language? Let’s take a<a id="_idIndexMarker372"/> look at the actual Go standard library code <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">fmt.Print</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// Print formats using the default formats for its operands and writes to standard output.
// Spaces are added between operands when neither is a string.
// It returns the number of bytes written and any write error encountered.
func Print(a ...interface{}) (n int, err error) {
  return Fprint(os.Stdout, a...)
}</pre>			<p>I hope you can see that looking at Go’s source code is not scary – it’s a great way to see how you should do things, and I recommend looking at it whenever you are curious about how they do something properly using <span class="No-Break">idiomatic Go.</span></p>
			<p>By looking at this code, we can see that <strong class="source-inline">fmt.Print</strong> has a variadic of the <strong class="source-inline">interface{}</strong> type. We’ll cover interfaces in more detail later, but for now, what you need to know is that an interface in Go describes which functions a type must have to conform to that interface. Interfaces in Go don’t describe fields and don’t describe a type’s core value, such as being a string or a number. In Go, any type can have functions, including strings and numbers. What <strong class="source-inline">interface{}</strong> is describing is a type with no functions. What use is a value with no function, no fields, and no core value? None, but it’s still a value, and it can still be passed around. This interface is not setting the type of the value but controlling which values it will allow for a variable with that interface. Which types in Go conform to <strong class="source-inline">interface{}</strong>? All of them! Any of Go’s types or any custom type you create conform to <strong class="source-inline">interface{}</strong>, and this is how <strong class="source-inline">fmt.Print</strong> can accept any type. You can also use <strong class="source-inline">interface{}</strong> in your code to achieve the <span class="No-Break">same result.</span></p>
			<p>The Go 1.18 release<a id="_idIndexMarker373"/> included an alias of the <strong class="source-inline">interface{}</strong> type called <strong class="source-inline">any</strong>. Since they are equivalent in usage, <strong class="source-inline">any</strong> is interchangeable with <strong class="source-inline">interface{}</strong> in the earlier code example that we saw at the beginning of <span class="No-Break">this section.</span></p>
			<p>Once you have your variable that conforms to <strong class="source-inline">interface{}</strong>, what can you do with it? Even if the underlying value of your <strong class="source-inline">interface{}</strong> variable has functions, fields, or a core value, you can’t use them because Go is enforcing the interface’s contract, which is why this is still <span class="No-Break">all type-safe.</span></p>
			<p>To unlock the capabilities of the value<a id="_idIndexMarker374"/> masked by <strong class="source-inline">interface{}</strong> or <strong class="source-inline">any</strong>, we need to use type assertion. The notation for type assertion is <strong class="source-inline">&lt;value&gt;.(&lt;type&gt;)</strong>. Type assertion results in a value of the type that was requested and, optionally, a Boolean value regarding whether it was successful or not. This looks like <strong class="source-inline">&lt;value&gt; := &lt;value&gt;.(&lt;type&gt;)</strong> or <strong class="source-inline">&lt;value&gt;, &lt;ok&gt; := &lt;value&gt;.(type)</strong>. If you leave the Boolean value out and the type assertion fails, Go raises <span class="No-Break">a panic.</span></p>
			<p>Go doesn’t remove anything from a value when you place it in an <strong class="source-inline">interface{}</strong> type or <strong class="source-inline">any</strong> variable. What happens is the Go compiler prevents you from using it because it’s not able to perform its type-safety checks at compile time. Using type assertion is your instruction to Go that you want to unlock the value. When you do type assertion, Go performs the type-safety checks it would have done at compile time and at runtime, and those checks may fail. It’s then your responsibility to deal with the type-safety checks failing. T<a id="_idTextAnchor1020"/><a id="_idTextAnchor1021"/>ype assertions<a id="_idIndexMarker375"/> <a id="_idTextAnchor1022"/>are a feature that causes runtime errors and panics, which means you must be extra careful <span class="No-Break">around them.</span></p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor1023"/>Exercise 4.21 – Type assertions</h2>
			<p>In this exercise, we will perform<a id="_idIndexMarker376"/> some type assertions and ensure that all the safety checks are in place when we do<a id="_idTextAnchor1024"/><a id="_idTextAnchor1025"/> so. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import (
  "errors"
  "fmt"
)</pre></li>				<li>Create a function that accepts an <strong class="source-inline">interface{}</strong> type and returns a string and <span class="No-Break">an error:</span><pre class="source-code">
func doubler(v interface{}) (string, error) {</pre></li>				<li>First, we’ll check to see if our argument is an <strong class="source-inline">int</strong> type, and if it is, we’ll multiply it by <strong class="source-inline">2</strong> and <span class="No-Break">return it:</span><pre class="source-code">
  if i, ok := v.(int); ok {
    return fmt.Sprint(i * 2), nil
  }</pre></li>				<li>Here, we’ll check if it’s a string, and if it is, we’ll concatenate it to itself and <span class="No-Break">return it:</span><pre class="source-code">
  if s, ok := v.(string); ok {
    return s + s, nil
  }</pre></li>				<li>If we don’t get any matches, return an error. Then, close <span class="No-Break">the function:</span><pre class="source-code">
  return "", errors.New("unsupported type passed")
}</pre></li>				<li>In <strong class="source-inline">main</strong>, call <strong class="source-inline">doubler</strong> with a <a id="_idIndexMarker377"/>variety of data and print the results to <span class="No-Break">the console:</span><pre class="source-code">
func main() {
  res, _ := doubler(5)
  fmt.Println("5 :", res)
  res, _ = doubler("yum")
  fmt.Println("yum :", res)
  _, err := doubler(true)
  fmt.Println("true:", err)
}</pre></li>				<li>Save the file. Then, in the folder you created<a id="_idTextAnchor1026"/> in <em class="italic">step 1</em>, run the code using the <span class="No-Break">following command:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Running the preceding code produces the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B18621_04_15.jpg" alt="Figure 4.15: Output showing matches" width="554" height="118"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15: Output showing matches</p>
			<p>The <a id="_idIndexMarker378"/>combination of <strong class="source-inline">interface{},</strong> <strong class="source-inline">any</strong>, and type assertions allows you to overcome Go’s strict type controls, in turn allowing you to create functions that can work with any type of variable. The challenge is that you lose the protection that Go gives you at compile time for type safety.<a id="_idTextAnchor1027"/><a id="_idTextAnchor1028"/> It’s still possible to be safe, but the responsibility is yours now – do it wrong, and you’ll get a nasty <span class="No-Break">runtime error.</span></p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor1029"/>Type switch</h2>
			<p>If we wanted to expand<a id="_idIndexMarker379"/> our <strong class="source-inline">doubler</strong> function to include all <strong class="source-inline">int</strong> types, we’d end up with a lot of duplicated logic. Go has an excellent way of dealing with more complex type assertion situations, known as a type switch. Here’s what it <span class="No-Break">looks like:</span></p>
			<pre class="source-code">
switch &lt;value&gt; := &lt;value&gt;.(type) {
case &lt;type&gt;:
  &lt;statement&gt;
case &lt;type&gt;, &lt;type&gt;:
  &lt;statement&gt;
default:
  &lt;statement&gt;
}</pre>			<p>The type switch only runs your logic if it matches the type you’re looking for, and it sets the value to that type. You can match on more than one type in a case but Go can’t change the type of the value for you, so you’ll still need to do type assertion. One of the things that makes this a type<a id="_idIndexMarker380"/> switch and not an expression switch is the <strong class="source-inline">&lt;value&gt;.(type)</strong> notation. You can only use <a id="_idTextAnchor1030"/><a id="_idTextAnchor1031"/>that as part of <a id="_idTextAnchor1032"/>a type switch. Something else that’s unique to type switches is that you can’t use a <span class="No-Break"><strong class="source-inline">fallthrough</strong></span><span class="No-Break"> statement.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor1033"/>Exercise 4.22 – Type switch</h2>
			<p>In this exercise, we’ll update our <strong class="source-inline">doubler</strong> function to use a type switch and expand its abilities to deal with more<a id="_idTextAnchor1034"/><a id="_idTextAnchor1035"/><a id="_idTextAnchor1036"/> types. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder and add a file named <strong class="source-inline">main.go</strong> <span class="No-Break">to it.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the package <span class="No-Break">and imports:</span><pre class="source-code">
package main
import (
  "errors"
  "fmt"
)</pre></li>				<li>Create our function, which takes a single <strong class="source-inline">interface{}</strong> argument and returns a string and <span class="No-Break">an error:</span><pre class="source-code">
func doubler(v interface{}) (string, error) {</pre></li>				<li>Create a type switch using <span class="No-Break">our argument:</span><pre class="source-code">
  switch t := v.(type) {</pre></li>				<li>For <strong class="source-inline">string</strong> and <strong class="source-inline">bool</strong>, since we’re only matching on one type, we don’t need to do any extra safety checks and can work with the <span class="No-Break">value directly:</span><pre class="source-code">
  case string:
   return t + t, nil
  case bool:
   if t {
     return "truetrue", nil
   }
   return "falsefalse", nil</pre></li>				<li>For the floats, we’re<a id="_idIndexMarker381"/> matching on more than one type. This means we need to do type assertion to be able to work with <span class="No-Break">the value:</span><pre class="source-code">
  case float32, float64:
   if f, ok := t.(float64); ok {
     return fmt.Sprint(f * 2), nil
   }</pre></li>				<li>If this type assertion were to fail, we’d panic, but we can rely on the logic that only <strong class="source-inline">float32</strong> can work directly with the result of <span class="No-Break">type assertion:</span><pre class="source-code">
  return fmt.Sprint(t.(float32) * 2), nil</pre></li>				<li>Match all the <strong class="source-inline">int</strong> and <strong class="source-inline">uint</strong> types. We’ve been able to remove lots of code here by not needing to do the type-safety <span class="No-Break">checks ourselves:</span><pre class="source-code">
  case int:
   return fmt.Sprint(t * 2), nil
  case int8:
   return fmt.Sprint(t * 2), nil
  case int16:
   return fmt.Sprint(t * 2), nil
  case int32:
   return fmt.Sprint(t * 2), nil
  case int64:
   return fmt.Sprint(t * 2), nil
  case uint:
   return fmt.Sprint(t * 2), nil
  case uint8:
   return fmt.Sprint(t * 2), nil
  case uint16:
   return fmt.Sprint(t * 2), nil
  case uint32:
   return fmt.Sprint(t * 2), nil
  case uint64:
   return fmt.Sprint(t * 2), nil</pre></li>				<li>We’ll use <strong class="source-inline">default</strong> to return an error. Then, we’ll close the <strong class="source-inline">switch </strong>statement <span class="No-Break">and function:</span><pre class="source-code">
  default:
  return "", errors.New("unsupported type passed")
  }
}</pre></li>				<li>In the <strong class="source-inline">main()</strong> function, call <a id="_idIndexMarker382"/>our function with even more data and print the results to <span class="No-Break">the console:</span><pre class="source-code">
func main() {
  res, _ := doubler(-5)
  fmt.Println("-5 :", res)
  res, _ = doubler(5)
  fmt.Println("5 :", res)
  res, _ = doubler("yum")
  fmt.Println("yum :", res)
  res, _ = doubler(true)
  fmt.Println("true:", res)
  res, _ = doubler(float32(3.14))
  fmt.Println("3.14:", res)
}</pre></li>				<li>Save the file. Then, in the folder you cre<a id="_idTextAnchor1037"/>ated in <em class="italic">step 1</em>, run the code using the <span class="No-Break">following command:</span><pre class="source-code">
go run .</pre></li>			</ol>
			<p>Running the preceding code produces the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B18621_04_16.jpg" alt="Figure 4.16: Output after calling functions" width="1117" height="174"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.16: Output after calling functions</p>
			<p>In this exercise, we used a<a id="_idIndexMarker383"/> type switch to build a complex type-assertion scenario. Using the type switch still gives us <a id="_idTextAnchor1038"/><a id="_idTextAnchor1039"/>full control of the type ass<a id="_idTextAnchor1040"/>ertions but also lets us simplify the type-safety logic when we don’t need that level <span class="No-Break">of control.</span></p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor1041"/>Activity 4.06 – Type checker</h2>
			<p>In this activity, you’re going to write some<a id="_idIndexMarker384"/> logic that has a slice or different types of data. These data types are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">int</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">float</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">string</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">bool</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">struct</strong></span></li>
			</ul>
			<p>Create a function that accepts a value of any type. The function returns a string with the name of <span class="No-Break">the type:</span></p>
			<ul>
				<li>For <strong class="source-inline">int</strong>, <strong class="source-inline">int32</strong>, and <strong class="source-inline">int64</strong>, it <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">int</strong></span></li>
				<li>For all floats, it <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">float</strong></span></li>
				<li>For a string, it <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">string</strong></span></li>
				<li>For a Boolean, it <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">bool</strong></span></li>
				<li>For anything else, it <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">unknown</strong></span></li>
				<li>Loop all the data by<a id="_idTextAnchor1042"/> passing each one to <span class="No-Break">your function.</span></li>
				<li>Then, print the data and its type name to <span class="No-Break">the console.</span></li>
			</ul>
			<p>The expected<a id="_idIndexMarker385"/> output is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B18621_04_17.jpg" alt="Figure 4.17: Expected output" width="1650" height="287"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.17: Expected output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found in the GitHub repository folder for this chapter: <a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.06">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.06</a>. Think about the different ways you could implement this<a id="_idTextAnchor1043"/><a id="_idTextAnchor1044"/> solution depending on which Go version you are using; for example, solving this with Go 1.18’s <strong class="source-inline">any</strong> or<strong class="source-inline"> interface{}</strong> <span class="No-Break">type alias.</span></p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor1045"/>Summary</h1>
			<p>In this chapter, we got into advanced uses of variables and types in Go. Real-world code gets complicated quickly because the real world is complicated. Being able to model the data accurately and keep that data logically organized in your code helps reduce the complexity of your code to <span class="No-Break">a minimum.</span></p>
			<p>You now know how to group similar data, either in a fixed-length ordered list using an array, in a dynamic-length ordered list using a slice, or in a key-value hash using <span class="No-Break">a map.</span></p>
			<p>We learned to go beyond Go’s core types and start to create custom types based either directly on the core types or by creating a struct, which is a collection of other types held in a single type <span class="No-Break">and value.</span></p>
			<p>There are times when you’ll have type mismatches, so Go gives us the ability to convert compatible types so that they can interact in a <span class="No-Break">type-safe way.</span></p>
			<p>Go also lets us break free of its type-safety rules and gives us full control. By using type assertions, we can accept any type using the magic of <strong class="source-inline">interface{}</strong> and <strong class="source-inline">any</strong>, and then get those <span class="No-Break">types back.</span></p>
			<p>In the next chapter, we’ll explore how to group our logic into reusa<a id="_idTextAnchor1046"/>ble components and attach them to our custom types to make our code more straightforward and easier to maintain and <span class="No-Break">build with.</span></p>
		</div>
	</div></div>
<div id="book-content"><div id="sbo-rt-content"><div id="_idContainer066" class="Content">
			<h1 id="_idParaDest-174" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor1047"/>Part 2: Components</h1>
			<p>As scripts evolve, they can become unwieldy and difficult to manage. To maintain control over your codebase, it’s essential to break it down into smaller, more manageable components. This not only enhances code organization but also facilitates <span class="No-Break">code reuse.</span></p>
			<p>This section delves into the realm of componentization, empowering you to create modular and reusable <span class="No-Break">code structures.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18621_05.xhtml#_idTextAnchor1048"><em class="italic">Chapter 5</em></a>, <em class="italic">Functions – Reduce, Reuse, and Recycle</em></li>
				<li><a href="B18621_06.xhtml#_idTextAnchor1210"><em class="italic">Chapter 6</em></a>, <em class="italic">Don’t Panic! Handle Your Errors</em></li>
				<li><a href="B18621_07.xhtml#_idTextAnchor1291"><em class="italic">Chapter 7</em></a>, <em class="italic">Interfaces</em></li>
				<li><a href="B18621_08.xhtml#_idTextAnchor1341"><em class="italic">Chapter 8</em></a>, <em class="italic">Generic Algorithm Superpowers</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer067">
			</div>
		</div>
	</div></div></body></html>