- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complex Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces Go’s more complex types. This will build on what we
    learned in the previous chapter regarding Go’s core types. These complex types
    are indispensable when you build more complex software as they allow you to logically
    group related data together. This ability to group data makes code easier to understand,
    maintain, and fix.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use arrays, slices, and maps
    to group data together. You will learn to create custom types based on the core
    types. You will also learn to use structs to create structures composed of named
    fields of any other types and explain the importance of `interface{}`.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you''ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered Go’s core types. These types are critical
    to everything you do in Go, but it can be challenging to model more complex data.
    In modern computer software, we want to be able to group data and logic where
    possible. We also want to be able to make our logic reflect the real-world solutions
    we’re building.
  prefs: []
  type: TYPE_NORMAL
- en: If you were building software for cars, you would ideally want a custom type
    that embodies a car. This type should be named “car” and it should have properties
    that can store information about what kind of car it is. The logic that affects
    the car, such as starting and stopping, should be associated with the car type.
    If we had to manage more than one car, we would need to be able to group all the
    cars.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll learn about the features in Go that allow us to model
    the data part of this challenge. Then, in the next chapter, we’ll solve the behavior
    part. By using custom types, you can extend Go’s core types, and using structs
    allows you to compose a type made of other types and associate logic with them.
    Collections let you group data together and allow you to loop over and perform
    operations on them.
  prefs: []
  type: TYPE_NORMAL
- en: As the complexity of your tasks increases, Go’s complex types help you keep
    your code easy to understand and maintain. Collections such as arrays, slices,
    and maps allow you to keep related data grouped together. Go’s `struct` type allows
    you to create a single type that’s made up of other strings, numbers, and Booleans,
    giving you the power to build models of complex real-world concepts. Structs also
    allow you to attach logic to them; this allows you to have the logic that controls
    your models closely tied together.
  prefs: []
  type: TYPE_NORMAL
- en: When things get complicated with types, we need to know how to use type conversions
    and assertions to manage type mismatches correctly. We’ll also be looking at Go’s
    `interface{}` type. This type is almost magical in that it allows you to overcome
    Go’s struct typing system but in a way that’s still type-safe.
  prefs: []
  type: TYPE_NORMAL
- en: Collection types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you were dealing with a single email address, you would define a string variable
    to hold that value for you. Now, think about how you would structure your code
    if you needed to deal with between 0 and 100 email addresses. You could define
    a separate variable for each email address, but Go has something else we can use.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with lots of similar data, we put it in a collection. Go’s collection
    types are arrays, slices, and maps. Go’s collection types are strongly typed and
    easy to loop over, but they each have unique qualities that mean they are better
    suited to different use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go’s most basic collection type is an array. When you define an array, you
    must specify what type of data it may contain and how big the array is in the
    following form: `[<size>]<type>`. For example, `[10]int` is an array of size 10
    that contains integers, while `[5]string` is an array of size 5 that contains
    strings. The key to making this an array is specifying the size. If your definition
    didn’t have the size, it would seem like it works, but it would not be an array
    – it’d be a slice. A slice is a different, more flexible, type of collection that
    we’ll look at after arrays. You can set the element values to be any type, including
    pointers and arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can initialize arrays with data using the following form: `[<size>]<type>{<value1>,<value2>,…<valueN>}`.
    For example, `[5]string{1}` would initialize the array with the first value as
    1, while `[5]string{9,9,9,9,9}` would fill the array with the value nine for each
    element. When initializing with data, you can have Go set the size of the array
    based on the number of elements you initialize it with. You can take advantage
    of this by replacing the length number with `...`. For example, `[...]string{9,9,9,9,9}`
    would create an array of length five because we initialized it with five elements.
    Just as with all arrays, the length is set at compile time and is not changeable
    at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.01 – Defining an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to define a simple array of size ten that takes
    integers. Then, we’ll print out the contents. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that defines an array and then return it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `main` function, call the function, and print the result. We’ll use
    `fmt.Printf` with `%#v` to get extra details about the value, including its type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save this. Then, from within the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code provides us with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we’ve defined an array but haven’t filled it with any data.
    Since all arrays have a fixed size, when the array was printed out, it contained
    10 values. These values are empty values for whatever type the array accepts.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The array’s length is part of its type definition. If you have two arrays that
    accept the same type but they’re different sizes, they are not compatible and
    aren’t comparable with each other. To compare arrays, they must be of both the
    same length (size) and the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.02 – Comparing arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll compare arrays. First, we’ll define several arrays;
    some are comparable, while some are not. Then, we’ll run the code and fix any
    problems that come up. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that defines four arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compare the arrays and return the result of the comparison. This closes off
    this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `main` function so that it prints out the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Array type mismatch error](img/B18621_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Array type mismatch error'
  prefs: []
  type: TYPE_NORMAL
- en: You should see an error. This error is telling you that `arr1`, which is a `[5]
    int` type, and `arr4`, which is a `[9] int` type, are not the same length arrays
    and therefore are not the same underlying type in Go, meaning they aren’t comparable.
    Let’s fix that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to replace this with the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also have the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to replace this with the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the code again using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Output without error](img/B18621_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Output without error'
  prefs: []
  type: TYPE_NORMAL
- en: In our exercise, we defined some arrays, and they were all defined in slightly
    different ways. At first, we had an error because we tried to compare arrays of
    different lengths, which, in Go, means they are different types. We fixed that
    and ran the code again. Then, we could see that even though the first three arrays
    were defined using different methods, they ended up being the same or equal to
    each other. The last array, now with its type fixed, had different data contained
    in it, so it’s not the same or equal to the other arrays. The other collection
    types, that is, `slice` and `map`, are not comparable in this way. With maps and
    slices, you must loop over the contents of the two collections you’re comparing
    and compare them manually. This ability gives arrays an advantage if comparing
    data in collections is a hot path, or frequent operation, in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing arrays using keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, when we’ve initialized our arrays with data, we’ve let Go choose the
    keys for us. Keys refer to the indices or positions used to initialize specific
    values in an array. By setting values at specific indices using keys, you can
    initialize an array with desired values at specific positions while leaving other
    elements at their default values. Go allows you to pick the key you want for your
    data using `[<size>]<type>{<key1>:<value1>,…<keyN>:<valueN>}`. Go is flexible
    and lets you set keys with gaps and in any order. This ability to set values with
    a key is helpful if you’ve defined an array where the numeric keys have a specific
    meaning, and you want to set a value for a specific key but don’t need to set
    any of the other values. Using keys when initializing arrays provides greater
    flexibility and control over the placement of values within an array.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.03 – Initializing an array using keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll initialize a few arrays using some keys to set specific
    values. Then, we’ll compare them to each other. After, we’ll print out one of
    the arrays and look at its contents. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that defines three arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compare the arrays and return the last one so that we can print it out later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `main` function and call `compArrays`. Then, print out the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: Array initialized using keys](img/B18621_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Array initialized using keys'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we used keys when initializing the data for an array. For
    `arr2`, we combined the `...` shortcut with setting a key to make the array length
    directly relate to the key we set. With `arr3`, we mixed it using keys and without
    using keys to initialize the array, and we also used the keys out of order when
    setting key 0 to value 1, key 9 to value 10, and key 4 to value 5\. Go’s flexibility
    when using keys is strong and makes using arrays in this way pleasant.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at initializing arrays, let’s take a further look at reading
    their values.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve defined an array and initialized it with some data. Now, let’s
    read that data out. It’s possible to access a single element of the array using
    `<array>[<index>]`. For example, this accesses the first element of an array,
    `arr[0]`. I know 0 is the first element of the array because arrays always use
    a zero-indexed integer key. The zero index means the first index for an array
    is always 0 and the last index is always the array’s length minus 1.
  prefs: []
  type: TYPE_NORMAL
- en: The order of items in an array is guaranteed to be stable. Order stability means
    that an item placed at index 0 is always the first item in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to access specific parts of an array can be helpful in a few ways.
    It’s often necessary to validate the data in an array by checking either the first
    and/or last elements. Sometimes, the position of the data in an array is important
    so that you know you can get, for example, a product’s name from the third index.
    This positional significance is common when reading **comma-separated value**
    (**CSV**) files or other similar delimiter-separated value files. CSV is still
    in common use as it is a popular choice for exporting data from spreadsheet documents.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.04 – Reading a single item from an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll define an array and initialize it with some words.
    Then, we’ll read the words out in the form of a message and print it. Let’s get
    started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that defines an array with words. The order of the words
    is important:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a message by joining the words in a specific order and returning
    it. We’re using the `fmt.Sprintln` function here since it allows us to capture
    the formatted text before it’s printed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create our `main()` function, call the `message` function, and print it to
    the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We now understand how to access specific elements in an array using indices.
    Next, we will explore writing to an array.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once an array is defined, you’re able to make changes to individual elements
    using its index using `<array>[<index>] = <value>`. This assignment works the
    same as it does for other types of variables.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world code, you often need to modify the data in your collections after
    it has been defined based on inputs or logic.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.05 – Writing to an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll define an array and initialize it with some words.
    Then, we’ll make some changes to the words. Finally, we’ll read the words out
    to form a message and print it. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that defines an array with words. The order of the words
    is important:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll change some of the words in the array by assigning new values using an
    array index. The order this is done in doesn’t matter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a message by joining the words in a specific order and return it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create our `main()` function, call the `message` function, and print it to
    the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save and run the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You now know the basics when it comes to initializing, reading, and writing
    to an array using an index. Knowing that arrays contain multiple values, let’s
    peek at how to loop over an array.
  prefs: []
  type: TYPE_NORMAL
- en: Looping over an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common way you’ll work with arrays is by using them in loops. Due to
    the way an array’s indexes work, they are easy to loop over. The index always
    starts at 0, there are no gaps, and the last element is the array’s length, minus
    1.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, it’s also common to use a loop where we create a variable to
    represent the index and increment it manually. This type of loop is often called
    a `for i` loop since `i` is the name that’s given to the index variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can use a different letter than `i`; however, `i` is very representative
    of the word index in the case of looping an array and thereby represents idiomatic
    Go stylistically.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’ll remember from the previous chapter, a `for` loop has three possible
    parts: the logic that can run before the loop, the logic that runs on each loop
    interaction to check whether the loop should continue, and the logic that runs
    at the end of each loop iteration. A `for i` loop looks like this: `i := 0; i
    < len(arr); i++ {`. What happens is that we define `i` to be zero, which also
    means `i` only exists in the scope of the loop. Then, `i` is checked on the loop’s
    iteration to ensure it’s less than the length of the array. We check that it’s
    less than the length of the array since the length is always 1 more than the last
    index key. Lastly, we increment `i` by 1 on each loop to let us step over each
    element in the array, one by one, until we’ve reached the length of the array.'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the length of an array, it can be tempting to hardcode the
    value of the last index instead of using `len` since you know the length of your
    array is always the same. Hardcoding length is a bad idea. Hardcoding would make
    your code harder to maintain. It’s common for your data to change and evolve.
    If you ever need to come back and change the size of an array, having hardcoded
    array lengths introduces hard-to-find bugs and even runtime panics. In Go, a runtime
    panic is essentially an event that occurs when the program encounters an exceptional
    situation it cannot or should not recover from. When a panic is triggered, the
    program will terminate immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Using loops with arrays allows you to repeat the same logic for every element
    – that is, validating the data, modifying the data, or outputting the data – without
    having to duplicate the same code for multiple variables.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.06 – Looping over an array using a “for i” loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll define an array and initialize it with some numbers.
    We’ll loop over the numbers and do an operation on each one, putting the result
    in a message. Then, we’ll return the message and print it. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function. We’ll define an array with data and an `m` variable before
    the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the start of the loop. This manages the index and the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, write the body of the loop, which does an operation on each element of
    the array and adds it to the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, close the loop, return the message, and close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create our `main` function, call the `message` function, and print it to the
    console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save this code. Then, from the new folder, run the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output after looping over
    the array using the `for i` loop and multiplying the values times themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: A `for i` loop is very common, so pay close attention to the `for` loop, and
    be sure to understand what each of the three parts is doing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`len`. This feature is also true for the other collection types; that is, slice
    and map.'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the contents of an array in a loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to reading from an array in a loop, you can also change the contents
    of the array in a loop. Working with the data in each element works like working
    with variables. You use the same `for i` loops too.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with reading data from arrays, being able to change data in collections
    reduces the amount of code you need to write if each element were a standalone
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.07 – Modifying the contents of an array in a loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to define an empty array, fill it with data,
    and then modify that data. Finally, we’ll print the filled and modified array
    to the console. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that fills an array with numbers from 1 to 10:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that multiples the number from an array by itself and then
    sets the result back to the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our `main()` function, we need to define our empty array, fill it, modify
    it, and then print its contents to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save this code. Then, from the new folder, run the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Working with data in arrays is simple once you’ve understood how to use them
    in a `for i` loop. One nice thing about working with arrays over other collections
    is their fixed length. With arrays, it’s not possible to accidentally change the
    size of the array and end up in an infinite loop, which is a loop that can’t end
    and results in software that runs forever while using lots of resources.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 4.01 – Filling an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we’re going to define an array and fill it using a `for i`
    loop. The following are the steps for this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Go program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define an array with 10 elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a `for i` loop to fill that array with the numbers 1 through 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `fmt.Println` to print the array to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.01).'
  prefs: []
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays are great, but their rigidity around size can cause issues. If you wanted
    to create a function that accepted an array and sorted the data in it, it could
    only work for one size of an array. That requires you to create a function for
    each size of an array. This strictness around size makes working with arrays feel
    like a hassle and unengaging. The flip side of arrays is that they are an efficient
    way of managing sorted collections of data. Wouldn’t it be great if there were
    a way to get the efficiency of arrays but with more flexibility? Go gives you
    this in the form of slices.
  prefs: []
  type: TYPE_NORMAL
- en: A slice is a thin layer around arrays that lets you have a sorted numeric indexed
    collection without having to worry about the size. Underneath the thin layer is
    still a Go array, but Go manages all the details, such as how big an array to
    use. You use a slice just like you would an array; it only holds values of one
    type, you can read and write to each element using `[` and `]`, and they are easy
    to loop over using `for` `i` loops.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing a slice can do is be easily expanded using the built-in `append`
    function. This function accepts your slice and the values you’d like to add and
    returns a new slice with everything merged. It’s common to start with an empty
    slice and expand it as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Since a slice is a thin layer around an array, this means it’s not a true type
    like an array. You need to understand how Go uses the hidden array behind a slice.
    If you don’t, it’ll lead to subtle and difficult-to-debug errors.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world code, you should be using slices as your go-to for all sorted
    collections. You’ll be more productive because you won’t need to write as much
    code as you would with an array. Most code you’ll see in real-world projects uses
    lots of slices and rarely uses arrays. Arrays are only used when the size needs
    to be exactly a certain length, and even then, slices get used most of the time
    as they can be passed around the code more easily.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.08 – Working with slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll show you how flexible slices are by reading some data
    from a slice, passing a slice to a function, looping over a slice, reading values
    from a slice, and appending values to the end of a slice. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that takes an `int` argument and returns a `string` slice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the function’s body, check if we have the correct number of arguments being
    passed in through the command line. If not, we exit the program with an error.
    When we run our program from the command line, Go automatically places all arguments
    into `os.Args`, which is a slice of strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first element of the `os.Args` slice, `os.Args[0]`, is how the code is
    called and not an argument, so we’ll skip that and start our `for i` loop at index
    1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we’ll return the arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a function that loops over a slice and finds the longest string.
    When two words are of the same length, the first word is returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, we call the functions and check for errors. If there
    is an error, we tell the user then terminate the program with `os.Exit(1)`, which
    also returns error code 1 to the operating system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the folder it’s saved in, run the code using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we were able to see how flexible slices are and, at the same
    time, how they work just like arrays. This way of working with slices is another
    reason why Go has the feel of a dynamic language.
  prefs: []
  type: TYPE_NORMAL
- en: Appending multiple items to a slice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The built-in `append` function can add more than one value to a slice. You can
    add as many parameters to `append` as you need since the last parameter is variadic.
    Since it’s variadic, this means that you can also use the `...` notation to use
    a slice as the variadic parameter, allowing you to pass an arbitrary number of
    arguments to `append`.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to pass more than one argument to `append` comes up all the time
    in real-world code, and having it keeps Go code compact by not requiring multiple
    calls or loops to add multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.09 – Appending multiple items to a slice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll use the variadic parameter of `append` to add multiple
    values in the form of predefined data to a slice. Then, we’ll add a dynamic amount
    of data based on user input to the same slice. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to safely grab user input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that accepts a slice of strings as a parameter and returns
    a slice of strings. Then, define a slice of `strings` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add multiple strings to the slice using `append`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add more data from the parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return the variable and close the function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, get the user input, pass it to our function, and
    then print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we used two methods of adding multiple values to a slice.
    You would also use this technique if you needed to join two slices together.
  prefs: []
  type: TYPE_NORMAL
- en: While appending a slice like this to add it to another slice may seem inefficient,
    the Go runtime can spot when you’re doing an explode in an append and optimizes
    the call in the background to ensure no resources get wasted.
  prefs: []
  type: TYPE_NORMAL
- en: Creating slices from slices and arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using a similar notation to accessing a single element in an array or a slice,
    you can create new slices derived from the contents of arrays and slices. The
    most common notation is `[<low>:<high>]`. This notation tells Go to create a new
    slice with the same value type as the source slice or array and to populate the
    new slice with values by starting at the low index and then going up to, but not
    including, the high index. Low and high are optional. If you omitted low, then
    Go defaults to the first element in the source. If you omit high, then it goes
    all the way to the last value. It’s possible to skip both, and if you do, then
    the new slice has all the values from the source.
  prefs: []
  type: TYPE_NORMAL
- en: When you create new slices this way, Go doesn’t copy the values. If the source
    is an array, then that source array is the hidden array for the new slice. If
    the source is a slice, then the hidden array for the new slice is the same hidden
    array the source slice uses.
  prefs: []
  type: TYPE_NORMAL
- en: This is an important concept because modifying *ANY* slice also changes the
    underlying array, not a copy of it. Think of a slice as a “view” of the underlying
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.10 – Creating slices from a slice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll use the slice range notation to create slices with
    a variety of initial values. Commonly, in real-world code, you need to work with
    only a small part of a slice or an array. The `range` notation is a quick and
    straightforward way of getting only the data you need. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function and define a slice with nine `int` values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll extract the first value, first directly as an `int` value, then as a
    slice using both low and high, and finally using just high and skipping low. We’ll
    write the values to a message string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll get the last element. To get the `int` value, we’ll use the length
    and subtract 1 from the index. We use that same logic when setting the low for
    the range notation. For high, we can use the length of the slice. Finally, we
    can see we can skip high and get the same result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s get the first five values and add them to the message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll get the last four values and add them to the message as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we’ll extract five values from the middle of the slice and get them
    in the message too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we’ll return the message and close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `main`, we’ll print the message out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: Output after creating slices from a slice](img/B18621_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Output after creating slices from a slice'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we tried out a few ways to create slices from another slice.
    You can also use these same techniques on an array as the source. We saw that
    both start and stop indexes are optional. If you don’t have a start index, it’ll
    start at the beginning of the source slice or array. If you don’t have a stop
    index, then it’ll stop at the end of the array. If you skip both start and stop
    indexes, it’ll make a copy of the slice or array. This trick is useful for turning
    an array into a slice but not helpful for copying slices because the two slices
    share the same hidden array.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding slice internals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Slices are great and should be your go-to when you need an ordered list, but
    if you don’t know how they work under the hood, they cause hard-to-spot bugs.
  prefs: []
  type: TYPE_NORMAL
- en: An array is a value type that’s like a `string` or an `int` type. Value types
    can be copied and compared to themselves. These value types, once copied, are
    not connected to their source values. Slices don’t work like value types; they
    work more like pointers, but they are also not pointers.
  prefs: []
  type: TYPE_NORMAL
- en: The key to staying safe with a slice is to understand that there is a hidden
    array that stores the values and that making changes to the slice changes the
    underlying array. These changes may or may not require that the hidden array be
    replaced with a bigger one. The fact that the management of the hidden array happens
    in the background is what makes it hard to reason well about what’s going on with
    your slices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Slices have three hidden properties: length, a pointer to the hidden array,
    and wherein the hidden array its starting point is. When you append to a slice,
    one or all of these properties get updated. Which properties get updated depends
    on whether the hidden array is full or not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The size of the hidden array and the size of the slice are not always the same.
    The size of the slice is its length, which we can find out by using the `len`
    built-in function. The size of the hidden array is the capacity of the slice.
    There is also a built-in function that tells you the capacity of a slice; that
    is, `cap`. When you add a new value to a slice using `append`, one of two things
    happens: if the slice has extra capacity – that is, the hidden array is not full
    yet – it adds the value to the hidden array and then updates the slice’s length
    property. If the hidden array is full, Go creates a new, larger, array. Go then
    copies all the values from the old array into the new array and adds the new value
    too. Then, Go updates the slice from pointing to the old array to the new array
    and updates the length of the slice and, possibly, its starting point.'
  prefs: []
  type: TYPE_NORMAL
- en: The starting point only comes into play if the slice is a subset of values from
    an array or a slice not starting at the first element, as in our example, where
    we got the last five elements of a slice. The rest of the time, it’ll be the first
    element in the hidden array.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to control the size of the hidden array when you define a slice.
    Go’s built-in `make` function allows you to set the length and capacity of a slice
    when creating it. The syntax looks like this: `make(<sliceType>, <length>, <capacity>)`.
    When creating a slice using `make`, the capacity is optional, but the length is
    required.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.11 – Using make to control the capacity of a slice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, using the `make` function, we’ll create several slices and
    display their length and capacity. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that returns three `int` slices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a slice using the `var` notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a slice using `make` and set only the length:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a slice that uses both the length and capacity of the slices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return the three slices and close the function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, call the function we created and capture the returned
    values. For each slice, print its length and capacity to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Output displaying slices](img/B18621_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Output displaying slices'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we used `make`, `len`, and `cap` to control and display the
    length and capacity of a slice when defining one.
  prefs: []
  type: TYPE_NORMAL
- en: If you already know the maximum size your slice will need, setting the capacity
    upfront can improve performance because Go won’t have to spend extra resources
    resizing the underlying array.
  prefs: []
  type: TYPE_NORMAL
- en: Background behavior of slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to the complexity of what a slice is and how it works, you can’t directly
    compare slices to one another. If you try, Go gives you an error. You can compare
    a slice to nil, but that’s it.
  prefs: []
  type: TYPE_NORMAL
- en: A slice is not a value, and it’s not a pointer, so what is it? A slice is a
    special construct in Go. A slice doesn’t store its own values directly. In the
    background, it’s using an array that you can’t access directly. What a slice does
    store is a pointer to that hidden array, its own starting point in that array,
    how long the slice is, and what the capacity of the slice is. These values provide
    slices with a window for the hidden array. The window can be the whole hidden
    array or just a smaller portion of it. The pointer to the hidden array can be
    shared by more than one slice. This pointer sharing can result in multiple slices
    that can share the same hidden array, even though not all the slides contain the
    same data. This means that one of the slices can have more data than the other
    slices.
  prefs: []
  type: TYPE_NORMAL
- en: When a slice needs to grow beyond its hidden array, it creates a new bigger
    array, copies the contents from the old array to the new one, and points the slice
    at the new array. This array swap is why our preceding slices became disconnected.
    At first, they were pointing to the same hidden array, but when we grow the first
    slice, the array it’s pointing to changes. This change means that changes to the
    grown slice no longer affect the other slices since they are still pointing to
    the old, smaller, array.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to make a copy of a slice and need to be sure they are not connected,
    you have a few choices. You can use `append` to copy the contents of the source
    slice into another array or use the built-in `copy` function. When using `copy`,
    Go won’t change the size of the destination slice, so be sure it has enough room
    for all the elements you want to copy.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.12 – Controlling internal slice behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to explore five different ways to copy data from
    slice to slice and how that has an impact on a slice’s internal behavior. Let’s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that returns three `int` values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define an `int` slice, initialized with some data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we’ll make a simple variable copy of that slice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new slice by copying all the values from the first slice as part of
    a slice range operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change some data in the first slice. Later, we’ll see how this affects the
    second and third slices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return the same index for each slice and close the function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that will return two `int` values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a slice with some data and do a simple copy again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, we’ll append to the first slice before we do anything else. This
    operation changes the length and capacity of the slice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we’ll change the first slice, return the same indexes from the two slices,
    and close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our next function, we’ll be returning two `int` values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll define our first slice using `make` this time. When doing this, we’ll
    be setting a capacity that’s larger than its length:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s fill the first array with the same data as before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll create a new slice by copying the first slice, like we did previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll append a new value to the first slice, which changes its length but not
    its capacity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we’ll change the first slice, return the same indexes from the two slices,
    and close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this function, we’ll use `make` again to set a capacity, but we’ll use `append`
    to add elements that will go beyond that capacity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the next function, we’ll use `copy` to copy the elements from the first
    slice to the second slice. `copy` returns how many elements were copied from one
    slice to another, so we’ll return that too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the final function, we’ll use `append` to copy the value into the second
    slice. Using `append` in this way results in the values being copied into a new
    hidden array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `main`, we’ll print out all the data we returned and print it to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: Output displaying data](img/B18621_04_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Output displaying data'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we stepped through five different scenarios where we made
    copies of slice data. In the `Linked` scenario, we made a simple copy of the first
    slice and then a range copy of it. While the slices themselves are distinct and
    are no longer the same slices, in reality, it doesn’t make a difference to the
    data they hold. Each of the slices pointed to the same hidden array, so when we
    made a change to the first slice, it affected all of the slices.
  prefs: []
  type: TYPE_NORMAL
- en: In the `No Link` scenario, the setup was the same for the first and second slices,
    but before we made a change to the first slice, we appended a value to it. When
    we appended this value to it, in the background, Go needed to create a new array
    to hold the now large number of values. Since we were appending to the first slice,
    its pointer was to look at the new, bigger slice. The second slice didn’t get
    its pointer updates. That’s why, when the first slice had its value change, the
    second slice wasn’t affected. The second slice isn’t pointing to the same hidden
    array anymore, meaning they are not linked.
  prefs: []
  type: TYPE_NORMAL
- en: For the `Cap Link` scenario, the first slice was defined using `make` and with
    an oversized capacity. This extra capacity meant that when the first slice had
    a value appended to it, there was already extra room in the hidden array. This
    extra capacity means there was no need to replace the hidden array. The effect
    was that when we updated the value on the first slice, it and the second slice
    were still pointing to the same hidden array, meaning the change affected both.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Cap No Link` scenario, the setup was the same as the previous scenario,
    but when we appended values, we appended more values than there was available
    capacity. Even though there was extra capacity, there was not enough, and the
    hidden array in the first slice got replaced. The result was that the link between
    the two slices broke.
  prefs: []
  type: TYPE_NORMAL
- en: In `Copy No Link`, we used the built-in `copy` function to copy the value for
    us. While this does copy the values into a new hidden array, `copy` won’t change
    the length of the slice. This fact means that the destination slice must be the
    correct length before you do the copy. You don’t see copy much in real-world code;
    this could be because it’s easy to misuse it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, with `Append No Link`, we used `append` to do something similar to
    `copy` but without having to worry about the length. This method is most commonly
    seen in real-world code when you need to ensure you get a copy of the values that
    are not linked to the source. This is easy to understand since `append` gets used
    a lot, and it’s a one-line solution. There is one slightly more efficient solution
    that avoids the extra memory allocation of the empty slice in the first argument
    of `append`. You can reuse the first slice by creating a 0-capacity range copy
    of it. This alternative looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Can you see something new here? This uses the seldom-used slice range notation
    of `<slice>[<low>:<high>:<capacity>]`. With the current Go compiler, this is the
    most memory-efficient way to copy a slice.
  prefs: []
  type: TYPE_NORMAL
- en: Map fundamentals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While arrays and slices are similar and can sometimes be interchangeable, Go’s
    other collection type, `map`, is quite different and is not interchangeable with
    `array` and `slice`. Go’s `map` type serves a different purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Go’s map is a hashmap in computer science terms. The main difference between
    a map and the other collection types relates to its key. In an array or slice,
    the key is a placeholder (the index number), and it has no meaning of its own.
    It’s only there to act as a counter and has no direct relationship with the value.
  prefs: []
  type: TYPE_NORMAL
- en: With a map, the key is data – data that has a real relationship with the value.
    For example, you could have a collection of user account records in a map. The
    key would be the users’ employee IDs. An employee ID is real data and not just
    an arbitrary placeholder. If someone were to give you their employee ID, you’d
    be able to look up their account records without needing to loop over the data
    to find it. With a map, you can set, get, and delete data quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access individual elements of a map in the same way as you do with
    a slice or an array: using `[` and `]`. Maps can have any type that is directly
    comparable as a key, such as an `int` or a `string` type. You can’t compare slices,
    so they can’t be keys. A map’s value can be of any type, including pointers, slices,
    and maps.'
  prefs: []
  type: TYPE_NORMAL
- en: You shouldn’t use a map as an ordered list. Even if you were to use an `int`
    type for a map’s keys, maps are not guaranteed to always start at index 0, and
    they are not guaranteed to not have any gaps in the keys. This feature could be
    an advantage, even if you did want `int` keys. If you had sparsely populated data
    – that is, values with gaps between keys– in a slice or an array, it would contain
    lots of zero data. In a map, it would only contain the data you set.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a map, you use the following notation: `map[<key_type>]<value_type>`'
  prefs: []
  type: TYPE_NORMAL
- en: You can use `make` to create maps, but the arguments for `make` are different
    when using `make` to create a map. Go can’t create keys for a map, so it’s not
    possible to create a map of an arbitrary length like you can with a slice. You
    can suggest a capacity for the compiler to use for your map. Suggesting the capacity
    for a map is optional, and `map` can’t be used with `cap` to check what its capacity
    is.
  prefs: []
  type: TYPE_NORMAL
- en: Maps are like slices in that they are not a value and not a pointer. A map is
    a special construct in Go. You’ll need to take the same care when copying the
    variable or the values. Since you can’t control or check the capacity of a map,
    they are even more challenging when you want to know what’s going to happen when
    you add elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Go does not help you manage your keys with maps, this means you must
    specify keys when initializing a map with data. It’s the same notation as the
    other collection types; that is, `map[<key_type>]<value_type>{<key1>: <value>,
    … <``keyN>:, <valueN>}`.'
  prefs: []
  type: TYPE_NORMAL
- en: Once defined, you can set values without needing to worry about the length of
    the map like you do with arrays and slices. Setting a value is just like the other
    collections; that is, `<map>[<key>] = <value>`. Something that you do need to
    do before setting the value of a map is to make sure you’ve initialized it first.
    If you try to set a value of an uninitialized map, it causes a runtime panic.
    To avoid this, it’s good practice to avoid defining a map using `var`. If you
    initialize the map with data or use `make` to create your maps, you won’t have
    this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.13 – Creating, reading, and writing a map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to define a map with some data and then add a
    new element to it. Finally, we’ll print the map to the console. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that returns a `map` type with `string` keys and `string`
    values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `map` type with `string` keys and `string` values and then initialize
    it with some elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll add a new element to the `map` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return the `map` type and close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main` function, print the `map` type to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we created a map, initialized it with data, and then added
    a new element. This exercise shows that working with maps is similar to working
    with arrays and slices. When you should use a map comes down to the kinds of data
    you’ll store in it and if your access pattern needs access to individual items
    rather than a list of items.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You won’t always know whether a key exists in a map before needing to use it
    to get a value. When you’re getting a value for a key that doesn’t exist in a
    map, Go returns the zero value for the map’s value type. Having logic that works
    with zero values is a valid way to program in Go, but that’s not always possible.
    If you can’t use zero-value logic, maps can return an extra return value when
    you need it. The notation looks like this: `<value>, <exists_value> := <map>[<key>]`.
    Here, `exists_value` is a Boolean value that is `true` if a key exists in the
    map; otherwise, it’s `false`. This is typically represented with a Boolean value
    called `ok`. When looping over a map, you should use the `range` keyword and never
    rely on the order of the items in it. Go doesn’t guarantee the order of items
    in a map. To ensure no one replies on the order of the elements, Go purposely
    randomizes the order of them when you range over a map. If you did need to loop
    over the elements of your map in a specific order, you’d need to use an array
    or a slice to assist you with that.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.14 – Reading from a map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to read from a map using direct access and a
    loop. We’ll also check to see if a key exists in the map. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that returns a `map` type with a string key and a string
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `map` type and initialize it with data. Then, return the `map` type
    and close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this function, we’ll accept a string as input. The function will also return
    a string and a Boolean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get a copy of the `users` map from our earlier function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get a value from the `users` maps using the passed-in ID as the key. Capture
    both the value and the `exists` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return both values and close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check that at least one argument gets passed in. If not, exit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Capture the passed argument and call the `getUser` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the key is not found, print a message, and then print all the users using
    a `range` loop. After that, exit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If everything is okay, print the name we found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Output displaying all the users and the name that was found](img/B18621_04_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Output displaying all the users and the name that was found'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned how we can check to see if a key exists in a map.
    It may look a little strange coming from other languages that require you to check
    for the existence of a key before getting the value, not after. This way of doing
    things does mean there is much less chance of runtime errors. If a zero value
    is not possible in your domain logic, then you can use that fact to check if a
    key exists.
  prefs: []
  type: TYPE_NORMAL
- en: We used a `range` loop to print all the users in our map nicely. Your output
    is probably in a different order to the output shown in the preceding screenshot,
    which is due to Go randomizing the order of the elements in a map when you use
    `range`.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 4.02 – Printing a user’s name based on user input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s now your turn to work with maps. We’re going to define a map and create
    logic to print the data in the map based on the key that’s passed to your app.
    The following are the steps for this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Go program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a `map` type with the following key-value pairs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Key*: `305`, *Value*: `Sue`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Key*: `204`, *Value*: `Bob`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Key*: `631`, *Value*: `Jake`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Key*: `073`, *Value*: `Tracy`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using `os.Args`, read a key that’s been passed in and print the corresponding
    name; for instance, `go run .` `073`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Correctly handle when no argument gets passed or if the passed argument doesn’t
    match a value in the `map` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print a message to the user with the name in the value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.02).'
  prefs: []
  type: TYPE_NORMAL
- en: Activity 4.03 – Slicing the week
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we’re going to create a slice and initialize it with some
    data. Then, we’re going to modify that slice using what we’ve learned about sub-slices.
    The following are the steps for this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Go program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a slice and initialize it with all the days of the week, starting on
    Monday and ending on Sunday.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the slice using slice ranges and append it so that the week now starts
    on Sunday and ends on Saturday.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the slice to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.03](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.03).'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting elements from a map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to remove an element from a map, you’ll need to do something different
    than you would with an array or a slice. In an array, you can’t remove elements
    since the length’s fixed; the best you can do is zero out the value. With a slice,
    you can zero out, but it’s also possible to use a combination of a slice `range`
    and `append` to cut out one or more elements. With a map, you could zero the value
    out, but the element still exists, so it causes problems if you’re checking whether
    a key exists in your logic. You can’t use slice ranges on a map to cut elements
    out either.
  prefs: []
  type: TYPE_NORMAL
- en: To remove an element, we need to use the built-in `delete` function. The function
    signature for `delete`, when used with maps, is `delete(<map>, <key>)`. The `delete`
    function doesn’t return anything, and if a key doesn’t exist, nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.15 – Deleting an element from a map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll define a map and then delete an element from it using
    user input. Then, we’ll print the now possibly smaller map to the console. Let’s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’re going to define our `users` map in the package scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that deletes from the `users` map using a passed-in string
    as the key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `main`, we’ll grab the passed-in `userID` value and print the `users` map
    to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we used the built-in `delete` function to totally remove an
    element from a map. This requirement is unique for maps; you can’t use `delete`
    on arrays or slices.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 4.04 – Removing an element from a slice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go doesn’t have anything built in to remove elements from a slice, but it’s
    possible with the techniques you’ve learned. In this activity, we’re going to
    set up a slice with some data and one element to remove. Then, you need to work
    out how to do this. There are many ways to get this done, but can you work out
    the most compact way?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps for this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Go program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a slice with the following elements in the following order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Write the code to remove the `Bad` element from the slice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the result to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.04](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.04).'
  prefs: []
  type: TYPE_NORMAL
- en: Simple custom types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can create custom types using Go’s simple types as a starting point. The
    notation is `type <name> <type>`. If we were to create an ID type based on a string,
    this would look like `type id string`. The custom type acts the same as the type
    you based it on, including getting the same zero value and having the same abilities
    to compare with other values of the same type. A custom type is not compatible
    with its base type, but you can convert your custom type back into the type it’s
    based on to allow for interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.16 – Creating a simple custom type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll define a map and then delete an element from it using
    user input and a simple custom type. Then, we’ll print the now possibly smaller
    map to the console. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a custom type called `id` based on the `string` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that returns three `id` instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For `id1`, we’ll initialize it and leave it at its zero value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For `id2`, we’ll initialize it using a string literal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, for `id3`, we’ll initialize it to zero and then set a value separately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, return the `id` instances and close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `main`, call our function and do some comparisons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this preceding comparison, we’ll convert the `id` type back into a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: Output after comparison](img/B18621_04_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Output after comparison'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we created a custom type called `id`, set data on it, and
    then compared it with values of the same type and with its base type of `string`.
  prefs: []
  type: TYPE_NORMAL
- en: Simple custom types are a foundational part of modeling the data problems you’ll
    see in the real world. Having types designed to reflect the data you need to work
    with closely helps keep your code easy to understand and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collections are perfect for grouping values of the same type and purpose together.
    There is another way of grouping data together in Go for a different purpose.
    Often, a simple string, number, or Boolean doesn’t fully capture the essence of
    the data you’ll have.
  prefs: []
  type: TYPE_NORMAL
- en: For example, for our user map, a user was represented by their unique ID and
    their first name. That is rarely going to be enough detail to be able to work
    with user records. The data you could capture about a person is almost infinite,
    such as their given, middle, and family names. Their preferred prefix and suffix,
    their date of birth, their height, weight, or where they work can also be captured.
    It would be possible to store this data in multiple maps, all with the same key,
    but that is hard to work with and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ideal thing to do is to collect all these different bits of data into a
    single data structure that you can design and control. That’s what Go’s `struct`
    type is: it’s a custom type that you can name and then specify the field properties
    and their types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The notation for structs looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Field names must be unique within a struct. You can use any type for a field,
    including pointers, collections, and other structs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access a field on a struct using the following notation: `<structValue>.<fieldName>`.
    To set a value, you use this notation: `<structValue>.<fieldName> = <value>`.
    To read a value, you use the following notation: `value = <``structValue>.<fieldName>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Structs are the closest thing that Go has to what are called classes in other
    languages, but structs have purposely been kept stripped down by Go’s designers.
    A key difference is that structs don’t have any form of inheritance. The designers
    of Go feel that inheritance causes more problems than it solves in real-world
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve defined your custom `struct` type, you can use it to create a value.
    You have several ways to create values from `struct` types. Let’s take a look
    at them now.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.17 – Creating struct types and values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to define a user struct. We’ll define some fields
    of different types. Then, we’ll create some struct values using a few different
    methods. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first thing we’ll do is define our `struct` type. You generally do this
    in the package scope (outside of any function body). We need to give it a name
    that’s unique at the package-level scope:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll add some fields of different types and then close the struct definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll create a function that returns a slice of our newly defined `struct`
    type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our first user is initialized using this key-value notation. This notation
    is the most common form to use when initializing structs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When using the key-value notation, the order of the fields doesn’t matter,
    and any you leave out will get a zero value for their type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It’s possible to initialize a struct with values only. If you do this, all
    the fields must be present, and their order must match how you defined them in
    the struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This `var` notation will create a struct where all the fields have zero values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can set values on the fields using `.` and the field name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will return the values wrapped in a slice and close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `main`, we’ll get the slice of `users`, loop over it, and print it to the
    console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: Output as per the new struct](img/B18621_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Output as per the new struct'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you defined a custom `struct` type that contained multiple
    fields, each of a different type. Then, we created values from that struct using
    a few different methods. Each of these methods is valid and useful in different
    contexts.
  prefs: []
  type: TYPE_NORMAL
- en: We defined the struct at the package scope, and while it’s not typical, you
    can define `struct` types in the function scope too. If you do define a `struct`
    type in a function, it’ll only be valid for use in that function. When defining
    a type at the package level, it’s available for use throughout the package.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to define and initialize a struct at the same time. If you
    do this, you can’t reuse the type, but it’s still a useful technique. The notation
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: You can also initialize using the key-value notation, but initializing with
    only the values is the most common when this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing structs to each other
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If all a struct’s fields are comparable types, then the struct is also comparable.
    So, if your struct is made up of `string` and `int` types, then you can compare
    whole structs to one another. If your struct has a slice in it, then you can’t.
    Go is strongly typed, so you can only compare values of the same type, but with
    structs, there is a little bit of flexibility. If the struct was defined anonymously
    and has the same structure as a named struct, then Go allows the comparison.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.18 – Comparing structs to each other
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll define a comparable struct and create a value with
    it. We’ll also define and create values with anonymous structs that have the same
    structure as our named struct. Finally, we’ll compare them and print the results
    to the console. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder and add a file named `main.go` to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s define a simple, comparable struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll create a function that returns two Booleans:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll now create our first anonymous struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The struct is considered anonymous because the `struct` type does not have a
    name. `point1` is a variable that contains an instance of the anonymous struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the second anonymous struct, we’re initializing it to zero and then changing
    the value after initialization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final struct to create uses the named `struct` type we created previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compare them. Then, return and close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `main`, we’ll call our function and print the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: Output comparing structs](img/B18621_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Output comparing structs'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw that we can work with anonymous struct values in the
    same way as named `struct` types, including comparing them. With named types,
    you can only compare structs of the same type. When you compare types in Go, Go
    compares all the fields to check for a match. Go allows a comparison of these
    anonymous structs to be made because the field names and types match. Go is a
    little flexible with comparing structs like this.
  prefs: []
  type: TYPE_NORMAL
- en: Struct composition using embedding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While inheritance is not possible with Go structs, the designers of Go did include
    an exciting alternative. The alternative is to embed types in `struct` types.
    Using embedding, you can add fields to a struct from other structs. This composition
    feature has the effect of letting you add to a struct using other structs as components.
    Embedding is different than having a field that is a `struct` type. When you embed,
    the fields from the embedded struct get promoted. Once promoted, a field acts
    as if it’s defined on the target struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'To embed a struct, you add it like you would a field, but you don’t specify
    a name. To do this, you add a `struct` type name to another struct without giving
    it a field name, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Though not common, you can embed any other type into structs. There is nothing
    to promote, so to access the embedded type, you access it using the type’s name;
    for example, `<structValue>.<type>`. This way of accessing embedded types by their
    type name is also true for structs. This means there are two valid ways to work
    with an embedded struct’s fields: `<structValue>.<fieldName>` or `<structValue>.<type>.<fieldName>`.
    This ability to access a type by its name also means that the type’s names must
    be unique between the embedded types and the root field names. When embedding
    pointer types, the type’s name is the type without the pointer notation, so the
    name `*<type>` becomes `<type>`. The field is still a pointer, and only the name
    is different.'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to promotion, if you were to have any overlap with your struct’s
    field names, Go allows you to embed, but the promotion of the overlapping field
    doesn’t happen. You can still access the field by going through the type name
    path.
  prefs: []
  type: TYPE_NORMAL
- en: You can’t use promotion when initializing structs with embedded types. To initialize
    the data, you must use the embedded type’s name.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.19 – Struct embedding and initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll define some structs and custom types. We’ll embed those
    types into a struct. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a custom `string` type called `name`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a struct called `location` with two `int` fields; that is, `x` and `y`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `size` struct with two `int` fields; that is, `width` and `height`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a struct named `dot`. This embeds each of the preceding structs in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that returns a slice of dots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our first `dot` instance uses the `var` notation. This will result in all the
    fields having a zero value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With `dot2`, we’re also initializing with zero values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To set the name, we use the type’s name as if it were a field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For `size` and `location`, we’ll use the promoted fields to set their value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When initializing embedded types, you can’t use promotion. For `name`, the
    result is the same, but for `location` and `size`, you need to put more work into
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For `dot4`, we’ll use the type names to set data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return all the dots in a slice and then close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `main`, call the function. Then, loop over the slice and print it to the
    console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12: Output after struct embedding and initialization](img/B18621_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Output after struct embedding and initialization'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we were able to define a complex struct by embedding other
    types into it. Embedding allows you to reuse common structures by reducing the
    duplicated code but still giving your struct a flat API.
  prefs: []
  type: TYPE_NORMAL
- en: We may not see much embedding in real-world Go code. It does come up, but the
    complexity and exception mean that Go developers prefer to have the other structs
    as named fields.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 4.05 – Creating a locale checker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we’re going to create a locale validator. A locale is an internationalization
    and localization concept that is a combination of both a language and a country
    or region. We’ll create a struct that represents a locale. After, we’re going
    to define a list of locales our code supports. Then, we’ll read in some locale
    code from the command line and print out whether our code accepts that locale
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps for this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Go program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a struct with a field for language and a separate field for country or
    region.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a collection to hold the local definitions for at least five locales;
    for instance, `en_US`, `en_CN`, `fr_CN`, `fr_FR`, and `ru_RU`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read in the locale from the command line; for example, using `os.Args`. Be sure
    to have error checking and validation working.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the passed locale string into a new locale struct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use that struct to check whether the passed struct is supported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print a message to the console stating whether the locale is supported or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13: Expected output](img/B18621_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.05](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.05).'
  prefs: []
  type: TYPE_NORMAL
- en: Type conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times when your types won’t match up, and with Go’s strict type system,
    if types are not the same, they can’t interact with one another. In these cases,
    you have two options. If the two types are compatible, you can do type conversion
    – that is, you can create a new value by changing one type to another. The notation
    to do this is `<value>.(<type>)`. When working with strings, we used this notation
    to cast a string to a slice of runes or bytes and back again. This works because
    a string is a special type that stores the string’s data as a slice of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '*It’s important to note that not all type conversions preserve the original
    value*. When working with numeric type conversion, the numbers can change from
    their original value. If you convert from a large `int` type (for example, `int64`)
    into a smaller `int` type (for example, `int8`), it causes the number to overflow.
    If you were to convert from an unsigned `int` type (for example, `uint64`) into
    a signed `int` type (for example, `int64`), this overflow happens because unsigned
    `int` types can store a higher number than a signed `int` type. This overflowing
    is the same when converting an `int` type into a `float` type since the `float`
    type splits its storage space between whole numbers and decimals. When converting
    from a `float` type to an `int` type, the decimal part is truncated.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s still perfectly reasonable to do these types of lossy conversions, and
    they happen all the time in real-world code. If you know that the data you’re
    dealing with doesn’t cross these thresholds, then there’s no need to worry.
  prefs: []
  type: TYPE_NORMAL
- en: Go does its best to guess at the types that need conversion. This is called
    implicit type conversion. For example, `math.MaxInt8` is an `int` type, and if
    you try to assign it to a number other than an `int` type, Go does an implicit
    type conversion for you.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.20 – Numeric type conversions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll do some numeric type conversions and intentionally
    cause some data issues. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that returns a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define some variables to do our work. Go is doing an implicit conversion of
    the `math.MaxInt8` int into an `int8` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we’ll convert from a smaller `int` type into a larger `int` type. This
    is always a safe operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll convert from an `int` type that’s 1 above `int8`’s maximum size.
    This will cause an overflow to `int8`’s minimum size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll convert our `int8` type into a `float64` type. This doesn’t cause
    an overflow and the data is unchanged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we’ll convert a `float` type into an `int` type. All the decimal data
    is lost but the whole number is kept as is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return the message and then close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, call the function and print it to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14: Output after conversion](img/B18621_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: Output after conversion'
  prefs: []
  type: TYPE_NORMAL
- en: Type assertions and interface{}
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve used `fmt.Print` and its siblings a great deal for writing our code,
    but how does a function such as `fmt.Print` take any type of value when Go is
    a strongly typed language? Let’s take a look at the actual Go standard library
    code for `fmt.Print`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: I hope you can see that looking at Go’s source code is not scary – it’s a great
    way to see how you should do things, and I recommend looking at it whenever you
    are curious about how they do something properly using idiomatic Go.
  prefs: []
  type: TYPE_NORMAL
- en: By looking at this code, we can see that `fmt.Print` has a variadic of the `interface{}`
    type. We’ll cover interfaces in more detail later, but for now, what you need
    to know is that an interface in Go describes which functions a type must have
    to conform to that interface. Interfaces in Go don’t describe fields and don’t
    describe a type’s core value, such as being a string or a number. In Go, any type
    can have functions, including strings and numbers. What `interface{}` is describing
    is a type with no functions. What use is a value with no function, no fields,
    and no core value? None, but it’s still a value, and it can still be passed around.
    This interface is not setting the type of the value but controlling which values
    it will allow for a variable with that interface. Which types in Go conform to
    `interface{}`? All of them! Any of Go’s types or any custom type you create conform
    to `interface{}`, and this is how `fmt.Print` can accept any type. You can also
    use `interface{}` in your code to achieve the same result.
  prefs: []
  type: TYPE_NORMAL
- en: The Go 1.18 release included an alias of the `interface{}` type called `any`.
    Since they are equivalent in usage, `any` is interchangeable with `interface{}`
    in the earlier code example that we saw at the beginning of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your variable that conforms to `interface{}`, what can you do
    with it? Even if the underlying value of your `interface{}` variable has functions,
    fields, or a core value, you can’t use them because Go is enforcing the interface’s
    contract, which is why this is still all type-safe.
  prefs: []
  type: TYPE_NORMAL
- en: To unlock the capabilities of the value masked by `interface{}` or `any`, we
    need to use type assertion. The notation for type assertion is `<value>.(<type>)`.
    Type assertion results in a value of the type that was requested and, optionally,
    a Boolean value regarding whether it was successful or not. This looks like `<value>
    := <value>.(<type>)` or `<value>, <ok> := <value>.(type)`. If you leave the Boolean
    value out and the type assertion fails, Go raises a panic.
  prefs: []
  type: TYPE_NORMAL
- en: Go doesn’t remove anything from a value when you place it in an `interface{}`
    type or `any` variable. What happens is the Go compiler prevents you from using
    it because it’s not able to perform its type-safety checks at compile time. Using
    type assertion is your instruction to Go that you want to unlock the value. When
    you do type assertion, Go performs the type-safety checks it would have done at
    compile time and at runtime, and those checks may fail. It’s then your responsibility
    to deal with the type-safety checks failing. Type assertions are a feature that
    causes runtime errors and panics, which means you must be extra careful around
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.21 – Type assertions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will perform some type assertions and ensure that all
    the safety checks are in place when we do so. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that accepts an `interface{}` type and returns a string and
    an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, we’ll check to see if our argument is an `int` type, and if it is, we’ll
    multiply it by `2` and return it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we’ll check if it’s a string, and if it is, we’ll concatenate it to itself
    and return it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we don’t get any matches, return an error. Then, close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `main`, call `doubler` with a variety of data and print the results to the
    console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15: Output showing matches](img/B18621_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: Output showing matches'
  prefs: []
  type: TYPE_NORMAL
- en: The combination of `interface{},` `any`, and type assertions allows you to overcome
    Go’s strict type controls, in turn allowing you to create functions that can work
    with any type of variable. The challenge is that you lose the protection that
    Go gives you at compile time for type safety. It’s still possible to be safe,
    but the responsibility is yours now – do it wrong, and you’ll get a nasty runtime
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Type switch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we wanted to expand our `doubler` function to include all `int` types, we’d
    end up with a lot of duplicated logic. Go has an excellent way of dealing with
    more complex type assertion situations, known as a type switch. Here’s what it
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: The type switch only runs your logic if it matches the type you’re looking for,
    and it sets the value to that type. You can match on more than one type in a case
    but Go can’t change the type of the value for you, so you’ll still need to do
    type assertion. One of the things that makes this a type switch and not an expression
    switch is the `<value>.(type)` notation. You can only use that as part of a type
    switch. Something else that’s unique to type switches is that you can’t use a
    `fallthrough` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.22 – Type switch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll update our `doubler` function to use a type switch
    and expand its abilities to deal with more types. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create our function, which takes a single `interface{}` argument and returns
    a string and an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a type switch using our argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For `string` and `bool`, since we’re only matching on one type, we don’t need
    to do any extra safety checks and can work with the value directly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For the floats, we’re matching on more than one type. This means we need to
    do type assertion to be able to work with the value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If this type assertion were to fail, we’d panic, but we can rely on the logic
    that only `float32` can work directly with the result of type assertion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Match all the `int` and `uint` types. We’ve been able to remove lots of code
    here by not needing to do the type-safety checks ourselves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll use `default` to return an error. Then, we’ll close the `switch` statement
    and function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, call our function with even more data and print the
    results to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16: Output after calling functions](img/B18621_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: Output after calling functions'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we used a type switch to build a complex type-assertion scenario.
    Using the type switch still gives us full control of the type assertions but also
    lets us simplify the type-safety logic when we don’t need that level of control.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 4.06 – Type checker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, you’re going to write some logic that has a slice or different
    types of data. These data types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a function that accepts a value of any type. The function returns a
    string with the name of the type:'
  prefs: []
  type: TYPE_NORMAL
- en: For `int`, `int32`, and `int64`, it returns `int`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all floats, it returns `float`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a string, it returns `string`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a Boolean, it returns `bool`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For anything else, it returns `unknown`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loop all the data by passing each one to your function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, print the data and its type name to the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17: Expected output](img/B18621_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.06](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.06).
    Think about the different ways you could implement this solution depending on
    which Go version you are using; for example, solving this with Go 1.18’s `any`
    or `interface{}` type alias.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got into advanced uses of variables and types in Go. Real-world
    code gets complicated quickly because the real world is complicated. Being able
    to model the data accurately and keep that data logically organized in your code
    helps reduce the complexity of your code to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to group similar data, either in a fixed-length ordered list
    using an array, in a dynamic-length ordered list using a slice, or in a key-value
    hash using a map.
  prefs: []
  type: TYPE_NORMAL
- en: We learned to go beyond Go’s core types and start to create custom types based
    either directly on the core types or by creating a struct, which is a collection
    of other types held in a single type and value.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when you’ll have type mismatches, so Go gives us the ability
    to convert compatible types so that they can interact in a type-safe way.
  prefs: []
  type: TYPE_NORMAL
- en: Go also lets us break free of its type-safety rules and gives us full control.
    By using type assertions, we can accept any type using the magic of `interface{}`
    and `any`, and then get those types back.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll explore how to group our logic into reusable components
    and attach them to our custom types to make our code more straightforward and
    easier to maintain and build with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Components'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As scripts evolve, they can become unwieldy and difficult to manage. To maintain
    control over your codebase, it’s essential to break it down into smaller, more
    manageable components. This not only enhances code organization but also facilitates
    code reuse.
  prefs: []
  type: TYPE_NORMAL
- en: This section delves into the realm of componentization, empowering you to create
    modular and reusable code structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18621_05.xhtml#_idTextAnchor1048), *Functions – Reduce, Reuse,
    and Recycle*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18621_06.xhtml#_idTextAnchor1210), *Don’t Panic! Handle Your
    Errors*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18621_07.xhtml#_idTextAnchor1291), *Interfaces*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18621_08.xhtml#_idTextAnchor1341), *Generic Algorithm Superpowers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
