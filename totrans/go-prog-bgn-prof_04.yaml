- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Complex Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂类型
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces Go’s more complex types. This will build on what we
    learned in the previous chapter regarding Go’s core types. These complex types
    are indispensable when you build more complex software as they allow you to logically
    group related data together. This ability to group data makes code easier to understand,
    maintain, and fix.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Go 的更复杂类型。这将建立在我们在上一章中关于 Go 核心类型所学的知识之上。当你构建更复杂的软件时，这些复杂类型是必不可少的，因为它们允许你逻辑地将相关数据分组在一起。这种分组数据的能力使得代码更容易理解、维护和修复。
- en: By the end of this chapter, you will be able to use arrays, slices, and maps
    to group data together. You will learn to create custom types based on the core
    types. You will also learn to use structs to create structures composed of named
    fields of any other types and explain the importance of `interface{}`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用数组、切片和映射来分组数据。你将学习根据核心类型创建自定义类型。你还将学习使用结构体来创建由任何其他类型的命名字段组成的结构，并解释
    `interface{}` 的重要性。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you''ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要 Go 版本 1.21 或更高。本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04)。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we covered Go’s core types. These types are critical
    to everything you do in Go, but it can be challenging to model more complex data.
    In modern computer software, we want to be able to group data and logic where
    possible. We also want to be able to make our logic reflect the real-world solutions
    we’re building.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了 Go 的核心类型。这些类型对于你在 Go 中所做的所有事情都至关重要，但建模更复杂的数据可能具有挑战性。在现代计算机软件中，我们希望尽可能地将数据和逻辑分组在一起。我们还希望我们的逻辑能够反映我们正在构建的现实世界解决方案。
- en: If you were building software for cars, you would ideally want a custom type
    that embodies a car. This type should be named “car” and it should have properties
    that can store information about what kind of car it is. The logic that affects
    the car, such as starting and stopping, should be associated with the car type.
    If we had to manage more than one car, we would need to be able to group all the
    cars.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在为汽车编写软件，理想情况下你希望有一个体现汽车的定制类型。这个类型应该命名为“car”，并且它应该有属性可以存储有关它是哪种汽车的信息。影响汽车的逻辑，如启动和停止，应该与汽车类型相关联。如果我们需要管理多辆汽车，我们需要能够将所有汽车分组在一起。
- en: In this chapter, we’ll learn about the features in Go that allow us to model
    the data part of this challenge. Then, in the next chapter, we’ll solve the behavior
    part. By using custom types, you can extend Go’s core types, and using structs
    allows you to compose a type made of other types and associate logic with them.
    Collections let you group data together and allow you to loop over and perform
    operations on them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习 Go 中允许我们建模此挑战数据部分的特性。然后，在下一章中，我们将解决行为部分。通过使用自定义类型，你可以扩展 Go 的核心类型，使用结构体允许你组合由其他类型组成的类型，并将逻辑与它们关联起来。集合允许你将数据分组在一起，并允许你遍历和操作它们。
- en: As the complexity of your tasks increases, Go’s complex types help you keep
    your code easy to understand and maintain. Collections such as arrays, slices,
    and maps allow you to keep related data grouped together. Go’s `struct` type allows
    you to create a single type that’s made up of other strings, numbers, and Booleans,
    giving you the power to build models of complex real-world concepts. Structs also
    allow you to attach logic to them; this allows you to have the logic that controls
    your models closely tied together.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你任务的复杂性增加，Go 的复杂类型可以帮助你保持代码易于理解和维护。例如数组、切片和映射等集合允许你将相关数据分组在一起。Go 的 `struct`
    类型允许你创建由其他字符串、数字和布尔值组成的单一类型，这让你能够构建复杂现实世界概念的模型。结构体还允许你将逻辑附加到它们上；这允许你将控制模型的逻辑紧密地结合在一起。
- en: When things get complicated with types, we need to know how to use type conversions
    and assertions to manage type mismatches correctly. We’ll also be looking at Go’s
    `interface{}` type. This type is almost magical in that it allows you to overcome
    Go’s struct typing system but in a way that’s still type-safe.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型变得复杂时，我们需要知道如何使用类型转换和断言来正确地处理类型不匹配。我们还将查看 Go 的 `interface{}` 类型。这种类型几乎是神奇的，因为它允许你克服
    Go 的结构类型系统，但以一种仍然类型安全的方式。
- en: Collection types
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合类型
- en: If you were dealing with a single email address, you would define a string variable
    to hold that value for you. Now, think about how you would structure your code
    if you needed to deal with between 0 and 100 email addresses. You could define
    a separate variable for each email address, but Go has something else we can use.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只处理一个电子邮件地址，你会定义一个字符串变量来为你保存该值。现在，考虑如果你需要处理 0 到 100 个电子邮件地址，你会如何组织你的代码。你可以为每个电子邮件地址定义一个单独的变量，但
    Go 有其他我们可以使用的东西。
- en: When dealing with lots of similar data, we put it in a collection. Go’s collection
    types are arrays, slices, and maps. Go’s collection types are strongly typed and
    easy to loop over, but they each have unique qualities that mean they are better
    suited to different use cases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大量类似数据时，我们会将其放入集合中。Go 的集合类型包括数组、切片和映射。Go 的集合类型是强类型的，并且易于循环遍历，但它们各自具有独特的特性，意味着它们更适合不同的用例。
- en: Arrays
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Go’s most basic collection type is an array. When you define an array, you
    must specify what type of data it may contain and how big the array is in the
    following form: `[<size>]<type>`. For example, `[10]int` is an array of size 10
    that contains integers, while `[5]string` is an array of size 5 that contains
    strings. The key to making this an array is specifying the size. If your definition
    didn’t have the size, it would seem like it works, but it would not be an array
    – it’d be a slice. A slice is a different, more flexible, type of collection that
    we’ll look at after arrays. You can set the element values to be any type, including
    pointers and arrays.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Go 最基本的集合类型是数组。当你定义一个数组时，你必须指定它可以包含哪种类型的数据以及数组的大小，以下形式：`[<size>]<type>`。例如，`[10]int`
    是一个包含整数的长度为 10 的数组，而 `[5]string` 是一个包含字符串的长度为 5 的数组。使这成为一个数组的关键是指定大小。如果你的定义没有大小，它看起来像可以工作，但它不会是一个数组——它将是一个切片。切片是不同于数组的一种更灵活的集合类型，我们将在数组之后讨论。您可以设置元素值为任何类型，包括指针和数组。
- en: 'You can initialize arrays with data using the following form: `[<size>]<type>{<value1>,<value2>,…<valueN>}`.
    For example, `[5]string{1}` would initialize the array with the first value as
    1, while `[5]string{9,9,9,9,9}` would fill the array with the value nine for each
    element. When initializing with data, you can have Go set the size of the array
    based on the number of elements you initialize it with. You can take advantage
    of this by replacing the length number with `...`. For example, `[...]string{9,9,9,9,9}`
    would create an array of length five because we initialized it with five elements.
    Just as with all arrays, the length is set at compile time and is not changeable
    at runtime.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下形式使用数据初始化数组：`[<size>]<type>{<value1>,<value2>,…<valueN>}`。例如，`[5]string{1}`
    会初始化一个数组，其第一个值为 1，而 `[5]string{9,9,9,9,9}` 会将每个元素填充为数值九。当使用数据初始化时，您可以让 Go 根据您初始化时使用的元素数量来设置数组的大小。您可以通过将长度数字替换为
    `...` 来利用这一点。例如，`[...]string{9,9,9,9,9}` 会创建一个长度为五的数组，因为我们用五个元素初始化了它。就像所有数组一样，长度是在编译时设置的，并且在运行时不可更改。
- en: Exercise 4.01 – Defining an array
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.01 – 定义数组
- en: 'In this exercise, we’re going to define a simple array of size ten that takes
    integers. Then, we’ll print out the contents. Let’s get started:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个包含整数的简单数组，大小为十。然后，我们将打印出其内容。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个 `main.go` 文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中，添加包和导入：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a function that defines an array and then return it:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来定义一个数组，然后返回它：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define a `main` function, call the function, and print the result. We’ll use
    `fmt.Printf` with `%#v` to get extra details about the value, including its type:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `main` 函数，调用该函数，并打印结果。我们将使用 `fmt.Printf` 与 `%#v` 来获取关于值的额外详细信息，包括其类型：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Save this. Then, from within the new folder, run the following:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存此文件。然后，在新的文件夹中，运行以下命令：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running the preceding code provides us with the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会给我们以下输出：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this exercise, we’ve defined an array but haven’t filled it with any data.
    Since all arrays have a fixed size, when the array was printed out, it contained
    10 values. These values are empty values for whatever type the array accepts.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们定义了一个数组，但没有填充任何数据。由于所有数组都有固定的大小，当数组被打印出来时，它包含了 10 个值。这些值是数组接受的任何类型的空值。
- en: Comparing arrays
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较数组
- en: The array’s length is part of its type definition. If you have two arrays that
    accept the same type but they’re different sizes, they are not compatible and
    aren’t comparable with each other. To compare arrays, they must be of both the
    same length (size) and the same type.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的长度是其类型定义的一部分。如果你有两个接受相同类型的数组但大小不同，它们是不兼容的，并且不能相互比较。要比较数组，它们必须具有相同的长度（大小）和类型。
- en: Exercise 4.02 – Comparing arrays
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.02 – 比较数组
- en: 'In this exercise, we’ll compare arrays. First, we’ll define several arrays;
    some are comparable, while some are not. Then, we’ll run the code and fix any
    problems that come up. Let’s get started:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将比较数组。首先，我们将定义几个数组；其中一些是可比较的，而另一些则不是。然后，我们将运行代码并修复出现的任何问题。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个 `main.go` 文件到其中。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中添加包和导入：
- en: '[PRE5]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a function that defines four arrays:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，定义四个数组：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Compare the arrays and return the result of the comparison. This closes off
    this function:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较这些数组并返回比较的结果。这完成了这个函数：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Define a `main` function so that it prints out the results:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `main` 函数，使其打印出结果：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Save and run the code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行代码：
- en: '[PRE9]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '![Figure 4.1: Array type mismatch error](img/B18621_04_1.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：数组类型不匹配错误](img/B18621_04_1.jpg)'
- en: 'Figure 4.1: Array type mismatch error'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：数组类型不匹配错误
- en: You should see an error. This error is telling you that `arr1`, which is a `[5]
    int` type, and `arr4`, which is a `[9] int` type, are not the same length arrays
    and therefore are not the same underlying type in Go, meaning they aren’t comparable.
    Let’s fix that.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个错误。这个错误告诉你，`arr1`，它是一个 `[5] int` 类型的数组，和 `arr4`，它是一个 `[9] int` 类型的数组，它们的长度不同，因此在
    Go 中它们不是同一类型的数组，这意味着它们是不可比较的。让我们来修复这个问题。
- en: 'Here, we have the following:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们有以下内容：
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We need to replace this with the following:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要将其替换为以下内容：
- en: '[PRE11]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We also have the following code:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还有以下代码：
- en: '[PRE12]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We need to replace this with the following:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要将其替换为以下内容：
- en: '[PRE13]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Save and run the code again using the following command:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令再次保存并运行代码：
- en: '[PRE14]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '![Figure 4.2: Output without error](img/B18621_04_2.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2：无错误输出](img/B18621_04_2.jpg)'
- en: 'Figure 4.2: Output without error'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：无错误输出
- en: In our exercise, we defined some arrays, and they were all defined in slightly
    different ways. At first, we had an error because we tried to compare arrays of
    different lengths, which, in Go, means they are different types. We fixed that
    and ran the code again. Then, we could see that even though the first three arrays
    were defined using different methods, they ended up being the same or equal to
    each other. The last array, now with its type fixed, had different data contained
    in it, so it’s not the same or equal to the other arrays. The other collection
    types, that is, `slice` and `map`, are not comparable in this way. With maps and
    slices, you must loop over the contents of the two collections you’re comparing
    and compare them manually. This ability gives arrays an advantage if comparing
    data in collections is a hot path, or frequent operation, in your code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的练习中，我们定义了一些数组，它们都是用稍微不同的方式定义的。起初，我们有一个错误，因为我们尝试比较不同长度的数组，在 Go 中这意味着它们是不同类型的。我们修复了这个问题，并再次运行了代码。然后，我们可以看到，尽管前三个数组是用不同的方法定义的，但它们最终是相同的或彼此相等。最后一个数组，现在类型已修复，包含不同的数据，所以它不与其它数组相同或相等。其他集合类型，即
    `slice` 和 `map`，以这种方式是不可比较的。对于映射和切片，你必须遍历你正在比较的两个集合的内容，并手动比较它们。这种能力使得数组在比较集合中的数据是代码中的热点路径或频繁操作时具有优势。
- en: Initializing arrays using keys
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用键初始化数组
- en: So far, when we’ve initialized our arrays with data, we’ve let Go choose the
    keys for us. Keys refer to the indices or positions used to initialize specific
    values in an array. By setting values at specific indices using keys, you can
    initialize an array with desired values at specific positions while leaving other
    elements at their default values. Go allows you to pick the key you want for your
    data using `[<size>]<type>{<key1>:<value1>,…<keyN>:<valueN>}`. Go is flexible
    and lets you set keys with gaps and in any order. This ability to set values with
    a key is helpful if you’ve defined an array where the numeric keys have a specific
    meaning, and you want to set a value for a specific key but don’t need to set
    any of the other values. Using keys when initializing arrays provides greater
    flexibility and control over the placement of values within an array.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当我们用数据初始化数组时，我们让Go为我们选择键。键指的是用于初始化数组中特定值的索引或位置。通过使用键在特定索引处设置值，您可以在特定位置初始化具有所需值的数组，同时保留其他元素为默认值。Go允许您使用
    `[<size>]<type>{<key1>:<value1>,…<keyN>:<valueN>}` 选择您想要的数据键。Go很灵活，允许您设置带有间隔的键，并且可以按任何顺序设置。如果您定义了一个数组，其中数字键具有特定的含义，并且您想为特定的键设置值，但不需要设置其他任何值，那么使用键来初始化数组可以提供更大的灵活性和对数组中值放置的控制。
- en: Exercise 4.03 – Initializing an array using keys
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.03 – 使用键初始化数组
- en: 'In this exercise, we’ll initialize a few arrays using some keys to set specific
    values. Then, we’ll compare them to each other. After, we’ll print out one of
    the arrays and look at its contents. Let’s get started:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用一些键初始化几个数组，并设置特定的值。然后，我们将比较它们。之后，我们将打印出一个数组并查看其内容。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个 `main.go` 文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 文件中，添加包和导入语句：
- en: '[PRE15]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a function that defines three arrays:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，定义三个数组：
- en: '[PRE16]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Compare the arrays and return the last one so that we can print it out later:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较数组并返回最后一个，以便我们稍后打印出来：
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a `main` function and call `compArrays`. Then, print out the results:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `main` 函数并调用 `compArrays`。然后，打印出结果：
- en: '[PRE18]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新建的文件夹中，运行以下命令：
- en: '[PRE19]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '![Figure 4.3: Array initialized using keys](img/B18621_04_3.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3：使用键初始化的数组](img/B18621_04_3.jpg)'
- en: 'Figure 4.3: Array initialized using keys'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：使用键初始化的数组
- en: In this exercise, we used keys when initializing the data for an array. For
    `arr2`, we combined the `...` shortcut with setting a key to make the array length
    directly relate to the key we set. With `arr3`, we mixed it using keys and without
    using keys to initialize the array, and we also used the keys out of order when
    setting key 0 to value 1, key 9 to value 10, and key 4 to value 5\. Go’s flexibility
    when using keys is strong and makes using arrays in this way pleasant.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用键初始化了数组的数组数据。对于 `arr2`，我们结合了 `...` 省略符和设置键，使数组长度直接与设置的键相关联。对于 `arr3`，我们混合了使用键和不使用键来初始化数组，并且在设置键0为值1、键9为值10和键4为值5时，我们使用了不按顺序的键。Go在使用键时的灵活性很强，使得以这种方式使用数组变得愉快。
- en: Now that we’ve looked at initializing arrays, let’s take a further look at reading
    their values.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了初始化数组，接下来让我们进一步看看如何读取它们的值。
- en: Reading from an array
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数组中读取
- en: So far, we’ve defined an array and initialized it with some data. Now, let’s
    read that data out. It’s possible to access a single element of the array using
    `<array>[<index>]`. For example, this accesses the first element of an array,
    `arr[0]`. I know 0 is the first element of the array because arrays always use
    a zero-indexed integer key. The zero index means the first index for an array
    is always 0 and the last index is always the array’s length minus 1.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了一个数组并用一些数据初始化了它。现在，让我们读取这些数据。可以使用 `<array>[<index>]` 来访问数组的一个单独元素。例如，这访问了数组的第一个元素，`arr[0]`。我知道0是数组的第一个元素，因为数组总是使用零索引的整数键。零索引意味着数组的第一个索引总是0，最后一个索引总是数组的长度减1。
- en: The order of items in an array is guaranteed to be stable. Order stability means
    that an item placed at index 0 is always the first item in the array.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中元素的顺序是有保证的稳定的。顺序稳定性意味着放置在索引0处的项总是数组中的第一个项。
- en: Being able to access specific parts of an array can be helpful in a few ways.
    It’s often necessary to validate the data in an array by checking either the first
    and/or last elements. Sometimes, the position of the data in an array is important
    so that you know you can get, for example, a product’s name from the third index.
    This positional significance is common when reading **comma-separated value**
    (**CSV**) files or other similar delimiter-separated value files. CSV is still
    in common use as it is a popular choice for exporting data from spreadsheet documents.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 能够访问数组的特定部分在几种情况下可能很有用。通常需要通过检查第一个和/或最后一个元素来验证数组中的数据。有时，数据在数组中的位置很重要，例如，您可以从第三个索引获取产品名称。这种位置重要性在读取
    **逗号分隔值**（**CSV**）文件或其他类似分隔符分隔的值文件时很常见。CSV 仍然很常见，因为它是从电子表格文档导出数据的一个流行选择。
- en: Exercise 4.04 – Reading a single item from an array
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.04 – 从数组中读取单个项目
- en: 'In this exercise, we’ll define an array and initialize it with some words.
    Then, we’ll read the words out in the form of a message and print it. Let’s get
    started:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个数组并用一些单词初始化它。然后，我们将以消息的形式读取单词并打印它。让我们开始吧：
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个名为 `main.go` 的文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中添加包和导入：
- en: '[PRE20]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a function that defines an array with words. The order of the words
    is important:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，该函数定义一个包含单词的数组。单词的顺序很重要：
- en: '[PRE21]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, create a message by joining the words in a specific order and returning
    it. We’re using the `fmt.Sprintln` function here since it allows us to capture
    the formatted text before it’s printed:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过以特定顺序连接单词来创建一条消息并返回它。我们在这里使用 `fmt.Sprintln` 函数，因为它允许我们在打印之前捕获格式化的文本：
- en: '[PRE22]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create our `main()` function, call the `message` function, and print it to
    the console:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的 `main()` 函数，调用 `message` 函数，并将其打印到控制台：
- en: '[PRE23]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Save and run the code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行代码：
- en: '[PRE24]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We now understand how to access specific elements in an array using indices.
    Next, we will explore writing to an array.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了如何使用索引访问数组中的特定元素。接下来，我们将探索如何向数组写入。
- en: Writing to an array
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向数组写入
- en: Once an array is defined, you’re able to make changes to individual elements
    using its index using `<array>[<index>] = <value>`. This assignment works the
    same as it does for other types of variables.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了一个数组，您就可以使用其索引来更改单个元素，格式为 `<array>[<index>] = <value>`。这种赋值方式与其他类型的变量赋值方式相同。
- en: In real-world code, you often need to modify the data in your collections after
    it has been defined based on inputs or logic.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的代码中，您通常需要在定义集合后根据输入或逻辑修改数据。
- en: Exercise 4.05 – Writing to an array
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.05 – 向数组写入
- en: 'In this exercise, we’ll define an array and initialize it with some words.
    Then, we’ll make some changes to the words. Finally, we’ll read the words out
    to form a message and print it. Let’s get started:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个数组并用一些单词初始化它。然后，我们将对单词进行一些修改。最后，我们将读取单词以形成一条消息并打印它。让我们开始吧：
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个名为 `main.go` 的文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中添加包和导入：
- en: '[PRE26]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a function that defines an array with words. The order of the words
    is important:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，该函数定义一个包含单词的数组。单词的顺序很重要：
- en: '[PRE27]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We’ll change some of the words in the array by assigning new values using an
    array index. The order this is done in doesn’t matter:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过使用数组索引分配新值来更改数组中的某些单词。这种操作的顺序并不重要：
- en: '[PRE28]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, create a message by joining the words in a specific order and return it:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过以特定顺序连接单词来创建一条消息并返回它：
- en: '[PRE29]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create our `main()` function, call the `message` function, and print it to
    the console:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的 `main()` 函数，调用 `message` 函数，并将其打印到控制台：
- en: '[PRE30]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Save and run the code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行代码：
- en: '[PRE31]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You now know the basics when it comes to initializing, reading, and writing
    to an array using an index. Knowing that arrays contain multiple values, let’s
    peek at how to loop over an array.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经了解了使用索引初始化、读取和向数组写入的基本知识。既然我们知道数组包含多个值，让我们看看如何遍历数组。
- en: Looping over an array
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历数组
- en: The most common way you’ll work with arrays is by using them in loops. Due to
    the way an array’s indexes work, they are easy to loop over. The index always
    starts at 0, there are no gaps, and the last element is the array’s length, minus
    1.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你最常使用数组的方式是在循环中使用它们。由于数组索引的工作方式，它们很容易被循环。索引始终从0开始，没有间隔，最后一个元素是数组的长度减1。
- en: Because of this, it’s also common to use a loop where we create a variable to
    represent the index and increment it manually. This type of loop is often called
    a `for i` loop since `i` is the name that’s given to the index variable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，也常常使用循环来创建一个变量来表示索引并手动增加它。这种类型的循环通常被称为`for i`循环，因为`i`是分配给索引变量的名字。
- en: Note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can use a different letter than `i`; however, `i` is very representative
    of the word index in the case of looping an array and thereby represents idiomatic
    Go stylistically.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用除`i`以外的不同字母；然而，在循环数组的情况下，`i`非常代表单词索引，因此从风格上讲代表了Go的惯用用法。
- en: 'As you’ll remember from the previous chapter, a `for` loop has three possible
    parts: the logic that can run before the loop, the logic that runs on each loop
    interaction to check whether the loop should continue, and the logic that runs
    at the end of each loop iteration. A `for i` loop looks like this: `i := 0; i
    < len(arr); i++ {`. What happens is that we define `i` to be zero, which also
    means `i` only exists in the scope of the loop. Then, `i` is checked on the loop’s
    iteration to ensure it’s less than the length of the array. We check that it’s
    less than the length of the array since the length is always 1 more than the last
    index key. Lastly, we increment `i` by 1 on each loop to let us step over each
    element in the array, one by one, until we’ve reached the length of the array.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从上一章所记得，`for`循环有三个可能的部分：循环前可以运行的逻辑、每次循环交互时运行的逻辑以检查循环是否应该继续，以及每次循环迭代结束时运行的逻辑。一个`for
    i`循环看起来像这样：`i := 0; i < len(arr); i++ {`。发生的事情是我们将`i`定义为零，这也意味着`i`只存在于循环的作用域内。然后，在循环的迭代中检查`i`以确保它小于数组的长度。我们检查它是否小于数组的长度，因为长度总是比最后一个索引键多1。最后，我们在每次循环中增加`i`以让我们逐个遍历数组中的每个元素，直到我们达到数组的长度。
- en: When it comes to the length of an array, it can be tempting to hardcode the
    value of the last index instead of using `len` since you know the length of your
    array is always the same. Hardcoding length is a bad idea. Hardcoding would make
    your code harder to maintain. It’s common for your data to change and evolve.
    If you ever need to come back and change the size of an array, having hardcoded
    array lengths introduces hard-to-find bugs and even runtime panics. In Go, a runtime
    panic is essentially an event that occurs when the program encounters an exceptional
    situation it cannot or should not recover from. When a panic is triggered, the
    program will terminate immediately.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到数组的长度时，可能会诱使你直接硬编码最后一个索引的值而不是使用`len`，因为你知道数组的长度始终是相同的。硬编码长度是一个坏主意。硬编码会使你的代码更难维护。你的数据通常会发生变化和演变。如果你需要回来更改数组的尺寸，硬编码的数组长度会引入难以发现的错误，甚至可能导致运行时恐慌。在Go中，运行时恐慌基本上是在程序遇到它无法或不应从中恢复的异常情况时发生的事件。当触发恐慌时，程序将立即终止。
- en: Using loops with arrays allows you to repeat the same logic for every element
    – that is, validating the data, modifying the data, or outputting the data – without
    having to duplicate the same code for multiple variables.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环和数组允许你对每个元素重复相同的逻辑——即验证数据、修改数据或输出数据——而无需为多个变量重复相同的代码。
- en: Exercise 4.06 – Looping over an array using a “for i” loop
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.06 - 使用“for i”循环遍历数组
- en: 'In this exercise, we’ll define an array and initialize it with some numbers.
    We’ll loop over the numbers and do an operation on each one, putting the result
    in a message. Then, we’ll return the message and print it. Let’s get started:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个数组并用一些数字初始化它。我们将遍历这些数字并对每个数字执行一个操作，将结果放入消息中。然后，我们将返回消息并打印它。让我们开始吧：
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个名为`main.go`的文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中添加包和导入：
- en: '[PRE33]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a function. We’ll define an array with data and an `m` variable before
    the loop:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数。在循环之前，我们将定义一个包含数据的数组和`m`变量：
- en: '[PRE34]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Define the start of the loop. This manages the index and the loop:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义循环的开始。这管理索引和循环：
- en: '[PRE35]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, write the body of the loop, which does an operation on each element of
    the array and adds it to the message:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，编写循环体，对数组的每个元素执行操作并将其添加到消息中：
- en: '[PRE36]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, close the loop, return the message, and close the function:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，关闭循环，返回消息，并关闭函数：
- en: '[PRE37]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create our `main` function, call the `message` function, and print it to the
    console:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的`main`函数，调用`message`函数，并将其打印到控制台：
- en: '[PRE38]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Save this code. Then, from the new folder, run the code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存此代码。然后，从新文件夹中运行代码：
- en: '[PRE39]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Running the preceding code produces the following output after looping over
    the array using the `for i` loop and multiplying the values times themselves:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`for i`循环遍历数组并将值自乘后，运行前面的代码会产生以下输出：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: A `for i` loop is very common, so pay close attention to the `for` loop, and
    be sure to understand what each of the three parts is doing.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i`循环非常常见，所以请密切关注`for`循环，并确保你理解每个部分的作用。'
- en: Note
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`len`. This feature is also true for the other collection types; that is, slice
    and map.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`len`。这个特性也适用于其他集合类型；即切片和映射。'
- en: Modifying the contents of an array in a loop
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在循环中修改数组的内容
- en: In addition to reading from an array in a loop, you can also change the contents
    of the array in a loop. Working with the data in each element works like working
    with variables. You use the same `for i` loops too.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在循环中从数组中读取内容外，你还可以在循环中更改数组的内容。在数组中的每个元素上工作就像在工作变量上一样。你也会使用相同的`for i`循环。
- en: Just as with reading data from arrays, being able to change data in collections
    reduces the amount of code you need to write if each element were a standalone
    variable.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 就像从数组中读取数据一样，能够更改集合中的数据可以减少你需要编写的代码量，如果每个元素都是一个独立的变量。
- en: Exercise 4.07 – Modifying the contents of an array in a loop
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.07 – 在循环中修改数组的内容
- en: 'In this exercise, we’re going to define an empty array, fill it with data,
    and then modify that data. Finally, we’ll print the filled and modified array
    to the console. Let’s get started:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个空数组，用数据填充它，然后修改这些数据。最后，我们将打印填充和修改后的数组到控制台。让我们开始吧：
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件夹并将一个名为`main.go`的文件添加到其中。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中添加包和导入：
- en: '[PRE41]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a function that fills an array with numbers from 1 to 10:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，用从1到10的数字填充数组：
- en: '[PRE42]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a function that multiples the number from an array by itself and then
    sets the result back to the array:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，将数组中的数字自乘并将结果设置回数组：
- en: '[PRE43]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In our `main()` function, we need to define our empty array, fill it, modify
    it, and then print its contents to the console:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`main()`函数中，我们需要定义我们的空数组，填充它，修改它，然后将内容打印到控制台：
- en: '[PRE44]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Save this code. Then, from the new folder, run the code:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存此代码。然后，从新文件夹中运行代码：
- en: '[PRE45]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '[PRE46]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Working with data in arrays is simple once you’ve understood how to use them
    in a `for i` loop. One nice thing about working with arrays over other collections
    is their fixed length. With arrays, it’s not possible to accidentally change the
    size of the array and end up in an infinite loop, which is a loop that can’t end
    and results in software that runs forever while using lots of resources.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你了解了如何在`for i`循环中使用数组，处理数组中的数据就变得简单了。与处理其他集合相比，处理数组的一个优点是它们的固定长度。使用数组时，不可能意外地更改数组的大小，从而导致无限循环，这是一种无法结束的循环，会导致软件无限期地运行并消耗大量资源。
- en: Activity 4.01 – Filling an array
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动4.01 – 填充数组
- en: 'In this activity, we’re going to define an array and fill it using a `for i`
    loop. The following are the steps for this activity:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将定义一个数组并使用`for i`循环填充它。以下是这个活动的步骤：
- en: Create a new Go program.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Go程序。
- en: Define an array with 10 elements.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含10个元素的数组。
- en: Use a `for i` loop to fill that array with the numbers 1 through 10.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`for i`循环将数字1到10填充到数组中。
- en: Use `fmt.Println` to print the array to the console.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fmt.Println`将数组打印到控制台。
- en: 'The expected output is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.01).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在本章节的GitHub仓库文件夹中找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.01)。
- en: Slices
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片
- en: Arrays are great, but their rigidity around size can cause issues. If you wanted
    to create a function that accepted an array and sorted the data in it, it could
    only work for one size of an array. That requires you to create a function for
    each size of an array. This strictness around size makes working with arrays feel
    like a hassle and unengaging. The flip side of arrays is that they are an efficient
    way of managing sorted collections of data. Wouldn’t it be great if there were
    a way to get the efficiency of arrays but with more flexibility? Go gives you
    this in the form of slices.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 数组很棒，但它们在大小上的刚性可能会导致问题。如果你想要创建一个接受数组并对其中的数据进行排序的函数，它只能针对一个数组大小工作。这需要你为每种大小的数组创建一个函数。这种对大小的严格性使得使用数组感觉像是一种麻烦和不吸引人的体验。数组的另一面是，它们是管理排序数据集合的高效方式。如果有一种方法可以同时获得数组的效率和更大的灵活性，那岂不是很好？Go通过切片的形式为你提供了这一点。
- en: A slice is a thin layer around arrays that lets you have a sorted numeric indexed
    collection without having to worry about the size. Underneath the thin layer is
    still a Go array, but Go manages all the details, such as how big an array to
    use. You use a slice just like you would an array; it only holds values of one
    type, you can read and write to each element using `[` and `]`, and they are easy
    to loop over using `for` `i` loops.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是围绕数组的一层薄层，它让你可以拥有一个排序的数值索引集合，而无需担心大小。在薄层下面仍然是Go数组，但Go管理所有细节，例如使用多大的数组。你使用切片的方式就像使用数组一样；它只持有一种类型的值，你可以使用`[`和`]`读取和写入每个元素，并且它们很容易使用`for`
    `i`循环进行遍历。
- en: The other thing a slice can do is be easily expanded using the built-in `append`
    function. This function accepts your slice and the values you’d like to add and
    returns a new slice with everything merged. It’s common to start with an empty
    slice and expand it as needed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 切片还可以通过内置的`append`函数轻松扩展。这个函数接受你的切片和要添加的值，并返回一个包含所有内容的新的切片。通常，我们会从一个空切片开始，并根据需要扩展它。
- en: Since a slice is a thin layer around an array, this means it’s not a true type
    like an array. You need to understand how Go uses the hidden array behind a slice.
    If you don’t, it’ll lead to subtle and difficult-to-debug errors.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于切片是围绕数组的一层薄层，这意味着它不是一个真正的类型，就像数组一样。你需要了解Go如何使用切片背后的隐藏数组。如果你不了解这一点，可能会导致微妙且难以调试的错误。
- en: In real-world code, you should be using slices as your go-to for all sorted
    collections. You’ll be more productive because you won’t need to write as much
    code as you would with an array. Most code you’ll see in real-world projects uses
    lots of slices and rarely uses arrays. Arrays are only used when the size needs
    to be exactly a certain length, and even then, slices get used most of the time
    as they can be passed around the code more easily.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的代码中，你应该将切片作为所有排序集合的首选。你将更加高效，因为你不需要像使用数组那样编写那么多代码。你将在现实世界的项目中看到的大部分代码都使用了大量的切片，而很少使用数组。数组仅在需要确切长度时使用，即使在这种情况下，切片也通常被使用，因为它们可以更容易地在代码中传递。
- en: Exercise 4.08 – Working with slices
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.08 – 使用切片
- en: 'In this exercise, we’ll show you how flexible slices are by reading some data
    from a slice, passing a slice to a function, looping over a slice, reading values
    from a slice, and appending values to the end of a slice. Let’s get started:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过从切片中读取一些数据、将切片传递给函数、遍历切片、从切片中读取值以及将值追加到切片的末尾来展示切片的灵活性。让我们开始吧：
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个名为`main.go`的文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，添加包和导入：
- en: '[PRE48]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a function that takes an `int` argument and returns a `string` slice:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，该函数接受一个`int`参数并返回一个`string`切片：
- en: '[PRE49]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the function’s body, check if we have the correct number of arguments being
    passed in through the command line. If not, we exit the program with an error.
    When we run our program from the command line, Go automatically places all arguments
    into `os.Args`, which is a slice of strings:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The first element of the `os.Args` slice, `os.Args[0]`, is how the code is
    called and not an argument, so we’ll skip that and start our `for i` loop at index
    1:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, we’ll return the arguments:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, create a function that loops over a slice and finds the longest string.
    When two words are of the same length, the first word is returned:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the `main()` function, we call the functions and check for errors. If there
    is an error, we tell the user then terminate the program with `os.Exit(1)`, which
    also returns error code 1 to the operating system:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Save the file. Then, in the folder it’s saved in, run the code using the following
    command:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this exercise, we were able to see how flexible slices are and, at the same
    time, how they work just like arrays. This way of working with slices is another
    reason why Go has the feel of a dynamic language.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Appending multiple items to a slice
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The built-in `append` function can add more than one value to a slice. You can
    add as many parameters to `append` as you need since the last parameter is variadic.
    Since it’s variadic, this means that you can also use the `...` notation to use
    a slice as the variadic parameter, allowing you to pass an arbitrary number of
    arguments to `append`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Being able to pass more than one argument to `append` comes up all the time
    in real-world code, and having it keeps Go code compact by not requiring multiple
    calls or loops to add multiple values.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.09 – Appending multiple items to a slice
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll use the variadic parameter of `append` to add multiple
    values in the form of predefined data to a slice. Then, we’ll add a dynamic amount
    of data based on user input to the same slice. Let’s get started:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create a function to safely grab user input:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create a function that accepts a slice of strings as a parameter and returns
    a slice of strings. Then, define a slice of `strings` variable:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Add multiple strings to the slice using `append`:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Add more data from the parameter:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Return the variable and close the function definition:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'In the `main()` function, get the user input, pass it to our function, and
    then print the result:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this exercise, we used two methods of adding multiple values to a slice.
    You would also use this technique if you needed to join two slices together.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: While appending a slice like this to add it to another slice may seem inefficient,
    the Go runtime can spot when you’re doing an explode in an append and optimizes
    the call in the background to ensure no resources get wasted.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Creating slices from slices and arrays
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using a similar notation to accessing a single element in an array or a slice,
    you can create new slices derived from the contents of arrays and slices. The
    most common notation is `[<low>:<high>]`. This notation tells Go to create a new
    slice with the same value type as the source slice or array and to populate the
    new slice with values by starting at the low index and then going up to, but not
    including, the high index. Low and high are optional. If you omitted low, then
    Go defaults to the first element in the source. If you omit high, then it goes
    all the way to the last value. It’s possible to skip both, and if you do, then
    the new slice has all the values from the source.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: When you create new slices this way, Go doesn’t copy the values. If the source
    is an array, then that source array is the hidden array for the new slice. If
    the source is a slice, then the hidden array for the new slice is the same hidden
    array the source slice uses.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: This is an important concept because modifying *ANY* slice also changes the
    underlying array, not a copy of it. Think of a slice as a “view” of the underlying
    array.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.10 – Creating slices from a slice
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll use the slice range notation to create slices with
    a variety of initial values. Commonly, in real-world code, you need to work with
    only a small part of a slice or an array. The `range` notation is a quick and
    straightforward way of getting only the data you need. Let’s get started:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Create a function and define a slice with nine `int` values:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We’ll extract the first value, first directly as an `int` value, then as a
    slice using both low and high, and finally using just high and skipping low. We’ll
    write the values to a message string:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we’ll get the last element. To get the `int` value, we’ll use the length
    and subtract 1 from the index. We use that same logic when setting the low for
    the range notation. For high, we can use the length of the slice. Finally, we
    can see we can skip high and get the same result:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, let’s get the first five values and add them to the message:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we’ll get the last four values and add them to the message as well:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Finally, we’ll extract five values from the middle of the slice and get them
    in the message too:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then, we’ll return the message and close the function:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In `main`, we’ll print the message out:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: Output after creating slices from a slice](img/B18621_04_5.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Output after creating slices from a slice'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we tried out a few ways to create slices from another slice.
    You can also use these same techniques on an array as the source. We saw that
    both start and stop indexes are optional. If you don’t have a start index, it’ll
    start at the beginning of the source slice or array. If you don’t have a stop
    index, then it’ll stop at the end of the array. If you skip both start and stop
    indexes, it’ll make a copy of the slice or array. This trick is useful for turning
    an array into a slice but not helpful for copying slices because the two slices
    share the same hidden array.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Understanding slice internals
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Slices are great and should be your go-to when you need an ordered list, but
    if you don’t know how they work under the hood, they cause hard-to-spot bugs.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: An array is a value type that’s like a `string` or an `int` type. Value types
    can be copied and compared to themselves. These value types, once copied, are
    not connected to their source values. Slices don’t work like value types; they
    work more like pointers, but they are also not pointers.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The key to staying safe with a slice is to understand that there is a hidden
    array that stores the values and that making changes to the slice changes the
    underlying array. These changes may or may not require that the hidden array be
    replaced with a bigger one. The fact that the management of the hidden array happens
    in the background is what makes it hard to reason well about what’s going on with
    your slices.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Slices have three hidden properties: length, a pointer to the hidden array,
    and wherein the hidden array its starting point is. When you append to a slice,
    one or all of these properties get updated. Which properties get updated depends
    on whether the hidden array is full or not.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'The size of the hidden array and the size of the slice are not always the same.
    The size of the slice is its length, which we can find out by using the `len`
    built-in function. The size of the hidden array is the capacity of the slice.
    There is also a built-in function that tells you the capacity of a slice; that
    is, `cap`. When you add a new value to a slice using `append`, one of two things
    happens: if the slice has extra capacity – that is, the hidden array is not full
    yet – it adds the value to the hidden array and then updates the slice’s length
    property. If the hidden array is full, Go creates a new, larger, array. Go then
    copies all the values from the old array into the new array and adds the new value
    too. Then, Go updates the slice from pointing to the old array to the new array
    and updates the length of the slice and, possibly, its starting point.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: The starting point only comes into play if the slice is a subset of values from
    an array or a slice not starting at the first element, as in our example, where
    we got the last five elements of a slice. The rest of the time, it’ll be the first
    element in the hidden array.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to control the size of the hidden array when you define a slice.
    Go’s built-in `make` function allows you to set the length and capacity of a slice
    when creating it. The syntax looks like this: `make(<sliceType>, <length>, <capacity>)`.
    When creating a slice using `make`, the capacity is optional, but the length is
    required.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.11 – Using make to control the capacity of a slice
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, using the `make` function, we’ll create several slices and
    display their length and capacity. Let’s get started:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Create a function that returns three `int` slices:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Define a slice using the `var` notation:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Define a slice using `make` and set only the length:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Define a slice that uses both the length and capacity of the slices:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Return the three slices and close the function definition:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In the `main()` function, call the function we created and capture the returned
    values. For each slice, print its length and capacity to the console:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Output displaying slices](img/B18621_04_6.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Output displaying slices'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we used `make`, `len`, and `cap` to control and display the
    length and capacity of a slice when defining one.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: If you already know the maximum size your slice will need, setting the capacity
    upfront can improve performance because Go won’t have to spend extra resources
    resizing the underlying array.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Background behavior of slices
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to the complexity of what a slice is and how it works, you can’t directly
    compare slices to one another. If you try, Go gives you an error. You can compare
    a slice to nil, but that’s it.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: A slice is not a value, and it’s not a pointer, so what is it? A slice is a
    special construct in Go. A slice doesn’t store its own values directly. In the
    background, it’s using an array that you can’t access directly. What a slice does
    store is a pointer to that hidden array, its own starting point in that array,
    how long the slice is, and what the capacity of the slice is. These values provide
    slices with a window for the hidden array. The window can be the whole hidden
    array or just a smaller portion of it. The pointer to the hidden array can be
    shared by more than one slice. This pointer sharing can result in multiple slices
    that can share the same hidden array, even though not all the slides contain the
    same data. This means that one of the slices can have more data than the other
    slices.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: When a slice needs to grow beyond its hidden array, it creates a new bigger
    array, copies the contents from the old array to the new one, and points the slice
    at the new array. This array swap is why our preceding slices became disconnected.
    At first, they were pointing to the same hidden array, but when we grow the first
    slice, the array it’s pointing to changes. This change means that changes to the
    grown slice no longer affect the other slices since they are still pointing to
    the old, smaller, array.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: If you need to make a copy of a slice and need to be sure they are not connected,
    you have a few choices. You can use `append` to copy the contents of the source
    slice into another array or use the built-in `copy` function. When using `copy`,
    Go won’t change the size of the destination slice, so be sure it has enough room
    for all the elements you want to copy.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.12 – Controlling internal slice behavior
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to explore five different ways to copy data from
    slice to slice and how that has an impact on a slice’s internal behavior. Let’s
    get started:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Create a function that returns three `int` values:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Define an `int` slice, initialized with some data:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Then, we’ll make a simple variable copy of that slice:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Create a new slice by copying all the values from the first slice as part of
    a slice range operation:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Change some data in the first slice. Later, we’ll see how this affects the
    second and third slices:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Return the same index for each slice and close the function definition:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Create a function that will return two `int` values:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Define a slice with some data and do a simple copy again:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This time, we’ll append to the first slice before we do anything else. This
    operation changes the length and capacity of the slice:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Then, we’ll change the first slice, return the same indexes from the two slices,
    and close the function:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'In our next function, we’ll be returning two `int` values:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We’ll define our first slice using `make` this time. When doing this, we’ll
    be setting a capacity that’s larger than its length:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Let’s fill the first array with the same data as before:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now, we’ll create a new slice by copying the first slice, like we did previously:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'We’ll append a new value to the first slice, which changes its length but not
    its capacity:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Then, we’ll change the first slice, return the same indexes from the two slices,
    and close the function:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'In this function, we’ll use `make` again to set a capacity, but we’ll use `append`
    to add elements that will go beyond that capacity:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In the next function, we’ll use `copy` to copy the elements from the first
    slice to the second slice. `copy` returns how many elements were copied from one
    slice to another, so we’ll return that too:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'In the final function, we’ll use `append` to copy the value into the second
    slice. Using `append` in this way results in the values being copied into a new
    hidden array:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In `main`, we’ll print out all the data we returned and print it to the console:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: Output displaying data](img/B18621_04_7.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Output displaying data'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we stepped through five different scenarios where we made
    copies of slice data. In the `Linked` scenario, we made a simple copy of the first
    slice and then a range copy of it. While the slices themselves are distinct and
    are no longer the same slices, in reality, it doesn’t make a difference to the
    data they hold. Each of the slices pointed to the same hidden array, so when we
    made a change to the first slice, it affected all of the slices.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: In the `No Link` scenario, the setup was the same for the first and second slices,
    but before we made a change to the first slice, we appended a value to it. When
    we appended this value to it, in the background, Go needed to create a new array
    to hold the now large number of values. Since we were appending to the first slice,
    its pointer was to look at the new, bigger slice. The second slice didn’t get
    its pointer updates. That’s why, when the first slice had its value change, the
    second slice wasn’t affected. The second slice isn’t pointing to the same hidden
    array anymore, meaning they are not linked.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: For the `Cap Link` scenario, the first slice was defined using `make` and with
    an oversized capacity. This extra capacity meant that when the first slice had
    a value appended to it, there was already extra room in the hidden array. This
    extra capacity means there was no need to replace the hidden array. The effect
    was that when we updated the value on the first slice, it and the second slice
    were still pointing to the same hidden array, meaning the change affected both.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: In the `Cap No Link` scenario, the setup was the same as the previous scenario,
    but when we appended values, we appended more values than there was available
    capacity. Even though there was extra capacity, there was not enough, and the
    hidden array in the first slice got replaced. The result was that the link between
    the two slices broke.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: In `Copy No Link`, we used the built-in `copy` function to copy the value for
    us. While this does copy the values into a new hidden array, `copy` won’t change
    the length of the slice. This fact means that the destination slice must be the
    correct length before you do the copy. You don’t see copy much in real-world code;
    this could be because it’s easy to misuse it.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, with `Append No Link`, we used `append` to do something similar to
    `copy` but without having to worry about the length. This method is most commonly
    seen in real-world code when you need to ensure you get a copy of the values that
    are not linked to the source. This is easy to understand since `append` gets used
    a lot, and it’s a one-line solution. There is one slightly more efficient solution
    that avoids the extra memory allocation of the empty slice in the first argument
    of `append`. You can reuse the first slice by creating a 0-capacity range copy
    of it. This alternative looks like this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Can you see something new here? This uses the seldom-used slice range notation
    of `<slice>[<low>:<high>:<capacity>]`. With the current Go compiler, this is the
    most memory-efficient way to copy a slice.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Map fundamentals
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While arrays and slices are similar and can sometimes be interchangeable, Go’s
    other collection type, `map`, is quite different and is not interchangeable with
    `array` and `slice`. Go’s `map` type serves a different purpose.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Go’s map is a hashmap in computer science terms. The main difference between
    a map and the other collection types relates to its key. In an array or slice,
    the key is a placeholder (the index number), and it has no meaning of its own.
    It’s only there to act as a counter and has no direct relationship with the value.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: With a map, the key is data – data that has a real relationship with the value.
    For example, you could have a collection of user account records in a map. The
    key would be the users’ employee IDs. An employee ID is real data and not just
    an arbitrary placeholder. If someone were to give you their employee ID, you’d
    be able to look up their account records without needing to loop over the data
    to find it. With a map, you can set, get, and delete data quickly.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access individual elements of a map in the same way as you do with
    a slice or an array: using `[` and `]`. Maps can have any type that is directly
    comparable as a key, such as an `int` or a `string` type. You can’t compare slices,
    so they can’t be keys. A map’s value can be of any type, including pointers, slices,
    and maps.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: You shouldn’t use a map as an ordered list. Even if you were to use an `int`
    type for a map’s keys, maps are not guaranteed to always start at index 0, and
    they are not guaranteed to not have any gaps in the keys. This feature could be
    an advantage, even if you did want `int` keys. If you had sparsely populated data
    – that is, values with gaps between keys– in a slice or an array, it would contain
    lots of zero data. In a map, it would only contain the data you set.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a map, you use the following notation: `map[<key_type>]<value_type>`'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: You can use `make` to create maps, but the arguments for `make` are different
    when using `make` to create a map. Go can’t create keys for a map, so it’s not
    possible to create a map of an arbitrary length like you can with a slice. You
    can suggest a capacity for the compiler to use for your map. Suggesting the capacity
    for a map is optional, and `map` can’t be used with `cap` to check what its capacity
    is.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Maps are like slices in that they are not a value and not a pointer. A map is
    a special construct in Go. You’ll need to take the same care when copying the
    variable or the values. Since you can’t control or check the capacity of a map,
    they are even more challenging when you want to know what’s going to happen when
    you add elements.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Go does not help you manage your keys with maps, this means you must
    specify keys when initializing a map with data. It’s the same notation as the
    other collection types; that is, `map[<key_type>]<value_type>{<key1>: <value>,
    … <``keyN>:, <valueN>}`.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Once defined, you can set values without needing to worry about the length of
    the map like you do with arrays and slices. Setting a value is just like the other
    collections; that is, `<map>[<key>] = <value>`. Something that you do need to
    do before setting the value of a map is to make sure you’ve initialized it first.
    If you try to set a value of an uninitialized map, it causes a runtime panic.
    To avoid this, it’s good practice to avoid defining a map using `var`. If you
    initialize the map with data or use `make` to create your maps, you won’t have
    this problem.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.13 – Creating, reading, and writing a map
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to define a map with some data and then add a
    new element to it. Finally, we’ll print the map to the console. Let’s get started:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Create a function that returns a `map` type with `string` keys and `string`
    values:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Define a `map` type with `string` keys and `string` values and then initialize
    it with some elements:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Next, we’ll add a new element to the `map` type:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Return the `map` type and close the function:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'In the `main` function, print the `map` type to the console:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: In this exercise, we created a map, initialized it with data, and then added
    a new element. This exercise shows that working with maps is similar to working
    with arrays and slices. When you should use a map comes down to the kinds of data
    you’ll store in it and if your access pattern needs access to individual items
    rather than a list of items.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Reading from maps
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You won’t always know whether a key exists in a map before needing to use it
    to get a value. When you’re getting a value for a key that doesn’t exist in a
    map, Go returns the zero value for the map’s value type. Having logic that works
    with zero values is a valid way to program in Go, but that’s not always possible.
    If you can’t use zero-value logic, maps can return an extra return value when
    you need it. The notation looks like this: `<value>, <exists_value> := <map>[<key>]`.
    Here, `exists_value` is a Boolean value that is `true` if a key exists in the
    map; otherwise, it’s `false`. This is typically represented with a Boolean value
    called `ok`. When looping over a map, you should use the `range` keyword and never
    rely on the order of the items in it. Go doesn’t guarantee the order of items
    in a map. To ensure no one replies on the order of the elements, Go purposely
    randomizes the order of them when you range over a map. If you did need to loop
    over the elements of your map in a specific order, you’d need to use an array
    or a slice to assist you with that.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.14 – Reading from a map
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to read from a map using direct access and a
    loop. We’ll also check to see if a key exists in the map. Let’s get started:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Create a function that returns a `map` type with a string key and a string
    value:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Define a `map` type and initialize it with data. Then, return the `map` type
    and close the function:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'In this function, we’ll accept a string as input. The function will also return
    a string and a Boolean:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Get a copy of the `users` map from our earlier function:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Get a value from the `users` maps using the passed-in ID as the key. Capture
    both the value and the `exists` value:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Return both values and close the function:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Create a `main` function:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Check that at least one argument gets passed in. If not, exit:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Capture the passed argument and call the `getUser` function:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'If the key is not found, print a message, and then print all the users using
    a `range` loop. After that, exit:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'If everything is okay, print the name we found:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Then, run the following command:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Output displaying all the users and the name that was found](img/B18621_04_8.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Output displaying all the users and the name that was found'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned how we can check to see if a key exists in a map.
    It may look a little strange coming from other languages that require you to check
    for the existence of a key before getting the value, not after. This way of doing
    things does mean there is much less chance of runtime errors. If a zero value
    is not possible in your domain logic, then you can use that fact to check if a
    key exists.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: We used a `range` loop to print all the users in our map nicely. Your output
    is probably in a different order to the output shown in the preceding screenshot,
    which is due to Go randomizing the order of the elements in a map when you use
    `range`.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Activity 4.02 – Printing a user’s name based on user input
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s now your turn to work with maps. We’re going to define a map and create
    logic to print the data in the map based on the key that’s passed to your app.
    The following are the steps for this activity:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Go program.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a `map` type with the following key-value pairs:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Key*: `305`, *Value*: `Sue`'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Key*: `204`, *Value*: `Bob`'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Key*: `631`, *Value*: `Jake`'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Key*: `073`, *Value*: `Tracy`'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using `os.Args`, read a key that’s been passed in and print the corresponding
    name; for instance, `go run .` `073`.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Correctly handle when no argument gets passed or if the passed argument doesn’t
    match a value in the `map` type.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print a message to the user with the name in the value.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Note
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.02).'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Activity 4.03 – Slicing the week
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we’re going to create a slice and initialize it with some
    data. Then, we’re going to modify that slice using what we’ve learned about sub-slices.
    The following are the steps for this activity:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Go program.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a slice and initialize it with all the days of the week, starting on
    Monday and ending on Sunday.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the slice using slice ranges and append it so that the week now starts
    on Sunday and ends on Saturday.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the slice to the console.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Note
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.03](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.03).'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Deleting elements from a map
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to remove an element from a map, you’ll need to do something different
    than you would with an array or a slice. In an array, you can’t remove elements
    since the length’s fixed; the best you can do is zero out the value. With a slice,
    you can zero out, but it’s also possible to use a combination of a slice `range`
    and `append` to cut out one or more elements. With a map, you could zero the value
    out, but the element still exists, so it causes problems if you’re checking whether
    a key exists in your logic. You can’t use slice ranges on a map to cut elements
    out either.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: To remove an element, we need to use the built-in `delete` function. The function
    signature for `delete`, when used with maps, is `delete(<map>, <key>)`. The `delete`
    function doesn’t return anything, and if a key doesn’t exist, nothing happens.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.15 – Deleting an element from a map
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll define a map and then delete an element from it using
    user input. Then, we’ll print the now possibly smaller map to the console. Let’s
    get started:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'We’re going to define our `users` map in the package scope:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Create a function that deletes from the `users` map using a passed-in string
    as the key:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'In `main`, we’ll grab the passed-in `userID` value and print the `users` map
    to the console:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-475
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: In this exercise, we used the built-in `delete` function to totally remove an
    element from a map. This requirement is unique for maps; you can’t use `delete`
    on arrays or slices.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Activity 4.04 – Removing an element from a slice
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go doesn’t have anything built in to remove elements from a slice, but it’s
    possible with the techniques you’ve learned. In this activity, we’re going to
    set up a slice with some data and one element to remove. Then, you need to work
    out how to do this. There are many ways to get this done, but can you work out
    the most compact way?
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps for this activity:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Go program.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a slice with the following elements in the following order:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Write the code to remove the `Bad` element from the slice.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the result to the console.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Note
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.04](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.04).'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Simple custom types
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can create custom types using Go’s simple types as a starting point. The
    notation is `type <name> <type>`. If we were to create an ID type based on a string,
    this would look like `type id string`. The custom type acts the same as the type
    you based it on, including getting the same zero value and having the same abilities
    to compare with other values of the same type. A custom type is not compatible
    with its base type, but you can convert your custom type back into the type it’s
    based on to allow for interaction.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.16 – Creating a simple custom type
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll define a map and then delete an element from it using
    user input and a simple custom type. Then, we’ll print the now possibly smaller
    map to the console. Let’s get started:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Define a custom type called `id` based on the `string` type:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Create a function that returns three `id` instances:'
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'For `id1`, we’ll initialize it and leave it at its zero value:'
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'For `id2`, we’ll initialize it using a string literal:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Finally, for `id3`, we’ll initialize it to zero and then set a value separately:'
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Now, return the `id` instances and close the function:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'In `main`, call our function and do some comparisons:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-511
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'For this preceding comparison, we’ll convert the `id` type back into a string:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: Output after comparison](img/B18621_04_9.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Output after comparison'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we created a custom type called `id`, set data on it, and
    then compared it with values of the same type and with its base type of `string`.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Simple custom types are a foundational part of modeling the data problems you’ll
    see in the real world. Having types designed to reflect the data you need to work
    with closely helps keep your code easy to understand and maintain.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: Structs
  id: totrans-521
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collections are perfect for grouping values of the same type and purpose together.
    There is another way of grouping data together in Go for a different purpose.
    Often, a simple string, number, or Boolean doesn’t fully capture the essence of
    the data you’ll have.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: For example, for our user map, a user was represented by their unique ID and
    their first name. That is rarely going to be enough detail to be able to work
    with user records. The data you could capture about a person is almost infinite,
    such as their given, middle, and family names. Their preferred prefix and suffix,
    their date of birth, their height, weight, or where they work can also be captured.
    It would be possible to store this data in multiple maps, all with the same key,
    but that is hard to work with and maintain.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'The ideal thing to do is to collect all these different bits of data into a
    single data structure that you can design and control. That’s what Go’s `struct`
    type is: it’s a custom type that you can name and then specify the field properties
    and their types.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: 'The notation for structs looks like this:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Field names must be unique within a struct. You can use any type for a field,
    including pointers, collections, and other structs.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access a field on a struct using the following notation: `<structValue>.<fieldName>`.
    To set a value, you use this notation: `<structValue>.<fieldName> = <value>`.
    To read a value, you use the following notation: `value = <``structValue>.<fieldName>`.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Structs are the closest thing that Go has to what are called classes in other
    languages, but structs have purposely been kept stripped down by Go’s designers.
    A key difference is that structs don’t have any form of inheritance. The designers
    of Go feel that inheritance causes more problems than it solves in real-world
    code.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve defined your custom `struct` type, you can use it to create a value.
    You have several ways to create values from `struct` types. Let’s take a look
    at them now.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.17 – Creating struct types and values
  id: totrans-531
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’re going to define a user struct. We’ll define some fields
    of different types. Then, we’ll create some struct values using a few different
    methods. Let’s get started:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-534
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-535
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The first thing we’ll do is define our `struct` type. You generally do this
    in the package scope (outside of any function body). We need to give it a name
    that’s unique at the package-level scope:'
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-537
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'We’ll add some fields of different types and then close the struct definition:'
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'We’ll create a function that returns a slice of our newly defined `struct`
    type:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Our first user is initialized using this key-value notation. This notation
    is the most common form to use when initializing structs:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-543
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'When using the key-value notation, the order of the fields doesn’t matter,
    and any you leave out will get a zero value for their type:'
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'It’s possible to initialize a struct with values only. If you do this, all
    the fields must be present, and their order must match how you defined them in
    the struct:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'This `var` notation will create a struct where all the fields have zero values:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Now, we can set values on the fields using `.` and the field name:'
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-551
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Now, we will return the values wrapped in a slice and close the function:'
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'In `main`, we’ll get the slice of `users`, loop over it, and print it to the
    console:'
  id: totrans-554
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: Output as per the new struct](img/B18621_04_10.jpg)'
  id: totrans-559
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: Output as per the new struct'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you defined a custom `struct` type that contained multiple
    fields, each of a different type. Then, we created values from that struct using
    a few different methods. Each of these methods is valid and useful in different
    contexts.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: We defined the struct at the package scope, and while it’s not typical, you
    can define `struct` types in the function scope too. If you do define a `struct`
    type in a function, it’ll only be valid for use in that function. When defining
    a type at the package level, it’s available for use throughout the package.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to define and initialize a struct at the same time. If you
    do this, you can’t reuse the type, but it’s still a useful technique. The notation
    looks like this:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: You can also initialize using the key-value notation, but initializing with
    only the values is the most common when this is done.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: Comparing structs to each other
  id: totrans-566
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If all a struct’s fields are comparable types, then the struct is also comparable.
    So, if your struct is made up of `string` and `int` types, then you can compare
    whole structs to one another. If your struct has a slice in it, then you can’t.
    Go is strongly typed, so you can only compare values of the same type, but with
    structs, there is a little bit of flexibility. If the struct was defined anonymously
    and has the same structure as a named struct, then Go allows the comparison.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.18 – Comparing structs to each other
  id: totrans-568
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll define a comparable struct and create a value with
    it. We’ll also define and create values with anonymous structs that have the same
    structure as our named struct. Finally, we’ll compare them and print the results
    to the console. Let’s get started:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder and add a file named `main.go` to it:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Let’s define a simple, comparable struct:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Now, we’ll create a function that returns two Booleans:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'We’ll now create our first anonymous struct:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Note
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: The struct is considered anonymous because the `struct` type does not have a
    name. `point1` is a variable that contains an instance of the anonymous struct.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: 'With the second anonymous struct, we’re initializing it to zero and then changing
    the value after initialization:'
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'The final struct to create uses the named `struct` type we created previously:'
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Compare them. Then, return and close the function:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-586
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'In `main`, we’ll call our function and print the results:'
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: Output comparing structs](img/B18621_04_11.jpg)'
  id: totrans-592
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Output comparing structs'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw that we can work with anonymous struct values in the
    same way as named `struct` types, including comparing them. With named types,
    you can only compare structs of the same type. When you compare types in Go, Go
    compares all the fields to check for a match. Go allows a comparison of these
    anonymous structs to be made because the field names and types match. Go is a
    little flexible with comparing structs like this.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: Struct composition using embedding
  id: totrans-595
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While inheritance is not possible with Go structs, the designers of Go did include
    an exciting alternative. The alternative is to embed types in `struct` types.
    Using embedding, you can add fields to a struct from other structs. This composition
    feature has the effect of letting you add to a struct using other structs as components.
    Embedding is different than having a field that is a `struct` type. When you embed,
    the fields from the embedded struct get promoted. Once promoted, a field acts
    as if it’s defined on the target struct.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: 'To embed a struct, you add it like you would a field, but you don’t specify
    a name. To do this, you add a `struct` type name to another struct without giving
    it a field name, which looks like this:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Though not common, you can embed any other type into structs. There is nothing
    to promote, so to access the embedded type, you access it using the type’s name;
    for example, `<structValue>.<type>`. This way of accessing embedded types by their
    type name is also true for structs. This means there are two valid ways to work
    with an embedded struct’s fields: `<structValue>.<fieldName>` or `<structValue>.<type>.<fieldName>`.
    This ability to access a type by its name also means that the type’s names must
    be unique between the embedded types and the root field names. When embedding
    pointer types, the type’s name is the type without the pointer notation, so the
    name `*<type>` becomes `<type>`. The field is still a pointer, and only the name
    is different.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to promotion, if you were to have any overlap with your struct’s
    field names, Go allows you to embed, but the promotion of the overlapping field
    doesn’t happen. You can still access the field by going through the type name
    path.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: You can’t use promotion when initializing structs with embedded types. To initialize
    the data, you must use the embedded type’s name.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.19 – Struct embedding and initialization
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll define some structs and custom types. We’ll embed those
    types into a struct. Let’s get started:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Create a custom `string` type called `name`:'
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Create a struct called `location` with two `int` fields; that is, `x` and `y`:'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Create a `size` struct with two `int` fields; that is, `width` and `height`:'
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Create a struct named `dot`. This embeds each of the preceding structs in it:'
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Create a function that returns a slice of dots:'
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Our first `dot` instance uses the `var` notation. This will result in all the
    fields having a zero value:'
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'With `dot2`, we’re also initializing with zero values:'
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'To set the name, we use the type’s name as if it were a field:'
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'For `size` and `location`, we’ll use the promoted fields to set their value:'
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'When initializing embedded types, you can’t use promotion. For `name`, the
    result is the same, but for `location` and `size`, you need to put more work into
    this:'
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'For `dot4`, we’ll use the type names to set data:'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Return all the dots in a slice and then close the function:'
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'In `main`, call the function. Then, loop over the slice and print it to the
    console:'
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12: Output after struct embedding and initialization](img/B18621_04_12.jpg)'
  id: totrans-636
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Output after struct embedding and initialization'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we were able to define a complex struct by embedding other
    types into it. Embedding allows you to reuse common structures by reducing the
    duplicated code but still giving your struct a flat API.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: We may not see much embedding in real-world Go code. It does come up, but the
    complexity and exception mean that Go developers prefer to have the other structs
    as named fields.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: Activity 4.05 – Creating a locale checker
  id: totrans-640
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we’re going to create a locale validator. A locale is an internationalization
    and localization concept that is a combination of both a language and a country
    or region. We’ll create a struct that represents a locale. After, we’re going
    to define a list of locales our code supports. Then, we’ll read in some locale
    code from the command line and print out whether our code accepts that locale
    or not.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps for this activity:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Go program.
  id: totrans-643
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a struct with a field for language and a separate field for country or
    region.
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a collection to hold the local definitions for at least five locales;
    for instance, `en_US`, `en_CN`, `fr_CN`, `fr_FR`, and `ru_RU`.
  id: totrans-645
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read in the locale from the command line; for example, using `os.Args`. Be sure
    to have error checking and validation working.
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the passed locale string into a new locale struct.
  id: totrans-647
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use that struct to check whether the passed struct is supported.
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print a message to the console stating whether the locale is supported or not.
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13: Expected output](img/B18621_04_13.jpg)'
  id: totrans-651
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: Expected output'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.05](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.05).'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: Type conversions
  id: totrans-655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times when your types won’t match up, and with Go’s strict type system,
    if types are not the same, they can’t interact with one another. In these cases,
    you have two options. If the two types are compatible, you can do type conversion
    – that is, you can create a new value by changing one type to another. The notation
    to do this is `<value>.(<type>)`. When working with strings, we used this notation
    to cast a string to a slice of runes or bytes and back again. This works because
    a string is a special type that stores the string’s data as a slice of bytes.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '*It’s important to note that not all type conversions preserve the original
    value*. When working with numeric type conversion, the numbers can change from
    their original value. If you convert from a large `int` type (for example, `int64`)
    into a smaller `int` type (for example, `int8`), it causes the number to overflow.
    If you were to convert from an unsigned `int` type (for example, `uint64`) into
    a signed `int` type (for example, `int64`), this overflow happens because unsigned
    `int` types can store a higher number than a signed `int` type. This overflowing
    is the same when converting an `int` type into a `float` type since the `float`
    type splits its storage space between whole numbers and decimals. When converting
    from a `float` type to an `int` type, the decimal part is truncated.'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: It’s still perfectly reasonable to do these types of lossy conversions, and
    they happen all the time in real-world code. If you know that the data you’re
    dealing with doesn’t cross these thresholds, then there’s no need to worry.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: Go does its best to guess at the types that need conversion. This is called
    implicit type conversion. For example, `math.MaxInt8` is an `int` type, and if
    you try to assign it to a number other than an `int` type, Go does an implicit
    type conversion for you.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.20 – Numeric type conversions
  id: totrans-660
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll do some numeric type conversions and intentionally
    cause some data issues. Let’s get started:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-663
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-664
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Create a function that returns a string:'
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Define some variables to do our work. Go is doing an implicit conversion of
    the `math.MaxInt8` int into an `int8` type:'
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-668
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Here, we’ll convert from a smaller `int` type into a larger `int` type. This
    is always a safe operation:'
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-670
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Now, we’ll convert from an `int` type that’s 1 above `int8`’s maximum size.
    This will cause an overflow to `int8`’s minimum size:'
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Next, we’ll convert our `int8` type into a `float64` type. This doesn’t cause
    an overflow and the data is unchanged:'
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Here, we’ll convert a `float` type into an `int` type. All the decimal data
    is lost but the whole number is kept as is:'
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Return the message and then close the function:'
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'In the `main()` function, call the function and print it to the console:'
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-682
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14: Output after conversion](img/B18621_04_14.jpg)'
  id: totrans-684
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: Output after conversion'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: Type assertions and interface{}
  id: totrans-686
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve used `fmt.Print` and its siblings a great deal for writing our code,
    but how does a function such as `fmt.Print` take any type of value when Go is
    a strongly typed language? Let’s take a look at the actual Go standard library
    code for `fmt.Print`:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: I hope you can see that looking at Go’s source code is not scary – it’s a great
    way to see how you should do things, and I recommend looking at it whenever you
    are curious about how they do something properly using idiomatic Go.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: By looking at this code, we can see that `fmt.Print` has a variadic of the `interface{}`
    type. We’ll cover interfaces in more detail later, but for now, what you need
    to know is that an interface in Go describes which functions a type must have
    to conform to that interface. Interfaces in Go don’t describe fields and don’t
    describe a type’s core value, such as being a string or a number. In Go, any type
    can have functions, including strings and numbers. What `interface{}` is describing
    is a type with no functions. What use is a value with no function, no fields,
    and no core value? None, but it’s still a value, and it can still be passed around.
    This interface is not setting the type of the value but controlling which values
    it will allow for a variable with that interface. Which types in Go conform to
    `interface{}`? All of them! Any of Go’s types or any custom type you create conform
    to `interface{}`, and this is how `fmt.Print` can accept any type. You can also
    use `interface{}` in your code to achieve the same result.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: The Go 1.18 release included an alias of the `interface{}` type called `any`.
    Since they are equivalent in usage, `any` is interchangeable with `interface{}`
    in the earlier code example that we saw at the beginning of this section.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your variable that conforms to `interface{}`, what can you do
    with it? Even if the underlying value of your `interface{}` variable has functions,
    fields, or a core value, you can’t use them because Go is enforcing the interface’s
    contract, which is why this is still all type-safe.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: To unlock the capabilities of the value masked by `interface{}` or `any`, we
    need to use type assertion. The notation for type assertion is `<value>.(<type>)`.
    Type assertion results in a value of the type that was requested and, optionally,
    a Boolean value regarding whether it was successful or not. This looks like `<value>
    := <value>.(<type>)` or `<value>, <ok> := <value>.(type)`. If you leave the Boolean
    value out and the type assertion fails, Go raises a panic.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: Go doesn’t remove anything from a value when you place it in an `interface{}`
    type or `any` variable. What happens is the Go compiler prevents you from using
    it because it’s not able to perform its type-safety checks at compile time. Using
    type assertion is your instruction to Go that you want to unlock the value. When
    you do type assertion, Go performs the type-safety checks it would have done at
    compile time and at runtime, and those checks may fail. It’s then your responsibility
    to deal with the type-safety checks failing. Type assertions are a feature that
    causes runtime errors and panics, which means you must be extra careful around
    them.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.21 – Type assertions
  id: totrans-695
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will perform some type assertions and ensure that all
    the safety checks are in place when we do so. Let’s get started:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-697
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-698
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-699
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Create a function that accepts an `interface{}` type and returns a string and
    an error:'
  id: totrans-700
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-701
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'First, we’ll check to see if our argument is an `int` type, and if it is, we’ll
    multiply it by `2` and return it:'
  id: totrans-702
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-703
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Here, we’ll check if it’s a string, and if it is, we’ll concatenate it to itself
    and return it:'
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-705
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'If we don’t get any matches, return an error. Then, close the function:'
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-707
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'In `main`, call `doubler` with a variety of data and print the results to the
    console:'
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-709
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-711
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15: Output showing matches](img/B18621_04_15.jpg)'
  id: totrans-713
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: Output showing matches'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: The combination of `interface{},` `any`, and type assertions allows you to overcome
    Go’s strict type controls, in turn allowing you to create functions that can work
    with any type of variable. The challenge is that you lose the protection that
    Go gives you at compile time for type safety. It’s still possible to be safe,
    but the responsibility is yours now – do it wrong, and you’ll get a nasty runtime
    error.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: Type switch
  id: totrans-716
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we wanted to expand our `doubler` function to include all `int` types, we’d
    end up with a lot of duplicated logic. Go has an excellent way of dealing with
    more complex type assertion situations, known as a type switch. Here’s what it
    looks like:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: The type switch only runs your logic if it matches the type you’re looking for,
    and it sets the value to that type. You can match on more than one type in a case
    but Go can’t change the type of the value for you, so you’ll still need to do
    type assertion. One of the things that makes this a type switch and not an expression
    switch is the `<value>.(type)` notation. You can only use that as part of a type
    switch. Something else that’s unique to type switches is that you can’t use a
    `fallthrough` statement.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 4.22 – Type switch
  id: totrans-720
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we’ll update our `doubler` function to use a type switch
    and expand its abilities to deal with more types. Let’s get started:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-722
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-723
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-724
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Create our function, which takes a single `interface{}` argument and returns
    a string and an error:'
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-726
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'Create a type switch using our argument:'
  id: totrans-727
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-728
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'For `string` and `bool`, since we’re only matching on one type, we don’t need
    to do any extra safety checks and can work with the value directly:'
  id: totrans-729
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-730
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'For the floats, we’re matching on more than one type. This means we need to
    do type assertion to be able to work with the value:'
  id: totrans-731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-732
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'If this type assertion were to fail, we’d panic, but we can rely on the logic
    that only `float32` can work directly with the result of type assertion:'
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-734
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'Match all the `int` and `uint` types. We’ve been able to remove lots of code
    here by not needing to do the type-safety checks ourselves:'
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'We’ll use `default` to return an error. Then, we’ll close the `switch` statement
    and function:'
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-738
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'In the `main()` function, call our function with even more data and print the
    results to the console:'
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-740
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-742
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16: Output after calling functions](img/B18621_04_16.jpg)'
  id: totrans-744
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: Output after calling functions'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we used a type switch to build a complex type-assertion scenario.
    Using the type switch still gives us full control of the type assertions but also
    lets us simplify the type-safety logic when we don’t need that level of control.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: Activity 4.06 – Type checker
  id: totrans-747
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, you’re going to write some logic that has a slice or different
    types of data. These data types are as follows:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: '`int`'
  id: totrans-749
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`'
  id: totrans-750
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`'
  id: totrans-751
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool`'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct`'
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a function that accepts a value of any type. The function returns a
    string with the name of the type:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: For `int`, `int32`, and `int64`, it returns `int`
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all floats, it returns `float`
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a string, it returns `string`
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a Boolean, it returns `bool`
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For anything else, it returns `unknown`
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loop all the data by passing each one to your function.
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, print the data and its type name to the console.
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17: Expected output](img/B18621_04_17.jpg)'
  id: totrans-763
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: Expected output'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.06](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter04/Activity04.06).
    Think about the different ways you could implement this solution depending on
    which Go version you are using; for example, solving this with Go 1.18’s `any`
    or `interface{}` type alias.'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-767
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got into advanced uses of variables and types in Go. Real-world
    code gets complicated quickly because the real world is complicated. Being able
    to model the data accurately and keep that data logically organized in your code
    helps reduce the complexity of your code to a minimum.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to group similar data, either in a fixed-length ordered list
    using an array, in a dynamic-length ordered list using a slice, or in a key-value
    hash using a map.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: We learned to go beyond Go’s core types and start to create custom types based
    either directly on the core types or by creating a struct, which is a collection
    of other types held in a single type and value.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: There are times when you’ll have type mismatches, so Go gives us the ability
    to convert compatible types so that they can interact in a type-safe way.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: Go also lets us break free of its type-safety rules and gives us full control.
    By using type assertions, we can accept any type using the magic of `interface{}`
    and `any`, and then get those types back.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll explore how to group our logic into reusable components
    and attach them to our custom types to make our code more straightforward and
    easier to maintain and build with.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Components'
  id: totrans-774
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As scripts evolve, they can become unwieldy and difficult to manage. To maintain
    control over your codebase, it’s essential to break it down into smaller, more
    manageable components. This not only enhances code organization but also facilitates
    code reuse.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: This section delves into the realm of componentization, empowering you to create
    modular and reusable code structures.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B18621_05.xhtml#_idTextAnchor1048), *Functions – Reduce, Reuse,
    and Recycle*'
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B18621_06.xhtml#_idTextAnchor1210), *Don’t Panic! Handle Your
    Errors*'
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18621_07.xhtml#_idTextAnchor1291), *Interfaces*'
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18621_08.xhtml#_idTextAnchor1341), *Generic Algorithm Superpowers*'
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
