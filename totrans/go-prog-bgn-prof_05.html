<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer080">
			<h1 id="_idParaDest-175" class="chapter-number"><a id="_idTextAnchor1048"/>5</h1>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor1049"/>Functions – Reduce, Reuse, and Recycle</h1>
			<p class="callout-heading"><a id="_idTextAnchor1050"/>Overview</p>
			<p class="callout">This chapter will describe the various ways in which you can reduce, reuse, and recycle code. It will include a large overview of functions so that you can include parts of a function, such as defining the function, function identifiers, parameter lists, return types, and the function body. We will also look at best practices when designing code so that you can make it reusable and flexible and make your functional logic small <span class="No-Break">and purposeful.</span></p>
			<p class="callout">By the end of this chapter, you will be able to see how easy Go makes it to reduce, reuse, and recycle code. This will include how to describe a function and the different parts that make up a function and evaluate the scope of variables with functions. You will know how to create and call a function, as well as how to utilize variadic and anonymous functions and create closures for various constructs. You will also know how to use functions as parameters and return values and how to use <strong class="source-inline">defer</strong> statements with functions. Finally, you will know how to separate similar functionality into logical sections by using multiple files and directories in <span class="No-Break">your projects.</span></p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor1051"/>Technical requirements</h1>
			<p>For this chapter, you will need to install the Go programming language. This chapter’s code can be found in this book’s GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor1052"/><a id="_idTextAnchor1053"/>Introduction</h1>
			<p>The ability to write code in a way that is easy to maintain and iterate on is a vital skill for an engineer. This means crafting it so that it may be reused, easily expanded upon, and understood by others. Go makes it easy to keep code clean and readable, and separate logical chunks together. The first major way of writing code that is easy to reduce, reuse, and recycle is through the use <span class="No-Break">of functions.</span></p>
			<p>Functions are a core part <a id="_idIndexMarker386"/>of many languages and Go is no exception. A function is a section of code that has been declared to perform a task. Go functions can have zero or more inputs and outputs. One feature that sets Go apart from other programming languages is the multiple return values; most programming languages are limited to one return value. This leads into Go’s flexibility and the ability for developers to continuously write <span class="No-Break">adaptable code.</span></p>
			<p>In the following section, we will see some features of Go functions that differ from other languages, such as returning multiple types. We will also see that Go has support for first-class functions. This means that Go can assign a variable to a function, pass a function as an argument, and have a function as a return type for a function. We will show how functions can be used to break up complex parts into <span class="No-Break">smaller parts.</span></p>
			<p>Functions in Go are considered <a id="_idIndexMarker387"/>first-class citizens and higher-order functions. First-class citizens are the functions that are assigned to a variable. Higher-order functions are functions that can take a function as an argument. The rich features of Go functions empower them to be used in various segments in the <span class="No-Break">following ways:</span></p>
			<ul>
				<li>To pass a function as an argument to <span class="No-Break">another function</span></li>
				<li>To return a function as a value from <span class="No-Break">a function</span></li>
				<li>To use functions as <span class="No-Break">a type</span></li>
				<li>To use functions <span class="No-Break">as closures</span></li>
				<li>To use <span class="No-Break">anonymous functions</span></li>
				<li>To assign functions to <span class="No-Break">a variable</span></li>
			</ul>
			<p>We will be looking at each of these features since they are all supported <span class="No-Break">in Go<a id="_idTextAnchor1054"/><a id="_idTextAnchor1055"/>.</span></p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor1056"/>Functions</h1>
			<p>Functions are a critical part of Go and we should understand their place. Let’s examine some of the reasons for <span class="No-Break">using functions:</span></p>
			<ul>
				<li><strong class="bold">Breaking up a complex task</strong>: Functions are used to perform a task, but if that task is complicated, it should be broken down into smaller tasks. Functions can be used for small tasks to solve a bigger<a id="_idIndexMarker388"/> problem. Smaller tasks are more manageable, and using a function to solve specific tasks will make the entire code base easier <span class="No-Break">to maintain.</span></li>
				<li><strong class="bold">Reducing code</strong>: A good indication that you should use a function is when you see similar code repeating throughout your program. When you have duplicate code, it increases the difficulty of maintenance. If you have one change to make, you will have multiple instances where your code needs <span class="No-Break">to change.</span></li>
				<li><strong class="bold">Reusability</strong>: Once you have defined your function, you can use it repeatedly. It can also be used by other programmers. This sharing of functions will reduce lines of code and save time by allowing you to not have to reinvent the wheel. There are a couple of guidelines we should follow when we <span class="No-Break">design functions:</span><ul><li><strong class="bold">Single responsibility</strong>: A function should perform one task. For example, a single function should not calculate the distance between two points and estimate the time to travel between those two points. There should be a function for each of those tasks. This allows for better testing of that function and easier maintenance. It is difficult to narrow a function to perform a single task, so do not get discouraged if you do not get it right the first time. Even seasoned programmers struggle with assigning a single responsibility to a function, and responsibilities can shift <span class="No-Break">over time.</span></li><li><strong class="bold">Small in size</strong>: Functions should not span over hundreds of lines of code. This is an indication that the code needs some refactoring. When we have large functions, it’s more likely that the single responsibility principle will be violated. A good rule of thumb is trying to limit the function size to approximately 25 lines of code; however, that’s not a hard-and-fast rule. The benefit of keeping the code concise is that it reduces the complexity of debugging a large<a id="_idIndexMarker389"/> function. It also makes writing unit tests with better code <span class="No-Break">coverage easi<a id="_idTextAnchor1057"/><a id="_idTextAnchor1058"/>er.</span></li></ul></li>
			</ul>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor1059"/>Parts of a function</h2>
			<p>Let’s look at the different<a id="_idIndexMarker390"/> components that are involved in defining a function. The following is the typical layout of <span class="No-Break">a functi<a id="_idTextAnchor1060"/>on:</span></p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B18621_05_01.jpg" alt="Figure 5.1: Different parts of a function" width="426" height="319"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1: Different parts of a function</p>
			<p>The different parts of a function are <span class="No-Break">described here:</span></p>
			<ul>
				<li><strong class="source-inline">func</strong>: In Go, the function <a id="_idIndexMarker391"/>declaration starts with the <span class="No-Break"><strong class="source-inline">func</strong></span><span class="No-Break"> keyword.</span></li>
				<li><strong class="bold">Identifier</strong>: This is also <a id="_idIndexMarker392"/>referred to as the function name. It is idiomatic in Go to use camelCase for the function name. camelCase is the practice of having the first letter of the function name in lowercase and the first letter of each word following in uppercase. Examples of function names that follow this convention include <strong class="source-inline">calculateTax</strong>, <strong class="source-inline">totalSum</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">fetchId</strong></span><span class="No-Break">.</span><p class="list-inset">The identifier should be something descriptive that makes the code easy to read and makes the purpose of the function easy to understand. The identifie<a id="_idTextAnchor1061"/>r is not required. You can have a function with no name; this is known as an anonymous function. Anonymous <a id="_idIndexMarker393"/>functions will be discussed in detail later in <span class="No-Break">this chapter.</span></p></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">When the first letter of the function name is in lowercase, then the function can’t be exported outside of a package. This means it’s private and cannot be called from outside the package. It can only be called within <span class="No-Break">the package.</span></p>
			<p class="callout">Keep this in mind when you use the camelCase naming convention. If you want your function to be exportable, the first letter of the function name must be capitalized. This will mean other packages can consume and use your function if it is exported and starts with a <span class="No-Break">capital letter.</span></p>
			<ul>
				<li><strong class="bold">Parameter list</strong>: Parameters are input values to a function. A parameter is data that is required by the function to <a id="_idIndexMarker394"/>help solve the task of the function. Parameters are defined as follows: name, type. An example parameter list could be (<strong class="source-inline">name string</strong>, <strong class="source-inline">age int</strong>). Parameters are local variables of <span class="No-Break">the function.</span><p class="list-inset">Parameters are optional for a function. It is possible to not have any parameters for a function. A function can have zero or <span class="No-Break">more parameters.</span></p><p class="list-inset">When two or more parameters have the same<a id="_idIndexMarker395"/> type, you can use what is called shorthand parameter notation. This removes specifying the same type for each parameter. For instance, if your parameters are (<strong class="source-inline">firstName string</strong>, <strong class="source-inline">lastName string</strong>), they can be shortened to (<strong class="source-inline">firstName</strong>, <strong class="source-inline">lastName string</strong>). This reduces the verbosity of the parameter inputs and increases the readability of the function <span class="No-Break">parameter list.</span></p></li>
				<li><strong class="bold">Return types</strong>: Return types <a id="_idIndexMarker396"/>are a list of data types, such as Boolean, string, map, or another function that can <span class="No-Break">be returned.</span><p class="list-inset">In the context of declaring a function, we refer to these types as return types. However, in the context of calling a function, they are called <span class="No-Break">return values.</span></p><p class="list-inset">Return types are the output of the function. Often, they are the result of the arguments provided to the<a id="_idIndexMarker397"/> function. They are optional. Most programming languages return a single type; in Go, you can return <span class="No-Break">multiple types.</span></p></li>
				<li><strong class="bold">Function body</strong>: The function body is the coding statements between curly <span class="No-Break">braces, </span><span class="No-Break"><strong class="source-inline">{}</strong></span><span class="No-Break">.</span><p class="list-inset">The statements in the function are what determine what the function does. The function code is the code that is <a id="_idIndexMarker398"/>being used to perform the task that the function was created <span class="No-Break">to accomplish.</span></p><p class="list-inset">If return types were defined, then a <strong class="source-inline">return</strong> statement is required in the function body. The <strong class="source-inline">return</strong> statement causes the function to immediately stop and return the value types listed after the <strong class="source-inline">return</strong> statement. The types in the return type list and the <strong class="source-inline">return</strong> statement <span class="No-Break">must match.</span></p><p class="list-inset">In the function body, there can be multiple <strong class="source-inline">return</strong> statements. You often see this in the case of errors, where you might return different values than, say if the function processed <span class="No-Break">logic successfully.</span></p></li>
				<li><strong class="bold">Function signature</strong>: Though not listed in the preceding code snippet, a function signature is a term that<a id="_idIndexMarker399"/> references the input parameters combined with the return types. Both of those units make up a <span class="No-Break">function signature.</span><p class="list-inset">Often, when you define the function signature when it is being used by others, you want to strive to not make changes to it as this can adversely impact your code and the code <span class="No-Break">of others.</span></p></li>
			</ul>
			<p>We will be diving deep into each of the parts of a function as we progress through this chapter. These parts of a function will become easier to understand through the following discussion and will become clearer as we go through <span class="No-Break">t<a id="_idTextAnchor1062"/><a id="_idTextAnchor1063"/>his chapter.</span></p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor1064"/>The checkNumbers function</h1>
			<p>Now that we have looked at the different parts of the function, let’s see how these parts work with various examples. Let’s start with a <a id="_idIndexMarker400"/>simple approach with a <strong class="source-inline">checkNumbers</strong> function. The <strong class="source-inline">checkNumbers</strong> function prints out various messages based on some math results of whether a number is even or odd. The rules perform one of the actions based on the <span class="No-Break">number given:</span></p>
			<ul>
				<li>If the number is <strong class="source-inline">even</strong>, <span class="No-Break">print </span><span class="No-Break"><strong class="source-inline">Even</strong></span></li>
				<li>If the number is <strong class="source-inline">odd</strong>, <span class="No-Break">print </span><span class="No-Break"><strong class="source-inline">Odd</strong></span></li>
			</ul>
			<p>The following is the code snippet to achieve<a id="_idTextAnchor1065"/><a id="_idTextAnchor1066"/> <span class="No-Break">this output:</span></p>
			<pre class="source-code">
func checkNumbers() {
    for i := 1; i &lt;= 30; i++ {
        if i%2 == 0 {
            fmt.Println("Even")
        } else {
            fmt.Println("Odd")
        }
    }
}</pre>			<p>Let’s look at the code <span class="No-Break">in sections:</span></p>
			<pre class="source-code">
func checkNumbers() {</pre>			<ul>
				<li><strong class="source-inline">func</strong>, as you may recall, is the keyword to declare a function. This informs Go that the following piece of code is going to be <span class="No-Break">a function.</span></li>
				<li><strong class="source-inline">checkNumbers</strong> is the name of our function. It is idiomatic (standard practice) in Go to use a <span class="No-Break">camelCase name.</span></li>
				<li><strong class="source-inline">()</strong>, the parenthesis following the name of our function, is empty: our current implementation of the <strong class="source-inline">checkNumbers</strong> game does not require any input parameters. If it <em class="italic">did</em> require input parameters, they would be contained <span class="No-Break">within parentheses.</span></li>
				<li>The space between the parameter list, <strong class="source-inline">()</strong>, and the opening brace would be the return type. Our current implementation does not require a <span class="No-Break">return type.</span></li>
				<li>Regarding <strong class="source-inline">{</strong>, unlike other programming languages that you may know, Go requires that the opening <a id="_idIndexMarker401"/>curly brace is on the same line as the function declaration. If the opening brace is not on the same line as the function signature when you attempt to run the program, you will get <span class="No-Break">an error:</span><pre class="source-code">
for i := 1; i &lt;= 30; i++ {</pre><p class="list-inset">The preceding line is a <strong class="source-inline">for</strong> loop that increments the <strong class="source-inline">i</strong> variable from <strong class="source-inline">1</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">30</strong></span><span class="No-Break">:</span></p><pre class="source-code">if i%2 == 0 {</pre></li>			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">%</strong> is a modulus operator; it gives the remainder of the two integers being divided. Using our function, if <strong class="source-inline">i</strong> is evenly divisible by <strong class="source-inline">2</strong>, then it <a id="_idIndexMarker402"/>will print out the word <strong class="source-inline">"Even"</strong>; otherwise, it will <span class="No-Break">print “</span><span class="No-Break"><strong class="source-inline">Odd"</strong></span><span class="No-Break">.</span></p>
			<p class="callout">As we become more familiar with Go concepts and language syntax, the explanation of the code will exclude items that we would otherwise be going over <span class="No-Break">multiple times.</span></p>
			<p>We have now defined our function. It has a specific task we want it to perform, but it doesn’t do any good if we do not execute the function. So, how do we execute a function? We must call our function. When we call a function, we are telling our program to execute the function. We will be calling our function inside the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function.</span></p>
			<p>Functions can call other functions. When this occurs, control is given to the function that was called. After the called function has returned data or reached the ending curly brace, <strong class="source-inline">}</strong>, control is given back to the caller. Let’s look at an example to understa<a id="_idTextAnchor1067"/><a id="_idTextAnchor1068"/>nd <span class="No-Break">this better:</span></p>
			<pre class="source-code">
func main() {
  fmt.Println("Main is in control")
  checkNumbers()
  fmt.Println("Back to main")
}</pre>			<ul>
				<li><strong class="source-inline">fmt.Println("Main is in control")</strong>: This <strong class="source-inline">print</strong> statement is for demonstration purposes. It shows that we are in the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function.</span></li>
				<li><strong class="source-inline">checkNumbers()</strong>: We are now calling the function inside the <strong class="source-inline">main()</strong> function. Even though there <a id="_idIndexMarker403"/>are no parameters for our function, the parentheses are still required, and control of the program is given to the <strong class="source-inline">checkNumbers()</strong> function. After the <strong class="source-inline">checkNumbers()</strong> function completes, control is then given back to the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function.</span></li>
				<li><strong class="source-inline">fmt.Println("Back to main")</strong>: The <strong class="source-inline">print</strong> statement is for demonstration purposes to show that control has been given back to the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function.</span></li>
			</ul>
			<p>The output will <a id="_idTextAnchor1069"/>be <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B18621_05_02.jpg" alt="Figure 5.2: Output for checkNumbers" width="325" height="1099"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2: Output for checkNumbers</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The parentheses<a id="_idIndexMarker404"/> following the <strong class="source-inline">checkNumbers</strong> function are still required, even though there are no input parameters. If they are omitted, the Go compiler will generate an error that states <strong class="source-inline">checkNumbers</strong> was evaluated but not used. This is<a id="_idTextAnchor1070"/><a id="_idTextAnchor1071"/> a <span class="No-Break">common error.</span></p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor1072"/>Exercise 5.01 – creating a function to print salesperson expectation ratings from the number of items sold</h2>
			<p>In this exercise, we will be<a id="_idIndexMarker405"/> creating a function that will not have any parameters or return types. The function will iterate over a map and print the name and number of items sold on the map. It will also print a statement based on how the salesperson performed based on their sales. The following steps will help you with <span class="No-Break">the solution:</span></p>
			<ol>
				<li>Use the IDE of <span class="No-Break">your choice.</span></li>
				<li>Create a new file and save it <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></li>
				<li>Enter the following code in <strong class="source-inline">main.go</strong>. The first function that <strong class="source-inline">main</strong> will call is <strong class="source-inline">itemsSold()</strong>; it does not have any parameters and has <a id="_idTextAnchor1073"/><a id="_idTextAnchor1074"/><a id="_idTextAnchor1075"/><a id="_idTextAnchor1076"/>no <span class="No-Break">return values:</span><pre class="source-code">
package main
import (
  "fmt"
)
func main() {
  itemsSold()
}</pre></li>				<li>Next, we’ll define our function for logic regarding <span class="No-Break">items sold:</span><pre class="source-code">
func itemsSold() {</pre></li>				<li>In the <strong class="source-inline">itemsSold()</strong> function, initialize a map that will have a key-value pair of <strong class="source-inline">string</strong>, <strong class="source-inline">int</strong>. The map will hold a <strong class="source-inline">name</strong>(<strong class="source-inline">string</strong>) and the number of <strong class="source-inline">items</strong>(<strong class="source-inline">int</strong>) sold by the individual. The name is the key for the map. We assign various names to number of <span class="No-Break">items sold:</span><pre class="source-code">
  items := make(map[string]int)
  items["John"] = 41
  items["Celina"] = 109
  items["Micah"] = 24</pre></li>				<li>We iterate over the <strong class="source-inline">items</strong> map and assign <strong class="source-inline">k</strong> to <strong class="source-inline">key(name)</strong> and <strong class="source-inline">v</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">value(items)</strong></span><span class="No-Break">:</span><pre class="source-code">
  for k, v := range items{</pre></li>				<li>We print out <strong class="source-inline">Name</strong> and the number of <span class="No-Break">sold </span><span class="No-Break"><strong class="source-inline">items</strong></span><span class="No-Break">:</span><pre class="source-code">
    fmt.Printf("%s sold %d items and ", k, v)</pre></li>				<li>Depending on the <a id="_idIndexMarker406"/>value of <strong class="source-inline">v</strong>(<strong class="source-inline">items</strong>), we will determine the statement <span class="No-Break">we print:</span><pre class="source-code">
    if v &lt; 40 {
      fmt.Println("is below expectations.")
    } else if v &gt; 40 &amp;&amp; v &lt;= 100 {
      fmt.Println("meets expectations.")
    } else if v &gt; 100 {
      fmt.Println("exceeded expectations.")
    }
  }
}</pre></li>				<li>Open your terminal and navigate to the <span class="No-Break">code’s directory.</span></li>
				<li>Run <strong class="source-inline">go build</strong> and then run <span class="No-Break">the executable.</span></li>
			</ol>
			<p>The expected output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
John sold 41 items and meets expectations.
Celina sold 109 items and exceeded expectations.
Micah sold 24 items and is below expectations.</pre>			<p>In this exercise, we saw some of the fundamental parts of a function. We demonstrated how to declare a function using the <strong class="source-inline">func</strong> keyword, followed by how to give our function an identifier or name, such as <strong class="source-inline">itemsSold()</strong>. Then, we added code to the function body. In the next<a id="_idIndexMarker407"/> few sections, we will expand on these core parts of the function and learn how to pass data into a function <span class="No-Break">using parameters.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is best to type the code into an IDE. The benefit is that if you type something incorrectly, you will see the error message and can perform some debugging to<a id="_idTextAnchor1077"/><a id="_idTextAnchor1078"/> solve <span class="No-Break">the problem.</span></p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor1079"/>Parameters</h1>
			<p>Parameters define what arguments can be passed to our function. Functions can have zero or more parameters. Even though Go allows us<a id="_idIndexMarker408"/> to define multiple parameters, we should take care not to have a huge parameter list; that would make the code harder to read. It may also be an indication that the function is doing more than one specific task. If that is the case, we should refactor the function. Take, for example, the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
func calculateSalary(lastName string, firstName string, age int, state string, country string, hoursWorked int, hourlyRate, isEmployee bool) {
// code
}</pre>			<p>The preceding code is an example of a function whose parameter list is bloated. The parameter list should pertain only to the single responsibility of the function. We should only define the parameters that are needed to solve the specific problem that the function is <span class="No-Break">built for.</span></p>
			<p>Parameters are the input types that our function will use to perform its task. Function parameters are local to the function, meaning they are only available to that function. They are not available outside of the context of the function. Also, the order of the parameters must match the parameter types in the <span class="No-Break">correct sequence.</span></p>
			<p><span class="No-Break"><strong class="bold">Correct</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func main() {
  greeting("Cayden", 45)
}
func greeting(name string, age int) {
  fmt.Printf("%s is %d", name, age)
}</pre>			<p>The output when the<a id="_idIndexMarker409"/> correct parameter matches would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Cayden is 45</pre>			<p><span class="No-Break"><strong class="bold">Incorrect</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func main() {
  greeting(45,"Cayden")
}
func greeting(name string, age int) {
  fmt.Printf("%s is %d",name, age)
}</pre>			<p>The outp<a id="_idTextAnchor1080"/>ut looks <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B18621_05_03.jpg" alt="Figure 5.3: Output for incorrect parameter matching" width="684" height="70"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3: Output for incorrect parameter matching</p>
			<p>In the incorrect version of the code, we are calling the <strong class="source-inline">greeting()</strong> function with the <strong class="source-inline">age</strong> argument, which is of the <strong class="source-inline">integer</strong> type, when the parameter is of the <strong class="source-inline">string</strong> type. The sequence of your arguments must match the sequence of the parameter <span class="No-Break">input list.</span></p>
			<p>Additionally, users would want to have more control over the data the code iterates over. Going back to the <strong class="source-inline">checkNumbers</strong> example, the current implementation only does <strong class="source-inline">1</strong> to <strong class="source-inline">30</strong>. Users may need to work on different number ranges, so we need a way to decide the ending range of the loop. We can change our <strong class="source-inline">checkNumbers</strong> function so that it accepts an input <a id="_idIndexMarker410"/>parameter. This would meet t<a id="_idTextAnchor1081"/><a id="_idTextAnchor1082"/>he needs of <span class="No-Break">our user:</span></p>
			<pre class="source-code">
func main() {
  checkNumbers(10)
}
func checkNumbers(end int) {
  for i := 1; i &lt;= end; i++ {
    if i%2 == 0 {
      fmt.Println("Even")
    } else {
      fmt.Println("Odd")
    }
  }
}</pre>			<p>The preceding code snippet can be explained <span class="No-Break">as follows:</span></p>
			<ul>
				<li>For <strong class="source-inline">checkNumbers(10)</strong> in the <strong class="source-inline">main()</strong> function, we pass <strong class="source-inline">10</strong> as an argument to our <span class="No-Break"><strong class="source-inline">checkNumbers</strong></span><span class="No-Break"> function</span></li>
				<li>For <strong class="source-inline">checkNumbers(end int)</strong>, <strong class="source-inline">end</strong> is the name of our parameter and it is of the <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> type</span></li>
				<li>Now, our function will only iterate up to the value of our end parameter; in this example, <a id="_idTextAnchor1083"/><a id="_idTextAnchor1084"/>it will iterate <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">10</strong></span></li>
			</ul>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor1085"/>The difference between an argument and a parameter</h2>
			<p>This is a good time to discuss the difference<a id="_idIndexMarker411"/> between an argument and a parameter. When you are defining your function, using our example, <strong class="source-inline">checkNumbers(end int)</strong> is called a<a id="_idIndexMarker412"/> parameter. When you call a function, such as <strong class="source-inline">checkNumbers(10)</strong>, <strong class="source-inline">10</strong> is called the argument. Also, the argument and parameter names do not need <span class="No-Break">to match.</span></p>
			<p>Functions in Go can also have more than one parameter defined. We need to add another parameter to our <strong class="source-inline">checkNumbers</strong> function to accomm<a id="_idTextAnchor1086"/><a id="_idTextAnchor1087"/>odate <span class="No-Break">this enhancement:</span></p>
			<pre class="source-code">
func main() {
  start:= 10
  end:= 20
  che<a id="_idTextAnchor1088"/><a id="_idTextAnchor1089"/>ckNumbers(start, end)
}
func checkNumbers(start int, end int) {
  for i := start; i &lt;= end; i++ {
    // code omitted for brevity
  }
}</pre>			<p>The preceding code snippet can be explained <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Regarding <strong class="source-inline">checkNumbers(start, end)</strong>, we are now passing two arguments to the <strong class="source-inline">checkNumbers</strong> function. When there are multiple arguments, they must be separated by <span class="No-Break">a comma.</span></li>
				<li>Regarding <strong class="source-inline">func checkNumbers(start int, end int)</strong>, when multiple parameters are defined in a function, they are separated by commas, following the convention of name type, name type, name type, and <span class="No-Break">so on.</span></li>
			</ul>
			<p>Our <strong class="source-inline">checkNumbers</strong> parameters are more verbose than what is necessary. When we have multiple input parameters of the same type, we can separate the input name by a comma followed by the type. This is referred to as shorthand parameter notation. See the following example of using shorthand <span class="No-Break">parameter no<a id="_idTextAnchor1090"/>tation:</span></p>
			<pre class="source-code">
func main() {
  start, end := 10,20
  checkNumbers(start, end)
}
func checkNumbers(start, end int) {
  // code…
}</pre>			<p>The preceding code snippet <a id="_idIndexMarker413"/>can be explained <span class="No-Break">as follows:</span></p>
			<ul>
				<li>There is no change to the <a id="_idIndexMarker414"/>caller when using shorthand <span class="No-Break">parameter notation.</span></li>
				<li>Regarding <strong class="source-inline">checkNumbers(start, end int)</strong>, <strong class="source-inline">start</strong> and <strong class="source-inline">end</strong> are of the <strong class="source-inline">int</strong> type. Nothing needs to change in the body of the function to accommodate the shor<a id="_idTextAnchor1091"/>than<a id="_idTextAnchor1092"/>d <span class="No-Break">parameter notation.</span></li>
			</ul>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor1093"/>Exercise 5.02 – mapping index values to column headers</h2>
			<p>The function that we are going to create<a id="_idIndexMarker415"/> will be taking a slice of column headers from a CSV file. It will print out a map of an index value of the headers we are <span class="No-Break">interested in:</span></p>
			<ol>
				<li>Open the IDE of <span class="No-Break">your choice.</span></li>
				<li>Create a new file and save it <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></li>
				<li>Enter the <a id="_idTextAnchor1094"/><a id="_idTextAnchor1095"/>foll<a id="_idTextAnchor1096"/>owing code <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">:</span><pre class="source-code">
package main
import (
  "fmt"
  "strings"
)
func main() {
  hdr :=[]string{"empid", "employee", "address", "hours worked", "hourly rate", "manager"}
  csvHdrCol(hdr)
  hdr2 :=[]string{"employee", "empid", "hours worked", "address", "manager", "hourly rate"}
  csvHdrCol(hdr2)
}
func csvHdrCol(header []string) {
        csvHeadersToColumnIndex:= make(map[int]string)</pre><p class="list-inset">First, we assign a variable to a key-value pair of <strong class="source-inline">int</strong> and <strong class="source-inline">string</strong>. <strong class="source-inline">key(int)</strong> will be the index of our <strong class="source-inline">header(string)</strong> column. The index will map to a <span class="No-Break">column header.</span></p></li>				<li>We range over <strong class="source-inline">header</strong> to process <a id="_idIndexMarker416"/>each string that is in the slice. In the following <strong class="source-inline">for</strong> loop, <strong class="source-inline">i</strong> will store the index, and <strong class="source-inline">v</strong> will be assigned t<a id="_idTextAnchor1097"/>o each value in <span class="No-Break">the header:</span><pre class="source-code">
for i, v := range header {</pre></li>				<li>For each string, remove any trailing spaces in front of and after the string. In general, we should always assume that our data may have some <span class="No-Break">erroneous characters:</span><pre class="source-code">
v = strings.TrimSpace(v)</pre></li>				<li>In our <strong class="source-inline">switch</strong> statement, we lower all the casing for exact matches. As you may recall, Go is a case-sensitive language. We need to ensure that the casing is the same for matching purposes. When our code finds the header, it sets the index value for the header in <span class="No-Break">the map:</span><pre class="source-code">
                switch strings.ToLower(v) {
                case "employee":
                        csvHeadersToColumnIndex[i] = v
                case "hours worked":
                        csvHeadersToColumnIndex[i] = v
                case "hourly rate":
                        csvHeadersToColumnIndex[i] = v
      }
  }</pre></li>				<li>Typically, we would not print out the<a id="_idIndexMarker417"/> results. We should return <strong class="source-inline">csvHeadersToColumnIndex</strong>, but since we have not gone over how to return a value, we will print it <span class="No-Break">for now:</span><pre class="source-code">
       fmt.Println(csvHeadersToColumnIndex)
}</pre></li>				<li>Open your terminal and navigate to the <span class="No-Break">code’s directory.</span></li>
				<li>Run <strong class="source-inline">go build</strong> and run <span class="No-Break">the executable.</span></li>
			</ol>
			<p>The expected output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Map[1:employee 3:hours worked 4: hourly rate]
Map[0:employee 2:hours worked 5: hourly rate]</pre>			<p>In this exercise, we saw how to accept data into a function: by defining a parameter for our function. The callers of our function were able to pass arguments to the function. We will continue to discover various abilities that functions in Go can provide. So far, we have seen how to get data into our function. In the next section, we will see how to g<a id="_idTextAnchor1098"/><a id="_idTextAnchor1099"/>et data out of <span class="No-Break">our function.</span></p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor1100"/>Function variable scope</h2>
			<p>When designing functions, we need to <a id="_idIndexMarker418"/>consider the variable scope. The scope of a variable determines where the variable is accessible or visible to the different parts of the application. Variables declared inside the function are considered local variables. This means that they are only accessible to the code within the body of the function. You cannot access variables from outside of the function. The calling function does not have access to variables inside the called function. The input parameter’s scope is the same as the local variable’s scope to <span class="No-Break">the function.</span></p>
			<p>Variables declared in the calling function are scoped to that function. This means that the variables are local to the function and those variables are not accessible outside of the function. Our function cannot reach into the calling function’s variables. To gain access to those variables, they must be passed into our function as <span class="No-Break">input parameters:</span></p>
			<pre class="source-code">
func main() {
  m:= "Uncle Bob"
  greeting()
}
func greeting() {
  fmt.Printf("Greeting <a id="_idTextAnchor1101"/>%s", m)
}</pre>			<p>Here’s <span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B18621_05_04.jpg" alt="Figure 5.4: Error output for the m variable being undefined" width="244" height="55"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4: Error output for the m variable being undefined</p>
			<p>The previous code snippet will result in an error in <strong class="source-inline">func greeting()</strong> that states that <strong class="source-inline">m</strong> is undefined. That is because the <strong class="source-inline">m</strong> variable is declared inside <strong class="source-inline">main()</strong>. The <strong class="source-inline">greeting()</strong> function does not have access to the <strong class="source-inline">m</strong> variable. For it to have access, the <strong class="source-inline">m</strong> variable must be passed to the <strong class="source-inline">greeting()</strong> fun<a id="_idTextAnchor1102"/><a id="_idTextAnchor1103"/>ction as an <span class="No-Break">input parameter:</span></p>
			<pre class="source-code">
func main() {
  m:= "Uncle Bob"
  greeting(m)
  fmt.Printf("Hi from main: %s", s)
}
func greeting(name string) {
  fmt.Printf("Greeting %s", name)
  s := "Slacker"
  fmt.Printf("Greeting %<a id="_idTextAnchor1104"/>s", s)
}</pre>			<p>Here’s <span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B18621_05_05.jpg" alt="Figure 5.5: Error output for the s variable being undefined" width="239" height="59"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5: Error output for the s variable being undefined</p>
			<p>The previous code snippet will result in an error in <strong class="source-inline">func main()</strong>. The error will state that <strong class="source-inline">s</strong> is undefined. This is because the <strong class="source-inline">s</strong> variable is declared in the <strong class="source-inline">greeting()</strong> function. The <strong class="source-inline">main()</strong> function <a id="_idIndexMarker419"/>does not have access to the <strong class="source-inline">s</strong> variable. The <strong class="source-inline">s</strong> variable is only visible to code inside the function body <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">greeting()</strong></span><span class="No-Break">.</span></p>
			<p>These are just some considerations that we need to keep in mind when we are declaring and accessing variables. It is important to understand the scope of the variables inside a function concerning the variables declared outside of a function. It can cause some confusion when you are trying to access variables but you are not scoped to the context that you are trying to access. The examples in this chapter should help you in understan<a id="_idTextAnchor1105"/><a id="_idTextAnchor1106"/>ding the scope <span class="No-Break">of variables.</span></p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor1107"/>Return values</h2>
			<p>So far, the functions that we have created do<a id="_idIndexMarker420"/> not have any return values. Functions typically accept inputs, perform some action on those inputs, and then return the results of those actions. Functions in some programming languages return only one value. Go allows you to return multiple values from a function. This is one of the features of Go functions that<a id="_idIndexMarker421"/> distinguishes it fro<a id="_idTextAnchor1108"/>m othe<a id="_idTextAnchor1109"/>r <span class="No-Break">programmi<a id="_idTextAnchor1110"/>ng languages.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor1111"/>Exercise 5.03 – creating a checkNumbers function with return values</h2>
			<p>In this exercise, we are going to make some enhancements to our <strong class="source-inline">checkNumbers</strong> function. We are going to change it<a id="_idIndexMarker422"/> so that it accepts only an integer. We will leave the onus on the caller to perform the looping if they desire to do so. Also, we<a id="_idIndexMarker423"/> are going to have two returns. The first will be the number provided and the corresponding text indicating if the number is <strong class="source-inline">Even</strong> or <strong class="source-inline">Odd</strong>. The following steps will help you with <span class="No-Break">the solution:</span></p>
			<ol>
				<li>Open the IDE of <span class="No-Break">your choice.</span></li>
				<li>Create a new file in a different directory and save it <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></li>
				<li>In the <strong class="source-inline">main()</strong> function, assign variables to the return values of our function. The <strong class="source-inline">n,</strong> and <strong class="source-inline">s</strong> variables correspond to the values being returned from our function, which a<a id="_idTextAnchor1112"/><a id="_idTextAnchor1113"/>re <strong class="source-inline">int</strong> and <span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break">, respectively:</span><pre class="source-code">
func main() {
  for i := 0; i &lt;= 15; i++ {
    num, result := checkNumbers(i)
    fmt.Printf("Results:  %d %s\n", num, result)
  }
}</pre></li>				<li>The <strong class="source-inline">checkNumbers</strong> function now returns two values; the first being an <strong class="source-inline">int</strong> value, followed by a <span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break"> value:</span><pre class="source-code">
func checkNumbers(i int) (int, string) {
  switch {</pre></li>				<li>Simplify the <strong class="source-inline">if{}else{}</strong> statements by replacing them with <strong class="source-inline">switch</strong> statements. As you are writing code, you should look for ways to simplify things and make the code more readable. <strong class="source-inline">case i%2 ==0</strong> is equivalent to our previous <strong class="source-inline">if i%2 == 0</strong> statements. Instead of our previous <strong class="source-inline">fmt.Println()</strong> statements, replace<a id="_idIndexMarker424"/> them with <strong class="source-inline">return</strong>. The <strong class="source-inline">return</strong> statement will immediately stop the execution<a id="_idIndexMarker425"/> of the function and return the results to <span class="No-Break">the caller:</span><pre class="source-code">
    cas<a id="_idTextAnchor1114"/><a id="_idTextAnchor1115"/>e i%2 == 0:
      return i, "Even"
    default:
      return i, "Odd"
  }
}</pre><p class="list-inset">T<a id="_idTextAnchor1116"/>he expected output is <span class="No-Break">as follows:</span></p></li>			</ol>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B18621_05_06.jpg" alt="Figure 5.6: Output for the checkNumbers function with return values" width="346" height="654"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6: Output for the checkNumbers function with return values</p>
			<p>In this exercise, we saw how we can return multiple values from a function. We were able to assign variables to the multiple return values from the function. We also noticed that the variables that were <a id="_idIndexMarker426"/>assigned to the function matched the order of the return values. In the following section, we will learn that in the<a id="_idIndexMarker427"/> body of the function, we can perform naked returns, where we do not need to specify the variable being returned in our <span class="No-Break">return statement.</span></p>
			<p>We also saw a switch statement that was used to clean up the <strong class="source-inline">if{}else{}</strong> logic. We had a case for even numbers and a <strong class="source-inline">default</strong> “catch-all” case where odd numbers would fall. The <strong class="source-inline">default</strong> case is<a id="_idIndexMarker428"/> just as it sounds and will be the defa<a id="_idTextAnchor1117"/><a id="_idTextAnchor1118"/>ult case if a case is not <span class="No-Break">before it.</span></p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor1119"/>Activity 5.01 – calculating the working hours of employees</h2>
			<p>In this activity, we’ll be creating a function that <a id="_idIndexMarker429"/>will calculate the working hours of employees for a week. Then, we’ll use this to calculate the payable salary amount. The <strong class="source-inline">developer</strong> struct has a field called <strong class="source-inline">Individual</strong> that is of the <strong class="source-inline">Employee</strong> type. The <strong class="source-inline">developer</strong> struct keeps track of the <strong class="source-inline">HourlyRate</strong> value that they charge and how many hours they work each day. The following steps will help you to reach <span class="No-Break">the solution:</span></p>
			<ol>
				<li>Create an <strong class="source-inline">Employee</strong> type that has the following fields: <strong class="source-inline">Id</strong> as <strong class="source-inline">int</strong>, <strong class="source-inline">FirstName</strong> as <strong class="source-inline">string</strong>, and <strong class="source-inline">LastName</strong> <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break">.</span></li>
				<li>Create a <strong class="source-inline">developer</strong> type that has the following fields: <strong class="source-inline">Individual</strong> as <strong class="source-inline">Employee</strong>, <strong class="source-inline">HourlyRate</strong> as <strong class="source-inline">int</strong>, and <strong class="source-inline">WorkWeek</strong> <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">[7]int</strong></span><span class="No-Break">.</span></li>
				<li>Create an <strong class="source-inline">enum</strong> type (enums are types that contain only a limited number of fixed values) for the seven days of the week. This will be of the <strong class="source-inline">Weekday</strong> <strong class="source-inline">int</strong> type with a constant declaration for each day of <span class="No-Break">the week.</span></li>
				<li>Create a pointer receiver method called <strong class="source-inline">LogHours</strong> for <strong class="source-inline">Developer</strong> that will take the <strong class="source-inline">WeekDay</strong> type and <strong class="source-inline">int</strong> type as input. Assign the hours worked that day to the <strong class="source-inline">Developer</strong> <span class="No-Break">workweek slice.</span></li>
				<li>Create a method that is a pointer receiver called <strong class="source-inline">HoursWorked()</strong>. This method will return the total hours that have <span class="No-Break">been worked.</span></li>
				<li>In the <strong class="source-inline">main()</strong> function, initialize and create a variable of the <span class="No-Break"><strong class="source-inline">Developer</strong></span><span class="No-Break"> type.</span></li>
				<li>In the <strong class="source-inline">LogHours</strong> method, call the method for two days (such as Monday <span class="No-Break">and Tuesday).</span></li>
				<li>Print the hours for the two days of the <span class="No-Break">previous step.</span></li>
				<li>Next, print the results of the <span class="No-Break"><strong class="source-inline">HoursWorked</strong></span><span class="No-Break"> method.</span></li>
			</ol>
			<p>The following is the <span class="No-Break">expected output:</span></p>
			<pre class="console">
Hours worked on Monday:  8
Hours worked on Tuesday:  10
Hours worked this week:  18</pre>			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found in the GitHub repository folder for this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05/Activity05.01"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05/Activity05.01</span></a></p>
			<p>This activity aims to<a id="_idIndexMarker430"/> demonstrate the ability to break problems down into manageable tasks to be implemented by functions, such that each of our functions has a single responsibility. <strong class="source-inline">LogHours</strong> is responsible for assigning the hours worked for each day. <strong class="source-inline">HoursWorked</strong> uses the values that were assigned in <strong class="source-inline">LogHours</strong> to display the hours worked each day. We used return types from our functions to display the data. This exercise demonstrates utilizing functions correct<a id="_idTextAnchor1120"/><a id="_idTextAnchor1121"/>ly to provide a solution to <span class="No-Break">a problem.</span></p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor1122"/>Naked returns</h1>
			<p class="callout-heading">Note</p>
			<p class="callout">Functions that have return values<a id="_idIndexMarker431"/> must have a return statement as the last statement in the function. If you omit the return statement, the Go compiler will give you an error stating “missing return at the end of <span class="No-Break">the function.”</span></p>
			<p class="callout">Typically, when a function returns two types, the second type is an <strong class="source-inline">error</strong>. We have not gone over errors yet, so we won’t be demonstrating them in these examples. It is good to know that, in Go, it is idiomatic for the second return type to be of the <span class="No-Break"><strong class="source-inline">error</strong></span><span class="No-Break"> type.</span></p>
			<p>Go also allows you to ignore a variable being returned. For example, say we are not interested in the <strong class="source-inline">int</strong> value that is being returned from our <strong class="source-inline">checkNumbers</strong> function. In Go, we can use what is called a blank identifier, which allows us t<a id="_idTextAnchor1123"/>o ignore values in <span class="No-Break">an assignment:</span></p>
			<pre class="source-code">
_, err := file.Read(bytes)</pre>			<p>For example, when reading a file, we might not be concerned about the number of bytes read. So, in that case, we can ignore the value being returned by using the blank identifier, <strong class="source-inline">_</strong>. When extra data is <a id="_idIndexMarker432"/>being returned from a function that does not provide any information that is needed by our program, such as the reading of a file, it is a good candidate for ignoring <span class="No-Break">the return:</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">As you will discover later, many functions return an error as the second return value. You should not ignore return values from functions that are errors. Ignoring an error returned by a function could result in unexpected behavior. Error return values should be <span class="No-Break">handled appropriately.</span></p>
			<pre class="source-code">
func main() {
  for i := 0; i &lt;= 15; i++ {
    _, result := checkNumbers(i)
    fmt.Printf("Results: %s\n", result)
  }
}</pre>			<p>In the preceding example, we used the blank identifier, <strong class="source-inline">_</strong>, to ignore the <strong class="source-inline">int</strong> value <span class="No-Break">being returned:</span></p>
			<pre class="source-code">
    _, result := checkNumbers(i)</pre>			<p>You must always have a placeholder for the values being returned when assigning values from a function. When performing an assignment, the placeholders must match the number of return values from the function. <strong class="source-inline">_</strong> and <strong class="source-inline">result</strong> are the placeholders for the return values of <strong class="source-inline">int</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break">.</span></p>
			<p>Go also has a feature that allows you to name your returns. If you use this feature, it can make your code more readable, as well as self-documenting. If you name your return variables, they are under the same constraints as the local variables, as discussed in the previous section. By naming your<a id="_idIndexMarker433"/> returns, you are creating local variables in the function. You can then assign values to those return variables, just as you do with <span class="No-Break">input parameters:</span></p>
			<pre class="source-code">
func greeting() (name string, age int) {
  name = "John"
  age = 21
  return name, age
}</pre>			<p>In the preceding code, <strong class="source-inline">(name string, age int)</strong> are named returns. They are now local variables to <span class="No-Break">the function.</span></p>
			<p>Since <strong class="source-inline">name</strong> and <strong class="source-inline">age</strong> are local variables that were declared in the return list of the function, you can now assign values to them. They can be treated as local variables. In the <strong class="source-inline">return</strong> statement, specify the return values. If you do not specify the variable name in the return, it is called a <span class="No-Break"><em class="italic">naked return</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func greeting() (name string, age int) {
  name = "John"
  age = 21
  return
}</pre>			<p>Consider the preceding code block. This code is the same as before with the exception that the return value does not name the variables to return. The <strong class="source-inline">return</strong> statement will return the variables that are named in the <span class="No-Break">return list.</span></p>
			<p>One of the disadvantages of naked returns is that it can cause confusion when reading code. To avoid confusion and the possibility of other issues, it is recommended that you avoid using the naked returns feature as it can make it difficult to follow the variable that is to be returned. There can also be issues with shadowing when using <span class="No-Break">naked returns:</span></p>
			<pre class="source-code">
func message() (message string, err error) {
  message = "hi"
  if message == "hi"{
    err := fmt.Errorf("say bye\n")
    return
  }
  return
}</pre>			<p>The preceding <a id="_idTextAnchor1124"/>code will result in the <span class="No-Break">following error:</span></p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B18621_05_07.jpg" alt="Figure 5.7: Output of shadowing with naked returns" width="383" height="24"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7: Output of shadowing with naked returns</p>
			<p>This is because the <strong class="source-inline">err</strong> variable is <a id="_idIndexMarker434"/>named in <strong class="source-inline">return</strong> and is initialized in an <strong class="source-inline">if</strong> statement. Recall that variables that are initialized within curly braces, such as <strong class="source-inline">for</strong> loops, <strong class="source-inline">if</strong> statements, and <strong class="source-inline">switch</strong> statements, are scoped to that context, meaning that they are only visible <a id="_idTextAnchor1125"/><a id="_idTextAnchor1126"/>and accessible within those <span class="No-Break">curly braces.</span></p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor1127"/>Exercise 5.04 – mapping a CSV index to a column header with return values</h2>
			<p>In <em class="italic">Exercise 5.02 – mapping index values to column headers</em>, we only printed the results of the index to the column <a id="_idIndexMarker435"/>header. In this exercise, we are going to return the map as the result. The map that’s being returned is the index-to-column header mapping. The following steps will help you with <span class="No-Break">the solution:</span></p>
			<ol>
				<li>Open the IDE of <span class="No-Break">your choice.</span></li>
				<li>Open the file from the previous column header exercise <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">mai<a id="_idTextAnchor1128"/><a id="_idTextAnchor1129"/>n.go</strong></span><span class="No-Break">.</span></li>
				<li>Enter the following code <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">:</span><pre class="source-code">
package main
import (
  "fmt"
  "strings"
)</pre></li>				<li>Next, in the <strong class="source-inline">main()</strong> function, define the headers for the columns. First, we will assign a variable to a key-value <a id="_idIndexMarker436"/>pair of <strong class="source-inline">int</strong> and <strong class="source-inline">string</strong>. <strong class="source-inline">key(int)</strong> will be the index of our <strong class="source-inline">header(string)</strong> column. The index will map to a <span class="No-Break">column header:</span><pre class="source-code">
func main() {
  hdr := []string{"empid", "employee", "address", "hours worked", "hourly rate", "manager"}
  result := csvHdrCol(hdr)
  fmt.Println("Result: ")
  fmt.Println(result)
  fmt.Println()
  hdr2 := []string{"employee", "empid", "hours worked", "address", "manager", "hourly rate"}
  result2 := csvHdrCol(hdr2)
  fmt.Println("Result2: ")
  fmt.Println(result2)
  fmt.Println()
}
func csvHdrCol(hdr []string) map[int]string {
  csvIdxToCol := make(map[int]string)</pre></li>				<li>We use <strong class="source-inline">range</strong> over <strong class="source-inline">header</strong> to process each string that is in <span class="No-Break">the slice:</span><pre class="source-code">
for i, v := range hdr {</pre></li>				<li>For each string, we remove any trailing spaces in front of and after the string. In general, we should always assume that our data may have some <span class="No-Break">erroneous characters:</span><pre class="source-code">
v = strings.TrimSpace(v)</pre></li>				<li>In our <strong class="source-inline">switch</strong> statement, we lower all the casing for exact matches. As you may recall, Go is a case-sensitive language. We need to ensure the casing is the same for matching purposes. When <a id="_idIndexMarker437"/>our code finds the header, it sets the index value for the header in <span class="No-Break">the map:</span><pre class="source-code">
switch strings.ToLower(v) {
    case "employee":
      csvIdxToCol[i] = v
    case "hours worked":
      csvIdxToCol[i] = v
    case "hourly rate":
      csvIdxToCol[i] = v
    }
  }
  return csvIdxToCol
}</pre></li>				<li>Open a terminal and navigate to the <span class="No-Break">code’s directory.</span></li>
				<li>Run <strong class="source-inline">go build</strong> and run <span class="No-Break">the executable.</span></li>
			</ol>
			<p>The expected output for return values is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Result1:
Map[1:employee 3:hours worked 4: hourly rate]
Result2:
Map[0:employee 2:hours worked 5: hourly rate]</pre>			<p>In this exercise, we saw a real-world example of mapping a CSV index to column headers. We used a function to solve this complex problem. We were able to have the function have a single return <a id="_idIndexMarker438"/>value of the <strong class="source-inline">map</strong> type. In the next section, we are going to see how functions can accept a variable number<a id="_idTextAnchor1130"/><a id="_idTextAnchor1131"/> of argument values within a <span class="No-Break">single argument.</span></p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor1132"/>Variadic functions</h2>
			<p>A variadic function is a function that accepts a <a id="_idIndexMarker439"/>variable number of argument values. It is good to use a variadic function when the number of arguments of a specified type <span class="No-Break">is unknown:</span></p>
			<pre class="source-code">
func f(parameterName …Type)</pre>			<p>The preceding function is an example of what a variadic function looks like. The three dots (<strong class="source-inline">…</strong>) in front of the type are called a <em class="italic">pack operator</em>. The pack <a id="_idIndexMarker440"/>operator is what makes it a variadic function. It tells Go to store all the arguments of <strong class="source-inline">Type</strong> in <strong class="source-inline">parameterName</strong>. The variadic variable can<a id="_idTextAnchor1133"/><a id="_idTextAnchor1134"/><a id="_idTextAnchor1135"/> accept zero or more variables as <span class="No-Break">the argument:</span></p>
			<pre class="source-code">
func main() {
  nums(99, 100)
  nums(200)
  nums()
}
func nums(i ...int) {
  fmt.Println(i)
}</pre>			<p>The <strong class="source-inline">nums</strong> function is a variadic function that accepts an <strong class="source-inline">int</strong> type. As stated previously, you can pass zero or more arguments of the type. If there is more than one value, you separate them with a comma, as in <strong class="source-inline">nums(99, 100)</strong>. If there is only one argument to pass, you only pass that argument, as in <strong class="source-inline">nums(200)</strong>. If there isn’t an argument to pass, you can leave it empty, as <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">nums()</strong></span><span class="No-Break">.</span></p>
			<p>Variadic functions can have other parameters. However, if your function requires multiple parameters, the variadic parameter must be the last in the function. Also, there can only be one variadic variable per function. The following function is incorrect and will result in an error at <a id="_idIndexMarker441"/>compile time as the variadic variable is not the last parameter of <span class="No-Break">the function.</span></p>
			<p><span class="No-Break"><strong class="bold">Incorrect function</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  nums(99, 100, "James")
}
func nums(i ...int, str person) {
  fmt.Println(str)
  fmt.P<a id="_idTextAnchor1136"/>rintln(i)
}</pre>			<p> The expected output is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B18621_05_08.jpg" alt="Figure 5.8: Variadic syntax error output" width="699" height="30"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8: Variadic syntax error output</p>
			<p><span class="No-Break"><strong class="bold">Correct function</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  nums("James", 99, 100)
}
func nums(str string, i ...int) {
  fmt.Println(str)
  fmt.Println(i)
}</pre>			<p>The output will look <span class="No-Break">as follows:</span></p>
			<pre class="console">
James
[99 100]</pre>			<p>You may have guessed by <a id="_idIndexMarker442"/>now that the actual type of <strong class="source-inline">Type</strong> inside the function is a slice. The function takes the arguments being passed in and converts them into the new slice being specified. For example, if the variadic type is <strong class="source-inline">int</strong>, then once you are inside the function, Go converts t<a id="_idTextAnchor1137"/>hat variadic <strong class="source-inline">int</strong> type into a slice <span class="No-Break">of integers:</span></p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B18621_05_09.jpg" alt="Figure 5.9: Converting a variadic int into a slice of integers" width="1197" height="314"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9: Converting a variadic int into a slice of integers</p>
			<p>Let’s make some tweaks to this example by having the <strong class="source-inline">variadic</strong> function take in <span class="No-Break">integer values:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  nums(99, 100)
}
func nums(i ...int) {
  fmt.Println(i)
  fmt.Printf("%T\n", i)
  fmt.Printf("Len: %d\n", len(i))
  fmt.Printf("Cap: %d\n", cap(i))
}</pre>			<p>The variadic function’s output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
[99 100]
[] int
Len: 2
Cap: 2</pre>			<p>The <strong class="source-inline">nums()</strong> function shows that the variadic type of <strong class="source-inline">i</strong> is a slice of integers. Once in the function, <strong class="source-inline">i</strong> will be a slice of <a id="_idIndexMarker443"/>integers. The variadic type has a length and capacity, which is to be expected for a slice. In the following code snippet, we will try to pass a slice of integers to a variadic <span class="No-Break">function, </span><span class="No-Break"><strong class="source-inline">nums()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  i := []int{ 5, 10, 15}
  nu<a id="_idTextAnchor1138"/>ms(i)
}
func nums(i ...int) {
  fmt.Println(i)
}</pre>			<p> The expected output is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B18621_05_10.jpg" alt="Figure 5.10: Variadic function error" width="713" height="28"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10: Variadic function error</p>
			<p>Why didn’t this code snippet work? We just proved that the variadic variable inside the function is of the <strong class="source-inline">slice</strong> type. The reason is that the function expects a list of arguments of the <strong class="source-inline">int</strong> type to be converted into a slice. Variadic functions work by converting the arguments that are passed into a slice of the type being specified. However, Go has a mechanism for passing a slice to a variadic function. For this, we need to use the unpack operator; it is three dots (<strong class="source-inline">…</strong>). When you call a variadic function and you want to pass a slice as <a id="_idIndexMarker444"/>an argument to a variadic parameter, you need to place the three dots before <span class="No-Break">the variable:</span></p>
			<pre class="source-code">
func main() {
  i := []int{ 5, 10, 15}
  nums(i…)
}
func nums(i ...int) {
  fmt.Println(i)
}</pre>			<p>The difference between this version of the function and the previous is the calling code to the function, <strong class="source-inline">nums</strong>. The three dots that are put after the <strong class="source-inline">i</strong> variable are a slice of integers. This allow<a id="_idTextAnchor1139"/>s a slice t<a id="_idTextAnchor1140"/>o be passed to the <span class="No-Break">variadic function.</span></p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor1141"/>Exercise 5.05 – summing numbers</h2>
			<p>In this exercise, we are going to sum up a variable number of arguments. We will pass the arguments as a list of arguments and as a <a id="_idIndexMarker445"/>slice. The return value will be an <strong class="source-inline">int</strong> type – that is, the sum of the values we passed to the function. The following steps will help you with <span class="No-Break">the solution:</span></p>
			<ol>
				<li>Open the IDE of <span class="No-Break">your choice.</span></li>
				<li>Create a new file in a new directory and save it<a id="_idTextAnchor1142"/><a id="_idTextAnchor1143"/> <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></li>
				<li>Enter the following code <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">:</span><pre class="source-code">
package main
import (
  "fmt"
)
func main() {
  i := []int{ 5, 10, 15}
  fmt.Println(sum(5, 4))
  fmt.Println(sum(i...))
}</pre></li>				<li>The <strong class="source-inline">sum</strong> function accepts a variadic argument of the <strong class="source-inline">int</strong> type. Since it gets converted into a slice, we can<a id="_idIndexMarker446"/> range over the values and return the sum of all the values that <span class="No-Break">get passed:</span><pre class="source-code">
func sum(nums ...int) int {
  total := 0
  for _, num := range nums {
    total += num
  }
  return total
}</pre></li>				<li>Open a terminal and navigate to the <span class="No-Break">code’s directory.</span></li>
				<li>Run <strong class="source-inline">go build</strong> and run <span class="No-Break">the executable.</span></li>
			</ol>
			<p>The expected output for summing numbers is <span class="No-Break">as follows:</span></p>
			<pre class="console">
9
30</pre>			<p>In this exercise, we saw that by using a variadic parameter, we can accept an unknown number of arguments. Our function allows us to sum up any number of integers. We can see that variadic parameters can be utilized to solve specific problems where the number of values of the same type being passed as an argument is unknown. In the next section, we are going to look at how to create a function w<a id="_idTextAnchor1144"/><a id="_idTextAnchor1145"/>ithout a name and assign a function to <span class="No-Break">a variable.</span></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor1146"/>Anonymous functions</h2>
			<p>So far, we have been using named functions. As you may recall, named functions are functions that have an identifier or a function<a id="_idIndexMarker447"/> name. Anonymous functions, also referred to as function <a id="_idIndexMarker448"/>literals, are functions that do not have a function name, hence the name “anonymous functions.” An anonymous function is declared in a similar way to how a named function is declared. The only difference with the declaration is that the name for the function is omitted. Anonymous functions can do whatever a normal function in Go does, including accepting arguments and returning values. Anonymous functions can also be declared within <span class="No-Break">another function.</span></p>
			<p>In this section, we will be introducing the fundamentals of anonymous functions and some of their basic uses. Later, you will see how anonymous functions can be fully utilized. Anonymous functions are used for (and in conjunction with) <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">Closure implementations</span></li>
				<li><span class="No-Break"><strong class="source-inline">defer</strong></span><span class="No-Break"> statements</span></li>
				<li>Defining a code block to be used with <span class="No-Break">a goroutine</span></li>
				<li>Defining a function for <span class="No-Break">one-time use</span></li>
				<li>Passing a function to <span class="No-Break">another function</span><p class="list-inset">The following is a basic declaration for an <span class="No-Break">anonymous function:</span></p><pre class="source-code">
func main() {
  func() {
    fmt.Println("Greeting")
  }()
}</pre></li>			</ul>
			<p>Let’s take a <span class="No-Break">closer look:</span></p>
			<ul>
				<li>Notice that we are declaring a function inside another function. As with named functions, you must start with the <strong class="source-inline">func</strong> keyword to declare <span class="No-Break">a function.</span></li>
				<li>Following the <strong class="source-inline">func</strong> keyword would normally be the name of the function, but with anonymous functions, there is no function name. Instead, there are <span class="No-Break">empty parentheses.</span></li>
				<li>The empty parentheses following the <strong class="source-inline">func</strong> keyword are where the function’s parameters would be defined for <span class="No-Break">the function.</span></li>
				<li>Next is the open curly brace, <strong class="source-inline">{</strong>, which starts the <span class="No-Break">function body.</span></li>
				<li>The function body is only a <a id="_idIndexMarker449"/>one-liner; it will <span class="No-Break">print “</span><span class="No-Break"><strong class="source-inline">Greeting</strong></span><span class="No-Break">”.</span></li>
				<li>The closing curly brace, <strong class="source-inline">}</strong>, denotes the end of <span class="No-Break">the function.</span></li>
				<li>The last set of parentheses is called the execution parentheses. These parentheses invoke the anonymous function. The function will execute immediately. Later, we will see how to execute an anonymous function at a later location within <span class="No-Break">the function.</span><p class="list-inset">You can also pass arguments to an anonymous function. To be able to pass arguments to an anonymous function, they must be supplied in the <span class="No-Break">execution parentheses:</span></p><pre class="source-code">
func main() {
  message := "Greeting"
  func(str string) {
    fmt.Println(str)
  }(message)
}</pre></li>			</ul>
			<p>Here, we have <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">func (str string)</strong>: The anonymous function being declared has an input parameter of the <span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break"> type.</span></li>
				<li><strong class="source-inline">} (message)</strong>: The argument message that’s being passed to the <span class="No-Break">execution parentheses.</span></li>
			</ul>
			<p>We have been executing anonymous functions as they are declared, but there are other ways to execute anonymous functions. You can also save the anonymous function to a variable. This leads to a different set of <a id="_idIndexMarker450"/>opportunities that we will look at in <span class="No-Break">this chapter:</span></p>
			<pre class="source-code">
func main() {
  f := func() {
    fmt.Println("Executing an anonymous function using a variable")
  }
  fmt.Println("Line after anonymous function declaration")
  f()
}</pre>			<p>Let’s take a <span class="No-Break">closer look:</span></p>
			<ul>
				<li>We are assigning the <strong class="source-inline">f</strong> variable to our <span class="No-Break">anonymous function.</span></li>
				<li><strong class="source-inline">f</strong> is now of the <span class="No-Break"><strong class="source-inline">func()</strong></span><span class="No-Break"> type.</span></li>
				<li><strong class="source-inline">f</strong> can now be used to invoke the anonymous function, in a fashion similar to that for a named function. You must in<a id="_idTextAnchor1147"/>clude <strong class="source-inline">()</strong> af<a id="_idTextAnchor1148"/>ter the <strong class="source-inline">f</strong> variabl<a id="_idTextAnchor1149"/>e to execute <span class="No-Break">the function.</span></li>
			</ul>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor1150"/>Exercise 5.06 – creating an anonymous function to calculate the square root of a number</h2>
			<p>Anonymous functions are great for small snippets <a id="_idIndexMarker451"/>of code that you want to execute within a function. Here, we are going to create an anonymous function that is going to have an argument passed to it. It will then calculate the square root. The following steps will help you with <span class="No-Break">the solution:</span></p>
			<ol>
				<li>Use the IDE of <span class="No-Break">your choice.</span></li>
				<li>Create a new file and save it <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></li>
				<li>Enter the following code in <strong class="source-inline">main.go</strong>. We are assigning our <strong class="source-inline">x</strong> variable to our anonymous function. Our <a id="_idIndexMarker452"/>anonymous function tak<a id="_idTextAnchor1151"/><a id="_idTextAnchor1152"/>es a parameter, <strong class="source-inline">(i int)</strong>. It also returns a value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break">:</span><pre class="source-code">
package main
import (
  "fmt"
)
func main() {
  j := 9
  x := func(i int) int {
    return i * i
  }</pre></li>				<li>Notice that the last curly brace does not have <strong class="source-inline">()</strong> to execute the function. We call our anonymous function <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">x(j)</strong></span><span class="No-Break">:</span><pre class="source-code">
  fmt.Printf("The square of %d is %d\n", j, x(j))
}</pre></li>				<li>Open a terminal and navigate to the <span class="No-Break">code’s directory.</span></li>
				<li>Run <strong class="source-inline">go build</strong> and run <span class="No-Break">the executable.</span></li>
			</ol>
			<p>The expected output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
The square of 9 is 81</pre>			<p>In this exercise, we saw how to assign a variable to a function and later call that function by using the variable that was assigned to it. We saw that when we need a small function that might not be reusable in our program, we can create an anonymous function and assign it to a variable. In the next section, we are goi<a id="_idTextAnchor1153"/><a id="_idTextAnchor1154"/>ng to expand the use of anonymous functions <span class="No-Break">to closures.</span></p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor1155"/>Closures</h1>
			<p>So far, we have introduced anonymous function syntax using some basic examples. Now that we have a fundamental understanding of<a id="_idIndexMarker453"/> how anonymous functions work, we will look at how we can use this <span class="No-Break">powerful concept.</span></p>
			<p>Closures are a form of anonymous functions. Regular functions cannot reference variables outside of themselves; however, an anonymous function can reference variables external to their definition. A closure can use variables declared at the same level as the anonymous function’s declaration. These variables do not need to be passed as parameters. The anonymous <a id="_idTextAnchor1156"/><a id="_idTextAnchor1157"/><a id="_idTextAnchor1158"/>function has access to these variables when it <span class="No-Break">is called:</span></p>
			<pre class="source-code">
func main() {
  i := 0
  incrementor := func() int {
    i +=1
    return i
  }
  fmt.Println(incrementor())
  fmt.Println(incrementor())
  i +=10
  fmt.Println(incrementor())
}</pre>			<p><span class="No-Break"><strong class="bold">Code synopsis</strong></span><span class="No-Break">:</span></p>
			<ol>
				<li>We initialize a variable in the <strong class="source-inline">main()</strong> function called <strong class="source-inline">i</strong> and set it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></li>
				<li>We assign <strong class="source-inline">incrementor</strong> to our <span class="No-Break">anonymous function.</span></li>
				<li>The anonymous function increments <strong class="source-inline">i</strong> and returns it. Notice that our function does not have any <span class="No-Break">input parameters.</span></li>
				<li>Then, we print the results of <strong class="source-inline">incrementor</strong> twice and get <strong class="source-inline">1</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">.</span></li>
				<li>Notice that, outside our function, we increment <strong class="source-inline">i</strong> by <strong class="source-inline">10</strong>. This is a problem. We want <strong class="source-inline">i</strong> to be isolated and for it not to change as this is not the desired behavior. When we print the results of <strong class="source-inline">incrementor</strong> again, it will be <strong class="source-inline">12</strong>. We want it to be <strong class="source-inline">3</strong>. We will correct this in our <span class="No-Break">next example.</span></li>
			</ol>
			<p>One problem with the previous<a id="_idIndexMarker454"/> example that we noticed is that any code in the main function has access to <strong class="source-inline">i</strong>. As we saw in the example, <strong class="source-inline">i</strong> can be accessed and changed outside of our function. This is not the desired behavior; we want the incrementor to be the only one to change that value. In other words, we want <strong class="source-inline">i</strong> to be protected from other functions changing it. The only function that sho<a id="_idTextAnchor1159"/><a id="_idTextAnchor1160"/>uld be changin<a id="_idTextAnchor1161"/><a id="_idTextAnchor1162"/>g is our anonymous function when we <span class="No-Break">call it:</span></p>
			<pre class="source-code">
func main() {<a id="_idTextAnchor1163"/>
  increment := incrementor()
  fmt.Println(increment())
  fmt.Println(increment())
}
func incrementor() func() int {
  i := 0
  return func() int {
    i += 1
    return i
  }
}</pre>			<p><span class="No-Break"><strong class="bold">Code synopsis</strong></span><span class="No-Break">:</span></p>
			<ol>
				<li>We declared a function called <strong class="source-inline">incrementor()</strong>. This function has a return type of <span class="No-Break"><strong class="source-inline">func() int</strong></span><span class="No-Break">.</span></li>
				<li>Using <strong class="source-inline">i := 0</strong>, we initialize our variable at the level of the <strong class="source-inline">incrementor()</strong> function; this is similar to what we did in the previous example, except it was at the <strong class="source-inline">main()</strong> function level <a id="_idIndexMarker455"/>and anyone at that level had access to <strong class="source-inline">i</strong>. Only the <strong class="source-inline">incrementor()</strong> function has access to the <strong class="source-inline">i</strong> variable with <span class="No-Break">this implementation.</span></li>
				<li>We are returning our anonymous function, <strong class="source-inline">func() int</strong>, which increments the <span class="No-Break"><strong class="source-inline">i</strong></span><span class="No-Break"> variable.</span></li>
				<li>In the <strong class="source-inline">main()</strong> function, <strong class="source-inline">increment := incrementor()</strong> assigns a variable to <strong class="source-inline">func() int</strong> that gets returned. It is important to note that <strong class="source-inline">incrementor()</strong> only gets executed once here. In our <strong class="source-inline">main()</strong> function, it is no longer being referenced <span class="No-Break">or executed.</span></li>
				<li><strong class="source-inline">increment()</strong> is of the <strong class="source-inline">func() int</strong> type. Each call to <strong class="source-inline">increment()</strong> runs the anonymous function code. It is referencing the <strong class="source-inline">i</strong> variable, even after <strong class="source-inline">incrementor()</strong> has <span class="No-Break">been executed.</span></li>
			</ol>
			<p>The preceding example demonstrated how we can protect our variable by wrapping it with an anonymous function, thereby restricting access to updating the variable only through invoking the anonymous function itself. This is shown through the expect<a id="_idTextAnchor1164"/><a id="_idTextAnchor1165"/>ed output, where we’ve incremented <strong class="source-inline">i</strong> twice, <span class="No-Break">as follows:</span></p>
			<pre class="console">
1
2</pre>			<h2 id="_idParaDest-197"><a id="_idTextAnchor1166"/>Exercise 5.07 – creating a closure function to decrement a counter</h2>
			<p>In this exercise, we are going to <a id="_idIndexMarker456"/>create a closure that decrements from a given starting value. We will combine what we have learned about passing an argument to an anonymous function and use that knowledge with a closure. The following steps will help you with <span class="No-Break">the solution:</span></p>
			<ol>
				<li>Open the IDE of <span class="No-Break">your choice.</span></li>
				<li>Create a new file in a new directory <a id="_idTextAnchor1167"/><a id="_idTextAnchor1168"/>and save it <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></li>
				<li>Enter the following code <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">:</span><pre class="source-code">
func main() {import "fmt"
  counter := 4</pre></li>				<li>We will look at the <strong class="source-inline">decrement</strong> function first. It takes an argument of the <strong class="source-inline">int</strong> type and has a return value of <strong class="source-inline">func()int</strong>. In previous examples, the variable was declared inside<a id="_idIndexMarker457"/> the function but before the anonymous function. In this exercise, we have it as an <span class="No-Break">input parameter:</span><pre class="source-code">
x:= decrement(counter)
  fmt.Println(x())
  fmt.Println(x())
  fmt.Println(x())
  fmt.Println(x())
}</pre></li>				<li>We decrement <strong class="source-inline">i</strong> by one inside the <span class="No-Break">anonymous function:</span><pre class="source-code">
func decrement(i int) func() int {</pre></li>				<li>In the <strong class="source-inline">main()</strong> function, we initialize a variable counter to be used as our starting integer to <span class="No-Break">be decremented:</span><pre class="source-code">
return func() int {</pre></li>				<li>Here, we have <strong class="source-inline">x:= decrement(counter)</strong>; <strong class="source-inline">x</strong> is assigned to <strong class="source-inline">func() int</strong>. Each call to <strong class="source-inline">x()</strong> runs the <span class="No-Break">anonymous function:</span><pre class="source-code">
    I–-
    return i
  }
}</pre></li>				<li>Open a terminal and navigate to the <span class="No-Break">code’s directory.</span></li>
				<li>Run <strong class="source-inline">go build</strong> and run <span class="No-Break">the executable.</span></li>
			</ol>
			<p>The expected output for the <strong class="source-inline">decrement</strong> counter is <span class="No-Break">as follows:</span></p>
			<pre class="console">
3
2
1
0</pre>			<p>In this exercise, we saw that closures have access to variables that are external to them. This allowed our anonymous<a id="_idIndexMarker458"/> function to make changes to the variable that a normal function would not be able to make. In the next section, we are going to look at<a id="_idTextAnchor1169"/><a id="_idTextAnchor1170"/> how functions can be passed as arguments to <span class="No-Break">another function.</span></p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor1171"/>Function types</h2>
			<p>As we have seen so far, Go has rich feature<a id="_idIndexMarker459"/> support for functions. In Go, functions are types too, just like <strong class="source-inline">int</strong>, <strong class="source-inline">string</strong>, and <strong class="source-inline">bool</strong> are types. This means we can pass functions as arguments to other functions, functions can be returned from a function, and functions can be assigned to variables. We can even define our own function types. A function’s type signature defines the types of its input parameters and return values. For a function to be of the type of another function, it must have the exact signature of the type ’unction that is declared. Let’s examine a few <span class="No-Break">function types:</span></p>
			<pre class="source-code">
type message func()</pre>			<p>The preceding code snippet creates a new function type called <strong class="source-inline">message</strong>. It has no input parameters and does not have any <span class="No-Break">return types.</span></p>
			<p>Let’s examine <span class="No-Break">another one:</span></p>
			<pre class="source-code">
type calc func(int, int) string</pre>			<p>The preceding code snippet creates a new function type called <strong class="source-inline">calc</strong>. It accepts two arguments of the <strong class="source-inline">int</strong> type and its return value is of the <span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break"> type.</span></p>
			<p>Now that we have a fundamental <a id="_idIndexMarker460"/>understanding of f<a id="_idTextAnchor1172"/><a id="_idTextAnchor1173"/>unction types, we can write some code to demonstrate <span class="No-Break">their uses:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
)
type calc func(int, int) string
func main() {
  calculator(add, 5, 6)
}
func add(i, j int) string {
  result := i + j
  return fmt.Sprintf("Added %d + %d = %d", i, j, result)
}
func calculator(f calc, i, j int) {
  fmt.Println(f(i, j))
}</pre>			<p>Let’s look at the code by <span class="No-Break">the line:</span></p>
			<pre class="source-code">
type calc func(int, int) string</pre>			<p><strong class="source-inline">type calc</strong> declares <strong class="source-inline">calc</strong> to be of the <strong class="source-inline">func</strong> type, determining that it takes two integers as arguments and returns <span class="No-Break">a string:</span></p>
			<pre class="source-code">
func add(i, j int) string {
  result := i + j
  return fmt.Sprintf("Added %d + %d = %d", i, j, result)
}</pre>			<p><strong class="source-inline">func add(i,j int) string</strong> has the same signature as the <strong class="source-inline">calc</strong> type. It takes two integers as arguments and returns a string stating “Adding <strong class="source-inline">i + j = result</strong>.” Functions can be passed to <a id="_idIndexMarker461"/>other functions, just like any other type <span class="No-Break">in Go:</span></p>
			<pre class="source-code">
func calculator(f calc, i, j int) {
  fmt.Println(f(i, j))
}</pre>			<p><strong class="source-inline">func calculator(f calc, i, j int)</strong> accepts <strong class="source-inline">calc</strong> as input. The <strong class="source-inline">calc</strong> type, as you may remember, is a function type that has input parameters of <strong class="source-inline">int</strong> and a return type of <strong class="source-inline">string</strong>. Anything that matches that signature can be passed to the function. The <strong class="source-inline">func calculator</strong> function returns the result of the function of the <span class="No-Break"><strong class="source-inline">calc</strong></span><span class="No-Break"> type.</span></p>
			<p>In the <strong class="source-inline">main</strong> function, we call <strong class="source-inline">calculator(add, 5, 6)</strong>. We are passing it the <strong class="source-inline">add</strong> function. <strong class="source-inline">add</strong> satisfies the signature of the <strong class="source-inline">calc </strong><span class="No-Break"><strong class="source-inline">func</strong></span><span class="No-Break"> type.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.11</em> summarizes each of the preceding functions and how they relate to each other. This figure shows how <strong class="source-inline">func add</strong> is of the <strong class="source-inline">func calc</strong> type, whic<a id="_idTextAnchor1174"/>h then allows it to be passed as an argument to <span class="No-Break"><strong class="source-inline">func calculator</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B18621_05_11.jpg" alt="Figure 5.11: Function types and uses" width="1122" height="631"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11: Function types and uses</p>
			<p>We have just seen how to create a function type and pass it as an argument to a function. It is not that far of a stretch to pass a function as a parameter to another function. We will change our<a id="_idIndexMarker462"/> previo<a id="_idTextAnchor1175"/><a id="_idTextAnchor1176"/>us example slightly to reflect passing a function as <span class="No-Break">a parameter:</span></p>
			<pre class="source-code">
func main() {
  calculator(add, 5, 6)
  calculator(subtract, 10, 5)
}
func calculator(f func(int, int) int, i, j int) {
  fmt.Println(f(i, j))
}
func add(i, j int) int {
  return i + j
}
func subtract(i, j int) int {
  return i - j
}</pre>			<p>Let’s take a <span class="No-Break">closer look:</span></p>
			<ul>
				<li>We modified the <strong class="source-inline">add</strong> function signature so that it returns an <strong class="source-inline">int</strong> type instead of a <span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break"> type.</span></li>
				<li>We added a second function called <strong class="source-inline">subtract</strong>. Note that its function signature is the same as that of the <strong class="source-inline">add</strong> function. The <strong class="source-inline">subtract</strong> function simply returns the result of subtracting <span class="No-Break">two numbers:</span><pre class="source-code">
func calculator(f func(int, int) int, i, j int) {
  fmt.Println(f(i, j))
}</pre></li>				<li>Here, we have <strong class="source-inline">calculator(f func(int, int) int, i, j int)</strong>. The <strong class="source-inline">calculator</strong> function now has an input parameter of the <strong class="source-inline">func</strong> type. The input parameter, <strong class="source-inline">f</strong>, is a function that accepts two integers and returns an <strong class="source-inline">int</strong> type. Any function that satisfies the signature can be passed to <span class="No-Break">the function.</span></li>
				<li>In the <strong class="source-inline">main()</strong> function, <strong class="source-inline">calculator</strong> is called twice: once with the <strong class="source-inline">add</strong> function and some integer <a id="_idIndexMarker463"/>values being passed and once with the <strong class="source-inline">subtract</strong> function being passed as an argument with some <span class="No-Break">integer values.</span></li>
			</ul>
			<p>The expected output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
11
5</pre>			<p>The ability to pass functions as a type is a powerful feature where you can pass functions to other functions if their signatures match the passed-to function’s input parameter. An integer type for a function can be any value if it is an integer. The same goes for passing functions: a function can be any value if it is the <span class="No-Break">correct type.</span></p>
			<p>A function can also be returned from another function. We saw this when using anonymous functions combined with closures. Here, we will take a brief look since we saw this <span class="No-Break">syntax previously:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  v:= square(9)
  fmt.Println(v())
  fmt.Printf("Type of v: %T",v)
}
func square(x int) func() int {
  f := func() int {
    return x * x
  }
  return f
}</pre>			<p>Returning a function looks <span class="No-Break">as follows:</span></p>
			<pre class="console">
81
Type of v: func() int</pre>			<ul>
				<li>Here, we have <strong class="source-inline">square(x int) func() int</strong>. The <strong class="source-inline">square</strong> function accepts an <strong class="source-inline">int</strong> type as <a id="_idIndexMarker464"/>an argument and returns a function type that returns an <span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> type:</span><pre class="source-code">
func square(x int) func() int {
  f := func() int {
    return x * x
  }
  return f
}</pre></li>				<li>In the <strong class="source-inline">square</strong> body, we assign a variable, <strong class="source-inline">f</strong>, to an anonymous function that returns the square value of the input <span class="No-Break">parameter, </span><span class="No-Break"><strong class="source-inline">x</strong></span><span class="No-Break">.</span></li>
				<li>The <strong class="source-inline">return</strong> statement for the <strong class="source-inline">square</strong> function returns an anonymous function that is of the <strong class="source-inline">func() </strong><span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> type.</span></li>
				<li><strong class="source-inline">v</strong> is assigned to the return of the <strong class="source-inline">square</strong> function. As you may recall, the return value is of the <strong class="source-inline">func() </strong><span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break"> type.</span></li>
				<li><strong class="source-inline">v</strong> has been assigned the <strong class="source-inline">func ()int</strong> type; however, it has not been invoked. We will invoke it inside the <span class="No-Break"><strong class="source-inline">print</strong></span><span class="No-Break"> statement.</span></li>
				<li>Finally, we have <strong class="source-inline">fmt.Printf("Type of v: %T",v)</strong>.<a id="_idTextAnchor1177"/><a id="_idTextAnchor1178"/> This statement just prints out the type for <strong class="source-inline">v</strong>, which <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">func()int</strong></span><span class="No-Break">.</span></li>
			</ul>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor1179"/>Exercise 5.08 – creating various functions to calculate salary</h2>
			<p>In this exercise, we are going to be creating several functions. We need the ability to calculate the salary of a developer and a manager. We want this solution to be extensible for the future possibilities of other salaries to be calculated. We will be creating functions to calculate the<a id="_idIndexMarker465"/> developer’s and manager’s salary. Then, we will create another function that will take the previously mentioned function as an input parameter. The following steps will help you with <span class="No-Break">the solution:</span></p>
			<ol>
				<li>Use the IDE of <span class="No-Break">your choice.</span></li>
				<li>Create a new file in a new di<a id="_idTextAnchor1180"/><a id="_idTextAnchor1181"/>rectory and save it <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></li>
				<li>Enter the following code <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">:</span><pre class="source-code">
package main
import "fmt"
func main() {
  devSalary := salary(50, 2080, developerSalary)
  bossSalary := salary(150000, 25000, managerSalary)
  fmt.Printf("Boss salary: %d\n", bossSalary)
  fmt.Printf("Developer salary: %d\n", devSalary)
}</pre></li>				<li>The <strong class="source-inline">salary</strong> function accepts a function that accepts two integers as arguments and returns an int <strong class="source-inline">type</strong>. So, any function that matches<a id="_idTextAnchor1182"/> that signature can be passed as an argument to the <span class="No-Break"><strong class="source-inline">salary</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func salary(x, y int, f func(int, int) int) int{</pre></li>				<li>In the body of the <strong class="source-inline">salary()</strong> function, <strong class="source-inline">pay</strong>, is assigned the value that gets returned from<a id="_idTextAnchor1183"/><a id="_idTextAnchor1184"/> the <strong class="source-inline">f</strong> function. It passes <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> as parameters to the <span class="No-Break"><strong class="source-inline">f</strong></span><span class="No-Break"> parameter:</span><pre class="source-code">
  pay := f(x, y)
  return pay
}</pre></li>				<li>Notice that the <strong class="source-inline">managerSalary</strong> and <strong class="source-inline">developerSalary</strong> signatures are identical and that they match the <strong class="source-inline">f</strong> function for <strong class="source-inline">salary</strong>. This means that both <strong class="source-inline">ma<a id="_idTextAnchor1185"/><a id="_idTextAnchor1186"/>nagerSalary</strong> and <strong class="source-inline">developerSalary</strong> can be passed as <strong class="source-inline">func(int, </strong><span class="No-Break"><strong class="source-inline">int) int</strong></span><span class="No-Break">:</span><pre class="source-code">
func managerSalary(baseSalary, bonus int) int {
  return baseSalary + bonus
}</pre></li>				<li><strong class="source-inline">devSalary</strong> and <strong class="source-inline">bossSalary</strong> get assigned to the results of the <strong class="source-inline">salary</strong> function. Since <strong class="source-inline">developerSalary</strong> and <strong class="source-inline">managerSalary</strong> satisfy the signa<a id="_idTextAnchor1187"/><a id="_idTextAnchor1188"/>ture of <strong class="source-inline">func(int, int) int</strong>, they can<a id="_idIndexMarker466"/> both be passed in <span class="No-Break">as arguments:</span><pre class="source-code">
func developerSalary(hourlyRate, hoursWorked int) int {
  return hourlyRate * hoursWorked
}</pre></li>				<li>Open a terminal and navigate to the <span class="No-Break">code’s directory.</span></li>
				<li>Run <strong class="source-inline">go build</strong> and run <span class="No-Break">the executable.</span></li>
			</ol>
			<p>The expected output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Boss salary: 175000
Developer salary: 104000</pre>			<p>In this exercise, we saw how a function type can be a parameter for another function. This allows a function to be an argument to another function. This exercise showed how our code can be simplified by having one <strong class="source-inline">salary</strong> function. If, in the future, we need to calculate the salary for a tester position, we would only need to create a function that matches the function type for <strong class="source-inline">salary</strong> and pass it as an argument. The flexibility that this gives is that we do not have to change our <strong class="source-inline">salary</strong> function’s implementation. In the next section, we are going to see how we can change the e<a id="_idTextAnchor1189"/><a id="_idTextAnchor1190"/>xecution flow of a function, specifically after the <span class="No-Break">function returns.</span></p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor1191"/>defer</h1>
			<p>The <strong class="source-inline">defer</strong> statement defers the execution of a function until the surrounding function returns. Let’s try to explain this a bit better. Inside<a id="_idIndexMarker467"/> a function, you have a <strong class="source-inline">defer</strong> statement in front of a function that you are calling. Essentially, that function will execute right before the function you are currently inside completes. Still<a id="_idTextAnchor1192"/><a id="_idTextAnchor1193"/> confused? Perhaps an example will make this concept a <span class="No-Break">little clearer:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  defer done()
  fmt.Println("Main: Start")
  fmt.Println("Main: End")
}
func done() {
  fmt.Println("Now I am done")
}</pre>			<p>The output for the <strong class="source-inline">defer</strong> example is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Main: Start
Main: End
Now I am done</pre>			<p>Inside the <strong class="source-inline">main()</strong> function, we have a deferred function, <strong class="source-inline">defer done()</strong>. Notice that the <strong class="source-inline">done()</strong> function has no new or special syntax. It just does a simple print to <span class="No-Break">the console.</span></p>
			<p>Next, we have two <strong class="source-inline">print</strong> statements. The results are interesting. The two <strong class="source-inline">print</strong> statements in the <strong class="source-inline">main()</strong> function print first. Even though the deferred function was first in <strong class="source-inline">main()</strong>, it printed last. Isn’t that interesting? Its ordering in the <strong class="source-inline">main()</strong> function did not dictate its order <span class="No-Break">of execution.</span></p>
			<p>These deferred functions are commonly used for performing “cleanup” activities. This includes releasing resources, closing files, closing database connections, and removing <strong class="source-inline">configuration\temp</strong> files created by a program. <strong class="source-inline">defer</strong> functions are also used to recover from a panic; this will be discussed later in <span class="No-Break">this book.</span></p>
			<p>Using the <strong class="source-inline">defer</strong> statement is<a id="_idIndexMarker468"/> not limited to just named functions – you can also utilize the <strong class="source-inline">defer</strong> statement with anonymous functions. Taking our previous code snippet, let’s turn it into a deferred call with an <span class="No-Break">anonymous function:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  defer func() {
    fmt.Println("Now I am done")
  }()
  fmt.Println("Main: Start")
  fmt.Println("Main: End")
}</pre>			<p>Let’s take a <span class="No-Break">closer look:</span></p>
			<ul>
				<li>There’s not much that has changed from the previous code. We took the code that was in the <strong class="source-inline">done</strong> function and created a deferred <span class="No-Break">anonymous function.</span></li>
				<li>The <strong class="source-inline">defer</strong> statement is placed before the <strong class="source-inline">func()</strong> keyword. Our function has no function name. As you may recall, a function without a name is an <span class="No-Break">anonymous function.</span></li>
				<li>The results are the same as those from the previous example. Its readability, to a certain extent, is easier than having the deferred function declared as a named function, as in the <span class="No-Break">previous example.</span></li>
			</ul>
			<p>It is also possible and common to have multiple <strong class="source-inline">defer</strong> statements in a function. However, they may not execute in the order that you expect. When using <strong class="source-inline">defer</strong> statements in front of functions, the execution <a id="_idIndexMarker469"/>follows the order of <strong class="bold">First In, Last Out</strong> (<strong class="bold">FILO</strong>). Think of it as how you would stack plates. The first plate to start the stack will have a second plate placed on it, the second plate will have a third plate placed on it, and so on. The first plate to get taken off the stack is the last plate that was placed on the stack. The first plate that <a id="_idIndexMarker470"/>was placed to start the stack will be the last plate to come off the stack. Let’s look at an example that declares multi<a id="_idTextAnchor1194"/><a id="_idTextAnchor1195"/>ple anonymous functions with the <strong class="source-inline">defer</strong> statement placed in front <span class="No-Break">of them:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  defer func() {
    fmt.Println("I was declared first.")
  }()
  defer func() {
    fmt.Println("I was declared second.")
  }()
  defer func() {
    fmt.Println("I was declared third.")
  }()
  f1 := func() {
    fmt.Println("Main: Start")
  }
  f2 := func() {
    fmt.Println("Main: End")
  }
  f1()
  f2()
}</pre>			<p>The multiple <strong class="source-inline">defer</strong> output looks <span class="No-Break">as follows:</span></p>
			<pre class="console">
Main: Start
Main: End
I was declared third.
I was declared second.
I was declared first.</pre>			<p>Let’s take a <span class="No-Break">closer look:</span></p>
			<ul>
				<li>The first three anonymous <a id="_idIndexMarker471"/>functions have their <span class="No-Break">execution deferred.</span></li>
				<li>We declare <strong class="source-inline">f1</strong> and <strong class="source-inline">f2</strong> to be of the <strong class="source-inline">func()</strong> type. These two functions <span class="No-Break">are anonymous.</span></li>
				<li>As you can see, <strong class="source-inline">f1()</strong> and <strong class="source-inline">f2()</strong> executed as expected, but the order of the multiple <strong class="source-inline">defer</strong> statements executed in the reverse order of how they were declared in the code. The first <strong class="source-inline">defer</strong> statement was the last to execute and the last <strong class="source-inline">defer</strong> statement was the first <span class="No-Break">to execute.</span></li>
			</ul>
			<p>Careful consideration must be given when using <strong class="source-inline">defer</strong> statements. A situation that you should consider is when you use <strong class="source-inline">defer</strong> statements in conjunction with variables. When a variable is passed to a deferred function, the variable’s value at that time is what will be used in the deferred function. If that variable is changed after the de<a id="_idTextAnchor1196"/><a id="_idTextAnchor1197"/>ferred function, it will not be reflected when the deferred <span class="No-Break">function runs:</span></p>
			<pre class="source-code">
func main() {
  age := 25
  name := "John"
  defer personAge(name, age)
  age *= 2
  fmt.Printf("Age double %d.\n", age)
}
func personAge(name string, i int) {
    fmt.Printf("%s is %d.\n", name, i)
}</pre>			<p>The output would be <span class="No-Break">as follows:</span></p>
			<pre class="console">
Age double 50.
John is 25.</pre>			<p>Let’s take a <span class="No-Break">closer look:</span></p>
			<ul>
				<li><strong class="source-inline">age := 25</strong>: We initialize<a id="_idIndexMarker472"/> the <strong class="source-inline">age</strong> variable to <strong class="source-inline">25</strong> before the <span class="No-Break"><strong class="source-inline">defer</strong></span><span class="No-Break"> function.</span></li>
				<li><strong class="source-inline">name := "John"</strong>: We initialize the <strong class="source-inline">name</strong> variable to <strong class="source-inline">"John"</strong> before the <span class="No-Break"><strong class="source-inline">defer</strong></span><span class="No-Break"> function.</span></li>
				<li><strong class="source-inline">defer personAge(name, age)</strong>: We state that the function is going to <span class="No-Break">be deferred.</span></li>
				<li><strong class="source-inline">age *= 2</strong>: We double the age after the deferred function. Then, we print the current value of <span class="No-Break"><strong class="source-inline">age</strong></span><span class="No-Break"> doubled.</span></li>
				<li><strong class="source-inline">personAge(name string, i int)</strong>: This is the function that is deferred; it only prints out the person <span class="No-Break">and age.</span></li>
				<li>The results show the value of <strong class="source-inline">age (25)</strong> after it has been doubled in the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function.</span></li>
				<li>When the execution of the program reaches the line that has <strong class="source-inline">defer</strong> <strong class="source-inline">personAge(name, age)</strong>, the value of <strong class="source-inline">age</strong> is <strong class="source-inline">25</strong>. Before the <strong class="source-inline">main()</strong> function completes, the deferred function runs and the value of <strong class="source-inline">age</strong> is still <strong class="source-inline">25</strong>. Variables used in the deferred function <a id="_idTextAnchor1198"/>are the valu<a id="_idTextAnchor1199"/><a id="_idTextAnchor1200"/>es before it was deferred, regardless of what happens <span class="No-Break">after it.</span></li>
			</ul>
			<h2 id="_idParaDest-201">Activit<a id="_idTextAnchor1201"/>y 5.02 – calculating the payable amount for employees based on working hours</h2>
			<p>This activity is based on the previous activity. We will keep the same functionality, but we will be adding three additional features. In this version of the application, we would like to give the employee the ability to <a id="_idIndexMarker473"/>track their hours throughout the day without having logged them yet. This will allow the employees to keep better track of their hours before they log them at the end of the day. We will also enhance the application so that it calculates the employee’s pay. The application will calculate their pay for any overtime they’ve worked. The application will also print out details of how many hours were worked <span class="No-Break">each day:</span></p>
			<ol>
				<li>Create a function called <strong class="source-inline">nonLoggedHours() func(int) int</strong>. Each time this function is called, it will calculate the hours of the employee that have not been logged. You will be using a closure inside <span class="No-Break">the function.</span></li>
				<li>Create a method called <strong class="source-inline">PayDay()(int,bool)</strong>. This method will calculate the weekly pay. It needs to consider overtime pay. The method will pay twice the hourly rate for hours greater than 40. The function will return <strong class="source-inline">int</strong> as the weekly pay and <strong class="source-inline">bool</strong> if the pay is overtime pay. The Boolean value will be true if the employee worked more than <strong class="source-inline">40</strong> hours and false if they worked less than <span class="No-Break"><strong class="source-inline">40</strong></span><span class="No-Break"> hours.</span></li>
				<li>Create a method called <strong class="source-inline">PayDetails()</strong>. This method will print each day and the hours worked that day by the employee. It will print the total hours for the week, the pay for the week, and if the pay contains <span class="No-Break">overtime pay.</span></li>
				<li>Inside the <strong class="source-inline">main</strong> function, initialize a variable of the <strong class="source-inline">Developer</strong> type. Assign a variable to <strong class="source-inline">nonLoggedHours</strong>. Print the variable that was assigned to <strong class="source-inline">nonLoggedHours</strong> with values of <strong class="source-inline">2</strong>, <strong class="source-inline">3</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">5</strong></span><span class="No-Break">.</span></li>
				<li>Also, in the <strong class="source-inline">main()</strong> function, log the hours for the following days: Monday 8, Tuesday 10, Wednesday 10, Thursday 10, Friday 6, and <span class="No-Break">Saturday 8.</span></li>
				<li><a id="_idTextAnchor1202"/>Finally, run the <span class="No-Break"><strong class="source-inline">PayDetails()</strong></span><span class="No-Break"> method.</span></li>
			</ol>
			<p>The following is the <span class="No-Break">expected output:</span></p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B18621_05_12.jpg" alt="Figure 5.12: Output for the payable amount activity" width="831" height="577"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12: Output for the payable amount activity</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found in the GitHub repository folder for this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05/Activity05.02"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05/Activity05.02</span></a><span class="No-Break">.</span></p>
			<p>This activity aims to go a step further than <em class="italic">Activity 5.01 – calculating the working hours of employees</em>, by using some more advanced programming with Go’s functions. In this activity, we continued to use functions, as we did previously; however, we returned multiple values and<a id="_idIndexMarker474"/> returned a function from a function. We also demonstrated the use of closures for calculating hours not logged by <span class="No-Break">an employee.</span></p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor1203"/>Separating similar code</h1>
			<p>So far, we have covered a lot regarding functions since they are a vital aspect of what makes Go successful and flexible as<a id="_idIndexMarker475"/> a language. To continue with the idea of making flexible code for others to understand, iterate on, and work with, we will discuss how to expand <span class="No-Break">this mentality.</span></p>
			<p>In the world of software development, organizing code effectively is crucial for creating maintainable and scalable applications. In Go programming, one approach to achieving code organization is by separating related functions into different directories and utilizing <span class="No-Break">multiple packages.</span></p>
			<p>Thus far, we have been working with just one file to understand the fundamentals of Go. However, there is life beyond just a <strong class="source-inline">main.go</strong> file. We will briefly discuss ways Go developers keep in mind the reusability and cleanliness of their code, beyond the scope of functions. However, we will keep things at a high level at this point as we dive into the details of this when we cover <span class="No-Break">Go modules.</span></p>
			<p>A well-structured directory layout enhances code readability and maintainability. It allows developers to locate and work with specific functionality quickly. In Go, it is common to group related functions into separate directories based on their purpose, context, or domain. By organizing code into feature-based or domain-specific directories, developers can easily identify and modify code pertaining to a particular functionality. This separation fosters modularity and makes it easier to understand the <span class="No-Break">application’s architecture.</span></p>
			<p>As projects grow in size and complexity, splitting code into functions and purposeful directories becomes essential for managing dependencies and reducing cognitive load. Large applications often benefit from a directory structure that aligns with the project’s modules or components. There <a id="_idIndexMarker476"/>are many benefits as to why you, as a developer, should care about separating your Go code into <span class="No-Break">logical chunks:</span></p>
			<ul>
				<li>Enhanced <span class="No-Break">code reusability</span></li>
				<li>Improved readability <span class="No-Break">and maintainability</span></li>
				<li>Testability <span class="No-Break">and isolation</span></li>
			</ul>
			<p>A concrete example of this can be seen in the <span class="No-Break">following example:</span></p>
			<ol>
				<li>Use the IDE of <span class="No-Break">your choice.</span></li>
				<li>Create a new file i<a id="_idTextAnchor1204"/><a id="_idTextAnchor1205"/>n a new directory and save it <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></li>
				<li>Enter the following code <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">:</span><pre class="source-code">
package main
import "fmt"
func main() {
calculateSalary()
playGame()
    getWeather()
}
func calculateSalary() {
    // do stuff
}
func playGame() {
    // do stuff
}
func g<a id="_idTextAnchor1206"/>etWeather() {
    // do stuff
}</pre></li>			</ol>
			<p>The <strong class="source-inline">calculateSalary</strong>, <strong class="source-inline">playGame</strong>, and <strong class="source-inline">getWeather</strong> functions are independent of each other, each can contain complex logic, and they may rely on different, <span class="No-Break">unrelated dependencies.</span></p>
			<p>Placing the unrelated functions, and even withholding their actual logic, makes the code file bloated; it can become messy and unmanageable as you continue to iterate on the code and add logic. It could <a id="_idIndexMarker477"/>make sense to separate the three functions into their own files, such as <strong class="source-inline">salary.go</strong>, <strong class="source-inline">game.go</strong>, and <strong class="source-inline">weather.go</strong>. Eventually, you could separate them into different directories, and so forth, as <span class="No-Break">you go.</span></p>
			<p>It is important to start small, and then think about how you can separate similar code to continue writing manageable Go code that others can easily understand and iterate on. Again, this idea of code separation will be discussed in more detail when we <a id="_idTextAnchor1207"/><a id="_idTextAnchor1208"/>cover Go modules since that is a vital way Go enables simple and <span class="No-Break">reusable code.</span></p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor1209"/>Summary</h1>
			<p>In this chapter, we studied why and how functions are an essential part of the Go programming language. We also discussed various features of functions in Go that make Go stand apart from other programming languages. Go has features that allow us to solve a lot of real-world problems and do so in a small, iterable, and manageable way. Functions in Go serve many purposes, including enhancing the usage and readability <span class="No-Break">of code.</span></p>
			<p>Next, we learned how to create and call functions. We studied the various types of functions that are used in Go and discussed scenarios where each of the function types can be used. We also expounded on the concept of closures. Closures are essentially a type of anonymous function that can use variables declared at the same level as that at which the anonymous function was declared. Then, we discussed various parameters and return types and studied <strong class="source-inline">defer</strong>. We also discussed how to keep your code clean and separated such that similar logic can be packaged up nicely together. This mentality of thinking about how to reduce, reuse, and recycle your code will enable you to become a <span class="No-Break">better developer.</span></p>
			<p>In the next chapter, we’ll explore errors and error types and learn how to build custom errors, thus building a recovery mechanism to handle errors <span class="No-Break">in Go.</span></p>
		</div>
	</div></div></body></html>