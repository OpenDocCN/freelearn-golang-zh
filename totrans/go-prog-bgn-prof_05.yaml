- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions – Reduce, Reuse, and Recycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will describe the various ways in which you can reduce, reuse,
    and recycle code. It will include a large overview of functions so that you can
    include parts of a function, such as defining the function, function identifiers,
    parameter lists, return types, and the function body. We will also look at best
    practices when designing code so that you can make it reusable and flexible and
    make your functional logic small and purposeful.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to see how easy Go makes it to
    reduce, reuse, and recycle code. This will include how to describe a function
    and the different parts that make up a function and evaluate the scope of variables
    with functions. You will know how to create and call a function, as well as how
    to utilize variadic and anonymous functions and create closures for various constructs.
    You will also know how to use functions as parameters and return values and how
    to use `defer` statements with functions. Finally, you will know how to separate
    similar functionality into logical sections by using multiple files and directories
    in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need to install the Go programming language. This
    chapter’s code can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to write code in a way that is easy to maintain and iterate on is
    a vital skill for an engineer. This means crafting it so that it may be reused,
    easily expanded upon, and understood by others. Go makes it easy to keep code
    clean and readable, and separate logical chunks together. The first major way
    of writing code that is easy to reduce, reuse, and recycle is through the use
    of functions.
  prefs: []
  type: TYPE_NORMAL
- en: Functions are a core part of many languages and Go is no exception. A function
    is a section of code that has been declared to perform a task. Go functions can
    have zero or more inputs and outputs. One feature that sets Go apart from other
    programming languages is the multiple return values; most programming languages
    are limited to one return value. This leads into Go’s flexibility and the ability
    for developers to continuously write adaptable code.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will see some features of Go functions that differ
    from other languages, such as returning multiple types. We will also see that
    Go has support for first-class functions. This means that Go can assign a variable
    to a function, pass a function as an argument, and have a function as a return
    type for a function. We will show how functions can be used to break up complex
    parts into smaller parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions in Go are considered first-class citizens and higher-order functions.
    First-class citizens are the functions that are assigned to a variable. Higher-order
    functions are functions that can take a function as an argument. The rich features
    of Go functions empower them to be used in various segments in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: To pass a function as an argument to another function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To return a function as a value from a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use functions as a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use functions as closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use anonymous functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To assign functions to a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be looking at each of these features since they are all supported in
    Go.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are a critical part of Go and we should understand their place. Let’s
    examine some of the reasons for using functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breaking up a complex task**: Functions are used to perform a task, but if
    that task is complicated, it should be broken down into smaller tasks. Functions
    can be used for small tasks to solve a bigger problem. Smaller tasks are more
    manageable, and using a function to solve specific tasks will make the entire
    code base easier to maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reducing code**: A good indication that you should use a function is when
    you see similar code repeating throughout your program. When you have duplicate
    code, it increases the difficulty of maintenance. If you have one change to make,
    you will have multiple instances where your code needs to change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability**: Once you have defined your function, you can use it repeatedly.
    It can also be used by other programmers. This sharing of functions will reduce
    lines of code and save time by allowing you to not have to reinvent the wheel.
    There are a couple of guidelines we should follow when we design functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single responsibility**: A function should perform one task. For example,
    a single function should not calculate the distance between two points and estimate
    the time to travel between those two points. There should be a function for each
    of those tasks. This allows for better testing of that function and easier maintenance.
    It is difficult to narrow a function to perform a single task, so do not get discouraged
    if you do not get it right the first time. Even seasoned programmers struggle
    with assigning a single responsibility to a function, and responsibilities can
    shift over time.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Small in size**: Functions should not span over hundreds of lines of code.
    This is an indication that the code needs some refactoring. When we have large
    functions, it’s more likely that the single responsibility principle will be violated.
    A good rule of thumb is trying to limit the function size to approximately 25
    lines of code; however, that’s not a hard-and-fast rule. The benefit of keeping
    the code concise is that it reduces the complexity of debugging a large function.
    It also makes writing unit tests with better code coverage easier.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Parts of a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at the different components that are involved in defining a function.
    The following is the typical layout of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Different parts of a function](img/B18621_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Different parts of a function'
  prefs: []
  type: TYPE_NORMAL
- en: 'The different parts of a function are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func`: In Go, the function declaration starts with the `func` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateTax`, `totalSum`, and `fetchId`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The identifier should be something descriptive that makes the code easy to read
    and makes the purpose of the function easy to understand. The identifier is not
    required. You can have a function with no name; this is known as an anonymous
    function. Anonymous functions will be discussed in detail later in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When the first letter of the function name is in lowercase, then the function
    can’t be exported outside of a package. This means it’s private and cannot be
    called from outside the package. It can only be called within the package.
  prefs: []
  type: TYPE_NORMAL
- en: Keep this in mind when you use the camelCase naming convention. If you want
    your function to be exportable, the first letter of the function name must be
    capitalized. This will mean other packages can consume and use your function if
    it is exported and starts with a capital letter.
  prefs: []
  type: TYPE_NORMAL
- en: '`name string`, `age int`). Parameters are local variables of the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters are optional for a function. It is possible to not have any parameters
    for a function. A function can have zero or more parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When two or more parameters have the same type, you can use what is called shorthand
    parameter notation. This removes specifying the same type for each parameter.
    For instance, if your parameters are (`firstName string`, `lastName string`),
    they can be shortened to (`firstName`, `lastName string`). This reduces the verbosity
    of the parameter inputs and increases the readability of the function parameter
    list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Return types**: Return types are a list of data types, such as Boolean, string,
    map, or another function that can be returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the context of declaring a function, we refer to these types as return types.
    However, in the context of calling a function, they are called return values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Return types are the output of the function. Often, they are the result of the
    arguments provided to the function. They are optional. Most programming languages
    return a single type; in Go, you can return multiple types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`{}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The statements in the function are what determine what the function does. The
    function code is the code that is being used to perform the task that the function
    was created to accomplish.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If return types were defined, then a `return` statement is required in the function
    body. The `return` statement causes the function to immediately stop and return
    the value types listed after the `return` statement. The types in the return type
    list and the `return` statement must match.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the function body, there can be multiple `return` statements. You often see
    this in the case of errors, where you might return different values than, say
    if the function processed logic successfully.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Function signature**: Though not listed in the preceding code snippet, a
    function signature is a term that references the input parameters combined with
    the return types. Both of those units make up a function signature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, when you define the function signature when it is being used by others,
    you want to strive to not make changes to it as this can adversely impact your
    code and the code of others.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will be diving deep into each of the parts of a function as we progress through
    this chapter. These parts of a function will become easier to understand through
    the following discussion and will become clearer as we go through this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The checkNumbers function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have looked at the different parts of the function, let’s see how
    these parts work with various examples. Let’s start with a simple approach with
    a `checkNumbers` function. The `checkNumbers` function prints out various messages
    based on some math results of whether a number is even or odd. The rules perform
    one of the actions based on the number given:'
  prefs: []
  type: TYPE_NORMAL
- en: If the number is `even`, print `Even`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the number is `odd`, print `Odd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the code snippet to achieve this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the code in sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`func`, as you may recall, is the keyword to declare a function. This informs
    Go that the following piece of code is going to be a function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkNumbers` is the name of our function. It is idiomatic (standard practice)
    in Go to use a camelCase name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`()`, the parenthesis following the name of our function, is empty: our current
    implementation of the `checkNumbers` game does not require any input parameters.
    If it *did* require input parameters, they would be contained within parentheses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The space between the parameter list, `()`, and the opening brace would be the
    return type. Our current implementation does not require a return type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regarding `{`, unlike other programming languages that you may know, Go requires
    that the opening curly brace is on the same line as the function declaration.
    If the opening brace is not on the same line as the function signature when you
    attempt to run the program, you will get an error:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding line is a `for` loop that increments the `i` variable from `1`
    to `30`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`%` is a modulus operator; it gives the remainder of the two integers being
    divided. Using our function, if `i` is evenly divisible by `2`, then it will print
    out the word `"Even"`; otherwise, it will print “`Odd"`.'
  prefs: []
  type: TYPE_NORMAL
- en: As we become more familiar with Go concepts and language syntax, the explanation
    of the code will exclude items that we would otherwise be going over multiple
    times.
  prefs: []
  type: TYPE_NORMAL
- en: We have now defined our function. It has a specific task we want it to perform,
    but it doesn’t do any good if we do not execute the function. So, how do we execute
    a function? We must call our function. When we call a function, we are telling
    our program to execute the function. We will be calling our function inside the
    `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions can call other functions. When this occurs, control is given to the
    function that was called. After the called function has returned data or reached
    the ending curly brace, `}`, control is given back to the caller. Let’s look at
    an example to understand this better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`fmt.Println("Main is in control")`: This `print` statement is for demonstration
    purposes. It shows that we are in the `main()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkNumbers()`: We are now calling the function inside the `main()` function.
    Even though there are no parameters for our function, the parentheses are still
    required, and control of the program is given to the `checkNumbers()` function.
    After the `checkNumbers()` function completes, control is then given back to the
    `main()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fmt.Println("Back to main")`: The `print` statement is for demonstration purposes
    to show that control has been given back to the `main()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: Output for checkNumbers](img/B18621_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: Output for checkNumbers'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The parentheses following the `checkNumbers` function are still required, even
    though there are no input parameters. If they are omitted, the Go compiler will
    generate an error that states `checkNumbers` was evaluated but not used. This
    is a common error.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.01 – creating a function to print salesperson expectation ratings
    from the number of items sold
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will be creating a function that will not have any parameters
    or return types. The function will iterate over a map and print the name and number
    of items sold on the map. It will also print a statement based on how the salesperson
    performed based on their sales. The following steps will help you with the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file and save it as `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`. The first function that `main` will
    call is `itemsSold()`; it does not have any parameters and has no return values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll define our function for logic regarding items sold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `itemsSold()` function, initialize a map that will have a key-value
    pair of `string`, `int`. The map will hold a `name`(`string`) and the number of
    `items`(`int`) sold by the individual. The name is the key for the map. We assign
    various names to number of items sold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We iterate over the `items` map and assign `k` to `key(name)` and `v` to `value(items)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We print out `Name` and the number of sold `items`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Depending on the value of `v`(`items`), we will determine the statement we
    print:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open your terminal and navigate to the code’s directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and then run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we saw some of the fundamental parts of a function. We demonstrated
    how to declare a function using the `func` keyword, followed by how to give our
    function an identifier or name, such as `itemsSold()`. Then, we added code to
    the function body. In the next few sections, we will expand on these core parts
    of the function and learn how to pass data into a function using parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is best to type the code into an IDE. The benefit is that if you type something
    incorrectly, you will see the error message and can perform some debugging to
    solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Parameters define what arguments can be passed to our function. Functions can
    have zero or more parameters. Even though Go allows us to define multiple parameters,
    we should take care not to have a huge parameter list; that would make the code
    harder to read. It may also be an indication that the function is doing more than
    one specific task. If that is the case, we should refactor the function. Take,
    for example, the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is an example of a function whose parameter list is bloated.
    The parameter list should pertain only to the single responsibility of the function.
    We should only define the parameters that are needed to solve the specific problem
    that the function is built for.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters are the input types that our function will use to perform its task.
    Function parameters are local to the function, meaning they are only available
    to that function. They are not available outside of the context of the function.
    Also, the order of the parameters must match the parameter types in the correct
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Correct**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output when the correct parameter matches would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Incorrect**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: Output for incorrect parameter matching](img/B18621_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Output for incorrect parameter matching'
  prefs: []
  type: TYPE_NORMAL
- en: In the incorrect version of the code, we are calling the `greeting()` function
    with the `age` argument, which is of the `integer` type, when the parameter is
    of the `string` type. The sequence of your arguments must match the sequence of
    the parameter input list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, users would want to have more control over the data the code
    iterates over. Going back to the `checkNumbers` example, the current implementation
    only does `1` to `30`. Users may need to work on different number ranges, so we
    need a way to decide the ending range of the loop. We can change our `checkNumbers`
    function so that it accepts an input parameter. This would meet the needs of our
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For `checkNumbers(10)` in the `main()` function, we pass `10` as an argument
    to our `checkNumbers` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `checkNumbers(end int)`, `end` is the name of our parameter and it is of
    the `int` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, our function will only iterate up to the value of our end parameter; in
    this example, it will iterate to `10`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between an argument and a parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a good time to discuss the difference between an argument and a parameter.
    When you are defining your function, using our example, `checkNumbers(end int)`
    is called a parameter. When you call a function, such as `checkNumbers(10)`, `10`
    is called the argument. Also, the argument and parameter names do not need to
    match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions in Go can also have more than one parameter defined. We need to add
    another parameter to our `checkNumbers` function to accommodate this enhancement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Regarding `checkNumbers(start, end)`, we are now passing two arguments to the
    `checkNumbers` function. When there are multiple arguments, they must be separated
    by a comma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding `func checkNumbers(start int, end int)`, when multiple parameters
    are defined in a function, they are separated by commas, following the convention
    of name type, name type, name type, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `checkNumbers` parameters are more verbose than what is necessary. When
    we have multiple input parameters of the same type, we can separate the input
    name by a comma followed by the type. This is referred to as shorthand parameter
    notation. See the following example of using shorthand parameter notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no change to the caller when using shorthand parameter notation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding `checkNumbers(start, end int)`, `start` and `end` are of the `int`
    type. Nothing needs to change in the body of the function to accommodate the shorthand
    parameter notation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise 5.02 – mapping index values to column headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function that we are going to create will be taking a slice of column headers
    from a CSV file. It will print out a map of an index value of the headers we are
    interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file and save it as `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we assign a variable to a key-value pair of `int` and `string`. `key(int)`
    will be the index of our `header(string)` column. The index will map to a column
    header.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We range over `header` to process each string that is in the slice. In the
    following `for` loop, `i` will store the index, and `v` will be assigned to each
    value in the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each string, remove any trailing spaces in front of and after the string.
    In general, we should always assume that our data may have some erroneous characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our `switch` statement, we lower all the casing for exact matches. As you
    may recall, Go is a case-sensitive language. We need to ensure that the casing
    is the same for matching purposes. When our code finds the header, it sets the
    index value for the header in the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Typically, we would not print out the results. We should return `csvHeadersToColumnIndex`,
    but since we have not gone over how to return a value, we will print it for now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open your terminal and navigate to the code’s directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this exercise, we saw how to accept data into a function: by defining a
    parameter for our function. The callers of our function were able to pass arguments
    to the function. We will continue to discover various abilities that functions
    in Go can provide. So far, we have seen how to get data into our function. In
    the next section, we will see how to get data out of our function.'
  prefs: []
  type: TYPE_NORMAL
- en: Function variable scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When designing functions, we need to consider the variable scope. The scope
    of a variable determines where the variable is accessible or visible to the different
    parts of the application. Variables declared inside the function are considered
    local variables. This means that they are only accessible to the code within the
    body of the function. You cannot access variables from outside of the function.
    The calling function does not have access to variables inside the called function.
    The input parameter’s scope is the same as the local variable’s scope to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables declared in the calling function are scoped to that function. This
    means that the variables are local to the function and those variables are not
    accessible outside of the function. Our function cannot reach into the calling
    function’s variables. To gain access to those variables, they must be passed into
    our function as input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Error output for the m variable being undefined](img/B18621_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Error output for the m variable being undefined'
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code snippet will result in an error in `func greeting()` that
    states that `m` is undefined. That is because the `m` variable is declared inside
    `main()`. The `greeting()` function does not have access to the `m` variable.
    For it to have access, the `m` variable must be passed to the `greeting()` function
    as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: Error output for the s variable being undefined](img/B18621_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Error output for the s variable being undefined'
  prefs: []
  type: TYPE_NORMAL
- en: The previous code snippet will result in an error in `func main()`. The error
    will state that `s` is undefined. This is because the `s` variable is declared
    in the `greeting()` function. The `main()` function does not have access to the
    `s` variable. The `s` variable is only visible to code inside the function body
    of `greeting()`.
  prefs: []
  type: TYPE_NORMAL
- en: These are just some considerations that we need to keep in mind when we are
    declaring and accessing variables. It is important to understand the scope of
    the variables inside a function concerning the variables declared outside of a
    function. It can cause some confusion when you are trying to access variables
    but you are not scoped to the context that you are trying to access. The examples
    in this chapter should help you in understanding the scope of variables.
  prefs: []
  type: TYPE_NORMAL
- en: Return values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, the functions that we have created do not have any return values. Functions
    typically accept inputs, perform some action on those inputs, and then return
    the results of those actions. Functions in some programming languages return only
    one value. Go allows you to return multiple values from a function. This is one
    of the features of Go functions that distinguishes it from other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.03 – creating a checkNumbers function with return values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to make some enhancements to our `checkNumbers`
    function. We are going to change it so that it accepts only an integer. We will
    leave the onus on the caller to perform the looping if they desire to do so. Also,
    we are going to have two returns. The first will be the number provided and the
    corresponding text indicating if the number is `Even` or `Odd`. The following
    steps will help you with the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file in a different directory and save it as `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `main()` function, assign variables to the return values of our function.
    The `n,` and `s` variables correspond to the values being returned from our function,
    which are `int` and `string`, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `checkNumbers` function now returns two values; the first being an `int`
    value, followed by a `string` value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Simplify the `if{}else{}` statements by replacing them with `switch` statements.
    As you are writing code, you should look for ways to simplify things and make
    the code more readable. `case i%2 ==0` is equivalent to our previous `if i%2 ==
    0` statements. Instead of our previous `fmt.Println()` statements, replace them
    with `return`. The `return` statement will immediately stop the execution of the
    function and return the results to the caller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The expected output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.6: Output for the checkNumbers function with return values](img/B18621_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Output for the checkNumbers function with return values'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw how we can return multiple values from a function.
    We were able to assign variables to the multiple return values from the function.
    We also noticed that the variables that were assigned to the function matched
    the order of the return values. In the following section, we will learn that in
    the body of the function, we can perform naked returns, where we do not need to
    specify the variable being returned in our return statement.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw a switch statement that was used to clean up the `if{}else{}` logic.
    We had a case for even numbers and a `default` “catch-all” case where odd numbers
    would fall. The `default` case is just as it sounds and will be the default case
    if a case is not before it.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 5.01 – calculating the working hours of employees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we’ll be creating a function that will calculate the working
    hours of employees for a week. Then, we’ll use this to calculate the payable salary
    amount. The `developer` struct has a field called `Individual` that is of the
    `Employee` type. The `developer` struct keeps track of the `HourlyRate` value
    that they charge and how many hours they work each day. The following steps will
    help you to reach the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `Employee` type that has the following fields: `Id` as `int`, `FirstName`
    as `string`, and `LastName` as `string`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `developer` type that has the following fields: `Individual` as `Employee`,
    `HourlyRate` as `int`, and `WorkWeek` as `[7]int`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `enum` type (enums are types that contain only a limited number of
    fixed values) for the seven days of the week. This will be of the `Weekday` `int`
    type with a constant declaration for each day of the week.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a pointer receiver method called `LogHours` for `Developer` that will
    take the `WeekDay` type and `int` type as input. Assign the hours worked that
    day to the `Developer` workweek slice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method that is a pointer receiver called `HoursWorked()`. This method
    will return the total hours that have been worked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main()` function, initialize and create a variable of the `Developer`
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `LogHours` method, call the method for two days (such as Monday and Tuesday).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the hours for the two days of the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, print the results of the `HoursWorked` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05/Activity05.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05/Activity05.01)'
  prefs: []
  type: TYPE_NORMAL
- en: This activity aims to demonstrate the ability to break problems down into manageable
    tasks to be implemented by functions, such that each of our functions has a single
    responsibility. `LogHours` is responsible for assigning the hours worked for each
    day. `HoursWorked` uses the values that were assigned in `LogHours` to display
    the hours worked each day. We used return types from our functions to display
    the data. This exercise demonstrates utilizing functions correctly to provide
    a solution to a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Naked returns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Functions that have return values must have a return statement as the last statement
    in the function. If you omit the return statement, the Go compiler will give you
    an error stating “missing return at the end of the function.”
  prefs: []
  type: TYPE_NORMAL
- en: Typically, when a function returns two types, the second type is an `error`.
    We have not gone over errors yet, so we won’t be demonstrating them in these examples.
    It is good to know that, in Go, it is idiomatic for the second return type to
    be of the `error` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go also allows you to ignore a variable being returned. For example, say we
    are not interested in the `int` value that is being returned from our `checkNumbers`
    function. In Go, we can use what is called a blank identifier, which allows us
    to ignore values in an assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, when reading a file, we might not be concerned about the number
    of bytes read. So, in that case, we can ignore the value being returned by using
    the blank identifier, `_`. When extra data is being returned from a function that
    does not provide any information that is needed by our program, such as the reading
    of a file, it is a good candidate for ignoring the return:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As you will discover later, many functions return an error as the second return
    value. You should not ignore return values from functions that are errors. Ignoring
    an error returned by a function could result in unexpected behavior. Error return
    values should be handled appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we used the blank identifier, `_`, to ignore the
    `int` value being returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You must always have a placeholder for the values being returned when assigning
    values from a function. When performing an assignment, the placeholders must match
    the number of return values from the function. `_` and `result` are the placeholders
    for the return values of `int` and `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go also has a feature that allows you to name your returns. If you use this
    feature, it can make your code more readable, as well as self-documenting. If
    you name your return variables, they are under the same constraints as the local
    variables, as discussed in the previous section. By naming your returns, you are
    creating local variables in the function. You can then assign values to those
    return variables, just as you do with input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `(name string, age int)` are named returns. They are
    now local variables to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `name` and `age` are local variables that were declared in the return
    list of the function, you can now assign values to them. They can be treated as
    local variables. In the `return` statement, specify the return values. If you
    do not specify the variable name in the return, it is called a *naked return*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Consider the preceding code block. This code is the same as before with the
    exception that the return value does not name the variables to return. The `return`
    statement will return the variables that are named in the return list.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the disadvantages of naked returns is that it can cause confusion when
    reading code. To avoid confusion and the possibility of other issues, it is recommended
    that you avoid using the naked returns feature as it can make it difficult to
    follow the variable that is to be returned. There can also be issues with shadowing
    when using naked returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will result in the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: Output of shadowing with naked returns](img/B18621_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: Output of shadowing with naked returns'
  prefs: []
  type: TYPE_NORMAL
- en: This is because the `err` variable is named in `return` and is initialized in
    an `if` statement. Recall that variables that are initialized within curly braces,
    such as `for` loops, `if` statements, and `switch` statements, are scoped to that
    context, meaning that they are only visible and accessible within those curly
    braces.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.04 – mapping a CSV index to a column header with return values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Exercise 5.02 – mapping index values to column headers*, we only printed
    the results of the index to the column header. In this exercise, we are going
    to return the map as the result. The map that’s being returned is the index-to-column
    header mapping. The following steps will help you with the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file from the previous column header exercise called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, in the `main()` function, define the headers for the columns. First,
    we will assign a variable to a key-value pair of `int` and `string`. `key(int)`
    will be the index of our `header(string)` column. The index will map to a column
    header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use `range` over `header` to process each string that is in the slice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each string, we remove any trailing spaces in front of and after the string.
    In general, we should always assume that our data may have some erroneous characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our `switch` statement, we lower all the casing for exact matches. As you
    may recall, Go is a case-sensitive language. We need to ensure the casing is the
    same for matching purposes. When our code finds the header, it sets the index
    value for the header in the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open a terminal and navigate to the code’s directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output for return values is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we saw a real-world example of mapping a CSV index to column
    headers. We used a function to solve this complex problem. We were able to have
    the function have a single return value of the `map` type. In the next section,
    we are going to see how functions can accept a variable number of argument values
    within a single argument.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A variadic function is a function that accepts a variable number of argument
    values. It is good to use a variadic function when the number of arguments of
    a specified type is unknown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function is an example of what a variadic function looks like.
    The three dots (`…`) in front of the type are called a *pack operator*. The pack
    operator is what makes it a variadic function. It tells Go to store all the arguments
    of `Type` in `parameterName`. The variadic variable can accept zero or more variables
    as the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `nums` function is a variadic function that accepts an `int` type. As stated
    previously, you can pass zero or more arguments of the type. If there is more
    than one value, you separate them with a comma, as in `nums(99, 100)`. If there
    is only one argument to pass, you only pass that argument, as in `nums(200)`.
    If there isn’t an argument to pass, you can leave it empty, as in `nums()`.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic functions can have other parameters. However, if your function requires
    multiple parameters, the variadic parameter must be the last in the function.
    Also, there can only be one variadic variable per function. The following function
    is incorrect and will result in an error at compile time as the variadic variable
    is not the last parameter of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Incorrect function**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: Variadic syntax error output](img/B18621_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: Variadic syntax error output'
  prefs: []
  type: TYPE_NORMAL
- en: '**Correct function**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have guessed by now that the actual type of `Type` inside the function
    is a slice. The function takes the arguments being passed in and converts them
    into the new slice being specified. For example, if the variadic type is `int`,
    then once you are inside the function, Go converts that variadic `int` type into
    a slice of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: Converting a variadic int into a slice of integers](img/B18621_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: Converting a variadic int into a slice of integers'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make some tweaks to this example by having the `variadic` function take
    in integer values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The variadic function’s output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nums()` function shows that the variadic type of `i` is a slice of integers.
    Once in the function, `i` will be a slice of integers. The variadic type has a
    length and capacity, which is to be expected for a slice. In the following code
    snippet, we will try to pass a slice of integers to a variadic function, `nums()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: Variadic function error](img/B18621_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: Variadic function error'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why didn’t this code snippet work? We just proved that the variadic variable
    inside the function is of the `slice` type. The reason is that the function expects
    a list of arguments of the `int` type to be converted into a slice. Variadic functions
    work by converting the arguments that are passed into a slice of the type being
    specified. However, Go has a mechanism for passing a slice to a variadic function.
    For this, we need to use the unpack operator; it is three dots (`…`). When you
    call a variadic function and you want to pass a slice as an argument to a variadic
    parameter, you need to place the three dots before the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The difference between this version of the function and the previous is the
    calling code to the function, `nums`. The three dots that are put after the `i`
    variable are a slice of integers. This allows a slice to be passed to the variadic
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 5.05 – summing numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to sum up a variable number of arguments. We
    will pass the arguments as a list of arguments and as a slice. The return value
    will be an `int` type – that is, the sum of the values we passed to the function.
    The following steps will help you with the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file in a new directory and save it as `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `sum` function accepts a variadic argument of the `int` type. Since it
    gets converted into a slice, we can range over the values and return the sum of
    all the values that get passed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open a terminal and navigate to the code’s directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output for summing numbers is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we saw that by using a variadic parameter, we can accept an
    unknown number of arguments. Our function allows us to sum up any number of integers.
    We can see that variadic parameters can be utilized to solve specific problems
    where the number of values of the same type being passed as an argument is unknown.
    In the next section, we are going to look at how to create a function without
    a name and assign a function to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have been using named functions. As you may recall, named functions
    are functions that have an identifier or a function name. Anonymous functions,
    also referred to as function literals, are functions that do not have a function
    name, hence the name “anonymous functions.” An anonymous function is declared
    in a similar way to how a named function is declared. The only difference with
    the declaration is that the name for the function is omitted. Anonymous functions
    can do whatever a normal function in Go does, including accepting arguments and
    returning values. Anonymous functions can also be declared within another function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will be introducing the fundamentals of anonymous functions
    and some of their basic uses. Later, you will see how anonymous functions can
    be fully utilized. Anonymous functions are used for (and in conjunction with)
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Closure implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defer` statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a code block to be used with a goroutine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a function for one-time use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a function to another function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a basic declaration for an anonymous function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are declaring a function inside another function. As with named
    functions, you must start with the `func` keyword to declare a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the `func` keyword would normally be the name of the function, but
    with anonymous functions, there is no function name. Instead, there are empty
    parentheses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The empty parentheses following the `func` keyword are where the function’s
    parameters would be defined for the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is the open curly brace, `{`, which starts the function body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function body is only a one-liner; it will print “`Greeting`”.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The closing curly brace, `}`, denotes the end of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last set of parentheses is called the execution parentheses. These parentheses
    invoke the anonymous function. The function will execute immediately. Later, we
    will see how to execute an anonymous function at a later location within the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also pass arguments to an anonymous function. To be able to pass arguments
    to an anonymous function, they must be supplied in the execution parentheses:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func (str string)`: The anonymous function being declared has an input parameter
    of the `string` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`} (message)`: The argument message that’s being passed to the execution parentheses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have been executing anonymous functions as they are declared, but there
    are other ways to execute anonymous functions. You can also save the anonymous
    function to a variable. This leads to a different set of opportunities that we
    will look at in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: We are assigning the `f` variable to our anonymous function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` is now of the `func()` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` can now be used to invoke the anonymous function, in a fashion similar
    to that for a named function. You must include `()` after the `f` variable to
    execute the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise 5.06 – creating an anonymous function to calculate the square root
    of a number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Anonymous functions are great for small snippets of code that you want to execute
    within a function. Here, we are going to create an anonymous function that is
    going to have an argument passed to it. It will then calculate the square root.
    The following steps will help you with the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file and save it as `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`. We are assigning our `x` variable to
    our anonymous function. Our anonymous function takes a parameter, `(i int)`. It
    also returns a value of `int`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that the last curly brace does not have `()` to execute the function.
    We call our anonymous function using `x(j)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open a terminal and navigate to the code’s directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we saw how to assign a variable to a function and later call
    that function by using the variable that was assigned to it. We saw that when
    we need a small function that might not be reusable in our program, we can create
    an anonymous function and assign it to a variable. In the next section, we are
    going to expand the use of anonymous functions to closures.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have introduced anonymous function syntax using some basic examples.
    Now that we have a fundamental understanding of how anonymous functions work,
    we will look at how we can use this powerful concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'Closures are a form of anonymous functions. Regular functions cannot reference
    variables outside of themselves; however, an anonymous function can reference
    variables external to their definition. A closure can use variables declared at
    the same level as the anonymous function’s declaration. These variables do not
    need to be passed as parameters. The anonymous function has access to these variables
    when it is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '**Code synopsis**:'
  prefs: []
  type: TYPE_NORMAL
- en: We initialize a variable in the `main()` function called `i` and set it to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We assign `incrementor` to our anonymous function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The anonymous function increments `i` and returns it. Notice that our function
    does not have any input parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we print the results of `incrementor` twice and get `1` and `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that, outside our function, we increment `i` by `10`. This is a problem.
    We want `i` to be isolated and for it not to change as this is not the desired
    behavior. When we print the results of `incrementor` again, it will be `12`. We
    want it to be `3`. We will correct this in our next example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One problem with the previous example that we noticed is that any code in the
    main function has access to `i`. As we saw in the example, `i` can be accessed
    and changed outside of our function. This is not the desired behavior; we want
    the incrementor to be the only one to change that value. In other words, we want
    `i` to be protected from other functions changing it. The only function that should
    be changing is our anonymous function when we call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '**Code synopsis**:'
  prefs: []
  type: TYPE_NORMAL
- en: We declared a function called `incrementor()`. This function has a return type
    of `func() int`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `i := 0`, we initialize our variable at the level of the `incrementor()`
    function; this is similar to what we did in the previous example, except it was
    at the `main()` function level and anyone at that level had access to `i`. Only
    the `incrementor()` function has access to the `i` variable with this implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are returning our anonymous function, `func() int`, which increments the
    `i` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main()` function, `increment := incrementor()` assigns a variable to
    `func() int` that gets returned. It is important to note that `incrementor()`
    only gets executed once here. In our `main()` function, it is no longer being
    referenced or executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`increment()` is of the `func() int` type. Each call to `increment()` runs
    the anonymous function code. It is referencing the `i` variable, even after `incrementor()`
    has been executed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The preceding example demonstrated how we can protect our variable by wrapping
    it with an anonymous function, thereby restricting access to updating the variable
    only through invoking the anonymous function itself. This is shown through the
    expected output, where we’ve incremented `i` twice, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 5.07 – creating a closure function to decrement a counter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to create a closure that decrements from a given
    starting value. We will combine what we have learned about passing an argument
    to an anonymous function and use that knowledge with a closure. The following
    steps will help you with the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file in a new directory and save it as `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will look at the `decrement` function first. It takes an argument of the
    `int` type and has a return value of `func()int`. In previous examples, the variable
    was declared inside the function but before the anonymous function. In this exercise,
    we have it as an input parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We decrement `i` by one inside the anonymous function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, we initialize a variable counter to be used as our
    starting integer to be decremented:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we have `x:= decrement(counter)`; `x` is assigned to `func() int`. Each
    call to `x()` runs the anonymous function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open a terminal and navigate to the code’s directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output for the `decrement` counter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we saw that closures have access to variables that are external
    to them. This allowed our anonymous function to make changes to the variable that
    a normal function would not be able to make. In the next section, we are going
    to look at how functions can be passed as arguments to another function.
  prefs: []
  type: TYPE_NORMAL
- en: Function types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have seen so far, Go has rich feature support for functions. In Go, functions
    are types too, just like `int`, `string`, and `bool` are types. This means we
    can pass functions as arguments to other functions, functions can be returned
    from a function, and functions can be assigned to variables. We can even define
    our own function types. A function’s type signature defines the types of its input
    parameters and return values. For a function to be of the type of another function,
    it must have the exact signature of the type ’unction that is declared. Let’s
    examine a few function types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet creates a new function type called `message`. It
    has no input parameters and does not have any return types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine another one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet creates a new function type called `calc`. It accepts
    two arguments of the `int` type and its return value is of the `string` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a fundamental understanding of function types, we can write
    some code to demonstrate their uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the code by the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '`type calc` declares `calc` to be of the `func` type, determining that it takes
    two integers as arguments and returns a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '`func add(i,j int) string` has the same signature as the `calc` type. It takes
    two integers as arguments and returns a string stating “Adding `i + j = result`.”
    Functions can be passed to other functions, just like any other type in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '`func calculator(f calc, i, j int)` accepts `calc` as input. The `calc` type,
    as you may remember, is a function type that has input parameters of `int` and
    a return type of `string`. Anything that matches that signature can be passed
    to the function. The `func calculator` function returns the result of the function
    of the `calc` type.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, we call `calculator(add, 5, 6)`. We are passing it the
    `add` function. `add` satisfies the signature of the `calc` `func` type.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.11* summarizes each of the preceding functions and how they relate
    to each other. This figure shows how `func add` is of the `func calc` type, which
    then allows it to be passed as an argument to `func calculator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Function types and uses](img/B18621_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: Function types and uses'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have just seen how to create a function type and pass it as an argument
    to a function. It is not that far of a stretch to pass a function as a parameter
    to another function. We will change our previous example slightly to reflect passing
    a function as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: We modified the `add` function signature so that it returns an `int` type instead
    of a `string` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We added a second function called `subtract`. Note that its function signature
    is the same as that of the `add` function. The `subtract` function simply returns
    the result of subtracting two numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have `calculator(f func(int, int) int, i, j int)`. The `calculator`
    function now has an input parameter of the `func` type. The input parameter, `f`,
    is a function that accepts two integers and returns an `int` type. Any function
    that satisfies the signature can be passed to the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `main()` function, `calculator` is called twice: once with the `add`
    function and some integer values being passed and once with the `subtract` function
    being passed as an argument with some integer values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The ability to pass functions as a type is a powerful feature where you can
    pass functions to other functions if their signatures match the passed-to function’s
    input parameter. An integer type for a function can be any value if it is an integer.
    The same goes for passing functions: a function can be any value if it is the
    correct type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function can also be returned from another function. We saw this when using
    anonymous functions combined with closures. Here, we will take a brief look since
    we saw this syntax previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning a function looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have `square(x int) func() int`. The `square` function accepts an
    `int` type as an argument and returns a function type that returns an `int` type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `square` body, we assign a variable, `f`, to an anonymous function that
    returns the square value of the input parameter, `x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `return` statement for the `square` function returns an anonymous function
    that is of the `func()` `int` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v` is assigned to the return of the `square` function. As you may recall,
    the return value is of the `func()` `int` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v` has been assigned the `func ()int` type; however, it has not been invoked.
    We will invoke it inside the `print` statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we have `fmt.Printf("Type of v: %T",v)`. This statement just prints
    out the type for `v`, which is `func()int`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise 5.08 – creating various functions to calculate salary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to be creating several functions. We need the
    ability to calculate the salary of a developer and a manager. We want this solution
    to be extensible for the future possibilities of other salaries to be calculated.
    We will be creating functions to calculate the developer’s and manager’s salary.
    Then, we will create another function that will take the previously mentioned
    function as an input parameter. The following steps will help you with the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file in a new directory and save it as `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `salary` function accepts a function that accepts two integers as arguments
    and returns an int `type`. So, any function that matches that signature can be
    passed as an argument to the `salary` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the body of the `salary()` function, `pay`, is assigned the value that gets
    returned from the `f` function. It passes `x` and `y` as parameters to the `f`
    parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that the `managerSalary` and `developerSalary` signatures are identical
    and that they match the `f` function for `salary`. This means that both `managerSalary`
    and `developerSalary` can be passed as `func(int,` `int) int`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`devSalary` and `bossSalary` get assigned to the results of the `salary` function.
    Since `developerSalary` and `managerSalary` satisfy the signature of `func(int,
    int) int`, they can both be passed in as arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open a terminal and navigate to the code’s directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we saw how a function type can be a parameter for another
    function. This allows a function to be an argument to another function. This exercise
    showed how our code can be simplified by having one `salary` function. If, in
    the future, we need to calculate the salary for a tester position, we would only
    need to create a function that matches the function type for `salary` and pass
    it as an argument. The flexibility that this gives is that we do not have to change
    our `salary` function’s implementation. In the next section, we are going to see
    how we can change the execution flow of a function, specifically after the function
    returns.
  prefs: []
  type: TYPE_NORMAL
- en: defer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `defer` statement defers the execution of a function until the surrounding
    function returns. Let’s try to explain this a bit better. Inside a function, you
    have a `defer` statement in front of a function that you are calling. Essentially,
    that function will execute right before the function you are currently inside
    completes. Still confused? Perhaps an example will make this concept a little
    clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the `defer` example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `main()` function, we have a deferred function, `defer done()`. Notice
    that the `done()` function has no new or special syntax. It just does a simple
    print to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have two `print` statements. The results are interesting. The two `print`
    statements in the `main()` function print first. Even though the deferred function
    was first in `main()`, it printed last. Isn’t that interesting? Its ordering in
    the `main()` function did not dictate its order of execution.
  prefs: []
  type: TYPE_NORMAL
- en: These deferred functions are commonly used for performing “cleanup” activities.
    This includes releasing resources, closing files, closing database connections,
    and removing `configuration\temp` files created by a program. `defer` functions
    are also used to recover from a panic; this will be discussed later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `defer` statement is not limited to just named functions – you can
    also utilize the `defer` statement with anonymous functions. Taking our previous
    code snippet, let’s turn it into a deferred call with an anonymous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: There’s not much that has changed from the previous code. We took the code that
    was in the `done` function and created a deferred anonymous function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `defer` statement is placed before the `func()` keyword. Our function has
    no function name. As you may recall, a function without a name is an anonymous
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results are the same as those from the previous example. Its readability,
    to a certain extent, is easier than having the deferred function declared as a
    named function, as in the previous example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also possible and common to have multiple `defer` statements in a function.
    However, they may not execute in the order that you expect. When using `defer`
    statements in front of functions, the execution follows the order of `defer` statement
    placed in front of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The multiple `defer` output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: The first three anonymous functions have their execution deferred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We declare `f1` and `f2` to be of the `func()` type. These two functions are
    anonymous.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, `f1()` and `f2()` executed as expected, but the order of the
    multiple `defer` statements executed in the reverse order of how they were declared
    in the code. The first `defer` statement was the last to execute and the last
    `defer` statement was the first to execute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Careful consideration must be given when using `defer` statements. A situation
    that you should consider is when you use `defer` statements in conjunction with
    variables. When a variable is passed to a deferred function, the variable’s value
    at that time is what will be used in the deferred function. If that variable is
    changed after the deferred function, it will not be reflected when the deferred
    function runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look:'
  prefs: []
  type: TYPE_NORMAL
- en: '`age := 25`: We initialize the `age` variable to `25` before the `defer` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name := "John"`: We initialize the `name` variable to `"John"` before the
    `defer` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defer personAge(name, age)`: We state that the function is going to be deferred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`age *= 2`: We double the age after the deferred function. Then, we print the
    current value of `age` doubled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`personAge(name string, i int)`: This is the function that is deferred; it
    only prints out the person and age.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results show the value of `age (25)` after it has been doubled in the `main`
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the execution of the program reaches the line that has `defer` `personAge(name,
    age)`, the value of `age` is `25`. Before the `main()` function completes, the
    deferred function runs and the value of `age` is still `25`. Variables used in
    the deferred function are the values before it was deferred, regardless of what
    happens after it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activity 5.02 – calculating the payable amount for employees based on working
    hours
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This activity is based on the previous activity. We will keep the same functionality,
    but we will be adding three additional features. In this version of the application,
    we would like to give the employee the ability to track their hours throughout
    the day without having logged them yet. This will allow the employees to keep
    better track of their hours before they log them at the end of the day. We will
    also enhance the application so that it calculates the employee’s pay. The application
    will calculate their pay for any overtime they’ve worked. The application will
    also print out details of how many hours were worked each day:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function called `nonLoggedHours() func(int) int`. Each time this function
    is called, it will calculate the hours of the employee that have not been logged.
    You will be using a closure inside the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method called `PayDay()(int,bool)`. This method will calculate the
    weekly pay. It needs to consider overtime pay. The method will pay twice the hourly
    rate for hours greater than 40\. The function will return `int` as the weekly
    pay and `bool` if the pay is overtime pay. The Boolean value will be true if the
    employee worked more than `40` hours and false if they worked less than `40` hours.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method called `PayDetails()`. This method will print each day and the
    hours worked that day by the employee. It will print the total hours for the week,
    the pay for the week, and if the pay contains overtime pay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `main` function, initialize a variable of the `Developer` type. Assign
    a variable to `nonLoggedHours`. Print the variable that was assigned to `nonLoggedHours`
    with values of `2`, `3`, and `5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, in the `main()` function, log the hours for the following days: Monday
    8, Tuesday 10, Wednesday 10, Thursday 10, Friday 6, and Saturday 8.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, run the `PayDetails()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Output for the payable amount activity](img/B18621_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: Output for the payable amount activity'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05/Activity05.02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05/Activity05.02).'
  prefs: []
  type: TYPE_NORMAL
- en: This activity aims to go a step further than *Activity 5.01 – calculating the
    working hours of employees*, by using some more advanced programming with Go’s
    functions. In this activity, we continued to use functions, as we did previously;
    however, we returned multiple values and returned a function from a function.
    We also demonstrated the use of closures for calculating hours not logged by an
    employee.
  prefs: []
  type: TYPE_NORMAL
- en: Separating similar code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered a lot regarding functions since they are a vital aspect
    of what makes Go successful and flexible as a language. To continue with the idea
    of making flexible code for others to understand, iterate on, and work with, we
    will discuss how to expand this mentality.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of software development, organizing code effectively is crucial
    for creating maintainable and scalable applications. In Go programming, one approach
    to achieving code organization is by separating related functions into different
    directories and utilizing multiple packages.
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, we have been working with just one file to understand the fundamentals
    of Go. However, there is life beyond just a `main.go` file. We will briefly discuss
    ways Go developers keep in mind the reusability and cleanliness of their code,
    beyond the scope of functions. However, we will keep things at a high level at
    this point as we dive into the details of this when we cover Go modules.
  prefs: []
  type: TYPE_NORMAL
- en: A well-structured directory layout enhances code readability and maintainability.
    It allows developers to locate and work with specific functionality quickly. In
    Go, it is common to group related functions into separate directories based on
    their purpose, context, or domain. By organizing code into feature-based or domain-specific
    directories, developers can easily identify and modify code pertaining to a particular
    functionality. This separation fosters modularity and makes it easier to understand
    the application’s architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'As projects grow in size and complexity, splitting code into functions and
    purposeful directories becomes essential for managing dependencies and reducing
    cognitive load. Large applications often benefit from a directory structure that
    aligns with the project’s modules or components. There are many benefits as to
    why you, as a developer, should care about separating your Go code into logical
    chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: Enhanced code reusability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved readability and maintainability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testability and isolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A concrete example of this can be seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file in a new directory and save it as `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `calculateSalary`, `playGame`, and `getWeather` functions are independent
    of each other, each can contain complex logic, and they may rely on different,
    unrelated dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Placing the unrelated functions, and even withholding their actual logic, makes
    the code file bloated; it can become messy and unmanageable as you continue to
    iterate on the code and add logic. It could make sense to separate the three functions
    into their own files, such as `salary.go`, `game.go`, and `weather.go`. Eventually,
    you could separate them into different directories, and so forth, as you go.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to start small, and then think about how you can separate similar
    code to continue writing manageable Go code that others can easily understand
    and iterate on. Again, this idea of code separation will be discussed in more
    detail when we cover Go modules since that is a vital way Go enables simple and
    reusable code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied why and how functions are an essential part of the
    Go programming language. We also discussed various features of functions in Go
    that make Go stand apart from other programming languages. Go has features that
    allow us to solve a lot of real-world problems and do so in a small, iterable,
    and manageable way. Functions in Go serve many purposes, including enhancing the
    usage and readability of code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned how to create and call functions. We studied the various types
    of functions that are used in Go and discussed scenarios where each of the function
    types can be used. We also expounded on the concept of closures. Closures are
    essentially a type of anonymous function that can use variables declared at the
    same level as that at which the anonymous function was declared. Then, we discussed
    various parameters and return types and studied `defer`. We also discussed how
    to keep your code clean and separated such that similar logic can be packaged
    up nicely together. This mentality of thinking about how to reduce, reuse, and
    recycle your code will enable you to become a better developer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll explore errors and error types and learn how to build
    custom errors, thus building a recovery mechanism to handle errors in Go.
  prefs: []
  type: TYPE_NORMAL
