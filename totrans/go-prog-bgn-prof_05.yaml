- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Functions – Reduce, Reuse, and Recycle
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数 – 减少、重用和回收
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will describe the various ways in which you can reduce, reuse,
    and recycle code. It will include a large overview of functions so that you can
    include parts of a function, such as defining the function, function identifiers,
    parameter lists, return types, and the function body. We will also look at best
    practices when designing code so that you can make it reusable and flexible and
    make your functional logic small and purposeful.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将描述你可以减少、重用和回收代码的各种方法。它将包括对函数的广泛概述，以便你可以包括函数的部分，如定义函数、函数标识符、参数列表、返回类型和函数体。我们还将探讨设计代码时的最佳实践，以便你可以使其可重用和灵活，并使你的功能逻辑小巧且具有目的性。
- en: By the end of this chapter, you will be able to see how easy Go makes it to
    reduce, reuse, and recycle code. This will include how to describe a function
    and the different parts that make up a function and evaluate the scope of variables
    with functions. You will know how to create and call a function, as well as how
    to utilize variadic and anonymous functions and create closures for various constructs.
    You will also know how to use functions as parameters and return values and how
    to use `defer` statements with functions. Finally, you will know how to separate
    similar functionality into logical sections by using multiple files and directories
    in your projects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够看到Go如何使减少、重用和回收代码变得容易。这包括如何描述一个函数以及构成函数的不同部分，以及使用函数评估变量的作用域。你将知道如何创建和调用函数，以及如何利用可变参数函数和匿名函数，并为各种结构创建闭包。你还将了解如何将函数用作参数和返回值，以及如何与函数一起使用`defer`语句。最后，你将了解如何通过在项目中使用多个文件和目录来将类似的功能分离成逻辑部分。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need to install the Go programming language. This
    chapter’s code can be found in this book’s GitHub repository: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要安装Go编程语言。本章的代码可以在本书的GitHub仓库中找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05)。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The ability to write code in a way that is easy to maintain and iterate on is
    a vital skill for an engineer. This means crafting it so that it may be reused,
    easily expanded upon, and understood by others. Go makes it easy to keep code
    clean and readable, and separate logical chunks together. The first major way
    of writing code that is easy to reduce, reuse, and recycle is through the use
    of functions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以一种易于维护和迭代的方式编写代码的能力是工程师的一项关键技能。这意味着要精心构建代码，使其可以被重用、易于扩展，并且易于他人理解。Go 语言使得保持代码的整洁和可读性变得容易，并且可以将逻辑块分开。编写易于减少、重用和回收的代码的第一种主要方式是通过使用函数。
- en: Functions are a core part of many languages and Go is no exception. A function
    is a section of code that has been declared to perform a task. Go functions can
    have zero or more inputs and outputs. One feature that sets Go apart from other
    programming languages is the multiple return values; most programming languages
    are limited to one return value. This leads into Go’s flexibility and the ability
    for developers to continuously write adaptable code.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是许多语言的核心部分，Go 语言也不例外。函数是一段被声明以执行任务的代码。Go 函数可以有零个或多个输入和输出。将Go与其他编程语言区分开来的一个特性是它支持多个返回值；大多数编程语言都限制为只有一个返回值。这导致了Go的灵活性和开发者持续编写可适应代码的能力。
- en: In the following section, we will see some features of Go functions that differ
    from other languages, such as returning multiple types. We will also see that
    Go has support for first-class functions. This means that Go can assign a variable
    to a function, pass a function as an argument, and have a function as a return
    type for a function. We will show how functions can be used to break up complex
    parts into smaller parts.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看到Go函数的一些与其他语言不同的特性，例如返回多个类型。我们还将看到Go支持一等函数。这意味着Go可以将变量分配给函数，将函数作为参数传递，以及将函数作为函数的返回类型。我们将展示如何使用函数将复杂部分分解成更小的部分。
- en: 'Functions in Go are considered first-class citizens and higher-order functions.
    First-class citizens are the functions that are assigned to a variable. Higher-order
    functions are functions that can take a function as an argument. The rich features
    of Go functions empower them to be used in various segments in the following ways:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的函数被认为是第一类公民和高级函数。第一类公民是将函数分配给变量的函数。高级函数是可以接受函数作为参数的函数。Go语言函数的丰富特性使它们能够在以下方式中使用在各个部分：
- en: To pass a function as an argument to another function
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数作为参数传递给另一个函数
- en: To return a function as a value from a function
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数作为值从函数返回
- en: To use functions as a type
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数用作类型
- en: To use functions as closures
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数用作闭包
- en: To use anonymous functions
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用匿名函数
- en: To assign functions to a variable
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数分配给变量
- en: We will be looking at each of these features since they are all supported in
    Go.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐一查看这些特性，因为它们在Go语言中都是支持的。
- en: Functions
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions are a critical part of Go and we should understand their place. Let’s
    examine some of the reasons for using functions:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是Go语言的关键部分，我们应该了解它们的位置。让我们考察一下使用函数的一些原因：
- en: '**Breaking up a complex task**: Functions are used to perform a task, but if
    that task is complicated, it should be broken down into smaller tasks. Functions
    can be used for small tasks to solve a bigger problem. Smaller tasks are more
    manageable, and using a function to solve specific tasks will make the entire
    code base easier to maintain.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分解复杂任务**：函数用于执行任务，但如果任务很复杂，应该将其分解成更小的任务。函数可以用于解决更大的问题的小任务。较小的任务更容易管理，使用函数解决特定任务将使整个代码库更容易维护。'
- en: '**Reducing code**: A good indication that you should use a function is when
    you see similar code repeating throughout your program. When you have duplicate
    code, it increases the difficulty of maintenance. If you have one change to make,
    you will have multiple instances where your code needs to change.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少代码**：你应该使用函数的一个好迹象是在你的程序中看到重复的代码。当你有重复的代码时，会增加维护的难度。如果你需要做一次更改，你将需要在多个实例中更改你的代码。'
- en: '**Reusability**: Once you have defined your function, you can use it repeatedly.
    It can also be used by other programmers. This sharing of functions will reduce
    lines of code and save time by allowing you to not have to reinvent the wheel.
    There are a couple of guidelines we should follow when we design functions:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：一旦你定义了函数，你就可以重复使用它。它也可以被其他程序员使用。这种函数的共享将减少代码行数并节省时间，因为你不需要重新发明轮子。在设计函数时，我们应该遵循以下几条准则：'
- en: '**Single responsibility**: A function should perform one task. For example,
    a single function should not calculate the distance between two points and estimate
    the time to travel between those two points. There should be a function for each
    of those tasks. This allows for better testing of that function and easier maintenance.
    It is difficult to narrow a function to perform a single task, so do not get discouraged
    if you do not get it right the first time. Even seasoned programmers struggle
    with assigning a single responsibility to a function, and responsibilities can
    shift over time.'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责**：一个函数应该执行一个任务。例如，一个函数不应该同时计算两点之间的距离并估算这两点之间的旅行时间。应该为每个任务创建一个函数。这有助于更好地测试该函数并更容易维护。将函数限制为执行单一任务可能很困难，所以如果你第一次没有做对，不要气馁。即使是经验丰富的程序员在分配函数的职责时也会遇到困难，而且职责可能会随时间而变化。'
- en: '**Small in size**: Functions should not span over hundreds of lines of code.
    This is an indication that the code needs some refactoring. When we have large
    functions, it’s more likely that the single responsibility principle will be violated.
    A good rule of thumb is trying to limit the function size to approximately 25
    lines of code; however, that’s not a hard-and-fast rule. The benefit of keeping
    the code concise is that it reduces the complexity of debugging a large function.
    It also makes writing unit tests with better code coverage easier.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**体积小**：函数不应该超过数百行代码。这是代码需要重构的迹象。当我们有大型函数时，违反单一职责原则的可能性更大。一个很好的经验法则是尝试将函数大小限制在大约25行代码；然而，这并不是一个硬性规定。保持代码简洁的好处是它减少了调试大型函数的复杂性。它还使得编写具有更好代码覆盖率的单元测试更容易。'
- en: Parts of a function
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的组成部分
- en: 'Let’s look at the different components that are involved in defining a function.
    The following is the typical layout of a function:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在定义函数时涉及的不同组件。以下是一个函数的典型布局：
- en: '![Figure 5.1: Different parts of a function](img/B18621_05_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：函数的不同部分](img/B18621_05_01.jpg)'
- en: 'Figure 5.1: Different parts of a function'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：函数的不同部分
- en: 'The different parts of a function are described here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述了函数的不同部分：
- en: '`func`: In Go, the function declaration starts with the `func` keyword.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func`：在 Go 中，函数声明以 `func` 关键字开始。'
- en: '`calculateTax`, `totalSum`, and `fetchId`.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateTax`、`totalSum` 和 `fetchId`。'
- en: The identifier should be something descriptive that makes the code easy to read
    and makes the purpose of the function easy to understand. The identifier is not
    required. You can have a function with no name; this is known as an anonymous
    function. Anonymous functions will be discussed in detail later in this chapter.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标识符应该是描述性的，使代码易于阅读，并使函数的目的易于理解。标识符不是必需的。您可以有一个没有名称的函数；这被称为匿名函数。匿名函数将在本章后面详细讨论。
- en: Note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When the first letter of the function name is in lowercase, then the function
    can’t be exported outside of a package. This means it’s private and cannot be
    called from outside the package. It can only be called within the package.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数名的第一个字母是小写时，则该函数不能导出包外。这意味着它是私有的，不能从包外调用。它只能在包内调用。
- en: Keep this in mind when you use the camelCase naming convention. If you want
    your function to be exportable, the first letter of the function name must be
    capitalized. This will mean other packages can consume and use your function if
    it is exported and starts with a capital letter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 camelCase 命名约定时请注意这一点。如果您希望函数可导出，函数名的第一个字母必须大写。这意味着如果函数导出并以大写字母开头，其他包可以消费和使用您的函数。
- en: '`name string`, `age int`). Parameters are local variables of the function.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name string`, `age int`) 参数是函数的局部变量。'
- en: Parameters are optional for a function. It is possible to not have any parameters
    for a function. A function can have zero or more parameters.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数对于函数是可选的。可能没有参数的函数。一个函数可以有零个或多个参数。
- en: When two or more parameters have the same type, you can use what is called shorthand
    parameter notation. This removes specifying the same type for each parameter.
    For instance, if your parameters are (`firstName string`, `lastName string`),
    they can be shortened to (`firstName`, `lastName string`). This reduces the verbosity
    of the parameter inputs and increases the readability of the function parameter
    list.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当两个或多个参数具有相同的类型时，可以使用所谓的简写参数表示法。这消除了为每个参数指定相同类型的需要。例如，如果您的参数是 (`firstName string`,
    `lastName string`)，它们可以缩短为 (`firstName`, `lastName string`)。这减少了参数输入的冗长性，并增加了函数参数列表的可读性。
- en: '**Return types**: Return types are a list of data types, such as Boolean, string,
    map, or another function that can be returned.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回类型**：返回类型是一系列数据类型，如布尔值、字符串、映射或另一个可以返回的函数。'
- en: In the context of declaring a function, we refer to these types as return types.
    However, in the context of calling a function, they are called return values.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在声明函数的上下文中，我们把这些类型称为返回类型。然而，在调用函数的上下文中，它们被称为返回值。
- en: Return types are the output of the function. Often, they are the result of the
    arguments provided to the function. They are optional. Most programming languages
    return a single type; in Go, you can return multiple types.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回类型是函数的输出。通常，它们是提供给函数的参数的结果。它们是可选的。大多数编程语言返回单个类型；在 Go 中，您可以返回多个类型。
- en: '`{}`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{}`。'
- en: The statements in the function are what determine what the function does. The
    function code is the code that is being used to perform the task that the function
    was created to accomplish.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数中的语句决定了函数做什么。函数代码是用于执行函数被创建来完成的任务的代码。
- en: If return types were defined, then a `return` statement is required in the function
    body. The `return` statement causes the function to immediately stop and return
    the value types listed after the `return` statement. The types in the return type
    list and the `return` statement must match.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果定义了返回类型，则函数体中需要有一个 `return` 语句。`return` 语句使函数立即停止并返回 `return` 语句之后列出的值类型。返回类型列表中的类型和
    `return` 语句中的类型必须匹配。
- en: In the function body, there can be multiple `return` statements. You often see
    this in the case of errors, where you might return different values than, say
    if the function processed logic successfully.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在函数体中，可以有多个`return`语句。你经常在出现错误的情况下看到这种情况，你可能需要返回与函数成功处理逻辑不同的值。
- en: '**Function signature**: Though not listed in the preceding code snippet, a
    function signature is a term that references the input parameters combined with
    the return types. Both of those units make up a function signature.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数签名**：尽管它没有在前面的代码片段中列出，但函数签名是一个术语，它指的是输入参数与返回类型的组合。这两个单元共同构成了函数签名。'
- en: Often, when you define the function signature when it is being used by others,
    you want to strive to not make changes to it as this can adversely impact your
    code and the code of others.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，当你在其他人使用函数时定义函数签名时，你希望努力不要对其进行更改，因为这可能会对你的代码和别人的代码产生不利影响。
- en: We will be diving deep into each of the parts of a function as we progress through
    this chapter. These parts of a function will become easier to understand through
    the following discussion and will become clearer as we go through this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本章中继续前进，我们将深入探讨函数的各个部分。通过以下讨论，这些函数部分将更容易理解，随着我们通过本章，它们将变得更加清晰。
- en: The checkNumbers function
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`checkNumbers`函数'
- en: 'Now that we have looked at the different parts of the function, let’s see how
    these parts work with various examples. Let’s start with a simple approach with
    a `checkNumbers` function. The `checkNumbers` function prints out various messages
    based on some math results of whether a number is even or odd. The rules perform
    one of the actions based on the number given:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看函数的不同部分，让我们看看这些部分如何与各种示例一起工作。让我们从一个简单的`checkNumbers`函数开始。`checkNumbers`函数根据数字是偶数还是奇数的某些数学结果打印出各种消息。规则根据给定的数字执行以下操作之一：
- en: If the number is `even`, print `Even`
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字是`偶数`，打印`Even`
- en: If the number is `odd`, print `Odd`
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字是`奇数`，打印`Odd`
- en: 'The following is the code snippet to achieve this output:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现此输出的代码片段：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s look at the code in sections:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分部分查看代码：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`func`, as you may recall, is the keyword to declare a function. This informs
    Go that the following piece of code is going to be a function.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func`，如你可能记得，是声明函数的关键字。这通知Go，接下来的代码块将是一个函数。'
- en: '`checkNumbers` is the name of our function. It is idiomatic (standard practice)
    in Go to use a camelCase name.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkNumbers`是我们函数的名称。在Go中，使用驼峰式名称是惯例（标准做法）。'
- en: '`()`, the parenthesis following the name of our function, is empty: our current
    implementation of the `checkNumbers` game does not require any input parameters.
    If it *did* require input parameters, they would be contained within parentheses.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`()`，跟随函数名称的括号是空的：我们当前实现的`checkNumbers`游戏不需要任何输入参数。如果它确实需要输入参数，它们将包含在括号内。'
- en: The space between the parameter list, `()`, and the opening brace would be the
    return type. Our current implementation does not require a return type.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数列表`()`和开括号之间的空格将是返回类型。我们当前的实施不需要返回类型。
- en: 'Regarding `{`, unlike other programming languages that you may know, Go requires
    that the opening curly brace is on the same line as the function declaration.
    If the opening brace is not on the same line as the function signature when you
    attempt to run the program, you will get an error:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`{`，与你可能知道的其它编程语言不同，Go要求开括号与函数声明在同一行上。如果你尝试运行程序时开括号不在函数签名同一行上，你会得到一个错误：
- en: '[PRE2]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding line is a `for` loop that increments the `i` variable from `1`
    to `30`:'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的行是一个`for`循环，它将`i`变量从`1`增加到`30`：
- en: '[PRE3]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`%` is a modulus operator; it gives the remainder of the two integers being
    divided. Using our function, if `i` is evenly divisible by `2`, then it will print
    out the word `"Even"`; otherwise, it will print “`Odd"`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`%`是取模运算符；它给出两个被除整数相除的余数。使用我们的函数，如果`i`能被`2`整除，那么它将打印出单词`"Even"`；否则，它将打印“`Odd"`。'
- en: As we become more familiar with Go concepts and language syntax, the explanation
    of the code will exclude items that we would otherwise be going over multiple
    times.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们越来越熟悉Go的概念和语言语法，代码的解释将排除我们本会多次讨论的项目。
- en: We have now defined our function. It has a specific task we want it to perform,
    but it doesn’t do any good if we do not execute the function. So, how do we execute
    a function? We must call our function. When we call a function, we are telling
    our program to execute the function. We will be calling our function inside the
    `main()` function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经定义了我们的函数。它有一个我们希望它执行的具体任务，但如果我们不执行该函数，那就没有用了。那么，我们如何执行一个函数呢？我们必须调用我们的函数。当我们调用一个函数时，我们是在告诉我们的程序执行该函数。我们将在`main()`函数内部调用我们的函数。
- en: 'Functions can call other functions. When this occurs, control is given to the
    function that was called. After the called function has returned data or reached
    the ending curly brace, `}`, control is given back to the caller. Let’s look at
    an example to understand this better:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以调用其他函数。当这种情况发生时，控制权交给被调用的函数。在被调用的函数返回数据或达到结束花括号`}`后，控制权返回给调用者。让我们通过一个例子来更好地理解这一点：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`fmt.Println("Main is in control")`: This `print` statement is for demonstration
    purposes. It shows that we are in the `main()` function.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmt.Println("main函数控制中")`：这个`打印`语句是为了演示目的。它显示我们处于`main()`函数中。'
- en: '`checkNumbers()`: We are now calling the function inside the `main()` function.
    Even though there are no parameters for our function, the parentheses are still
    required, and control of the program is given to the `checkNumbers()` function.
    After the `checkNumbers()` function completes, control is then given back to the
    `main()` function.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkNumbers()`：我们现在在`main()`函数内部调用函数。尽管我们的函数没有参数，但括号仍然是必需的，程序的控制权交给`checkNumbers()`函数。在`checkNumbers()`函数完成后，控制权随后返回到`main()`函数。'
- en: '`fmt.Println("Back to main")`: The `print` statement is for demonstration purposes
    to show that control has been given back to the `main()` function.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmt.Println("回到main")`：这个`打印`语句是为了演示目的，以显示控制权已经返回到`main()`函数。'
- en: 'The output will be as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 5.2: Output for checkNumbers](img/B18621_05_02.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：`checkNumbers`的输出](img/B18621_05_02.jpg)'
- en: 'Figure 5.2: Output for checkNumbers'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：`checkNumbers`的输出
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The parentheses following the `checkNumbers` function are still required, even
    though there are no input parameters. If they are omitted, the Go compiler will
    generate an error that states `checkNumbers` was evaluated but not used. This
    is a common error.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有输入参数，`checkNumbers`函数后面的括号仍然是必需的。如果省略了它们，Go 编译器将生成一个错误，指出`checkNumbers`被评估但没有使用。这是一个常见的错误。
- en: Exercise 5.01 – creating a function to print salesperson expectation ratings
    from the number of items sold
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.01 – 创建一个函数，根据售出的商品数量打印销售人员期望评级
- en: 'In this exercise, we will be creating a function that will not have any parameters
    or return types. The function will iterate over a map and print the name and number
    of items sold on the map. It will also print a statement based on how the salesperson
    performed based on their sales. The following steps will help you with the solution:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个没有参数或返回类型的函数。该函数将遍历映射并打印映射上的名称和售出的商品数量。它还将根据销售人员的销售情况打印一条声明。以下步骤将帮助您找到解决方案：
- en: Use the IDE of your choice.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的集成开发环境（IDE）。
- en: Create a new file and save it as `main.go`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，并将其保存为`main.go`。
- en: 'Enter the following code in `main.go`. The first function that `main` will
    call is `itemsSold()`; it does not have any parameters and has no return values:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中输入以下代码。`main`将首先调用的函数是`itemsSold()`；它没有参数，也没有返回值：
- en: '[PRE5]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we’ll define our function for logic regarding items sold:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将定义关于售出商品的逻辑函数：
- en: '[PRE6]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `itemsSold()` function, initialize a map that will have a key-value
    pair of `string`, `int`. The map will hold a `name`(`string`) and the number of
    `items`(`int`) sold by the individual. The name is the key for the map. We assign
    various names to number of items sold:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`itemsSold()`函数中，初始化一个将包含`string`到`int`键值对的映射。该映射将保存个人售出的`名称`（`string`）和`商品`数量（`int`）。名称是该映射的键。我们为售出的商品数量分配各种名称：
- en: '[PRE7]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We iterate over the `items` map and assign `k` to `key(name)` and `v` to `value(items)`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历`items`映射，将`k`分配给`key(名称)`，将`v`分配给`value(商品)`：
- en: '[PRE8]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We print out `Name` and the number of sold `items`:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打印出`名称`和售出的`商品`数量：
- en: '[PRE9]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Depending on the value of `v`(`items`), we will determine the statement we
    print:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据变量`v`（`商品`）的值，我们将确定要打印的声明：
- en: '[PRE10]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Open your terminal and navigate to the code’s directory.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的终端并导航到代码目录。
- en: Run `go build` and then run the executable.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go build`然后运行可执行文件。
- en: 'The expected output is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下所示：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this exercise, we saw some of the fundamental parts of a function. We demonstrated
    how to declare a function using the `func` keyword, followed by how to give our
    function an identifier or name, such as `itemsSold()`. Then, we added code to
    the function body. In the next few sections, we will expand on these core parts
    of the function and learn how to pass data into a function using parameters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了函数的一些基本部分。我们展示了如何使用`func`关键字声明一个函数，然后是如何给我们的函数一个标识符或名称，例如`itemsSold()`。然后，我们在函数体中添加了代码。在接下来的几节中，我们将扩展函数的核心部分，并学习如何使用参数将数据传递给函数。
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is best to type the code into an IDE. The benefit is that if you type something
    incorrectly, you will see the error message and can perform some debugging to
    solve the problem.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最好在IDE中输入代码。好处是如果你输入错误，你会看到错误信息，并可以进行一些调试来解决问题。
- en: Parameters
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数
- en: 'Parameters define what arguments can be passed to our function. Functions can
    have zero or more parameters. Even though Go allows us to define multiple parameters,
    we should take care not to have a huge parameter list; that would make the code
    harder to read. It may also be an indication that the function is doing more than
    one specific task. If that is the case, we should refactor the function. Take,
    for example, the following code snippet:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 参数定义了可以传递给我们的函数的参数。函数可以有零个或多个参数。尽管Go允许我们定义多个参数，但我们应小心不要有一个庞大的参数列表；这会使代码更难阅读。这也可能表明函数正在执行多个特定任务。如果是这样，我们应该重构函数。以下是一个代码片段的例子：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code is an example of a function whose parameter list is bloated.
    The parameter list should pertain only to the single responsibility of the function.
    We should only define the parameters that are needed to solve the specific problem
    that the function is built for.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个参数列表膨胀的函数示例。参数列表应该只与函数的单个职责相关。我们只应该定义解决函数构建的特定问题所需的参数。
- en: Parameters are the input types that our function will use to perform its task.
    Function parameters are local to the function, meaning they are only available
    to that function. They are not available outside of the context of the function.
    Also, the order of the parameters must match the parameter types in the correct
    sequence.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是我们函数将用于执行其任务的输入类型。函数参数是局部的，意味着它们只对那个函数可用。它们在函数的上下文之外不可用。此外，参数的顺序必须与正确的参数类型顺序相匹配。
- en: '**Correct**:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**正确**：'
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output when the correct parameter matches would be as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确参数匹配时的输出如下所示：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Incorrect**:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**不正确**：'
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output looks as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 5.3: Output for incorrect parameter matching](img/B18621_05_03.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3：不正确参数匹配的输出](img/B18621_05_03.jpg)'
- en: 'Figure 5.3: Output for incorrect parameter matching'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：不正确参数匹配的输出
- en: In the incorrect version of the code, we are calling the `greeting()` function
    with the `age` argument, which is of the `integer` type, when the parameter is
    of the `string` type. The sequence of your arguments must match the sequence of
    the parameter input list.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的不正确版本中，我们正在使用`age`参数调用`greeting()`函数，该参数是`integer`类型，而参数是`string`类型。你的参数序列必须与参数输入列表的序列相匹配。
- en: 'Additionally, users would want to have more control over the data the code
    iterates over. Going back to the `checkNumbers` example, the current implementation
    only does `1` to `30`. Users may need to work on different number ranges, so we
    need a way to decide the ending range of the loop. We can change our `checkNumbers`
    function so that it accepts an input parameter. This would meet the needs of our
    user:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，用户可能希望对代码遍历的数据有更多的控制。回到`checkNumbers`示例，当前的实现只做`1`到`30`。用户可能需要处理不同的数字范围，因此我们需要一种方法来决定循环的结束范围。我们可以修改我们的`checkNumbers`函数，使其接受一个输入参数。这将满足用户的需求：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code snippet can be explained as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段可以这样解释：
- en: For `checkNumbers(10)` in the `main()` function, we pass `10` as an argument
    to our `checkNumbers` function
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main()`函数中对于`checkNumbers(10)`，我们将`10`作为参数传递给我们的`checkNumbers`函数
- en: For `checkNumbers(end int)`, `end` is the name of our parameter and it is of
    the `int` type
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`checkNumbers(end int)`，`end`是我们参数的名称，它是`int`类型
- en: Now, our function will only iterate up to the value of our end parameter; in
    this example, it will iterate to `10`
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，我们的函数将只迭代到我们的结束参数的值；在这个例子中，它将迭代到`10`
- en: The difference between an argument and a parameter
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数和参数之间的区别
- en: This is a good time to discuss the difference between an argument and a parameter.
    When you are defining your function, using our example, `checkNumbers(end int)`
    is called a parameter. When you call a function, such as `checkNumbers(10)`, `10`
    is called the argument. Also, the argument and parameter names do not need to
    match.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是讨论参数和参数之间区别的好时机。当你定义你的函数时，使用我们的例子，`checkNumbers(end int)` 被称为参数。当你调用一个函数，例如
    `checkNumbers(10)`，`10` 被称为参数。此外，参数和参数的名称不需要匹配。
- en: 'Functions in Go can also have more than one parameter defined. We need to add
    another parameter to our `checkNumbers` function to accommodate this enhancement:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的函数也可以定义多个参数。我们需要给 `checkNumbers` 函数添加另一个参数以适应这个增强：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code snippet can be explained as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段可以这样解释：
- en: Regarding `checkNumbers(start, end)`, we are now passing two arguments to the
    `checkNumbers` function. When there are multiple arguments, they must be separated
    by a comma.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 `checkNumbers(start, end)`，我们现在向 `checkNumbers` 函数传递两个参数。当有多个参数时，它们必须通过逗号分隔。
- en: Regarding `func checkNumbers(start int, end int)`, when multiple parameters
    are defined in a function, they are separated by commas, following the convention
    of name type, name type, name type, and so on.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 `func checkNumbers(start int, end int)`，当在函数中定义多个参数时，它们通过逗号分隔，遵循名称类型、名称类型、名称类型等约定。
- en: 'Our `checkNumbers` parameters are more verbose than what is necessary. When
    we have multiple input parameters of the same type, we can separate the input
    name by a comma followed by the type. This is referred to as shorthand parameter
    notation. See the following example of using shorthand parameter notation:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `checkNumbers` 参数比必要的更详细。当我们有多个相同类型的输入参数时，我们可以通过逗号后跟类型来分隔输入名称。这被称为简写参数符号。请参见以下使用简写参数符号的示例：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code snippet can be explained as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段可以这样解释：
- en: There is no change to the caller when using shorthand parameter notation.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简写参数符号时，调用者没有变化。
- en: Regarding `checkNumbers(start, end int)`, `start` and `end` are of the `int`
    type. Nothing needs to change in the body of the function to accommodate the shorthand
    parameter notation.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 `checkNumbers(start, end int)`，`start` 和 `end` 是 `int` 类型。为了适应简写参数符号，函数体内的内容不需要做任何改变。
- en: Exercise 5.02 – mapping index values to column headers
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.02 – 将索引值映射到列标题
- en: 'The function that we are going to create will be taking a slice of column headers
    from a CSV file. It will print out a map of an index value of the headers we are
    interested in:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的函数将从一个 CSV 文件中获取列标题的切片。它将打印出我们感兴趣的标题的索引值映射：
- en: Open the IDE of your choice.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您选择的 IDE。
- en: Create a new file and save it as `main.go`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，并将其保存为 `main.go`。
- en: 'Enter the following code in `main.go`:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中输入以下代码：
- en: '[PRE19]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, we assign a variable to a key-value pair of `int` and `string`. `key(int)`
    will be the index of our `header(string)` column. The index will map to a column
    header.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们给一个 `int` 和 `string` 的键值对分配一个变量。`key(int)` 将是我们的 `header(string)` 列的索引。索引将映射到列标题。
- en: 'We range over `header` to process each string that is in the slice. In the
    following `for` loop, `i` will store the index, and `v` will be assigned to each
    value in the header:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历 `header` 来处理切片中的每个字符串。在下面的 `for` 循环中，`i` 将存储索引，`v` 将被分配给标题中的每个值：
- en: '[PRE20]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For each string, remove any trailing spaces in front of and after the string.
    In general, we should always assume that our data may have some erroneous characters:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个字符串，删除字符串前后任何多余的空格。一般来说，我们应该始终假设我们的数据可能包含一些错误字符：
- en: '[PRE21]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In our `switch` statement, we lower all the casing for exact matches. As you
    may recall, Go is a case-sensitive language. We need to ensure that the casing
    is the same for matching purposes. When our code finds the header, it sets the
    index value for the header in the map:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `switch` 语句中，我们将所有的大小写转换为精确匹配。如您所回忆的，Go 是一个区分大小写的语言。我们需要确保匹配时大小写相同。当我们的代码找到标题时，它将在映射中设置标题的索引值：
- en: '[PRE22]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Typically, we would not print out the results. We should return `csvHeadersToColumnIndex`,
    but since we have not gone over how to return a value, we will print it for now:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，我们不会打印出结果。我们应该返回 `csvHeadersToColumnIndex`，但由于我们还没有讲解如何返回值，我们现在将其打印出来：
- en: '[PRE23]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Open your terminal and navigate to the code’s directory.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的终端并导航到代码目录。
- en: Run `go build` and run the executable.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go build` 并运行可执行文件。
- en: 'The expected output is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this exercise, we saw how to accept data into a function: by defining a
    parameter for our function. The callers of our function were able to pass arguments
    to the function. We will continue to discover various abilities that functions
    in Go can provide. So far, we have seen how to get data into our function. In
    the next section, we will see how to get data out of our function.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何将数据传入函数：通过为我们的函数定义一个参数。我们的函数调用者能够将参数传递给函数。我们将继续发现 Go 中函数可以提供的各种能力。到目前为止，我们已经看到了如何将数据传入我们的函数。在下一节中，我们将看到如何从我们的函数中获取数据。
- en: Function variable scope
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数变量作用域
- en: When designing functions, we need to consider the variable scope. The scope
    of a variable determines where the variable is accessible or visible to the different
    parts of the application. Variables declared inside the function are considered
    local variables. This means that they are only accessible to the code within the
    body of the function. You cannot access variables from outside of the function.
    The calling function does not have access to variables inside the called function.
    The input parameter’s scope is the same as the local variable’s scope to the function.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计函数时，我们需要考虑变量作用域。变量的作用域决定了变量在应用程序的不同部分中可访问或可见的位置。在函数内部声明的变量被认为是局部变量。这意味着它们只能被函数体内的代码访问。你不能从函数外部访问变量。调用函数无法访问被调用函数内部的变量。输入参数的作用域与函数的局部变量作用域相同。
- en: 'Variables declared in the calling function are scoped to that function. This
    means that the variables are local to the function and those variables are not
    accessible outside of the function. Our function cannot reach into the calling
    function’s variables. To gain access to those variables, they must be passed into
    our function as input parameters:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数中声明的变量具有该函数的作用域。这意味着变量是函数内的局部变量，并且这些变量在函数外部不可访问。我们的函数无法访问调用函数的变量。要访问这些变量，它们必须作为输入参数传递给我们的函数：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here’s the output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '![Figure 5.4: Error output for the m variable being undefined](img/B18621_05_04.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4：m 变量未定义时的错误输出](img/B18621_05_04.jpg)'
- en: 'Figure 5.4: Error output for the m variable being undefined'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：m 变量未定义时的错误输出
- en: 'The previous code snippet will result in an error in `func greeting()` that
    states that `m` is undefined. That is because the `m` variable is declared inside
    `main()`. The `greeting()` function does not have access to the `m` variable.
    For it to have access, the `m` variable must be passed to the `greeting()` function
    as an input parameter:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段将在 `func greeting()` 中导致错误，指出 `m` 未定义。这是因为 `m` 变量是在 `main()` 中声明的。`greeting()`
    函数无法访问 `m` 变量。为了访问它，必须将 `m` 变量作为输入参数传递给 `greeting()` 函数：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here’s the output:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '![Figure 5.5: Error output for the s variable being undefined](img/B18621_05_05.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5：s 变量未定义时的错误输出](img/B18621_05_05.jpg)'
- en: 'Figure 5.5: Error output for the s variable being undefined'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5：s 变量未定义时的错误输出
- en: The previous code snippet will result in an error in `func main()`. The error
    will state that `s` is undefined. This is because the `s` variable is declared
    in the `greeting()` function. The `main()` function does not have access to the
    `s` variable. The `s` variable is only visible to code inside the function body
    of `greeting()`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段将在 `func main()` 中导致错误，错误将指出 `s` 未定义。这是因为 `s` 变量是在 `greeting()` 函数中声明的。`main()`
    函数无法访问 `s` 变量。`s` 变量仅在 `greeting()` 函数体内部的代码中可见。
- en: These are just some considerations that we need to keep in mind when we are
    declaring and accessing variables. It is important to understand the scope of
    the variables inside a function concerning the variables declared outside of a
    function. It can cause some confusion when you are trying to access variables
    but you are not scoped to the context that you are trying to access. The examples
    in this chapter should help you in understanding the scope of variables.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是我们在声明和访问变量时需要考虑的一些注意事项。理解函数内部变量与函数外部声明的变量作用域之间的关系非常重要。当你试图访问变量但未处于你试图访问的上下文作用域时，可能会造成一些混淆。本章中的示例应该有助于你理解变量的作用域。
- en: Return values
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回值
- en: So far, the functions that we have created do not have any return values. Functions
    typically accept inputs, perform some action on those inputs, and then return
    the results of those actions. Functions in some programming languages return only
    one value. Go allows you to return multiple values from a function. This is one
    of the features of Go functions that distinguishes it from other programming languages.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的函数都没有任何返回值。函数通常接受输入，对这些输入执行一些操作，然后返回这些操作的结果。某些编程语言的函数只返回一个值。Go 允许你从函数中返回多个值。这是
    Go 函数的一个特性，使其与其他编程语言区分开来。
- en: Exercise 5.03 – creating a checkNumbers function with return values
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.03 – 创建带有返回值的`checkNumbers`函数
- en: 'In this exercise, we are going to make some enhancements to our `checkNumbers`
    function. We are going to change it so that it accepts only an integer. We will
    leave the onus on the caller to perform the looping if they desire to do so. Also,
    we are going to have two returns. The first will be the number provided and the
    corresponding text indicating if the number is `Even` or `Odd`. The following
    steps will help you with the solution:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将对我们的`checkNumbers`函数进行一些改进。我们将将其修改为只接受一个整数。我们将把是否进行循环的责任留给调用者，如果他们希望这样做。此外，我们将有两个返回值。第一个将是提供的数字和相应的文本，指示该数字是`Even`还是`Odd`。以下步骤将帮助你找到解决方案：
- en: Open the IDE of your choice.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你选择的 IDE。
- en: Create a new file in a different directory and save it as `main.go`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不同的目录中创建一个新的文件，并将其保存为`main.go`。
- en: 'In the `main()` function, assign variables to the return values of our function.
    The `n,` and `s` variables correspond to the values being returned from our function,
    which are `int` and `string`, respectively:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，将变量分配给我们的函数的返回值。`n`和`s`变量对应于从我们的函数返回的值，分别是`int`和`string`：
- en: '[PRE27]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `checkNumbers` function now returns two values; the first being an `int`
    value, followed by a `string` value:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`checkNumbers`函数返回两个值；第一个是一个`int`值，后面跟着一个`string`值：
- en: '[PRE28]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Simplify the `if{}else{}` statements by replacing them with `switch` statements.
    As you are writing code, you should look for ways to simplify things and make
    the code more readable. `case i%2 ==0` is equivalent to our previous `if i%2 ==
    0` statements. Instead of our previous `fmt.Println()` statements, replace them
    with `return`. The `return` statement will immediately stop the execution of the
    function and return the results to the caller:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过用`switch`语句替换`if{}else{}`语句来简化`if{}else{}`语句。当你编写代码时，你应该寻找简化事物和使代码更易读的方法。`case
    i%2 ==0`与我们之前的`if i%2 == 0`语句等价。我们不再使用之前的`fmt.Println()`语句，而是用`return`替换它们。`return`语句将立即停止函数的执行，并将结果返回给调用者：
- en: '[PRE29]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The expected output is as follows:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '![Figure 5.6: Output for the checkNumbers function with return values](img/B18621_05_06.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6：带有返回值的`checkNumbers`函数的输出](img/B18621_05_06.jpg)'
- en: 'Figure 5.6: Output for the checkNumbers function with return values'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6：带有返回值的`checkNumbers`函数的输出
- en: In this exercise, we saw how we can return multiple values from a function.
    We were able to assign variables to the multiple return values from the function.
    We also noticed that the variables that were assigned to the function matched
    the order of the return values. In the following section, we will learn that in
    the body of the function, we can perform naked returns, where we do not need to
    specify the variable being returned in our return statement.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何从一个函数中返回多个值。我们能够将变量分配给函数的多个返回值。我们还注意到分配给函数的变量与返回值的顺序相匹配。在下一节中，我们将了解到在函数体中，我们可以执行裸返回，在这种情况下，我们不需要在我们的返回语句中指定要返回的变量。
- en: We also saw a switch statement that was used to clean up the `if{}else{}` logic.
    We had a case for even numbers and a `default` “catch-all” case where odd numbers
    would fall. The `default` case is just as it sounds and will be the default case
    if a case is not before it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了一个用于清理`if{}else{}`逻辑的`switch`语句。我们有一个偶数的`case`，还有一个`default`“通配”`case`，其中奇数会落入。`default``case`正如其名，如果它之前没有`case`，它将是默认`case`。
- en: Activity 5.01 – calculating the working hours of employees
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 5.01 – 计算员工的工作时间
- en: 'In this activity, we’ll be creating a function that will calculate the working
    hours of employees for a week. Then, we’ll use this to calculate the payable salary
    amount. The `developer` struct has a field called `Individual` that is of the
    `Employee` type. The `developer` struct keeps track of the `HourlyRate` value
    that they charge and how many hours they work each day. The following steps will
    help you to reach the solution:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将创建一个函数来计算员工一周的工作小时数。然后，我们将使用这个函数来计算应支付的工资金额。`developer`结构体有一个名为`Individual`的字段，其类型为`Employee`。`developer`结构体跟踪他们收取的`HourlyRate`值以及他们每天工作的小时数。以下步骤将帮助你找到解决方案：
- en: 'Create an `Employee` type that has the following fields: `Id` as `int`, `FirstName`
    as `string`, and `LastName` as `string`.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有以下字段的`Employee`类型：`Id`为`int`，`FirstName`为`string`，`LastName`为`string`。
- en: 'Create a `developer` type that has the following fields: `Individual` as `Employee`,
    `HourlyRate` as `int`, and `WorkWeek` as `[7]int`.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`developer`类型，它有以下字段：`Individual`为`Employee`，`HourlyRate`为`int`，`WorkWeek`为`[7]int`。
- en: Create an `enum` type (enums are types that contain only a limited number of
    fixed values) for the seven days of the week. This will be of the `Weekday` `int`
    type with a constant declaration for each day of the week.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示一周七天的`enum`类型（枚举是只包含有限个固定值的类型）。这将是一个`Weekday` `int`类型，并为每周的每一天声明一个常量。
- en: Create a pointer receiver method called `LogHours` for `Developer` that will
    take the `WeekDay` type and `int` type as input. Assign the hours worked that
    day to the `Developer` workweek slice.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Developer`类型创建一个名为`LogHours`的指针接收器方法，该方法将接受`WeekDay`类型和`int`类型作为输入。将当天工作的小时数分配给`Developer`的工作周切片。
- en: Create a method that is a pointer receiver called `HoursWorked()`. This method
    will return the total hours that have been worked.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`HoursWorked()`的方法，该方法是一个指针接收器。这个方法将返回已经工作的总小时数。
- en: In the `main()` function, initialize and create a variable of the `Developer`
    type.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，初始化并创建一个`Developer`类型的变量。
- en: In the `LogHours` method, call the method for two days (such as Monday and Tuesday).
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LogHours`方法中，调用两天的方法（例如星期一和星期二）。
- en: Print the hours for the two days of the previous step.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印上一步骤中两天的小时数。
- en: Next, print the results of the `HoursWorked` method.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打印`HoursWorked`方法的结果。
- en: 'The following is the expected output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为预期的输出：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05/Activity05.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05/Activity05.01)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在本章节的GitHub仓库文件夹中找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05/Activity05.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05/Activity05.01)
- en: This activity aims to demonstrate the ability to break problems down into manageable
    tasks to be implemented by functions, such that each of our functions has a single
    responsibility. `LogHours` is responsible for assigning the hours worked for each
    day. `HoursWorked` uses the values that were assigned in `LogHours` to display
    the hours worked each day. We used return types from our functions to display
    the data. This exercise demonstrates utilizing functions correctly to provide
    a solution to a problem.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的目的是展示将问题分解为可管理的任务以供函数实现的能力，使得我们的每个函数都有一个单一的责任。`LogHours`负责分配每天的工作小时数。`HoursWorked`使用在`LogHours`中分配的值来显示每天的工作小时数。我们使用函数的返回类型来显示数据。这个练习展示了正确利用函数来解决问题。
- en: Naked returns
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 裸返回
- en: Note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Functions that have return values must have a return statement as the last statement
    in the function. If you omit the return statement, the Go compiler will give you
    an error stating “missing return at the end of the function.”
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有返回值的函数必须在函数的最后一个语句处有一个返回语句。如果你省略了返回语句，Go编译器会给出一个错误，指出“函数末尾缺少返回语句。”
- en: Typically, when a function returns two types, the second type is an `error`.
    We have not gone over errors yet, so we won’t be demonstrating them in these examples.
    It is good to know that, in Go, it is idiomatic for the second return type to
    be of the `error` type.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当一个函数返回两种类型时，第二种类型是`error`。我们还没有讲解错误，所以不会在这些示例中演示它们。了解在Go语言中，第二种返回类型通常是`error`类型是很重要的。
- en: 'Go also allows you to ignore a variable being returned. For example, say we
    are not interested in the `int` value that is being returned from our `checkNumbers`
    function. In Go, we can use what is called a blank identifier, which allows us
    to ignore values in an assignment:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Go 也允许你忽略返回的变量。例如，假设我们对从`checkNumbers`函数返回的`int`值不感兴趣。在 Go 中，我们可以使用所谓的空白标识符，这允许我们在赋值时忽略值：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For example, when reading a file, we might not be concerned about the number
    of bytes read. So, in that case, we can ignore the value being returned by using
    the blank identifier, `_`. When extra data is being returned from a function that
    does not provide any information that is needed by our program, such as the reading
    of a file, it is a good candidate for ignoring the return:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在读取文件时，我们可能不会关心读取的字节数。因此，在这种情况下，我们可以使用空白标识符`_`来忽略返回的值。当从函数返回额外数据，而这些数据对我们的程序没有任何必要信息时，例如读取文件，忽略返回值是一个很好的选择：
- en: Note
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As you will discover later, many functions return an error as the second return
    value. You should not ignore return values from functions that are errors. Ignoring
    an error returned by a function could result in unexpected behavior. Error return
    values should be handled appropriately.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，许多函数将错误作为第二个返回值返回。你不应该忽略错误函数的返回值。忽略函数返回的错误可能会导致意外的行为。错误返回值应该得到适当的处理。
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding example, we used the blank identifier, `_`, to ignore the
    `int` value being returned:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了空白标识符`_`来忽略返回的`int`值：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You must always have a placeholder for the values being returned when assigning
    values from a function. When performing an assignment, the placeholders must match
    the number of return values from the function. `_` and `result` are the placeholders
    for the return values of `int` and `string`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在从函数赋值时，你必须始终为返回的值提供一个占位符。在进行赋值时，占位符的数量必须与函数返回值的数量相匹配。`_`和`result`是`int`和`string`返回值的占位符。
- en: 'Go also has a feature that allows you to name your returns. If you use this
    feature, it can make your code more readable, as well as self-documenting. If
    you name your return variables, they are under the same constraints as the local
    variables, as discussed in the previous section. By naming your returns, you are
    creating local variables in the function. You can then assign values to those
    return variables, just as you do with input parameters:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Go 还有一个允许你命名返回值的功能。如果你使用这个功能，它可以使你的代码更易于阅读，以及自我文档化。如果你为返回变量命名，它们将受到与上一节中讨论的局部变量相同的约束。通过命名返回值，你正在在函数中创建局部变量。然后你可以像处理输入参数一样为这些返回变量赋值：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code, `(name string, age int)` are named returns. They are
    now local variables to the function.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`(name string, age int)`是命名返回。现在它们是函数的局部变量。
- en: 'Since `name` and `age` are local variables that were declared in the return
    list of the function, you can now assign values to them. They can be treated as
    local variables. In the `return` statement, specify the return values. If you
    do not specify the variable name in the return, it is called a *naked return*:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`name`和`age`是在函数返回列表中声明的局部变量，你现在可以给它们赋值。它们可以被视为局部变量。在`return`语句中，指定返回值。如果你没有在返回中指定变量名，它被称为*裸返回*：
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Consider the preceding code block. This code is the same as before with the
    exception that the return value does not name the variables to return. The `return`
    statement will return the variables that are named in the return list.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前面的代码块。这段代码与之前相同，只是返回值没有命名变量。`return`语句将返回返回列表中命名的变量。
- en: 'One of the disadvantages of naked returns is that it can cause confusion when
    reading code. To avoid confusion and the possibility of other issues, it is recommended
    that you avoid using the naked returns feature as it can make it difficult to
    follow the variable that is to be returned. There can also be issues with shadowing
    when using naked returns:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 裸返回的一个缺点是它可能在阅读代码时引起混淆。为了避免混淆和其他可能的问题，建议避免使用裸返回功能，因为它可能会使跟踪要返回的变量变得困难。使用裸返回也可能存在阴影问题：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding code will result in the following error:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码将导致以下错误：
- en: '![Figure 5.7: Output of shadowing with naked returns](img/B18621_05_07.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7：裸返回的阴影输出](img/B18621_05_07.jpg)'
- en: 'Figure 5.7: Output of shadowing with naked returns'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：裸返回的阴影输出
- en: This is because the `err` variable is named in `return` and is initialized in
    an `if` statement. Recall that variables that are initialized within curly braces,
    such as `for` loops, `if` statements, and `switch` statements, are scoped to that
    context, meaning that they are only visible and accessible within those curly
    braces.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `err` 变量在 `return` 语句中被命名，并在 `if` 语句中初始化。回想一下，在花括号内初始化的变量，如 `for` 循环、`if`
    语句和 `switch` 语句，其作用域仅限于该上下文，这意味着它们只在前面的花括号内可见和可访问。
- en: Exercise 5.04 – mapping a CSV index to a column header with return values
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.04 – 将 CSV 索引映射到列标题并返回值
- en: 'In *Exercise 5.02 – mapping index values to column headers*, we only printed
    the results of the index to the column header. In this exercise, we are going
    to return the map as the result. The map that’s being returned is the index-to-column
    header mapping. The following steps will help you with the solution:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *练习 5.02 – 将索引值映射到列标题* 中，我们只打印了索引到列标题的结果。在这个练习中，我们将返回映射作为结果。返回的映射是索引到列标题的映射。以下步骤将帮助您找到解决方案：
- en: Open the IDE of your choice.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您选择的 IDE。
- en: Open the file from the previous column header exercise called `main.go`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开之前列标题练习中的文件 `main.go`。
- en: 'Enter the following code in `main.go`:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 文件中输入以下代码：
- en: '[PRE37]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, in the `main()` function, define the headers for the columns. First,
    we will assign a variable to a key-value pair of `int` and `string`. `key(int)`
    will be the index of our `header(string)` column. The index will map to a column
    header:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `main()` 函数中，定义列的标题。首先，我们将一个变量分配给 `int` 和 `string` 的键值对。`key(int)` 将是我们的
    `header(string)` 列的索引。索引将映射到列标题：
- en: '[PRE38]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We use `range` over `header` to process each string that is in the slice:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `range` 操作符遍历 `header` 来处理切片中的每个字符串：
- en: '[PRE39]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For each string, we remove any trailing spaces in front of and after the string.
    In general, we should always assume that our data may have some erroneous characters:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个字符串，我们移除了字符串前后任何多余的空格。一般来说，我们应该始终假设我们的数据可能包含一些错误字符：
- en: '[PRE40]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In our `switch` statement, we lower all the casing for exact matches. As you
    may recall, Go is a case-sensitive language. We need to ensure the casing is the
    same for matching purposes. When our code finds the header, it sets the index
    value for the header in the map:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `switch` 语句中，我们将所有匹配项的字母大小写转换为小写。如您所回忆的，Go 是一个区分大小写的语言。我们需要确保匹配时的大小写相同。当我们的代码找到标题时，它将在映射中设置标题的索引值：
- en: '[PRE41]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Open a terminal and navigate to the code’s directory.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并导航到代码目录。
- en: Run `go build` and run the executable.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go build` 并运行可执行文件。
- en: 'The expected output for return values is as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值的预期输出如下：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this exercise, we saw a real-world example of mapping a CSV index to column
    headers. We used a function to solve this complex problem. We were able to have
    the function have a single return value of the `map` type. In the next section,
    we are going to see how functions can accept a variable number of argument values
    within a single argument.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了一个将 CSV 索引映射到列标题的实际例子。我们使用一个函数来解决这个复杂的问题。我们能够使函数返回一个 `map` 类型的单一值。在下一节中，我们将看到函数如何接受单个参数内的可变数量参数值。
- en: Variadic functions
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变参数函数
- en: 'A variadic function is a function that accepts a variable number of argument
    values. It is good to use a variadic function when the number of arguments of
    a specified type is unknown:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数函数是一种接受可变数量参数值的函数。当指定类型的参数数量未知时，使用可变参数函数是很好的选择：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding function is an example of what a variadic function looks like.
    The three dots (`…`) in front of the type are called a *pack operator*. The pack
    operator is what makes it a variadic function. It tells Go to store all the arguments
    of `Type` in `parameterName`. The variadic variable can accept zero or more variables
    as the argument:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数是一个可变参数函数的例子。类型前面的三个点 (`…`) 被称为 *打包操作符*。打包操作符使得它成为一个可变参数函数。它告诉 Go 将 `Type`
    类型的所有参数存储在 `parameterName` 中。可变参数变量可以接受零个或多个变量作为参数：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `nums` function is a variadic function that accepts an `int` type. As stated
    previously, you can pass zero or more arguments of the type. If there is more
    than one value, you separate them with a comma, as in `nums(99, 100)`. If there
    is only one argument to pass, you only pass that argument, as in `nums(200)`.
    If there isn’t an argument to pass, you can leave it empty, as in `nums()`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`nums` 函数是一个接受 `int` 类型的可变函数。如前所述，你可以传递零个或多个该类型的参数。如果有多个值，你用逗号将它们分开，例如 `nums(99,
    100)`。如果只有一个参数要传递，你只需传递那个参数，例如 `nums(200)`。如果没有参数要传递，你可以将其留空，例如 `nums()`。'
- en: Variadic functions can have other parameters. However, if your function requires
    multiple parameters, the variadic parameter must be the last in the function.
    Also, there can only be one variadic variable per function. The following function
    is incorrect and will result in an error at compile time as the variadic variable
    is not the last parameter of the function.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 可变函数可以有其他参数。然而，如果你的函数需要多个参数，可变参数必须是函数中的最后一个。此外，每个函数只能有一个可变变量。以下函数是不正确的，并且会在编译时出错，因为可变变量不是函数的最后一个参数。
- en: '**Incorrect function**:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误函数**：'
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The expected output is as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '![Figure 5.8: Variadic syntax error output](img/B18621_05_08.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8：可变语法错误输出](img/B18621_05_08.jpg)'
- en: 'Figure 5.8: Variadic syntax error output'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：可变语法错误输出
- en: '**Correct function**:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**正确函数**：'
- en: '[PRE46]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output will look as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You may have guessed by now that the actual type of `Type` inside the function
    is a slice. The function takes the arguments being passed in and converts them
    into the new slice being specified. For example, if the variadic type is `int`,
    then once you are inside the function, Go converts that variadic `int` type into
    a slice of integers:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经猜到了函数内部 `Type` 的实际类型是一个切片。该函数接收传入的参数并将它们转换为指定的新的切片。例如，如果可变类型是 `int`，那么一旦你进入函数，Go
    会将那个可变 `int` 类型转换为整数的切片：
- en: '![Figure 5.9: Converting a variadic int into a slice of integers](img/B18621_05_09.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9：将可变整型转换为整数切片](img/B18621_05_09.jpg)'
- en: 'Figure 5.9: Converting a variadic int into a slice of integers'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：将可变整型转换为整数切片
- en: 'Let’s make some tweaks to this example by having the `variadic` function take
    in integer values:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过让 `variadic` 函数接受整数值来调整这个示例：
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The variadic function’s output is as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 可变函数的输出如下：
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `nums()` function shows that the variadic type of `i` is a slice of integers.
    Once in the function, `i` will be a slice of integers. The variadic type has a
    length and capacity, which is to be expected for a slice. In the following code
    snippet, we will try to pass a slice of integers to a variadic function, `nums()`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`nums()` 函数显示 `i` 的可变类型是一个整数的切片。一旦进入函数，`i` 将会是一个整数的切片。可变类型具有长度和容量，这对于切片来说是预期的。在下面的代码片段中，我们将尝试将一个整数的切片传递给一个可变函数
    `nums()`：'
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The expected output is as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '![Figure 5.10: Variadic function error](img/B18621_05_10.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10：可变函数错误](img/B18621_05_10.jpg)'
- en: 'Figure 5.10: Variadic function error'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：可变函数错误
- en: 'Why didn’t this code snippet work? We just proved that the variadic variable
    inside the function is of the `slice` type. The reason is that the function expects
    a list of arguments of the `int` type to be converted into a slice. Variadic functions
    work by converting the arguments that are passed into a slice of the type being
    specified. However, Go has a mechanism for passing a slice to a variadic function.
    For this, we need to use the unpack operator; it is three dots (`…`). When you
    call a variadic function and you want to pass a slice as an argument to a variadic
    parameter, you need to place the three dots before the variable:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个代码片段不起作用？我们刚刚证明了函数内部的可变变量是 `slice` 类型。原因是该函数期望一个 `int` 类型的参数列表被转换成一个切片。可变函数通过将传入的参数转换成指定类型的切片来工作。然而，Go
    有一种将切片传递给可变函数的机制。为此，我们需要使用解包操作符；它是三个点（`…`）。当你调用一个可变函数，并且你想将一个切片作为参数传递给可变参数时，你需要在变量前放置三个点：
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The difference between this version of the function and the previous is the
    calling code to the function, `nums`. The three dots that are put after the `i`
    variable are a slice of integers. This allows a slice to be passed to the variadic
    function.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数版本与上一个版本的区别在于调用函数的代码，`nums` 函数。放在 `i` 变量后面的三个点是整数的切片。这允许将切片传递给可变函数。
- en: Exercise 5.05 – summing numbers
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.05 – 求和数字
- en: 'In this exercise, we are going to sum up a variable number of arguments. We
    will pass the arguments as a list of arguments and as a slice. The return value
    will be an `int` type – that is, the sum of the values we passed to the function.
    The following steps will help you with the solution:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将对可变数量的参数进行求和。我们将以参数列表和切片的形式传递参数。返回值将是 `int` 类型——即我们传递给函数的所有值的总和。以下步骤将帮助您找到解决方案：
- en: Open the IDE of your choice.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您选择的集成开发环境（IDE）。
- en: Create a new file in a new directory and save it as `main.go`.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新目录中创建一个新文件，并将其保存为 `main.go`。
- en: 'Enter the following code in `main.go`:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 文件中输入以下代码：
- en: '[PRE52]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `sum` function accepts a variadic argument of the `int` type. Since it
    gets converted into a slice, we can range over the values and return the sum of
    all the values that get passed:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sum` 函数接受一个可变数量的 `int` 类型参数。由于它被转换成了一个切片，我们可以遍历这些值并返回所有传入值的总和：'
- en: '[PRE53]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Open a terminal and navigate to the code’s directory.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并导航到代码目录。
- en: Run `go build` and run the executable.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go build` 并运行可执行文件。
- en: 'The expected output for summing numbers is as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 求和数字的预期输出如下：
- en: '[PRE54]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this exercise, we saw that by using a variadic parameter, we can accept an
    unknown number of arguments. Our function allows us to sum up any number of integers.
    We can see that variadic parameters can be utilized to solve specific problems
    where the number of values of the same type being passed as an argument is unknown.
    In the next section, we are going to look at how to create a function without
    a name and assign a function to a variable.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了通过使用可变参数，我们可以接受未知数量的参数。我们的函数允许我们求和任意数量的整数。我们可以看到，可变参数可以用于解决特定问题，其中作为参数传递的相同类型值的数量是未知的。在下一节中，我们将探讨如何创建一个没有名称的函数并将函数赋给一个变量。
- en: Anonymous functions
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: So far, we have been using named functions. As you may recall, named functions
    are functions that have an identifier or a function name. Anonymous functions,
    also referred to as function literals, are functions that do not have a function
    name, hence the name “anonymous functions.” An anonymous function is declared
    in a similar way to how a named function is declared. The only difference with
    the declaration is that the name for the function is omitted. Anonymous functions
    can do whatever a normal function in Go does, including accepting arguments and
    returning values. Anonymous functions can also be declared within another function.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用命名函数。如您所回忆的，命名函数是有标识符或函数名的函数。匿名函数，也称为函数字面量，是没有函数名的函数，因此得名“匿名函数”。匿名函数的声明方式与命名函数的声明方式类似。唯一的不同之处在于声明中省略了函数名。匿名函数可以执行
    Go 中普通函数所能做的任何事情，包括接受参数和返回值。匿名函数也可以在另一个函数内部声明。
- en: 'In this section, we will be introducing the fundamentals of anonymous functions
    and some of their basic uses. Later, you will see how anonymous functions can
    be fully utilized. Anonymous functions are used for (and in conjunction with)
    the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍匿名函数的基本原理及其一些基本用法。稍后，您将看到如何充分利用匿名函数。匿名函数用于（并与）以下：
- en: Closure implementations
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包实现
- en: '`defer` statements'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer` 语句'
- en: Defining a code block to be used with a goroutine
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个用于与 goroutine 一起使用的代码块
- en: Defining a function for one-time use
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个一次性使用的函数
- en: Passing a function to another function
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个函数传递给另一个函数
- en: 'The following is a basic declaration for an anonymous function:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个匿名函数的基本声明：
- en: '[PRE55]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let’s take a closer look:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看：
- en: Notice that we are declaring a function inside another function. As with named
    functions, you must start with the `func` keyword to declare a function.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，我们是在另一个函数内部声明一个函数。与命名函数一样，您必须以 `func` 关键字开始声明函数。
- en: Following the `func` keyword would normally be the name of the function, but
    with anonymous functions, there is no function name. Instead, there are empty
    parentheses.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `func` 关键字之后通常会跟函数名，但匿名函数没有函数名。相反，是空括号。
- en: The empty parentheses following the `func` keyword are where the function’s
    parameters would be defined for the function.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `func` 关键字之后的空括号是定义函数参数的地方。
- en: Next is the open curly brace, `{`, which starts the function body.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是开括号 `{`，它标志着函数体的开始。
- en: The function body is only a one-liner; it will print “`Greeting`”.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数体只有一行；它将打印 “`Greeting`”。
- en: The closing curly brace, `}`, denotes the end of the function.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结束的圆括号 `}` 表示函数的结束。
- en: The last set of parentheses is called the execution parentheses. These parentheses
    invoke the anonymous function. The function will execute immediately. Later, we
    will see how to execute an anonymous function at a later location within the function.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的一组括号称为执行括号。这些括号调用匿名函数。函数将立即执行。稍后，我们将看到如何在函数内的其他位置执行匿名函数。
- en: 'You can also pass arguments to an anonymous function. To be able to pass arguments
    to an anonymous function, they must be supplied in the execution parentheses:'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以向匿名函数传递参数。要能够向匿名函数传递参数，它们必须在执行括号中提供：
- en: '[PRE56]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here, we have the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有以下内容：
- en: '`func (str string)`: The anonymous function being declared has an input parameter
    of the `string` type.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (str string)`: 正在声明的匿名函数有一个 `string` 类型的输入参数。'
- en: '`} (message)`: The argument message that’s being passed to the execution parentheses.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`} (message)`: 正在被传递到执行括号中的参数消息。'
- en: 'We have been executing anonymous functions as they are declared, but there
    are other ways to execute anonymous functions. You can also save the anonymous
    function to a variable. This leads to a different set of opportunities that we
    will look at in this chapter:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直像声明时那样执行匿名函数，但还有其他执行匿名函数的方法。您还可以将匿名函数保存到变量中。这导致了一系列不同的机会，我们将在本章中探讨：
- en: '[PRE57]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let’s take a closer look:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看：
- en: We are assigning the `f` variable to our anonymous function.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在将 `f` 变量分配给我们的匿名函数。
- en: '`f` is now of the `func()` type.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f` 现在是 `func()` 类型。'
- en: '`f` can now be used to invoke the anonymous function, in a fashion similar
    to that for a named function. You must include `()` after the `f` variable to
    execute the function.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f` 现在可以用来调用匿名函数，方式与命名函数类似。在 `f` 变量后必须包含 `()` 来执行函数。'
- en: Exercise 5.06 – creating an anonymous function to calculate the square root
    of a number
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.06 – 创建一个计算数字平方根的匿名函数
- en: 'Anonymous functions are great for small snippets of code that you want to execute
    within a function. Here, we are going to create an anonymous function that is
    going to have an argument passed to it. It will then calculate the square root.
    The following steps will help you with the solution:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数非常适合执行函数内的小段代码。在这里，我们将创建一个匿名函数，该函数将接受一个参数。然后它将计算平方根。以下步骤将帮助您找到解决方案：
- en: Use the IDE of your choice.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的 IDE。
- en: Create a new file and save it as `main.go`.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件并将其保存为 `main.go`。
- en: 'Enter the following code in `main.go`. We are assigning our `x` variable to
    our anonymous function. Our anonymous function takes a parameter, `(i int)`. It
    also returns a value of `int`:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中输入以下代码。我们将我们的 `x` 变量分配给我们的匿名函数。我们的匿名函数接受一个参数 `(i int)`。它还返回一个 `int`
    类型的值：
- en: '[PRE58]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Notice that the last curly brace does not have `()` to execute the function.
    We call our anonymous function using `x(j)`:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到最后的大括号没有 `()` 来执行函数。我们使用 `x(j)` 调用我们的匿名函数：
- en: '[PRE59]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Open a terminal and navigate to the code’s directory.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并导航到代码目录。
- en: Run `go build` and run the executable.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go build` 并运行可执行文件。
- en: 'The expected output is as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE60]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this exercise, we saw how to assign a variable to a function and later call
    that function by using the variable that was assigned to it. We saw that when
    we need a small function that might not be reusable in our program, we can create
    an anonymous function and assign it to a variable. In the next section, we are
    going to expand the use of anonymous functions to closures.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何将变量分配给函数，然后通过分配给它的变量调用该函数。我们看到，当我们需要一个可能不在程序中可重用的简单函数时，我们可以创建一个匿名函数并将其分配给一个变量。在下一节中，我们将扩展匿名函数的使用到闭包。
- en: Closures
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: So far, we have introduced anonymous function syntax using some basic examples.
    Now that we have a fundamental understanding of how anonymous functions work,
    we will look at how we can use this powerful concept.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过一些基本示例介绍了匿名函数的语法。现在，我们对匿名函数的工作原理有了基本的理解，我们将探讨如何使用这个强大的概念。
- en: 'Closures are a form of anonymous functions. Regular functions cannot reference
    variables outside of themselves; however, an anonymous function can reference
    variables external to their definition. A closure can use variables declared at
    the same level as the anonymous function’s declaration. These variables do not
    need to be passed as parameters. The anonymous function has access to these variables
    when it is called:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是一种匿名函数的形式。常规函数不能引用自身之外的变量；然而，匿名函数可以引用其定义之外的变量。闭包可以使用与匿名函数声明同一级别的变量。这些变量不需要作为参数传递。当匿名函数被调用时，它可以访问这些变量：
- en: '[PRE61]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**Code synopsis**:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码摘要**:'
- en: We initialize a variable in the `main()` function called `i` and set it to `0`.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中初始化一个名为`i`的变量并将其设置为`0`。
- en: We assign `incrementor` to our anonymous function.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`incrementor`赋值给我们的匿名函数。
- en: The anonymous function increments `i` and returns it. Notice that our function
    does not have any input parameters.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匿名函数增加`i`的值并返回它。请注意，我们的函数没有任何输入参数。
- en: Then, we print the results of `incrementor` twice and get `1` and `2`.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们两次打印`incrementor`的结果，得到`1`和`2`。
- en: Notice that, outside our function, we increment `i` by `10`. This is a problem.
    We want `i` to be isolated and for it not to change as this is not the desired
    behavior. When we print the results of `incrementor` again, it will be `12`. We
    want it to be `3`. We will correct this in our next example.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在我们的函数外部，我们通过`i`增加`10`。这是一个问题。我们希望`i`是隔离的，并且它不应该改变，因为这不是我们想要的行为。当我们再次打印`incrementor`的结果时，它将是`12`。我们希望它是`3`。我们将在下一个示例中纠正这个问题。
- en: 'One problem with the previous example that we noticed is that any code in the
    main function has access to `i`. As we saw in the example, `i` can be accessed
    and changed outside of our function. This is not the desired behavior; we want
    the incrementor to be the only one to change that value. In other words, we want
    `i` to be protected from other functions changing it. The only function that should
    be changing is our anonymous function when we call it:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到上一个示例中的一个问题是，主函数中的任何代码都可以访问`i`。正如我们在示例中看到的，`i`可以在函数外部被访问和更改。这不是我们想要的行为；我们希望递增器是唯一可以更改该值的函数。换句话说，我们希望`i`被保护，防止其他函数更改它。唯一应该更改的是当我们调用它时我们的匿名函数：
- en: '[PRE62]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**Code synopsis**:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码摘要**:'
- en: We declared a function called `incrementor()`. This function has a return type
    of `func() int`.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了一个名为`incrementor()`的函数。此函数的返回类型为`func() int`。
- en: Using `i := 0`, we initialize our variable at the level of the `incrementor()`
    function; this is similar to what we did in the previous example, except it was
    at the `main()` function level and anyone at that level had access to `i`. Only
    the `incrementor()` function has access to the `i` variable with this implementation.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`i := 0`，我们在`incrementor()`函数级别初始化我们的变量；这与我们在上一个示例中所做类似，只是它是在`main()`函数级别，任何人都可以访问`i`。只有`incrementor()`函数可以访问这个实现中的`i`变量。
- en: We are returning our anonymous function, `func() int`, which increments the
    `i` variable.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们返回我们的匿名函数`func() int`，该函数增加`i`变量。
- en: In the `main()` function, `increment := incrementor()` assigns a variable to
    `func() int` that gets returned. It is important to note that `incrementor()`
    only gets executed once here. In our `main()` function, it is no longer being
    referenced or executed.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，`increment := incrementor()`将一个变量赋值给返回`func() int`类型的`func()`。重要的是要注意，在这里`incrementor()`只执行一次。在我们的`main()`函数中，它不再被引用或执行。
- en: '`increment()` is of the `func() int` type. Each call to `increment()` runs
    the anonymous function code. It is referencing the `i` variable, even after `incrementor()`
    has been executed.'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`increment()`是`func() int`类型。每次调用`increment()`都会运行匿名函数代码。它引用了`i`变量，即使`incrementor()`已经执行完毕。'
- en: 'The preceding example demonstrated how we can protect our variable by wrapping
    it with an anonymous function, thereby restricting access to updating the variable
    only through invoking the anonymous function itself. This is shown through the
    expected output, where we’ve incremented `i` twice, as follows:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例演示了我们可以通过将匿名函数包装起来来保护我们的变量，从而仅通过调用匿名函数本身来限制对更新变量的访问。这通过预期的输出显示，我们已将`i`增加了两次，如下所示：
- en: '[PRE63]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Exercise 5.07 – creating a closure function to decrement a counter
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.07 – 创建一个用于递减计数器的闭包函数
- en: 'In this exercise, we are going to create a closure that decrements from a given
    starting value. We will combine what we have learned about passing an argument
    to an anonymous function and use that knowledge with a closure. The following
    steps will help you with the solution:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个从给定起始值递减的闭包。我们将结合我们关于将参数传递给匿名函数的知识，并使用这些知识来使用闭包。以下步骤将帮助您找到解决方案：
- en: Open the IDE of your choice.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您选择的 IDE。
- en: Create a new file in a new directory and save it as `main.go`.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新目录中创建一个新文件，并将其保存为 `main.go`。
- en: 'Enter the following code in `main.go`:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中输入以下代码：
- en: '[PRE64]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We will look at the `decrement` function first. It takes an argument of the
    `int` type and has a return value of `func()int`. In previous examples, the variable
    was declared inside the function but before the anonymous function. In this exercise,
    we have it as an input parameter:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将查看 `decrement` 函数。它接受一个 `int` 类型的参数，并有一个返回值为 `func()int` 的值。在先前的例子中，变量是在函数内部声明的，但在匿名函数之前。在这个练习中，我们将其作为输入参数：
- en: '[PRE65]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We decrement `i` by one inside the anonymous function:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在匿名函数内部将 `i` 减去一：
- en: '[PRE66]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the `main()` function, we initialize a variable counter to be used as our
    starting integer to be decremented:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们初始化一个名为 `counter` 的变量，用作要递减的起始整数：
- en: '[PRE67]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Here, we have `x:= decrement(counter)`; `x` is assigned to `func() int`. Each
    call to `x()` runs the anonymous function:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们有 `x:= decrement(counter)`；`x` 被分配为 `func() int`。每次调用 `x()` 都会运行匿名函数：
- en: '[PRE68]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Open a terminal and navigate to the code’s directory.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并导航到代码目录。
- en: Run `go build` and run the executable.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go build` 并运行可执行文件。
- en: 'The expected output for the `decrement` counter is as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`decrement` 计数器的预期输出如下：'
- en: '[PRE69]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In this exercise, we saw that closures have access to variables that are external
    to them. This allowed our anonymous function to make changes to the variable that
    a normal function would not be able to make. In the next section, we are going
    to look at how functions can be passed as arguments to another function.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了闭包可以访问它们外部变量的情况。这使得我们的匿名函数能够对正常函数无法修改的变量进行修改。在下一节中，我们将探讨函数如何作为参数传递给另一个函数。
- en: Function types
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数类型
- en: 'As we have seen so far, Go has rich feature support for functions. In Go, functions
    are types too, just like `int`, `string`, and `bool` are types. This means we
    can pass functions as arguments to other functions, functions can be returned
    from a function, and functions can be assigned to variables. We can even define
    our own function types. A function’s type signature defines the types of its input
    parameters and return values. For a function to be of the type of another function,
    it must have the exact signature of the type ’unction that is declared. Let’s
    examine a few function types:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Go 对函数有丰富的功能支持。在 Go 中，函数也是类型，就像 `int`、`string` 和 `bool` 是类型一样。这意味着我们可以将函数作为参数传递给其他函数，函数可以从函数中返回，函数可以被分配给变量。我们甚至可以定义自己的函数类型。函数的类型签名定义了其输入参数和返回值的类型。为了使一个函数成为另一个函数的类型，它必须具有声明类型
    `func` 的确切签名。让我们检查一些函数类型：
- en: '[PRE70]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The preceding code snippet creates a new function type called `message`. It
    has no input parameters and does not have any return types.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段创建了一个名为 `message` 的新函数类型。它没有输入参数，也没有任何返回类型。
- en: 'Let’s examine another one:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再检查一个例子：
- en: '[PRE71]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The preceding code snippet creates a new function type called `calc`. It accepts
    two arguments of the `int` type and its return value is of the `string` type.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段创建了一个名为 `calc` 的新函数类型。它接受两个 `int` 类型的参数，其返回值是 `string` 类型。
- en: 'Now that we have a fundamental understanding of function types, we can write
    some code to demonstrate their uses:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对函数类型有了基本理解，我们可以编写一些代码来演示它们的用法：
- en: '[PRE72]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Let’s look at the code by the line:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看代码：
- en: '[PRE73]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`type calc` declares `calc` to be of the `func` type, determining that it takes
    two integers as arguments and returns a string:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`type calc` 声明 `calc` 为 `func` 类型，确定它接受两个整数作为参数并返回一个字符串：'
- en: '[PRE74]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`func add(i,j int) string` has the same signature as the `calc` type. It takes
    two integers as arguments and returns a string stating “Adding `i + j = result`.”
    Functions can be passed to other functions, just like any other type in Go:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`func add(i,j int) string` 与 `calc` 类型具有相同的签名。它接受两个整数作为参数，并返回一个字符串，表示“`i +
    j = result`”。函数可以像 Go 中的任何其他类型一样传递给其他函数：'
- en: '[PRE75]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`func calculator(f calc, i, j int)` accepts `calc` as input. The `calc` type,
    as you may remember, is a function type that has input parameters of `int` and
    a return type of `string`. Anything that matches that signature can be passed
    to the function. The `func calculator` function returns the result of the function
    of the `calc` type.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`func calculator(f calc, i, j int)` 接受 `calc` 作为输入。你可能记得，`calc` 类型是一个具有 `int`
    输入参数和 `string` 返回类型的函数类型。任何匹配该签名的都可以传递给该函数。`func calculator` 函数返回 `calc` 类型函数的结果。'
- en: In the `main` function, we call `calculator(add, 5, 6)`. We are passing it the
    `add` function. `add` satisfies the signature of the `calc` `func` type.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们调用 `calculator(add, 5, 6)`。我们传递给它 `add` 函数。`add` 满足 `calc` `func`
    类型的签名。
- en: '*Figure 5**.11* summarizes each of the preceding functions and how they relate
    to each other. This figure shows how `func add` is of the `func calc` type, which
    then allows it to be passed as an argument to `func calculator`:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.11* 总结了前面每个函数及其相互关系。此图显示了 `func add` 是 `func calc` 类型，这允许它作为参数传递给 `func
    calculator`：'
- en: '![Figure 5.11: Function types and uses](img/B18621_05_11.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11：函数类型和用途](img/B18621_05_11.jpg)'
- en: 'Figure 5.11: Function types and uses'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：函数类型和用途
- en: 'We have just seen how to create a function type and pass it as an argument
    to a function. It is not that far of a stretch to pass a function as a parameter
    to another function. We will change our previous example slightly to reflect passing
    a function as a parameter:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何创建一个函数类型并将其作为参数传递给函数。将函数作为参数传递给另一个函数并不是那么遥远。我们将稍微修改之前的例子，以反映将函数作为参数传递：
- en: '[PRE76]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let’s take a closer look:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看：
- en: We modified the `add` function signature so that it returns an `int` type instead
    of a `string` type.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们修改了 `add` 函数签名，使其返回 `int` 类型而不是 `string` 类型。
- en: 'We added a second function called `subtract`. Note that its function signature
    is the same as that of the `add` function. The `subtract` function simply returns
    the result of subtracting two numbers:'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个名为 `subtract` 的第二个函数。请注意，它的函数签名与 `add` 函数相同。`subtract` 函数简单地返回两个数字相减的结果：
- en: '[PRE77]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, we have `calculator(f func(int, int) int, i, j int)`. The `calculator`
    function now has an input parameter of the `func` type. The input parameter, `f`,
    is a function that accepts two integers and returns an `int` type. Any function
    that satisfies the signature can be passed to the function.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里，我们有 `calculator(f func(int, int) int, i, j int)`。现在 `calculator` 函数有一个 `func`
    类型的输入参数。输入参数 `f` 是一个接受两个整数并返回 `int` 类型的函数。任何满足该签名的函数都可以传递给该函数。
- en: 'In the `main()` function, `calculator` is called twice: once with the `add`
    function and some integer values being passed and once with the `subtract` function
    being passed as an argument with some integer values.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，`calculator` 被调用了两次：一次是用 `add` 函数和一些整数值传递，另一次是用 `subtract` 函数作为参数传递，并带有一些整数值。
- en: 'The expected output is as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE78]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The ability to pass functions as a type is a powerful feature where you can
    pass functions to other functions if their signatures match the passed-to function’s
    input parameter. An integer type for a function can be any value if it is an integer.
    The same goes for passing functions: a function can be any value if it is the
    correct type.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数作为类型传递的能力是一个强大的功能，其中你可以将函数传递给其他函数，如果它们的签名与传递给函数的输入参数匹配。如果是一个整数类型，函数可以传递任何值。对于传递函数也是如此：如果类型正确，函数可以是任何值。
- en: 'A function can also be returned from another function. We saw this when using
    anonymous functions combined with closures. Here, we will take a brief look since
    we saw this syntax previously:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以从另一个函数中返回。我们在使用匿名函数与闭包结合时看到了这一点。在这里，我们将简要地看一下，因为我们之前已经看到了这个语法：
- en: '[PRE79]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Returning a function looks as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 返回函数看起来如下：
- en: '[PRE80]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here, we have `square(x int) func() int`. The `square` function accepts an
    `int` type as an argument and returns a function type that returns an `int` type:'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里，我们有 `square(x int) func() int`。`square` 函数接受一个 `int` 类型的参数，并返回一个返回 `int`
    类型的函数类型：
- en: '[PRE81]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In the `square` body, we assign a variable, `f`, to an anonymous function that
    returns the square value of the input parameter, `x`.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `square` 函数体中，我们将变量 `f` 赋值为一个匿名函数，该函数返回输入参数 `x` 的平方值。
- en: The `return` statement for the `square` function returns an anonymous function
    that is of the `func()` `int` type.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`square` 函数的 `return` 语句返回一个匿名函数，该函数是 `func()` `int` 类型。'
- en: '`v` is assigned to the return of the `square` function. As you may recall,
    the return value is of the `func()` `int` type.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v` 被分配给 `square` 函数的返回值。如您所回忆的，返回值是 `func() int` 类型。'
- en: '`v` has been assigned the `func ()int` type; however, it has not been invoked.
    We will invoke it inside the `print` statement.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v` 被分配了 `func ()int` 类型；然而，它尚未被调用。我们将在 `print` 语句中调用它。'
- en: 'Finally, we have `fmt.Printf("Type of v: %T",v)`. This statement just prints
    out the type for `v`, which is `func()int`.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '最后，我们有 `fmt.Printf("Type of v: %T",v)`。这个语句只是打印出 `v` 的类型，它是 `func()int`。'
- en: Exercise 5.08 – creating various functions to calculate salary
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.08 – 创建各种函数以计算薪资
- en: 'In this exercise, we are going to be creating several functions. We need the
    ability to calculate the salary of a developer and a manager. We want this solution
    to be extensible for the future possibilities of other salaries to be calculated.
    We will be creating functions to calculate the developer’s and manager’s salary.
    Then, we will create another function that will take the previously mentioned
    function as an input parameter. The following steps will help you with the solution:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建几个函数。我们需要能够计算开发人员和经理的薪资。我们希望这个解决方案能够扩展到未来计算其他薪资的可能性。我们将创建计算开发人员和经理薪资的函数。然后，我们将创建另一个函数，它将接受前面提到的函数作为输入参数。以下步骤将帮助您找到解决方案：
- en: Use the IDE of your choice.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的 IDE。
- en: Create a new file in a new directory and save it as `main.go`.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新目录中创建一个新文件，并将其保存为 `main.go`。
- en: 'Enter the following code in `main.go`:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中输入以下代码：
- en: '[PRE82]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `salary` function accepts a function that accepts two integers as arguments
    and returns an int `type`. So, any function that matches that signature can be
    passed as an argument to the `salary` function:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`salary` 函数接受一个接受两个整数作为参数并返回 int 类型的函数。因此，任何匹配该签名的函数都可以作为参数传递给 `salary` 函数：'
- en: '[PRE83]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In the body of the `salary()` function, `pay`, is assigned the value that gets
    returned from the `f` function. It passes `x` and `y` as parameters to the `f`
    parameter:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `salary()` 函数的主体中，`pay` 被分配给从 `f` 函数返回的值。它将 `x` 和 `y` 作为参数传递给 `f` 参数：
- en: '[PRE84]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Notice that the `managerSalary` and `developerSalary` signatures are identical
    and that they match the `f` function for `salary`. This means that both `managerSalary`
    and `developerSalary` can be passed as `func(int,` `int) int`:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到 `managerSalary` 和 `developerSalary` 的签名是相同的，并且与 `salary` 的 `f` 函数匹配。这意味着
    `managerSalary` 和 `developerSalary` 都可以作为 `func(int, int) int` 传递：
- en: '[PRE85]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '`devSalary` and `bossSalary` get assigned to the results of the `salary` function.
    Since `developerSalary` and `managerSalary` satisfy the signature of `func(int,
    int) int`, they can both be passed in as arguments:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`devSalary` 和 `bossSalary` 被分配给 `salary` 函数的结果。由于 `developerSalary` 和 `managerSalary`
    满足 `func(int, int) int` 的签名，它们都可以作为参数传递：'
- en: '[PRE86]'
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Open a terminal and navigate to the code’s directory.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并导航到代码目录。
- en: Run `go build` and run the executable.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go build` 并运行可执行文件。
- en: 'The expected output is as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '[PRE87]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In this exercise, we saw how a function type can be a parameter for another
    function. This allows a function to be an argument to another function. This exercise
    showed how our code can be simplified by having one `salary` function. If, in
    the future, we need to calculate the salary for a tester position, we would only
    need to create a function that matches the function type for `salary` and pass
    it as an argument. The flexibility that this gives is that we do not have to change
    our `salary` function’s implementation. In the next section, we are going to see
    how we can change the execution flow of a function, specifically after the function
    returns.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了函数类型可以作为另一个函数的参数。这允许函数作为另一个函数的参数。这个练习展示了如何通过有一个 `salary` 函数来简化我们的代码。如果将来我们需要计算测试员的薪资，我们只需要创建一个与
    `salary` 函数类型匹配的函数，并将其作为参数传递。这种灵活性意味着我们不需要更改 `salary` 函数的实现。在下一节中，我们将看到如何改变函数的执行流程，特别是函数返回之后。
- en: defer
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟调用
- en: 'The `defer` statement defers the execution of a function until the surrounding
    function returns. Let’s try to explain this a bit better. Inside a function, you
    have a `defer` statement in front of a function that you are calling. Essentially,
    that function will execute right before the function you are currently inside
    completes. Still confused? Perhaps an example will make this concept a little
    clearer:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer`语句将函数的执行推迟到周围函数返回。让我们试着更好地解释这一点。在函数内部，你有一个在调用函数之前的`defer`语句。本质上，该函数将在你当前所在的函数完成之前执行。还是不明白？或许一个例子会使这个概念更清晰一些：'
- en: '[PRE88]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The output for the `defer` example is as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer`示例的输出如下：'
- en: '[PRE89]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Inside the `main()` function, we have a deferred function, `defer done()`. Notice
    that the `done()` function has no new or special syntax. It just does a simple
    print to the console.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数内部，我们有一个延迟函数，`defer done()`。请注意，`done()`函数没有新的或特殊的语法。它只是简单地打印到控制台。
- en: Next, we have two `print` statements. The results are interesting. The two `print`
    statements in the `main()` function print first. Even though the deferred function
    was first in `main()`, it printed last. Isn’t that interesting? Its ordering in
    the `main()` function did not dictate its order of execution.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有两个`print`语句。结果很有趣。`main()`函数中的两个`print`语句首先打印。尽管延迟函数在`main()`中是第一个，但它最后打印。这不是很有趣吗？在`main()`函数中的顺序并没有决定它的执行顺序。
- en: These deferred functions are commonly used for performing “cleanup” activities.
    This includes releasing resources, closing files, closing database connections,
    and removing `configuration\temp` files created by a program. `defer` functions
    are also used to recover from a panic; this will be discussed later in this book.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这些延迟执行的函数通常用于执行“清理”活动。这包括释放资源、关闭文件、关闭数据库连接以及删除程序创建的`configuration\temp`文件。`defer`函数也用于从恐慌中恢复；这将在本书的后面讨论。
- en: 'Using the `defer` statement is not limited to just named functions – you can
    also utilize the `defer` statement with anonymous functions. Taking our previous
    code snippet, let’s turn it into a deferred call with an anonymous function:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`defer`语句不仅限于命名函数——你还可以使用匿名函数的`defer`语句。以我们之前的代码片段为例，让我们将其转换为使用匿名函数的延迟调用：
- en: '[PRE90]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Let’s take a closer look:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看：
- en: There’s not much that has changed from the previous code. We took the code that
    was in the `done` function and created a deferred anonymous function.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与之前的代码相比，变化不大。我们将`done`函数中的代码提取出来，创建了一个延迟的匿名函数。
- en: The `defer` statement is placed before the `func()` keyword. Our function has
    no function name. As you may recall, a function without a name is an anonymous
    function.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer`语句放置在`func()`关键字之前。我们的函数没有函数名。如您所回忆的那样，没有名称的函数是匿名函数。'
- en: The results are the same as those from the previous example. Its readability,
    to a certain extent, is easier than having the deferred function declared as a
    named function, as in the previous example.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果与上一个示例相同。在一定程度上，它的可读性比将延迟函数声明为命名函数更容易，就像上一个示例中那样。
- en: 'It is also possible and common to have multiple `defer` statements in a function.
    However, they may not execute in the order that you expect. When using `defer`
    statements in front of functions, the execution follows the order of `defer` statement
    placed in front of them:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个函数中同时拥有多个`defer`语句也是可能且常见的。然而，它们可能不会按照您预期的顺序执行。当在函数前使用`defer`语句时，执行顺序遵循它们之前放置的`defer`语句的顺序：
- en: '[PRE91]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The multiple `defer` output looks as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 多个`defer`的输出如下：
- en: '[PRE92]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Let’s take a closer look:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看：
- en: The first three anonymous functions have their execution deferred.
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前三个匿名函数的执行被推迟。
- en: We declare `f1` and `f2` to be of the `func()` type. These two functions are
    anonymous.
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`f1`和`f2`声明为`func()`类型。这两个函数是匿名的。
- en: As you can see, `f1()` and `f2()` executed as expected, but the order of the
    multiple `defer` statements executed in the reverse order of how they were declared
    in the code. The first `defer` statement was the last to execute and the last
    `defer` statement was the first to execute.
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如您所见，`f1()`和`f2()`按预期执行，但多个`defer`语句的执行顺序与它们在代码中声明的顺序相反。第一个`defer`语句是最后一个执行的，而最后一个`defer`语句是第一个执行的。
- en: 'Careful consideration must be given when using `defer` statements. A situation
    that you should consider is when you use `defer` statements in conjunction with
    variables. When a variable is passed to a deferred function, the variable’s value
    at that time is what will be used in the deferred function. If that variable is
    changed after the deferred function, it will not be reflected when the deferred
    function runs:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`defer`语句时必须谨慎考虑。你应该考虑的情况之一是当你在变量上使用`defer`语句。当一个变量传递给延迟函数时，该变量在该时刻的值将在延迟函数中使用。如果该变量在延迟函数之后被更改，则更改后的值不会在延迟函数运行时反映出来：
- en: '[PRE93]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The output would be as follows:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE94]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Let’s take a closer look:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看：
- en: '`age := 25`: We initialize the `age` variable to `25` before the `defer` function.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`age := 25`：在`defer`函数之前，我们将`age`变量初始化为`25`。'
- en: '`name := "John"`: We initialize the `name` variable to `"John"` before the
    `defer` function.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name := "John"`：在`defer`函数之前，我们将`name`变量初始化为`"John"`。'
- en: '`defer personAge(name, age)`: We state that the function is going to be deferred.'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer personAge(name, age)`：我们声明该函数将被延迟调用。'
- en: '`age *= 2`: We double the age after the deferred function. Then, we print the
    current value of `age` doubled.'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`age *= 2`：在`defer`函数之后，我们将年龄翻倍。然后，我们打印出翻倍后的当前`age`值。'
- en: '`personAge(name string, i int)`: This is the function that is deferred; it
    only prints out the person and age.'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`personAge(name string, i int)`：这是被延迟调用的函数；它只打印出人员和年龄。'
- en: The results show the value of `age (25)` after it has been doubled in the `main`
    function.
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果显示了在`main`函数中将`age`翻倍后的值。
- en: When the execution of the program reaches the line that has `defer` `personAge(name,
    age)`, the value of `age` is `25`. Before the `main()` function completes, the
    deferred function runs and the value of `age` is still `25`. Variables used in
    the deferred function are the values before it was deferred, regardless of what
    happens after it.
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当程序执行到达包含`defer personAge(name, age)`的行时，`age`的值为`25`。在`main()`函数完成之前，延迟函数运行，`age`的值仍然是`25`。在延迟函数中使用的变量是延迟之前的值，无论之后发生什么。
- en: Activity 5.02 – calculating the payable amount for employees based on working
    hours
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动第5.02节 - 根据工作时间计算员工的应付款项
- en: 'This activity is based on the previous activity. We will keep the same functionality,
    but we will be adding three additional features. In this version of the application,
    we would like to give the employee the ability to track their hours throughout
    the day without having logged them yet. This will allow the employees to keep
    better track of their hours before they log them at the end of the day. We will
    also enhance the application so that it calculates the employee’s pay. The application
    will calculate their pay for any overtime they’ve worked. The application will
    also print out details of how many hours were worked each day:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动基于上一个活动。我们将保持相同的功能，但将增加三个额外功能。在本版本的应用程序中，我们希望赋予员工在尚未记录的情况下跟踪他们一天中工作时间的权限。这将使员工在一天结束时记录时间之前能更好地跟踪他们的工作时间。我们还将增强应用程序，以便计算员工的工资。应用程序将计算他们加班工作的工资。应用程序还将打印出每天工作了多少小时的详细信息：
- en: Create a function called `nonLoggedHours() func(int) int`. Each time this function
    is called, it will calculate the hours of the employee that have not been logged.
    You will be using a closure inside the function.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`nonLoggedHours() func(int) int`的函数。每次调用此函数时，它将计算员工未记录的工作时间。你将在函数内部使用闭包。
- en: Create a method called `PayDay()(int,bool)`. This method will calculate the
    weekly pay. It needs to consider overtime pay. The method will pay twice the hourly
    rate for hours greater than 40\. The function will return `int` as the weekly
    pay and `bool` if the pay is overtime pay. The Boolean value will be true if the
    employee worked more than `40` hours and false if they worked less than `40` hours.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PayDay()(int,bool)`的方法。此方法将计算每周的工资。它需要考虑加班工资。对于超过40小时的工作时间，此方法将支付双倍的小时费率。该函数将返回`int`类型的每周工资和`bool`类型的加班工资。如果员工工作超过40小时，布尔值将为true；如果他们工作少于40小时，则为false。
- en: Create a method called `PayDetails()`. This method will print each day and the
    hours worked that day by the employee. It will print the total hours for the week,
    the pay for the week, and if the pay contains overtime pay.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PayDetails()`的方法。此方法将打印出员工每天的工作时间和当天的工作时间。它将打印出每周的总工作时间、每周的工资以及工资中是否包含加班工资。
- en: Inside the `main` function, initialize a variable of the `Developer` type. Assign
    a variable to `nonLoggedHours`. Print the variable that was assigned to `nonLoggedHours`
    with values of `2`, `3`, and `5`.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数内部，初始化一个 `Developer` 类型的变量。将变量分配给 `nonLoggedHours`。使用 `2`、`3` 和 `5`
    的值打印分配给 `nonLoggedHours` 的变量。
- en: 'Also, in the `main()` function, log the hours for the following days: Monday
    8, Tuesday 10, Wednesday 10, Thursday 10, Friday 6, and Saturday 8.'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在 `main()` 函数中，记录以下几天的工时：周一 8 小时，周二 10 小时，周三 10 小时，周四 10 小时，周五 6 小时，以及周六
    8 小时。
- en: Finally, run the `PayDetails()` method.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行 `PayDetails()` 方法。
- en: 'The following is the expected output:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为预期输出：
- en: '![Figure 5.12: Output for the payable amount activity](img/B18621_05_12.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12：可支付金额活动的输出](img/B18621_05_12.jpg)'
- en: 'Figure 5.12: Output for the payable amount activity'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12：可支付金额活动的输出
- en: Note
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05/Activity05.02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05/Activity05.02).'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在本章 GitHub 仓库文件夹中找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05/Activity05.02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter05/Activity05.02)。
- en: This activity aims to go a step further than *Activity 5.01 – calculating the
    working hours of employees*, by using some more advanced programming with Go’s
    functions. In this activity, we continued to use functions, as we did previously;
    however, we returned multiple values and returned a function from a function.
    We also demonstrated the use of closures for calculating hours not logged by an
    employee.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动旨在比 *活动 5.01 – 计算员工的工作时间* 更进一步，通过使用 Go 函数的一些更高级编程来实现。在这个活动中，我们继续使用函数，就像我们之前做的那样；然而，我们返回了多个值，并从函数中返回了一个函数。我们还展示了如何使用闭包来计算未记录的员工小时数。
- en: Separating similar code
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离相似代码
- en: So far, we have covered a lot regarding functions since they are a vital aspect
    of what makes Go successful and flexible as a language. To continue with the idea
    of making flexible code for others to understand, iterate on, and work with, we
    will discuss how to expand this mentality.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经就函数进行了很多讨论，因为它们是使 Go 成功和灵活作为语言的关键方面之一。为了继续讨论为他人编写灵活的代码，以便他们可以理解、迭代和工作，我们将讨论如何扩展这种心态。
- en: In the world of software development, organizing code effectively is crucial
    for creating maintainable and scalable applications. In Go programming, one approach
    to achieving code organization is by separating related functions into different
    directories and utilizing multiple packages.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发的世界里，有效地组织代码对于创建可维护和可扩展的应用程序至关重要。在 Go 编程中，实现代码组织的一种方法是将相关函数分离到不同的目录中，并利用多个包。
- en: Thus far, we have been working with just one file to understand the fundamentals
    of Go. However, there is life beyond just a `main.go` file. We will briefly discuss
    ways Go developers keep in mind the reusability and cleanliness of their code,
    beyond the scope of functions. However, we will keep things at a high level at
    this point as we dive into the details of this when we cover Go modules.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用一个文件来理解 Go 的基础知识。然而，除了 `main.go` 文件之外，还有其他的生活。我们将简要讨论 Go 开发者如何记住他们的代码的可重用性和整洁性，这超出了函数的范围。然而，在介绍
    Go 模块时，我们将保持这一高度，以便我们深入探讨细节。
- en: A well-structured directory layout enhances code readability and maintainability.
    It allows developers to locate and work with specific functionality quickly. In
    Go, it is common to group related functions into separate directories based on
    their purpose, context, or domain. By organizing code into feature-based or domain-specific
    directories, developers can easily identify and modify code pertaining to a particular
    functionality. This separation fosters modularity and makes it easier to understand
    the application’s architecture.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的目录布局可以增强代码的可读性和可维护性。它允许开发者快速定位和操作特定的功能。在 Go 中，根据其目的、上下文或领域，将相关函数分组到单独的目录中是很常见的。通过将代码组织到基于功能或特定领域的目录中，开发者可以轻松地识别和修改与特定功能相关的代码。这种分离促进了模块化，并使理解应用程序的架构更容易。
- en: 'As projects grow in size and complexity, splitting code into functions and
    purposeful directories becomes essential for managing dependencies and reducing
    cognitive load. Large applications often benefit from a directory structure that
    aligns with the project’s modules or components. There are many benefits as to
    why you, as a developer, should care about separating your Go code into logical
    chunks:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目规模和复杂性的增长，将代码拆分为函数和有目的的目录对于管理依赖项和减少认知负荷变得至关重要。大型应用程序通常受益于与项目模块或组件对齐的目录结构。作为开发者，你应该关心将你的
    Go 代码分离成逻辑块的原因有很多：
- en: Enhanced code reusability
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强代码重用性
- en: Improved readability and maintainability
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高可读性和可维护性
- en: Testability and isolation
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试性和隔离性
- en: 'A concrete example of this can be seen in the following example:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个具体的例子：
- en: Use the IDE of your choice.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你选择的 IDE。
- en: Create a new file in a new directory and save it as `main.go`.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新目录中创建一个新文件，并将其保存为 `main.go`。
- en: 'Enter the following code in `main.go`:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中输入以下代码：
- en: '[PRE95]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The `calculateSalary`, `playGame`, and `getWeather` functions are independent
    of each other, each can contain complex logic, and they may rely on different,
    unrelated dependencies.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateSalary`、`playGame` 和 `getWeather` 函数彼此独立，每个都可以包含复杂的逻辑，并且它们可能依赖于不同的、无关的依赖项。'
- en: Placing the unrelated functions, and even withholding their actual logic, makes
    the code file bloated; it can become messy and unmanageable as you continue to
    iterate on the code and add logic. It could make sense to separate the three functions
    into their own files, such as `salary.go`, `game.go`, and `weather.go`. Eventually,
    you could separate them into different directories, and so forth, as you go.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 将无关的函数，甚至保留它们的实际逻辑，会使代码文件膨胀；随着你继续迭代代码并添加逻辑，它可能会变得杂乱无章，难以管理。将这三个函数分别放入它们自己的文件中，例如
    `salary.go`、`game.go` 和 `weather.go`，可能是合理的。最终，你可以随着项目的进展将它们分离到不同的目录中。
- en: It is important to start small, and then think about how you can separate similar
    code to continue writing manageable Go code that others can easily understand
    and iterate on. Again, this idea of code separation will be discussed in more
    detail when we cover Go modules since that is a vital way Go enables simple and
    reusable code.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是从小处着手，然后考虑如何将类似的代码分离出来，以继续编写其他人可以轻松理解和迭代的可管理的 Go 代码。再次强调，当我们在介绍 Go 模块时，将更详细地讨论代码分离的概念，因为这是
    Go 使代码简单且可重用的关键方式。
- en: Summary
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we studied why and how functions are an essential part of the
    Go programming language. We also discussed various features of functions in Go
    that make Go stand apart from other programming languages. Go has features that
    allow us to solve a lot of real-world problems and do so in a small, iterable,
    and manageable way. Functions in Go serve many purposes, including enhancing the
    usage and readability of code.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了为什么以及如何函数是 Go 编程语言的一个基本组成部分。我们还讨论了 Go 中函数的各种特性，这些特性使 Go 与其他编程语言区别开来。Go
    具有允许我们以小、可迭代和可管理的方式解决许多现实世界问题的特性。Go 中的函数服务于许多目的，包括增强代码的使用和可读性。
- en: Next, we learned how to create and call functions. We studied the various types
    of functions that are used in Go and discussed scenarios where each of the function
    types can be used. We also expounded on the concept of closures. Closures are
    essentially a type of anonymous function that can use variables declared at the
    same level as that at which the anonymous function was declared. Then, we discussed
    various parameters and return types and studied `defer`. We also discussed how
    to keep your code clean and separated such that similar logic can be packaged
    up nicely together. This mentality of thinking about how to reduce, reuse, and
    recycle your code will enable you to become a better developer.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们学习了如何创建和调用函数。我们研究了 Go 中使用的各种函数类型，并讨论了每种函数类型可以使用的场景。我们还详细阐述了闭包的概念。闭包本质上是一种匿名函数，它可以使用与匿名函数声明级别相同的变量。然后，我们讨论了各种参数和返回类型，并研究了
    `defer`。我们还讨论了如何保持代码的整洁和分离，以便可以将类似的逻辑打包在一起。这种思考如何减少、重用和回收代码的心态将使你成为一个更好的开发者。
- en: In the next chapter, we’ll explore errors and error types and learn how to build
    custom errors, thus building a recovery mechanism to handle errors in Go.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨错误和错误类型，并学习如何构建自定义错误，从而构建一个恢复机制来处理 Go 中的错误。
