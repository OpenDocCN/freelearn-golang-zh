<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer094">
			<h1 id="_idParaDest-204" class="chapter-number"><a id="_idTextAnchor1210"/>6</h1>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor1211"/>Don’t Panic! Handle Your Errors</h1>
			<p class="callout-heading"><a id="_idTextAnchor1212"/>Overview</p>
			<p class="callout">In this chapter, we will be looking at various code snippets from the Go standard packages to get an understanding of Go’s idiomatic way of performing error handling. We will also look at how to create custom error types in Go and see more examples in the <span class="No-Break">standard library.</span></p>
			<p class="callout">By the end of this chapter, you will be able to distinguish between the different types of errors and compare error handling and exception handling. You will also be able to create error values, <strong class="source-inline">panic()</strong>, and properly recover after a panic and handle your errors. Lastly, we will briefly discuss adding context to our errors through <span class="No-Break">error wrapping.</span></p>
			<h1 id="_idParaDest-206"><a id="_idTextAnchor1213"/>Technical requirements</h1>
			<p>For this chapter, you’ll require Go version 1.21 or higher. The code for this chapter can be found <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor1214"/><a id="_idTextAnchor1215"/>Introduction</h1>
			<p>In the previous chapter, we learned how to reduce, reuse, and recycle good code practices with Go through the help of functions, separating logical components, and more! We also discovered more regarding functions, such as the fact that functions can be passed as parameters and returned from a function. In this chapter, we will work with errors and learn how to return those <span class="No-Break">from functions.</span></p>
			<p>Developers are not perfect and, by extension, neither is the code that they produce. All software at some point in time has had errors. Handling errors is critical when you are developing software. These errors can have a negative impact of varying degrees on its users. The impact on the users of your software can be more far-reaching than <span class="No-Break">you realize.</span></p>
			<p>For instance, let’s consider the Northeast Blackout of 2003. On August 14, there was a blackout for about 50 million people in the United States and Canada that lasted for 14 days. This was due to a race condition bug in the alarm system in a control room. Technically, a race condition bug is when two separate threads try to access the same memory location for a write operation. This race condition can cause a program to crash. In this instance, it resulted in over 250 power plants going offline. One way to handle a race condition is to ensure proper synchronization between the various threads, or small units of execution within a process, and allow memory locations to be accessed for write operations by only one thread at a time. We will discuss concurrency in more detail later in this book; however, this example illustrates how it is important that we, as developers, ensure we handle errors properly so that we can try our best to avoid issues such as this. If we do not handle errors properly, this can harm the users of our application and their way of life, as seen by the power outage incident described here. Yes, this is an event from years ago; however, we should take the opportunity to learn from the past and work toward handling errors properly to avoid this in the future. Further information on the Northeast Blackout can be found <span class="No-Break">online: </span><a href="https://en.wikipedia.org/wiki/Northeast_blackout_of_2003"><span class="No-Break">https://en.wikipedia.org/wiki/Northeast_blackout_of_2003</span></a><span class="No-Break">.</span></p>
			<p>In this chapter, we will be looking at what an error is, what an error looks like in Go, and, more specifically, how to handle errors the Go way. Let’s <span class="No-Break">get started!</span></p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor1216"/><a id="_idTextAnchor1217"/>What are errors?</h1>
			<p>An error is something that causes your program to produce unintended results. Those unintended <a id="_idIndexMarker478"/>results could range from the application crashing, an incorrect data calculation (such as a bank transaction not being processed correctly), or not providing any results. These unintended results are referred to as software bugs. Any software will contain errors during its lifetime due to numerous scenarios that programmers do not anticipate. The following are possible outcomes when <span class="No-Break">errors occur:</span></p>
			<ul>
				<li>The erroneous code could cause the program to crash <span class="No-Break">without warning</span></li>
				<li>The output of the program was not the <span class="No-Break">intended result</span></li>
				<li>An error message <span class="No-Break">is displayed</span></li>
			</ul>
			<p>There are three types of errors that you <span class="No-Break">might encounter:</span></p>
			<ul>
				<li><span class="No-Break">Syntax errors</span></li>
				<li><span class="No-Break">Runtime errors</span></li>
				<li><span class="No-Break">Semantic errors</span><a id="_idTextAnchor1218"/><a id="_idTextAnchor1219"/></li>
			</ul>
			<p>Let’s explore each one in <span class="No-Break">more detail.</span></p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor1220"/>Syntax errors</h2>
			<p>Syntax errors result from improper use of the programming language. This often occurs due to <a id="_idIndexMarker479"/>mistyping the code. Most modern IDEs will have some visual way of bringing syntax errors to the attention of the programmer. In most modern IDEs, syntax errors <a id="_idIndexMarker480"/>can be caught at an early stage. They may occur more frequently when you are learning a new programming language. A few occurrences of syntax errors could be due to <span class="No-Break">the following:</span></p>
			<ul>
				<li>Incorrect use of syntax for <span class="No-Break">a loop</span></li>
				<li>Misplacing or omitting curly braces, parentheses, <span class="No-Break">or brackets</span></li>
				<li>Misspelled function names or <span class="No-Break">package names</span></li>
				<li>Passing the wrong type of argument to <span class="No-Break">a function</span></li>
			</ul>
			<p>Here is <a id="_idIndexMarker481"/>an example of a <span class="No-Break">syntax error:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
)
func main() {
  fmt.println("Enter your city:")
}</pre>			<p>The output appears <span class="No-Break">as follows:</span></p>
			<pre class="console">
fmt.println("Enter your city:")
cannot refer to unexported name fmt.println
undefined: fmt.println</pre>			<p>Go is case-sensitive, so <strong class="source-inline">println</strong> should <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">Println</strong></span><span class="No-Break">.</span></p>
			<p>Syntax errors are errors that you receive quick feedback on from <strong class="source-inline">golint</strong> that runs within your <a id="_idIndexMarker482"/>IDE thanks to the <strong class="source-inline">gopls</strong> language server. <strong class="source-inline">gopls</strong> is the official Go <a id="_idIndexMarker483"/>language server developed by the Google Go team and provides various language features, including code completion and diagnostics on syntax warnings and errors, as well as formatting issues. Working with Go code within an IDE <a id="_idIndexMarker484"/>that supports the <strong class="bold">Language Server Protocol</strong> (<strong class="bold">LSP</strong>) communicates with <strong class="source-inline">gopls</strong> to enable these features. <strong class="source-inline">golint</strong> itself is a separate command-line tool that can provide code analysis and can integrate with <strong class="source-inline">gopls</strong>. It is recommended to run your code through a linter before committing. This process is often <a id="_idIndexMarker485"/>automated when you’re opening up code for team members to review in a <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) environment so that team-based and/or larger projects all have good code <span class="No-Break">quality sta<a id="_idTextAnchor1221"/><a id="_idTextAnchor1222"/>ndards.</span></p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor1223"/>Runtime errors</h2>
			<p>These errors <a id="_idIndexMarker486"/>occur when the code is asked to perform a task that <a id="_idIndexMarker487"/>it cannot do. Unlike syntax errors, these are typically only found during the execution of <span class="No-Break">the code.</span></p>
			<p>The following are common examples of <span class="No-Break">runtime errors:</span></p>
			<ul>
				<li>Opening a connection to a database that does <span class="No-Break">not exist</span></li>
				<li>Performing a loop that is bigger than the number of elements in the slice or array you are <span class="No-Break">iterating over</span></li>
				<li>Opening a file that does <span class="No-Break">not exist</span></li>
				<li>Performing a mathematical operation, such as dividing a numbe<a id="_idTextAnchor1224"/><a id="_idTextAnchor1225"/>r <span class="No-Break">by zero</span></li>
			</ul>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor1226"/>Exercise 6.01 – runtime errors while adding numbers</h2>
			<p>In this exercise, we are going to write a simple program that sums up a slice of numbers. This program <a id="_idIndexMarker488"/>will demonstrate an example of a runtime error and will crash when it <span class="No-Break">is executed:</span></p>
			<ol>
				<li>Create a directory called <strong class="source-inline">Exercise06.01</strong> inside the <span class="No-Break"><strong class="source-inline">Chapter06</strong></span><span class="No-Break"> directory.</span></li>
				<li>Create a file called <strong class="source-inline">main.go</strong> inside the directory you created in <span class="No-Break"><em class="italic">step 1</em></span><span class="No-Break">.</span></li>
				<li>This program will be in <strong class="source-inline">package main</strong>. Import the <span class="No-Break"><strong class="source-inline">fmt</strong></span><span class="No-Break"> package:</span><pre class="source-code">
package main
import "fmt"</pre></li>				<li>Inside the <strong class="source-inline">main</strong> function, we will have a slice of integers that will have <span class="No-Break">four elements:</span><pre class="source-code">
func main() {
  nums := []int{2, 4, 6, 8}</pre></li>				<li>We will have a variable, <strong class="source-inline">total</strong>, to be used to sum all the integer variables in the slice. Use a <strong class="source-inline">for</strong> loop to sum <span class="No-Break">the variables:</span><pre class="source-code">
  total := 0
  for i := 0; i &lt;= 10; i++ {
    total += nums[i]
  }</pre></li>				<li>Next, we print the results of <span class="No-Break">the total:</span><pre class="source-code">
  fmt.Println("Total: ", total)
}</pre><p class="list-inset">With that, we have introduced an example of a runtime error to the program; so, we will not get the <span class="No-Break">following output:</span></p><pre class="source-code">Total: 20</pre></li>				<li>At the command line, navigate to the directory you created in <span class="No-Break"><em class="italic">step 1</em></span><span class="No-Break">.</span></li>
				<li>At the command line, type <span class="No-Break">the following:</span><pre class="source-code">
go build main.go</pre><p class="list-inset">The <strong class="source-inline">go build</strong> command will compile your program and create an executable named after the directory you created in <span class="No-Break"><em class="italic">step 1</em></span><span class="No-Break">.</span></p></li>				<li>Type the name of the file you created in <em class="italic">step 8</em> and hit <em class="italic">Enter</em> to run the ex<a id="_idTextAnchor1227"/>ecutable (Add the <strong class="source-inline">./main</strong> command). The expected output will be <span class="No-Break">as follows:</span></li>
			</ol>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B18621_06_01.jpg" alt="Figure 6.1: Output after executing" width="1547" height="200"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1: Output after executing</p>
			<p>As you can see, the program crashed. The <strong class="source-inline">index out of range</strong> panic is a common error to <a id="_idIndexMarker489"/>new Go developers and <span class="No-Break">veterans alike.</span></p>
			<p>In this example, the error – a panic (we will discuss what a panic is later in this chapter) in this program – is the result of iterating in the <strong class="source-inline">for</strong> loop by a greater number – in our case, 10 – than the actual number of elements in the slice – in our case, 4. One possible solution would be to use a <strong class="source-inline">for</strong> loop with <span class="No-Break">a range:</span></p>
			<pre class="source-code">
package main
import "fmt"
func main() {
  nums := []int{2, 4, 6, 8}
  total := 0
  for i := range nums {
    total += nums[i]
  }
  fmt.Println("Total: ", total)
}</pre>			<p>In this exercise, we saw how we can avoid runtime errors by paying attention to <span class="No-Break">minute details.</span></p>
			<p>To capture <a id="_idIndexMarker490"/>issues more easily before they become runtime errors, it is best to do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Properly test <span class="No-Break">your code</span></li>
				<li>Avoid <strong class="source-inline">nil</strong> <span class="No-Break">pointer dereferences</span></li>
				<li>Use proper input validation <span class="No-Break">as necessary</span></li>
				<li>Perform boundary checks to check bounds on data <span class="No-Break">before accessing</span></li>
				<li>Use proper <span class="No-Break">synchronization mechanisms</span></li>
				<li>Avoid <span class="No-Break">global state</span></li>
				<li>Use panic and <span class="No-Break">recover sparingly</span></li>
				<li>Conductor thorough code reviews <span class="No-Break">on teammates</span></li>
				<li>Use code linters <span class="No-Break">and analyzers</span></li>
				<li>Conduct version management <span class="No-Break">for dependencies</span></li>
			</ul>
			<p>While several of these include trying to be mindful of proper coding practices, many of them will also be discussed in subsequent chapters of<a id="_idTextAnchor1228"/><a id="_idTextAnchor1229"/> <span class="No-Break">this book.</span></p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor1230"/>Semantic errors</h2>
			<p>Syntax errors are the easiest to debug, followed by runtime errors, while logic errors are the hardest. Semantic <a id="_idIndexMarker491"/>errors are sometimes very hard to spot as they <a id="_idIndexMarker492"/>are a result of logical errors that can lead to <span class="No-Break">unexpected behavior.</span></p>
			<p>For example, in 1998, when the Mars Climate Orbiter was launched, its purpose was to study the climate of Mars, but due to a logic error in the system, the Mars Climate Orbiter, valued at $235 million, was destroyed. After some analysis, it was discovered that the calculations of units on the ground controller system were done in imperial units and the software on the Orbiter was done in metric units. This was a logic error that caused the navigation system to incorrectly calculate its maneuvers in space. As indicated by this historical tale of a semantic error, these are defects in the way code processes elements of a program. These types of errors are often caught at runtime. This is another illustration of the significant consequences erroneous code can cause since the <a id="_idIndexMarker493"/>Mars Climate Orbiter was very expensive and included many hours of <span class="No-Break">engineering efforts.</span></p>
			<p>Here are <a id="_idIndexMarker494"/>some reasons for semantic errors <span class="No-Break">to occur:</span></p>
			<ul>
				<li>Logical errors such as <span class="No-Break">incorrect computations</span></li>
				<li>Accessing incorrect resources (files, databases, servers, <span class="No-Break">and variables)</span></li>
				<li>Incorrect setting of variables for negation (not equal <span class="No-Break">versus equal)</span></li>
				<li>Type errors <span class="No-Break">on variables</span></li>
				<li>Incorrect use of functions, data structures, pointers, <a id="_idTextAnchor1231"/><a id="_idTextAnchor1232"/><span class="No-Break">and concurrency</span></li>
			</ul>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor1233"/>Exercise 6.02 – a semantic error with walking distance</h2>
			<p>We are writing an application that will determine whether we should walk to our destination <a id="_idIndexMarker495"/>or take a car. If our destination is greater than or equal to 2 km, we are going to take a car. If it is less than 2 km, then we will walk to our destination. We are going to demonstrate a semantic error with <span class="No-Break">this program.</span></p>
			<p>The expected output of this exercise is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Take the car</pre>			<p>Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Create a directory called <strong class="source-inline">Exercise6.02</strong> inside the <span class="No-Break"><strong class="source-inline">Chapter06</strong></span><span class="No-Break"> directory.</span></li>
				<li>Save a file called <strong class="source-inline">main.go</strong> inside the directory you created in the previous step. This program will be inside <span class="No-Break"><strong class="source-inline">package main</strong></span><span class="No-Break">.</span></li>
				<li>Import the <span class="No-Break"><strong class="source-inline">fmt</strong></span><span class="No-Break"> package:</span><pre class="source-code">
package main
import "fmt"</pre></li>				<li>Inside the <strong class="source-inline">main</strong> function, display a message to take the car when <strong class="source-inline">km</strong> is greater than <strong class="source-inline">2</strong>, and when <strong class="source-inline">km</strong> is less than <strong class="source-inline">2</strong>, to send a message <span class="No-Break">for walking:</span><pre class="source-code">
func main() {
  km := 2
  if km &gt; 2 {
    fmt.Println("Take the car")
  } else {
    fmt.Println("Going to walk today")
  }
}</pre></li>				<li>At the <a id="_idIndexMarker496"/>command line, navigate to the directory <span class="No-Break">you created.</span></li>
				<li>At the command line, type <span class="No-Break">the following:</span><pre class="source-code">
go build main.go</pre><p class="list-inset">The <strong class="source-inline">go build</strong> command will compile your program and create an executable named after the directory <span class="No-Break">you created.</span></p></li>				<li>Type the name of the file you created in <em class="italic">Step 6</em> and hit <em class="italic">Enter</em> to run the executable (Add the <strong class="source-inline">./main</strong> command). The expected output will be <span class="No-Break">as follows:</span></li>
			</ol>
			<p>You will get the <span class="No-Break">following output:</span></p>
			<pre class="console">
Going to walk today</pre>			<p>The program will run with no errors, but the message that’s displayed won’t be what <span class="No-Break">we expected.</span></p>
			<p>As mentioned previously, the program runs with no errors, but the results are not what we expected. This is because we have a logic error. Our <strong class="source-inline">if</strong> statement does not account for <strong class="source-inline">km</strong> equal to <strong class="source-inline">2</strong>. It only checks that the distance is greater than <strong class="source-inline">2</strong>. Fortunately, this is a simple fix: replace <strong class="source-inline">&gt;</strong> with <strong class="source-inline">&gt;=</strong>. Now, the program will give the results that <span class="No-Break">we expect:</span></p>
			<pre class="source-code">
func main() {
  km := 2
  if km &gt;= 2 {
    fmt.Println("Take the car")
  } else {
    fmt.Println("Going to walk today")
  }
}</pre>			<p>This simple program made it easy to debug the logic error, but these types of errors in a larger program may not be as easy <span class="No-Break">to spot.</span></p>
			<p>Semantic <a id="_idIndexMarker497"/>errors involve understanding the intended logic of the code. It is best to be thorough in testing. This includes various types of tests, such as unit, integration, end-to-end, and others. Each type of test serves a specific purpose in capturing different aspects of errors and preventing unintended consequences. Later in this book, we will discuss the various types of testing in further detail. Additionally, adopting best practices for Go and a continuous learning mindset <span class="No-Break">can help!</span></p>
			<p>The remainder of this chapter will focus on the runtime errors we’ve covered. However, it is good to understand the various types of errors that you, as a programmer<a id="_idTextAnchor1234"/><a id="_idTextAnchor1235"/>, <span class="No-Break">could encounter.</span></p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor1236"/>Error handling using other programming languages</h2>
			<p>Programmers who are new to Go and who have a background in other programming languages <a id="_idIndexMarker498"/>may initially find Go’s methodology for dealing with errors a bit odd. Go does not handle errors in the same fashion <a id="_idIndexMarker499"/>as other languages, such as Java, Python, C#, and Ruby. Those languages perform <span class="No-Break">exception handling.</span></p>
			<p>The following code snippets are some examples of how other languages handle errors by performing <span class="No-Break">exception handling:</span></p>
			<pre class="source-code">
//java
try {
  // code
}<strong class="bold">catch</strong> (exception e){
  // block of code to handle the error
}
//python
<strong class="bold">try:</strong>
  //code
except:
  //code
else:
  try:
  // code
  except:
  // code
<strong class="bold">finally:</strong>
  //code</pre>			<p>Typically, exceptions, if not handled, will crash your application. In most cases, exception <a id="_idIndexMarker500"/>handling tends to be implicit <a id="_idIndexMarker501"/>checking versus Go’s explicit checking for errors returned by its functions. In the exception-handling paradigm, anything can fail, and you must account for that. Each function can throw an exception, but you do not know what that exception <span class="No-Break">could be.</span></p>
			<p>In the error handling paradigm that Go uses, it is obvious when the programmer does not handle the error because the function returns the error code, and you can see that they did not check for the error. We will be looking at the specifics of checking for error code later in <span class="No-Break">this chapter.</span></p>
			<p>Most programming languages follow a similar pattern to the one shown in the previous code snippet. It is usually some sort of <strong class="source-inline">try..catch..finally</strong> block. One point of contention with the <strong class="source-inline">try..catch..finally</strong> block is that the control flow of the program’s execution gets interrupted and can follow a different path. This can lead to several logic errors <a id="_idIndexMarker502"/>and difficulty in the readability <a id="_idIndexMarker503"/>of the code. Here is a quick peek at how Go <span class="No-Break">handles errors:</span></p>
			<pre class="source-code">
val, err := someFunc() err
if err != nil{
  return err
}
return nil</pre>			<p>The preceding code snippet is a very simple syntax for handling the error. We will look at this in greater detail in <a id="_idTextAnchor1237"/><a id="_idTextAnchor1238"/>the <span class="No-Break">following sections.</span></p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor1239"/>Error interface type</h1>
			<p>What is <a id="_idIndexMarker504"/>an error in Go? An error in Go is a value. Here’s a quote from Rob Pike, one of the pivotal pioneers <span class="No-Break">of Go:</span></p>
			<p>“<em class="italic">Values can be programmed, and since errors are values, errors can be programmed. Errors are not like exceptions. There’s nothing special about them, whereas an unhandled exception can crash </em><span class="No-Break"><em class="italic">your program.</em></span><span class="No-Break">”</span></p>
			<p>Since errors are values, they can be passed into a function, returned from a function, and evaluated just like any other value <span class="No-Break">in Go.</span></p>
			<p>An error in Go is anything that implements the error interface. Interfaces will be explained in detail in the following chapter, so we will keep the details light in this chapter concerning interface references. We need to look at some fundamental aspects that make up the error type in Go. To be an error type in Go, it must first satisfy <strong class="source-inline">type </strong><span class="No-Break"><strong class="source-inline">error interface</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
//https://golang.org/pkg/builtin/#error
type error interface {
  Error() string
}</pre>			<p>The wonderful thing about Go is its simplistic design regarding language features. This can easily be seen with the error interface that Go’s standard library uses. To satisfy the error interface, only two things <span class="No-Break">are required:</span></p>
			<ul>
				<li>The method <span class="No-Break">name, </span><span class="No-Break"><strong class="source-inline">Error()</strong></span></li>
				<li>The <strong class="source-inline">Error()</strong> method to return <span class="No-Break">a string</span></li>
			</ul>
			<p>It is important to understand that an error type is an interface type. Any value that is an error can <a id="_idIndexMarker505"/>be described as a string. When performing error handling in Go, the functions will return error values. The Go language uses this throughout the <span class="No-Break">standard library.</span></p>
			<p>Look at the following code snippet for a starting discussion point <span class="No-Break">on errors:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
  "strconv"
)
func main() {
  v := "10"
  if s, err := strconv.Atoi(v); err == nil {
    fmt.Printf("%T, %v\n", s, s)
  }else{
    fmt.Println(err)
  }
  v = "s2"
  s, err := strconv.Atoi(v)
  if err != nil{
    fmt.Println(s, err)
  }
}</pre>			<p>We will not go into every detail of the function and instead focus on the error portion of the code. In <a href="B18621_05.xhtml#_idTextAnchor1048"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Reduce, Reuse, and Recycle</em>, we learned that functions can return multiple values. This is a powerful feature that most languages do not have. This is powerful, especially when dealing with error values. The <strong class="source-inline">strconv.Atoi()</strong> function returns an <strong class="source-inline">int</strong> type and an error, as seen in the example stated previously. It is a function that is in the Go standard library. For functions that return error values, the error value should be the last <span class="No-Break">return value.</span></p>
			<p>It is Go-idiomatic to evaluate the error value for functions or methods that return an error. It is <a id="_idIndexMarker506"/>generally bad practice to not handle an error that is returned from a function. When returned and ignored, an error can lead to lots of wasted debugging efforts. It can also cause unforeseen consequences in your program. If the value is not <strong class="source-inline">nil</strong>, then we have an error and must decide how we want to handle it. Depending on the scenario, we might want to do one of the <span class="No-Break">following things:</span></p>
			<ul>
				<li>Return the error to <span class="No-Break">the caller</span></li>
				<li>Log the error and <span class="No-Break">continue execution</span></li>
				<li>Stop the execution of <span class="No-Break">the program</span></li>
				<li>Ignore it (this is highly <span class="No-Break">not recommended)</span></li>
				<li>Panic (only in very rare conditions; we will discuss this in more <span class="No-Break">detail later)</span></li>
			</ul>
			<p>If the value of error is <strong class="source-inline">nil</strong>, this means there is no error. No further steps <span class="No-Break">are necessary.</span></p>
			<p>Let’s take a closer look at the standard package regarding the error type. We will start by looking at each piece of code in the <a href="https://packt.live/2rk6r8Z"><span class="No-Break">https://packt.live/2rk6r8Z</span></a><span class="No-Break"> file:</span></p>
			<pre class="source-code">
type errorString struct {
    s string
}</pre>			<p>The <strong class="source-inline">errorString</strong> struct is in the <strong class="source-inline">errors</strong> package. This struct is used to store the string version of the error. <strong class="source-inline">errorString</strong> has a single field of <strong class="source-inline">s</strong> that is of the <strong class="source-inline">string</strong> type. <strong class="source-inline">errorString</strong> and the field are unexportable. This means that we can’t access the <strong class="source-inline">errorString</strong> type or its field, <strong class="source-inline">s</strong>, directly. The following code shows an example of trying to access an unexported <strong class="source-inline">errorString</strong> type and its <span class="No-Break">field, </span><span class="No-Break"><strong class="source-inline">s</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
package main
import (
  "errors"
  "fmt"
)
func main() {
  es := errors.errorString{}
  es.s = "<a id="_idTextAnchor1240"/>slacker"
  fmt.Println(es)
}</pre>			<p>Here’s <span class="No-Break">the output:</span></p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B18621_06_02.jpg" alt="Figure 6.2: Expected output for the unexported field" width="1511" height="112"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2: Expected output for the unexported field</p>
			<p>On the <a id="_idIndexMarker507"/>surface, it appears that <strong class="source-inline">errorString</strong> is neither accessible nor useful, but we should keep digging into the <span class="No-Break">standard library:</span></p>
			<pre class="source-code">
func (e *errorString) Error() string {
    return e.s
}</pre>			<p>The <strong class="source-inline">errorString</strong> type has a method that implements the error interface. It satisfies the requirements, provides a method called <strong class="source-inline">Error()</strong>, and returns a string. The error interface has been satisfied. We now have access to the <strong class="source-inline">errorString</strong> field, <strong class="source-inline">s</strong>, through the <strong class="source-inline">Error()</strong> method. This is how an error gets returned within the <span class="No-Break">standard library.</span></p>
			<p>You should now have a basic understanding of what an error is in Go. Next, we’ll learn how t<a id="_idTextAnchor1241"/><a id="_idTextAnchor1242"/>o create error types <span class="No-Break">in Go.</span></p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor1243"/>Creating error values</h2>
			<p>In the standard library, the <strong class="source-inline">errors</strong> package has a method that we can use to <span class="No-Break">create errors:</span></p>
			<pre class="source-code">
// https://golang.org/src/errors/errors.go
// New returns an error that formats as the given text.
func New(text string) error {
    return &amp;errorString{text}
}</pre>			<p>It is <a id="_idIndexMarker508"/>important to understand that the <strong class="source-inline">New</strong> function takes <a id="_idIndexMarker509"/>a string as an argument, converts it into <strong class="source-inline">*errors.errorString</strong>, and returns an error value. The underlying value of the error type that gets returned is of the <strong class="source-inline">*</strong><span class="No-Break"><strong class="source-inline">errors.errorString</strong></span><span class="No-Break"> type.</span></p>
			<p>We can prove this by running the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
package main
import (
    "errors"
    "fmt"
)
func main() {
     ErrBadData := errors.New("Some bad data")
     fmt.Printf("ErrBadData type: %T", ErrBadData)
}</pre>			<p>Here is an example from Go’s standard library, <strong class="source-inline">http</strong>, that uses the <strong class="source-inline">errors</strong> package to create <span class="No-Break">package-level variables:</span></p>
			<pre class="source-code">
var (
    ErrBodyNotAllowed = errors.New("http: request method or response status code does not allow body")
    ErrHijacked = errors.New("http: connection has been hijacked")
    ErrContentLength = errors.New("http: wrote more than the declared Content- Length")
    ErrWriteAfterFlush = errors.New("unused")
)</pre>			<p>When <a id="_idIndexMarker510"/>creating errors in Go, it is idiomatic <a id="_idIndexMarker511"/><a id="_idTextAnchor1244"/><a id="_idTextAnchor1245"/>to start with the <span class="No-Break"><strong class="source-inline">Err</strong></span><span class="No-Break"> variable.</span></p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor1246"/>Exercise 6.03 – creating an application to calculate pay for the week</h2>
			<p>In this exercise, we are going to create a function that calculates pay for the week. This function <a id="_idIndexMarker512"/>will accept two arguments – the hours worked during the week and the hourly rate. The function <a id="_idIndexMarker513"/>is going to check whether the two parameters meet the criteria for being valid. The function will need to calculate regular pay, which is hours less than or equal to 40, and overtime pay, which is hours greater than 40 for <span class="No-Break">the week.</span></p>
			<p>We will create two error values using <strong class="source-inline">errors.New()</strong>. The one error value will be used when there is an invalid hourly rate. An invalid hourly rate in our app is an hourly rate that is less than 10 or greater than 75. The second error value will be when hours per week are not between 0 <span class="No-Break">and 80.</span></p>
			<p>Use the IDE of your choice. One option would be Visual Studio Code. Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li> Create a directory called <strong class="source-inline">Exercise6.03</strong> inside the <span class="No-Break"><strong class="source-inline">Chapter06</strong></span><span class="No-Break"> directory.</span></li>
				<li>Save a file called <strong class="source-inline">main.go</strong> inside the directory you created in the previous step The <strong class="source-inline">main.go</strong> file will be in <span class="No-Break"><strong class="source-inline">package main</strong></span><span class="No-Break">.</span></li>
				<li>Import the two Go standard libraries, <strong class="source-inline">errors</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">fmt</strong></span><span class="No-Break">:</span><pre class="source-code">
package main
import (
    "errors"
    "fmt"
)</pre></li>				<li>With that, we have declared our error variables using <strong class="source-inline">errors.New()</strong>. Now, we can use idiomatic Go for the variable name, starting it with <strong class="source-inline">Err</strong> and camel casing. Our error string is in lowercase with <span class="No-Break">no punctuation:</span><pre class="source-code">
var (
     ErrHourlyRate = errors.New("invalid hourly rate")
     ErrHoursWorked = errors.New("invalid hours worked per week")
)</pre></li>				<li>Inside <a id="_idIndexMarker514"/>the <strong class="source-inline">main</strong> function, we will be calling our <strong class="source-inline">payday()</strong> function three times. We will declare <a id="_idIndexMarker515"/>our error variables using <strong class="source-inline">errors.New()</strong> and check <strong class="source-inline">err</strong> after <span class="No-Break">the function:</span><pre class="source-code">
func main() {
    pay, err := payDay(81, 50)
    if err != nil {
        fmt.Println(err)
    }
}</pre></li>				<li>Create the <strong class="source-inline">payDay</strong> function and make it accept two arguments (<strong class="source-inline">hoursWorked</strong> and <strong class="source-inline">hourlyRate</strong>). The function will return an <strong class="source-inline">int</strong> type and an error. We will discuss this step by <span class="No-Break">step afterward:</span><pre class="source-code">
    func payDay(hoursWorked, hourlyRate int) (int, error) {
        if hourlyRate &lt; 10 || hourlyRate &gt; 75 {
            return 0, ErrHourlyRate
    }
    if hoursWorked &lt; 0 || hoursWorked &gt; 80 {
        return 0, ErrHoursWorked
    }
    if hoursWorked &gt; 40 {
        hoursOver := hoursWorked - 40
        overTime := hoursOver * 2
        regularPay := hoursWorked * hourlyRate
        return regularPay + overTime, nil
    }
    return hoursWorked * hourlyRate, nil
}</pre></li>				<li>We will <a id="_idIndexMarker516"/>use an <strong class="source-inline">if</strong> statement to check whether the hourly rate is less than 10 or greater than 75. If <strong class="source-inline">hourlyRate</strong> meets those conditions, we will return <strong class="source-inline">0</strong> and our <a id="_idIndexMarker517"/>custom error, <strong class="source-inline">ErrHourlyRate</strong>. If <strong class="source-inline">hourlyRate</strong> does not meet those conditions, then the returned value will be <strong class="source-inline">return hoursWorked * hourlyRate, nil</strong>. We return <strong class="source-inline">nil</strong> for the error because there was <span class="No-Break">no error:</span><pre class="source-code">
func payDay(hoursWorked, hourlyRate int) (int, error) {
    if hourlyRate &lt; 10 || hourlyRate &gt; 75 {
        return 0, ErrHourlyRate
    }
    return hoursWorked * hourlyRate, nil
}</pre></li>				<li>In <em class="italic">step 7</em>, we validated <strong class="source-inline">hourlyRate</strong>. Now, we will need to validate <strong class="source-inline">hoursWorked</strong>. We will add another <strong class="source-inline">if</strong> statement to the <strong class="source-inline">payDay()</strong> function that <a id="_idIndexMarker518"/>will check <a id="_idIndexMarker519"/>whether <strong class="source-inline">hoursWorked</strong> is less than <strong class="source-inline">0</strong> or greater than <strong class="source-inline">80</strong>. If <strong class="source-inline">hoursWorked</strong> matches that condition, we will return <strong class="source-inline">0</strong> and the <span class="No-Break">error, </span><span class="No-Break"><strong class="source-inline">ErrHoursWorked</strong></span><span class="No-Break">:</span><pre class="source-code">
func payDay(hoursWorked, hourlyRate int) (int, error) {
    if hourlyRate &lt; 10 || hourlyRate &gt; 75 {
        return 0, ErrHourlyRate
    }
    if hoursWorked &lt; 0 || hoursWorked &gt; 80 {
        return 0, ErrHoursWorked
    }
    return hoursWorked * hourlyRate, nil
}</pre></li>				<li>In the previous two steps, we added <strong class="source-inline">if</strong> statements to validate the arguments being passed to the function. In this step, we will add another <strong class="source-inline">if</strong> statement to calculate overtime pay. Overtime pay is hours greater than <strong class="source-inline">40</strong>. The hours over <strong class="source-inline">40</strong> are double <strong class="source-inline">hourlyRate</strong>. The hours less than or equal to <strong class="source-inline">40</strong> are <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">hourlyRate</strong></span><span class="No-Break">:</span><pre class="source-code">
func payDay(hoursWorked, hourlyRate int) (int, error) {
    if hourlyRate &lt; 10 || hourlyRate &gt; 75 {
        return 0, ErrHourlyRate
    }
    if hoursWorked &lt; 0 || hoursWorked &gt; 80 {
        return 0, ErrHoursWorked
    }
    if hoursWorked &gt; 40 {
        hoursOver := hoursWorked - 40
        overTime := hoursOver * 2
        regularPay := hoursWorked * hourlyRate
        return regularPay + overTime, nil
    }
    return hoursWorked * hourlyRate, nil
}</pre></li>				<li>In the <strong class="source-inline">main()</strong> function, we will call the <strong class="source-inline">payDay()</strong> function three times with various <a id="_idIndexMarker520"/>arguments. We <a id="_idIndexMarker521"/>will check the error after each call and print the error message if applicable. If there is no error, then we print the pay for <span class="No-Break">the week:</span><pre class="source-code">
func main() {
    pay, err := payDay(81, 50)
    if err != nil {
        fmt.Println(err)
    }
    pay, err = payDay(80, 5)
    if err != nil {
        fmt.Println(err)
    }
    pay, err = payDay(80, 50)
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(pay)
}</pre></li>				<li>In the <a id="_idIndexMarker522"/>command line, navigate to the directory you <span class="No-Break">created previously.</span></li>
				<li>In the <a id="_idIndexMarker523"/>command line, type <span class="No-Break">the following:</span><pre class="source-code">
go build main.go</pre><p class="list-inset">The <strong class="source-inline">go build</strong> command will compile your program and create an executable named after the directory <span class="No-Break">you created.</span></p></li>				<li>Type the name of the file you created and hit <em class="italic">Enter</em> to run <span class="No-Break">the executable:</span><pre class="source-code">
./main</pre></li>			</ol>
			<p>The expected output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Invalid hours worked per week
Invalid hourly rate
4080</pre>			<p>In this exercise, we saw how to create custom error messages that can be used to easily determine why the data was considered invalid. We also showed how to return multiple values from a function and to check for errors from the function. In the next section, we will lo<a id="_idTextAnchor1247"/><a id="_idTextAnchor1248"/>ok at how to use panic in <span class="No-Break">our applications.</span></p>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor1249"/>Panic</h1>
			<p>Several languages <a id="_idIndexMarker524"/>use exceptions for handling errors. However, Go does not use exceptions – it uses something called a panic. This is a built-in function that causes a program to crash. It stops the normal execution of the current goroutine where the panic happened and all other ongoing goroutines and shows a stack trace of <span class="No-Break">what occurred.</span></p>
			<p>In Go, a panic is not the norm, unlike other languages where an exception is the norm. A panic signal indicates something abnormal that is occurring within your code. Usually, when a panic is initiated by runtime or the developer, it is to protect the integrity of <span class="No-Break">the program.</span></p>
			<p>Errors and panics differ in their purposes and how they are handled by the Go runtime. An error in Go indicates that something unexpected occurred, but it will not adversely impact the <a id="_idIndexMarker525"/>integrity of the program. Go expects that the developer will handle the error properly. The function or other programs will not typically crash if you do not handle the error. However, panics differ in this regard. When a panic occurs, it will ultimately crash the system unless there are handlers to handle the panic. If there are no handlers for the panic, it will go all the way up the stack and crash <span class="No-Break">the program.</span></p>
			<p>One example that we will look at later in this chapter is where a panic occurs due to an index being out of range. This is typical when trying to access the index of a collection that doesn’t exist. If Go did not panic in this case, it could harm the integrity of the program, such as other parts of the program trying to store or retrieve data that is not there in <span class="No-Break">the collection.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Review the topic of goroutines to understand what occurs in Go when you panic. At a high level, the <strong class="source-inline">main()</strong> function is a Goroutine. When a panic occurs, you will see references to “Goroutine running” in the <span class="No-Break">error message.</span></p>
			<p>Panics can be initiated by the developer and can be caused during the execution of a program by runtime errors. A <strong class="source-inline">panic()</strong> function accepts an empty interface. For now, suffice to say, this means it can accept anything as an argument. However, in most cases, you should pass an error type to the <strong class="source-inline">panic()</strong> function. It is more intuitive to the user of our function to have some details on what caused the panic. Passing an error to the panic function is also idiomatic in Go. We will also see how recovering from a panic that has an error type passed to it gives us some different options when dealing with panic. When a panic occurs, it will generally follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li class="upper-roman">The execution <span class="No-Break">is stopped.</span></li>
				<li class="upper-roman">Any deferred functions in the panicking function will <span class="No-Break">be called.</span></li>
				<li class="upper-roman">Any deferred functions in the stack of the panicking function will <span class="No-Break">be called.</span></li>
				<li class="upper-roman">It will continue up the stack until it <span class="No-Break">reaches </span><span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break">.</span></li>
				<li class="upper-roman">Statements after the panicking function will <span class="No-Break">not execute.</span></li>
				<li class="upper-roman">The p<a id="_idTextAnchor1250"/>rogram <span class="No-Break">then crashes.</span></li>
			</ol>
			<p>Here’s how <a id="_idIndexMarker526"/>a <span class="No-Break">panic works:</span></p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B18621_06_03.jpg" alt="Figure 6.3: The working of a panic" width="374" height="582"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3: The working of a panic</p>
			<p>The preceding diagram illustrates code in the <strong class="source-inline">main</strong> function that calls the <strong class="source-inline">a()</strong> function. This function then calls the <strong class="source-inline">b()</strong> function. Inside <strong class="source-inline">b()</strong>, a panic occurs. The <strong class="source-inline">panic()</strong> function is not handled by any of the code upstream (<strong class="source-inline">a()</strong> or the <strong class="source-inline">main()</strong> function), so the program will crash the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function.</span></p>
			<p>Here’s an <a id="_idIndexMarker527"/>example of a panic that occurs in Go. Try to determine why this <span class="No-Break">program panics:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
)
func main() {
    nums := []int{1, 2, 3}
    for i := 0; i &lt;= 10; i++ {
        fmt.Println(nums[i])
  <a id="_idTextAnchor1251"/>  }
}</pre>			<p>The output of this panic is <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B18621_06_04.jpg" alt="Figure 6.4: Panic example" width="1165" height="314"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4: Panic example</p>
			<p>The panic runtime error is a common one that you will encounter while developing. It is an <strong class="source-inline">index out of range</strong> error. Go generated this panic because we are trying to iterate over a slice more times than there are elements. Go felt that this is a reason to panic because it puts the program in an <span class="No-Break">abnormal condition.</span></p>
			<p>Here’s a snippet of code that demonstrates the basics of using <span class="No-Break">a panic:</span></p>
			<pre class="source-code">
package main
import (
    "errors"
    "fmt"
)
func main() {
    msg := "good-bye"
     message(msg)
     fmt.Println("This line will not get printed")
}
func message(msg string) {
    if msg == "good-bye" {
        panic(errors.New("something went wrong"))
    }
}</pre>			<p><span class="No-Break"><strong class="bold">Code synopsis</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>The function <a id="_idIndexMarker528"/>panics because the argument to the function message <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">"good-bye"</strong></span><span class="No-Break">.</span></li>
				<li>The <strong class="source-inline">panic()</strong> function prints the error message. Having a good error message helps with the <span class="No-Break">debugging process.</span></li>
				<li>Inside the panic, we are using <strong class="source-inline">errors.New()</strong>, which we used in the previous section to create an <span class="No-Break">error type.</span></li>
				<li>As you can see, <strong class="source-inline">fmt.Println()</strong> does not get executed in the <strong class="source-inline">main()</strong> function. Since there are no <strong class="source-inline">defer</strong> statements, execution <span class="No-Break">stops immediately.</span></li>
			</ul>
			<p>The expecte<a id="_idTextAnchor1252"/>d output for this code snippet is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B18621_06_05.jpg" alt="Figure 6.5: Panic example output" width="938" height="274"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5: Panic example output</p>
			<p>The following <a id="_idIndexMarker529"/>code snippet shows how <strong class="source-inline">panic</strong> and a <strong class="source-inline">defer</strong> statement <span class="No-Break">function together:</span></p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">main.go</p>
			<pre class="source-code">
func test() {
    n := func() {
    fmt.Println("Defer in test")
    }
    defer n()
    msg := "good-bye"
    message(msg)
}
func message(msg string) {
    f := func() {
    fmt.Println("Defer in message func")
}
    defer f()
    if msg == "good-bye" {
    panic(errors.New("something went wrong"))</pre>			<p>Th<a id="_idTextAnchor1253"/>e output of this panic example is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B18621_06_06.jpg" alt="Figure 6.6: Panic example output" width="933" height="425"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6: Panic example output</p>
			<p>Let’s <a id="_idIndexMarker530"/>understand the code <span class="No-Break">in parts:</span></p>
			<ol>
				<li class="upper-roman">We start by examining the code in the <strong class="source-inline">message()</strong> function since that is where the panic starts. When the panic occurs, it runs the <strong class="source-inline">defer</strong> statement within the panicking <span class="No-Break">function, </span><span class="No-Break"><strong class="source-inline">message()</strong></span><span class="No-Break">.</span></li>
				<li class="upper-roman">The deferred function, <strong class="source-inline">func f()</strong>, runs in the <span class="No-Break"><strong class="source-inline">message()</strong></span><span class="No-Break"> function.</span></li>
				<li class="upper-roman">Going up the call stack, the next function is the <strong class="source-inline">test()</strong> function, and its deferred function, <strong class="source-inline">n()</strong>, <span class="No-Break">will execute.</span></li>
				<li class="upper-roman">Finally, we get to the <strong class="source-inline">main()</strong> function, where the execution is stopped by the panicking function. The print statement in <strong class="source-inline">main()</strong> does not <span class="No-Break">get executed.</span></li>
			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">You may have seen <strong class="source-inline">os.Exit()</strong> used to stop the execution of a program. <strong class="source-inline">os.Exit()</strong> stops execution immediately and returns a status code. No deferred statements are run when <strong class="source-inline">os.Exit()</strong> is performed. <strong class="source-inline">Panic</strong> is preferred over <strong class="source-inline">os.Exit()</strong> in certain<a id="_idTextAnchor1254"/><a id="_idTextAnchor1255"/> cases as a panic will run <span class="No-Break">deferred functions.</span></p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor1256"/>Exercise 6.04 – Crashing the program on errors using a panic</h2>
			<p>In this <a id="_idIndexMarker531"/>exercise, we will be modifying <em class="italic">Exercise 6.03 – creating an application to calculate pay for the week</em>. Consider the following scenario, where the requirements <span class="No-Break">have changed.</span></p>
			<p>We no longer need to return error values from our <strong class="source-inline">payDay()</strong> function. It has been decided that we cannot trust the user of the program to respond properly to the errors. There have been complaints of incorrect paychecks. We believe this is due to the caller of our function ignoring the errors <span class="No-Break">being returned.</span></p>
			<p>The <strong class="source-inline">payDay()</strong> function will now only return the pay amount and no errors. When the arguments provided to the function are invalid, instead of returning an error, the function will panic. This will cause the program to stop immediately and, therefore, not process <span class="No-Break">a paycheck.</span></p>
			<p>Use the <a id="_idIndexMarker532"/>IDE of your choice. One option could be Visual Studio Code. Now, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li> Create a directory called <strong class="source-inline">Exercise6.04</strong> inside the <span class="No-Break"><strong class="source-inline">Chapter06</strong></span><span class="No-Break"> directory.</span></li>
				<li>Save a file called <strong class="source-inline">main.go</strong> inside the directory you created in the previous step. This program will be inside <span class="No-Break"><strong class="source-inline">package main</strong></span><span class="No-Break">.</span></li>
				<li>Enter the following code <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">:</span><pre class="source-code">
package main
import (
    "fmt"
    "errors"
)
var (
    ErrHourlyRate = errors.New("invalid hourly rate")
    ErrHoursWorked = errors.New("invalid hours worked per week")
)</pre></li>				<li>Inside the <strong class="source-inline">main</strong> function, call the <strong class="source-inline">payDay()</strong> function, assign it to only one variable, <strong class="source-inline">pay</strong>, and then <span class="No-Break">print it:</span><pre class="source-code">
func main() {
    pay := payDay(81, 50)
    fmt.Println(pay)
}</pre></li>				<li>Change the return type of the <strong class="source-inline">payDay()</strong> function so that it only <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break">:</span><pre class="source-code">
func payDay(hoursWorked, hourlyRate int) int {</pre></li>				<li>Inside the <strong class="source-inline">payDay()</strong> function, assign a variable, <strong class="source-inline">report</strong>, to an anonymous function. This anonymous function provides details of the arguments provided to the <strong class="source-inline">payDay()</strong> function. Even though we are not returning errors, this will provide <a id="_idIndexMarker533"/>some insight as to why the function panics. Since it is a deferred function, it will always execute before the <span class="No-Break">function exits:</span><pre class="source-code">
func payDay(hoursWorked, hourlyRate int) int {
    report := func() {
        fmt.Printf("HoursWorked: %d\nHourldyRate: %d\n", hoursWorked, hourlyRate)
    }
    defer report()
}</pre><p class="list-inset">The business rule for valid <strong class="source-inline">hourlyRate</strong> and <strong class="source-inline">hoursWorked</strong> stays the same as in the previous exercise. Instead of returning an error, we will be using the <strong class="source-inline">panic</strong> function. When the data is invalid, we panic and pass the argument of <strong class="source-inline">ErrHourlyRate</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">ErrHoursWorked</strong></span><span class="No-Break">.</span></p><p class="list-inset">The arguments that are passed to the <strong class="source-inline">panic()</strong> function assist the user of our function in <strong class="source-inline">understanding</strong> the cause of <span class="No-Break">the panic.</span></p></li>				<li>When a panic occurs in the <strong class="source-inline">payDay()</strong> function, the <strong class="source-inline">defer</strong> function, <strong class="source-inline">report()</strong>, will give the caller some insight into why the panic occurred. The panic will bubble up the stack to the <strong class="source-inline">main()</strong> function and execution will stop immediately. The following code must be added after the <strong class="source-inline">defer</strong> function in the <span class="No-Break"><strong class="source-inline">payDay()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
    if hourlyRate &lt; 10 || hourlyRate &gt; 75 {
        panic(ErrHourlyRate)
    }
    if hoursWorked &lt; 0 || hoursWorked &gt; 80 {
        panic(ErrHoursWorked )
    }
    if hoursWorked &gt; 40 {
        hoursOver := hoursWorked – 40
        overTime := hoursOver * 2
        regularPay := hoursWorked * hourlyRate
        return regularPay + overTime
    }
    return hoursWorked * hourlyRate
}</pre></li>				<li>At the <a id="_idIndexMarker534"/>command line, navigate to the directory <span class="No-Break">you created.</span></li>
				<li>At the command line, type <span class="No-Break">the following:</span><pre class="source-code">
go build main.go</pre></li>				<li>The <strong class="source-inline">go build</strong> command will compile your program and create an executable named after the directory <span class="No-Break">you created.</span></li>
				<li>Type in the name of the file you created and hit <em class="italic">Enter</em> to run <span class="No-Break">the exec<a id="_idTextAnchor1257"/>utable.</span></li>
			</ol>
			<p>The expected output should be <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B18621_06_07.jpg" alt="Figure 6.7: Panic exercise output" width="953" height="347"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7: Panic exercise output</p>
			<p>In this <a id="_idIndexMarker535"/>exercise, we learned how to perform a panic and pass an error to the <strong class="source-inline">panic()</strong> function. This aids the user of the function in gaining a good understanding of the cause of the panic. In the next section, we will learn how to regain control of the program after a panic occurs using <strong class="source-inline">recover()</strong>. We will also discuss gui<a id="_idTextAnchor1258"/><a id="_idTextAnchor1259"/>delines on <strong class="source-inline">panic()</strong> and <strong class="source-inline">recover()</strong> in <span class="No-Break">Go thereafter.</span></p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor1260"/>Recover</h1>
			<p>Go provides us <a id="_idIndexMarker536"/>with the ability to regain control after a panic has occurred. <strong class="source-inline">recover()</strong> is a function that is used to regain control of a <span class="No-Break">panicking goroutine.</span></p>
			<p>The signature of the <strong class="source-inline">recover()</strong> function is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
func recover() interface{}</pre>			<p>The <strong class="source-inline">recover()</strong> function accepts no arguments and returns an empty <strong class="source-inline">interface{}</strong>. For now, an empty <strong class="source-inline">interface{}</strong> indicates that any type can be returned. The <strong class="source-inline">recover()</strong> function will return the value sent to the <span class="No-Break"><strong class="source-inline">panic()</strong></span><span class="No-Break"> function.</span></p>
			<p>The <strong class="source-inline">recover()</strong> function is only useful inside a deferred function. As you may recall, a deferred function gets executed before the encompassing function terminates. Executing a call to the <strong class="source-inline">recover()</strong> function inside a deferred function stops the panicking by restoring normal execution. If the <strong class="source-inline">recover()</strong> function is called outside a deferred function, it will not stop <span class="No-Break">the panicking.</span></p>
			<p>The following diagram shows the steps a program would take wh<a id="_idTextAnchor1261"/>en using <strong class="source-inline">panic()</strong>, <strong class="source-inline">recover()</strong>, and a <span class="No-Break"><strong class="source-inline">defer()</strong></span><span class="No-Break"> function:</span></p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B18621_06_08.jpg" alt="Figure 6.8: The recover() function’s flow" width="1073" height="905"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8: The recover() function’s flow</p>
			<p>The steps <a id="_idIndexMarker537"/>that are taken in the preceding diagram can be explained <span class="No-Break">as follows:</span></p>
			<ol>
				<li class="upper-roman">The <strong class="source-inline">main()</strong> function calls <span class="No-Break"><strong class="source-inline">func a()</strong></span><span class="No-Break">.</span></li>
				<li class="upper-roman"><strong class="source-inline">func a()</strong> calls <span class="No-Break"><strong class="source-inline">func b()</strong></span><span class="No-Break">.</span></li>
				<li class="upper-roman">Inside <strong class="source-inline">func b()</strong>, there is <span class="No-Break">a panic.</span></li>
				<li class="upper-roman">The <strong class="source-inline">panic()</strong> function gets handled by a deferred function that uses the <span class="No-Break"><strong class="source-inline">recover()</strong></span><span class="No-Break"> function.</span></li>
				<li class="upper-roman">The deferred function is the last function to execute inside <span class="No-Break"><strong class="source-inline">func b()</strong></span><span class="No-Break">.</span></li>
				<li class="upper-roman">The deferred function calls the <span class="No-Break"><strong class="source-inline">recover()</strong></span><span class="No-Break"> function.</span></li>
				<li class="upper-roman">The call to <strong class="source-inline">recover()</strong> causes normal flow back to the caller, <span class="No-Break"><strong class="source-inline">func a()</strong></span><span class="No-Break">.</span></li>
				<li class="upper-roman">Normal flow continues, and control is finally given back with the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function.</span></li>
			</ol>
			<p>The following <a id="_idIndexMarker538"/>code snippet mimics the behavior of the <span class="No-Break">preceding diagram:</span></p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">main.go</p>
			<pre class="source-code">
func main() {
    a()
    fmt.Println("This line will now get printed from main() function")
}
func a() {
    b("good-bye")
    fmt.Println("Back in function a()")
}
func b(msg string) {
    defer func() {
        if r := recover(); r!= nil{
            fmt.Println("error in func b()", r)
    }
}()</pre>			<p>The full code is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter06/Examples/Example06.02/main.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter06/Examples/Example06.02/main.go</span></a><span class="No-Break">.</span></p>
			<p><span class="No-Break"><strong class="bold">Code synopsis</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li>The <strong class="source-inline">main()</strong> function <a id="_idIndexMarker539"/>calls the <strong class="source-inline">a()</strong> function. This calls the <span class="No-Break"><strong class="source-inline">b()</strong></span><span class="No-Break"> function.</span></li>
				<li><strong class="source-inline">b()</strong> accepts a string type and assigns it to the <strong class="source-inline">msg</strong> variable. If <strong class="source-inline">msg</strong> evaluates to <strong class="source-inline">true</strong> in the <strong class="source-inline">if</strong> statement, a panic <span class="No-Break">will occur.</span></li>
				<li>The argument for the panic is a new error created by the <span class="No-Break"><strong class="source-inline">errors.New()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
if msg == "good-bye" {
    panic(errors.New("something went wrong"))
}</pre></li>			</ul>
			<p>Once the panic occurs, the next call will be to the <span class="No-Break">deferred function.</span></p>
			<p>The deferred function uses the <strong class="source-inline">recover()</strong> function. The value of the panic is returned from <strong class="source-inline">recover()</strong>; in this case, the value of <strong class="source-inline">r</strong> is an error type. Then, the function prints out <span class="No-Break">some details:</span></p>
			<pre class="source-code">
defer func() {
    if r := recover(); r!= nil {
        fmt.Println("error in func b()", r)
    }
}()</pre>			<ul>
				<li>The control flow goes back to <strong class="source-inline">a()</strong>. Then, the <strong class="source-inline">a()</strong> function prints out <span class="No-Break">some details.</span></li>
				<li>Next, control goes back to the <strong class="source-inline">main()</strong> functi<a id="_idTextAnchor1262"/>on, where it prints out some details <span class="No-Break">an<a id="_idTextAnchor1263"/><a id="_idTextAnchor1264"/>d terminates:</span></li>
			</ul>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B18621_06_09.jpg" alt="Figure 6.9: recover() example output" width="1041" height="118"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9: recover() example output</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor1265"/>Exercise 6.05 – recovering from a panic</h2>
			<p>In this <a id="_idIndexMarker540"/>exercise, we will enhance our <strong class="source-inline">payDay()</strong> function so that it can recover from a panic. When our <strong class="source-inline">payDay()</strong> function panics, we will inspect the error from that panic. Then, depending on the error, we will print an informative message to the user. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li> Create a directory called <strong class="source-inline">Exercise6.05</strong> inside the <span class="No-Break"><strong class="source-inline">Chapter06</strong></span><span class="No-Break"> directory.</span></li>
				<li>Save a file called <strong class="source-inline">main.go</strong> inside the directory you created in the previous step. This program will be inside <span class="No-Break"><strong class="source-inline">package main</strong></span><span class="No-Break">.</span></li>
				<li>Enter the following code <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">:</span><pre class="source-code">
package main
import (
    "errors"
    "fmt"
)
var (
    ErrHourlyRate = errors.New("invalid hourly rate")
    ErrHoursWorked = errors.New("invalid hours worked per week")
)</pre></li>				<li>Call the <strong class="source-inline">payDay()</strong> function with various arguments and then print the return value of <span class="No-Break">the function:</span><pre class="source-code">
func main() {
    pay := payDay(100, 25)
    fmt.Println(pay)
    pay = payDay(100, 200)
    fmt.Println(pay)
    pay = payDay(60, 25)
    fmt.Println(pay)
}</pre></li>				<li>Then, add a <strong class="source-inline">defer</strong> function to your <span class="No-Break"><strong class="source-inline">payDay()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func payDay(hoursWorked, hourlyRate int) int {
    defer func() {</pre></li>				<li>We can <a id="_idIndexMarker541"/>check for the return value from the <strong class="source-inline">recover()</strong> function, <span class="No-Break">as follows:</span><pre class="source-code">
        if r := recover(); r != nil {
           if r == ErrHourlyRate {</pre><p class="list-inset">If <strong class="source-inline">r</strong> is not <strong class="source-inline">nil</strong>, this means a panic occurs and we should perform <span class="No-Break">an action.</span></p></li>				<li>We can evaluate <strong class="source-inline">r</strong> and see whether it equals one of our error values – <strong class="source-inline">ErrHourlyRate</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">ErrHoursWorked</strong></span><span class="No-Break">:</span><pre class="source-code">
                fmt.Printf("hourly rate: %d\nerr: %v\n\n", hourlyRate, r)
            }
            if r == ErrHoursWorked {
                fmt.Printf("hours worked: %d\nerr: %v\n\n", hoursWorked, r)
            }
        }</pre></li>				<li>If our <strong class="source-inline">if</strong> statements evaluate to <strong class="source-inline">true</strong>, we print some details about the data and the error values from the <strong class="source-inline">recover()</strong> function. Then, we print how our pay <span class="No-Break">was calculated:</span><pre class="source-code">
        fmt.Printf("Pay was calculated based on:\nhours worked: %d\nhourly Rate: %d\n", hoursWorked, hourlyRate)
    }()</pre></li>				<li>The rest <a id="_idIndexMarker542"/>of the code in the <strong class="source-inline">payDay()</strong> function remains unchanged. To see a description of it, please refer to <em class="italic">Exercise 6.04 – crashing the program on errors using </em><span class="No-Break"><em class="italic">a panic</em></span><span class="No-Break">:</span><pre class="source-code">
    if hourlyRate &lt; 10 || hourlyRate &gt; 75 {
        panic(ErrHourlyRate)
    }
    if hoursWorked &lt; 0 || hoursWorked &gt; 80 {
         panic(ErrHoursWorked)
    }
    if hoursWorked &gt; 40 {
        hoursOver := hoursWorked - 40
        overTime := hoursOver * 2
        regularPay := hoursWorked * hourlyRate
        return regularPay + overTime
    }
    return hoursWorked * hourlyRate
}</pre></li>				<li>At the command line, navigate to the directory <span class="No-Break">you created.</span></li>
				<li>At the command line, type <span class="No-Break">the following:</span><pre class="source-code">
go build main.go</pre><p class="list-inset">The <strong class="source-inline">go build</strong> command will compile your program and create an executable named after the directory <span class="No-Break">you created.</span></p></li>				<li>Type the name of the file you created and hit <em class="italic">Enter</em> to run <span class="No-Break">the<a id="_idTextAnchor1266"/> executable:</span><pre class="source-code">
./main</pre></li>			</ol>
			<p>The expected output is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B18621_06_10.jpg" alt="Figure 6.10: Recovering from a panic exercise output" width="694" height="689"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10: Recovering from a panic exercise output</p>
			<p>In the <a id="_idIndexMarker543"/>preceding exercises, we have seen the progression of creating a custom error and returning that error. From this, we have been able to crash programs when needed using <strong class="source-inline">panic()</strong>. In the previous exercise, we demonstrated the ability to recover from panics and display error messages based on the error type that was passed to the <strong class="source-inline">panic()</strong> function. In the following section, we will discuss some<a id="_idTextAnchor1267"/><a id="_idTextAnchor1268"/> basic guidelines when performing error handling <span class="No-Break">in Go.</span></p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor1269"/>Guidelines when working with errors and panics</h2>
			<p>Guidelines are just for guidance. They are not set in stone. This means that the majority of the <a id="_idIndexMarker544"/>time, you should follow the guidelines; however, there could be exceptions. Some of these guidelines have been mentioned previously, but we have consolidated them here for <span class="No-Break">quick reference:</span></p>
			<ul>
				<li>When declaring an error type, the variable needs to start with <strong class="source-inline">Err</strong>. It should also follow the camel case <span class="No-Break">naming convention:</span><pre class="source-code">
var ErrExampleNotAllowd= errors.New("error example text")</pre></li>				<li>The <strong class="source-inline">error</strong> string should start in lowercase and not end with punctuation. One of the reasons for this guideline is that the error can be returned and concatenated with other information relevant to <span class="No-Break">the error.</span></li>
				<li>If a function or method returns an error, it should be evaluated. Errors that are not evaluated can cause the program to not function <span class="No-Break">as expected.</span></li>
				<li>When using <strong class="source-inline">panic()</strong>, pass an error type as the argument, instead of an <span class="No-Break">empty value.</span></li>
				<li>Do not <a id="_idIndexMarker545"/>evaluate the string value of an error to extract information directly from the string representation of an error. Instead, use type assertions or the error interface methods to retrieve specific details about <span class="No-Break">the error.</span></li>
				<li>Use the <strong class="source-inline">panic()</strong> <span class="No-Break">function sparingly.</span></li>
			</ul>
			<p>Errors should be used for expected situations, such as when you come across a recoverable issue in your code. When a function cannot return its intended result due to specific conditions, returning an error allows the caller to handle the situation gracefully. <strong class="source-inline">panic()</strong> should never be your first line of defense. <strong class="source-inline">panic()</strong> is meant for exceptional or unexpected situations and using it for regular error handling can lead to hard-to-debug issues, making your code less maintainable. Additionally, logging your errors in <strong class="source-inline">DEBUG</strong> mode, which is a state where a program provides more detailed information for debugging purposes, can be useful when debugging why an <span class="No-Break">error occurred.</span></p>
			<p>Following these suggestions will help improve the reliability and maintainability of your Go code and help you handle <span class="No-Break">errors gracefully.</span></p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor1270"/>Error wrapping</h2>
			<p>When <a id="_idIndexMarker546"/>propagating errors up the call stack, there are ways to improve the context around why an error occurred. This is extremely useful in complex systems to aid in understanding an error case. Error wrapping helps preserve the original error information while adding additional context to the error. This can be seen with the use of <strong class="source-inline">fmt.Errorf</strong> or the <strong class="source-inline">errors.Wrap</strong> function from <strong class="source-inline">github.com/pkg/errors</strong>. Error wrapping provides more detailed information about where an error occurred or what caused it, making it easier to understand and handle errors in <span class="No-Break">your code.</span></p>
			<p>A simple example of error wrapping can be seen in the <span class="No-Break">following function:</span></p>
			<pre class="source-code">
func readConfig() error {
    _, err := readFile("file.txt")
    if err != nil {
        return errors.Wrap(err, "failed to read config file")
    }
    return nil
}</pre>			<p>Alternatively, the wrapped error return can be represented by the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
return fmt.Errorf("failed to read config file: %w", err)</pre>			<p>The preceding <a id="_idIndexMarker547"/>code shows how you can easily chain errors using error wrapping. <strong class="source-inline">%w</strong> in the format string on the error provided previously allows errors to be chained, which provides additional context on why the error occurred. This approach is supported in the standard library, so it should be considered the preferred and most <span class="No-Break">simplistic method.</span></p>
			<p>However, there is another third-party Go package that can be used to handle multiple errors together using <strong class="source-inline">github.com/hashicorp/go-multierror</strong>. These options give you the flexibility to understand additional error context or aggregate multiple errors into a single error, which can be convenient in <span class="No-Break">certain scenarios.</span></p>
			<p>The Go standard library introduced error wrapping in Go 1.13, and you can see this type of functionality in use today by professional teams and in more complex applications. Providing additional context around an error can be useful in debugging scenarios. To illustrate this, consider a situation where an error occurs in code you are unfamiliar with, and the error provides no context. It will be very challenging to pinpoint the origin of the error. Debugging becomes very difficult when you lack information about the specific part of the code where the error occurred. However, you must be mindful of not propagating too much context up the call stack so t<a id="_idTextAnchor1271"/><a id="_idTextAnchor1272"/>hat you’re not compromising the security of your <span class="No-Break">code base.</span></p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor1273"/>Activity 6.01 – creating a custom error message for a banking application</h2>
			<p>A bank wants to add some custom errors when checking for last names and valid routing numbers. They have found that the direct deposit procedure allows invalid names and routing <a id="_idIndexMarker548"/>numbers to be used. The bank wants a descriptive error message for when these incidents occur. Our job is to create two descriptive custom error messages. Remember to use an idiomatic naming convention for the error variable and a proper structure for the <span class="No-Break">error message.</span></p>
			<p>You need to do <span class="No-Break">the following:</span></p>
			<ol>
				<li>First, you must create two error values for <strong class="source-inline">ErrInvalidLastName</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">ErrInvalidRoutingNumber</strong></span><span class="No-Break">.</span></li>
				<li>Then, you must print the custom message in the <strong class="source-inline">main()</strong> function to show the bank the error message they will receive when those errors <span class="No-Break">are encountered.</span></li>
			</ol>
			<p>The expected output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
invalid last name
invalid routing number</pre>			<p>By the end of this activity, you will be familiar with the steps that are needed to create a custom <span class="No-Break">error message.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this <a id="_idTextAnchor1274"/><a id="_idTextAnchor1275"/>activity can be <span class="No-Break">found </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.01"><span class="No-Break">https://github.com/PacktPublishing/</span>
<span class="No-Break">Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.01</span><span class="No-Break">.</span></a></p>
			<h2 id="_idParaDest-225"><a id="_idTextAnchor1276"/>Activity 6.02 – validating a bank customer’s direct deposit submission</h2>
			<p>The <a id="_idIndexMarker549"/>bank was pleased with the custom error messages that you created in <em class="italic">Activity 6.01 – creating a custom error message for a banking application</em>. They are so pleased that they now want you to implement two methods. These two methods are for validating the last name and the <span class="No-Break">routing number:</span></p>
			<ol>
				<li>You will need to create a struct <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">directDeposit</strong></span><span class="No-Break">.</span></li>
				<li>The <strong class="source-inline">directDeposit</strong> struct will have three string fields: <strong class="source-inline">lastName</strong>, <strong class="source-inline">firstName</strong>, and <strong class="source-inline">bankName</strong>. It will also have two <strong class="source-inline">int</strong> fields called <strong class="source-inline">routingNumber</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">accountNumber</strong></span><span class="No-Break">.</span></li>
				<li>The <strong class="source-inline">directDeposit</strong> struct will have a <strong class="source-inline">validateRoutingNumber</strong> method. The method will return <strong class="source-inline">ErrInvalidRoutingNum</strong> when the routing number is less <span class="No-Break">than 100.</span></li>
				<li>The <strong class="source-inline">directDeposit</strong> struct will have a <strong class="source-inline">validateLastName</strong> method. It will return <strong class="source-inline">ErrInvalidLastName</strong> when <strong class="source-inline">lastName</strong> is an <span class="No-Break">empty string.</span></li>
				<li>The <strong class="source-inline">directDeposit</strong> struct will have a method report. It will print out each of the <span class="No-Break">fields’ values.</span></li>
				<li>In the <strong class="source-inline">main()</strong> function, assign values to the <strong class="source-inline">directDeposit</strong> struct’s fields and call each of the <strong class="source-inline">direct<a id="_idTextAnchor1277"/>Deposit</strong> <span class="No-Break">struct’s methods.</span></li>
			</ol>
			<p>The <a id="_idIndexMarker550"/>expected output is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B18621_06_11.jpg" alt="Figure 6.11: Validating a bank customer’s direct deposit submission" width="655" height="145"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11: Validating a bank customer’s direct deposit submission</p>
			<p>By the end of this activity, you will have learned how to return errors from functions and how to check for errors returned from a function. You will also be able to check for a condition and, based on that condition, return a <span class="No-Break">custom error.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this<a id="_idTextAnchor1278"/><a id="_idTextAnchor1279"/> activity can be <span class="No-Break">found </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.02"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.02</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-226"><a id="_idTextAnchor1280"/>Activity 6.03 – panic on invalid data submission</h2>
			<p>The bank has now decided that it would rather crash the program when an invalid routing <a id="_idIndexMarker551"/>number is submitted. The bank feels that the erroneous data should cause the program to stop processing the direct deposit data. You need to raise panic on an invalid data submission instance. Build this on top of <em class="italic">Activity 6.02 – validating a bank customer’s direct </em><span class="No-Break"><em class="italic">deposit submission</em></span><span class="No-Break">.</span></p>
			<p>For this activity, you only need to do one thing – change the <strong class="source-inline">validateRoutingNumber</strong> method so that it doesn’t return <strong class="source-inline">ErrInvalidRoutingNum</strong>, but<a id="_idTextAnchor1281"/> instead performs <span class="No-Break">a panic:</span></p>
			<p>The expected output is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B18621_06_12.jpg" alt="Figure 6.12: Panic on an invalid routing number" width="948" height="282"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12: Panic on an invalid routing number</p>
			<p>By the end of this activity, you will be able to cause a panic to occur and see how that impacts the flow of <span class="No-Break">the program.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this<a id="_idTextAnchor1282"/><a id="_idTextAnchor1283"/> activity can be <span class="No-Break">found </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.03"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.03</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor1284"/>Activity 6.04 – preventing a panic from crashing the app</h2>
			<p>After <a id="_idIndexMarker552"/>some initial alpha testing, the bank no longer wants the app to crash, Instead, in this activity, we need to recover from the panic that we added in <em class="italic">Activity 6.03 – panic on invalid data submission</em>, and print the error that caused <span class="No-Break">the panic:</span></p>
			<ol>
				<li>Add a <strong class="source-inline">defer</strong> function inside the <span class="No-Break"><strong class="source-inline">validateRoutingNumber</strong></span><span class="No-Break"> method.</span></li>
				<li>Add an <strong class="source-inline">if</strong> statement that checks the error that’s returned from the <strong class="source-inline">recover()</strong> function. If there i<a id="_idTextAnchor1285"/>s an error, then <span class="No-Break">print it:</span></li>
			</ol>
			<p>The <a id="_idIndexMarker553"/>exp<a id="_idTextAnchor1286"/>ected output is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B18621_06_13.jpg" alt="Figure 6.13: Recovering from a panic on an invalid routing number" width="1500" height="312"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13: Recovering from a panic on an invalid routing number</p>
			<p>By the end of this activity, you will have caused a panic, but you will be able to prevent it from crashing the application. You will get an understanding of how the <strong class="source-inline">recover()</strong> function, used in conjunction with the <strong class="source-inline">defer</strong> statement, can be used to prevent the application <span class="No-Break">from crashing.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for thi<a id="_idTextAnchor1287"/><a id="_idTextAnchor1288"/>s activity can be <span class="No-Break">found </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.04"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.04</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-228"><a id="_idTextAnchor1289"/>Summary</h1>
			<p>In this chapter, we looked at the different types of errors that you will encounter while programming, such as syntax, runtime, and semantic errors. We focused more on runtime errors since they are challenging <span class="No-Break">to debug.</span></p>
			<p>Then, we examined the difference between various language philosophies when it comes to dealing with errors. We saw how Go’s syntax for errors is simpler to understand compared to the exception handling that various <span class="No-Break">languages utilize.</span></p>
			<p>An error in Go is a value. Values can be passed around to functions. Any error can be a value, so long as it implements the error interface type. We learned how easily we can create errors. We also learned that we should name our error values so that they start with <strong class="source-inline">Err</strong>, followed by a descriptive camel <span class="No-Break">case name.</span></p>
			<p>Next, we discussed panics and the similarities between a panic and an exception. We also discovered that panics are pretty similar to exceptions; however, if panics aren’t handled, they will cause the program to crash. However, Go has a mechanism that will return control of the program to normal: the <strong class="source-inline">recover()</strong> function. The requirement for recovering from a panic is the usage of the <strong class="source-inline">recover()</strong> function in a deferred function. Then, we learned about the general guidelines for using errors, <strong class="source-inline">panic()</strong>, and <strong class="source-inline">recover()</strong> before exploring how to add additional context to errors using <span class="No-Break">error wrapping.</span></p>
			<p>In the next chapter, we will look at interfaces and their uses, as well as how they differ from how other programming languages implement interfaces. We will see how they can be use<a id="_idTextAnchor1290"/>d to solve various problems that you will face as <span class="No-Break">a programmer.</span></p>
		</div>
	</div></div></body></html>