- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Don’t Panic! Handle Your Errors
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要恐慌！处理您的错误
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will be looking at various code snippets from the Go standard
    packages to get an understanding of Go’s idiomatic way of performing error handling.
    We will also look at how to create custom error types in Go and see more examples
    in the standard library.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看 Go 标准包中的各种代码片段，以了解 Go 语言执行错误处理的惯用方式。我们还将了解如何在 Go 中创建自定义错误类型，并在标准库中查看更多示例。
- en: By the end of this chapter, you will be able to distinguish between the different
    types of errors and compare error handling and exception handling. You will also
    be able to create error values, `panic()`, and properly recover after a panic
    and handle your errors. Lastly, we will briefly discuss adding context to our
    errors through error wrapping.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够区分不同类型的错误，并比较错误处理和异常处理。您还将能够创建错误值、使用`panic()`，并在恐慌后正确恢复，并处理您的错误。最后，我们将简要讨论通过错误包装向我们的错误添加上下文。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you’ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要 Go 版本 1.21 或更高版本。本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06)。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we learned how to reduce, reuse, and recycle good code
    practices with Go through the help of functions, separating logical components,
    and more! We also discovered more regarding functions, such as the fact that functions
    can be passed as parameters and returned from a function. In this chapter, we
    will work with errors and learn how to return those from functions.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何通过函数、分离逻辑组件等方式，借助 Go 语言来减少、重用和回收良好的代码实践！我们还发现了更多关于函数的信息，例如函数可以作为参数传递，也可以从函数中返回。在本章中，我们将处理错误，并学习如何在函数中返回这些错误。
- en: Developers are not perfect and, by extension, neither is the code that they
    produce. All software at some point in time has had errors. Handling errors is
    critical when you are developing software. These errors can have a negative impact
    of varying degrees on its users. The impact on the users of your software can
    be more far-reaching than you realize.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者并不完美，因此他们生产的代码也不完美。所有软件在某个时间点都会出现错误。在软件开发过程中，错误处理至关重要。这些错误可能会对用户产生不同程度的负面影响。您软件对用户的影响可能比您想象的要深远。
- en: 'For instance, let’s consider the Northeast Blackout of 2003\. On August 14,
    there was a blackout for about 50 million people in the United States and Canada
    that lasted for 14 days. This was due to a race condition bug in the alarm system
    in a control room. Technically, a race condition bug is when two separate threads
    try to access the same memory location for a write operation. This race condition
    can cause a program to crash. In this instance, it resulted in over 250 power
    plants going offline. One way to handle a race condition is to ensure proper synchronization
    between the various threads, or small units of execution within a process, and
    allow memory locations to be accessed for write operations by only one thread
    at a time. We will discuss concurrency in more detail later in this book; however,
    this example illustrates how it is important that we, as developers, ensure we
    handle errors properly so that we can try our best to avoid issues such as this.
    If we do not handle errors properly, this can harm the users of our application
    and their way of life, as seen by the power outage incident described here. Yes,
    this is an event from years ago; however, we should take the opportunity to learn
    from the past and work toward handling errors properly to avoid this in the future.
    Further information on the Northeast Blackout can be found online: [https://en.wikipedia.org/wiki/Northeast_blackout_of_2003](https://en.wikipedia.org/wiki/Northeast_blackout_of_2003).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑2003年的东北电网停电事件。2003年8月14日，美国和加拿大大约有5000万人遭遇了为期14天的停电。这是由于控制室警报系统中的竞态条件错误。从技术上讲，竞态条件错误是两个独立的线程试图对同一内存位置进行写操作。这种竞态条件可能导致程序崩溃。在这个例子中，它导致了超过250个发电厂断电。处理竞态条件的一种方法是通过确保各种线程或进程内的执行小单元之间适当的同步，并允许一次只有一个线程对内存位置进行写操作。我们将在本书的后面部分更详细地讨论并发；然而，这个例子说明了我们作为开发者，确保我们正确处理错误的重要性，以便我们尽可能避免此类问题。如果我们没有正确处理错误，这可能会损害我们应用程序的用户及其生活方式，正如这里描述的停电事件所示。是的，这是一个多年前的事件；然而，我们应该抓住这个机会从过去学习，努力正确处理错误，以避免未来再次发生。有关东北电网停电的更多信息可以在网上找到：[https://en.wikipedia.org/wiki/Northeast_blackout_of_2003](https://en.wikipedia.org/wiki/Northeast_blackout_of_2003)。
- en: In this chapter, we will be looking at what an error is, what an error looks
    like in Go, and, more specifically, how to handle errors the Go way. Let’s get
    started!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨错误是什么，Go语言中的错误看起来是什么样子，以及更具体地，如何以Go的方式处理错误。让我们开始吧！
- en: What are errors?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是错误？
- en: 'An error is something that causes your program to produce unintended results.
    Those unintended results could range from the application crashing, an incorrect
    data calculation (such as a bank transaction not being processed correctly), or
    not providing any results. These unintended results are referred to as software
    bugs. Any software will contain errors during its lifetime due to numerous scenarios
    that programmers do not anticipate. The following are possible outcomes when errors
    occur:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是导致你的程序产生非预期结果的东西。这些非预期结果可能包括应用程序崩溃、不正确的数据计算（例如银行交易处理不当），或者没有任何结果。这些非预期结果被称为软件缺陷。任何软件在其生命周期中都会因为程序员没有预料到的众多场景而包含错误。当错误发生时，可能出现以下结果：
- en: The erroneous code could cause the program to crash without warning
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的代码可能导致程序在没有警告的情况下崩溃
- en: The output of the program was not the intended result
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序的输出不是预期的结果
- en: An error message is displayed
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示错误信息
- en: 'There are three types of errors that you might encounter:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到三种类型的错误：
- en: Syntax errors
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法错误
- en: Runtime errors
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时错误
- en: Semantic errors
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义错误
- en: Let’s explore each one in more detail.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨每一个。
- en: Syntax errors
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法错误
- en: 'Syntax errors result from improper use of the programming language. This often
    occurs due to mistyping the code. Most modern IDEs will have some visual way of
    bringing syntax errors to the attention of the programmer. In most modern IDEs,
    syntax errors can be caught at an early stage. They may occur more frequently
    when you are learning a new programming language. A few occurrences of syntax
    errors could be due to the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 语法错误是由于编程语言使用不当造成的。这通常是由于代码输入错误导致的。大多数现代集成开发环境（IDE）都会有一些视觉方式将语法错误通知程序员。在大多数现代IDE中，可以在早期阶段捕获语法错误。当你学习一门新的编程语言时，语法错误可能会更频繁地发生。一些语法错误的出现可能是因为以下原因：
- en: Incorrect use of syntax for a loop
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环语法使用不当
- en: Misplacing or omitting curly braces, parentheses, or brackets
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误地放置或省略花括号、括号或方括号
- en: Misspelled function names or package names
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拼写错误的函数名或包名
- en: Passing the wrong type of argument to a function
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向函数传递错误的参数类型
- en: 'Here is an example of a syntax error:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个语法错误的示例：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output appears as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Go is case-sensitive, so `println` should be `Println`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是大小写敏感的，所以 `println` 应该是 `Println`。
- en: Syntax errors are errors that you receive quick feedback on from `golint` that
    runs within your IDE thanks to the `gopls` language server. `gopls` is the official
    Go language server developed by the Google Go team and provides various language
    features, including code completion and diagnostics on syntax warnings and errors,
    as well as formatting issues. Working with Go code within an IDE that supports
    the `gopls` to enable these features. `golint` itself is a separate command-line
    tool that can provide code analysis and can integrate with `gopls`. It is recommended
    to run your code through a linter before committing. This process is often automated
    when you’re opening up code for team members to review in a **continuous integration**
    (**CI**) environment so that team-based and/or larger projects all have good code
    quality standards.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 语法错误是你在 IDE 中通过 `golint` 收到的快速反馈，`golint` 是由 `gopls` 语言服务器运行的。`gopls` 是由 Google
    Go 团队开发的官方 Go 语言服务器，它提供了各种语言功能，包括代码补全、对语法警告和错误的诊断以及格式化问题。在支持 `gopls` 的 IDE 中与
    Go 代码一起工作以启用这些功能。`golint` 本身是一个独立的命令行工具，可以提供代码分析，并且可以与 `gopls` 集成。建议在提交代码之前运行代码检查器。当你在**持续集成**（**CI**）环境中打开代码供团队成员审查时，这个过程通常会被自动化，以确保基于团队和/或更大规模的项目都有良好的代码质量标准。
- en: Runtime errors
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时错误
- en: These errors occur when the code is asked to perform a task that it cannot do.
    Unlike syntax errors, these are typically only found during the execution of the
    code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误发生在代码被要求执行它无法完成的任务时。与语法错误不同，这些错误通常只在代码执行期间被发现。
- en: 'The following are common examples of runtime errors:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见的运行时错误示例：
- en: Opening a connection to a database that does not exist
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个不存在的数据库的连接
- en: Performing a loop that is bigger than the number of elements in the slice or
    array you are iterating over
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个大于你正在迭代的切片或数组中元素数量的循环
- en: Opening a file that does not exist
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个不存在的文件
- en: Performing a mathematical operation, such as dividing a number by zero
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个数学运算，例如除以零
- en: Exercise 6.01 – runtime errors while adding numbers
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.01 – 添加数字时的运行时错误
- en: 'In this exercise, we are going to write a simple program that sums up a slice
    of numbers. This program will demonstrate an example of a runtime error and will
    crash when it is executed:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个简单的程序，该程序将计算一个数字切片的总和。这个程序将演示一个运行时错误的例子，并在执行时崩溃：
- en: Create a directory called `Exercise06.01` inside the `Chapter06` directory.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter06`目录内创建一个名为`Exercise06.01`的目录。
- en: Create a file called `main.go` inside the directory you created in *step 1*.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*步骤1*中创建的目录内创建一个名为`main.go`的文件。
- en: 'This program will be in `package main`. Import the `fmt` package:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此程序将在 `package main` 中。导入 `fmt` 包：
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Inside the `main` function, we will have a slice of integers that will have
    four elements:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数内部，我们将有一个包含四个元素的整数切片：
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will have a variable, `total`, to be used to sum all the integer variables
    in the slice. Use a `for` loop to sum the variables:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将有一个名为`total`的变量，用于累加切片中的所有整数变量。使用`for`循环来累加变量：
- en: '[PRE4]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we print the results of the total:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们打印出总和的结果：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With that, we have introduced an example of a runtime error to the program;
    so, we will not get the following output:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过这种方式，我们已经向程序中引入了一个运行时错误的例子；因此，我们不会得到以下输出：
- en: '[PRE6]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At the command line, navigate to the directory you created in *step 1*.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，导航到你在*步骤1*中创建的目录。
- en: 'At the command line, type the following:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，键入以下内容：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `go build` command will compile your program and create an executable named
    after the directory you created in *step 1*.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`go build`命令将编译你的程序，并创建一个以你在*步骤1*中创建的目录命名的可执行文件。'
- en: 'Type the name of the file you created in *step 8* and hit *Enter* to run the
    executable (Add the `./main` command). The expected output will be as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*步骤8*中创建的文件中键入文件名并按*Enter*键运行可执行文件（添加`./main`命令）。预期的输出如下：
- en: '![Figure 6.1: Output after executing](img/B18621_06_01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1：执行后的输出](img/B18621_06_01.jpg)'
- en: 'Figure 6.1: Output after executing'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：执行后的输出
- en: As you can see, the program crashed. The `index out of range` panic is a common
    error to new Go developers and veterans alike.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，程序崩溃了。`index out of range` panic是新手和经验丰富的Go开发者都常见的错误。
- en: 'In this example, the error – a panic (we will discuss what a panic is later
    in this chapter) in this program – is the result of iterating in the `for` loop
    by a greater number – in our case, 10 – than the actual number of elements in
    the slice – in our case, 4\. One possible solution would be to use a `for` loop
    with a range:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，这个程序中的错误——一个panic（我们将在本章后面讨论panic是什么）——是由于在`for`循环中迭代次数过多——在我们的例子中，是10次——超过了切片中的实际元素数量——在我们的例子中，是4次。一个可能的解决方案是使用带有范围的`for`循环：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this exercise, we saw how we can avoid runtime errors by paying attention
    to minute details.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何通过关注细节来避免运行时错误。
- en: 'To capture issues more easily before they become runtime errors, it is best
    to do the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在它们成为运行时错误之前更容易地捕获问题，最好做以下事情：
- en: Properly test your code
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确测试你的代码
- en: Avoid `nil` pointer dereferences
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免对`nil`指针进行解引用
- en: Use proper input validation as necessary
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要使用适当的输入验证
- en: Perform boundary checks to check bounds on data before accessing
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在访问之前执行边界检查以检查数据范围
- en: Use proper synchronization mechanisms
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用适当的同步机制
- en: Avoid global state
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免全局状态
- en: Use panic and recover sparingly
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适度使用panic和recover
- en: Conductor thorough code reviews on teammates
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对队友进行彻底的代码审查
- en: Use code linters and analyzers
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码检查器和分析器
- en: Conduct version management for dependencies
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对依赖项进行版本管理
- en: While several of these include trying to be mindful of proper coding practices,
    many of them will also be discussed in subsequent chapters of this book.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其中一些包括尝试注意适当的编码实践，但本书的后续章节中也将讨论许多这些内容。
- en: Semantic errors
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语义错误
- en: Syntax errors are the easiest to debug, followed by runtime errors, while logic
    errors are the hardest. Semantic errors are sometimes very hard to spot as they
    are a result of logical errors that can lead to unexpected behavior.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 语法错误是最容易调试的，其次是运行时错误，而逻辑错误是最难调试的。语义错误有时很难发现，因为它们是导致意外行为的逻辑错误的结果。
- en: For example, in 1998, when the Mars Climate Orbiter was launched, its purpose
    was to study the climate of Mars, but due to a logic error in the system, the
    Mars Climate Orbiter, valued at $235 million, was destroyed. After some analysis,
    it was discovered that the calculations of units on the ground controller system
    were done in imperial units and the software on the Orbiter was done in metric
    units. This was a logic error that caused the navigation system to incorrectly
    calculate its maneuvers in space. As indicated by this historical tale of a semantic
    error, these are defects in the way code processes elements of a program. These
    types of errors are often caught at runtime. This is another illustration of the
    significant consequences erroneous code can cause since the Mars Climate Orbiter
    was very expensive and included many hours of engineering efforts.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在1998年，当火星气候轨道器发射时，其目的是研究火星的气候，但由于系统中的逻辑错误，价值2.35亿美元的火星气候轨道器被摧毁。经过一些分析，发现地面控制器系统上的单位计算是在英制单位下进行的，而轨道器上的软件是在公制单位下进行的。这是一个导致导航系统在太空中错误计算其机动动作的逻辑错误。正如这个语义错误的典型案例所示，这些是代码处理程序元素的方式上的缺陷。这类错误通常在运行时被发现。这是错误代码可能造成的重大后果的另一个例证，因为火星气候轨道器非常昂贵，并包含了大量的工程努力。
- en: 'Here are some reasons for semantic errors to occur:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些导致语义错误发生的原因：
- en: Logical errors such as incorrect computations
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑错误，例如计算错误
- en: Accessing incorrect resources (files, databases, servers, and variables)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问错误的资源（文件、数据库、服务器和变量）
- en: Incorrect setting of variables for negation (not equal versus equal)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量取反设置不正确（不等号与等号）
- en: Type errors on variables
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量上的类型错误
- en: Incorrect use of functions, data structures, pointers, and concurrency
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数、数据结构、指针和并发使用不当
- en: Exercise 6.02 – a semantic error with walking distance
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.02 – 走路距离的语义错误
- en: We are writing an application that will determine whether we should walk to
    our destination or take a car. If our destination is greater than or equal to
    2 km, we are going to take a car. If it is less than 2 km, then we will walk to
    our destination. We are going to demonstrate a semantic error with this program.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在编写一个应用程序，该应用程序将确定我们是否应该步行到目的地或开车。如果我们的目的地大于或等于2公里，我们将开车。如果它小于2公里，那么我们将步行到我们的目的地。我们将通过这个程序演示一个语义错误。
- en: 'The expected output of this exercise is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的预期输出如下：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Follow these steps:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Create a directory called `Exercise6.02` inside the `Chapter06` directory.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter06`目录中创建一个名为`Exercise6.02`的目录。
- en: Save a file called `main.go` inside the directory you created in the previous
    step. This program will be inside `package main`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步创建的目录中保存一个名为`main.go`的文件。此程序将位于`package main`中。
- en: 'Import the `fmt` package:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`fmt`包：
- en: '[PRE10]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside the `main` function, display a message to take the car when `km` is
    greater than `2`, and when `km` is less than `2`, to send a message for walking:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中，当`km`大于`2`时显示一条取车的消息，当`km`小于`2`时，发送一条步行消息：
- en: '[PRE11]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At the command line, navigate to the directory you created.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，导航到您创建的目录。
- en: 'At the command line, type the following:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，键入以下内容：
- en: '[PRE12]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `go build` command will compile your program and create an executable named
    after the directory you created.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`go build`命令将编译您的程序，并创建一个以您创建的目录命名的可执行文件。'
- en: 'Type the name of the file you created in *Step 6* and hit *Enter* to run the
    executable (Add the `./main` command). The expected output will be as follows:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*步骤6*中输入您创建的文件名并按*Enter*键运行可执行文件（添加`./main`命令）。预期的输出如下：
- en: 'You will get the following output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下输出：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The program will run with no errors, but the message that’s displayed won’t
    be what we expected.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将无错误运行，但显示的消息并非我们所期望的。
- en: 'As mentioned previously, the program runs with no errors, but the results are
    not what we expected. This is because we have a logic error. Our `if` statement
    does not account for `km` equal to `2`. It only checks that the distance is greater
    than `2`. Fortunately, this is a simple fix: replace `>` with `>=`. Now, the program
    will give the results that we expect:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，程序运行没有错误，但结果并非我们所期望的。这是因为我们有一个逻辑错误。我们的`if`语句没有考虑到`km`等于`2`的情况。它只检查距离是否大于`2`。幸运的是，这是一个简单的修复：将`>`替换为`>=`。现在，程序将给出我们期望的结果：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This simple program made it easy to debug the logic error, but these types of
    errors in a larger program may not be as easy to spot.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的程序使得调试逻辑错误变得容易，但在更大的程序中，这类错误可能并不容易发现。
- en: Semantic errors involve understanding the intended logic of the code. It is
    best to be thorough in testing. This includes various types of tests, such as
    unit, integration, end-to-end, and others. Each type of test serves a specific
    purpose in capturing different aspects of errors and preventing unintended consequences.
    Later in this book, we will discuss the various types of testing in further detail.
    Additionally, adopting best practices for Go and a continuous learning mindset
    can help!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 语义错误涉及理解代码的预期逻辑。最好进行彻底的测试。这包括各种类型的测试，如单元测试、集成测试、端到端测试等。每种类型的测试在捕捉不同方面的错误和防止意外后果方面都起着特定的作用。本书后面将更详细地讨论各种测试类型。此外，采用Go的最佳实践和持续学习的思维方式可以帮助！
- en: The remainder of this chapter will focus on the runtime errors we’ve covered.
    However, it is good to understand the various types of errors that you, as a programmer,
    could encounter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的剩余部分将重点介绍我们已经讨论过的运行时错误。然而，了解作为程序员可能遇到的错误的各种类型是很好的。
- en: Error handling using other programming languages
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用其他编程语言进行错误处理
- en: Programmers who are new to Go and who have a background in other programming
    languages may initially find Go’s methodology for dealing with errors a bit odd.
    Go does not handle errors in the same fashion as other languages, such as Java,
    Python, C#, and Ruby. Those languages perform exception handling.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者Go并且有其他编程语言背景的程序员来说，他们可能会觉得Go处理错误的方法有些奇怪。Go不按与其他语言（如Java、Python、C#和Ruby）相同的方式处理错误。那些语言执行异常处理。
- en: 'The following code snippets are some examples of how other languages handle
    errors by performing exception handling:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些其他语言通过执行异常处理来处理错误的代码片段示例：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Typically, exceptions, if not handled, will crash your application. In most
    cases, exception handling tends to be implicit checking versus Go’s explicit checking
    for errors returned by its functions. In the exception-handling paradigm, anything
    can fail, and you must account for that. Each function can throw an exception,
    but you do not know what that exception could be.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，如果没有处理异常，应用程序将会崩溃。在大多数情况下，异常处理倾向于是隐式检查，与Go函数返回的错误相比是显式检查。在异常处理范式中，任何事物都可能失败，你必须考虑到这一点。每个函数都可能抛出异常，但你不知道那个异常会是什么。
- en: In the error handling paradigm that Go uses, it is obvious when the programmer
    does not handle the error because the function returns the error code, and you
    can see that they did not check for the error. We will be looking at the specifics
    of checking for error code later in this chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go使用的错误处理范式中，当程序员没有处理错误时，很明显，因为函数返回错误代码，你可以看到他们没有检查错误。我们将在本章后面讨论检查错误代码的细节。
- en: 'Most programming languages follow a similar pattern to the one shown in the
    previous code snippet. It is usually some sort of `try..catch..finally` block.
    One point of contention with the `try..catch..finally` block is that the control
    flow of the program’s execution gets interrupted and can follow a different path.
    This can lead to several logic errors and difficulty in the readability of the
    code. Here is a quick peek at how Go handles errors:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言遵循与之前代码片段中所示类似的模式。通常是一些`try..catch..finally`块。与`try..catch..finally`块的一个争议点是程序的执行流程被中断，可能会遵循不同的路径。这可能导致几个逻辑错误，并使代码的可读性变得困难。以下是如何快速查看Go处理错误的方式：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code snippet is a very simple syntax for handling the error. We
    will look at this in greater detail in the following sections.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段是处理错误的非常简单的语法。我们将在接下来的章节中更详细地探讨这一点。
- en: Error interface type
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误接口类型
- en: 'What is an error in Go? An error in Go is a value. Here’s a quote from Rob
    Pike, one of the pivotal pioneers of Go:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的错误是什么？Go中的错误是一个值。以下是从Go的关键先驱之一Rob Pike引述的一句话：
- en: “*Values can be programmed, and since errors are values, errors can be programmed.
    Errors are not like exceptions. There’s nothing special about them, whereas an
    unhandled exception can crash* *your program.*”
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: “*值可以被编程，由于错误是值，错误也可以被编程。错误不像异常那样特殊，它们没有什么特别之处，而未处理的异常可能会导致* *你的程序崩溃* *。”
- en: Since errors are values, they can be passed into a function, returned from a
    function, and evaluated just like any other value in Go.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 由于错误是值，它们可以被传递到函数中，从函数中返回，并且像Go中的任何其他值一样进行评估。
- en: 'An error in Go is anything that implements the error interface. Interfaces
    will be explained in detail in the following chapter, so we will keep the details
    light in this chapter concerning interface references. We need to look at some
    fundamental aspects that make up the error type in Go. To be an error type in
    Go, it must first satisfy `type` `error interface`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，任何实现了错误接口的东西都可以被视为错误。接口将在下一章中详细解释，所以在这章中我们将简要介绍接口引用。我们需要查看构成Go中错误类型的一些基本方面。要成为Go中的错误类型，它必须首先满足`type`
    `error interface`：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The wonderful thing about Go is its simplistic design regarding language features.
    This can easily be seen with the error interface that Go’s standard library uses.
    To satisfy the error interface, only two things are required:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Go的奇妙之处在于其关于语言特性的简单设计。这可以通过Go标准库使用的错误接口轻松看出。为了满足错误接口，只需要两个条件：
- en: The method name, `Error()`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名，`Error()`
- en: The `Error()` method to return a string
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回字符串的`Error()`方法
- en: It is important to understand that an error type is an interface type. Any value
    that is an error can be described as a string. When performing error handling
    in Go, the functions will return error values. The Go language uses this throughout
    the standard library.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 理解错误类型是一个接口类型非常重要。任何错误值都可以描述为一个字符串。在Go中进行错误处理时，函数将返回错误值。Go语言在整个标准库中都使用这一点。
- en: 'Look at the following code snippet for a starting discussion point on errors:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是关于错误讨论的起点：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will not go into every detail of the function and instead focus on the error
    portion of the code. In [*Chapter 5*](B18621_05.xhtml#_idTextAnchor1048), *Reduce,
    Reuse, and Recycle*, we learned that functions can return multiple values. This
    is a powerful feature that most languages do not have. This is powerful, especially
    when dealing with error values. The `strconv.Atoi()` function returns an `int`
    type and an error, as seen in the example stated previously. It is a function
    that is in the Go standard library. For functions that return error values, the
    error value should be the last return value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨函数的每个细节，而是专注于代码的错误部分。在[*第五章*](B18621_05.xhtml#_idTextAnchor1048)“减少、重用和回收”中，我们了解到函数可以返回多个值。这是一个大多数语言都没有的强大功能。这一点在处理错误值时尤其强大。`strconv.Atoi()`函数返回一个`int`类型和一个错误，正如之前提到的示例中所示。这是一个Go标准库中的函数。对于返回错误值的函数，错误值应该是最后一个返回值。
- en: 'It is Go-idiomatic to evaluate the error value for functions or methods that
    return an error. It is generally bad practice to not handle an error that is returned
    from a function. When returned and ignored, an error can lead to lots of wasted
    debugging efforts. It can also cause unforeseen consequences in your program.
    If the value is not `nil`, then we have an error and must decide how we want to
    handle it. Depending on the scenario, we might want to do one of the following
    things:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，对于返回错误值的函数或方法，评估错误值是 Go 语言的规范。不处理从函数返回的错误通常是不良的实践。当返回并被忽略时，错误可能导致大量的调试工作浪费。它也可能导致程序中出现未预见的后果。如果值不是
    `nil`，那么我们遇到了错误，必须决定如何处理它。根据场景，我们可能想要执行以下操作之一：
- en: Return the error to the caller
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将错误返回给调用者
- en: Log the error and continue execution
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录错误并继续执行
- en: Stop the execution of the program
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止程序的执行
- en: Ignore it (this is highly not recommended)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略它（这强烈不推荐）
- en: Panic (only in very rare conditions; we will discuss this in more detail later)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出异常（仅在非常罕见的情况下；我们将在稍后详细讨论）
- en: If the value of error is `nil`, this means there is no error. No further steps
    are necessary.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错误的值为 `nil`，这意味着没有错误。不需要进一步的操作。
- en: 'Let’s take a closer look at the standard package regarding the error type.
    We will start by looking at each piece of code in the [https://packt.live/2rk6r8Z](https://packt.live/2rk6r8Z)
    file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看关于错误类型的标准包。我们将从查看 [https://packt.live/2rk6r8Z](https://packt.live/2rk6r8Z)
    文件中的每一行代码开始：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `errorString` struct is in the `errors` package. This struct is used to
    store the string version of the error. `errorString` has a single field of `s`
    that is of the `string` type. `errorString` and the field are unexportable. This
    means that we can’t access the `errorString` type or its field, `s`, directly.
    The following code shows an example of trying to access an unexported `errorString`
    type and its field, `s`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`errorString` 结构体位于 `errors` 包中。这个结构体用于存储错误的字符串版本。`errorString` 有一个名为 `s` 的单个字段，其类型为
    `string`。`errorString` 和该字段是不可导出的。这意味着我们无法直接访问 `errorString` 类型或其字段 `s`。以下代码展示了尝试访问不可导出的
    `errorString` 类型及其字段 `s` 的示例：'
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here’s the output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '![Figure 6.2: Expected output for the unexported field](img/B18621_06_02.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2：未导出字段的预期输出](img/B18621_06_02.jpg)'
- en: 'Figure 6.2: Expected output for the unexported field'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：未导出字段的预期输出
- en: 'On the surface, it appears that `errorString` is neither accessible nor useful,
    but we should keep digging into the standard library:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，`errorString` 似乎既不可访问也不实用，但我们应该继续挖掘标准库：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `errorString` type has a method that implements the error interface. It
    satisfies the requirements, provides a method called `Error()`, and returns a
    string. The error interface has been satisfied. We now have access to the `errorString`
    field, `s`, through the `Error()` method. This is how an error gets returned within
    the standard library.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`errorString` 类型有一个实现错误接口的方法。它满足要求，提供了一个名为 `Error()` 的方法，并返回一个字符串。错误接口已被满足。我们现在可以通过
    `Error()` 方法访问 `errorString` 字段 `s`。这就是错误在标准库中返回的方式。'
- en: You should now have a basic understanding of what an error is in Go. Next, we’ll
    learn how to create error types in Go.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该对 Go 中的错误有基本理解了。接下来，我们将学习如何在 Go 中创建错误类型。
- en: Creating error values
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建错误值
- en: 'In the standard library, the `errors` package has a method that we can use
    to create errors:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库中，`errors` 包有一个我们可以用来创建错误的方法：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is important to understand that the `New` function takes a string as an argument,
    converts it into `*errors.errorString`, and returns an error value. The underlying
    value of the error type that gets returned is of the `*``errors.errorString` type.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解 `New` 函数接受一个字符串作为参数，将其转换为 `*errors.errorString`，并返回一个错误值。返回的错误类型的底层值是
    `*errors.errorString` 类型。
- en: 'We can prove this by running the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下代码来证明这一点：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is an example from Go’s standard library, `http`, that uses the `errors`
    package to create package-level variables:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Go 标准库 `http` 中使用 `errors` 包创建包级变量的一个示例：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When creating errors in Go, it is idiomatic to start with the `Err` variable.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中创建错误时，通常从 `Err` 变量开始。
- en: Exercise 6.03 – creating an application to calculate pay for the week
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.03 – 创建一个计算每周工资的应用程序
- en: In this exercise, we are going to create a function that calculates pay for
    the week. This function will accept two arguments – the hours worked during the
    week and the hourly rate. The function is going to check whether the two parameters
    meet the criteria for being valid. The function will need to calculate regular
    pay, which is hours less than or equal to 40, and overtime pay, which is hours
    greater than 40 for the week.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个函数来计算一周的工资。这个函数将接受两个参数——一周内工作的小时数和时薪。该函数将检查这两个参数是否符合有效性的标准。该函数需要计算正常工资，即一周内工作的小时数少于或等于40，以及加班工资，即一周内工作的小时数超过40。
- en: We will create two error values using `errors.New()`. The one error value will
    be used when there is an invalid hourly rate. An invalid hourly rate in our app
    is an hourly rate that is less than 10 or greater than 75\. The second error value
    will be when hours per week are not between 0 and 80.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`errors.New()`创建两个错误值。其中一个错误值将在时薪无效时使用。在我们应用中，无效的时薪是指小于10或大于75的时薪。第二个错误值将在每周工作小时数不在0到80之间时使用。
- en: 'Use the IDE of your choice. One option would be Visual Studio Code. Follow
    these steps:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您选择的IDE。一个选项是Visual Studio Code。按照以下步骤操作：
- en: Create a directory called `Exercise6.03` inside the `Chapter06` directory.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter06`目录中创建一个名为`Exercise6.03`的目录。
- en: Save a file called `main.go` inside the directory you created in the previous
    step The `main.go` file will be in `package main`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步创建的目录中保存一个名为`main.go`的文件。`main.go`文件将在`package main`中。
- en: 'Import the two Go standard libraries, `errors` and `fmt`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入两个Go标准库，`errors`和`fmt`：
- en: '[PRE25]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With that, we have declared our error variables using `errors.New()`. Now,
    we can use idiomatic Go for the variable name, starting it with `Err` and camel
    casing. Our error string is in lowercase with no punctuation:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们已经使用`errors.New()`声明了我们的错误变量。现在，我们可以使用Go的惯用命名方法，以`Err`开头并使用驼峰式命名。我们的错误字符串是小写的，不带标点符号：
- en: '[PRE26]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Inside the `main` function, we will be calling our `payday()` function three
    times. We will declare our error variables using `errors.New()` and check `err`
    after the function:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们将调用三次`payday()`函数。我们将使用`errors.New()`声明错误变量，并在函数调用后检查`err`：
- en: '[PRE27]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create the `payDay` function and make it accept two arguments (`hoursWorked`
    and `hourlyRate`). The function will return an `int` type and an error. We will
    discuss this step by step afterward:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`payDay`的函数，并使其接受两个参数（`hoursWorked`和`hourlyRate`）。该函数将返回一个`int`类型和一个错误。我们将在之后一步步讨论这个步骤：
- en: '[PRE28]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will use an `if` statement to check whether the hourly rate is less than
    10 or greater than 75\. If `hourlyRate` meets those conditions, we will return
    `0` and our custom error, `ErrHourlyRate`. If `hourlyRate` does not meet those
    conditions, then the returned value will be `return hoursWorked * hourlyRate,
    nil`. We return `nil` for the error because there was no error:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`if`语句检查时薪是否小于10或大于75。如果`hourlyRate`满足这些条件，我们将返回`0`和我们的自定义错误`ErrHourlyRate`。如果`hourlyRate`不满足这些条件，则返回值将是`return
    hoursWorked * hourlyRate, nil`。我们返回`nil`作为错误，因为没有错误发生：
- en: '[PRE29]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In *step 7*, we validated `hourlyRate`. Now, we will need to validate `hoursWorked`.
    We will add another `if` statement to the `payDay()` function that will check
    whether `hoursWorked` is less than `0` or greater than `80`. If `hoursWorked`
    matches that condition, we will return `0` and the error, `ErrHoursWorked`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*第7步*中，我们验证了`hourlyRate`。现在，我们需要验证`hoursWorked`。我们将在`payDay()`函数中添加另一个`if`语句，检查`hoursWorked`是否小于`0`或大于`80`。如果`hoursWorked`符合该条件，我们将返回`0`和错误，`ErrHoursWorked`：
- en: '[PRE30]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the previous two steps, we added `if` statements to validate the arguments
    being passed to the function. In this step, we will add another `if` statement
    to calculate overtime pay. Overtime pay is hours greater than `40`. The hours
    over `40` are double `hourlyRate`. The hours less than or equal to `40` are at
    `hourlyRate`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前两个步骤中，我们添加了`if`语句来验证传递给函数的参数。在这个步骤中，我们将添加另一个`if`语句来计算加班工资。加班工资是指超过`40`小时的工作时间。超过`40`小时的工作时间是时薪的两倍。不超过`40`小时的工作时间是按时薪计算的：
- en: '[PRE31]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the `main()` function, we will call the `payDay()` function three times
    with various arguments. We will check the error after each call and print the
    error message if applicable. If there is no error, then we print the pay for the
    week:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们将用不同的参数三次调用`payDay()`函数。我们将在每次调用后检查错误，并在适用的情况下打印错误消息。如果没有错误，则打印一周的工资：
- en: '[PRE32]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the command line, navigate to the directory you created previously.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，导航到您之前创建的目录。
- en: 'In the command line, type the following:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，输入以下内容：
- en: '[PRE33]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `go build` command will compile your program and create an executable named
    after the directory you created.
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`go build`命令将编译你的程序并创建一个以你创建的目录命名的可执行文件。'
- en: 'Type the name of the file you created and hit *Enter* to run the executable:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入你创建的文件名并按*Enter*键运行可执行文件：
- en: '[PRE34]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The expected output is as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this exercise, we saw how to create custom error messages that can be used
    to easily determine why the data was considered invalid. We also showed how to
    return multiple values from a function and to check for errors from the function.
    In the next section, we will look at how to use panic in our applications.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们展示了如何创建自定义的错误信息，这些信息可以用来轻松地确定数据为何被认为是无效的。我们还展示了如何从函数中返回多个值，以及如何检查函数中的错误。在下一节中，我们将探讨如何在我们的应用程序中使用panic。
- en: Panic
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Panic
- en: Several languages use exceptions for handling errors. However, Go does not use
    exceptions – it uses something called a panic. This is a built-in function that
    causes a program to crash. It stops the normal execution of the current goroutine
    where the panic happened and all other ongoing goroutines and shows a stack trace
    of what occurred.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 几种语言使用异常来处理错误。然而，Go不使用异常——它使用一种称为panic的东西。这是一个导致程序崩溃的内置函数。它停止panic发生处的当前goroutine的正常执行，以及所有其他正在进行的goroutines，并显示发生情况的堆栈跟踪。
- en: In Go, a panic is not the norm, unlike other languages where an exception is
    the norm. A panic signal indicates something abnormal that is occurring within
    your code. Usually, when a panic is initiated by runtime or the developer, it
    is to protect the integrity of the program.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，panic不是常态，与其他语言中异常是常态不同。panic信号表示代码中正在发生异常情况。通常，当panic由运行时或开发者启动时，是为了保护程序的完整性。
- en: Errors and panics differ in their purposes and how they are handled by the Go
    runtime. An error in Go indicates that something unexpected occurred, but it will
    not adversely impact the integrity of the program. Go expects that the developer
    will handle the error properly. The function or other programs will not typically
    crash if you do not handle the error. However, panics differ in this regard. When
    a panic occurs, it will ultimately crash the system unless there are handlers
    to handle the panic. If there are no handlers for the panic, it will go all the
    way up the stack and crash the program.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 错误和panic在目的和Go运行时如何处理它们方面有所不同。Go中的错误表示发生了意外情况，但它不会对程序的完整性产生不利影响。Go期望开发者正确处理错误。如果你没有处理错误，函数或其他程序通常不会崩溃。然而，panic在这方面有所不同。当发生panic时，除非有处理panic的处理程序，否则它最终会崩溃系统。如果没有处理panic的处理程序，它将一路向上堆栈并崩溃程序。
- en: One example that we will look at later in this chapter is where a panic occurs
    due to an index being out of range. This is typical when trying to access the
    index of a collection that doesn’t exist. If Go did not panic in this case, it
    could harm the integrity of the program, such as other parts of the program trying
    to store or retrieve data that is not there in the collection.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面我们将探讨的一个例子是，由于索引超出范围而发生的panic。这在尝试访问不存在的集合的索引时很典型。如果Go在这种情况下不panic，可能会损害程序的完整性，例如程序的其他部分尝试存储或检索集合中不存在的数据。
- en: Note
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Review the topic of goroutines to understand what occurs in Go when you panic.
    At a high level, the `main()` function is a Goroutine. When a panic occurs, you
    will see references to “Goroutine running” in the error message.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾goroutines的相关内容，以了解在Go中panic时会发生什么。从高层次来看，`main()`函数是一个Goroutine。当发生panic时，你将在错误信息中看到“Goroutine
    running”的引用。
- en: 'Panics can be initiated by the developer and can be caused during the execution
    of a program by runtime errors. A `panic()` function accepts an empty interface.
    For now, suffice to say, this means it can accept anything as an argument. However,
    in most cases, you should pass an error type to the `panic()` function. It is
    more intuitive to the user of our function to have some details on what caused
    the panic. Passing an error to the panic function is also idiomatic in Go. We
    will also see how recovering from a panic that has an error type passed to it
    gives us some different options when dealing with panic. When a panic occurs,
    it will generally follow these steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 恐慌可以被开发者发起，也可以在程序执行过程中由运行时错误引起。`panic()`函数接受一个空接口。目前，只需说，这意味着它可以接受任何作为参数。然而，在大多数情况下，你应该将错误类型传递给`panic()`函数。对于我们的函数用户来说，了解导致恐慌的详细信息更直观。将错误传递给恐慌函数也是Go中的惯例。我们还将看到如何从传递错误类型的恐慌中恢复，这为我们处理恐慌提供了不同的选项。当发生恐慌时，它通常遵循以下步骤：
- en: The execution is stopped.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行被停止。
- en: Any deferred functions in the panicking function will be called.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在恐慌函数中的任何延迟函数都将被调用。
- en: Any deferred functions in the stack of the panicking function will be called.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在恐慌函数的调用栈中的任何延迟函数都将被调用。
- en: It will continue up the stack until it reaches `main()`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将继续向上堆栈传播，直到达到`main()`。
- en: Statements after the panicking function will not execute.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在恐慌函数之后的语句将不会执行。
- en: The program then crashes.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序随后崩溃。
- en: 'Here’s how a panic works:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是恐慌的工作原理：
- en: '![Figure 6.3: The working of a panic](img/B18621_06_03.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3：恐慌的工作原理](img/B18621_06_03.jpg)'
- en: 'Figure 6.3: The working of a panic'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：恐慌的工作原理
- en: The preceding diagram illustrates code in the `main` function that calls the
    `a()` function. This function then calls the `b()` function. Inside `b()`, a panic
    occurs. The `panic()` function is not handled by any of the code upstream (`a()`
    or the `main()` function), so the program will crash the `main()` function.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示说明了`main`函数中调用`a()`函数的代码。然后该函数调用`b()`函数。在`b()`内部发生恐慌。`panic()`函数没有被上游的任何代码（`a()`或`main()`函数）处理，所以程序将崩溃`main()`函数。
- en: 'Here’s an example of a panic that occurs in Go. Try to determine why this program
    panics:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在Go中发生的恐慌示例。试着确定这个程序为什么崩溃：
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of this panic is shown here:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个恐慌的输出如下所示：
- en: '![Figure 6.4: Panic example](img/B18621_06_04.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4：恐慌示例](img/B18621_06_04.jpg)'
- en: 'Figure 6.4: Panic example'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：恐慌示例
- en: The panic runtime error is a common one that you will encounter while developing.
    It is an `index out of range` error. Go generated this panic because we are trying
    to iterate over a slice more times than there are elements. Go felt that this
    is a reason to panic because it puts the program in an abnormal condition.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 恐慌运行时错误是在开发过程中经常会遇到的一个常见错误。它是一个`index out of range`错误。Go生成这个恐慌是因为我们试图迭代一个比元素多的切片。Go认为这是一个恐慌的理由，因为它使程序处于不正常的状态。
- en: 'Here’s a snippet of code that demonstrates the basics of using a panic:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个演示使用恐慌的基本代码片段：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Code synopsis**:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码摘要**：'
- en: The function panics because the argument to the function message is `"good-bye"`.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数恐慌是因为函数消息的参数是 `"good-bye"`。
- en: The `panic()` function prints the error message. Having a good error message
    helps with the debugging process.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`panic()`函数打印错误消息。一个好的错误消息有助于调试过程。'
- en: Inside the panic, we are using `errors.New()`, which we used in the previous
    section to create an error type.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在恐慌中，我们使用了`errors.New()`，这是我们之前章节中用来创建错误类型的。
- en: As you can see, `fmt.Println()` does not get executed in the `main()` function.
    Since there are no `defer` statements, execution stops immediately.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如您所见，`fmt.Println()`在`main()`函数中没有被执行。由于没有`defer`语句，执行将立即停止。
- en: 'The expected output for this code snippet is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段的预期输出如下：
- en: '![Figure 6.5: Panic example output](img/B18621_06_05.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5：恐慌示例输出](img/B18621_06_05.jpg)'
- en: 'Figure 6.5: Panic example output'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：恐慌示例输出
- en: 'The following code snippet shows how `panic` and a `defer` statement function
    together:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了`panic`和`defer`语句如何一起工作：
- en: main.go
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: main.go
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of this panic example is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个恐慌示例的输出如下：
- en: '![Figure 6.6: Panic example output](img/B18621_06_06.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6：恐慌示例输出](img/B18621_06_06.jpg)'
- en: 'Figure 6.6: Panic example output'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：恐慌示例输出
- en: 'Let’s understand the code in parts:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分部分理解这段代码：
- en: We start by examining the code in the `message()` function since that is where
    the panic starts. When the panic occurs, it runs the `defer` statement within
    the panicking function, `message()`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先检查`message()`函数中的代码，因为panic就是从这里开始的。当panic发生时，它会运行panic函数中的`defer`语句，即`message()`。
- en: The deferred function, `func f()`, runs in the `message()` function.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 延迟函数`func f()`在`message()`函数中运行。
- en: Going up the call stack, the next function is the `test()` function, and its
    deferred function, `n()`, will execute.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用栈中向上，下一个函数是`test()`函数，它的延迟函数`n()`将执行。
- en: Finally, we get to the `main()` function, where the execution is stopped by
    the panicking function. The print statement in `main()` does not get executed.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们到达`main()`函数，执行被panic函数停止。`main()`中的打印语句不会执行。
- en: Note
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You may have seen `os.Exit()` used to stop the execution of a program. `os.Exit()`
    stops execution immediately and returns a status code. No deferred statements
    are run when `os.Exit()` is performed. `Panic` is preferred over `os.Exit()` in
    certain cases as a panic will run deferred functions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能见过使用`os.Exit()`来停止程序的执行。`os.Exit()`会立即停止执行并返回一个状态码。当执行`os.Exit()`时，不会运行任何延迟语句。在某些情况下，`panic`比`os.Exit()`更受欢迎，因为panic会运行延迟函数。
- en: Exercise 6.04 – Crashing the program on errors using a panic
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Exercise 6.04 – 使用panic在错误时崩溃程序
- en: In this exercise, we will be modifying *Exercise 6.03 – creating an application
    to calculate pay for the week*. Consider the following scenario, where the requirements
    have changed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将修改*Exercise 6.03 – 创建一个计算每周工资的应用程序*。考虑以下场景，其中要求已经改变。
- en: We no longer need to return error values from our `payDay()` function. It has
    been decided that we cannot trust the user of the program to respond properly
    to the errors. There have been complaints of incorrect paychecks. We believe this
    is due to the caller of our function ignoring the errors being returned.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要从`payDay()`函数返回错误值。已经决定我们不能信任程序的用户正确地响应错误。有人抱怨工资单不正确。我们相信这是由于调用我们的函数的人忽略了返回的错误。
- en: The `payDay()` function will now only return the pay amount and no errors. When
    the arguments provided to the function are invalid, instead of returning an error,
    the function will panic. This will cause the program to stop immediately and,
    therefore, not process a paycheck.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`payDay()`函数现在将只返回工资金额，而不返回错误。当提供给函数的参数无效时，而不是返回错误，函数将panic。这将导致程序立即停止，因此不会处理工资单。'
- en: 'Use the IDE of your choice. One option could be Visual Studio Code. Now, follow
    these steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你选择的IDE。一个选项可以是Visual Studio Code。现在，按照以下步骤操作：
- en: Create a directory called `Exercise6.04` inside the `Chapter06` directory.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter06`目录内创建一个名为`Exercise6.04`的目录。
- en: Save a file called `main.go` inside the directory you created in the previous
    step. This program will be inside `package main`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步创建的目录中保存一个名为`main.go`的文件。这个程序将位于`package main`中。
- en: 'Enter the following code in `main.go`:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中输入以下代码：
- en: '[PRE39]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Inside the `main` function, call the `payDay()` function, assign it to only
    one variable, `pay`, and then print it:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中，调用`payDay()`函数，将其赋值给一个变量`pay`，然后打印它：
- en: '[PRE40]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Change the return type of the `payDay()` function so that it only returns `int`:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`payDay()`函数的返回类型更改为只返回`int`：
- en: '[PRE41]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Inside the `payDay()` function, assign a variable, `report`, to an anonymous
    function. This anonymous function provides details of the arguments provided to
    the `payDay()` function. Even though we are not returning errors, this will provide
    some insight as to why the function panics. Since it is a deferred function, it
    will always execute before the function exits:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`payDay()`函数中，将一个变量`report`赋值给一个匿名函数。这个匿名函数提供了传递给`payDay()`函数的参数的详细信息。尽管我们不是返回错误，但这将提供一些关于为什么函数panic的见解。由于它是一个延迟函数，它将在函数退出之前始终执行：
- en: '[PRE42]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The business rule for valid `hourlyRate` and `hoursWorked` stays the same as
    in the previous exercise. Instead of returning an error, we will be using the
    `panic` function. When the data is invalid, we panic and pass the argument of
    `ErrHourlyRate` or `ErrHoursWorked`.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于有效的`hourlyRate`和`hoursWorked`的业务规则与之前的练习相同。而不是返回错误，我们将使用`panic`函数。当数据无效时，我们panic并传递`ErrHourlyRate`或`ErrHoursWorked`的参数。
- en: The arguments that are passed to the `panic()` function assist the user of our
    function in `understanding` the cause of the panic.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 传递给`panic()`函数的参数帮助我们的函数用户`理解`panic的原因。
- en: 'When a panic occurs in the `payDay()` function, the `defer` function, `report()`,
    will give the caller some insight into why the panic occurred. The panic will
    bubble up the stack to the `main()` function and execution will stop immediately.
    The following code must be added after the `defer` function in the `payDay()`
    function:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `payDay()` 函数发生恐慌时，`defer` 函数 `report()` 将向调用者提供有关恐慌原因的一些洞察。恐慌会向上冒泡到 `main()`
    函数，并且执行将立即停止。必须在 `payDay()` 函数中的 `defer` 函数之后添加以下代码：
- en: '[PRE43]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: At the command line, navigate to the directory you created.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，导航到您创建的目录。
- en: 'At the command line, type the following:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，键入以下内容：
- en: '[PRE44]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `go build` command will compile your program and create an executable named
    after the directory you created.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`go build` 命令将编译您的程序并创建一个以您创建的目录命名的可执行文件。'
- en: Type in the name of the file you created and hit *Enter* to run the executable.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入你创建的文件名并按 *Enter* 键来运行可执行文件。
- en: 'The expected output should be as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出应该是以下内容：
- en: '![Figure 6.7: Panic exercise output](img/B18621_06_07.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7：恐慌练习输出](img/B18621_06_07.jpg)'
- en: 'Figure 6.7: Panic exercise output'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：恐慌练习输出
- en: In this exercise, we learned how to perform a panic and pass an error to the
    `panic()` function. This aids the user of the function in gaining a good understanding
    of the cause of the panic. In the next section, we will learn how to regain control
    of the program after a panic occurs using `recover()`. We will also discuss guidelines
    on `panic()` and `recover()` in Go thereafter.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何执行恐慌并将错误传递给 `panic()` 函数。这有助于用户更好地理解恐慌的原因。在下一节中，我们将学习如何在发生恐慌后使用
    `recover()` 来恢复程序控制。我们还将讨论 Go 中 `panic()` 和 `recover()` 的指南。
- en: Recover
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复
- en: Go provides us with the ability to regain control after a panic has occurred.
    `recover()` is a function that is used to regain control of a panicking goroutine.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了在发生恐慌后恢复控制的能力。`recover()` 是一个用于恢复恐慌 goroutine 控制的函数。
- en: 'The signature of the `recover()` function is as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`recover()` 函数的签名如下：'
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `recover()` function accepts no arguments and returns an empty `interface{}`.
    For now, an empty `interface{}` indicates that any type can be returned. The `recover()`
    function will return the value sent to the `panic()` function.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`recover()` 函数不接受任何参数，并返回一个空的 `interface{}`。目前，一个空的 `interface{}` 表示可以返回任何类型。`recover()`
    函数将返回发送给 `panic()` 函数的值。'
- en: The `recover()` function is only useful inside a deferred function. As you may
    recall, a deferred function gets executed before the encompassing function terminates.
    Executing a call to the `recover()` function inside a deferred function stops
    the panicking by restoring normal execution. If the `recover()` function is called
    outside a deferred function, it will not stop the panicking.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`recover()` 函数仅在延迟函数内部有用。如您所回忆的那样，延迟函数会在包含函数终止之前执行。在延迟函数内部执行对 `recover()` 函数的调用会通过恢复正常执行来停止恐慌。如果
    `recover()` 函数在延迟函数外部被调用，它将不会停止恐慌。'
- en: 'The following diagram shows the steps a program would take when using `panic()`,
    `recover()`, and a `defer()` function:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了程序在使用 `panic()`、`recover()` 和 `defer()` 函数时采取的步骤：
- en: '![Figure 6.8: The recover() function’s flow](img/B18621_06_08.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8：`recover()` 函数的流程](img/B18621_06_08.jpg)'
- en: 'Figure 6.8: The recover() function’s flow'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8：`recover()` 函数的流程
- en: 'The steps that are taken in the preceding diagram can be explained as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面图表中采取的步骤可以这样解释：
- en: The `main()` function calls `func a()`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main()` 函数调用 `func a()`。'
- en: '`func a()` calls `func b()`.'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`func a()` 调用 `func b()`。'
- en: Inside `func b()`, there is a panic.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `func b()` 内部有一个恐慌。
- en: The `panic()` function gets handled by a deferred function that uses the `recover()`
    function.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`panic()` 函数由使用 `recover()` 函数的延迟函数处理。'
- en: The deferred function is the last function to execute inside `func b()`.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 延迟函数是 `func b()` 内部最后一个执行的函数。
- en: The deferred function calls the `recover()` function.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 延迟函数调用 `recover()` 函数。
- en: The call to `recover()` causes normal flow back to the caller, `func a()`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `recover()` 的调用导致正常流程返回到调用者，即 `func a()`。
- en: Normal flow continues, and control is finally given back with the `main()` function.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正常流程继续，并且最终通过 `main()` 函数恢复控制。
- en: 'The following code snippet mimics the behavior of the preceding diagram:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段模拟了前面图表的行为：
- en: main.go
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: main.go
- en: '[PRE46]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The full code is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter06/Examples/Example06.02/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter06/Examples/Example06.02/main.go).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter06/Examples/Example06.02/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter06/Examples/Example06.02/main.go)找到。
- en: '**Code synopsis**:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码摘要**：'
- en: The `main()` function calls the `a()` function. This calls the `b()` function.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()` 函数调用 `a()` 函数。这调用了 `b()` 函数。'
- en: '`b()` accepts a string type and assigns it to the `msg` variable. If `msg`
    evaluates to `true` in the `if` statement, a panic will occur.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b()` 接受一个字符串类型并将其分配给 `msg` 变量。如果 `msg` 在 `if` 语句中评估为 `true`，则将发生 panic。'
- en: 'The argument for the panic is a new error created by the `errors.New()` function:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: panic 的参数是由 `errors.New()` 函数创建的新错误：
- en: '[PRE47]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Once the panic occurs, the next call will be to the deferred function.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发生 panic，下一个调用将是延迟函数。
- en: 'The deferred function uses the `recover()` function. The value of the panic
    is returned from `recover()`; in this case, the value of `r` is an error type.
    Then, the function prints out some details:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟函数使用 `recover()` 函数。从 `recover()` 返回 panic 的值；在这种情况下，`r` 的值是一个错误类型。然后，函数打印出一些详细信息：
- en: '[PRE48]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The control flow goes back to `a()`. Then, the `a()` function prints out some
    details.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流返回到 `a()`。然后，`a()` 函数打印出一些详细信息。
- en: 'Next, control goes back to the `main()` function, where it prints out some
    details and terminates:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，控制权返回到 `main()` 函数，其中它打印出一些详细信息并终止：
- en: '![Figure 6.9: recover() example output](img/B18621_06_09.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9：recover() 示例输出](img/B18621_06_09.jpg)'
- en: 'Figure 6.9: recover() example output'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9：recover() 示例输出
- en: Exercise 6.05 – recovering from a panic
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.05 – 从 panic 中恢复
- en: 'In this exercise, we will enhance our `payDay()` function so that it can recover
    from a panic. When our `payDay()` function panics, we will inspect the error from
    that panic. Then, depending on the error, we will print an informative message
    to the user. Let’s get started:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将增强我们的 `payDay()` 函数，使其能够从 panic 中恢复。当我们的 `payDay()` 函数 panic 时，我们将检查该
    panic 的错误。然后，根据错误，我们将向用户打印一条信息性消息。让我们开始吧：
- en: Create a directory called `Exercise6.05` inside the `Chapter06` directory.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter06` 目录内创建一个名为 `Exercise6.05` 的目录。
- en: Save a file called `main.go` inside the directory you created in the previous
    step. This program will be inside `package main`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一步创建的目录中保存一个名为 `main.go` 的文件。此程序将位于 `package main` 中。
- en: 'Enter the following code in `main.go`:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 文件中输入以下代码：
- en: '[PRE49]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Call the `payDay()` function with various arguments and then print the return
    value of the function:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用各种参数调用 `payDay()` 函数，然后打印函数的返回值：
- en: '[PRE50]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Then, add a `defer` function to your `payDay()` function:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，向您的 `payDay()` 函数添加一个 `defer` 函数：
- en: '[PRE51]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can check for the return value from the `recover()` function, as follows:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以检查 `recover()` 函数的返回值，如下所示：
- en: '[PRE52]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: If `r` is not `nil`, this means a panic occurs and we should perform an action.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `r` 不是 `nil`，这意味着发生了 panic，我们应该执行一个操作。
- en: 'We can evaluate `r` and see whether it equals one of our error values – `ErrHourlyRate`
    or `ErrHoursWorked`:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以评估 `r` 并查看它是否等于我们的错误值之一 – `ErrHourlyRate` 或 `ErrHoursWorked`：
- en: '[PRE53]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If our `if` statements evaluate to `true`, we print some details about the
    data and the error values from the `recover()` function. Then, we print how our
    pay was calculated:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的 `if` 语句评估为 `true`，我们将打印有关数据和 `recover()` 函数的错误值的一些详细信息。然后，我们打印出我们的工资是如何计算的：
- en: '[PRE54]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The rest of the code in the `payDay()` function remains unchanged. To see a
    description of it, please refer to *Exercise 6.04 – crashing the program on errors
    using* *a panic*:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`payDay()` 函数中的其余代码保持不变。要查看其描述，请参阅 *练习 6.04 – 使用 panic 在错误时崩溃程序*：'
- en: '[PRE55]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: At the command line, navigate to the directory you created.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，导航到您创建的目录。
- en: 'At the command line, type the following:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，键入以下内容：
- en: '[PRE56]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `go build` command will compile your program and create an executable named
    after the directory you created.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`go build` 命令将编译您的程序并创建一个以您创建的目录命名的可执行文件。'
- en: 'Type the name of the file you created and hit *Enter* to run the executable:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入您创建的文件名并按 *Enter* 运行可执行文件：
- en: '[PRE57]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The expected output is as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '![Figure 6.10: Recovering from a panic exercise output](img/B18621_06_10.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10：从 panic 中恢复的练习输出](img/B18621_06_10.jpg)'
- en: 'Figure 6.10: Recovering from a panic exercise output'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10：从 panic 中恢复的练习输出
- en: In the preceding exercises, we have seen the progression of creating a custom
    error and returning that error. From this, we have been able to crash programs
    when needed using `panic()`. In the previous exercise, we demonstrated the ability
    to recover from panics and display error messages based on the error type that
    was passed to the `panic()` function. In the following section, we will discuss
    some basic guidelines when performing error handling in Go.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的练习中，我们看到了创建自定义错误并返回该错误的过程。从这一点上，我们能够在需要时使用`panic()`使程序崩溃。在上一个练习中，我们展示了从`panic()`中恢复并基于传递给`panic()`函数的错误类型显示错误消息的能力。在下一节中，我们将讨论在Go中进行错误处理时的一些基本指南。
- en: Guidelines when working with errors and panics
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误和`panic()`时的指南
- en: 'Guidelines are just for guidance. They are not set in stone. This means that
    the majority of the time, you should follow the guidelines; however, there could
    be exceptions. Some of these guidelines have been mentioned previously, but we
    have consolidated them here for quick reference:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 指南仅作为指导。它们并非一成不变。这意味着大多数时候，你应该遵循指南；然而，可能会有例外。其中一些指南之前已经提到，但我们在这里进行了整合，以便快速参考：
- en: 'When declaring an error type, the variable needs to start with `Err`. It should
    also follow the camel case naming convention:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在声明错误类型时，变量需要以`Err`开头。它还应遵循驼峰命名法：
- en: '[PRE58]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `error` string should start in lowercase and not end with punctuation. One
    of the reasons for this guideline is that the error can be returned and concatenated
    with other information relevant to the error.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`字符串应以小写字母开头，且不以标点符号结尾。制定此指南的原因之一是错误可以被返回并与其他与错误相关的信息连接。'
- en: If a function or method returns an error, it should be evaluated. Errors that
    are not evaluated can cause the program to not function as expected.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个函数或方法返回错误，则应该对其进行评估。未评估的错误可能导致程序无法按预期运行。
- en: When using `panic()`, pass an error type as the argument, instead of an empty
    value.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用`panic()`时，应传递一个错误类型作为参数，而不是空值。
- en: Do not evaluate the string value of an error to extract information directly
    from the string representation of an error. Instead, use type assertions or the
    error interface methods to retrieve specific details about the error.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要评估错误的字符串值来直接从错误的字符串表示中提取信息。相反，应使用类型断言或错误接口方法来检索有关错误的特定细节。
- en: Use the `panic()` function sparingly.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该谨慎使用`panic()`函数。
- en: Errors should be used for expected situations, such as when you come across
    a recoverable issue in your code. When a function cannot return its intended result
    due to specific conditions, returning an error allows the caller to handle the
    situation gracefully. `panic()` should never be your first line of defense. `panic()`
    is meant for exceptional or unexpected situations and using it for regular error
    handling can lead to hard-to-debug issues, making your code less maintainable.
    Additionally, logging your errors in `DEBUG` mode, which is a state where a program
    provides more detailed information for debugging purposes, can be useful when
    debugging why an error occurred.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在预期情况下使用错误，例如当你遇到代码中的可恢复问题时。当一个函数由于特定条件无法返回预期结果时，返回错误允许调用者优雅地处理这种情况。`panic()`永远不应该成为你的第一道防线。`panic()`是为了处理异常或意外情况而设计的，将其用于常规错误处理可能导致难以调试的问题，使代码的可维护性降低。此外，在`DEBUG`模式下记录错误，这是一种程序为了调试目的提供更多详细信息的状态，当调试错误发生的原因时可能很有用。
- en: Following these suggestions will help improve the reliability and maintainability
    of your Go code and help you handle errors gracefully.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些建议将有助于提高你的Go代码的可靠性和可维护性，并帮助你优雅地处理错误。
- en: Error wrapping
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误包装
- en: When propagating errors up the call stack, there are ways to improve the context
    around why an error occurred. This is extremely useful in complex systems to aid
    in understanding an error case. Error wrapping helps preserve the original error
    information while adding additional context to the error. This can be seen with
    the use of `fmt.Errorf` or the `errors.Wrap` function from `github.com/pkg/errors`.
    Error wrapping provides more detailed information about where an error occurred
    or what caused it, making it easier to understand and handle errors in your code.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在将错误传播到调用栈时，有方法可以改进错误发生的原因的上下文。这在复杂系统中非常有用，有助于理解错误情况。错误封装有助于保留原始错误信息，同时为错误添加额外的上下文。这可以通过使用`fmt.Errorf`或`github.com/pkg/errors`中的`errors.Wrap`函数来实现。错误封装提供了更多关于错误发生位置或原因的详细信息，使得理解和处理代码中的错误变得更加容易。
- en: 'A simple example of error wrapping can be seen in the following function:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 错误封装的一个简单示例可以在以下函数中看到：
- en: '[PRE59]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Alternatively, the wrapped error return can be represented by the following
    code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，封装的错误返回可以表示为以下代码：
- en: '[PRE60]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The preceding code shows how you can easily chain errors using error wrapping.
    `%w` in the format string on the error provided previously allows errors to be
    chained, which provides additional context on why the error occurred. This approach
    is supported in the standard library, so it should be considered the preferred
    and most simplistic method.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了如何使用错误封装轻松地链接错误。在之前提供的错误格式字符串上的`%w`允许错误链接，这提供了关于错误发生原因的额外上下文。这种方法在标准库中得到支持，因此应该被认为是首选和最简单的方法。
- en: However, there is another third-party Go package that can be used to handle
    multiple errors together using `github.com/hashicorp/go-multierror`. These options
    give you the flexibility to understand additional error context or aggregate multiple
    errors into a single error, which can be convenient in certain scenarios.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个第三方Go包可以用来使用`github.com/hashicorp/go-multierror`一起处理多个错误。这些选项为你提供了理解额外的错误上下文或将多个错误聚合为单个错误的灵活性，这在某些场景中可能很方便。
- en: The Go standard library introduced error wrapping in Go 1.13, and you can see
    this type of functionality in use today by professional teams and in more complex
    applications. Providing additional context around an error can be useful in debugging
    scenarios. To illustrate this, consider a situation where an error occurs in code
    you are unfamiliar with, and the error provides no context. It will be very challenging
    to pinpoint the origin of the error. Debugging becomes very difficult when you
    lack information about the specific part of the code where the error occurred.
    However, you must be mindful of not propagating too much context up the call stack
    so that you’re not compromising the security of your code base.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库在1.13版本中引入了错误封装，你可以在今天看到专业团队和更复杂的应用程序中使用这种功能。在错误周围提供额外的上下文在调试场景中可能很有用。为了说明这一点，考虑一个在你不熟悉代码中发生错误的情况，并且错误没有提供任何上下文。确定错误的来源将非常具有挑战性。当你缺乏关于错误发生代码特定部分的信息时，调试变得非常困难。然而，你必须注意不要将过多的上下文传播到调用栈中，以免损害你的代码库的安全性。
- en: Activity 6.01 – creating a custom error message for a banking application
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动6.01 – 为银行应用程序创建自定义错误消息
- en: A bank wants to add some custom errors when checking for last names and valid
    routing numbers. They have found that the direct deposit procedure allows invalid
    names and routing numbers to be used. The bank wants a descriptive error message
    for when these incidents occur. Our job is to create two descriptive custom error
    messages. Remember to use an idiomatic naming convention for the error variable
    and a proper structure for the error message.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 一家银行希望在检查姓氏和有效路由号时添加一些自定义错误。他们发现直接存款程序允许使用无效的名称和路由号。银行希望在发生这些事件时有一个描述性的错误消息。我们的任务是创建两个描述性的自定义错误消息。请记住，为错误变量使用惯用的命名约定，并为错误消息使用适当的结构。
- en: 'You need to do the following:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做以下事情：
- en: First, you must create two error values for `ErrInvalidLastName` and `ErrInvalidRoutingNumber`.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你必须为`ErrInvalidLastName`和`ErrInvalidRoutingNumber`创建两个错误值。
- en: Then, you must print the custom message in the `main()` function to show the
    bank the error message they will receive when those errors are encountered.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你必须打印`main()`函数中的自定义消息，以向银行显示当遇到这些错误时他们将收到的错误消息。
- en: 'The expected output is as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '[PRE61]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: By the end of this activity, you will be familiar with the steps that are needed
    to create a custom error message.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成此活动后，您将熟悉创建自定义错误消息所需的步骤。
- en: Note
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found [https://github.com/PacktPublishing/
    Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.01.](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.01)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.01)找到。
- en: Activity 6.02 – validating a bank customer’s direct deposit submission
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动六.02 – 验证银行客户的直接存款提交
- en: 'The bank was pleased with the custom error messages that you created in *Activity
    6.01 – creating a custom error message for a banking application*. They are so
    pleased that they now want you to implement two methods. These two methods are
    for validating the last name and the routing number:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 银行对您在*活动 6.01 – 为银行应用程序创建自定义错误消息*中创建的自定义错误消息感到满意。他们非常满意，现在希望您实现两个方法。这两个方法用于验证姓氏和路线号：
- en: You will need to create a struct called `directDeposit`.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要创建一个名为 `directDeposit` 的结构。
- en: 'The `directDeposit` struct will have three string fields: `lastName`, `firstName`,
    and `bankName`. It will also have two `int` fields called `routingNumber` and
    `accountNumber`.'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`directDeposit` 结构将包含三个字符串字段：`lastName`、`firstName` 和 `bankName`。它还将包含两个名为
    `routingNumber` 和 `accountNumber` 的 `int` 字段。'
- en: The `directDeposit` struct will have a `validateRoutingNumber` method. The method
    will return `ErrInvalidRoutingNum` when the routing number is less than 100.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`directDeposit` 结构将有一个 `validateRoutingNumber` 方法。当路线号小于 100 时，该方法将返回 `ErrInvalidRoutingNum`。'
- en: The `directDeposit` struct will have a `validateLastName` method. It will return
    `ErrInvalidLastName` when `lastName` is an empty string.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`directDeposit` 结构将有一个 `validateLastName` 方法。当 `lastName` 为空字符串时，它将返回 `ErrInvalidLastName`。'
- en: The `directDeposit` struct will have a method report. It will print out each
    of the fields’ values.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`directDeposit` 结构将有一个名为 report 的方法。它将打印出每个字段的值。'
- en: In the `main()` function, assign values to the `directDeposit` struct’s fields
    and call each of the `directDeposit` struct’s methods.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，为 `directDeposit` 结构的字段分配值，并调用 `directDeposit` 结构的每个方法。
- en: 'The expected output is as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 6.11: Validating a bank customer’s direct deposit submission](img/B18621_06_11.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11：验证银行客户的直接存款提交](img/B18621_06_11.jpg)'
- en: 'Figure 6.11: Validating a bank customer’s direct deposit submission'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11：验证银行客户的直接存款提交
- en: By the end of this activity, you will have learned how to return errors from
    functions and how to check for errors returned from a function. You will also
    be able to check for a condition and, based on that condition, return a custom
    error.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成此活动后，您将学会如何从函数中返回错误，以及如何检查从函数返回的错误。您还将能够检查条件，并根据该条件返回自定义错误。
- en: Note
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.02).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.02)找到。
- en: Activity 6.03 – panic on invalid data submission
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动六.03 – 对无效数据提交引发恐慌
- en: The bank has now decided that it would rather crash the program when an invalid
    routing number is submitted. The bank feels that the erroneous data should cause
    the program to stop processing the direct deposit data. You need to raise panic
    on an invalid data submission instance. Build this on top of *Activity 6.02 –
    validating a bank customer’s direct* *deposit submission*.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 银行现在决定，当提交无效的路线号时，宁愿让程序崩溃。银行认为，错误数据应导致程序停止处理直接存款数据。您需要在无效数据提交实例上引发恐慌。在*活动 6.02
    – 验证银行客户的直接存款提交*的基础上构建此功能。
- en: 'For this activity, you only need to do one thing – change the `validateRoutingNumber`
    method so that it doesn’t return `ErrInvalidRoutingNum`, but instead performs
    a panic:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此活动，您只需做一件事 – 修改 `validateRoutingNumber` 方法，使其不返回 `ErrInvalidRoutingNum`，而是执行恐慌：
- en: 'The expected output is as follows:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 6.12: Panic on an invalid routing number](img/B18621_06_12.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12：无效路由号上的panic](img/B18621_06_12.jpg)'
- en: 'Figure 6.12: Panic on an invalid routing number'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12：无效路由号上的panic
- en: By the end of this activity, you will be able to cause a panic to occur and
    see how that impacts the flow of the program.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个活动后，你将能够引发panic，并看到它如何影响程序的流程。
- en: Note
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.03](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.03).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.03](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.03)找到。
- en: Activity 6.04 – preventing a panic from crashing the app
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动六.04 – 防止panic导致应用崩溃
- en: 'After some initial alpha testing, the bank no longer wants the app to crash,
    Instead, in this activity, we need to recover from the panic that we added in
    *Activity 6.03 – panic on invalid data submission*, and print the error that caused
    the panic:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行一些初步的alpha测试后，银行不再希望应用崩溃，因此，在本活动中，我们需要从我们在*活动6.03 – 无效数据提交时的panic*中恢复，并打印出导致panic的错误：
- en: Add a `defer` function inside the `validateRoutingNumber` method.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`validateRoutingNumber`方法中添加一个`defer`函数。
- en: 'Add an `if` statement that checks the error that’s returned from the `recover()`
    function. If there is an error, then print it:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`recover()`函数返回的错误上添加一个`if`语句。如果有错误，则打印它：
- en: 'The expected output is as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 6.13: Recovering from a panic on an invalid routing number](img/B18621_06_13.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![图6.13：从无效路由号上的panic中恢复](img/B18621_06_13.jpg)'
- en: 'Figure 6.13: Recovering from a panic on an invalid routing number'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13：从无效路由号上的panic中恢复
- en: By the end of this activity, you will have caused a panic, but you will be able
    to prevent it from crashing the application. You will get an understanding of
    how the `recover()` function, used in conjunction with the `defer` statement,
    can be used to prevent the application from crashing.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这个活动后，你将引发一个panic，但你会知道如何防止它导致应用崩溃。你将了解如何使用`recover()`函数，与`defer`语句结合使用，以防止应用崩溃。
- en: Note
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.04](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.04).
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.04](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.04)找到。
- en: Summary
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the different types of errors that you will encounter
    while programming, such as syntax, runtime, and semantic errors. We focused more
    on runtime errors since they are challenging to debug.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了编程过程中会遇到的不同类型的错误，例如语法、运行时和语义错误。我们更关注运行时错误，因为它们难以调试。
- en: Then, we examined the difference between various language philosophies when
    it comes to dealing with errors. We saw how Go’s syntax for errors is simpler
    to understand compared to the exception handling that various languages utilize.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查了在处理错误时各种语言哲学之间的差异。我们看到了Go的错误语法相对于各种语言使用的异常处理来说更容易理解。
- en: An error in Go is a value. Values can be passed around to functions. Any error
    can be a value, so long as it implements the error interface type. We learned
    how easily we can create errors. We also learned that we should name our error
    values so that they start with `Err`, followed by a descriptive camel case name.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，错误是一个值。值可以在函数之间传递。任何错误都可以是一个值，只要它实现了错误接口类型。我们学习了如何轻松地创建错误。我们还学习了我们应该给错误值命名，使它们以`Err`开头，后面跟着一个描述性的驼峰式名称。
- en: 'Next, we discussed panics and the similarities between a panic and an exception.
    We also discovered that panics are pretty similar to exceptions; however, if panics
    aren’t handled, they will cause the program to crash. However, Go has a mechanism
    that will return control of the program to normal: the `recover()` function. The
    requirement for recovering from a panic is the usage of the `recover()` function
    in a deferred function. Then, we learned about the general guidelines for using
    errors, `panic()`, and `recover()` before exploring how to add additional context
    to errors using error wrapping.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了恐慌（panic）以及恐慌与异常之间的相似性。我们还发现恐慌与异常相当相似；然而，如果恐慌没有被处理，它们将导致程序崩溃。但是，Go
    语言有一个机制可以将程序的控制权返回到正常状态：`recover()` 函数。从恐慌中恢复的要求是在延迟函数中使用 `recover()` 函数。然后，在探索如何使用错误包装添加额外上下文之前，我们学习了使用错误、`panic()`
    和 `recover()` 的一般指南。
- en: In the next chapter, we will look at interfaces and their uses, as well as how
    they differ from how other programming languages implement interfaces. We will
    see how they can be used to solve various problems that you will face as a programmer.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨接口及其用途，以及它们与其他编程语言实现接口的方式有何不同。我们将看到它们如何被用来解决作为程序员可能会遇到的各种问题。
