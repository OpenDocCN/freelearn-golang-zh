- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Don’t Panic! Handle Your Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at various code snippets from the Go standard
    packages to get an understanding of Go’s idiomatic way of performing error handling.
    We will also look at how to create custom error types in Go and see more examples
    in the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to distinguish between the different
    types of errors and compare error handling and exception handling. You will also
    be able to create error values, `panic()`, and properly recover after a panic
    and handle your errors. Lastly, we will briefly discuss adding context to our
    errors through error wrapping.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you’ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to reduce, reuse, and recycle good code
    practices with Go through the help of functions, separating logical components,
    and more! We also discovered more regarding functions, such as the fact that functions
    can be passed as parameters and returned from a function. In this chapter, we
    will work with errors and learn how to return those from functions.
  prefs: []
  type: TYPE_NORMAL
- en: Developers are not perfect and, by extension, neither is the code that they
    produce. All software at some point in time has had errors. Handling errors is
    critical when you are developing software. These errors can have a negative impact
    of varying degrees on its users. The impact on the users of your software can
    be more far-reaching than you realize.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let’s consider the Northeast Blackout of 2003\. On August 14,
    there was a blackout for about 50 million people in the United States and Canada
    that lasted for 14 days. This was due to a race condition bug in the alarm system
    in a control room. Technically, a race condition bug is when two separate threads
    try to access the same memory location for a write operation. This race condition
    can cause a program to crash. In this instance, it resulted in over 250 power
    plants going offline. One way to handle a race condition is to ensure proper synchronization
    between the various threads, or small units of execution within a process, and
    allow memory locations to be accessed for write operations by only one thread
    at a time. We will discuss concurrency in more detail later in this book; however,
    this example illustrates how it is important that we, as developers, ensure we
    handle errors properly so that we can try our best to avoid issues such as this.
    If we do not handle errors properly, this can harm the users of our application
    and their way of life, as seen by the power outage incident described here. Yes,
    this is an event from years ago; however, we should take the opportunity to learn
    from the past and work toward handling errors properly to avoid this in the future.
    Further information on the Northeast Blackout can be found online: [https://en.wikipedia.org/wiki/Northeast_blackout_of_2003](https://en.wikipedia.org/wiki/Northeast_blackout_of_2003).'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at what an error is, what an error looks
    like in Go, and, more specifically, how to handle errors the Go way. Let’s get
    started!
  prefs: []
  type: TYPE_NORMAL
- en: What are errors?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An error is something that causes your program to produce unintended results.
    Those unintended results could range from the application crashing, an incorrect
    data calculation (such as a bank transaction not being processed correctly), or
    not providing any results. These unintended results are referred to as software
    bugs. Any software will contain errors during its lifetime due to numerous scenarios
    that programmers do not anticipate. The following are possible outcomes when errors
    occur:'
  prefs: []
  type: TYPE_NORMAL
- en: The erroneous code could cause the program to crash without warning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output of the program was not the intended result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An error message is displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three types of errors that you might encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semantic errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explore each one in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Syntax errors result from improper use of the programming language. This often
    occurs due to mistyping the code. Most modern IDEs will have some visual way of
    bringing syntax errors to the attention of the programmer. In most modern IDEs,
    syntax errors can be caught at an early stage. They may occur more frequently
    when you are learning a new programming language. A few occurrences of syntax
    errors could be due to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Incorrect use of syntax for a loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Misplacing or omitting curly braces, parentheses, or brackets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Misspelled function names or package names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing the wrong type of argument to a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of a syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Go is case-sensitive, so `println` should be `Println`.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax errors are errors that you receive quick feedback on from `golint` that
    runs within your IDE thanks to the `gopls` language server. `gopls` is the official
    Go language server developed by the Google Go team and provides various language
    features, including code completion and diagnostics on syntax warnings and errors,
    as well as formatting issues. Working with Go code within an IDE that supports
    the `gopls` to enable these features. `golint` itself is a separate command-line
    tool that can provide code analysis and can integrate with `gopls`. It is recommended
    to run your code through a linter before committing. This process is often automated
    when you’re opening up code for team members to review in a **continuous integration**
    (**CI**) environment so that team-based and/or larger projects all have good code
    quality standards.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These errors occur when the code is asked to perform a task that it cannot do.
    Unlike syntax errors, these are typically only found during the execution of the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are common examples of runtime errors:'
  prefs: []
  type: TYPE_NORMAL
- en: Opening a connection to a database that does not exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a loop that is bigger than the number of elements in the slice or
    array you are iterating over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening a file that does not exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a mathematical operation, such as dividing a number by zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise 6.01 – runtime errors while adding numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to write a simple program that sums up a slice
    of numbers. This program will demonstrate an example of a runtime error and will
    crash when it is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `Exercise06.01` inside the `Chapter06` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `main.go` inside the directory you created in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This program will be in `package main`. Import the `fmt` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main` function, we will have a slice of integers that will have
    four elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will have a variable, `total`, to be used to sum all the integer variables
    in the slice. Use a `for` loop to sum the variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we print the results of the total:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With that, we have introduced an example of a runtime error to the program;
    so, we will not get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the command line, navigate to the directory you created in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the command line, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `go build` command will compile your program and create an executable named
    after the directory you created in *step 1*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type the name of the file you created in *step 8* and hit *Enter* to run the
    executable (Add the `./main` command). The expected output will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1: Output after executing](img/B18621_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Output after executing'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the program crashed. The `index out of range` panic is a common
    error to new Go developers and veterans alike.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the error – a panic (we will discuss what a panic is later
    in this chapter) in this program – is the result of iterating in the `for` loop
    by a greater number – in our case, 10 – than the actual number of elements in
    the slice – in our case, 4\. One possible solution would be to use a `for` loop
    with a range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we saw how we can avoid runtime errors by paying attention
    to minute details.
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture issues more easily before they become runtime errors, it is best
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Properly test your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid `nil` pointer dereferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use proper input validation as necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform boundary checks to check bounds on data before accessing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use proper synchronization mechanisms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid global state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use panic and recover sparingly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conductor thorough code reviews on teammates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use code linters and analyzers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conduct version management for dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While several of these include trying to be mindful of proper coding practices,
    many of them will also be discussed in subsequent chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Syntax errors are the easiest to debug, followed by runtime errors, while logic
    errors are the hardest. Semantic errors are sometimes very hard to spot as they
    are a result of logical errors that can lead to unexpected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in 1998, when the Mars Climate Orbiter was launched, its purpose
    was to study the climate of Mars, but due to a logic error in the system, the
    Mars Climate Orbiter, valued at $235 million, was destroyed. After some analysis,
    it was discovered that the calculations of units on the ground controller system
    were done in imperial units and the software on the Orbiter was done in metric
    units. This was a logic error that caused the navigation system to incorrectly
    calculate its maneuvers in space. As indicated by this historical tale of a semantic
    error, these are defects in the way code processes elements of a program. These
    types of errors are often caught at runtime. This is another illustration of the
    significant consequences erroneous code can cause since the Mars Climate Orbiter
    was very expensive and included many hours of engineering efforts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some reasons for semantic errors to occur:'
  prefs: []
  type: TYPE_NORMAL
- en: Logical errors such as incorrect computations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing incorrect resources (files, databases, servers, and variables)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrect setting of variables for negation (not equal versus equal)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type errors on variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrect use of functions, data structures, pointers, and concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise 6.02 – a semantic error with walking distance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are writing an application that will determine whether we should walk to
    our destination or take a car. If our destination is greater than or equal to
    2 km, we are going to take a car. If it is less than 2 km, then we will walk to
    our destination. We are going to demonstrate a semantic error with this program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected output of this exercise is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `Exercise6.02` inside the `Chapter06` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save a file called `main.go` inside the directory you created in the previous
    step. This program will be inside `package main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `fmt` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main` function, display a message to take the car when `km` is
    greater than `2`, and when `km` is less than `2`, to send a message for walking:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the command line, navigate to the directory you created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the command line, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `go build` command will compile your program and create an executable named
    after the directory you created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type the name of the file you created in *Step 6* and hit *Enter* to run the
    executable (Add the `./main` command). The expected output will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The program will run with no errors, but the message that’s displayed won’t
    be what we expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, the program runs with no errors, but the results are
    not what we expected. This is because we have a logic error. Our `if` statement
    does not account for `km` equal to `2`. It only checks that the distance is greater
    than `2`. Fortunately, this is a simple fix: replace `>` with `>=`. Now, the program
    will give the results that we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This simple program made it easy to debug the logic error, but these types of
    errors in a larger program may not be as easy to spot.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic errors involve understanding the intended logic of the code. It is
    best to be thorough in testing. This includes various types of tests, such as
    unit, integration, end-to-end, and others. Each type of test serves a specific
    purpose in capturing different aspects of errors and preventing unintended consequences.
    Later in this book, we will discuss the various types of testing in further detail.
    Additionally, adopting best practices for Go and a continuous learning mindset
    can help!
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of this chapter will focus on the runtime errors we’ve covered.
    However, it is good to understand the various types of errors that you, as a programmer,
    could encounter.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling using other programming languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programmers who are new to Go and who have a background in other programming
    languages may initially find Go’s methodology for dealing with errors a bit odd.
    Go does not handle errors in the same fashion as other languages, such as Java,
    Python, C#, and Ruby. Those languages perform exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippets are some examples of how other languages handle
    errors by performing exception handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Typically, exceptions, if not handled, will crash your application. In most
    cases, exception handling tends to be implicit checking versus Go’s explicit checking
    for errors returned by its functions. In the exception-handling paradigm, anything
    can fail, and you must account for that. Each function can throw an exception,
    but you do not know what that exception could be.
  prefs: []
  type: TYPE_NORMAL
- en: In the error handling paradigm that Go uses, it is obvious when the programmer
    does not handle the error because the function returns the error code, and you
    can see that they did not check for the error. We will be looking at the specifics
    of checking for error code later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most programming languages follow a similar pattern to the one shown in the
    previous code snippet. It is usually some sort of `try..catch..finally` block.
    One point of contention with the `try..catch..finally` block is that the control
    flow of the program’s execution gets interrupted and can follow a different path.
    This can lead to several logic errors and difficulty in the readability of the
    code. Here is a quick peek at how Go handles errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is a very simple syntax for handling the error. We
    will look at this in greater detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Error interface type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is an error in Go? An error in Go is a value. Here’s a quote from Rob
    Pike, one of the pivotal pioneers of Go:'
  prefs: []
  type: TYPE_NORMAL
- en: “*Values can be programmed, and since errors are values, errors can be programmed.
    Errors are not like exceptions. There’s nothing special about them, whereas an
    unhandled exception can crash* *your program.*”
  prefs: []
  type: TYPE_NORMAL
- en: Since errors are values, they can be passed into a function, returned from a
    function, and evaluated just like any other value in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'An error in Go is anything that implements the error interface. Interfaces
    will be explained in detail in the following chapter, so we will keep the details
    light in this chapter concerning interface references. We need to look at some
    fundamental aspects that make up the error type in Go. To be an error type in
    Go, it must first satisfy `type` `error interface`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The wonderful thing about Go is its simplistic design regarding language features.
    This can easily be seen with the error interface that Go’s standard library uses.
    To satisfy the error interface, only two things are required:'
  prefs: []
  type: TYPE_NORMAL
- en: The method name, `Error()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Error()` method to return a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to understand that an error type is an interface type. Any value
    that is an error can be described as a string. When performing error handling
    in Go, the functions will return error values. The Go language uses this throughout
    the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following code snippet for a starting discussion point on errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We will not go into every detail of the function and instead focus on the error
    portion of the code. In [*Chapter 5*](B18621_05.xhtml#_idTextAnchor1048), *Reduce,
    Reuse, and Recycle*, we learned that functions can return multiple values. This
    is a powerful feature that most languages do not have. This is powerful, especially
    when dealing with error values. The `strconv.Atoi()` function returns an `int`
    type and an error, as seen in the example stated previously. It is a function
    that is in the Go standard library. For functions that return error values, the
    error value should be the last return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is Go-idiomatic to evaluate the error value for functions or methods that
    return an error. It is generally bad practice to not handle an error that is returned
    from a function. When returned and ignored, an error can lead to lots of wasted
    debugging efforts. It can also cause unforeseen consequences in your program.
    If the value is not `nil`, then we have an error and must decide how we want to
    handle it. Depending on the scenario, we might want to do one of the following
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: Return the error to the caller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log the error and continue execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop the execution of the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore it (this is highly not recommended)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Panic (only in very rare conditions; we will discuss this in more detail later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value of error is `nil`, this means there is no error. No further steps
    are necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the standard package regarding the error type.
    We will start by looking at each piece of code in the [https://packt.live/2rk6r8Z](https://packt.live/2rk6r8Z)
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `errorString` struct is in the `errors` package. This struct is used to
    store the string version of the error. `errorString` has a single field of `s`
    that is of the `string` type. `errorString` and the field are unexportable. This
    means that we can’t access the `errorString` type or its field, `s`, directly.
    The following code shows an example of trying to access an unexported `errorString`
    type and its field, `s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Expected output for the unexported field](img/B18621_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Expected output for the unexported field'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the surface, it appears that `errorString` is neither accessible nor useful,
    but we should keep digging into the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `errorString` type has a method that implements the error interface. It
    satisfies the requirements, provides a method called `Error()`, and returns a
    string. The error interface has been satisfied. We now have access to the `errorString`
    field, `s`, through the `Error()` method. This is how an error gets returned within
    the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a basic understanding of what an error is in Go. Next, we’ll
    learn how to create error types in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Creating error values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the standard library, the `errors` package has a method that we can use
    to create errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It is important to understand that the `New` function takes a string as an argument,
    converts it into `*errors.errorString`, and returns an error value. The underlying
    value of the error type that gets returned is of the `*``errors.errorString` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can prove this by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example from Go’s standard library, `http`, that uses the `errors`
    package to create package-level variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When creating errors in Go, it is idiomatic to start with the `Err` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.03 – creating an application to calculate pay for the week
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we are going to create a function that calculates pay for
    the week. This function will accept two arguments – the hours worked during the
    week and the hourly rate. The function is going to check whether the two parameters
    meet the criteria for being valid. The function will need to calculate regular
    pay, which is hours less than or equal to 40, and overtime pay, which is hours
    greater than 40 for the week.
  prefs: []
  type: TYPE_NORMAL
- en: We will create two error values using `errors.New()`. The one error value will
    be used when there is an invalid hourly rate. An invalid hourly rate in our app
    is an hourly rate that is less than 10 or greater than 75\. The second error value
    will be when hours per week are not between 0 and 80.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the IDE of your choice. One option would be Visual Studio Code. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `Exercise6.03` inside the `Chapter06` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save a file called `main.go` inside the directory you created in the previous
    step The `main.go` file will be in `package main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the two Go standard libraries, `errors` and `fmt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With that, we have declared our error variables using `errors.New()`. Now,
    we can use idiomatic Go for the variable name, starting it with `Err` and camel
    casing. Our error string is in lowercase with no punctuation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main` function, we will be calling our `payday()` function three
    times. We will declare our error variables using `errors.New()` and check `err`
    after the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `payDay` function and make it accept two arguments (`hoursWorked`
    and `hourlyRate`). The function will return an `int` type and an error. We will
    discuss this step by step afterward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use an `if` statement to check whether the hourly rate is less than
    10 or greater than 75\. If `hourlyRate` meets those conditions, we will return
    `0` and our custom error, `ErrHourlyRate`. If `hourlyRate` does not meet those
    conditions, then the returned value will be `return hoursWorked * hourlyRate,
    nil`. We return `nil` for the error because there was no error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In *step 7*, we validated `hourlyRate`. Now, we will need to validate `hoursWorked`.
    We will add another `if` statement to the `payDay()` function that will check
    whether `hoursWorked` is less than `0` or greater than `80`. If `hoursWorked`
    matches that condition, we will return `0` and the error, `ErrHoursWorked`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the previous two steps, we added `if` statements to validate the arguments
    being passed to the function. In this step, we will add another `if` statement
    to calculate overtime pay. Overtime pay is hours greater than `40`. The hours
    over `40` are double `hourlyRate`. The hours less than or equal to `40` are at
    `hourlyRate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, we will call the `payDay()` function three times
    with various arguments. We will check the error after each call and print the
    error message if applicable. If there is no error, then we print the pay for the
    week:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the command line, navigate to the directory you created previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the command line, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `go build` command will compile your program and create an executable named
    after the directory you created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type the name of the file you created and hit *Enter* to run the executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we saw how to create custom error messages that can be used
    to easily determine why the data was considered invalid. We also showed how to
    return multiple values from a function and to check for errors from the function.
    In the next section, we will look at how to use panic in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Panic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several languages use exceptions for handling errors. However, Go does not use
    exceptions – it uses something called a panic. This is a built-in function that
    causes a program to crash. It stops the normal execution of the current goroutine
    where the panic happened and all other ongoing goroutines and shows a stack trace
    of what occurred.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, a panic is not the norm, unlike other languages where an exception is
    the norm. A panic signal indicates something abnormal that is occurring within
    your code. Usually, when a panic is initiated by runtime or the developer, it
    is to protect the integrity of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Errors and panics differ in their purposes and how they are handled by the Go
    runtime. An error in Go indicates that something unexpected occurred, but it will
    not adversely impact the integrity of the program. Go expects that the developer
    will handle the error properly. The function or other programs will not typically
    crash if you do not handle the error. However, panics differ in this regard. When
    a panic occurs, it will ultimately crash the system unless there are handlers
    to handle the panic. If there are no handlers for the panic, it will go all the
    way up the stack and crash the program.
  prefs: []
  type: TYPE_NORMAL
- en: One example that we will look at later in this chapter is where a panic occurs
    due to an index being out of range. This is typical when trying to access the
    index of a collection that doesn’t exist. If Go did not panic in this case, it
    could harm the integrity of the program, such as other parts of the program trying
    to store or retrieve data that is not there in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Review the topic of goroutines to understand what occurs in Go when you panic.
    At a high level, the `main()` function is a Goroutine. When a panic occurs, you
    will see references to “Goroutine running” in the error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Panics can be initiated by the developer and can be caused during the execution
    of a program by runtime errors. A `panic()` function accepts an empty interface.
    For now, suffice to say, this means it can accept anything as an argument. However,
    in most cases, you should pass an error type to the `panic()` function. It is
    more intuitive to the user of our function to have some details on what caused
    the panic. Passing an error to the panic function is also idiomatic in Go. We
    will also see how recovering from a panic that has an error type passed to it
    gives us some different options when dealing with panic. When a panic occurs,
    it will generally follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The execution is stopped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any deferred functions in the panicking function will be called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any deferred functions in the stack of the panicking function will be called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will continue up the stack until it reaches `main()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Statements after the panicking function will not execute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The program then crashes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s how a panic works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: The working of a panic](img/B18621_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: The working of a panic'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram illustrates code in the `main` function that calls the
    `a()` function. This function then calls the `b()` function. Inside `b()`, a panic
    occurs. The `panic()` function is not handled by any of the code upstream (`a()`
    or the `main()` function), so the program will crash the `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a panic that occurs in Go. Try to determine why this program
    panics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this panic is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Panic example](img/B18621_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Panic example'
  prefs: []
  type: TYPE_NORMAL
- en: The panic runtime error is a common one that you will encounter while developing.
    It is an `index out of range` error. Go generated this panic because we are trying
    to iterate over a slice more times than there are elements. Go felt that this
    is a reason to panic because it puts the program in an abnormal condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a snippet of code that demonstrates the basics of using a panic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**Code synopsis**:'
  prefs: []
  type: TYPE_NORMAL
- en: The function panics because the argument to the function message is `"good-bye"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `panic()` function prints the error message. Having a good error message
    helps with the debugging process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the panic, we are using `errors.New()`, which we used in the previous
    section to create an error type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, `fmt.Println()` does not get executed in the `main()` function.
    Since there are no `defer` statements, execution stops immediately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The expected output for this code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: Panic example output](img/B18621_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Panic example output'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how `panic` and a `defer` statement function
    together:'
  prefs: []
  type: TYPE_NORMAL
- en: main.go
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this panic example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: Panic example output](img/B18621_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Panic example output'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s understand the code in parts:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by examining the code in the `message()` function since that is where
    the panic starts. When the panic occurs, it runs the `defer` statement within
    the panicking function, `message()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The deferred function, `func f()`, runs in the `message()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Going up the call stack, the next function is the `test()` function, and its
    deferred function, `n()`, will execute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we get to the `main()` function, where the execution is stopped by
    the panicking function. The print statement in `main()` does not get executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may have seen `os.Exit()` used to stop the execution of a program. `os.Exit()`
    stops execution immediately and returns a status code. No deferred statements
    are run when `os.Exit()` is performed. `Panic` is preferred over `os.Exit()` in
    certain cases as a panic will run deferred functions.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.04 – Crashing the program on errors using a panic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be modifying *Exercise 6.03 – creating an application
    to calculate pay for the week*. Consider the following scenario, where the requirements
    have changed.
  prefs: []
  type: TYPE_NORMAL
- en: We no longer need to return error values from our `payDay()` function. It has
    been decided that we cannot trust the user of the program to respond properly
    to the errors. There have been complaints of incorrect paychecks. We believe this
    is due to the caller of our function ignoring the errors being returned.
  prefs: []
  type: TYPE_NORMAL
- en: The `payDay()` function will now only return the pay amount and no errors. When
    the arguments provided to the function are invalid, instead of returning an error,
    the function will panic. This will cause the program to stop immediately and,
    therefore, not process a paycheck.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the IDE of your choice. One option could be Visual Studio Code. Now, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `Exercise6.04` inside the `Chapter06` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save a file called `main.go` inside the directory you created in the previous
    step. This program will be inside `package main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main` function, call the `payDay()` function, assign it to only
    one variable, `pay`, and then print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the return type of the `payDay()` function so that it only returns `int`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `payDay()` function, assign a variable, `report`, to an anonymous
    function. This anonymous function provides details of the arguments provided to
    the `payDay()` function. Even though we are not returning errors, this will provide
    some insight as to why the function panics. Since it is a deferred function, it
    will always execute before the function exits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The business rule for valid `hourlyRate` and `hoursWorked` stays the same as
    in the previous exercise. Instead of returning an error, we will be using the
    `panic` function. When the data is invalid, we panic and pass the argument of
    `ErrHourlyRate` or `ErrHoursWorked`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The arguments that are passed to the `panic()` function assist the user of our
    function in `understanding` the cause of the panic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When a panic occurs in the `payDay()` function, the `defer` function, `report()`,
    will give the caller some insight into why the panic occurred. The panic will
    bubble up the stack to the `main()` function and execution will stop immediately.
    The following code must be added after the `defer` function in the `payDay()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the command line, navigate to the directory you created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the command line, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `go build` command will compile your program and create an executable named
    after the directory you created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in the name of the file you created and hit *Enter* to run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: Panic exercise output](img/B18621_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Panic exercise output'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned how to perform a panic and pass an error to the
    `panic()` function. This aids the user of the function in gaining a good understanding
    of the cause of the panic. In the next section, we will learn how to regain control
    of the program after a panic occurs using `recover()`. We will also discuss guidelines
    on `panic()` and `recover()` in Go thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: Recover
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go provides us with the ability to regain control after a panic has occurred.
    `recover()` is a function that is used to regain control of a panicking goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature of the `recover()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `recover()` function accepts no arguments and returns an empty `interface{}`.
    For now, an empty `interface{}` indicates that any type can be returned. The `recover()`
    function will return the value sent to the `panic()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `recover()` function is only useful inside a deferred function. As you may
    recall, a deferred function gets executed before the encompassing function terminates.
    Executing a call to the `recover()` function inside a deferred function stops
    the panicking by restoring normal execution. If the `recover()` function is called
    outside a deferred function, it will not stop the panicking.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the steps a program would take when using `panic()`,
    `recover()`, and a `defer()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8: The recover() function’s flow](img/B18621_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: The recover() function’s flow'
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps that are taken in the preceding diagram can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` function calls `func a()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`func a()` calls `func b()`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside `func b()`, there is a panic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `panic()` function gets handled by a deferred function that uses the `recover()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The deferred function is the last function to execute inside `func b()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The deferred function calls the `recover()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The call to `recover()` causes normal flow back to the caller, `func a()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Normal flow continues, and control is finally given back with the `main()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code snippet mimics the behavior of the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: main.go
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The full code is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter06/Examples/Example06.02/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter06/Examples/Example06.02/main.go).
  prefs: []
  type: TYPE_NORMAL
- en: '**Code synopsis**:'
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` function calls the `a()` function. This calls the `b()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b()` accepts a string type and assigns it to the `msg` variable. If `msg`
    evaluates to `true` in the `if` statement, a panic will occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The argument for the panic is a new error created by the `errors.New()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the panic occurs, the next call will be to the deferred function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The deferred function uses the `recover()` function. The value of the panic
    is returned from `recover()`; in this case, the value of `r` is an error type.
    Then, the function prints out some details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The control flow goes back to `a()`. Then, the `a()` function prints out some
    details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, control goes back to the `main()` function, where it prints out some
    details and terminates:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.9: recover() example output](img/B18621_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: recover() example output'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.05 – recovering from a panic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will enhance our `payDay()` function so that it can recover
    from a panic. When our `payDay()` function panics, we will inspect the error from
    that panic. Then, depending on the error, we will print an informative message
    to the user. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `Exercise6.05` inside the `Chapter06` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save a file called `main.go` inside the directory you created in the previous
    step. This program will be inside `package main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `payDay()` function with various arguments and then print the return
    value of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add a `defer` function to your `payDay()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can check for the return value from the `recover()` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If `r` is not `nil`, this means a panic occurs and we should perform an action.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can evaluate `r` and see whether it equals one of our error values – `ErrHourlyRate`
    or `ErrHoursWorked`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If our `if` statements evaluate to `true`, we print some details about the
    data and the error values from the `recover()` function. Then, we print how our
    pay was calculated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The rest of the code in the `payDay()` function remains unchanged. To see a
    description of it, please refer to *Exercise 6.04 – crashing the program on errors
    using* *a panic*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the command line, navigate to the directory you created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the command line, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `go build` command will compile your program and create an executable named
    after the directory you created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type the name of the file you created and hit *Enter* to run the executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10: Recovering from a panic exercise output](img/B18621_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Recovering from a panic exercise output'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding exercises, we have seen the progression of creating a custom
    error and returning that error. From this, we have been able to crash programs
    when needed using `panic()`. In the previous exercise, we demonstrated the ability
    to recover from panics and display error messages based on the error type that
    was passed to the `panic()` function. In the following section, we will discuss
    some basic guidelines when performing error handling in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines when working with errors and panics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Guidelines are just for guidance. They are not set in stone. This means that
    the majority of the time, you should follow the guidelines; however, there could
    be exceptions. Some of these guidelines have been mentioned previously, but we
    have consolidated them here for quick reference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When declaring an error type, the variable needs to start with `Err`. It should
    also follow the camel case naming convention:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `error` string should start in lowercase and not end with punctuation. One
    of the reasons for this guideline is that the error can be returned and concatenated
    with other information relevant to the error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a function or method returns an error, it should be evaluated. Errors that
    are not evaluated can cause the program to not function as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using `panic()`, pass an error type as the argument, instead of an empty
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not evaluate the string value of an error to extract information directly
    from the string representation of an error. Instead, use type assertions or the
    error interface methods to retrieve specific details about the error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `panic()` function sparingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Errors should be used for expected situations, such as when you come across
    a recoverable issue in your code. When a function cannot return its intended result
    due to specific conditions, returning an error allows the caller to handle the
    situation gracefully. `panic()` should never be your first line of defense. `panic()`
    is meant for exceptional or unexpected situations and using it for regular error
    handling can lead to hard-to-debug issues, making your code less maintainable.
    Additionally, logging your errors in `DEBUG` mode, which is a state where a program
    provides more detailed information for debugging purposes, can be useful when
    debugging why an error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Following these suggestions will help improve the reliability and maintainability
    of your Go code and help you handle errors gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: Error wrapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When propagating errors up the call stack, there are ways to improve the context
    around why an error occurred. This is extremely useful in complex systems to aid
    in understanding an error case. Error wrapping helps preserve the original error
    information while adding additional context to the error. This can be seen with
    the use of `fmt.Errorf` or the `errors.Wrap` function from `github.com/pkg/errors`.
    Error wrapping provides more detailed information about where an error occurred
    or what caused it, making it easier to understand and handle errors in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of error wrapping can be seen in the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the wrapped error return can be represented by the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how you can easily chain errors using error wrapping.
    `%w` in the format string on the error provided previously allows errors to be
    chained, which provides additional context on why the error occurred. This approach
    is supported in the standard library, so it should be considered the preferred
    and most simplistic method.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is another third-party Go package that can be used to handle
    multiple errors together using `github.com/hashicorp/go-multierror`. These options
    give you the flexibility to understand additional error context or aggregate multiple
    errors into a single error, which can be convenient in certain scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The Go standard library introduced error wrapping in Go 1.13, and you can see
    this type of functionality in use today by professional teams and in more complex
    applications. Providing additional context around an error can be useful in debugging
    scenarios. To illustrate this, consider a situation where an error occurs in code
    you are unfamiliar with, and the error provides no context. It will be very challenging
    to pinpoint the origin of the error. Debugging becomes very difficult when you
    lack information about the specific part of the code where the error occurred.
    However, you must be mindful of not propagating too much context up the call stack
    so that you’re not compromising the security of your code base.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 6.01 – creating a custom error message for a banking application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bank wants to add some custom errors when checking for last names and valid
    routing numbers. They have found that the direct deposit procedure allows invalid
    names and routing numbers to be used. The bank wants a descriptive error message
    for when these incidents occur. Our job is to create two descriptive custom error
    messages. Remember to use an idiomatic naming convention for the error variable
    and a proper structure for the error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you must create two error values for `ErrInvalidLastName` and `ErrInvalidRoutingNumber`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you must print the custom message in the `main()` function to show the
    bank the error message they will receive when those errors are encountered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: By the end of this activity, you will be familiar with the steps that are needed
    to create a custom error message.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found [https://github.com/PacktPublishing/
    Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.01.](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.01)
  prefs: []
  type: TYPE_NORMAL
- en: Activity 6.02 – validating a bank customer’s direct deposit submission
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The bank was pleased with the custom error messages that you created in *Activity
    6.01 – creating a custom error message for a banking application*. They are so
    pleased that they now want you to implement two methods. These two methods are
    for validating the last name and the routing number:'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to create a struct called `directDeposit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `directDeposit` struct will have three string fields: `lastName`, `firstName`,
    and `bankName`. It will also have two `int` fields called `routingNumber` and
    `accountNumber`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `directDeposit` struct will have a `validateRoutingNumber` method. The method
    will return `ErrInvalidRoutingNum` when the routing number is less than 100.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `directDeposit` struct will have a `validateLastName` method. It will return
    `ErrInvalidLastName` when `lastName` is an empty string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `directDeposit` struct will have a method report. It will print out each
    of the fields’ values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main()` function, assign values to the `directDeposit` struct’s fields
    and call each of the `directDeposit` struct’s methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11: Validating a bank customer’s direct deposit submission](img/B18621_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.11: Validating a bank customer’s direct deposit submission'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this activity, you will have learned how to return errors from
    functions and how to check for errors returned from a function. You will also
    be able to check for a condition and, based on that condition, return a custom
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.02).
  prefs: []
  type: TYPE_NORMAL
- en: Activity 6.03 – panic on invalid data submission
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bank has now decided that it would rather crash the program when an invalid
    routing number is submitted. The bank feels that the erroneous data should cause
    the program to stop processing the direct deposit data. You need to raise panic
    on an invalid data submission instance. Build this on top of *Activity 6.02 –
    validating a bank customer’s direct* *deposit submission*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this activity, you only need to do one thing – change the `validateRoutingNumber`
    method so that it doesn’t return `ErrInvalidRoutingNum`, but instead performs
    a panic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12: Panic on an invalid routing number](img/B18621_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.12: Panic on an invalid routing number'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this activity, you will be able to cause a panic to occur and
    see how that impacts the flow of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.03](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.03).
  prefs: []
  type: TYPE_NORMAL
- en: Activity 6.04 – preventing a panic from crashing the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After some initial alpha testing, the bank no longer wants the app to crash,
    Instead, in this activity, we need to recover from the panic that we added in
    *Activity 6.03 – panic on invalid data submission*, and print the error that caused
    the panic:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `defer` function inside the `validateRoutingNumber` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an `if` statement that checks the error that’s returned from the `recover()`
    function. If there is an error, then print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13: Recovering from a panic on an invalid routing number](img/B18621_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.13: Recovering from a panic on an invalid routing number'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this activity, you will have caused a panic, but you will be able
    to prevent it from crashing the application. You will get an understanding of
    how the `recover()` function, used in conjunction with the `defer` statement,
    can be used to prevent the application from crashing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.04](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter06/Activity06.04).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the different types of errors that you will encounter
    while programming, such as syntax, runtime, and semantic errors. We focused more
    on runtime errors since they are challenging to debug.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we examined the difference between various language philosophies when
    it comes to dealing with errors. We saw how Go’s syntax for errors is simpler
    to understand compared to the exception handling that various languages utilize.
  prefs: []
  type: TYPE_NORMAL
- en: An error in Go is a value. Values can be passed around to functions. Any error
    can be a value, so long as it implements the error interface type. We learned
    how easily we can create errors. We also learned that we should name our error
    values so that they start with `Err`, followed by a descriptive camel case name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we discussed panics and the similarities between a panic and an exception.
    We also discovered that panics are pretty similar to exceptions; however, if panics
    aren’t handled, they will cause the program to crash. However, Go has a mechanism
    that will return control of the program to normal: the `recover()` function. The
    requirement for recovering from a panic is the usage of the `recover()` function
    in a deferred function. Then, we learned about the general guidelines for using
    errors, `panic()`, and `recover()` before exploring how to add additional context
    to errors using error wrapping.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at interfaces and their uses, as well as how
    they differ from how other programming languages implement interfaces. We will
    see how they can be used to solve various problems that you will face as a programmer.
  prefs: []
  type: TYPE_NORMAL
