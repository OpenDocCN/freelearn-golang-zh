<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer108">
			<h1 id="_idParaDest-229" class="chapter-number"><a id="_idTextAnchor1291"/>7</h1>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor1292"/>Interfaces</h1>
			<p class="callout-heading"><a id="_idTextAnchor1293"/>Overview</p>
			<p class="callout">This chapter aims to demonstrate the implementation of interfaces in Go. It is quite simple compared to other languages because it is done implicitly in Go, whereas other languages require interfaces to be <span class="No-Break">implemented explicitly.</span></p>
			<p class="callout">In the beginning, you will be able to define and declare an interface for an application and implement an interface in your applications. This chapter introduces you to using duck typing and polymorphism, accepting interfaces, and <span class="No-Break">returning structs.</span></p>
			<p class="callout">By the end of this chapter, you will have learned how to use type assertion to access your interface’s underlying concrete value and use the type <span class="No-Break">switch statement.</span></p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor1294"/><a id="_idTextAnchor1295"/>Technical requirements</h1>
			<p>For this chapter, you'll require Go version 1.21 or higher. The code for this chapter can be found at: <a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter07"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter07</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-232"><a id="_idTextAnchor1296"/>Introduction</h1>
			<p>In the previous chapter, we discussed error handling in Go. We looked at what an error is in Go; it is anything that implements the error interface. At the time, we did not investigate what an interface was. In this chapter, we are going to look at what an <span class="No-Break">interface is.</span></p>
			<p>For example, your manager requests that you create an API that can accept JSON data. The data contains information about various<a id="_idIndexMarker554"/> employees, such as their address and the hours they worked on a project. The data will need to be parsed into an <strong class="source-inline">employee</strong> struct, a relatively simple task. You then create a function called <strong class="source-inline">loadEmployee(s string)</strong>. The function will accept a string that is formatted as JSON, and then parse that string to load the <span class="No-Break"><strong class="source-inline">employee</strong></span><span class="No-Break"> struct.</span></p>
			<p>Your manager is happy with the work; however, they have another requirement. The clients need the ability to accept a file with the employee data in JSON format. The functionality to be performed is the same underlying task as before. You create another function called <strong class="source-inline">loadEmployeeFromFile(f *os.File)</strong> that reads the data from the file, parses the data, and loads the <span class="No-Break"><strong class="source-inline">employee</strong></span><span class="No-Break"> struct.</span></p>
			<p>Your manager has yet another requirement that the employee data should now also come from an HTTP endpoint. You will need to be able to read the data from the HTTP request, so you create another function called <span class="No-Break"><strong class="source-inline">loadEmployeeFromHTTP(r *Request)</strong></span><span class="No-Break">.</span></p>
			<p>All three functions that were written have a common behavior that they are performing. They all need to be able to read the data. The underlying type could be different (such as <strong class="source-inline">string</strong>, <strong class="source-inline">os.File</strong>, or <strong class="source-inline">http.Request</strong>) but the behavior, or reading the data, is the same in <span class="No-Break">all cases.</span></p>
			<p>The <strong class="source-inline">func loadEmployee(s string)</strong>, <strong class="source-inline">func loadEmployeeFromFile(f *os.File)</strong>, and <strong class="source-inline">func loadEmployeeFromHTTP(r *Request)</strong> functions can all be replaced using an interface, <strong class="source-inline">func loadEmployee (r io.Reader)</strong>. <strong class="source-inline">io.Reader</strong> is an interface, and we will discuss it in more depth later in the chapter, but for now, it is enough to say it can be used to solve the <span class="No-Break">given problem.</span></p>
			<p>In this chapter, we will see how interfaces can solve such a problem; by defining the behavior that is being performed as an interface type, we can accept any underlying concrete type. Don’t worry if that does not make sense right now; it will start to become clearer as we progress in this chapter. We will discuss how interfaces give us the ability to perform duck typing and polymorphism. We will see how accepting interfaces and returning structs will decrease coupling and increase the use of functions in more areas of our programs. We will also examine the empty interface and discuss use cases to fully utilize it, along with type assertion and type <span class="No-Break">switch statements.</span><a id="_idTextAnchor1297"/><a id="_idTextAnchor1298"/></p>
			<h1 id="_idParaDest-233"><a id="_idTextAnchor1299"/>Interface</h1>
			<p>An interface is a set of methods that describe the behavior of the data type. Interfaces define the behavior(s) of the type that<a id="_idIndexMarker555"/> must be satisfied to implement that interface. A behavior describes what that type can do. Almost everything exhibits certain behavior. For example, a cat can meow, walk, jump, and purr. All of those are behaviors of a cat. A car can start, stop, turn, and <a id="_idIndexMarker556"/>speed up. All of those are behaviors of a car. Similarly, behaviors for types are <span class="No-Break">called methods.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The definition that the official documentation provides is <em class="italic">Interfaces in Go provide a way to specify the behavior of an object.</em>  (<a href="https://go.dev/doc/effective_go#interfaces_and_types"><span class="No-Break">https://go.dev/doc/effective_go#interfaces_and_types</span></a><span class="No-Break">)</span></p>
			<p>There are several ways to describe <span class="No-Break">an interface:</span></p>
			<ul>
				<li>A collection of method signatures is methods with only the name of the method, its arguments, types, and a return type. This is an example of a collection of method signatures for the <span class="No-Break"><strong class="source-inline">Speaker{}</strong></span><span class="No-Break"> interface:</span><pre class="source-code">
type Speaker interface {
    Speak(message string) string
    Greet() string
}</pre></li>				<li>Blueprints of the type’s methods are needed to satisfy the interface. Using the <strong class="source-inline">Speaker{}</strong> interface, the blueprint (interface) states that to satisfy the <strong class="source-inline">Speaker{}</strong> interface, the type must have a <strong class="source-inline">Speak()</strong> method that accepts a string and returns a string. It also must have a <strong class="source-inline">Greet()</strong> method that returns <span class="No-Break">a string.</span></li>
				<li>Behaviors are what the interface type must exhibit. For example, the <strong class="source-inline">Reader{}</strong> interface has a <strong class="source-inline">Read</strong> method. Its behavior is the reading of data. The following code is from the Go standard library’s <span class="No-Break"><strong class="source-inline">Reader{}</strong></span><span class="No-Break"> interface:</span><pre class="source-code">
type Reader interface {
    Read(b []byte)(n int, err error)
}</pre></li>				<li>Interfaces can be described as having no implementation details. When defining an interface, such as the <strong class="source-inline">Reader{}</strong> interface, it only contains the method signatures without the actual code implementation. The responsibility for supplying the code or implementation details lies with the type that implements the interface, not the <span class="No-Break">interfaces themselves.</span></li>
			</ul>
			<p>Behaviors of a type are<a id="_idIndexMarker557"/> collectively called method sets, which are collections of methods associated with that type. A method set <a id="_idIndexMarker558"/>encompasses the names of methods defined by an interface, along with any input parameters and return types. For example, a type may exhibit behaviors such as <strong class="source-inline">Read()</strong>, <strong class="source-inline">Write()</strong>, and <strong class="source-inline">Save()</strong>. These behaviors collectively form the method sets of the type, providing a clear definition of what actions or functionalities the type <span class="No-Break">can perform.</span></p>
			<p>It is important to note that the reasoning behind the selection of these behaviors and the type’s characteristics should be clearly documented. Understanding why a type has specific behaviors adds context to the <a id="_idIndexMarker559"/>design decisions and enhances overall <span class="No-Break">code comprehension.</span></p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B18621_07_01.jpg" alt="Figure 7.1: Graphical representation of interface elements" width="818" height="525"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1: Graphical representation of interface elements</p>
			<p>When talking about behaviors, note that we did not discuss the implementation details. Implementation details are omitted when you define an interface. It is important to understand that no implementation is specified or enforced in the declaration of an interface. Each type that we create that implements an interface can have its own implementation details. An interface that has a method called <strong class="source-inline">Greeting()</strong> can be implemented in different ways by various types. A struct type of <strong class="source-inline">person</strong> can implement <strong class="source-inline">Greeting()</strong> in a different <a id="_idIndexMarker560"/>way than a struct type <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">animal</strong></span><span class="No-Break">.</span></p>
			<p>Interfaces focus on the behaviors that the type must exhibit. It is not the job of the interface to provide method implementations. That is the job of the type that is implementing the interface. The types, usually a struct, contain the implementation details of the method sets. Now that we have a basic understanding of an interface, in the next topic, we will be looking at how to define <span class="No-Break">an inter<a id="_idTextAnchor1300"/><a id="_idTextAnchor1301"/>face.</span></p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor1302"/>Defining an interface</h2>
			<p>Defining an interface involves the<a id="_idIndexMarker561"/> <span class="No-Break">following steps:</span></p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B18621_07_02.jpg" alt="Figure 7.2: Defining an interface" width="1300" height="270"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2: Defining an interface</p>
			<p>Here is an example of declaring <span class="No-Break">an interfa<a id="_idTextAnchor1303"/>ce:</span></p>
			<pre class="source-code">
type Speaker interface {
    Speak() string
}</pre>			<p>Let’s look at each part of <span class="No-Break">this declaration:</span></p>
			<ul>
				<li>Start with the <strong class="source-inline">type</strong> keyword, followed by the name, and then the <span class="No-Break"><strong class="source-inline">interface</strong></span><span class="No-Break"> keyword.</span></li>
				<li>We are defining an interface type called <strong class="source-inline">Speaker{}</strong>. It is idiomatic in Go to name the interface with an <strong class="source-inline">er</strong> suffix. If it is a one-method interface, it is typical to name the interface after that <span class="No-Break">one method.</span></li>
				<li>Next, you define <a id="_idIndexMarker562"/>the method set. Defining an interface type specifies the method(s) that belong to it. In this interface, we are declaring an interface type that has one method called <strong class="source-inline">Speak()</strong> and it returns <span class="No-Break">a string.</span></li>
				<li>The method set of the <strong class="source-inline">Speaker{}</strong> interface <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Speak()</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Here is an interface that is used frequently <span class="No-Break">in Go:</span></p>
			<pre class="source-code">
// https://golang.org/pkg/io/#Reader
type Reader interface {
    Read(p []byte) (n int, err error)
}</pre>			<p>Let’s look at the parts of <span class="No-Break">this code:</span></p>
			<ul>
				<li>The interface name <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Reader{}</strong></span></li>
				<li>The method set <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Read()</strong></span></li>
				<li>The signature of the <strong class="source-inline">Read()</strong> method is <strong class="source-inline">(p []byte)(n int, </strong><span class="No-Break"><strong class="source-inline">err error)</strong></span></li>
			</ul>
			<p>Interfaces can have more than one method as its method set. Let’s look at an interface used in the <span class="No-Break">Go package:</span></p>
			<pre class="source-code">
// https://golang.org/pkg/os/#FileInfo
type FileInfo interface {
    Name() string // base name of the file
    Size() int64 // length in bytes for regular files; system-dependent for others
    Mode() FileMode // file mode bits
    ModTime() time.Time // modification time
    IsDir() bool // abbreviation for Mode().IsDir()
    Sys() interface{} // underlying data source (can return nil)
}</pre>			<p>As you can see, <strong class="source-inline">FileInfo{}</strong> has <span class="No-Break">multiple methods.</span></p>
			<p>In summary, interfaces are types that declare method sets. Similar to other languages that utilize interfaces, they do not implement the method sets. Implementation details are not part of defining an<a id="_idIndexMarker563"/> interface. In the next topic, we will be looking at what Go requires for you to be able to implement <span class="No-Break">the int<a id="_idTextAnchor1304"/><a id="_idTextAnchor1305"/>erface.</span></p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor1306"/>Implementing an interface</h2>
			<p>Interfaces in other programming languages<a id="_idIndexMarker564"/> implement an interface explicitly. Explicit implementation means that the programming language directly and clearly states that this object is using this interface. For example, this is <span class="No-Break">in Java:</span></p>
			<pre class="source-code">
class Dog implements Pet</pre>			<p>The code segment explicitly states that the <strong class="source-inline">Dog</strong> class will implement the <span class="No-Break"><strong class="source-inline">Pet</strong></span><span class="No-Break"> interface.</span></p>
			<p>In Go, interfaces are implemented implicitly. This means that a type will implement the interface by having all the methods and the signature of the interface. Here is <span class="No-Break">an example:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
)
type Speaker interface {
  Speak() string
}
type cat struct {
}
func main() {
  c := cat{}
  fmt.Println(c.Speak())
  c.Greeting()
}
func (c cat) Speak() string {
  return "Purr Meow"
}
func (c cat) Greeting() {
  fmt.Println("Meow,Meow!!!!mmmeeeeoooowwww")
}</pre>			<p>Let’s break this code down <span class="No-Break">into parts:</span></p>
			<pre class="source-code">
type Speaker interface {
  Speak() string
}</pre>			<p>We are defining a <strong class="source-inline">Speaker{}</strong> interface. It has one method that describes the <strong class="source-inline">Speak()</strong> behavior. The method returns a string. For a type to implement the <strong class="source-inline">Speaker{}</strong> interface, it must <a id="_idIndexMarker565"/>have the method listed in the interface declaration. Then, we create an empty struct type <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">cat</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type cat struct {
}
func (c cat) Speak() string {
  return "Purr Meow"
}</pre>			<p>The <strong class="source-inline">cat</strong> type has a <strong class="source-inline">Speak()</strong> method that returns the string. This satisfies the <strong class="source-inline">Speaker{}</strong> interface. It is now the responsibility of the implementer of <strong class="source-inline">cat</strong> to provide the implementation details for the <strong class="source-inline">cat</strong> type’s <span class="No-Break"><strong class="source-inline">Speak()</strong></span><span class="No-Break"> method.</span></p>
			<p>Notice that there was no explicit statement that declares <strong class="source-inline">cat</strong> implements the <strong class="source-inline">Speaker{}</strong> interface; it does so by just having met the requirements of <span class="No-Break">the interface.</span></p>
			<p>It is also important to notice that the <strong class="source-inline">cat</strong> type has a method called <strong class="source-inline">Greeting()</strong>. The type can have methods that are not needed to satisfy the <strong class="source-inline">Speaker{}</strong> interface. However, the <strong class="source-inline">cat</strong> must have<a id="_idIndexMarker566"/> at least the required method sets to be able to satisfy <span class="No-Break">the interface.</span></p>
			<p>The output will be <span class="No-Break">as follows:</span></p>
			<pre class="console">
Purr Meow
Meow,Meow!!!!mmmee<a id="_idTextAnchor1307"/><a id="_idTextAnchor1308"/>eeoooowwww</pre>			<h2 id="_idParaDest-236"><a id="_idTextAnchor1309"/>Advantages of implementing interfaces implicitly</h2>
			<p>There are some advantages to implementing interfaces implicitly. We have seen that when you create an interface, you have to go to each type and explicitly state that the type implements the interface. In Go, the type <a id="_idIndexMarker567"/>that satisfies the interface is said to implement it. There is no <strong class="source-inline">implements</strong> keyword like in other languages; you do not need to say that a type implements the interface. In Go, if it has the method sets and signatures of the interface, it implicitly implements <span class="No-Break">the interface.</span></p>
			<p>When you change the method sets of an interface, in other languages you would have to go to all those types that did not satisfy the interface and remove the explicit declaration for the type. This is not the case in Go, since it is an <span class="No-Break">implicit declaration.</span></p>
			<p>Another advantage is you can use interfaces for types that are in another package. This decouples the definition of an interface from its implementation. We will discuss packages and their scope in <a href="B18621_10.xhtml#_idTextAnchor1405"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Packages Keep </em><span class="No-Break"><em class="italic">Projects Manageable</em></span><span class="No-Break">.</span></p>
			<p>Let’s look at an example of using an interface from a different package in our main package. The <strong class="source-inline">Stringer</strong> interface is an interface that is in the Go language. It is used by several packages through the Go language. One example is the <strong class="source-inline">fmt</strong> package, which is used for formatting when <span class="No-Break">printing values:</span></p>
			<pre class="source-code">
type Stringer interface {
  String() string
}</pre>			<p><strong class="source-inline">Stringer</strong> is an interface that is a type that can describe itself as a string. Interface names typically follow the method <a id="_idIndexMarker568"/>name but with the addition of the <span class="No-Break"><strong class="source-inline">er</strong></span><span class="No-Break"> suffix:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
)
type Speaker interface {
  Speak() string
}
type cat struct {
  name string
  age int
}
func main() {
  c := cat{name: "Oreo", age:9}
  fmt.Println(c.Speak())
  fmt.Println(c)
}
func (c cat) Speak() string {
  return "Purr Meow"
}
func (c cat) String() string {
  return fmt.Sprintf("%v (%v years old)", c.name, c.age)
}</pre>			<p>Let’s break down this code <span class="No-Break">into parts:</span></p>
			<ul>
				<li>We have added a <strong class="source-inline">String()</strong> method to our <strong class="source-inline">cat</strong> type. It returns the field data for <strong class="source-inline">name</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">age</strong></span><span class="No-Break">.</span></li>
				<li>When we call the <strong class="source-inline">fmt.Println()</strong> method in <strong class="source-inline">main()</strong> with the argument of <strong class="source-inline">cat</strong>, <strong class="source-inline">fmt.Println()</strong> calls the <strong class="source-inline">String()</strong> method on the <span class="No-Break"><strong class="source-inline">cat</strong></span><span class="No-Break"> type.</span></li>
				<li>Our <strong class="source-inline">cat</strong> type now<a id="_idIndexMarker569"/> implements two interfaces: the <strong class="source-inline">Speaker{}</strong> interface and the <strong class="source-inline">Stringer{}</strong> interface. It has the methods required to satisfy both of <span class="No-Break">those interfaces:</span></li>
			</ul>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B18621_07_03.jpg" alt="Figure 7.3: Types can implement multiple interfaces" width="331" height="194"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3: Types can implement multipl<a id="_idTextAnchor1310"/><a id="_idTextAnchor1311"/>e interfaces</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor1312"/>Exercise 7.01 – implementing an interface</h2>
			<p>In this exercise, we are going to create<a id="_idIndexMarker570"/> a simple program that demonstrates how to implement interfaces implicitly. We will have a <strong class="source-inline">person</strong> struct that will implicitly implement the <strong class="source-inline">Speaker{}</strong> interface. The <strong class="source-inline">person</strong> struct will contain <strong class="source-inline">name</strong>, <strong class="source-inline">age</strong>, and <strong class="source-inline">isMarried</strong> as its fields. The program will call the <strong class="source-inline">Speak()</strong> method of our <strong class="source-inline">person</strong> struct and display a message displaying the <strong class="source-inline">person</strong> struct’s <strong class="source-inline">name</strong>. The <strong class="source-inline">person</strong> struct will also satisfy the requirements for the <strong class="source-inline">Stringer{}</strong> interface by having a <strong class="source-inline">String()</strong> method. You may recall previously, in the <em class="italic">Advantages of implementing interfaces implicitly</em> section, that the <strong class="source-inline">Stringer{}</strong> interface is an interface that is in the Go language. It can be used for formatting when printing values. That is how we are going to use it in this exercise to format the printing of the fields of the <span class="No-Break"><strong class="source-inline">person</strong></span><span class="No-Break"> struct:</span></p>
			<ol>
				<li>Create a new file and save it <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></li>
				<li>We will have <strong class="source-inline">package</strong> <strong class="source-inline">main</strong> and will be using the <strong class="source-inline">fmt</strong> package in <span class="No-Break">this program:</span><pre class="source-code">
package main
import (
  "fmt"
)</pre></li>				<li>Create a <strong class="source-inline">Speaker{}</strong> interface with a method called <strong class="source-inline">Speak()</strong> that returns <span class="No-Break">a string:</span><pre class="source-code">
type Speaker interface {
  Speak() string
}</pre><p class="list-inset">We have created a <strong class="source-inline">Speaker{}</strong> interface. Any type that wants to implement our <strong class="source-inline">Speaker{}</strong> interface<a id="_idIndexMarker571"/> must have a <strong class="source-inline">Speak()</strong> method that returns <span class="No-Break">a string.</span></p></li>				<li>Create our <strong class="source-inline">person</strong> struct with <strong class="source-inline">name</strong>, <strong class="source-inline">age</strong>, and <strong class="source-inline">isMarried</strong> as <span class="No-Break">its fields:</span><pre class="source-code">
type person struct {
  name string
  age int
  isMarried bool
}</pre><p class="list-inset">Our <strong class="source-inline">person</strong> type contains <strong class="source-inline">name</strong>, <strong class="source-inline">age</strong>, and <strong class="source-inline">isMarried</strong> fields. We will later print the contents of these fields in our <strong class="source-inline">main</strong> function using a <strong class="source-inline">Speak()</strong> method that returns a string. Having a <strong class="source-inline">Speak()</strong> method will satisfy the <span class="No-Break"><strong class="source-inline">Speaker{}</strong></span><span class="No-Break"> interface.</span></p></li>				<li>In the <strong class="source-inline">main()</strong> function, we will initialize a <strong class="source-inline">person</strong> type, print the <strong class="source-inline">Speak()</strong> method, and print the <strong class="source-inline">person</strong> <span class="No-Break">field values:</span><pre class="source-code">
func main() {
  p := person{name: "Cailyn", age: 44, isMarried: false}
  fmt.Println(p.Speak())
  fmt.Println(p)
}</pre></li>				<li>Create a <strong class="source-inline">String()</strong> method for <strong class="source-inline">person</strong> and return a string value. This will satisfy the <strong class="source-inline">Stringer{}</strong> interface, which <a id="_idIndexMarker572"/>will now allow it to be called by the <span class="No-Break"><strong class="source-inline">fmt.Println()</strong></span><span class="No-Break"> method:</span><pre class="source-code">
func (p person) String() string {
  return fmt.Sprintf("%v (%v years old).\nMarried status: %v ", p.name, p.age, p.isMarried)
}</pre></li>				<li>Create a <strong class="source-inline">Speak()</strong> method for <strong class="source-inline">person</strong> that returns a string. The <strong class="source-inline">person</strong> type has a <strong class="source-inline">Speak()</strong> method that has the same signature as the <strong class="source-inline">Speak()</strong> method of the <strong class="source-inline">Speaker{}</strong> interface. The <strong class="source-inline">person</strong> type satisfies the <strong class="source-inline">Speaker{}</strong> interface by having a <strong class="source-inline">Speak()</strong> method that returns the string. To satisfy interfaces, you must have the same methods and method signatures of <span class="No-Break">the interface:</span><pre class="source-code">
func (p person) Speak() string {
  return "Hi my name is: " + p.name
}</pre></li>				<li>Open the terminal and navigate to the <span class="No-Break">code’s directory.</span></li>
				<li>Run <strong class="source-inline">go </strong><span class="No-Break"><strong class="source-inline">build main.go</strong></span><span class="No-Break">.</span></li>
				<li>Correct any errors that are returned and ensure your code matches the code <span class="No-Break">snippet here.</span></li>
				<li>Run the executable by typing the executable name in the command line with the <strong class="source-inline">./</strong><span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> command.</span></li>
			</ol>
			<p>You should get the <span class="No-Break">following output:</span></p>
			<pre class="console">
Hi my name is Cailyn
Cailyn (44 years old).
Married status: false</pre>			<p>In this exercise, we saw how simple it is to implement interfaces implicitly. In the next topic, we will build on this by having different data types, such as structs, implement the same interface, which can be passed to any function that has the argument of that type of interface. We will go into greater <a id="_idIndexMarker573"/>detail about how that is possible in the next topic and see why it is a benefit for a type to appear i<a id="_idTextAnchor1313"/><a id="_idTextAnchor1314"/>n <span class="No-Break">various forms.</span></p>
			<h1 id="_idParaDest-238"><a id="_idTextAnchor1315"/>Duck typing</h1>
			<p>We have been basically doing what is called duck typing. Duck<a id="_idIndexMarker574"/> typing is a test in computer programming: <em class="italic">If it looks like a duck, swims like a duck, and quacks like a duck, then it must be a duck.</em> If a type matches an interface, then you can use that type wherever that interface is used. Duck typing is matching a type based upon methods, rather than the <span class="No-Break">expected type:</span></p>
			<pre class="source-code">
type Speaker interface {
  Speak() string
}</pre>			<p>Anything that matches the <strong class="source-inline">Speak()</strong> method can be a <strong class="source-inline">Speaker{}</strong> interface. When implementing an interface, we are essentially conforming to that interface by having the required <span class="No-Break">method sets:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
)
type Speaker interface {
  Speak() string
}
type cat struct {
}
func main() {
  c := cat{}
  fmt.Println(c.Speak())
}
func (c cat) Speak() string {
  return "Purr Meow"
}</pre>			<p><strong class="source-inline">cat</strong> matches the <strong class="source-inline">Speak()</strong> method <a id="_idIndexMarker575"/>of the <strong class="source-inline">Speaker{}</strong> interface, so a <strong class="source-inline">cat</strong> is <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">Speaker{}</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
)
type Speaker interface {
  Speak() string
}
type cat struct {
}
func main() {
  c := cat{}
  chatter(c)
}
func (c cat) Speak() string {
  return "Purr Meow"
}
func chatter(s Speaker) {
  fmt.Println(s.Speak())
}</pre>			<p>Let’s examine this code <span class="No-Break">in parts:</span></p>
			<ul>
				<li>In the preceding code, we declare a <strong class="source-inline">cat</strong> type and create a method for the <strong class="source-inline">cat</strong> type called <strong class="source-inline">Speak()</strong>. This<a id="_idIndexMarker576"/> fulfills the required method sets for the <span class="No-Break"><strong class="source-inline">Speaker{}</strong></span><span class="No-Break"> interface.</span></li>
				<li>We create a method called <strong class="source-inline">chatter</strong> that takes the <strong class="source-inline">Speaker{}</strong> interface as <span class="No-Break">an argument.</span></li>
				<li>In the <strong class="source-inline">main()</strong> function, we are able to pass a <strong class="source-inline">cat</strong> type into the <strong class="source-inline">chatter</strong> function, which can evaluate to the <strong class="source-inline">Speaker{}</strong> interface. This satisfies the required method sets<a id="_idTextAnchor1316"/><a id="_idTextAnchor1317"/> for <span class="No-Break">the interface.</span></li>
			</ul>
			<h1 id="_idParaDest-239"><a id="_idTextAnchor1318"/>Polymorphism</h1>
			<p>Polymorphism is the ability to appear in <a id="_idIndexMarker577"/>various forms. For example, a shape can appear as a square, circle, rectangle, or any <span class="No-Break">other shape:</span></p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B18621_07_04.jpg" alt="Figure 7.4: Polymorphism example for shape" width="450" height="186"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4: Polymorphism example for shape</p>
			<p>Go does not do subclassing like other object-oriented languages because Go does not have classes. Subclassing in object-oriented programming is inheriting from one class to another. By doing subclassing, you are inheriting the fields and methods of another class. Go provides a similar behavior through embedding structs and by using polymorphism <span class="No-Break">through interfaces.</span></p>
			<p>One of the advantages of using polymorphism is that it allows the reuse of methods that have been written once and tested. Code is reused by having an <strong class="bold">Application Programming Interface</strong> (<strong class="bold">API</strong>) that accepts an<a id="_idIndexMarker578"/> interface; if our type satisfies that interface, it can be passed to that API. There is no need to write additional code for each type; we just need to ensure we meet the interface method’s set requirements. Obtaining polymorphism through the use of interfaces will increase the reusability of the code. If your API only accepts<a id="_idIndexMarker579"/> concrete types such as <strong class="source-inline">int</strong>, <strong class="source-inline">float</strong>, and <strong class="source-inline">bool</strong>, only that concrete type can be passed. However, if your API accepts an interface, then the caller can add the required method sets to satisfy that interface regardless of the underlying type. This reusability is accomplished by allowing your APIs to accept interfaces. Any type that satisfies the interface can be passed to the API. We have seen this type of behavior in a previous example. This is a good time to take a closer look at the <span class="No-Break"><strong class="source-inline">Speaker{}</strong></span><span class="No-Break"> interface.</span></p>
			<p>As we have seen in previous examples, each concrete type can implement one or more interfaces. Recall that our <strong class="source-inline">Speaker{}</strong> interface can be implemented by a <strong class="source-inline">dog</strong>, <strong class="source-inline">cat</strong>, or <span class="No-Break"><strong class="source-inline">person</strong></span><span class="No-Break"> type:</span></p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B18621_07_05.jpg" alt="Figure 7.5: The Speaker interface implemented by multiple types" width="466" height="207"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5: The Speaker interface implemented by multiple types</p>
			<p>When a function accepts an interface as an input parameter, any concrete type that implements that interface can be passed as an argument. Now, you have achieved polymorphism by being able to pass various concrete types to a method or function that has an interface type as an <span class="No-Break">input parameter.</span></p>
			<p>Let’s look at some progressive examples that will enable us to demonstrate how polymorphism is achieved <span class="No-Break">in Go:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
)
type Speaker interface {
  Speak() string
}
type cat struct {
}
func main() {
  c := cat{}
  catSpeak(c)
}
func (c cat) Speak() string {
  return "Purr Meow"
}
func catSpeak(c cat) {
  fmt.Println(c.Speak())
}</pre>			<p>Let’s examine the code <span class="No-Break">in parts:</span></p>
			<ul>
				<li><strong class="source-inline">cat</strong> satisfies the <strong class="source-inline">Speaker{}</strong> interface. The <strong class="source-inline">main()</strong> function calls <strong class="source-inline">catSpeak()</strong> and takes a type <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">cat</strong></span><span class="No-Break">.</span></li>
				<li>Inside <strong class="source-inline">catSpeak()</strong>, it prints out the results of its <span class="No-Break"><strong class="source-inline">Speak()</strong></span><span class="No-Break"> method.</span></li>
			</ul>
			<p>We are going to implement some <a id="_idIndexMarker580"/>code that takes a concrete type (<strong class="source-inline">cat</strong>, <strong class="source-inline">dog</strong>, or <strong class="source-inline">person</strong>) and satisfies the <strong class="source-inline">Speaker{}</strong> interface type. Using the previous coding pattern, it would look like the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
)
type Speaker interface {
  Speak() string
}
type cat struct {
}
type dog struct {
}
type person struct {
  name string
}
func main() {
  c := cat{}
  d := dog{}
  p := person{name:"Heather"}
  catSpeak(c)
  dogSpeak(d)
  personSpeak(p)
}
func (c cat) Speak() string {
  return "Purr Meow"
}
func (d dog) Speak() string {
  return "Woof Woof"
}
func (p person) Speak() string {
  return "Hi my name is " + p.name +"."
}
func catSpeak(c cat) {
  fmt.Println(c.Speak())
}
func dogSpeak(d dog) {
  fmt.Println(d.Speak())
}
func personSpeak(p person) {
  fmt.Println(p.Speak())
}</pre>			<p>Let’s look at this code <span class="No-Break">in parts:</span></p>
			<pre class="source-code">
type cat struct {
}
type dog struct {
}
type person struct {
  name string
}</pre>			<p>We have three concrete types (<strong class="source-inline">cat</strong>, <strong class="source-inline">dog</strong>, and <strong class="source-inline">person</strong>). The <strong class="source-inline">cat</strong> and <strong class="source-inline">dog</strong> types are empty structs, while<a id="_idIndexMarker581"/> the <strong class="source-inline">person</strong> struct has a <span class="No-Break"><strong class="source-inline">name</strong></span><span class="No-Break"> field:</span></p>
			<pre class="source-code">
func (c cat) Speak() string {
  return "Purr Meow"
}
func (d dog) Speak() string {
  return "Woof Woof"
}
func (p person) Speak() string {
  return "Hi my name is " + p.name +"."
}</pre>			<p>Each of our types implicitly implements the <strong class="source-inline">Speaker{}</strong> interface. Each of the concrete types implements it differently<a id="_idIndexMarker582"/> from <span class="No-Break">the others:</span></p>
			<pre class="source-code">
func main() {
  c := cat{}
  d := dog{}
  p := person{name:"Heather"}
  catSpeak(c)
  dogSpeak(d)
  personSpeak(p)
}</pre>			<p>In the <strong class="source-inline">main()</strong> function, we call <strong class="source-inline">catSpeak()</strong>, <strong class="source-inline">dogSpeak()</strong>, and <strong class="source-inline">personSpeak()</strong> to invoke their respective <strong class="source-inline">Speak()</strong> methods. The preceding code has a lot of redundant functions that perform similar actions. We can refactor this code to be simpler and easier to read. We will use some of the features you get with implementing interfaces to provide a more <span class="No-Break">concise implementation:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
)
type Speaker interface {
  Speak() string
}
func saySomething(say ...Speaker) {
  for _, s := range say {
    fmt.Println(s.Speak())
  }
}
type cat struct {}
func (c cat) Speak() string {
  return "Purr Meow"
}
type dog struct {}
func (d dog) Speak() string {
  return "Woof Woof"
}
type person struct {
  name string
}
func (p person) Speak() string {
  return "Hi my name is " + p.name + "."
}
func main() {
  c := cat{}
  d := dog{}
  p := person{name: "Heather"}
  saySomething(c,d,p)
}</pre>			<p>Let’s look at the code <span class="No-Break">in parts:</span></p>
			<pre class="source-code">
func saySomething(say ...Speaker)</pre>			<p>Our <strong class="source-inline">saySomething()</strong> function is using a variadic parameter. If you recall, a variadic parameter can accept zero or more<a id="_idIndexMarker583"/> arguments for that type. For more information on variadic functions, review <a href="B18621_05.xhtml#_idTextAnchor1048"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Reduce, Reuse, and Recycle</em>. The parameter type is <strong class="source-inline">Speaker</strong>. An interface can be used as an <span class="No-Break">input parameter:</span></p>
			<pre class="source-code">
func saySomething(say ...Speaker) {
  for _, s := range say {
    fmt.Println(s.Speak())
  }
}</pre>			<p>We range over the slice of <strong class="source-inline">Speaker</strong>. For each <strong class="source-inline">Speaker</strong> type, we call the <strong class="source-inline">Speak()</strong> method. In our code, we passed the <strong class="source-inline">cat</strong> and <strong class="source-inline">dog</strong> struct types to the <strong class="source-inline">person</strong> function. The function accepts an argument as an interface of <strong class="source-inline">Speaker{}</strong>. Any of the methods that make up that interface can be invoked. For each of those concrete types, the <strong class="source-inline">Speak()</strong> method <span class="No-Break">is called.</span></p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B18621_07_06.jpg" alt="Figure 7.6: Multiple types implementing the Speaker interface" width="474" height="245"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6: Multiple types implementing the Speaker interface</p>
			<p>In the <strong class="source-inline">main()</strong> function, we will see polymorphism being demonstrated through the use <span class="No-Break">of interfaces:</span></p>
			<pre class="source-code">
func main() {
  c := cat{}
  d := dog{}
  p := person{name: "Heather"}
  saySomething(c,d,p)
}</pre>			<p>We implement each of the concrete types, <strong class="source-inline">cat</strong>, <strong class="source-inline">dog</strong>, and <strong class="source-inline">person</strong>. The <strong class="source-inline">cat</strong>, <strong class="source-inline">dog</strong>, and <strong class="source-inline">person</strong> types all satisfy the <strong class="source-inline">Speaker{}</strong> interface. Since they match an interface, you can use that type wherever that interface is used. As you can see, this also includes being able to pass the <strong class="source-inline">cat</strong>, <strong class="source-inline">dog</strong>, and <strong class="source-inline">person</strong> types into <span class="No-Break">a method.</span></p>
			<p>Through the use of interfaces and polymorphism, this code is more concise than the previous code snippets. The<a id="_idIndexMarker584"/> example at the beginning of the chapter showed a single concrete type that satisfied the <strong class="source-inline">Speaker{}</strong> interface that invoked the <strong class="source-inline">Speak()</strong> method. We then added a few more concrete types to our running example (<strong class="source-inline">cat</strong>, <strong class="source-inline">dog</strong>, and <strong class="source-inline">person</strong>), each of these separately invoking their own <strong class="source-inline">Speak()</strong> method. We noticed redundant code in that example and started looking for a better way to implement the solution. We discovered that interface types can be parameter input types. Through duck typing and polymorphism, our third and final code snippet was able to have a single function that would call the <strong class="source-inline">Speak()</strong> method on each type that satisfied <a id="_idTextAnchor1319"/><a id="_idTextAnchor1320"/>the <span class="No-Break"><strong class="source-inline">Speaker()</strong></span><span class="No-Break"> interface.</span></p>
			<p>Exercise 7.02 – calculating the area of different shapes <span class="No-Break">using polymorphism</span></p>
			<p>We will be implementing a program that will <a id="_idIndexMarker585"/>calculate the area of a triangle, rectangle, and square. The program will use a single function that accepts a <strong class="source-inline">Shape</strong> interface. Any type that satisfies the <strong class="source-inline">Shape</strong> interface can be passed as an argument to the function. This function should then print the area and the name of <span class="No-Break">the shape:</span></p>
			<ol>
				<li>Use the IDE of <span class="No-Break">your choice.</span></li>
				<li>Create a new file and save it <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></li>
				<li>We will have a package called <strong class="source-inline">main</strong>, and we will be using the <strong class="source-inline">fmt</strong> package in <span class="No-Break">this program:</span><pre class="source-code">
package main
import (
  "fmt"
)</pre></li>				<li>Create the <strong class="source-inline">Shape{}</strong> interface, which has two method sets called <strong class="source-inline">Area() float64</strong> and <span class="No-Break"><strong class="source-inline">Name() string</strong></span><span class="No-Break">:</span><pre class="source-code">
type Shape interface {
  Area() float64
  Name() string
}</pre></li>				<li>Next, we will create <strong class="source-inline">triangle</strong>, <strong class="source-inline">rectangle</strong>, and <strong class="source-inline">square</strong> struct types. These types will each satisfy the <strong class="source-inline">Shape{}</strong> interface. <strong class="source-inline">triangle</strong>, <strong class="source-inline">rectangle</strong>, and <strong class="source-inline">square</strong> have appropriate <a id="_idIndexMarker586"/>fields that are needed to calculate the area of <span class="No-Break">the shape:</span><pre class="source-code">
type triangle struct {
  base float64
  height float64
}
type rectangle struct {
  length float64
  width float64
}
type square struct {
  side float64
}</pre></li>				<li>We create the <strong class="source-inline">Area()</strong> and <strong class="source-inline">Name()</strong> methods for the <strong class="source-inline">triangle</strong> struct type. The area of a triangle is <em class="italic">base * height/2</em>. The <strong class="source-inline">Name()</strong> method returns the name of <span class="No-Break">the shape:</span><pre class="source-code">
func (t triangle) Area() float64 {
  return (t.base * t.height) / 2
}
func (t triangle) Name() string {
  return "triangle"
}</pre></li>				<li>We create the <strong class="source-inline">Area()</strong> and <strong class="source-inline">Name()</strong> methods for the <strong class="source-inline">rectangle</strong> struct type. The area of<a id="_idIndexMarker587"/> a rectangle is <strong class="source-inline">length * width</strong>. The <strong class="source-inline">Name()</strong> method returns the name of <span class="No-Break">the shape:</span><pre class="source-code">
func (r rectangle) Area() float64 {
  return r.length * r.width
}
func (r rectangle) Name() string {
  return "rectangle"
}</pre></li>				<li>We create the <strong class="source-inline">Area()</strong> and <strong class="source-inline">Name()</strong> methods for the <strong class="source-inline">square</strong> struct type. The area of a square is <strong class="source-inline">side * side</strong>. The <strong class="source-inline">Name()</strong> method returns the name of <span class="No-Break">the shape:</span><pre class="source-code">
func (s square) Area() float64 {
  return s.side * s.side
}
func (s square) Name() string {
  return "square"
}</pre><p class="list-inset">Now, each of our shapes (<strong class="source-inline">triangle</strong>, <strong class="source-inline">rectangle</strong>, and <strong class="source-inline">square</strong>) satisfies the <strong class="source-inline">Shape</strong> interface <a id="_idIndexMarker588"/>because they each have an <strong class="source-inline">Area()</strong> and <strong class="source-inline">Name()</strong> method with the <span class="No-Break">appropriate signatures:</span></p></li>			</ol>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B18621_07_07.jpg" alt="Figure 7.7: square, triangle, and rectangle areas of the Shape type" width="543" height="520"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7: square, triangle, and rectangle areas of the Shape type</p>
			<ol>
				<li value="9">We will now create a function that accepts the <strong class="source-inline">Shape</strong> interface as a variadic parameter. The function will iterate over the <strong class="source-inline">Shape</strong> type and execute each of its <strong class="source-inline">Name()</strong> and <span class="No-Break"><strong class="source-inline">Area()</strong></span><span class="No-Break"> methods:</span><pre class="source-code">
func printShapeDetails(shapes ...Shape) {
  for _, item := range shapes {
    fmt.Printf("The area of %s is: %.2f\n", item.Name(), item.Area())
  }
}</pre></li>				<li>Inside the <strong class="source-inline">main()</strong> function, set the fields for <strong class="source-inline">triangle</strong>, <strong class="source-inline">rectangle</strong>, and <strong class="source-inline">square</strong>. Pass all three to the <strong class="source-inline">printShapeDetail()</strong> function. All three can be passed because they each satisfy the <span class="No-Break"><strong class="source-inline">Shape</strong></span><span class="No-Break"> interface:</span><pre class="source-code">
func main() {
  t := triangle{base: 15.5, height: 20.1}
  r := rectangle{length: 20, width: 10}
  s := square{side: 10}
  printShapeDetails(t, r, s)
}</pre></li>				<li>Build the program by<a id="_idIndexMarker589"/> running <strong class="source-inline">go build</strong> at the <span class="No-Break">command line:</span><pre class="source-code">
go build main.go</pre></li>				<li>Correct any errors that are returned and ensure your code matches the code <span class="No-Break">snippet here.</span></li>
				<li>Run the executable by typing the name of the executable and hit <em class="italic">Enter</em> to <span class="No-Break">run it:</span><pre class="source-code">
./main</pre></li>			</ol>
			<p>You should see the <span class="No-Break">following output:</span></p>
			<pre class="console">
The area of triangle is: 155.78
The area of rectangle is: 200.00
The area of square is: 100.00</pre>			<p>In this exercise, we saw the flexibility and the reusable code that interfaces provide to our programs. Further, we will discuss how accepting interfaces and returning structs for our functions and methods increase code reusability and low coupling by not being dependent on the concrete types. When we use interfaces as input arguments to an API, we are stating that a type needs to satisfy the interface. When using concrete types, we require that the argument for the API must be of that type. For instance, if a function signature is <strong class="source-inline">func greeting(msg string)</strong>, we know that the argument being passed must be a string. Concrete types can be thought of as types that are not abstract (<strong class="source-inline">float64</strong>, <strong class="source-inline">int</strong>, <strong class="source-inline">string</strong>, and so on); however, interfaces could be considered an abstract type because you are satisfying the method sets of the interface type. The underlying interface type is a concrete type, but the underlying type is not what needs to be passed into the API. The type must meet the requirements of having the method sets that the interface <span class="No-Break">type defines.</span></p>
			<p>In the future, if we require another type to be passed, this will mean the code upstream to our API will need to change, or if the caller of our API needs to change its data type, it might request we change our API to accommodate it. If we use interfaces, this is not an issue; the caller of our code <a id="_idIndexMarker590"/>needs to satisfy the interface’s method sets. The caller can then change the underlying type if it complies wit<a id="_idTextAnchor1321"/><a id="_idTextAnchor1322"/>h the <span class="No-Break">interface requirements.</span></p>
			<p>Accepting interfaces and <span class="No-Break">returning structs</span></p>
			<p>There is a Go proverb that states, <em class="italic">Accept interfaces, return structs</em>. It can be restated as accept interfaces and return <a id="_idIndexMarker591"/>concrete types. This proverb is talking about accepting interfaces for your APIs (functions, methods, and so on) and the return to be structs or concrete types. This proverb follows Postel’s Law, which states, <em class="italic">Be conservative with what you do, be liberal with what you accept</em>. We are focusing on the <em class="italic">be liberal with what you accept</em> part. By accepting interfaces, you are increasing the flexibility of the API for your functi0on or method. By doing this, you are allowing for the user of the API to meet the requirements of the interface, but not forcing the user to use a concrete type. If our functions or methods only accept concrete types, then we are limiting the users of our functions to a specific implementation. In this chapter, we are going to explore the previously mentioned Go proverb and learn why it is a good design pattern to follow. We will see that as we go over the <span class="No-Break">code example:</span></p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B18621_07_08.jpg" alt="Figure 7.8: Benefits of accepting interfaces" width="770" height="484"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8: Benefits of accepting interfaces</p>
			<p>The following example will illustrate the benefits of accepting interfaces versus using concrete types. We will have two functions that perform the same task of decoding JSON, but each has <a id="_idIndexMarker592"/>different inputs. One of these functions is superior to the other, and we will go over the reasons why that is <span class="No-Break">the case.</span></p>
			<p>Look at the <span class="No-Break">following example:</span></p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">main.go</p>
			<pre class="source-code">
package main
import (
    "encoding/json"
    "fmt"
    "io"
    "strings"
)
type Person struct {
    Name string `json:"name"`
    Age int `json:"age"`
}</pre>			<p>The full code is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Example01/main.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Example01/main.go</span></a><span class="No-Break">.</span></p>
			<p>The expected output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
{Joe 18}
{Jane 21}</pre>			<p>Let’s examine each part of this code. We will discuss some parts of the code in the upcoming chapters. This<a id="_idIndexMarker593"/> code decodes some data into a struct. There are two functions being used for that purpose, <strong class="source-inline">loadPerson2()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">loadPerson()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func loadPerson2(s string) (Person, error) {
    var p Person
    err := json.NewDecoder(strings.NewReader(s)).Decode(&amp;p)
    return p, err
}</pre>			<p>The <strong class="source-inline">loadPerson2()</strong> function accepts an argument that is a concrete string and returns a struct. The returning of the struct meets half of <em class="italic">Accept interfaces, return structs</em>. However, it is very limited and not liberal in what it accepts. This limits the user of the function to a narrow implementation. The only thing that can ever be passed is a string. Granted, in some cases that might be acceptable, but in other situations, it could be a problem. For example, if your function or method should only accept a specific data type, then you may not want to <span class="No-Break">accept interfaces:</span></p>
			<pre class="source-code">
func loadPerson(r io.Reader) (Person, error) {
    var p Person
    err := json.NewDecoder(r).Decode(&amp;p)    return p, err
}</pre>			<p>In this function, we are accepting the <strong class="source-inline">io.Reader{}</strong> interface. The <strong class="source-inline">io.Reader{}</strong> (<a href="https://pkg.go.dev/io#Reader">https://pkg.go.dev/io#Reader</a>) and <strong class="source-inline">io.Writer{}</strong> (<a href="https://pkg.go.dev/io#Writer">https://pkg.go.dev/io#Writer</a>) interfaces are among the most utilized interfaces in Go packages. <strong class="source-inline">json.NewDecoder</strong> accepts anything that satisfies the <strong class="source-inline">io.Reader{}</strong> interface. The caller code just needs to make sure whatever they pass satisfies the <span class="No-Break"><strong class="source-inline">io.Reader{}</strong></span><span class="No-Break"> interface:</span></p>
			<pre class="source-code">
p, err := loadPerson(strings.NewReader(s))</pre>			<p><strong class="source-inline">strings.NewReader</strong> returns a <strong class="source-inline">Reader</strong> type that has a <strong class="source-inline">Read(b []byte) (n int, err error)</strong> method that satisfies the <strong class="source-inline">io.Reader{}</strong> interface. It can be passed to our <strong class="source-inline">loadPerson()</strong> function. You may be thinking that each function still does what it was intended for. You would be correct, but let’s say the caller is no longer going to pass a string, or another<a id="_idIndexMarker594"/> caller will be passing a file that contains the <span class="No-Break">JSON data:</span></p>
			<pre class="source-code">
f, err := os.Open("data.json")
if err != nil {
  fmt.Println(err)
}</pre>			<p>Our <strong class="source-inline">loadPerson2()</strong> function would not work; however, our <strong class="source-inline">loadPerson()</strong> data would work because the return type from <strong class="source-inline">os.Open()</strong> satisfies the <span class="No-Break"><strong class="source-inline">io.Reader{}</strong></span><span class="No-Break"> interface.</span></p>
			<p>Say, for instance, the data will be coming through an HTTP endpoint. We will be getting the data from <strong class="source-inline">*http.Request</strong>. Again, the <strong class="source-inline">loadPerson2()</strong> function would not be a good choice. We would get the data from <strong class="source-inline">request.Body</strong>, which just so happens to implement the <span class="No-Break"><strong class="source-inline">io.Reader{}</strong></span><span class="No-Break"> interface.</span></p>
			<p>You may be wondering whether interfaces are good for input arguments. If so, why would we not return them too? If you return an interface, it adds unnecessary difficulty for the user. The user will have to look up the interface to then find the method set and the method <span class="No-Break">set’s signature:</span></p>
			<pre class="source-code">
func someFunc() Speaker{} {
  // code
}</pre>			<p>You would need to look at the definition of the <strong class="source-inline">Speaker{}</strong> interface and then spend time looking at the implementation code, all of which is unnecessary for the user of the function. If an interface is needed from the return type of the function, the user of the function can create the interface for that concrete type and use it in <span class="No-Break">their code.</span></p>
			<p>As you start to follow this Go proverb, check to see whether there is an interface in the Go standard packages. This will increase the number of different implementations that your function can provide. Our users of the <a id="_idIndexMarker595"/>function can have various implementations using <strong class="source-inline">strings.newReader</strong>, <strong class="source-inline">http.Request.Body</strong>, and <strong class="source-inline">os.File</strong>, just like in our code example, by using the <strong class="source-inline">io.Reader{}</strong> interfa<a id="_idTextAnchor1323"/><a id="_idTextAnchor1324"/>ce from the Go <span class="No-Break">standard packages.</span></p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor1325"/>Empty interface</h2>
			<p>An empty interface is an interface that has no method sets and no behaviors. An empty interface specifies <span class="No-Break">no methods:</span></p>
			<pre class="source-code">
interface{}</pre>			<p>This is a straightforward yet complex<a id="_idIndexMarker596"/> concept to wrap your head around. As you may recall, interfaces are implemented implicitly; there is no <strong class="source-inline">implements</strong> keyword. Since an empty interface specifies no methods, that means that every type in Go implements an empty interface automatically. All types satisfy the <span class="No-Break">empty interface.</span></p>
			<p>In the following code snippet, we will demonstrate how to use the empty interface. We will also see how a function that accepts an empty interface allows any type to be passed to <span class="No-Break">that function:</span></p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">main.go</p>
			<pre class="source-code">
package main
import "fmt"
type Speaker interface {
    Speak() string
}
type cat struct {
    name string
}</pre>			<p>The full code is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/01d1c9d340172a55335add4ad7adc285b7a51fe4/Chapter07/Example02/main.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/01d1c9d340172a55335add4ad7adc285b7a51fe4/Chapter07/Example02/main.go</span></a><span class="No-Break">.</span></p>
			<p>The expected output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
({oreo}, main.cat)
({oreo}, main.cat)
(99, int)
(false, bool)
(test, string)</pre>			<p>Let’s evaluate the code <span class="No-Break">in sections:</span></p>
			<pre class="source-code">
func emptyDetails(s interface{}) {
  fmt.Printf("(%v, %T)\n", i, i)
}</pre>			<p>The function accepts an empty <strong class="source-inline">interface{}</strong>. Any type can be passed to the function since all types implement<a id="_idIndexMarker597"/> the empty <strong class="source-inline">interface{}</strong>. It prints the value and the concrete type. The <strong class="source-inline">%v</strong> verb prints the value and the <strong class="source-inline">%T</strong> verb prints the <span class="No-Break">concrete type:</span></p>
			<pre class="source-code">
func main() {
  c := cat{name: "oreo"}
  i := 99
  b := false
  str := "test"
  catDetails(c)
  emptyDetails(c)
  emptyDetails(i)
  emptyDetails(b)
  emptyDetails(str)
}</pre>			<p>We pass a <strong class="source-inline">cat</strong> type, <strong class="source-inline">integer</strong>, <strong class="source-inline">bool</strong>, and <strong class="source-inline">string</strong>. The <strong class="source-inline">emptyDetails()</strong> function will print each <span class="No-Break">of them:</span></p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B18621_07_09.jpg" alt="Figure 7.9: The cat type implements an empty interface{} and the Speaker interface" width="505" height="160"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9: The cat type implements an empty interface{} and the Speaker interface</p>
			<p>The <strong class="source-inline">cat</strong> type implements the empty <strong class="source-inline">interface{}</strong> and the <strong class="source-inline">Speaker{}</strong> <span class="No-Break">interface implicitly.</span></p>
			<p>Now that we have a basic<a id="_idIndexMarker598"/> understanding of empty interfaces, we will be looking at various use cases for them in the upcoming topics, including <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">Type switching</span></li>
				<li><span class="No-Break">Typ<a id="_idTextAnchor1326"/><a id="_idTextAnchor1327"/>e assertion</span></li>
				<li>Examples of <span class="No-Break">Go packages</span></li>
			</ul>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor1328"/>Type assertion and switches</h2>
			<p>Type assertion provides access to an<a id="_idIndexMarker599"/> interface’s concrete type. Remember that <strong class="source-inline">interface{}</strong> can be <span class="No-Break">any value:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
)
func main() {
  var str interface{} = "some string"
  var i interface{} = 42
  var b interface{} = true
  fmt.Println(str)
  fmt.Println(i)
  fmt.Println(b)
}</pre>			<p>The type assertion output <a id="_idIndexMarker600"/>would look <span class="No-Break">as follows:</span></p>
			<pre class="console">
some string
42
true</pre>			<p>In each instance of the variable declaration, each variable is declared as an empty interface, but the concrete value for <strong class="source-inline">str</strong> is a string, for <strong class="source-inline">i</strong> is an integer, and for <strong class="source-inline">b</strong> is <span class="No-Break">a Boolean.</span></p>
			<p>When there is an empty <strong class="source-inline">interface{}</strong> type, sometimes, it is beneficial to know the underlying concrete type. For instance, you may need to perform data manipulation based on that type. If that type is a string, you would perform data modification and validation differently from how you would if it was an integer value. This also comes into play when you are consuming JSON data of an unknown schema. The values in that JSON might be known during the ingesting process. We would need to convert that data to <strong class="source-inline">map[string]interface{}</strong> and perform various data massaging, or transformation of the data based on its underlying type or structure. We have an activity later in this chapter that will show us how to perform such an action. We could perform a type conversion with the <span class="No-Break"><strong class="source-inline">strconv</strong></span><span class="No-Break"> package:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
  "strconv"
)
func main() {
  var str interface{} = "some string"
  var i interface{} = 42
  fmt.Println(strconv.Atoi(i))
}</pre>			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B18621_07_10.jpg" alt="Figure 7.10: Error when type assertion is needed" width="909" height="29"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10: Error when type assertion is needed</p>
			<p>So, it appears we cannot use type <a id="_idIndexMarker601"/>conversion because the types are not compatible with type conversion. We will need to use <span class="No-Break">type assertion:</span></p>
			<pre class="source-code">
v := s.(T)</pre>			<p>The preceding statement says that it asserts that the interface value <strong class="source-inline">s</strong> is of type <strong class="source-inline">T</strong> and assigns the underlying value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">v</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B18621_07_11.jpg" alt="Figure 7.11: Type assertion flow" width="568" height="95"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11: Type assertion flow</p>
			<p>Consider the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
  "strings"
)
func main() {
  var str interface{} = "some string"
  v := str.(string)
  fmt.Println(strings.Title(v))
}</pre>			<p>Let’s examine the <span class="No-Break">preceding code:</span></p>
			<ul>
				<li>The preceding code asserts that <strong class="source-inline">str</strong> is of the <strong class="source-inline">string</strong> type and assigns it to the <span class="No-Break">variable </span><span class="No-Break"><strong class="source-inline">v</strong></span></li>
				<li>Since <strong class="source-inline">v</strong> is a <strong class="source-inline">string</strong>, it will print it with <span class="No-Break">title casing</span></li>
			</ul>
			<p>The result is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Some String</pre>			<p>It is good when the assertion<a id="_idIndexMarker602"/> matches the expected type. So, what will happen if <strong class="source-inline">s</strong> is not of type <strong class="source-inline">T</strong>? Let’s take <span class="No-Break">a look:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
  "strings"
)
func main() {
  var str interface{} = 49
  v := str.(string)
  fmt.Println(strings.Title(v))
}</pre>			<p>Let’s examine the <span class="No-Break">preceding code:</span></p>
			<ul>
				<li><strong class="source-inline">str{}</strong> is an empty interface and the concrete type <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">int</strong></span></li>
				<li>The type assertion is checking whether <strong class="source-inline">str</strong> is of the string type, but in this scenario, it is not, so the code <span class="No-Break">will panic</span></li>
				<li>The result is <span class="No-Break">as follows:</span></li>
			</ul>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B18621_07_12.jpg" alt="Figure 7.12: Failed type assertion" width="508" height="95"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12: Failed type assertion</p>
			<p>Having a panic being thrown is not desirable. However, Go has a way to check whether <strong class="source-inline">str</strong> is <span class="No-Break">a string:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
)
func main() {
  var str interface{} = "the book club"
  v, isValid := str.(int)
  fmt.Println(v, isValid)
}</pre>			<p>Let’s examine the <span class="No-Break">preceding code:</span></p>
			<ul>
				<li>A type assertion returns<a id="_idIndexMarker603"/> two values, the underlying value and a <span class="No-Break">Boolean value.</span></li>
				<li><strong class="source-inline">isValid</strong> is assigned to a return type of <strong class="source-inline">bool</strong>. If it returns <strong class="source-inline">true</strong>, that indicates that <strong class="source-inline">str</strong> is of the <strong class="source-inline">int</strong> type. It means that the assertion is true. We can use the Boolean that was returned to determine what action we can take <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">str</strong></span><span class="No-Break">.</span></li>
				<li>When the assertion fails, it will return <strong class="source-inline">false</strong>. The return value will be the zero value that you are trying to assert to. It also will <span class="No-Break">not panic.</span></li>
			</ul>
			<p>There will be times when you do not know the empty interface concrete type. This is when you will use a type switch. A type switch can <a id="_idIndexMarker604"/>perform several types of assertions; it is similar to a regular switch statement. It has a case and default clauses. The difference is that type switch statements evaluate for a type rather than <span class="No-Break">a value.</span></p>
			<p>Here is a basic <span class="No-Break">syntax structure:</span></p>
			<pre class="source-code">
switch v := i.(type) {
case S:
  // code to act upon the type S
}</pre>			<p>Let’s examine the <span class="No-Break">preceding code:</span></p>
			<pre class="source-code">
i.(type)</pre>			<p>The syntax is like that of the type assertion, <strong class="source-inline">i.(int)</strong>, except the specified type, <strong class="source-inline">int</strong> in our example, is replaced with the <strong class="source-inline">type</strong> keyword. The type being asserted of type <strong class="source-inline">i</strong> is assigned to <strong class="source-inline">v</strong>; then, it is compared to each of the <span class="No-Break"><strong class="source-inline">case</strong></span><span class="No-Break"> statements:</span></p>
			<pre class="source-code">
case S:</pre>			<p>In the <strong class="source-inline">switch</strong> type, the statements <a id="_idIndexMarker605"/>evaluate for types. In regular switching, they evaluate for values. Here, it is evaluated for a type <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">S</strong></span><span class="No-Break">.</span></p>
			<p>Now that we have a fundamental understanding of the type switch statement, let’s look at an example that uses the syntax we have <span class="No-Break">just evaluated:</span></p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">main.go</p>
			<pre class="source-code">
func typeExample(i []interface{}) {
    for _, x := range i {
    switch v := x.(type) {
        case int:
            fmt.Printf("%v is int\n", v)
        case string:
            fmt.Printf("%v is a string\n", v)
        case bool:
            fmt.Printf("a bool %v\n", v)
        default:
            fmt.Printf("Unknown type %T\n", v)
        }
    }
}</pre>			<p>The full code is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Example03/main.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Example03/main.go</span></a><span class="No-Break">.</span></p>
			<p>Let’s now explore the code <span class="No-Break">in pieces:</span></p>
			<pre class="source-code">
func main() {
  c := cat{name: "oreo"}
  i := []interface{}{42, "The book club", true, c}
  typeExample(i)
}</pre>			<p>In the <strong class="source-inline">main()</strong> function, we are initializing a <a id="_idIndexMarker606"/>variable, <strong class="source-inline">i</strong>, to a slice of interfaces. In the slice, we have the <strong class="source-inline">int</strong>, <strong class="source-inline">string</strong>, <strong class="source-inline">bool</strong>, and <span class="No-Break"><strong class="source-inline">cat</strong></span><span class="No-Break"> types:</span></p>
			<pre class="source-code">
func typeExample(i []interface{})</pre>			<p>The function accepts a slice <span class="No-Break">of interfaces:</span></p>
			<pre class="source-code">
  for _, x := range i {
    switch v := x.(type) {
      case int:
        fmt.Printf("%v is int\n", v)
      case string:
        fmt.Printf("%v is a string\n", v)
      case bool:
        fmt.Printf("a bool %v\n", v)
      default:
        fmt.Printf("Unknown type %T\n", v)
    }
  }</pre>			<p>The <strong class="source-inline">for</strong> loop ranges over the slice of interfaces. The first value in the slice is <strong class="source-inline">42</strong>. The <strong class="source-inline">switch</strong> case asserts that the slice value of <strong class="source-inline">42</strong> is an <strong class="source-inline">int</strong> type. The <strong class="source-inline">case int</strong> statement will evaluate to <strong class="source-inline">true</strong> and print that <strong class="source-inline">42</strong> is <strong class="source-inline">int</strong>. When the <strong class="source-inline">for</strong> loop iterates over the last value of the <strong class="source-inline">cat</strong> type, the <strong class="source-inline">switch</strong> statement will not find that type in its case evaluations. Since <a id="_idIndexMarker607"/>there is no <strong class="source-inline">cat</strong> type being checked for in the <strong class="source-inline">case</strong> statements, the default will execute its <strong class="source-inline">print</strong> statement. Here are the results of the code <span class="No-Break">being executed:</span></p>
			<pre class="console">
42 is int
The book club is<a id="_idTextAnchor1329"/><a id="_idTextAnchor1330"/> string
a bool true
Unknown type main.cat</pre>			<h2 id="_idParaDest-242"><a id="_idTextAnchor1331"/>Exercise 7.03 – analyzing empty interface{} data</h2>
			<p>In this exercise, we are given a map. The map’s key is a string and its value is an empty <strong class="source-inline">interface{}</strong>. The map’s value <a id="_idIndexMarker608"/>contains different types of data stored in the value portion of the map. Our job is to determine each key’s value type. We are going to write a program that will analyze the data of <strong class="source-inline">map[string]</strong> <strong class="source-inline">interface{}</strong>. Understand that the values of the data can be of any type. We need to write logic to catch types we are not looking for. We are going to store that information in a slice of structs that will hold the key name, data, and the type <span class="No-Break">of data:</span></p>
			<ol>
				<li>Create a new file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></li>
				<li>Inside the file, we will have a <strong class="source-inline">main</strong> package and will need to import the <span class="No-Break"><strong class="source-inline">fmt</strong></span><span class="No-Break"> package:</span><pre class="source-code">
package main
import (
  "fmt"
)</pre></li>				<li>We will create a struct called <strong class="source-inline">record</strong> that will store the key, type of value, and data from <strong class="source-inline">map[string]interface{}</strong>. This struct is used to store the analysis that we are performing on the map. The <strong class="source-inline">key</strong> field is the name of the map key. The <strong class="source-inline">valueType</strong> field stores the type of data stored as a value in the map. The <strong class="source-inline">data</strong> field stores the data we are analyzing. It is an empty <strong class="source-inline">interface{}</strong>, since there can be various types of data in <span class="No-Break">the map:</span><pre class="source-code">
type record struct {
  key string
  valueType string
  data interface{}
}</pre></li>				<li>We will create a <strong class="source-inline">person</strong> struct that will be added to <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">map[string]interface{}</strong></span><span class="No-Break">:</span><pre class="source-code">
type person struct {
  lastName string
  age int
  isMarried bool
}</pre></li>				<li>We will create an <strong class="source-inline">animal</strong> struct that <a id="_idIndexMarker609"/>will be added to <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">map[string]interface{}</strong></span><span class="No-Break">:</span><pre class="source-code">
type animal struct {
  name string
  category string
}</pre></li>				<li>Create a <strong class="source-inline">newRecord()</strong> function. The <strong class="source-inline">key</strong> parameter will be our map’s key. The function also takes <strong class="source-inline">interface{}</strong> as an input parameter. <strong class="source-inline">i</strong> will be our map’s value for the key that is passed to the function. It will return a <span class="No-Break"><strong class="source-inline">record</strong></span><span class="No-Break"> type:</span><pre class="source-code">
func newRecord(key string, i interface{}) record {</pre></li>				<li>Inside the <strong class="source-inline">newRecord()</strong> function, we initialize <strong class="source-inline">record{}</strong> and assign it to the <strong class="source-inline">r</strong> variable. We then assign <strong class="source-inline">r.key</strong> to the key <span class="No-Break">input parameter.</span></li>
				<li>The <strong class="source-inline">switch</strong> statement assigns the type of <strong class="source-inline">i</strong> to the <strong class="source-inline">v</strong> variable. The <strong class="source-inline">v</strong> variable type gets evaluated against <a id="_idIndexMarker610"/>a series of <strong class="source-inline">case</strong> statements. If a type evaluates to <strong class="source-inline">true</strong> for one of the <strong class="source-inline">case</strong> statements, then the <strong class="source-inline">valueType</strong> record gets assigned to that type, along with the value of <strong class="source-inline">v</strong> to <strong class="source-inline">r.data</strong>, and then returns the <span class="No-Break"><strong class="source-inline">record</strong></span><span class="No-Break"> type:</span><pre class="source-code">
  r := record{}
  r.key = key
  switch v := i.(type) {
  case int:
    r.valueType = "int"
    r.data = v  case bool:
    r.valueType = "bool"
    r.data = v  case string:
    r.valueType = "string"
    r.data = v  case person:
    r.valueType = "person"</pre></li>				<li>The <strong class="source-inline">r.data = vA default</strong> statement is needed for the <strong class="source-inline">switch</strong> statement. If the type of <strong class="source-inline">v</strong> does not get evaluated to <strong class="source-inline">true</strong> in the <strong class="source-inline">case</strong> statements, then <strong class="source-inline">default</strong> will be executed. <strong class="source-inline">record.valueType</strong> will be marked <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">unknown</strong></span><span class="No-Break">:</span><pre class="source-code">
  default:
    r.valueType = "unknown"
    r.data = v  }
    return r
}</pre></li>				<li>Inside the <strong class="source-inline">main()</strong> function, we will initialize our map. The map is initialized to a string for the key and an <a id="_idIndexMarker611"/>empty interface for the value. We then assign <strong class="source-inline">a</strong> to an <strong class="source-inline">animal</strong> struct literal and <strong class="source-inline">p</strong> to a <strong class="source-inline">person</strong> struct literal. Then, we start adding various key-value pairs to <span class="No-Break">the map:</span><pre class="source-code">
func main() {
  m := make(map[string]interface{})
  a := animal{name: "oreo", category: "cat"}
  p := person{lastName: "Doe", isMarried: false, age: 19}
  m["person"] = p
  m["animal"] = a
  m["age"] = 54
  m["isMarried"] = true
  m["lastName"] = "Smith"</pre></li>				<li>Next, we initialize a slice of <strong class="source-inline">record</strong>. We iterate over the map and add records <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">rs</strong></span><span class="No-Break">:</span><pre class="source-code">
  rs := []record{}
  for k, v := range m {
    r := newRecord(k, v)
    rs = append(rs, r)
  }</pre></li>				<li>Now, print out the record field values. We range over the slice of records and print each <span class="No-Break">record value:</span><pre class="source-code">
  for _, v := range rs {
    fmt.Println("Key: ", v.key)
    fmt.Println("Data: ", v.data)
    fmt.Println("Type: ", v.valueType)
    fmt.Println()
  }
}</pre></li>			</ol>
			<p>Iterating over maps may produce<a id="_idIndexMarker612"/> output in different orders. A<a id="_idTextAnchor1332"/>n example of the expected output is <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B18621_07_13.jpg" alt="Figure 7.13: Output for the exercise" width="209" height="324"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13: Output for the exercise</p>
			<p>The exercise has demonstrated Go’s ability to identify the underlying type of an empty interface. As you can see from the results, our type switch was able to identify each type except for the value of the key of <strong class="source-inline">animal</strong>. It has its type marked as <strong class="source-inline">unknown</strong>. Also, it was even able to identify the <strong class="source-inline">person</strong> struct type, and<a id="_idTextAnchor1333"/><a id="_idTextAnchor1334"/> the data has the field values of <span class="No-Break">the struct.</span></p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor1335"/>Activity 7.01 – calculating pay and performance review</h2>
			<p>In this activity, we are going to <a id="_idIndexMarker613"/>calculate the annual pay for a manager and a developer. We will print out the developer’s and manager’s names and their pay for the year. The developer pay will be based on an hourly rate. The developer type will also keep track of the number of hours they have worked in a year. The developer type will also include their review. The review will need to be a collection of keys of strings. These strings are the categories that the developer is being reviewed on, for example, work quality, teamwork, <span class="No-Break">and communication.</span></p>
			<p>The aim of this activity is to use an interface to demonstrate polymorphism by calling a single function called <strong class="source-inline">payDetails()</strong> that accepts an interface. This <strong class="source-inline">payDetails()</strong> function will print the salary information for a developer type and a <span class="No-Break">manager type.</span></p>
			<p>The following steps should help you with <span class="No-Break">the solution:</span></p>
			<ol>
				<li>Create an <strong class="source-inline">Employee</strong> type that has <strong class="source-inline">Id</strong>, <strong class="source-inline">FirstName</strong>, and <span class="No-Break"><strong class="source-inline">LastName</strong></span><span class="No-Break"> fields.</span></li>
				<li>Create a <strong class="source-inline">Developer</strong> type that has the following fields: <strong class="source-inline">Individual</strong> of the <strong class="source-inline">Employee</strong> type and <strong class="source-inline">HourlyRate</strong>, <strong class="source-inline">HoursWorkedInYear</strong>, and <strong class="source-inline">Review</strong> of the <span class="No-Break"><strong class="source-inline">map[string]interface{}</strong></span><span class="No-Break"> type.</span></li>
				<li>Create a <strong class="source-inline">Manager</strong> type with the following fields: <strong class="source-inline">Individual</strong> of the <strong class="source-inline">Employee</strong> type, <strong class="source-inline">Salary</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">CommissionRate</strong></span><span class="No-Break">.</span></li>
				<li>Create a <strong class="source-inline">Payer</strong> interface that has a <strong class="source-inline">Pay()</strong> method that returns a string <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">float64</strong></span><span class="No-Break">.</span></li>
				<li>The <strong class="source-inline">Developer</strong> type should implement the <strong class="source-inline">Payer{}</strong> interface by returning the <strong class="source-inline">Developer</strong> name and returning the developer year pay based on the calculation of <strong class="source-inline">Developer.HourlyRate * </strong><span class="No-Break"><strong class="source-inline">Developer.HoursWorkInYear</strong></span><span class="No-Break">.</span></li>
				<li>The <strong class="source-inline">Manager</strong> type should implement the <strong class="source-inline">Payer{}</strong> interface by returning the <strong class="source-inline">Manager</strong> name and returning the <strong class="source-inline">Manager</strong> year pay based on the calculation of <strong class="source-inline">Manager.Salary</strong> + (<strong class="source-inline">Manager.Salary * </strong><span class="No-Break"><strong class="source-inline">Manager.CommissionRate</strong></span><span class="No-Break">).</span></li>
				<li>Add a function called <strong class="source-inline">payDetails</strong> (<strong class="source-inline">p Payer</strong>) that accepts a <strong class="source-inline">Payer</strong> interface and prints <strong class="source-inline">fullName</strong> and the pay that is returned from the <span class="No-Break"><strong class="source-inline">Pay()</strong></span><span class="No-Break"> method.</span></li>
				<li>We now need to calculate the review rating for a developer. <strong class="source-inline">Review</strong> is obtained by <strong class="source-inline">map[string]interface{}</strong>. The key of the map is a string; it is what the developer is being rated on, such as work quality, teamwork, <span class="No-Break">and skills.</span></li>
				<li>The empty <strong class="source-inline">interface{}</strong> of the map<a id="_idIndexMarker614"/> is needed because some managers give the rating as a string and others as a number. Here is the mapping of the string to <span class="No-Break">the integer:</span><pre class="source-code">
"Excellent" – 5
"Good" – 4
"Fair" – 3
"Poor" – 2
"Unsatisfactory" – 1</pre></li>				<li>We need to calculate the performance review value as a <strong class="source-inline">float</strong> type. It is the sum of the map <strong class="source-inline">interface{}</strong> divided by the length of the map. Take into consideration that the rating can be a string or an integer, so you will need to be able to accept both and convert it into <span class="No-Break">a float.</span></li>
			</ol>
			<p>The expected output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Eric Davis got a review rating of 2.80
Eric Davis got paid 84000.00 for the year
Mr. Boss got paid 160500.00 for the year</pre>			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found in the GitHub repository folder for this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter07/Activity7.01"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter07/Activity7.01</span></a><span class="No-Break">.</span></p>
			<p>In this activity, we saw the benefits of using an empty interface that allows us to accept any type of data. We then <a id="_idIndexMarker615"/>used type assertion and type switch statements to perform certain tasks based on the underlying concrete type of the <span class="No-Break">empty interface.</span></p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor1336"/>any</h2>
			<p>The <strong class="source-inline">any</strong> keyword as of <strong class="bold">Go 1.18</strong> is basically an alias<a id="_idIndexMarker616"/> to <strong class="source-inline">interface{}</strong>. With the <strong class="source-inline">any</strong> type definition, Go has replaced all references to<a id="_idIndexMarker617"/> the empty interface. However, it is important to note <a id="_idTextAnchor1337"/><a id="_idTextAnchor1338"/>that they are<a id="_idTextAnchor1339"/> interchangeable, being <span class="No-Break">type aliases.</span></p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor1340"/>Summary</h1>
			<p>This chapter presented some fundamental and advanced topics when using interfaces. We learned that Go’s implementation of interfaces has some similarities with other languages; for example, an interface does not contain the implementation details of the behaviors it is representing, and an interface is the blueprint of the methods. The different types that implement the interface can differ in their implementation details. However, Go differs in how you implement an interface compared to other languages. We learned that the implementation is done implicitly and not explicitly like in <span class="No-Break">other languages.</span></p>
			<p>This concludes that Go does not do subclassing; so, for it to implement polymorphism, it uses interfaces. It allows an interface type to appear in different forms, such as a <strong class="source-inline">Shape</strong> interface appearing as a rectangle, square, <span class="No-Break">or circle.</span></p>
			<p>We also discussed a design pattern of accepting interfaces and returning structs. We demonstrated that this pattern allows for broader uses by other callers. We examined the empty interface and saw how it can be used when you do not know the type being passed or when there could be multiple different types being passed to your API. Even though we did not know the type at runtime, we showed you how to use type assertion and type switching to determine the type. We also saw updates regarding the <strong class="source-inline">any</strong> keyword being a type alias to the empty interface. The knowledge and practice of these various tools will help you build robust and <span class="No-Break">fluid programs.</span></p>
			<p>In the following chapter, we will look at more Go 1.18 updates regarding generics, and how that allows developers to use code for more than one type <span class="No-Break">of variable!</span></p>
		</div>
	</div></div></body></html>