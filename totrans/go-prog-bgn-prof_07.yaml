- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter aims to demonstrate the implementation of interfaces in Go. It
    is quite simple compared to other languages because it is done implicitly in Go,
    whereas other languages require interfaces to be implemented explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: In the beginning, you will be able to define and declare an interface for an
    application and implement an interface in your applications. This chapter introduces
    you to using duck typing and polymorphism, accepting interfaces, and returning
    structs.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to use type assertion
    to access your interface’s underlying concrete value and use the type switch statement.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you''ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter07](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed error handling in Go. We looked at what
    an error is in Go; it is anything that implements the error interface. At the
    time, we did not investigate what an interface was. In this chapter, we are going
    to look at what an interface is.
  prefs: []
  type: TYPE_NORMAL
- en: For example, your manager requests that you create an API that can accept JSON
    data. The data contains information about various employees, such as their address
    and the hours they worked on a project. The data will need to be parsed into an
    `employee` struct, a relatively simple task. You then create a function called
    `loadEmployee(s string)`. The function will accept a string that is formatted
    as JSON, and then parse that string to load the `employee` struct.
  prefs: []
  type: TYPE_NORMAL
- en: Your manager is happy with the work; however, they have another requirement.
    The clients need the ability to accept a file with the employee data in JSON format.
    The functionality to be performed is the same underlying task as before. You create
    another function called `loadEmployeeFromFile(f *os.File)` that reads the data
    from the file, parses the data, and loads the `employee` struct.
  prefs: []
  type: TYPE_NORMAL
- en: Your manager has yet another requirement that the employee data should now also
    come from an HTTP endpoint. You will need to be able to read the data from the
    HTTP request, so you create another function called `loadEmployeeFromHTTP(r *Request)`.
  prefs: []
  type: TYPE_NORMAL
- en: All three functions that were written have a common behavior that they are performing.
    They all need to be able to read the data. The underlying type could be different
    (such as `string`, `os.File`, or `http.Request`) but the behavior, or reading
    the data, is the same in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: The `func loadEmployee(s string)`, `func loadEmployeeFromFile(f *os.File)`,
    and `func loadEmployeeFromHTTP(r *Request)` functions can all be replaced using
    an interface, `func loadEmployee (r io.Reader)`. `io.Reader` is an interface,
    and we will discuss it in more depth later in the chapter, but for now, it is
    enough to say it can be used to solve the given problem.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how interfaces can solve such a problem; by defining
    the behavior that is being performed as an interface type, we can accept any underlying
    concrete type. Don’t worry if that does not make sense right now; it will start
    to become clearer as we progress in this chapter. We will discuss how interfaces
    give us the ability to perform duck typing and polymorphism. We will see how accepting
    interfaces and returning structs will decrease coupling and increase the use of
    functions in more areas of our programs. We will also examine the empty interface
    and discuss use cases to fully utilize it, along with type assertion and type
    switch statements.
  prefs: []
  type: TYPE_NORMAL
- en: Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interface is a set of methods that describe the behavior of the data type.
    Interfaces define the behavior(s) of the type that must be satisfied to implement
    that interface. A behavior describes what that type can do. Almost everything
    exhibits certain behavior. For example, a cat can meow, walk, jump, and purr.
    All of those are behaviors of a cat. A car can start, stop, turn, and speed up.
    All of those are behaviors of a car. Similarly, behaviors for types are called
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The definition that the official documentation provides is *Interfaces in Go
    provide a way to specify the behavior of an object.*  ([https://go.dev/doc/effective_go#interfaces_and_types](https://go.dev/doc/effective_go#interfaces_and_types))
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to describe an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A collection of method signatures is methods with only the name of the method,
    its arguments, types, and a return type. This is an example of a collection of
    method signatures for the `Speaker{}` interface:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Blueprints of the type’s methods are needed to satisfy the interface. Using
    the `Speaker{}` interface, the blueprint (interface) states that to satisfy the
    `Speaker{}` interface, the type must have a `Speak()` method that accepts a string
    and returns a string. It also must have a `Greet()` method that returns a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Behaviors are what the interface type must exhibit. For example, the `Reader{}`
    interface has a `Read` method. Its behavior is the reading of data. The following
    code is from the Go standard library’s `Reader{}` interface:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Interfaces can be described as having no implementation details. When defining
    an interface, such as the `Reader{}` interface, it only contains the method signatures
    without the actual code implementation. The responsibility for supplying the code
    or implementation details lies with the type that implements the interface, not
    the interfaces themselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behaviors of a type are collectively called method sets, which are collections
    of methods associated with that type. A method set encompasses the names of methods
    defined by an interface, along with any input parameters and return types. For
    example, a type may exhibit behaviors such as `Read()`, `Write()`, and `Save()`.
    These behaviors collectively form the method sets of the type, providing a clear
    definition of what actions or functionalities the type can perform.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the reasoning behind the selection of these behaviors
    and the type’s characteristics should be clearly documented. Understanding why
    a type has specific behaviors adds context to the design decisions and enhances
    overall code comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: Graphical representation of interface elements](img/B18621_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Graphical representation of interface elements'
  prefs: []
  type: TYPE_NORMAL
- en: When talking about behaviors, note that we did not discuss the implementation
    details. Implementation details are omitted when you define an interface. It is
    important to understand that no implementation is specified or enforced in the
    declaration of an interface. Each type that we create that implements an interface
    can have its own implementation details. An interface that has a method called
    `Greeting()` can be implemented in different ways by various types. A struct type
    of `person` can implement `Greeting()` in a different way than a struct type of
    `animal`.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces focus on the behaviors that the type must exhibit. It is not the
    job of the interface to provide method implementations. That is the job of the
    type that is implementing the interface. The types, usually a struct, contain
    the implementation details of the method sets. Now that we have a basic understanding
    of an interface, in the next topic, we will be looking at how to define an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Defining an interface involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Defining an interface](img/B18621_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Defining an interface'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of declaring an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at each part of this declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the `type` keyword, followed by the name, and then the `interface`
    keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are defining an interface type called `Speaker{}`. It is idiomatic in Go
    to name the interface with an `er` suffix. If it is a one-method interface, it
    is typical to name the interface after that one method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, you define the method set. Defining an interface type specifies the method(s)
    that belong to it. In this interface, we are declaring an interface type that
    has one method called `Speak()` and it returns a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method set of the `Speaker{}` interface is `Speak()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an interface that is used frequently in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the parts of this code:'
  prefs: []
  type: TYPE_NORMAL
- en: The interface name is `Reader{}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method set is `Read()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The signature of the `Read()` method is `(p []byte)(n int,` `err error)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interfaces can have more than one method as its method set. Let’s look at an
    interface used in the Go package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `FileInfo{}` has multiple methods.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, interfaces are types that declare method sets. Similar to other
    languages that utilize interfaces, they do not implement the method sets. Implementation
    details are not part of defining an interface. In the next topic, we will be looking
    at what Go requires for you to be able to implement the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Interfaces in other programming languages implement an interface explicitly.
    Explicit implementation means that the programming language directly and clearly
    states that this object is using this interface. For example, this is in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code segment explicitly states that the `Dog` class will implement the `Pet`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Go, interfaces are implemented implicitly. This means that a type will implement
    the interface by having all the methods and the signature of the interface. Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break this code down into parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We are defining a `Speaker{}` interface. It has one method that describes the
    `Speak()` behavior. The method returns a string. For a type to implement the `Speaker{}`
    interface, it must have the method listed in the interface declaration. Then,
    we create an empty struct type called `cat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `cat` type has a `Speak()` method that returns the string. This satisfies
    the `Speaker{}` interface. It is now the responsibility of the implementer of
    `cat` to provide the implementation details for the `cat` type’s `Speak()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there was no explicit statement that declares `cat` implements the
    `Speaker{}` interface; it does so by just having met the requirements of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to notice that the `cat` type has a method called `Greeting()`.
    The type can have methods that are not needed to satisfy the `Speaker{}` interface.
    However, the `cat` must have at least the required method sets to be able to satisfy
    the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Advantages of implementing interfaces implicitly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some advantages to implementing interfaces implicitly. We have seen
    that when you create an interface, you have to go to each type and explicitly
    state that the type implements the interface. In Go, the type that satisfies the
    interface is said to implement it. There is no `implements` keyword like in other
    languages; you do not need to say that a type implements the interface. In Go,
    if it has the method sets and signatures of the interface, it implicitly implements
    the interface.
  prefs: []
  type: TYPE_NORMAL
- en: When you change the method sets of an interface, in other languages you would
    have to go to all those types that did not satisfy the interface and remove the
    explicit declaration for the type. This is not the case in Go, since it is an
    implicit declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage is you can use interfaces for types that are in another package.
    This decouples the definition of an interface from its implementation. We will
    discuss packages and their scope in [*Chapter 10*](B18621_10.xhtml#_idTextAnchor1405),
    *Packages Keep* *Projects Manageable*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of using an interface from a different package in
    our main package. The `Stringer` interface is an interface that is in the Go language.
    It is used by several packages through the Go language. One example is the `fmt`
    package, which is used for formatting when printing values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`Stringer` is an interface that is a type that can describe itself as a string.
    Interface names typically follow the method name but with the addition of the
    `er` suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down this code into parts:'
  prefs: []
  type: TYPE_NORMAL
- en: We have added a `String()` method to our `cat` type. It returns the field data
    for `name` and `age`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we call the `fmt.Println()` method in `main()` with the argument of `cat`,
    `fmt.Println()` calls the `String()` method on the `cat` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `cat` type now implements two interfaces: the `Speaker{}` interface and
    the `Stringer{}` interface. It has the methods required to satisfy both of those
    interfaces:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.3: Types can implement multiple interfaces](img/B18621_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Types can implement multiple interfaces'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.01 – implementing an interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to create a simple program that demonstrates
    how to implement interfaces implicitly. We will have a `person` struct that will
    implicitly implement the `Speaker{}` interface. The `person` struct will contain
    `name`, `age`, and `isMarried` as its fields. The program will call the `Speak()`
    method of our `person` struct and display a message displaying the `person` struct’s
    `name`. The `person` struct will also satisfy the requirements for the `Stringer{}`
    interface by having a `String()` method. You may recall previously, in the *Advantages
    of implementing interfaces implicitly* section, that the `Stringer{}` interface
    is an interface that is in the Go language. It can be used for formatting when
    printing values. That is how we are going to use it in this exercise to format
    the printing of the fields of the `person` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file and save it as `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will have `package` `main` and will be using the `fmt` package in this program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Speaker{}` interface with a method called `Speak()` that returns
    a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have created a `Speaker{}` interface. Any type that wants to implement our
    `Speaker{}` interface must have a `Speak()` method that returns a string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create our `person` struct with `name`, `age`, and `isMarried` as its fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `person` type contains `name`, `age`, and `isMarried` fields. We will later
    print the contents of these fields in our `main` function using a `Speak()` method
    that returns a string. Having a `Speak()` method will satisfy the `Speaker{}`
    interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `main()` function, we will initialize a `person` type, print the `Speak()`
    method, and print the `person` field values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `String()` method for `person` and return a string value. This will
    satisfy the `Stringer{}` interface, which will now allow it to be called by the
    `fmt.Println()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Speak()` method for `person` that returns a string. The `person`
    type has a `Speak()` method that has the same signature as the `Speak()` method
    of the `Speaker{}` interface. The `person` type satisfies the `Speaker{}` interface
    by having a `Speak()` method that returns the string. To satisfy interfaces, you
    must have the same methods and method signatures of the interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the terminal and navigate to the code’s directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go` `build main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Correct any errors that are returned and ensure your code matches the code snippet
    here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the executable by typing the executable name in the command line with the
    `./``main` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we saw how simple it is to implement interfaces implicitly.
    In the next topic, we will build on this by having different data types, such
    as structs, implement the same interface, which can be passed to any function
    that has the argument of that type of interface. We will go into greater detail
    about how that is possible in the next topic and see why it is a benefit for a
    type to appear in various forms.
  prefs: []
  type: TYPE_NORMAL
- en: Duck typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have been basically doing what is called duck typing. Duck typing is a test
    in computer programming: *If it looks like a duck, swims like a duck, and quacks
    like a duck, then it must be a duck.* If a type matches an interface, then you
    can use that type wherever that interface is used. Duck typing is matching a type
    based upon methods, rather than the expected type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Anything that matches the `Speak()` method can be a `Speaker{}` interface.
    When implementing an interface, we are essentially conforming to that interface
    by having the required method sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`cat` matches the `Speak()` method of the `Speaker{}` interface, so a `cat`
    is a `Speaker{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s examine this code in parts:'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we declare a `cat` type and create a method for the `cat`
    type called `Speak()`. This fulfills the required method sets for the `Speaker{}`
    interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create a method called `chatter` that takes the `Speaker{}` interface as
    an argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `main()` function, we are able to pass a `cat` type into the `chatter`
    function, which can evaluate to the `Speaker{}` interface. This satisfies the
    required method sets for the interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Polymorphism is the ability to appear in various forms. For example, a shape
    can appear as a square, circle, rectangle, or any other shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Polymorphism example for shape](img/B18621_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Polymorphism example for shape'
  prefs: []
  type: TYPE_NORMAL
- en: Go does not do subclassing like other object-oriented languages because Go does
    not have classes. Subclassing in object-oriented programming is inheriting from
    one class to another. By doing subclassing, you are inheriting the fields and
    methods of another class. Go provides a similar behavior through embedding structs
    and by using polymorphism through interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of using polymorphism is that it allows the reuse of methods
    that have been written once and tested. Code is reused by having an `int`, `float`,
    and `bool`, only that concrete type can be passed. However, if your API accepts
    an interface, then the caller can add the required method sets to satisfy that
    interface regardless of the underlying type. This reusability is accomplished
    by allowing your APIs to accept interfaces. Any type that satisfies the interface
    can be passed to the API. We have seen this type of behavior in a previous example.
    This is a good time to take a closer look at the `Speaker{}` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen in previous examples, each concrete type can implement one
    or more interfaces. Recall that our `Speaker{}` interface can be implemented by
    a `dog`, `cat`, or `person` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: The Speaker interface implemented by multiple types](img/B18621_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: The Speaker interface implemented by multiple types'
  prefs: []
  type: TYPE_NORMAL
- en: When a function accepts an interface as an input parameter, any concrete type
    that implements that interface can be passed as an argument. Now, you have achieved
    polymorphism by being able to pass various concrete types to a method or function
    that has an interface type as an input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some progressive examples that will enable us to demonstrate
    how polymorphism is achieved in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s examine the code in parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cat` satisfies the `Speaker{}` interface. The `main()` function calls `catSpeak()`
    and takes a type of `cat`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside `catSpeak()`, it prints out the results of its `Speak()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are going to implement some code that takes a concrete type (`cat`, `dog`,
    or `person`) and satisfies the `Speaker{}` interface type. Using the previous
    coding pattern, it would look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at this code in parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We have three concrete types (`cat`, `dog`, and `person`). The `cat` and `dog`
    types are empty structs, while the `person` struct has a `name` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of our types implicitly implements the `Speaker{}` interface. Each of
    the concrete types implements it differently from the others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main()` function, we call `catSpeak()`, `dogSpeak()`, and `personSpeak()`
    to invoke their respective `Speak()` methods. The preceding code has a lot of
    redundant functions that perform similar actions. We can refactor this code to
    be simpler and easier to read. We will use some of the features you get with implementing
    interfaces to provide a more concise implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the code in parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `saySomething()` function is using a variadic parameter. If you recall,
    a variadic parameter can accept zero or more arguments for that type. For more
    information on variadic functions, review [*Chapter 5*](B18621_05.xhtml#_idTextAnchor1048),
    *Reduce, Reuse, and Recycle*. The parameter type is `Speaker`. An interface can
    be used as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We range over the slice of `Speaker`. For each `Speaker` type, we call the `Speak()`
    method. In our code, we passed the `cat` and `dog` struct types to the `person`
    function. The function accepts an argument as an interface of `Speaker{}`. Any
    of the methods that make up that interface can be invoked. For each of those concrete
    types, the `Speak()` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: Multiple types implementing the Speaker interface](img/B18621_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Multiple types implementing the Speaker interface'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` function, we will see polymorphism being demonstrated through
    the use of interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We implement each of the concrete types, `cat`, `dog`, and `person`. The `cat`,
    `dog`, and `person` types all satisfy the `Speaker{}` interface. Since they match
    an interface, you can use that type wherever that interface is used. As you can
    see, this also includes being able to pass the `cat`, `dog`, and `person` types
    into a method.
  prefs: []
  type: TYPE_NORMAL
- en: Through the use of interfaces and polymorphism, this code is more concise than
    the previous code snippets. The example at the beginning of the chapter showed
    a single concrete type that satisfied the `Speaker{}` interface that invoked the
    `Speak()` method. We then added a few more concrete types to our running example
    (`cat`, `dog`, and `person`), each of these separately invoking their own `Speak()`
    method. We noticed redundant code in that example and started looking for a better
    way to implement the solution. We discovered that interface types can be parameter
    input types. Through duck typing and polymorphism, our third and final code snippet
    was able to have a single function that would call the `Speak()` method on each
    type that satisfied the `Speaker()` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 7.02 – calculating the area of different shapes using polymorphism
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be implementing a program that will calculate the area of a triangle,
    rectangle, and square. The program will use a single function that accepts a `Shape`
    interface. Any type that satisfies the `Shape` interface can be passed as an argument
    to the function. This function should then print the area and the name of the
    shape:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file and save it as `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will have a package called `main`, and we will be using the `fmt` package
    in this program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `Shape{}` interface, which has two method sets called `Area() float64`
    and `Name() string`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will create `triangle`, `rectangle`, and `square` struct types. These
    types will each satisfy the `Shape{}` interface. `triangle`, `rectangle`, and
    `square` have appropriate fields that are needed to calculate the area of the
    shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create the `Area()` and `Name()` methods for the `triangle` struct type.
    The area of a triangle is *base * height/2*. The `Name()` method returns the name
    of the shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create the `Area()` and `Name()` methods for the `rectangle` struct type.
    The area of a rectangle is `length * width`. The `Name()` method returns the name
    of the shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create the `Area()` and `Name()` methods for the `square` struct type. The
    area of a square is `side * side`. The `Name()` method returns the name of the
    shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, each of our shapes (`triangle`, `rectangle`, and `square`) satisfies the
    `Shape` interface because they each have an `Area()` and `Name()` method with
    the appropriate signatures:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.7: square, triangle, and rectangle areas of the Shape type](img/B18621_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: square, triangle, and rectangle areas of the Shape type'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create a function that accepts the `Shape` interface as a variadic
    parameter. The function will iterate over the `Shape` type and execute each of
    its `Name()` and `Area()` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main()` function, set the fields for `triangle`, `rectangle`, and
    `square`. Pass all three to the `printShapeDetail()` function. All three can be
    passed because they each satisfy the `Shape` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the program by running `go build` at the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Correct any errors that are returned and ensure your code matches the code snippet
    here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the executable by typing the name of the executable and hit *Enter* to
    run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we saw the flexibility and the reusable code that interfaces
    provide to our programs. Further, we will discuss how accepting interfaces and
    returning structs for our functions and methods increase code reusability and
    low coupling by not being dependent on the concrete types. When we use interfaces
    as input arguments to an API, we are stating that a type needs to satisfy the
    interface. When using concrete types, we require that the argument for the API
    must be of that type. For instance, if a function signature is `func greeting(msg
    string)`, we know that the argument being passed must be a string. Concrete types
    can be thought of as types that are not abstract (`float64`, `int`, `string`,
    and so on); however, interfaces could be considered an abstract type because you
    are satisfying the method sets of the interface type. The underlying interface
    type is a concrete type, but the underlying type is not what needs to be passed
    into the API. The type must meet the requirements of having the method sets that
    the interface type defines.
  prefs: []
  type: TYPE_NORMAL
- en: In the future, if we require another type to be passed, this will mean the code
    upstream to our API will need to change, or if the caller of our API needs to
    change its data type, it might request we change our API to accommodate it. If
    we use interfaces, this is not an issue; the caller of our code needs to satisfy
    the interface’s method sets. The caller can then change the underlying type if
    it complies with the interface requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting interfaces and returning structs
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a Go proverb that states, *Accept interfaces, return structs*. It
    can be restated as accept interfaces and return concrete types. This proverb is
    talking about accepting interfaces for your APIs (functions, methods, and so on)
    and the return to be structs or concrete types. This proverb follows Postel’s
    Law, which states, *Be conservative with what you do, be liberal with what you
    accept*. We are focusing on the *be liberal with what you accept* part. By accepting
    interfaces, you are increasing the flexibility of the API for your functi0on or
    method. By doing this, you are allowing for the user of the API to meet the requirements
    of the interface, but not forcing the user to use a concrete type. If our functions
    or methods only accept concrete types, then we are limiting the users of our functions
    to a specific implementation. In this chapter, we are going to explore the previously
    mentioned Go proverb and learn why it is a good design pattern to follow. We will
    see that as we go over the code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8: Benefits of accepting interfaces](img/B18621_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Benefits of accepting interfaces'
  prefs: []
  type: TYPE_NORMAL
- en: The following example will illustrate the benefits of accepting interfaces versus
    using concrete types. We will have two functions that perform the same task of
    decoding JSON, but each has different inputs. One of these functions is superior
    to the other, and we will go over the reasons why that is the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: main.go
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The full code is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Example01/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Example01/main.go).
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s examine each part of this code. We will discuss some parts of the code
    in the upcoming chapters. This code decodes some data into a struct. There are
    two functions being used for that purpose, `loadPerson2()` and `loadPerson()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The `loadPerson2()` function accepts an argument that is a concrete string
    and returns a struct. The returning of the struct meets half of *Accept interfaces,
    return structs*. However, it is very limited and not liberal in what it accepts.
    This limits the user of the function to a narrow implementation. The only thing
    that can ever be passed is a string. Granted, in some cases that might be acceptable,
    but in other situations, it could be a problem. For example, if your function
    or method should only accept a specific data type, then you may not want to accept
    interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we are accepting the `io.Reader{}` interface. The `io.Reader{}`
    ([https://pkg.go.dev/io#Reader](https://pkg.go.dev/io#Reader)) and `io.Writer{}`
    ([https://pkg.go.dev/io#Writer](https://pkg.go.dev/io#Writer)) interfaces are
    among the most utilized interfaces in Go packages. `json.NewDecoder` accepts anything
    that satisfies the `io.Reader{}` interface. The caller code just needs to make
    sure whatever they pass satisfies the `io.Reader{}` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`strings.NewReader` returns a `Reader` type that has a `Read(b []byte) (n int,
    err error)` method that satisfies the `io.Reader{}` interface. It can be passed
    to our `loadPerson()` function. You may be thinking that each function still does
    what it was intended for. You would be correct, but let’s say the caller is no
    longer going to pass a string, or another caller will be passing a file that contains
    the JSON data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Our `loadPerson2()` function would not work; however, our `loadPerson()` data
    would work because the return type from `os.Open()` satisfies the `io.Reader{}`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Say, for instance, the data will be coming through an HTTP endpoint. We will
    be getting the data from `*http.Request`. Again, the `loadPerson2()` function
    would not be a good choice. We would get the data from `request.Body`, which just
    so happens to implement the `io.Reader{}` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be wondering whether interfaces are good for input arguments. If so,
    why would we not return them too? If you return an interface, it adds unnecessary
    difficulty for the user. The user will have to look up the interface to then find
    the method set and the method set’s signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You would need to look at the definition of the `Speaker{}` interface and then
    spend time looking at the implementation code, all of which is unnecessary for
    the user of the function. If an interface is needed from the return type of the
    function, the user of the function can create the interface for that concrete
    type and use it in their code.
  prefs: []
  type: TYPE_NORMAL
- en: As you start to follow this Go proverb, check to see whether there is an interface
    in the Go standard packages. This will increase the number of different implementations
    that your function can provide. Our users of the function can have various implementations
    using `strings.newReader`, `http.Request.Body`, and `os.File`, just like in our
    code example, by using the `io.Reader{}` interface from the Go standard packages.
  prefs: []
  type: TYPE_NORMAL
- en: Empty interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An empty interface is an interface that has no method sets and no behaviors.
    An empty interface specifies no methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This is a straightforward yet complex concept to wrap your head around. As you
    may recall, interfaces are implemented implicitly; there is no `implements` keyword.
    Since an empty interface specifies no methods, that means that every type in Go
    implements an empty interface automatically. All types satisfy the empty interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we will demonstrate how to use the empty interface.
    We will also see how a function that accepts an empty interface allows any type
    to be passed to that function:'
  prefs: []
  type: TYPE_NORMAL
- en: main.go
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The full code is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/01d1c9d340172a55335add4ad7adc285b7a51fe4/Chapter07/Example02/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/01d1c9d340172a55335add4ad7adc285b7a51fe4/Chapter07/Example02/main.go).
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s evaluate the code in sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The function accepts an empty `interface{}`. Any type can be passed to the
    function since all types implement the empty `interface{}`. It prints the value
    and the concrete type. The `%v` verb prints the value and the `%T` verb prints
    the concrete type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass a `cat` type, `integer`, `bool`, and `string`. The `emptyDetails()`
    function will print each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9: The cat type implements an empty interface{} and the Speaker
    interface](img/B18621_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: The cat type implements an empty interface{} and the Speaker interface'
  prefs: []
  type: TYPE_NORMAL
- en: The `cat` type implements the empty `interface{}` and the `Speaker{}` interface
    implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a basic understanding of empty interfaces, we will be looking
    at various use cases for them in the upcoming topics, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Type switching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type assertion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of Go packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type assertion and switches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type assertion provides access to an interface’s concrete type. Remember that
    `interface{}` can be any value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The type assertion output would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In each instance of the variable declaration, each variable is declared as an
    empty interface, but the concrete value for `str` is a string, for `i` is an integer,
    and for `b` is a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'When there is an empty `interface{}` type, sometimes, it is beneficial to know
    the underlying concrete type. For instance, you may need to perform data manipulation
    based on that type. If that type is a string, you would perform data modification
    and validation differently from how you would if it was an integer value. This
    also comes into play when you are consuming JSON data of an unknown schema. The
    values in that JSON might be known during the ingesting process. We would need
    to convert that data to `map[string]interface{}` and perform various data massaging,
    or transformation of the data based on its underlying type or structure. We have
    an activity later in this chapter that will show us how to perform such an action.
    We could perform a type conversion with the `strconv` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 7.10: Error when type assertion is needed](img/B18621_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: Error when type assertion is needed'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, it appears we cannot use type conversion because the types are not compatible
    with type conversion. We will need to use type assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding statement says that it asserts that the interface value `s` is
    of type `T` and assigns the underlying value of `v`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11: Type assertion flow](img/B18621_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: Type assertion flow'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s examine the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code asserts that `str` is of the `string` type and assigns it
    to the variable `v`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since `v` is a `string`, it will print it with title casing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'It is good when the assertion matches the expected type. So, what will happen
    if `s` is not of type `T`? Let’s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s examine the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`str{}` is an empty interface and the concrete type is `int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type assertion is checking whether `str` is of the string type, but in this
    scenario, it is not, so the code will panic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.12: Failed type assertion](img/B18621_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: Failed type assertion'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a panic being thrown is not desirable. However, Go has a way to check
    whether `str` is a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s examine the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: A type assertion returns two values, the underlying value and a Boolean value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isValid` is assigned to a return type of `bool`. If it returns `true`, that
    indicates that `str` is of the `int` type. It means that the assertion is true.
    We can use the Boolean that was returned to determine what action we can take
    on `str`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the assertion fails, it will return `false`. The return value will be the
    zero value that you are trying to assert to. It also will not panic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be times when you do not know the empty interface concrete type.
    This is when you will use a type switch. A type switch can perform several types
    of assertions; it is similar to a regular switch statement. It has a case and
    default clauses. The difference is that type switch statements evaluate for a
    type rather than a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a basic syntax structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s examine the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax is like that of the type assertion, `i.(int)`, except the specified
    type, `int` in our example, is replaced with the `type` keyword. The type being
    asserted of type `i` is assigned to `v`; then, it is compared to each of the `case`
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the `switch` type, the statements evaluate for types. In regular switching,
    they evaluate for values. Here, it is evaluated for a type of `S`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a fundamental understanding of the type switch statement,
    let’s look at an example that uses the syntax we have just evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: main.go
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The full code is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Example03/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Example03/main.go).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now explore the code in pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main()` function, we are initializing a variable, `i`, to a slice of
    interfaces. In the slice, we have the `int`, `string`, `bool`, and `cat` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The function accepts a slice of interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` loop ranges over the slice of interfaces. The first value in the
    slice is `42`. The `switch` case asserts that the slice value of `42` is an `int`
    type. The `case int` statement will evaluate to `true` and print that `42` is
    `int`. When the `for` loop iterates over the last value of the `cat` type, the
    `switch` statement will not find that type in its case evaluations. Since there
    is no `cat` type being checked for in the `case` statements, the default will
    execute its `print` statement. Here are the results of the code being executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 7.03 – analyzing empty interface{} data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are given a map. The map’s key is a string and its value
    is an empty `interface{}`. The map’s value contains different types of data stored
    in the value portion of the map. Our job is to determine each key’s value type.
    We are going to write a program that will analyze the data of `map[string]` `interface{}`.
    Understand that the values of the data can be of any type. We need to write logic
    to catch types we are not looking for. We are going to store that information
    in a slice of structs that will hold the key name, data, and the type of data:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the file, we will have a `main` package and will need to import the
    `fmt` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will create a struct called `record` that will store the key, type of value,
    and data from `map[string]interface{}`. This struct is used to store the analysis
    that we are performing on the map. The `key` field is the name of the map key.
    The `valueType` field stores the type of data stored as a value in the map. The
    `data` field stores the data we are analyzing. It is an empty `interface{}`, since
    there can be various types of data in the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will create a `person` struct that will be added to our `map[string]interface{}`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will create an `animal` struct that will be added to our `map[string]interface{}`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `newRecord()` function. The `key` parameter will be our map’s key.
    The function also takes `interface{}` as an input parameter. `i` will be our map’s
    value for the key that is passed to the function. It will return a `record` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `newRecord()` function, we initialize `record{}` and assign it to
    the `r` variable. We then assign `r.key` to the key input parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `switch` statement assigns the type of `i` to the `v` variable. The `v`
    variable type gets evaluated against a series of `case` statements. If a type
    evaluates to `true` for one of the `case` statements, then the `valueType` record
    gets assigned to that type, along with the value of `v` to `r.data`, and then
    returns the `record` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `r.data = vA default` statement is needed for the `switch` statement. If
    the type of `v` does not get evaluated to `true` in the `case` statements, then
    `default` will be executed. `record.valueType` will be marked as `unknown`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main()` function, we will initialize our map. The map is initialized
    to a string for the key and an empty interface for the value. We then assign `a`
    to an `animal` struct literal and `p` to a `person` struct literal. Then, we start
    adding various key-value pairs to the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we initialize a slice of `record`. We iterate over the map and add records
    to `rs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, print out the record field values. We range over the slice of records
    and print each record value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Iterating over maps may produce output in different orders. An example of the
    expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13: Output for the exercise](img/B18621_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: Output for the exercise'
  prefs: []
  type: TYPE_NORMAL
- en: The exercise has demonstrated Go’s ability to identify the underlying type of
    an empty interface. As you can see from the results, our type switch was able
    to identify each type except for the value of the key of `animal`. It has its
    type marked as `unknown`. Also, it was even able to identify the `person` struct
    type, and the data has the field values of the struct.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 7.01 – calculating pay and performance review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we are going to calculate the annual pay for a manager and
    a developer. We will print out the developer’s and manager’s names and their pay
    for the year. The developer pay will be based on an hourly rate. The developer
    type will also keep track of the number of hours they have worked in a year. The
    developer type will also include their review. The review will need to be a collection
    of keys of strings. These strings are the categories that the developer is being
    reviewed on, for example, work quality, teamwork, and communication.
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to use an interface to demonstrate polymorphism
    by calling a single function called `payDetails()` that accepts an interface.
    This `payDetails()` function will print the salary information for a developer
    type and a manager type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps should help you with the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `Employee` type that has `Id`, `FirstName`, and `LastName` fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `Developer` type that has the following fields: `Individual` of the
    `Employee` type and `HourlyRate`, `HoursWorkedInYear`, and `Review` of the `map[string]interface{}`
    type.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `Manager` type with the following fields: `Individual` of the `Employee`
    type, `Salary`, and `CommissionRate`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Payer` interface that has a `Pay()` method that returns a string and
    `float64`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Developer` type should implement the `Payer{}` interface by returning the
    `Developer` name and returning the developer year pay based on the calculation
    of `Developer.HourlyRate *` `Developer.HoursWorkInYear`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Manager` type should implement the `Payer{}` interface by returning the
    `Manager` name and returning the `Manager` year pay based on the calculation of
    `Manager.Salary` + (`Manager.Salary *` `Manager.CommissionRate`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a function called `payDetails` (`p Payer`) that accepts a `Payer` interface
    and prints `fullName` and the pay that is returned from the `Pay()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now need to calculate the review rating for a developer. `Review` is obtained
    by `map[string]interface{}`. The key of the map is a string; it is what the developer
    is being rated on, such as work quality, teamwork, and skills.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The empty `interface{}` of the map is needed because some managers give the
    rating as a string and others as a number. Here is the mapping of the string to
    the integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to calculate the performance review value as a `float` type. It is the
    sum of the map `interface{}` divided by the length of the map. Take into consideration
    that the rating can be a string or an integer, so you will need to be able to
    accept both and convert it into a float.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter07/Activity7.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter07/Activity7.01).'
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we saw the benefits of using an empty interface that allows
    us to accept any type of data. We then used type assertion and type switch statements
    to perform certain tasks based on the underlying concrete type of the empty interface.
  prefs: []
  type: TYPE_NORMAL
- en: any
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `any` keyword as of `interface{}`. With the `any` type definition, Go has
    replaced all references to the empty interface. However, it is important to note
    that they are interchangeable, being type aliases.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presented some fundamental and advanced topics when using interfaces.
    We learned that Go’s implementation of interfaces has some similarities with other
    languages; for example, an interface does not contain the implementation details
    of the behaviors it is representing, and an interface is the blueprint of the
    methods. The different types that implement the interface can differ in their
    implementation details. However, Go differs in how you implement an interface
    compared to other languages. We learned that the implementation is done implicitly
    and not explicitly like in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes that Go does not do subclassing; so, for it to implement polymorphism,
    it uses interfaces. It allows an interface type to appear in different forms,
    such as a `Shape` interface appearing as a rectangle, square, or circle.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed a design pattern of accepting interfaces and returning structs.
    We demonstrated that this pattern allows for broader uses by other callers. We
    examined the empty interface and saw how it can be used when you do not know the
    type being passed or when there could be multiple different types being passed
    to your API. Even though we did not know the type at runtime, we showed you how
    to use type assertion and type switching to determine the type. We also saw updates
    regarding the `any` keyword being a type alias to the empty interface. The knowledge
    and practice of these various tools will help you build robust and fluid programs.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will look at more Go 1.18 updates regarding generics,
    and how that allows developers to use code for more than one type of variable!
  prefs: []
  type: TYPE_NORMAL
