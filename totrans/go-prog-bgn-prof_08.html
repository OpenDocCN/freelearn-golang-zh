<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer109">
			<h1 id="_idParaDest-246" class="chapter-number"><a id="_idTextAnchor1341"/>8</h1>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor1342"/>Generic Algorithm Superpowers</h1>
			<p class="callout-heading"><a id="_idTextAnchor1343"/>Overview</p>
			<p class="callout">This chapter will discuss the versatility and expressive strength that Go’s type parameter syntax brings developers. As we explore this chapter, we’ll uncover the means to create algorithms that transcend the limitations of single variable types. By harnessing the power of type parameters, developers gain the ability to craft generic versions of their code, enabling it to seamlessly operate on multiple types. This chapter will highlight the overarching goal to reduce code duplication while preserving the robust safety intrinsic to Go’s strong <span class="No-Break">typing system.</span></p>
			<p class="callout">This chapter will also navigate the world of constraints, showcasing how Go fortifies generic algorithms against unintended mishaps, as well as help you understand when to use generic algorithms versus interfaces. Through practical examples and activities, you will grasp the art of designing generic algorithms and understand the superpowers of generic algorithms. By the end of the chapter, you will be equipped with a profound understanding of when, why, and how to wield the generic algorithm superpowers in Go. We’ll also cover some best practices and provide clarity on when to use interfaces <span class="No-Break">versus generics.</span></p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor1344"/>Technical requirements</h1>
			<p>For this chapter, you'll require Go version 1.21 or higher. The code for this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor1345"/>Introduction</h1>
			<p>The Go team at Google is always thinking about how to make the lives of Go developers easier and what tools, packages, and support we need for the future – always in a fully backward-compatible way. In this chapter, we will expand upon our knowledge gained so far and discuss <span class="No-Break">Go generics.</span></p>
			<p>Generics officially<a id="_idIndexMarker618"/> became a part of the language in Go version 1.18. Go generics provide a powerful means of developing code that removes duplication, simplifies readability, and enables developers a way to use multiple types within a function. However, with great power comes great responsibility. Let’s discuss <span class="No-Break">generics further.</span><a id="_idTextAnchor1346"/></p>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor1347"/>When to use generics?</h1>
			<p>The decision to finally<a id="_idIndexMarker619"/> incorporate generics into the Go programming language was not a trivial one. As they are such a large change to the language, it is important to remember our roots as developers and not to allow support such as generics to change <em class="italic">how</em> we write our code. In other words, you should continue writing normal Go code and not overly design types right from the get-go. These are fundamental Go philosophies rooted in simplicity and readability, which are the core tenets of <span class="No-Break">the language.</span></p>
			<p>The following is a synopsis of insights to consider when incorporating Go generics into a <span class="No-Break">code base:</span></p>
			<ul>
				<li><strong class="bold">Write normal Go code, and don’t design types</strong>: Start with your typical concrete types and <a id="_idIndexMarker620"/>straightforward functions, leveraging Go’s strong static typing and simplicity. Generics were never meant to replace the fundamental principles guiding the use of the language but, rather, be a tool to be <span class="No-Break">applied judiciously.</span></li>
				<li><strong class="bold">Avoid boilerplate code</strong>: This was one of the main motivating factors behind introducing generics to the language. When you find yourself writing repetitive and nearly identical code for different types, then it is a signal that generics can help streamline your implementation. Instead of duplicating logic for various data structures and types, you can create generic functions or types that work seamlessly with different types. This removes code redundancy and improves developer maintainability of <span class="No-Break">the logic.</span></li>
				<li><strong class="bold">Code complexity considerations</strong>: If your project involves intricate data structures or algorithms, generics can help abstract away the complexity and make your code more comprehensible. However, be cautious to not over-engineer; only introduce generics when they genuinely simplify <span class="No-Break">your code.</span></li>
				<li><strong class="bold">Enhance code flexibility</strong>: Generics allow functions and data structures to work with various types. If your code needs to accommodate diverse data types without sacrificing performance or safety, then generics can be a <span class="No-Break">valuable addition.</span></li>
				<li><strong class="bold">Future-proofing code</strong>: If you anticipate changes or expansion where introducing new types is<a id="_idIndexMarker621"/> likely, incorporating generics early on can future-proof your code and reduce the need for extensive refactoring down <span class="No-Break">the line.</span></li>
			</ul>
			<p>To take a look at what generics look like in action in Go, let’s first look at a regular implementation for <a id="_idIndexMarker622"/>a function, finding the maximum value for integer values passed into a function using a <span class="No-Break">naive approach:</span></p>
			<pre class="source-code">
package main
import "fmt"
func findMaxInt(nums []int) int {
    if len(nums) == 0 {
        return -1
    }
    max := nums[0]
    for _, num := range nums {
        if num &gt; max {
            max = num
        }
    }
    return max
}
func main() {
    max := findMaxInt([]int{1, 32, 5, 8, 10, 11})
    fmt.Printf("max integer value: %v\n", max)
}</pre>			<p>If we wanted to now find the maximum value for a different type of input, such as floating-point values, then we’d have to add a new function containing <span class="No-Break">duplicate logic:</span></p>
			<pre class="source-code">
func findMaxFloat(nums []float64) float64 {
    if len(nums) == 0 {
        return -1
    }
    max := nums[0]
    for _, num := range nums {
        if num &gt; max {
            max = num
        }
    }
    return max
}</pre>			<p>You can see how this is <a id="_idIndexMarker623"/>already repetitive. If we wanted to check for the max value for additional types, then so far, we’d have a lot of repeated logic. However, now we can take a look at how having a generic maximum function can be <span class="No-Break">beneficial here:</span></p>
			<pre class="source-code">
func findMaxGeneric[Num int | float64](nums []Num) Num {
    if len(nums) == 0 {
        return -1
    }
    max := nums[0]
    for _, num := range nums {
        if num &gt; max {
            max = num
        }
    }
    return max
}</pre>			<p>Albeit, this is a simple example to find a maximum, we’ve made progress by moving from expanded code to adding generics to it and removing code duplication, making for cleaner code. You can also see that the preceding function signature uses a different notation utilizing generics in Go that allows for integer input or float-point input to the function. Now, let’s introduce type parameters, a fundamental aspect of generics that helps developers <a id="_idIndexMarker624"/>enhance code clarity and maintainability, which will explain the different notations in the function signature on our preceding <span class="No-Break">generic fun<a id="_idTextAnchor1348"/><a id="_idTextAnchor1349"/><a id="_idTextAnchor1350"/>ction.</span></p>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor1351"/>Type parameters</h1>
			<p>Type parameters for<a id="_idIndexMarker625"/> Go functions give you the ability to parameterize a function with types that support generic input. It’s a way to specify to the compiler the types allowed when invoking a generic function and represents a placeholder for a type within a given function. Type parameter lists look like normal parameter lists but are encompassed by square brackets. For example, <strong class="source-inline">[T any]</strong> declares a <strong class="source-inline">T</strong> type parameter that can be any type. The <strong class="source-inline">any</strong> keyword was touched on in the <span class="No-Break">previous chapter.</span></p>
			<p>To continue to understand type parameters, let’s return to our maximum generic function signature from the earlier <span class="No-Break">example code:</span></p>
			<pre class="source-code">
func findMaxGeneric[Num int | float64](nums []Num) Num {</pre>			<p>This indicates that our function, titled <strong class="source-inline">findMaxGeneric</strong>, includes a type parameter, <strong class="source-inline">Num</strong>, that can be instantiated by an integer or float64 type. It will take in a slice of <strong class="source-inline">Num</strong> and return the resulting maximum integer or <span class="No-Break">float64 value.</span></p>
			<p>An interesting concept associated with type parameters is type sets. In the preceding example function signature, we discussed how <strong class="source-inline">Num</strong> can be instantiated by an integer or float64 type. This means that the type set for the <strong class="source-inline">Num</strong> type parameter is the union of integer and float64 types. So, our <strong class="source-inline">findMaxGeneric</strong> function may be called with those constrained allowed types for <strong class="source-inline">Num</strong>. Type constraints will be discussed further in <span class="No-Break">this chapter.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Type parameters are usually uppercase to emphasize that they are <span class="No-Break">indeed types.</span></p>
			<p>We can call the generic function and pass in our input with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
maxGenericInt := findMaxGeneric([]int{1, 32, 5, 8, 10, 11})</pre>			<p>The numbers we pass into the function are called our type arguments. Providing type arguments to a function is called instantiation. Instantiation is important in generics when you provide<a id="_idIndexMarker626"/> type arguments for type parameters. The type argument is the actual type that is provided or inferred when using generic functions. It is the concrete type that replaces the type parameter when the generic code is instantiated or <span class="No-Break">called upon.</span></p>
			<p>Furthermore, if we were to pass in an invalid type argument for our type parameter, then the Go compiler would complain. For example, if we tried to pass in string values, then we’d see <span class="No-Break">an error:</span></p>
			<pre class="console">
string does not satisfy int | float64 (string missing in int | float64)</pre>			<p>Our code did not compile properly, as the Go type system prevented us from passing in an invalid type argument for our <span class="No-Break">type pa<a id="_idTextAnchor1352"/>rameter.</span></p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor1353"/>Activity 8.01 – a minimum value</h2>
			<p>In this activity, we<a id="_idIndexMarker627"/> write a <a id="_idIndexMarker628"/>simple function to calculate a minimum value, where the input can be of the integer or <span class="No-Break">float64 type:</span></p>
			<ol>
				<li>Create a <strong class="source-inline">findMinGeneric</strong> function that calculates the minimum value of a slice <span class="No-Break">of input.</span><p class="list-inset">The input can only be of integer or <span class="No-Break">float64 type.</span></p></li>
				<li>Print the resulting minimum value for both integers and <span class="No-Break">floating-point values.</span></li>
			</ol>
			<p>For input using <strong class="source-inline">[]int{1, 32, 5, 8, 10, 11}</strong>, your output should look <span class="No-Break">like this:</span></p>
			<pre class="console">
min value: 1</pre>			<p>For input using <strong class="source-inline">[]float64{1.1, 32.1, 5.1, 8.1, 10.1, 11.1}</strong>, your output should look <span class="No-Break">like this:</span></p>
			<pre class="console">
min value: 1.1</pre>			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found in the GitHub repository folder for this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08/Activity08.01"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08/Activity08.01</span></a><span class="No-Break">.</span></p>
			<p>Type parameters are useful when working with functions that operate on slices, maps, and channels of any element type. Furthermore, when the function has parameters with those types and doesn’t make assumptions based on the element type, it can be generalized– for example, returning keys in any map type. This is also useful when working with general-purpose data structures such as linked lists or binary trees. Replacing an element type with a type parameter can provide a more general data structure that is far more reusable. You should not make use type parameters prematurely. Wait until you’re about to write boilerplate code. Premature abstractions can lead to unnecessary complexity and make code harder for others to understand. It is recommended to wait until you encounter a specific need for generic solutions, especially when faced with repetitive patterns or boilerplate code. This approach aligns well with Go’s philosophy of simplicity and incremental design, ensuring that the introduction of generics to a code base is purposeful <span class="No-Break">and justified.</span></p>
			<p>Now, let’s explore type constraints and how they give us a way to specify capabilities or properties that a<a id="_idIndexMarker629"/> type parameter must have, in <a id="_idIndexMarker630"/>order to be used with a <span class="No-Break">gener<a id="_idTextAnchor1354"/>ic function.</span></p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor1355"/>Type constraints</h1>
			<p>Type constraints <a id="_idIndexMarker631"/>are a sort of meta-type for the function type parameter. Type constraints dictate the allowed type arguments for any given type parameter of <span class="No-Break">a function.</span></p>
			<p>Type constraints in Go generics refer to interfaces that define sets of types. These interfaces play a powerful role in specifying the requirements or capabilities that a type parameter must satisfy when working with generic functions or types. To use these interfaces effectively, they must be placed in what is known as the “constraint position” within the syntax, specifically in the type parameter list where the type parameter <span class="No-Break">is declared.</span></p>
			<p>In this constraint position, when declaring a generic function or type, the constraints are expressed using an interface type to define the expected behavior of the type parameter. This ensures that the provided types adhere to the specified constraints, allowing the generic code to operate on them safely. By enforcing these constraints, the Go compiler can perform thorough type checking at compile time, enhancing code reliability <span class="No-Break">and maintainability.</span></p>
			<p>When dealing with more complex types, oftentimes you will declare constraints as an interface. The constraint allows any type that implements the interface to be used with the function. Constraint interfaces can refer to specific and more basic types. Using constraint interfaces can help pull out the type constraints into a more <span class="No-Break">readable form.</span></p>
			<p>Containing a distinct set of logic for constraints for the added generics in the Go programming<a id="_idIndexMarker632"/> language, a standard library package called <strong class="source-inline">constraints</strong> has been added experimentally that you can explore for more insights on defining constraints when working with <span class="No-Break">type parameters.</span></p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor1356"/>Exercise 8.01 – calculate the maximum value using interfaces</h2>
			<p>Let’s take a<a id="_idIndexMarker633"/> look at expanding our <a id="_idIndexMarker634"/>maximum logic from earlier into a<a id="_idIndexMarker635"/> more readable form, using interfaces for our type constraints. We will continue only allowing integer and float64 values <span class="No-Break">for now:</span></p>
			<ol>
				<li>Create a new folder and add a <span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break"> file.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the main package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Now, add the imports that we’ll use in <span class="No-Break">this file:</span><pre class="source-code">
import (
  "fmt"
)</pre></li>				<li>Create a <strong class="source-inline">Number</strong> interface that will represent the types of values we allow <span class="No-Break">as input:</span><pre class="source-code">
type Number interface {
    int | float64
}</pre></li>				<li>Create a function that takes a slice of numbers and returns the <span class="No-Break">maximum value:</span><pre class="source-code">
func findMaxGeneric[Num Number](nums []Num) Num {</pre></li>				<li>Ensure valid input by verifying that there are inputs passed into <span class="No-Break">the function:</span><pre class="source-code">
    if len(nums) == 0 {
        return -1
    }</pre></li>				<li>Get the first value to have a placeholder maximum value, before checking the <span class="No-Break">remaining values:</span><pre class="source-code">
    max := nums[0]</pre></li>				<li>Traverse <span class="No-Break">the numbers:</span><pre class="source-code">
    for _, num := range nums {</pre></li>				<li>Check whether the current number is greater than the placeholder maximum value, and reset the maximum to the current value <span class="No-Break">as needed:</span><pre class="source-code">
        if num &gt; max {
            max = num
        }</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">for</strong></span><span class="No-Break"> loop:</span><pre class="source-code">
    }</pre></li>				<li>Return <span class="No-Break">the maximum:</span><pre class="source-code">
    return max</pre></li>				<li>Close <span class="No-Break">the function:</span><pre class="source-code">
}</pre></li>				<li>Define the <span class="No-Break">main function:</span><pre class="source-code">
func main() {</pre></li>				<li>Call our<a id="_idIndexMarker636"/> function <a id="_idIndexMarker637"/>and <a id="_idIndexMarker638"/>print out the results for integer and <span class="No-Break">float64 input:</span><pre class="source-code">
    maxGenericInt := findMaxGeneric([]int{1, 32, 5, 8, 10, 11})
    fmt.Printf("max generic int: %v\n", maxGenericInt)
    maxGenericFloat := findMaxGeneric([]float64{1.1, 32.1, 5.1, 8.1, 10.1, 11.1})
    fmt.Printf("max generic float: %v\n", maxGenericFloat)</pre></li>				<li>Close the <span class="No-Break">main function:</span><pre class="source-code">
}</pre></li>			</ol>
			<p>Running the preceding code shows the <span class="No-Break">following output:</span></p>
			<pre class="console">
max generic int: 32
max generic float: 32.1</pre>			<p>We have now seen what it looks like to make our type constraint interface more readable, by defining a <strong class="source-inline">Number</strong> interface to find the maximum value. You can see the benefits of defining one function that can be used for integer and <span class="No-Break">float64 values.</span></p>
			<p>In the last chapter, we learned a lot about interfaces and how they define a set of methods that a type must implement. When working with generics, you can express constraints on the types that can be used as type parameters, by specifying that they must satisfy certain <span class="No-Break">interface requirements.</span></p>
			<p>For type parameters, you might see constraints such as <strong class="source-inline">comparable</strong> or custom interfaces <a id="_idIndexMarker639"/>that <a id="_idIndexMarker640"/>define specific methods. Let’s take a peek at <a id="_idIndexMarker641"/>leveraging a more complex example <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">comparable</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor1357"/>Exercise 8.02 – calculate the largest stock of items on a ranch</h2>
			<p>Let’s say that there<a id="_idIndexMarker642"/> is a ranch with different items in stock. We can use generics to calculate the largest stock of different items on <span class="No-Break">the ranch:</span></p>
			<ol>
				<li>Create a new folder and add a <span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break"> file.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the main package name at the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Now, add the imports that we’ll use in <span class="No-Break">this file:</span><pre class="source-code">
import (
  "fmt"
)</pre></li>				<li>Define the function to find the largest ranch stock <span class="No-Break">using generics:</span><pre class="source-code">
func FindLargestRanchStock[K comparable, V int | float64](m map[K]V) K {</pre></li>				<li>Define variables to save the largest stock found so far and the name of the <span class="No-Break">stocked item:</span><pre class="source-code">
    var stock V
    var name K</pre></li>				<li>Loop over the map, and if the new value found is greater than the largest stock at the time, then update the values to the largest and save the <span class="No-Break">item name:</span><pre class="source-code">
    for k, v := range m {
        if v &gt; stock {
            stock = v
            name = k
        }
    }</pre></li>				<li>Return the <a id="_idIndexMarker643"/>name of the item with the largest stock on <span class="No-Break">the ranch:</span><pre class="source-code">
    return name</pre></li>				<li>Close <span class="No-Break">the function:</span><pre class="source-code">
}</pre></li>				<li>Define the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Define our ranch items <span class="No-Break">in stock:</span><pre class="source-code">
    animalStock := map[string]int{
        "Chicken": 5,
        "Cattle": 20,
        "Horses": 4,
     }
    miscStock := map[string]float64{
        "Hay": 5.5,
        "Feed": 1.2,
        "Fertilizer": 4.5,
     }</pre></li>				<li>Call our function, and print out the results for the largest stocked items in <span class="No-Break">the ranch:</span><pre class="source-code">
    largestStockOnRanchInt := FindLargestRanchStock(animalStock)
    fmt.Printf("The largest stocked item on the ranch is %s\n", largestStockOnRanchInt)
    largestStockOnRanchFloat := FindLargestRanchStock(miscStock)
    fmt.Printf("The largest stocked item on the ranch is %s\n", largestStockOnRanchFloat)</pre></li>				<li>Close <a id="_idIndexMarker644"/>the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>			</ol>
			<p>Running the preceding code shows the <span class="No-Break">following output:</span></p>
			<pre class="console">
The largest stocked item on the ranch is Cattle
The largest stocked item on the ranch is Hay</pre>			<p>We’ve now seen a generics example using <strong class="source-inline">comparable</strong>. The constraint on our <strong class="source-inline">K</strong> type parameter in the function was <strong class="source-inline">comparable</strong>. This is thanks to the type of the commonly used constraint, enabled by helpers from Go using the <strong class="source-inline">comparable</strong> standard library. <strong class="source-inline">comparable</strong> allows any type whose value can be used as an operand of the comparison operators, such as <strong class="source-inline">==</strong> and <strong class="source-inline">!=</strong>. Go requires the keys of maps to be comparable, so the <strong class="source-inline">comparable</strong> declaration is necessary on our map key type to use <strong class="source-inline">K</strong> as the key in the ranch map. If we didn’t declare <strong class="source-inline">K</strong> to be <strong class="source-inline">comparable</strong>, then the Go compiler would reject the reference to <strong class="source-inline">map[K]V</strong> in our <span class="No-Break">function’s argument.</span></p>
			<p>As you can see, Go allows a very powerful form of interface type to express constraints. We can easily expand this example to work on even more complex interfaces <span class="No-Break">and constraints.</span></p>
			<p>It is noteworthy to mention that replacing an interface type with a type parameter can make the underlying storage of data more efficient. It can also mean that code can avoid type assertions and be fully type-checked at <span class="No-Break">compile time.</span></p>
			<p>Now that we’ve <a id="_idIndexMarker645"/>discussed type parameters and type constraints, let’s take a peek at what’s going on when <a id="_idTextAnchor1358"/>it comes to <span class="No-Break">type inference.</span></p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor1359"/>Type inference</h1>
			<p>The Go compiler infers <a id="_idIndexMarker646"/>the types we want to use from the function arguments. This is called type inference. The compiler will deduce type arguments from type <span class="No-Break">parameter constraints.</span></p>
			<p>Type inference either succeeds or fails. The compiler will complain, and we are provided the type arguments that need correcting upon finding an issue. Using generics is meant to be easy; however, the underlying details of type inference are highly complicated. It is also something the authors are iterating on <span class="No-Break">to improve.</span></p>
			<p>At this point, when it comes to calling generic functions, we’ve covered how you can specify type arguments in square brackets as type names. This allows the compiler to know to replace the type parameters within the function you’re invoking. However, you can omit the type arguments, as most of the time Go can infer them. However, it is not always possible to simplify your code by dropping type arguments. As the compiler runs your code, it replaces each type parameter with the <span class="No-Break">concrete types.</span></p>
			<p>A concrete example of this can be seen in many of our function signatures where we’ve allowed the compiler to infer our types. For example, in the last exercise, we discussed ranch item stocks. Our function signature in the code was <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
largestStockOnRanchInt := FindLargestRanchStock(animalStock)</pre>			<p>This invocation allows the compiler to infer the type of <strong class="source-inline">animalStock</strong>. However, it is also identical to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
largestStockOnRanchInt := FindLargestRanchStock[string, int](animalStock)</pre>			<p>Here, we explicitly state the types for our key and values getting passed in. There are a few scenarios where <a id="_idIndexMarker647"/>it may not be possible or advisable to rely on the compiler to infer types when working with <span class="No-Break">generic functions:</span></p>
			<ul>
				<li><strong class="bold">Ambiguous types</strong>: There may be multiple types that satisfy the constraints. For example, imagine you have a <strong class="source-inline">PrintType</strong> function that prints the type of a value. If you pass in a string, it should recognize it as a string; if you pass in an integer, it should recognize it as an integer. When calling this function, you explicitly state the types using <strong class="source-inline">PrintType("Hello")</strong>, <strong class="source-inline">PrintType(42)</strong>, <strong class="source-inline">PrintType(3.14)</strong>, and <span class="No-Break">so on.</span></li>
				<li><strong class="bold">Multiple type parameters</strong>: Consider a <strong class="source-inline">PrintTwoTypes</strong> function that takes two parameters of potentially different types. When calling this function, you might specify the types explicitly for various reasons. Then, <strong class="source-inline">PrintTwoTypes</strong> could be defined with an integer and string parameter and used as such – <span class="No-Break"><strong class="source-inline">PrintTwoTypes(42, "Hello)</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Chained calls</strong>: This is where types need to flow multiple calls. Envision a scenario where you have a function, <strong class="source-inline">ChainCalls</strong>, that processes a value and then calls another function, <strong class="source-inline">AnotherFunction</strong>. Here, you might explicitly state the types of chained calls to ensure a <span class="No-Break">smooth flow.</span></li>
			</ul>
			<p>You can also add explicit types to add clarity in complex scenarios or to enhance readability, reducing<a id="_idIndexMarker648"/> time spent debugging wh<a id="_idTextAnchor1360"/>en it comes to <span class="No-Break">type inference.</span></p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor1361"/>When to use generics versus interfaces</h1>
			<p>The question of<a id="_idIndexMarker649"/> when to use generics versus interfaces in Go often depends<a id="_idIndexMarker650"/> on the nature of the problem you’re solving and the specific requirements of <span class="No-Break">your code.</span></p>
			<p>Generics in Go allow you to write functions or data structures that can operate on a variety of types, without sacrificing type safety. With generics, you can create functions or structures that work with different types, without the need for code duplication and while maintaining compile-time <span class="No-Break">safety checks.</span></p>
			<p>Interfaces in Go define a set of method signatures. Any type that implements all the methods of an interface is said to satisfy the interface. Interfaces provide a way to achieve polymorphism in Go, enabling code to work with different types that share a common set of behaviors. Interfaces are technically a form of generic programming by allowing developers to capture common aspects of different types and express them as methods. This allows for not only a nice abstraction layer but also <span class="No-Break">duplicate logic.</span></p>
			<p>You should use interfaces when your work requires an abstraction layer that others may implement, or you have distinct behavior you want captured. Generics are good for maintaining compilation type safety in a statically typed language when writing type-agnostic <a id="_idIndexMarker651"/>functions <a id="_idIndexMarker652"/>and methods. Other considerations such as performance and optimizations benchmarking can be considered for different <span class="No-Break">use cases.</span></p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor1362"/>What are some best practices?</h1>
			<p>The following are a few<a id="_idIndexMarker653"/> best practices to consider when working with <span class="No-Break">generic code:</span></p>
			<ul>
				<li><strong class="bold">Use functions over methods</strong>: A method is a function associated with a type and is called with a receiver; therefore, a function in the context of generics is more flexible, as it is not tied to a specific type. This allows for easier reuse and the ability to compose functions with <span class="No-Break">different types.</span></li>
				<li><strong class="bold">Ease of transformation</strong>: It is easier to turn methods into functions than it is to add a function to a type. Functions can be defined independently of specific types. In the context of generics, you can use generic functions with any type that satisfies the required constraints. If it later makes sense to convert to a method, then you can do so without modifying the original function <span class="No-Break">more easily.</span></li>
				<li><strong class="bold">Prefer functions over constraints that require methods</strong>: Instead of defining constraints that specifically require a method on a type, prefer using functions that work with types that satisfy more general constraints, such as <strong class="source-inline">comparable</strong>. This allows flexibility in the future when working with type parameters and a broader range of types to be used with <span class="No-Break">the function.</span></li>
			</ul>
			<p>When working with generics in Go, it is also best to be mindful of the complexity that can be involved. They are a tool in our toolbelt to be used wisely and properly. By doing so, you can leverage <a id="_idIndexMarker654"/>the power of generics without compromising the simplicity and readability that<a id="_idTextAnchor1363"/><a id="_idTextAnchor1364"/> define the Go <span class="No-Break">programming language.</span></p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor1365"/>Summary</h1>
			<p>In this chapter, we explored the world of Go generics, a groundbreaking enhancement to the language that provides key features such as type parameters, constraints, and type inference. Type parameters, encapsulated within square brackets, emerged as versatile placeholders, enabling the creation of functions and data structures without prior knowledge of the specific types they are to interact with. The incorporation of constraints such as <strong class="source-inline">comparable</strong> bolstered type safety and clarity, ensures that the generic constructs adhere to specific rules or interfaces. Moreover, the compiler’s type inference unveiled a new era of concise and streamlined code, where developers can leverage static typing without the burden of explicit <span class="No-Break">type annotations.</span></p>
			<p>While Go generics is still being smoothened out and added to, it is a powerful addition that aims to empower developers to write efficient, reusable code with unprecedented ease. Now that we know how to write optimal and reusable code thanks to generics, we can look at expanding this knowledge in the next chapter. There, we will enhance our understanding by covering Go modules and seeing how to reuse code at a much larger scale and <span class="No-Break">collaborative effort.</span></p>
		</div>
	</div></div>
<div id="book-content"><div id="sbo-rt-content"><div id="_idContainer110" class="Content">
			<h1 id="_idParaDest-260" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor1366"/>Part 3: Modules</h1>
			<p>A module serves as a repository for reusable code utilized by various applications. Whether large or small, a module enables efficient code organization and enhances reusability. In this section, you’ll learn how to create and manage modules effectively, leveraging packages and external modules to streamline your <span class="No-Break">development process.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18621_09.xhtml#_idTextAnchor1367"><em class="italic">Chapter 9</em></a>, <em class="italic">Using Go Modules to Define a Project</em></li>
				<li><a href="B18621_10.xhtml#_idTextAnchor1405"><em class="italic">Chapter 10</em></a>, <em class="italic">Package Keep Projects Manageable</em></li>
				<li><a href="B18621_11.xhtml#_idTextAnchor1462"><em class="italic">Chapter 11</em></a>, <em class="italic">Bug-Busting Debugging Skills</em>,</li>
				<li><a href="B18621_12.xhtml#_idTextAnchor1532"><em class="italic">Chapter 12</em></a>, <em class="italic">About Time</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer111">
			</div>
		</div>
	</div></div></body></html>