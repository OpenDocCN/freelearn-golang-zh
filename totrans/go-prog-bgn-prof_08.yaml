- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generic Algorithm Superpowers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will discuss the versatility and expressive strength that Go’s
    type parameter syntax brings developers. As we explore this chapter, we’ll uncover
    the means to create algorithms that transcend the limitations of single variable
    types. By harnessing the power of type parameters, developers gain the ability
    to craft generic versions of their code, enabling it to seamlessly operate on
    multiple types. This chapter will highlight the overarching goal to reduce code
    duplication while preserving the robust safety intrinsic to Go’s strong typing
    system.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will also navigate the world of constraints, showcasing how Go
    fortifies generic algorithms against unintended mishaps, as well as help you understand
    when to use generic algorithms versus interfaces. Through practical examples and
    activities, you will grasp the art of designing generic algorithms and understand
    the superpowers of generic algorithms. By the end of the chapter, you will be
    equipped with a profound understanding of when, why, and how to wield the generic
    algorithm superpowers in Go. We’ll also cover some best practices and provide
    clarity on when to use interfaces versus generics.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you'll require Go version 1.21 or higher. The code for this
    chapter can be found at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go team at Google is always thinking about how to make the lives of Go developers
    easier and what tools, packages, and support we need for the future – always in
    a fully backward-compatible way. In this chapter, we will expand upon our knowledge
    gained so far and discuss Go generics.
  prefs: []
  type: TYPE_NORMAL
- en: Generics officially became a part of the language in Go version 1.18\. Go generics
    provide a powerful means of developing code that removes duplication, simplifies
    readability, and enables developers a way to use multiple types within a function.
    However, with great power comes great responsibility. Let’s discuss generics further.
  prefs: []
  type: TYPE_NORMAL
- en: When to use generics?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The decision to finally incorporate generics into the Go programming language
    was not a trivial one. As they are such a large change to the language, it is
    important to remember our roots as developers and not to allow support such as
    generics to change *how* we write our code. In other words, you should continue
    writing normal Go code and not overly design types right from the get-go. These
    are fundamental Go philosophies rooted in simplicity and readability, which are
    the core tenets of the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a synopsis of insights to consider when incorporating Go generics
    into a code base:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Write normal Go code, and don’t design types**: Start with your typical concrete
    types and straightforward functions, leveraging Go’s strong static typing and
    simplicity. Generics were never meant to replace the fundamental principles guiding
    the use of the language but, rather, be a tool to be applied judiciously.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid boilerplate code**: This was one of the main motivating factors behind
    introducing generics to the language. When you find yourself writing repetitive
    and nearly identical code for different types, then it is a signal that generics
    can help streamline your implementation. Instead of duplicating logic for various
    data structures and types, you can create generic functions or types that work
    seamlessly with different types. This removes code redundancy and improves developer
    maintainability of the logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code complexity considerations**: If your project involves intricate data
    structures or algorithms, generics can help abstract away the complexity and make
    your code more comprehensible. However, be cautious to not over-engineer; only
    introduce generics when they genuinely simplify your code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhance code flexibility**: Generics allow functions and data structures
    to work with various types. If your code needs to accommodate diverse data types
    without sacrificing performance or safety, then generics can be a valuable addition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Future-proofing code**: If you anticipate changes or expansion where introducing
    new types is likely, incorporating generics early on can future-proof your code
    and reduce the need for extensive refactoring down the line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To take a look at what generics look like in action in Go, let’s first look
    at a regular implementation for a function, finding the maximum value for integer
    values passed into a function using a naive approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to now find the maximum value for a different type of input, such
    as floating-point values, then we’d have to add a new function containing duplicate
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see how this is already repetitive. If we wanted to check for the max
    value for additional types, then so far, we’d have a lot of repeated logic. However,
    now we can take a look at how having a generic maximum function can be beneficial
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Albeit, this is a simple example to find a maximum, we’ve made progress by moving
    from expanded code to adding generics to it and removing code duplication, making
    for cleaner code. You can also see that the preceding function signature uses
    a different notation utilizing generics in Go that allows for integer input or
    float-point input to the function. Now, let’s introduce type parameters, a fundamental
    aspect of generics that helps developers enhance code clarity and maintainability,
    which will explain the different notations in the function signature on our preceding
    generic function.
  prefs: []
  type: TYPE_NORMAL
- en: Type parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type parameters for Go functions give you the ability to parameterize a function
    with types that support generic input. It’s a way to specify to the compiler the
    types allowed when invoking a generic function and represents a placeholder for
    a type within a given function. Type parameter lists look like normal parameter
    lists but are encompassed by square brackets. For example, `[T any]` declares
    a `T` type parameter that can be any type. The `any` keyword was touched on in
    the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue to understand type parameters, let’s return to our maximum generic
    function signature from the earlier example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that our function, titled `findMaxGeneric`, includes a type parameter,
    `Num`, that can be instantiated by an integer or float64 type. It will take in
    a slice of `Num` and return the resulting maximum integer or float64 value.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting concept associated with type parameters is type sets. In the
    preceding example function signature, we discussed how `Num` can be instantiated
    by an integer or float64 type. This means that the type set for the `Num` type
    parameter is the union of integer and float64 types. So, our `findMaxGeneric`
    function may be called with those constrained allowed types for `Num`. Type constraints
    will be discussed further in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Type parameters are usually uppercase to emphasize that they are indeed types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call the generic function and pass in our input with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The numbers we pass into the function are called our type arguments. Providing
    type arguments to a function is called instantiation. Instantiation is important
    in generics when you provide type arguments for type parameters. The type argument
    is the actual type that is provided or inferred when using generic functions.
    It is the concrete type that replaces the type parameter when the generic code
    is instantiated or called upon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, if we were to pass in an invalid type argument for our type parameter,
    then the Go compiler would complain. For example, if we tried to pass in string
    values, then we’d see an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Our code did not compile properly, as the Go type system prevented us from passing
    in an invalid type argument for our type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 8.01 – a minimum value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we write a simple function to calculate a minimum value,
    where the input can be of the integer or float64 type:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `findMinGeneric` function that calculates the minimum value of a slice
    of input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The input can only be of integer or float64 type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Print the resulting minimum value for both integers and floating-point values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For input using `[]int{1, 32, 5, 8, 10, 11}`, your output should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For input using `[]float64{1.1, 32.1, 5.1, 8.1, 10.1, 11.1}`, your output should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08/Activity08.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter08/Activity08.01).'
  prefs: []
  type: TYPE_NORMAL
- en: Type parameters are useful when working with functions that operate on slices,
    maps, and channels of any element type. Furthermore, when the function has parameters
    with those types and doesn’t make assumptions based on the element type, it can
    be generalized– for example, returning keys in any map type. This is also useful
    when working with general-purpose data structures such as linked lists or binary
    trees. Replacing an element type with a type parameter can provide a more general
    data structure that is far more reusable. You should not make use type parameters
    prematurely. Wait until you’re about to write boilerplate code. Premature abstractions
    can lead to unnecessary complexity and make code harder for others to understand.
    It is recommended to wait until you encounter a specific need for generic solutions,
    especially when faced with repetitive patterns or boilerplate code. This approach
    aligns well with Go’s philosophy of simplicity and incremental design, ensuring
    that the introduction of generics to a code base is purposeful and justified.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s explore type constraints and how they give us a way to specify capabilities
    or properties that a type parameter must have, in order to be used with a generic
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Type constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type constraints are a sort of meta-type for the function type parameter. Type
    constraints dictate the allowed type arguments for any given type parameter of
    a function.
  prefs: []
  type: TYPE_NORMAL
- en: Type constraints in Go generics refer to interfaces that define sets of types.
    These interfaces play a powerful role in specifying the requirements or capabilities
    that a type parameter must satisfy when working with generic functions or types.
    To use these interfaces effectively, they must be placed in what is known as the
    “constraint position” within the syntax, specifically in the type parameter list
    where the type parameter is declared.
  prefs: []
  type: TYPE_NORMAL
- en: In this constraint position, when declaring a generic function or type, the
    constraints are expressed using an interface type to define the expected behavior
    of the type parameter. This ensures that the provided types adhere to the specified
    constraints, allowing the generic code to operate on them safely. By enforcing
    these constraints, the Go compiler can perform thorough type checking at compile
    time, enhancing code reliability and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with more complex types, oftentimes you will declare constraints
    as an interface. The constraint allows any type that implements the interface
    to be used with the function. Constraint interfaces can refer to specific and
    more basic types. Using constraint interfaces can help pull out the type constraints
    into a more readable form.
  prefs: []
  type: TYPE_NORMAL
- en: Containing a distinct set of logic for constraints for the added generics in
    the Go programming language, a standard library package called `constraints` has
    been added experimentally that you can explore for more insights on defining constraints
    when working with type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.01 – calculate the maximum value using interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at expanding our maximum logic from earlier into a more readable
    form, using interfaces for our type constraints. We will continue only allowing
    integer and float64 values for now:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the main package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the imports that we’ll use in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Number` interface that will represent the types of values we allow
    as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that takes a slice of numbers and returns the maximum value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure valid input by verifying that there are inputs passed into the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the first value to have a placeholder maximum value, before checking the
    remaining values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Traverse the numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the current number is greater than the placeholder maximum value,
    and reset the maximum to the current value as needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `for` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return the maximum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the main function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call our function and print out the results for integer and float64 input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the main function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code shows the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have now seen what it looks like to make our type constraint interface more
    readable, by defining a `Number` interface to find the maximum value. You can
    see the benefits of defining one function that can be used for integer and float64
    values.
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, we learned a lot about interfaces and how they define a
    set of methods that a type must implement. When working with generics, you can
    express constraints on the types that can be used as type parameters, by specifying
    that they must satisfy certain interface requirements.
  prefs: []
  type: TYPE_NORMAL
- en: For type parameters, you might see constraints such as `comparable` or custom
    interfaces that define specific methods. Let’s take a peek at leveraging a more
    complex example using `comparable`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.02 – calculate the largest stock of items on a ranch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say that there is a ranch with different items in stock. We can use generics
    to calculate the largest stock of different items on the ranch:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the main package name at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the imports that we’ll use in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the function to find the largest ranch stock using generics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define variables to save the largest stock found so far and the name of the
    stocked item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop over the map, and if the new value found is greater than the largest stock
    at the time, then update the values to the largest and save the item name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return the name of the item with the largest stock on the ranch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define our ranch items in stock:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call our function, and print out the results for the largest stocked items
    in the ranch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code shows the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now seen a generics example using `comparable`. The constraint on our
    `K` type parameter in the function was `comparable`. This is thanks to the type
    of the commonly used constraint, enabled by helpers from Go using the `comparable`
    standard library. `comparable` allows any type whose value can be used as an operand
    of the comparison operators, such as `==` and `!=`. Go requires the keys of maps
    to be comparable, so the `comparable` declaration is necessary on our map key
    type to use `K` as the key in the ranch map. If we didn’t declare `K` to be `comparable`,
    then the Go compiler would reject the reference to `map[K]V` in our function’s
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Go allows a very powerful form of interface type to express
    constraints. We can easily expand this example to work on even more complex interfaces
    and constraints.
  prefs: []
  type: TYPE_NORMAL
- en: It is noteworthy to mention that replacing an interface type with a type parameter
    can make the underlying storage of data more efficient. It can also mean that
    code can avoid type assertions and be fully type-checked at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve discussed type parameters and type constraints, let’s take a
    peek at what’s going on when it comes to type inference.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go compiler infers the types we want to use from the function arguments.
    This is called type inference. The compiler will deduce type arguments from type
    parameter constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference either succeeds or fails. The compiler will complain, and we
    are provided the type arguments that need correcting upon finding an issue. Using
    generics is meant to be easy; however, the underlying details of type inference
    are highly complicated. It is also something the authors are iterating on to improve.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, when it comes to calling generic functions, we’ve covered how
    you can specify type arguments in square brackets as type names. This allows the
    compiler to know to replace the type parameters within the function you’re invoking.
    However, you can omit the type arguments, as most of the time Go can infer them.
    However, it is not always possible to simplify your code by dropping type arguments.
    As the compiler runs your code, it replaces each type parameter with the concrete
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'A concrete example of this can be seen in many of our function signatures where
    we’ve allowed the compiler to infer our types. For example, in the last exercise,
    we discussed ranch item stocks. Our function signature in the code was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This invocation allows the compiler to infer the type of `animalStock`. However,
    it is also identical to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we explicitly state the types for our key and values getting passed in.
    There are a few scenarios where it may not be possible or advisable to rely on
    the compiler to infer types when working with generic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PrintType` function that prints the type of a value. If you pass in a string,
    it should recognize it as a string; if you pass in an integer, it should recognize
    it as an integer. When calling this function, you explicitly state the types using
    `PrintType("Hello")`, `PrintType(42)`, `PrintType(3.14)`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PrintTwoTypes` function that takes two parameters of potentially different
    types. When calling this function, you might specify the types explicitly for
    various reasons. Then, `PrintTwoTypes` could be defined with an integer and string
    parameter and used as such – `PrintTwoTypes(42, "Hello)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChainCalls`, that processes a value and then calls another function, `AnotherFunction`.
    Here, you might explicitly state the types of chained calls to ensure a smooth
    flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also add explicit types to add clarity in complex scenarios or to enhance
    readability, reducing time spent debugging when it comes to type inference.
  prefs: []
  type: TYPE_NORMAL
- en: When to use generics versus interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The question of when to use generics versus interfaces in Go often depends on
    the nature of the problem you’re solving and the specific requirements of your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Generics in Go allow you to write functions or data structures that can operate
    on a variety of types, without sacrificing type safety. With generics, you can
    create functions or structures that work with different types, without the need
    for code duplication and while maintaining compile-time safety checks.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces in Go define a set of method signatures. Any type that implements
    all the methods of an interface is said to satisfy the interface. Interfaces provide
    a way to achieve polymorphism in Go, enabling code to work with different types
    that share a common set of behaviors. Interfaces are technically a form of generic
    programming by allowing developers to capture common aspects of different types
    and express them as methods. This allows for not only a nice abstraction layer
    but also duplicate logic.
  prefs: []
  type: TYPE_NORMAL
- en: You should use interfaces when your work requires an abstraction layer that
    others may implement, or you have distinct behavior you want captured. Generics
    are good for maintaining compilation type safety in a statically typed language
    when writing type-agnostic functions and methods. Other considerations such as
    performance and optimizations benchmarking can be considered for different use
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: What are some best practices?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are a few best practices to consider when working with generic
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use functions over methods**: A method is a function associated with a type
    and is called with a receiver; therefore, a function in the context of generics
    is more flexible, as it is not tied to a specific type. This allows for easier
    reuse and the ability to compose functions with different types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ease of transformation**: It is easier to turn methods into functions than
    it is to add a function to a type. Functions can be defined independently of specific
    types. In the context of generics, you can use generic functions with any type
    that satisfies the required constraints. If it later makes sense to convert to
    a method, then you can do so without modifying the original function more easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comparable`. This allows flexibility in the future when working with type
    parameters and a broader range of types to be used with the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working with generics in Go, it is also best to be mindful of the complexity
    that can be involved. They are a tool in our toolbelt to be used wisely and properly.
    By doing so, you can leverage the power of generics without compromising the simplicity
    and readability that define the Go programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the world of Go generics, a groundbreaking enhancement
    to the language that provides key features such as type parameters, constraints,
    and type inference. Type parameters, encapsulated within square brackets, emerged
    as versatile placeholders, enabling the creation of functions and data structures
    without prior knowledge of the specific types they are to interact with. The incorporation
    of constraints such as `comparable` bolstered type safety and clarity, ensures
    that the generic constructs adhere to specific rules or interfaces. Moreover,
    the compiler’s type inference unveiled a new era of concise and streamlined code,
    where developers can leverage static typing without the burden of explicit type
    annotations.
  prefs: []
  type: TYPE_NORMAL
- en: While Go generics is still being smoothened out and added to, it is a powerful
    addition that aims to empower developers to write efficient, reusable code with
    unprecedented ease. Now that we know how to write optimal and reusable code thanks
    to generics, we can look at expanding this knowledge in the next chapter. There,
    we will enhance our understanding by covering Go modules and seeing how to reuse
    code at a much larger scale and collaborative effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Modules'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A module serves as a repository for reusable code utilized by various applications.
    Whether large or small, a module enables efficient code organization and enhances
    reusability. In this section, you’ll learn how to create and manage modules effectively,
    leveraging packages and external modules to streamline your development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18621_09.xhtml#_idTextAnchor1367), *Using Go Modules to Define
    a Project*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18621_10.xhtml#_idTextAnchor1405), *Package Keep Projects Manageable*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18621_11.xhtml#_idTextAnchor1462), *Bug-Busting Debugging Skills*,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B18621_12.xhtml#_idTextAnchor1532), *About Time*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
