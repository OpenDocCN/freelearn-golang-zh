<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer112">
			<h1 id="_idParaDest-261" class="chapter-number"><a id="_idTextAnchor1367"/>9</h1>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor1368"/>Using Go Modules to Define a Project</h1>
			<p class="callout-heading"><a id="_idTextAnchor1369"/>Overview</p>
			<p class="callout">This chapter dives into the use of Go modules for structuring and managing Go projects. We will start by introducing the concept of modules and their significance in organizing code. This chapter will also cover creating your first module while discussing the essential <strong class="source-inline">go.mod</strong> and <span class="No-Break"><strong class="source-inline">go.sum</strong></span><span class="No-Break"> files.</span></p>
			<p class="callout">Moreover, we will cover how to use third-party modules as dependencies and offer insights into managing these dependencies effectively. This chapter will provide hands-on experience through exercises and activities that will empower you to develop more structured and manageable Go projects, promoting code reusability and simplifying the <span class="No-Break">development process.</span></p>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor1370"/><a id="_idTextAnchor1371"/>Technical requirements</h1>
			<p>For this chapter, you'll require Go version 1.21 or higher. The code for this chapter can be found <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter09"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter09</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor1372"/>Introduction</h1>
			<p>In the previous chapter, we learned about the importance of creating maintainable, reusable, and modular software using Go packages. We learned how packages are structured, the principles of proper package naming, and the distinctions between executable and non-executable packages. The concept of exportable and unexportable code was <span class="No-Break">also discussed.</span></p>
			<p>In this chapter, we will expand upon this knowledge and explore the utilization of Go modules to define projects, advancing our software development capabilities. We will understand what Go modules are, how they are helpful, and even create our own module. We will understand the different files required for working with Go modules to maintain the integrity of our project dependencies, and then learn how to consume third-party modules and manage them. Lastly, we will look at how to create a project containing multiple modules, and when that <span class="No-Break">is useful.</span></p>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor1373"/><a id="_idTextAnchor1374"/><a id="_idTextAnchor1375"/>What is a module?</h1>
			<p>In the world of Go programming, a module is a fundamental concept that serves as a cornerstone for organizing, versioning, and managing your projects and their dependencies. Think <a id="_idIndexMarker655"/>of it as a self-contained, encapsulated unit that simplifies the complexities of dependency management while fostering code reusability <span class="No-Break">and maintainability.</span></p>
			<p>A Go module represents a discrete collection of Go packages, all neatly bundled together under a common, versioned umbrella. This isolation ensures that your code base remains cohesive and well-structured, making it easier to share, collaborate on, and maintain. Modules are designed to put you in control of your project’s external dependencies and provide a structured mechanism for versioning and <span class="No-Break">managing them.</span></p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor1376"/>Key components when working with Go modules</h2>
			<p>There are a few key components that are associated with working Go modules. Let’s take a look at some of the aspects that<a id="_idIndexMarker656"/> help us with Go dependency management for <span class="No-Break">our projects:</span></p>
			<ul>
				<li><strong class="bold">The</strong> <strong class="source-inline">go.mod</strong> file: At the core of a Go module is the <strong class="source-inline">go.mod</strong> file. This file serves as the blueprint for your module and contains essential information such as the module’s path and version, as well as a comprehensive list of its dependencies. This detailed map ensures that all required packages are clearly defined and that their specific versions <span class="No-Break">are recorded.</span></li>
				<li><strong class="bold">The</strong> <strong class="source-inline">go.sum</strong> file: The <strong class="source-inline">go.sum</strong> file, working in tandem with <strong class="source-inline">go.mod</strong>, is a vital component in Go module management. It contains cryptographic checksums, such as SHA-256 hashes, for all the dependencies listed in <strong class="source-inline">go.mod</strong>. These checksums serve as security measures, ensuring that the downloaded dependencies have not been tampered with <span class="No-Break">or corrupted.</span></li>
				<li><strong class="bold">Versioning</strong>: Go modules<a id="_idIndexMarker657"/> introduce a robust versioning system that plays a <a id="_idIndexMarker658"/>pivotal role in dependency management. Each module is assigned a unique version identifier, typically through tags or commit hashes in the version control system. This meticulous approach guarantees that your project consistently uses a known and verified set of dependencies. A released module is published with a version number using the semantic versioning model, which you can find more information about on their <span class="No-Break">website: </span><a href="https://semver.org"><span class="No-Break">https://semver.org</span></a><span class="No-Break">.</span></li>
			</ul>
			<p>These three aspects of Go modules help us with project dependency management. With Go modules, you no longer need to worry about manually tracking and managing your project’s dependencies. As you import packages, they are automatically added to the <strong class="source-inline">go.mod</strong> file with version information, simplifying the process of ensuring that your code remains compatible with the exact set of dependencies it was <span class="No-Break">designed for.</span></p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor1377"/>The go.mod file</h2>
			<p>The <strong class="source-inline">go.mod</strong> file is the main configuration<a id="_idIndexMarker659"/> file for a Go module. It contains the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker660"/></span><span class="No-Break"> information:</span></p>
			<ul>
				<li><strong class="bold">Module path</strong>: This is the path at which the module is expected to be found. As an example, <strong class="source-inline">module mymodule</strong> specifies the module path <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">mymodule</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Dependencies</strong>: The <strong class="source-inline">go.mod</strong> file lists the dependencies required by the module, including their module paths and specific versions or <span class="No-Break">version ranges.</span></li>
				<li><strong class="bold">Replace directives (optional)</strong>: These directives allow you to specify replacements for certain dependencies, which can be useful for testing or resolving <span class="No-Break">compatibility issues.</span></li>
				<li><strong class="bold">Exclude directives (optional)</strong>: These directives allow you to exclude specific versions of a dependency<a id="_idIndexMarker661"/> that may have <span class="No-Break">known issues.</span></li>
			</ul>
			<p>Here’s an example of a simple <span class="No-Break"><strong class="source-inline">go.mod</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
module mymodule
require (
  github.com/some/dependency v1.2.3
  github.com/another/dependency v2.0.0
)
replace (
  github.com/dependency/v3 =&gt; github.com/dependency/v4
)
exclude (
  github.com/some/dependency v2.0.0
)</pre>			<p>The preceding code shows how the <strong class="source-inline">go.mod</strong> file can be easily read, lists the dependencies of a project, and makes adjustments when working locally with the <strong class="source-inline">replace</strong> directive, or excludes <a id="_idIndexMarker662"/>certain dependencies <span class="No-Break">as needed.</span></p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor1378"/>The go.sum file</h2>
			<p>The <strong class="source-inline">go.sum</strong> file contains a list of<a id="_idIndexMarker663"/> checksums for the specific versions of the dependencies used<a id="_idIndexMarker664"/> in the project. These checksums are used to verify the integrity of downloaded <span class="No-Break">package files.</span></p>
			<p>The <strong class="source-inline">go.sum</strong> file is automatically generated and maintained by the Go toolchain. It ensures that the downloaded packages have not been tampered with and that the project always uses the correct versions of <span class="No-Break">the dependencies.</span></p>
			<p>Here’s a simplified example of a <span class="No-Break"><strong class="source-inline">go.sum</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
github.com/some/dependency v1.2.3 h1:abcdefg...
github.com/some/dependency v1.2.3/go.mod h1:hijklm...
github.com/another/dependency v2.0.0 h1:mnopqr...
github.com/another/dependency v2.0.0/go.mod h1:stuvwx...</pre>			<p>The sample <strong class="source-inline">go.sum</strong> file’s contents in the preceding example demonstrate how to verify the integrity of downloaded <a id="_idIndexMarker665"/>package files for Go projects. This was a very simple example; however, in reality, the <strong class="source-inline">go.sum</strong> file can become quite large, depending on the size and amount of <a id="_idIndexMarker666"/>dependencies that a projec<a id="_idTextAnchor1379"/>t <span class="No-Break">may have.</span></p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor1380"/>How are modules helpful?</h1>
			<p>Go modules offer many benefits that enhance the Go development experience. Let’s take a closer look at how <a id="_idIndexMarker667"/>Go modules <span class="No-Break">are helpful.</span></p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor1381"/>Precise and simplified dependency management</h2>
			<p>One of the most significant advantages of Go modules is their ability to provide precise control over dependencies. When specifying dependencies in your <strong class="source-inline">go.mod</strong> file, you can define the exact versions you need, which eliminates the guesswork and potential compatibility issues associated with less rigorous dependency <span class="No-Break">management methods.</span></p>
			<p>Go modules have streamlined the process of adding, updating, and managing dependencies. In the past, Go developers had to rely on the <strong class="source-inline">GOPATH</strong> and <strong class="source-inline">vendor </strong>directories, which could lead to version conflicts and make it challenging to manage dependencies. Go modules replace these practices with a more intuitive and <span class="No-Break">efficient approach.</span></p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor1382"/>Versioning and reproducibility</h2>
			<p>Go modules introduce a robust versioning system. Each module is tagged with a specific version identifier or commit hash. This meticulous version control ensures that your project relies on a consistent and known set of dependencies. It promotes reproducibility, meaning that you and your collaborators can recreate the same development environment effortlessly, reducing the “it works on my <span class="No-Break">machine” problem.</span></p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor1383"/>Improved collaboration</h2>
			<p>With well-defined modules, collaborating on Go projects becomes more accessible. Modules provide a clear boundary for your code, ensuring that it remains cohesive and self-contained. This makes it easier for you to share your work with others and for others to<a id="_idIndexMarker668"/> contribute to your projects without worrying about breaking <span class="No-Break">existing functionality.</span></p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor1384"/>Dependency safety</h2>
			<p>Go modules incorporate security measures through the <strong class="source-inline">go.sum</strong> file. By incorporating cryptographic checksums for all your project’s dependencies, as mentioned previously in this chapter, you can see how this safeguards against potential tampering or corruption of <span class="No-Break">downloaded packages.</span></p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor1385"/>Ease of use while promoting isolation and modularity</h2>
			<p>It is easy to see the benefits in which Go modules help our programs. Modules lead to easier maintenance on the development team through ease of use to understand, update, and track project dependencies. As projects evolve, it is easy to keep up with changes in <span class="No-Break">external packages.</span></p>
			<p>Go modules promote isolation and modularity. They also provide a natural mechanism for isolating your project from the global workspace. This isolation fosters modularity, allowing you to focus on building self-contained, reusable components that are easy to manage and share. This builds on the idiomatic nature of Go and promotes best practices for development teams for their <span class="No-Break">Go projects.</span></p>
			<p>Go modules were officially introduced in Go 1.11, and they provide a more sophisticated, structured, and version-aware way of managing project dependencies. Developers are encouraged to migrate to Go modules for modern Go <span class="No-Break">project<a id="_idTextAnchor1386"/> development.</span></p>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor1387"/>Exercise 09.01 – creating and using your first module</h1>
			<p>In this exercise, we will <a id="_idIndexMarker669"/>see how to create our first Go module <span class="No-Break">with ease:</span></p>
			<ol>
				<li>Create a new directory called <strong class="source-inline">bookutil</strong> and navigate <span class="No-Break">into it:</span><pre class="source-code">
mkdir bookutil
cd bookutil</pre></li>				<li>Initialize a Go module <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">bookutil</strong></span><span class="No-Break">:</span><pre class="source-code">
go mod init bookutil</pre></li>				<li>Verify that <strong class="source-inline">go.mod</strong> is created within your project directory with the module path set <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">bookutil</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">No <strong class="source-inline">go.sum</strong> file is created after running <strong class="source-inline">go mod init</strong>. It will be generated and updated as you interact with your module and add to <span class="No-Break">its dependencies.</span></p>
			<ol>
				<li value="4">Now, let’s create a<a id="_idIndexMarker670"/> Go package for the author information while focusing on functions related to book chapters by creating a directory named <strong class="source-inline">author</strong> within our module’s <span class="No-Break">project directory.</span></li>
				<li>Inside the <strong class="source-inline">author</strong> directory, create a file named <strong class="source-inline">author.go</strong> to define the package <span class="No-Break">and functions.</span><p class="list-inset">Here is the starting code <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">author.go</strong></span><span class="No-Break">:</span></p><pre class="source-code">
package author
import "fmt"
// Author represents an author of a book.
type Author struct {
    Name string
    Contact string
}</pre></li>				<li>Now, we can add the necessary functions to create our author and define actions that our author <a id="_idIndexMarker671"/><span class="No-Break">can perform:</span><pre class="source-code">
func NewAuthor(name, contact string) *Author {
    return &amp;Author{Name: name, Contact: contact}
}
func (a *Author) WriteChapter(chapterTitle string, content string) {
    fmt.Printf("Author %s is writing a chapter titled   '%s'\n", a.Name, chapterTitle)
    fmt.Println(content)
}
func (a *Author) ReviewChapter(chapterTitle string, content string) {
    fmt.Printf("Author %s is reviewing a chapter titled '%s'\n", a.Name, chapterTitle)
    fmt.Println(content)
}
func (a *Author) FinalizeChapter(chapterTitle string) {
    fmt.Printf("Author %s has finalized the chapter titled '%s'.\n", a.Name, chapterTitle)
}</pre></li>				<li>With the author package defined, we can create a Go file in our module to demonstrate how to use it. Let’s name this file <strong class="source-inline">main.go</strong> at the root of <span class="No-Break">our directory:</span><pre class="source-code">
package main
import "bookutil/author "
func main() {
    // Create an author instance.
    authorInstance := author.NewAuthor("Jane Doe",   "jane@example.com")
    // Write and review a chapter.
    chapterTitle := "Introduction to Go Modules"
    chapterContent := "Go modules provide a structured way to manage dependencies and improve code maintainability."
    authorInstance.WriteChapter(chapterTitle, chapterContent)
    authorInstance.ReviewChapter(chapterTitle, "This chapter looks great, but let's add some more examples.")
    authorInstance.FinalizeChapter(chapterTitle)
}</pre></li>				<li>Save the file in the folder <a id="_idIndexMarker672"/>and run the <span class="No-Break">f<a id="_idTextAnchor1388"/>ollowing command:</span><pre class="source-code">
go run main.go</pre></li>			</ol>
			<p>Running the preceding code results in the <span class="No-Break">following output:</span></p>
			<pre class="console">
Author John Doe is writing a chapter titled 'Introduction to Go Modules':
Go modules provide a structured way to manage dependencies and improve code maintainability.
Author John Doe is reviewing a chapter titled 'Introduction to Go Modules':
This chapter<a id="_idTextAnchor1389"/> looks great, but let's add some more examples.
Author John Doe has finalized the chapter titled 'Introduction to Go Modules'.</pre>			<p>In this exercise, we learned how to create a Go module and run a program <span class="No-Break">using it.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Your Go module does not have to be named the same as your Go package since you can have many packages to one Go module and project. It is good practice to name your module based on the main purpose of <span class="No-Break">the project.</span></p>
			<p class="callout">In this case, the primary purpose of the module is to manage and work with book chapters and authors, so the module’s name reflects the broader context. The name <strong class="source-inline">bookutil</strong> provides flexibility to include multiple packages related to book-related operations, including the <span class="No-Break"><strong class="source-inline">author</strong></span><span class="No-Break"> package.</span></p>
			<p>In addition, there are best practices for module naming, such as <strong class="source-inline">&lt;prefix&gt;/&lt;descriptive-text&gt;</strong> and <strong class="source-inline">github.com/&lt;project-name&gt;/</strong>, that you can read more about in the Go <span class="No-Break">documentation: </span><a href="https://go.dev/doc/modules/managing-dependencies#naming_module"><span class="No-Break">https://go.dev/doc/modules/managing-dependencies#naming_module</span></a><span class="No-Break">.</span></p>
			<p>Now that you have successfully created a Go module named <strong class="source-inline">bookutil</strong> with an <strong class="source-inline">author</strong> package <a id="_idIndexMarker673"/>focused on book chapters, let’s explore the importance of using external Go modules and how they can enh<a id="_idTextAnchor1390"/>ance <span class="No-Break">your project.</span></p>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor1391"/>When should you use external modules, and why?</h1>
			<p>In Go development, leveraging<a id="_idIndexMarker674"/> external modules is a frequent practice that can benefit your projects. External modules, also known as third-party dependencies, offer many advantages when used judiciously. In this section, we will explore when to use external modules and the compelling reasons behind <span class="No-Break">their adoption.</span></p>
			<p>You should use external modules to do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Promote code reusability <span class="No-Break">and efficiency</span></li>
				<li>Expand <span class="No-Break">project functionality</span></li>
				<li>Offload <span class="No-Break">dependency management</span></li>
				<li>Enable collaborative development with the open <span class="No-Break">source community</span></li>
				<li>Utilize proven reliability, community support, and documentation by open <span class="No-Break">source code</span></li>
			</ul>
			<p>However, always exercise caution and select dependencies and modules that align with your project’s goals and<a id="_idIndexMarker675"/> long-term <span class="No-Break">sustainability plans.</span></p>
			<h1 id="_idParaDest-277"><a id="_idTextAnchor1392"/>Exercise 09.02 – using an external module within our module</h1>
			<p>Sometimes, in code, you need a<a id="_idIndexMarker676"/> unique identifier for an identity you provide to something. This <a id="_idIndexMarker677"/>unique identifier is often called a <strong class="bold">universally unique identifier</strong> (<strong class="bold">UUID</strong>). Google provides a package to create such a UUID. Let’s look at how to <span class="No-Break">use it:</span></p>
			<ol>
				<li>Create a new directory called <strong class="source-inline">myuuidapp</strong> and navigate <span class="No-Break">into it:</span><pre class="source-code">
mkdir myuuidapp
cd myuuidapp</pre></li>				<li>Initialize a Go module <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">myuuidapp</strong></span><span class="No-Break">:</span><pre class="source-code">
go mod init myuuidapp</pre></li>				<li>Verify that the <strong class="source-inline">go.mod</strong> file is created within your project directory with the module path set <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">myuuidapp</strong></span><span class="No-Break">.</span></li>
				<li>Add a <span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break"> file.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the main package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Now, add the imports we will use in <span class="No-Break">this file:</span><pre class="source-code">
import (
    "fmt"
    "github.com/google/uuid"
)</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Generate a new UUID using the external <span class="No-Break">module package:</span><pre class="source-code">
    id := uuid.New()</pre></li>				<li>Print the <span class="No-Break">generated UUID:</span><pre class="source-code">
    fmt.Print<a id="_idTextAnchor1393"/>f("Generated UUID: %s\n", id)</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>				<li>Save the file and <a id="_idIndexMarker678"/>then run the following command to fetch the external dependencies, thereby updating your <strong class="source-inline">go.mod</strong> file with the <span class="No-Break">dependency information:</span><pre class="source-code">
go get github.com/google/uuid</pre></li>				<li>Verify that our <strong class="source-inline">go.mod</strong> file has now been updated with the package dependency with a new <strong class="source-inline">require</strong> line. Your version number may be different for the package, depending on what release version they <span class="No-Break">are on:</span><pre class="source-code">
require github.com/google/uuid v1.3.1</pre></li>				<li>Verify that our <strong class="source-inline">go.sum</strong> file has now been updated with the new dependencies. Again, your version numbers may be different for the package, depending on what release version they <span class="No-Break">are on:</span><pre class="source-code">
github.com/google/uuid v1.3.1 h1:KjJaJ9iWZ3jOFZIf1Lqf4laDRCasjl0BCmnEGxkdLb4=
github.com/google/uuid v1.3.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+<a id="_idTextAnchor1394"/>nhxU+yHo=</pre></li>				<li>Run <span class="No-Break">the code:</span><pre class="source-code">
go run main.go</pre></li>			</ol>
			<p>Running the preceding code results in the following output, with a <span class="No-Break">random UUID:</span></p>
			<pre class="console">
Generated UUID: 7a533339-58b6-4396-b7f7-d0a50216bf88</pre>			<p>With that, you’ve learned how to use an external module’s package within your module by generating a unique identifier using Google’s open source code. In this example, we trusted that Google has well-tested code and that it meets the standards we set for our code base. If we ever want to <a id="_idIndexMarker679"/>upgrade or downgrade the version of the external package, then that is offloaded to our Go module. Next, we’ll look at expanding our understanding of modules by looking at when to use multiple modules within <span class="No-Break">their project.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">More information on the UUID module and package can be found on GitHub <span class="No-Break">at </span><a href="https://github.com/google/uuid/tree/master"><span class="No-Break">https://github.com/<span id="_idTextAnchor1395"/>google/uuid/tree/master</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor1396"/>Consuming multiple modules within a project</h1>
			<p>You can consume multiple Go modules within a project. Just as you saw with the Google module example earlier, you can use that module alongside other Go modules that you may need in <span class="No-Break">your project.</span></p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor1397"/>Activity 9.01 – consuming multiple modules</h2>
			<p>In this activity, we will use multiple <a id="_idIndexMarker680"/>Go modules within <span class="No-Break">our code:</span></p>
			<ol>
				<li>Create a new UUID and print <span class="No-Break">the UUID.</span></li>
				<li>Fetch and print a random quote using the <span class="No-Break"><strong class="source-inline">rsc.io/quote</strong></span><span class="No-Break"> module.</span></li>
			</ol>
			<p>Your output should look like this, with a different UUID and a different random sentence for your <span class="No-Break">second line:</span></p>
			<pre class="console">
Generated UUID: 3c986212-f12d-415e-8eb5-87f61a6cbfee
Random Quote: Do not communicate by sharing memory, share memory by communicating.</pre>			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found in the GitHub repository folder for this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter09/Activity09.01"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter09/Activity09.01</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor1398"/>Defining multiple modules within a project</h1>
			<p>The Go module system is designed to manage dependencies and versions for the entire module, not for subsets or subprojects within a module. However, there might be situations where you have<a id="_idIndexMarker681"/> multiple distinct components or subprojects within your main project, and each of these components or subprojects has dependencies and version requirements. In such cases, you can structure your project in a way that each component is its own module, separate from the main project module. These submodules can be maintained as separate Go modules, each with its own <span class="No-Break"><strong class="source-inline">go.mod</strong></span><span class="No-Break"> file.</span></p>
			<p>For example, if you have a project with a main component and two other components, and each component has unique dependencies, you can structure your project <span class="No-Break">like this:</span></p>
			<pre class="console">
myproject/
├── mainmodule/
│   ├── main.go
│   ├── go.mod
│   ├── go.sum
│   ├── ...
├── secondmodule/
│   ├── othermain.go
│   ├── go.mod
│   ├── go.sum
│   ├── ...
├── thirdmodule/
│   ├── othermain.go
│   ├── go.mod
│   ├── go.sum
│   ├── ...</pre>			<p>Each subcomponent/module (that is, <strong class="source-inline">secondmodule</strong> and <strong class="source-inline">thirdmodule</strong>) is treated as a separate Go module with its own <strong class="source-inline">go.mod</strong> file <span class="No-Break">and dependencies.</span></p>
			<p>It makes sense to create<a id="_idIndexMarker682"/> submodules in the <span class="No-Break">following situations:</span></p>
			<ul>
				<li><strong class="bold">Components have different dependencies</strong>: When different components within your project have distinct sets of dependencies, creating submodules allows you to manage these <span class="No-Break">dependencies separately</span></li>
				<li><strong class="bold">There are separate versioning requirements</strong>: If different components need different versions of the same dependency, using submodules can help manage these version conflicts <span class="No-Break">more effectively</span></li>
				<li><strong class="bold">There’s component reusability</strong>: When you intend to reuse a component across multiple projects, structuring it as a separate module can facilitate its reuse in <span class="No-Break">various contexts</span></li>
				<li><strong class="bold">There’s maintainability</strong>: Submodules can enhance code organization and maintainability as each component can be developed, tested, and <span class="No-Break">maintained separately</span></li>
			</ul>
			<p>While you can technically create submodules within a project, it is not a customary practice, and it should be done when there is a clear need for separate dependency management, versioning, or code organization for distinct components within your project. Each submodule should have its own <strong class="source-inline">go.mod</strong> file that defines its specific dependencie<a id="_idTextAnchor1399"/>s and <span class="No-Break">version requirements.</span></p>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor1400"/>Go workspaces</h1>
			<p>In Go 1.18, the <em class="italic">Go workspaces</em> feature was released, which improved the experience of working with multiple <strong class="source-inline">Go </strong>modules within the same project locally. Originally, when working with multiple Go modules in the same project, you would need to manually edit the Go module files for each <a id="_idIndexMarker683"/>module with the replace directive to use your local changes. Now, with Go workspaces, we can define a <strong class="source-inline">go.work</strong> file, specifying to use our local changes, and not have to worry about managing several <strong class="source-inline">go.mod</strong> files manually ourselves. This is particularly useful when working with larger projects, or projects that span <span class="No-Break">multiple repositories.</span></p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor1401"/>Exercise 09.03 – working with workspaces</h2>
			<p>In this exercise, we will look at what it <a id="_idIndexMarker684"/>used to be like when working with projects that had multiple Go modules that needed their dependencies to be replaced so that they could use local changes. We will then update the example code so that it uses Go workspaces to show <span class="No-Break">the improvements:</span></p>
			<ol>
				<li>Create a new folder called <strong class="source-inline">printer</strong> and add a <span class="No-Break"><strong class="source-inline">printer.go</strong></span><span class="No-Break"> file.</span></li>
				<li>In <strong class="source-inline">printer.go</strong>, add the <strong class="source-inline">printer</strong> package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package printer</pre></li>				<li>Now, add the imports we will use in <span class="No-Break">this file:</span><pre class="source-code">
import (
    "fmt"
    "github.com/google/uuid"
)</pre></li>				<li>Create the exported <strong class="source-inline">PrintNewUUID()</strong> function, returning <span class="No-Break">a string:</span><pre class="source-code">
func PrintNewUUID() string {</pre></li>				<li>Generate a new UUID using the external <span class="No-Break">module package:</span><pre class="source-code">
    id := uuid.New()</pre></li>				<li>Create and return a string to print the <span class="No-Break">generated UUID:</span><pre class="source-code">
    return fmt.Sprintf("Generated UUID: %s\n", id)</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">PrintNewUUID()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>				<li>Create a Go module <a id="_idIndexMarker685"/>and install the <span class="No-Break">necessary dependencies:</span><pre class="source-code">
go mod init github.com/sicoyle/printer
go mod tidy</pre></li>				<li>Go back a folder and create a new folder sitting side-by-side with the <strong class="source-inline">printer</strong> folder called <strong class="source-inline">othermodule</strong> and add a <span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break"> file.</span></li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of <span class="No-Break">the file:</span><pre class="source-code">
package main</pre></li>				<li>Now, add the imports we will use in <span class="No-Break">this file:</span><pre class="source-code">
import (
    "fmt"
    "github.com/sicoyle/printer"
)</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Use the <strong class="source-inline">PrintNewUUID()</strong> function we defined in our <span class="No-Break"><strong class="source-inline">printer</strong></span><span class="No-Break"> module:</span><pre class="source-code">
    msg := printer.PrintNewUUID()</pre></li>				<li>Print the generated UUID <span class="No-Break">message string:</span><pre class="source-code">
    fmt.Println(msg)</pre></li>				<li>Close the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
}</pre></li>				<li>Initialize a Go module <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">othermodule</strong></span><span class="No-Break">:</span><pre class="source-code">
go mod init othermodule</pre></li>				<li>Add the <span class="No-Break">module’s requirements:</span><pre class="source-code">
go mod tidy</pre></li>				<li>View the error message <a id="_idIndexMarker686"/>when Go tries to retrieve the module dependencies; the <strong class="source-inline">printer</strong> package includes only local changes that are not published externally <span class="No-Break">on GitHub:</span><pre class="source-code">
go: finding module for package github.com/sicoyle/printer
go: othermodule imports
      github.com/sicoyle/printer: cannot find module...</pre></li>				<li>The old way of addressing this before Go workspaces included editing the Go module with a replacement inside the <span class="No-Break"><strong class="source-inline">othermodule</strong></span><span class="No-Break"> directory:</span><pre class="source-code">
go mod edit -replace github.com/sicoyle/printer=../printer</pre></li>				<li>Verify that the <strong class="source-inline">othermodule/go.mod</strong> file was updated to include the <span class="No-Break">following contents:</span><pre class="source-code">
module othermodule
go 1.21.0
replace github.com/sicoyle/printer =&gt; ../printer</pre></li>				<li>Now, we can successfully tidy <span class="No-Break">our dependencies:</span><pre class="source-code">
go mod tidy</pre></li>				<li>Run <span class="No-Break">the code:</span><pre class="source-code">
go run main.go</pre></li>				<li>Running the preceding code shows the following output, with a <span class="No-Break">random UUID:</span><pre class="source-code">
Generated UUID: 5ff596a2-7c0e-41fe-b0b1-256b28a35b76</pre></li>			</ol>
			<p>We’ve just seen what the flow <a id="_idIndexMarker687"/>was like before Go workspaces were introduced. Now, let’s see what changes with this <span class="No-Break">new feature.</span></p>
			<ol>
				<li>Replace the entirety of <strong class="source-inline">othermodule/go.mod</strong> with the <span class="No-Break">following contents:</span><pre class="source-code">
module othermodule
go 1.21.0</pre></li>				<li>Run the tidying command; you’ll see that the error finds the <span class="No-Break"><strong class="source-inline">printer</strong></span><span class="No-Break"> module:</span><pre class="source-code">
go mod tidy</pre></li>				<li>Run the following command in the <strong class="source-inline">printer</strong> directory to initialize a <span class="No-Break">Go workspace:</span><pre class="source-code">
go work init</pre></li>				<li>Use your local changes within <span class="No-Break">the workspace:</span><pre class="source-code">
go work use ./printer</pre></li>				<li>Run <span class="No-Break">the code:</span><pre class="source-code">
go run othermodule/main.go</pre></li>				<li>Running the preceding code shows the following output, with a <span class="No-Break">random UUID:</span><pre class="source-code">
Generated UUID: 5ff596a2-7c0e-41fe-b0b1-256b28a35b76</pre></li>			</ol>
			<p>This exercise demonstrated the flow both before and after the Go workspaces feature was introduced. This feature gives developers a way to better manage local changes among larger projects and across different repositories that include multiple <strong class="source-inline">go.mod</strong> files that might <span class="No-Break">need updating.</span></p>
			<p>We’ve covered a lot of ground in this chapter. Let’s take a loo<a id="_idTextAnchor1402"/><a id="_idTextAnchor1403"/>k at everything that <span class="No-Break">we covered.</span></p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor1404"/>Summary</h1>
			<p>In this chapter, we explored the world of Go modules, beginning with an understanding of what modules are and how they provide structured project organization and management of project dependencies. We introduced the two key module files – <strong class="source-inline">go.mod</strong> and <strong class="source-inline">go.sum</strong> – that handle dependencies. We also delved into external modules, emphasizing their role in expanding project functionality and their impact on maintainability. We discussed using and consuming multiple modules in a single project, and the concept of Go workspaces for managing multiple modules within a project directory. Hands-on exercises and activities reinforced <span class="No-Break">our understanding.</span></p>
			<p>In the next chapter, we will enhance our module understanding by covering how packages help keep projects more manageable for teams as they iterate, reuse, and maintain projects <span class="No-Break">using packages.</span></p>
		</div>
	</div></div></body></html>