- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Go Modules to Define a Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter dives into the use of Go modules for structuring and managing Go
    projects. We will start by introducing the concept of modules and their significance
    in organizing code. This chapter will also cover creating your first module while
    discussing the essential `go.mod` and `go.sum` files.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we will cover how to use third-party modules as dependencies and offer
    insights into managing these dependencies effectively. This chapter will provide
    hands-on experience through exercises and activities that will empower you to
    develop more structured and manageable Go projects, promoting code reusability
    and simplifying the development process.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you''ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter09](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter09).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about the importance of creating maintainable,
    reusable, and modular software using Go packages. We learned how packages are
    structured, the principles of proper package naming, and the distinctions between
    executable and non-executable packages. The concept of exportable and unexportable
    code was also discussed.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will expand upon this knowledge and explore the utilization
    of Go modules to define projects, advancing our software development capabilities.
    We will understand what Go modules are, how they are helpful, and even create
    our own module. We will understand the different files required for working with
    Go modules to maintain the integrity of our project dependencies, and then learn
    how to consume third-party modules and manage them. Lastly, we will look at how
    to create a project containing multiple modules, and when that is useful.
  prefs: []
  type: TYPE_NORMAL
- en: What is a module?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of Go programming, a module is a fundamental concept that serves
    as a cornerstone for organizing, versioning, and managing your projects and their
    dependencies. Think of it as a self-contained, encapsulated unit that simplifies
    the complexities of dependency management while fostering code reusability and
    maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: A Go module represents a discrete collection of Go packages, all neatly bundled
    together under a common, versioned umbrella. This isolation ensures that your
    code base remains cohesive and well-structured, making it easier to share, collaborate
    on, and maintain. Modules are designed to put you in control of your project’s
    external dependencies and provide a structured mechanism for versioning and managing
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Key components when working with Go modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few key components that are associated with working Go modules.
    Let’s take a look at some of the aspects that help us with Go dependency management
    for our projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`go.mod` file: At the core of a Go module is the `go.mod` file. This file serves
    as the blueprint for your module and contains essential information such as the
    module’s path and version, as well as a comprehensive list of its dependencies.
    This detailed map ensures that all required packages are clearly defined and that
    their specific versions are recorded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go.sum` file: The `go.sum` file, working in tandem with `go.mod`, is a vital
    component in Go module management. It contains cryptographic checksums, such as
    SHA-256 hashes, for all the dependencies listed in `go.mod`. These checksums serve
    as security measures, ensuring that the downloaded dependencies have not been
    tampered with or corrupted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning**: Go modules introduce a robust versioning system that plays
    a pivotal role in dependency management. Each module is assigned a unique version
    identifier, typically through tags or commit hashes in the version control system.
    This meticulous approach guarantees that your project consistently uses a known
    and verified set of dependencies. A released module is published with a version
    number using the semantic versioning model, which you can find more information
    about on their website: [https://semver.org](https://semver.org).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three aspects of Go modules help us with project dependency management.
    With Go modules, you no longer need to worry about manually tracking and managing
    your project’s dependencies. As you import packages, they are automatically added
    to the `go.mod` file with version information, simplifying the process of ensuring
    that your code remains compatible with the exact set of dependencies it was designed
    for.
  prefs: []
  type: TYPE_NORMAL
- en: The go.mod file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `go.mod` file is the main configuration file for a Go module. It contains
    the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`module mymodule` specifies the module path as `mymodule`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go.mod` file lists the dependencies required by the module, including their
    module paths and specific versions or version ranges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replace directives (optional)**: These directives allow you to specify replacements
    for certain dependencies, which can be useful for testing or resolving compatibility
    issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exclude directives (optional)**: These directives allow you to exclude specific
    versions of a dependency that may have known issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of a simple `go.mod` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows how the `go.mod` file can be easily read, lists the
    dependencies of a project, and makes adjustments when working locally with the
    `replace` directive, or excludes certain dependencies as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The go.sum file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `go.sum` file contains a list of checksums for the specific versions of
    the dependencies used in the project. These checksums are used to verify the integrity
    of downloaded package files.
  prefs: []
  type: TYPE_NORMAL
- en: The `go.sum` file is automatically generated and maintained by the Go toolchain.
    It ensures that the downloaded packages have not been tampered with and that the
    project always uses the correct versions of the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simplified example of a `go.sum` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The sample `go.sum` file’s contents in the preceding example demonstrate how
    to verify the integrity of downloaded package files for Go projects. This was
    a very simple example; however, in reality, the `go.sum` file can become quite
    large, depending on the size and amount of dependencies that a project may have.
  prefs: []
  type: TYPE_NORMAL
- en: How are modules helpful?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go modules offer many benefits that enhance the Go development experience. Let’s
    take a closer look at how Go modules are helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Precise and simplified dependency management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most significant advantages of Go modules is their ability to provide
    precise control over dependencies. When specifying dependencies in your `go.mod`
    file, you can define the exact versions you need, which eliminates the guesswork
    and potential compatibility issues associated with less rigorous dependency management
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Go modules have streamlined the process of adding, updating, and managing dependencies.
    In the past, Go developers had to rely on the `GOPATH` and `vendor` directories,
    which could lead to version conflicts and make it challenging to manage dependencies.
    Go modules replace these practices with a more intuitive and efficient approach.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning and reproducibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go modules introduce a robust versioning system. Each module is tagged with
    a specific version identifier or commit hash. This meticulous version control
    ensures that your project relies on a consistent and known set of dependencies.
    It promotes reproducibility, meaning that you and your collaborators can recreate
    the same development environment effortlessly, reducing the “it works on my machine”
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Improved collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With well-defined modules, collaborating on Go projects becomes more accessible.
    Modules provide a clear boundary for your code, ensuring that it remains cohesive
    and self-contained. This makes it easier for you to share your work with others
    and for others to contribute to your projects without worrying about breaking
    existing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go modules incorporate security measures through the `go.sum` file. By incorporating
    cryptographic checksums for all your project’s dependencies, as mentioned previously
    in this chapter, you can see how this safeguards against potential tampering or
    corruption of downloaded packages.
  prefs: []
  type: TYPE_NORMAL
- en: Ease of use while promoting isolation and modularity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is easy to see the benefits in which Go modules help our programs. Modules
    lead to easier maintenance on the development team through ease of use to understand,
    update, and track project dependencies. As projects evolve, it is easy to keep
    up with changes in external packages.
  prefs: []
  type: TYPE_NORMAL
- en: Go modules promote isolation and modularity. They also provide a natural mechanism
    for isolating your project from the global workspace. This isolation fosters modularity,
    allowing you to focus on building self-contained, reusable components that are
    easy to manage and share. This builds on the idiomatic nature of Go and promotes
    best practices for development teams for their Go projects.
  prefs: []
  type: TYPE_NORMAL
- en: Go modules were officially introduced in Go 1.11, and they provide a more sophisticated,
    structured, and version-aware way of managing project dependencies. Developers
    are encouraged to migrate to Go modules for modern Go project development.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 09.01 – creating and using your first module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this exercise, we will see how to create our first Go module with ease:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory called `bookutil` and navigate into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize a Go module named `bookutil`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Verify that `go.mod` is created within your project directory with the module
    path set as `bookutil`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: No `go.sum` file is created after running `go mod init`. It will be generated
    and updated as you interact with your module and add to its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s create a Go package for the author information while focusing on
    functions related to book chapters by creating a directory named `author` within
    our module’s project directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `author` directory, create a file named `author.go` to define the
    package and functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the starting code for `author.go`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can add the necessary functions to create our author and define actions
    that our author can perform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the author package defined, we can create a Go file in our module to demonstrate
    how to use it. Let’s name this file `main.go` at the root of our directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file in the folder and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we learned how to create a Go module and run a program using
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Your Go module does not have to be named the same as your Go package since you
    can have many packages to one Go module and project. It is good practice to name
    your module based on the main purpose of the project.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the primary purpose of the module is to manage and work with book
    chapters and authors, so the module’s name reflects the broader context. The name
    `bookutil` provides flexibility to include multiple packages related to book-related
    operations, including the `author` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, there are best practices for module naming, such as `<prefix>/<descriptive-text>`
    and `github.com/<project-name>/`, that you can read more about in the Go documentation:
    [https://go.dev/doc/modules/managing-dependencies#naming_module](https://go.dev/doc/modules/managing-dependencies#naming_module).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have successfully created a Go module named `bookutil` with an
    `author` package focused on book chapters, let’s explore the importance of using
    external Go modules and how they can enhance your project.
  prefs: []
  type: TYPE_NORMAL
- en: When should you use external modules, and why?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Go development, leveraging external modules is a frequent practice that can
    benefit your projects. External modules, also known as third-party dependencies,
    offer many advantages when used judiciously. In this section, we will explore
    when to use external modules and the compelling reasons behind their adoption.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should use external modules to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Promote code reusability and efficiency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expand project functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offload dependency management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable collaborative development with the open source community
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize proven reliability, community support, and documentation by open source
    code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, always exercise caution and select dependencies and modules that align
    with your project’s goals and long-term sustainability plans.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 09.02 – using an external module within our module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, in code, you need a unique identifier for an identity you provide
    to something. This unique identifier is often called a **universally unique identifier**
    (**UUID**). Google provides a package to create such a UUID. Let’s look at how
    to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory called `myuuidapp` and navigate into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize a Go module named `myuuidapp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Verify that the `go.mod` file is created within your project directory with
    the module path set as `myuuidapp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the main package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the imports we will use in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate a new UUID using the external module package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the generated UUID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file and then run the following command to fetch the external dependencies,
    thereby updating your `go.mod` file with the dependency information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that our `go.mod` file has now been updated with the package dependency
    with a new `require` line. Your version number may be different for the package,
    depending on what release version they are on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that our `go.sum` file has now been updated with the new dependencies.
    Again, your version numbers may be different for the package, depending on what
    release version they are on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code results in the following output, with a random UUID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With that, you’ve learned how to use an external module’s package within your
    module by generating a unique identifier using Google’s open source code. In this
    example, we trusted that Google has well-tested code and that it meets the standards
    we set for our code base. If we ever want to upgrade or downgrade the version
    of the external package, then that is offloaded to our Go module. Next, we’ll
    look at expanding our understanding of modules by looking at when to use multiple
    modules within their project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: More information on the UUID module and package can be found on GitHub at [https://github.com/google/uuid/tree/master](https://github.com/google/uuid/tree/master).
  prefs: []
  type: TYPE_NORMAL
- en: Consuming multiple modules within a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can consume multiple Go modules within a project. Just as you saw with the
    Google module example earlier, you can use that module alongside other Go modules
    that you may need in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 9.01 – consuming multiple modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we will use multiple Go modules within our code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new UUID and print the UUID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetch and print a random quote using the `rsc.io/quote` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your output should look like this, with a different UUID and a different random
    sentence for your second line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter09/Activity09.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter09/Activity09.01).'
  prefs: []
  type: TYPE_NORMAL
- en: Defining multiple modules within a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go module system is designed to manage dependencies and versions for the
    entire module, not for subsets or subprojects within a module. However, there
    might be situations where you have multiple distinct components or subprojects
    within your main project, and each of these components or subprojects has dependencies
    and version requirements. In such cases, you can structure your project in a way
    that each component is its own module, separate from the main project module.
    These submodules can be maintained as separate Go modules, each with its own `go.mod`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have a project with a main component and two other components,
    and each component has unique dependencies, you can structure your project like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Each subcomponent/module (that is, `secondmodule` and `thirdmodule`) is treated
    as a separate Go module with its own `go.mod` file and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'It makes sense to create submodules in the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Components have different dependencies**: When different components within
    your project have distinct sets of dependencies, creating submodules allows you
    to manage these dependencies separately'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**There are separate versioning requirements**: If different components need
    different versions of the same dependency, using submodules can help manage these
    version conflicts more effectively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**There’s component reusability**: When you intend to reuse a component across
    multiple projects, structuring it as a separate module can facilitate its reuse
    in various contexts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**There’s maintainability**: Submodules can enhance code organization and maintainability
    as each component can be developed, tested, and maintained separately'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While you can technically create submodules within a project, it is not a customary
    practice, and it should be done when there is a clear need for separate dependency
    management, versioning, or code organization for distinct components within your
    project. Each submodule should have its own `go.mod` file that defines its specific
    dependencies and version requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Go workspaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Go 1.18, the *Go workspaces* feature was released, which improved the experience
    of working with multiple `Go` modules within the same project locally. Originally,
    when working with multiple Go modules in the same project, you would need to manually
    edit the Go module files for each module with the replace directive to use your
    local changes. Now, with Go workspaces, we can define a `go.work` file, specifying
    to use our local changes, and not have to worry about managing several `go.mod`
    files manually ourselves. This is particularly useful when working with larger
    projects, or projects that span multiple repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 09.03 – working with workspaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will look at what it used to be like when working with
    projects that had multiple Go modules that needed their dependencies to be replaced
    so that they could use local changes. We will then update the example code so
    that it uses Go workspaces to show the improvements:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `printer` and add a `printer.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `printer.go`, add the `printer` package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the imports we will use in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the exported `PrintNewUUID()` function, returning a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate a new UUID using the external module package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create and return a string to print the generated UUID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `PrintNewUUID()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a Go module and install the necessary dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Go back a folder and create a new folder sitting side-by-side with the `printer`
    folder called `othermodule` and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the imports we will use in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `PrintNewUUID()` function we defined in our `printer` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the generated UUID message string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize a Go module named `othermodule`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the module’s requirements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'View the error message when Go tries to retrieve the module dependencies; the
    `printer` package includes only local changes that are not published externally
    on GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The old way of addressing this before Go workspaces included editing the Go
    module with a replacement inside the `othermodule` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that the `othermodule/go.mod` file was updated to include the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can successfully tidy our dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code shows the following output, with a random UUID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve just seen what the flow was like before Go workspaces were introduced.
    Now, let’s see what changes with this new feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the entirety of `othermodule/go.mod` with the following contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the tidying command; you’ll see that the error finds the `printer` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command in the `printer` directory to initialize a Go workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use your local changes within the workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code shows the following output, with a random UUID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This exercise demonstrated the flow both before and after the Go workspaces
    feature was introduced. This feature gives developers a way to better manage local
    changes among larger projects and across different repositories that include multiple
    `go.mod` files that might need updating.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve covered a lot of ground in this chapter. Let’s take a look at everything
    that we covered.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the world of Go modules, beginning with an understanding
    of what modules are and how they provide structured project organization and management
    of project dependencies. We introduced the two key module files – `go.mod` and
    `go.sum` – that handle dependencies. We also delved into external modules, emphasizing
    their role in expanding project functionality and their impact on maintainability.
    We discussed using and consuming multiple modules in a single project, and the
    concept of Go workspaces for managing multiple modules within a project directory.
    Hands-on exercises and activities reinforced our understanding.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will enhance our module understanding by covering how
    packages help keep projects more manageable for teams as they iterate, reuse,
    and maintain projects using packages.
  prefs: []
  type: TYPE_NORMAL
