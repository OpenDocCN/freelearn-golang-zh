- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Using Go Modules to Define a Project
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Go模块定义项目
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter dives into the use of Go modules for structuring and managing Go
    projects. We will start by introducing the concept of modules and their significance
    in organizing code. This chapter will also cover creating your first module while
    discussing the essential `go.mod` and `go.sum` files.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了使用Go模块来结构和管理工作Go项目。我们将从介绍模块的概念及其在组织代码中的重要性开始。本章还将涵盖创建第一个模块，同时讨论必要的`go.mod`和`go.sum`文件。
- en: Moreover, we will cover how to use third-party modules as dependencies and offer
    insights into managing these dependencies effectively. This chapter will provide
    hands-on experience through exercises and activities that will empower you to
    develop more structured and manageable Go projects, promoting code reusability
    and simplifying the development process.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将介绍如何将第三方模块作为依赖项使用，并提供有效管理这些依赖项的见解。本章将通过练习和活动提供实践经验，使您能够开发出更加结构化和易于管理的Go项目，促进代码重用并简化开发过程。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you''ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter09](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter09).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要Go版本1.21或更高版本。本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter09](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter09)。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we learned about the importance of creating maintainable,
    reusable, and modular software using Go packages. We learned how packages are
    structured, the principles of proper package naming, and the distinctions between
    executable and non-executable packages. The concept of exportable and unexportable
    code was also discussed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了使用Go包创建可维护、可重用和模块化软件的重要性。我们学习了包的结构、合适的包命名原则以及可执行包和非可执行包的区别。还讨论了可导出和不可导出代码的概念。
- en: In this chapter, we will expand upon this knowledge and explore the utilization
    of Go modules to define projects, advancing our software development capabilities.
    We will understand what Go modules are, how they are helpful, and even create
    our own module. We will understand the different files required for working with
    Go modules to maintain the integrity of our project dependencies, and then learn
    how to consume third-party modules and manage them. Lastly, we will look at how
    to create a project containing multiple modules, and when that is useful.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在此基础上扩展知识，并探讨使用Go模块来定义项目，提高我们的软件开发能力。我们将了解Go模块是什么，它们如何有帮助，甚至创建我们自己的模块。我们将了解与Go模块一起工作所需的不同文件，以维护项目依赖项的完整性，然后学习如何消费第三方模块并管理它们。最后，我们将探讨如何创建包含多个模块的项目，以及何时这样做是有用的。
- en: What is a module?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是模块？
- en: In the world of Go programming, a module is a fundamental concept that serves
    as a cornerstone for organizing, versioning, and managing your projects and their
    dependencies. Think of it as a self-contained, encapsulated unit that simplifies
    the complexities of dependency management while fostering code reusability and
    maintainability.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go编程的世界里，模块是一个基本概念，它是组织、版本控制和管理工作及其依赖项的基石。将其视为一个自包含、封装的单元，它简化了依赖项管理的复杂性，同时促进了代码的重用和维护性。
- en: A Go module represents a discrete collection of Go packages, all neatly bundled
    together under a common, versioned umbrella. This isolation ensures that your
    code base remains cohesive and well-structured, making it easier to share, collaborate
    on, and maintain. Modules are designed to put you in control of your project’s
    external dependencies and provide a structured mechanism for versioning and managing
    them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Go模块代表了一组离散的Go包，所有这些包都整齐地打包在一个共同的、版本化的伞状结构下。这种隔离确保了您的代码库保持一致性和良好的结构，使其更容易共享、协作和维护。模块旨在让您控制项目的外部依赖项，并提供一种结构化的机制来版本控制和管理工作。
- en: Key components when working with Go modules
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Go模块时的关键组件
- en: 'There are a few key components that are associated with working Go modules.
    Let’s take a look at some of the aspects that help us with Go dependency management
    for our projects:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与Go模块工作相关的一些关键组件。让我们看看一些有助于我们为项目进行Go依赖项管理的方面：
- en: '`go.mod` file: At the core of a Go module is the `go.mod` file. This file serves
    as the blueprint for your module and contains essential information such as the
    module’s path and version, as well as a comprehensive list of its dependencies.
    This detailed map ensures that all required packages are clearly defined and that
    their specific versions are recorded.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go.mod` 文件：Go 模块的核心是 `go.mod` 文件。该文件作为您模块的蓝图，包含有关模块路径和版本的基本信息，以及其依赖项的详细列表。这个详细的映射确保所有必需的包都得到了明确定义，并且它们的特定版本被记录下来。'
- en: '`go.sum` file: The `go.sum` file, working in tandem with `go.mod`, is a vital
    component in Go module management. It contains cryptographic checksums, such as
    SHA-256 hashes, for all the dependencies listed in `go.mod`. These checksums serve
    as security measures, ensuring that the downloaded dependencies have not been
    tampered with or corrupted.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go.sum` 文件：`go.sum` 文件与 `go.mod` 文件协同工作，是 Go 模块管理中的一个重要组成部分。它包含所有在 `go.mod`
    中列出的依赖项的加密校验和，如 SHA-256 哈希。这些校验和作为安全措施，确保下载的依赖项未被篡改或损坏。'
- en: '**Versioning**: Go modules introduce a robust versioning system that plays
    a pivotal role in dependency management. Each module is assigned a unique version
    identifier, typically through tags or commit hashes in the version control system.
    This meticulous approach guarantees that your project consistently uses a known
    and verified set of dependencies. A released module is published with a version
    number using the semantic versioning model, which you can find more information
    about on their website: [https://semver.org](https://semver.org).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：Go 模块引入了一个强大的版本控制系统，在依赖项管理中发挥着关键作用。每个模块都被分配一个唯一的版本标识符，通常通过版本控制系统的标签或提交哈希实现。这种细致的方法确保您的项目始终使用已知和验证的依赖项集。已发布的模块使用语义版本控制模型发布版本号，您可以在他们的网站上找到更多关于此的信息：[https://semver.org](https://semver.org)。'
- en: These three aspects of Go modules help us with project dependency management.
    With Go modules, you no longer need to worry about manually tracking and managing
    your project’s dependencies. As you import packages, they are automatically added
    to the `go.mod` file with version information, simplifying the process of ensuring
    that your code remains compatible with the exact set of dependencies it was designed
    for.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个方面的 Go 模块帮助我们进行项目依赖项管理。使用 Go 模块，您不再需要手动跟踪和管理项目的依赖项。随着您导入包，它们会自动添加到 `go.mod`
    文件中，并带有版本信息，简化了确保代码与为它设计的确切依赖项集兼容的过程。
- en: The go.mod file
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: go.mod 文件
- en: 'The `go.mod` file is the main configuration file for a Go module. It contains
    the following information:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`go.mod` 文件是 Go 模块的主要配置文件。它包含以下信息：'
- en: '`module mymodule` specifies the module path as `mymodule`.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`module mymodule` 指定了模块路径为 `mymodule`。'
- en: '`go.mod` file lists the dependencies required by the module, including their
    module paths and specific versions or version ranges.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`go.mod` 文件列出了模块所需的依赖项，包括它们的模块路径和特定版本或版本范围。'
- en: '**Replace directives (optional)**: These directives allow you to specify replacements
    for certain dependencies, which can be useful for testing or resolving compatibility
    issues.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**替换指令（可选）**：这些指令允许您指定某些依赖项的替换，这在测试或解决兼容性问题时可能很有用。'
- en: '**Exclude directives (optional)**: These directives allow you to exclude specific
    versions of a dependency that may have known issues.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排除指令（可选）**：这些指令允许您排除可能存在已知问题的特定版本的依赖项。'
- en: 'Here’s an example of a simple `go.mod` file:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的 `go.mod` 文件示例：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code shows how the `go.mod` file can be easily read, lists the
    dependencies of a project, and makes adjustments when working locally with the
    `replace` directive, or excludes certain dependencies as needed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了如何轻松读取 `go.mod` 文件，列出项目的依赖项，并在使用 `replace` 指令进行本地工作时进行调整，或者根据需要排除某些依赖项。
- en: The go.sum file
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: go.sum 文件
- en: The `go.sum` file contains a list of checksums for the specific versions of
    the dependencies used in the project. These checksums are used to verify the integrity
    of downloaded package files.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`go.sum` 文件包含项目中使用的特定版本依赖项的校验和列表。这些校验和用于验证下载的包文件的完整性。'
- en: The `go.sum` file is automatically generated and maintained by the Go toolchain.
    It ensures that the downloaded packages have not been tampered with and that the
    project always uses the correct versions of the dependencies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`go.sum` 文件由 Go 工具链自动生成和维护。它确保下载的包未被篡改，并且项目始终使用依赖项的正确版本。'
- en: 'Here’s a simplified example of a `go.sum` file:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简化的 `go.sum` 文件示例：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The sample `go.sum` file’s contents in the preceding example demonstrate how
    to verify the integrity of downloaded package files for Go projects. This was
    a very simple example; however, in reality, the `go.sum` file can become quite
    large, depending on the size and amount of dependencies that a project may have.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，`go.sum` 文件的内容展示了如何验证 Go 项目的下载包文件的完整性。这是一个非常简单的例子；然而，在实际中，`go.sum` 文件可能会变得相当大，这取决于项目可能拥有的依赖项的大小和数量。
- en: How are modules helpful?
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块是如何有帮助的？
- en: Go modules offer many benefits that enhance the Go development experience. Let’s
    take a closer look at how Go modules are helpful.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Go 模块提供了许多增强 Go 开发体验的好处。让我们更深入地看看 Go 模块是如何有帮助的。
- en: Precise and simplified dependency management
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精确且简化的依赖项管理
- en: One of the most significant advantages of Go modules is their ability to provide
    precise control over dependencies. When specifying dependencies in your `go.mod`
    file, you can define the exact versions you need, which eliminates the guesswork
    and potential compatibility issues associated with less rigorous dependency management
    methods.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Go 模块最显著的优点之一是它们能够提供对依赖项的精确控制。当你在 `go.mod` 文件中指定依赖项时，你可以定义所需的精确版本，这消除了与不那么严格的依赖项管理方法相关的猜测工作和潜在兼容性问题。
- en: Go modules have streamlined the process of adding, updating, and managing dependencies.
    In the past, Go developers had to rely on the `GOPATH` and `vendor` directories,
    which could lead to version conflicts and make it challenging to manage dependencies.
    Go modules replace these practices with a more intuitive and efficient approach.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Go 模块简化了添加、更新和管理依赖项的过程。在过去，Go 开发者必须依赖于 `GOPATH` 和 `vendor` 目录，这可能导致版本冲突，并使依赖项管理变得具有挑战性。Go
    模块用更直观和高效的方法取代了这些做法。
- en: Versioning and reproducibility
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制和可重复性
- en: Go modules introduce a robust versioning system. Each module is tagged with
    a specific version identifier or commit hash. This meticulous version control
    ensures that your project relies on a consistent and known set of dependencies.
    It promotes reproducibility, meaning that you and your collaborators can recreate
    the same development environment effortlessly, reducing the “it works on my machine”
    problem.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Go 模块引入了一个健壮的版本控制系统。每个模块都带有特定的版本标识符或提交哈希。这种细致的版本控制确保你的项目依赖于一致且已知的依赖项集合。它促进了可重复性，这意味着你和你的合作者可以轻松地重新创建相同的发展环境，减少“在我的机器上它工作”的问题。
- en: Improved collaboration
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改善协作
- en: With well-defined modules, collaborating on Go projects becomes more accessible.
    Modules provide a clear boundary for your code, ensuring that it remains cohesive
    and self-contained. This makes it easier for you to share your work with others
    and for others to contribute to your projects without worrying about breaking
    existing functionality.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义良好的模块，在 Go 项目上进行协作变得更加容易。模块为你的代码提供了清晰的边界，确保它保持一致性和自包含。这使得你更容易与他人分享你的工作，其他人也可以在不担心破坏现有功能的情况下为你的项目做出贡献。
- en: Dependency safety
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖项安全性
- en: Go modules incorporate security measures through the `go.sum` file. By incorporating
    cryptographic checksums for all your project’s dependencies, as mentioned previously
    in this chapter, you can see how this safeguards against potential tampering or
    corruption of downloaded packages.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Go 模块通过 `go.sum` 文件整合了安全措施。通过在所有项目依赖项中包含前面章节中提到的加密校验和，你可以看到这是如何保护下载包免受潜在篡改或损坏的。
- en: Ease of use while promoting isolation and modularity
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在促进隔离和模块化的同时易于使用
- en: It is easy to see the benefits in which Go modules help our programs. Modules
    lead to easier maintenance on the development team through ease of use to understand,
    update, and track project dependencies. As projects evolve, it is easy to keep
    up with changes in external packages.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看到 Go 模块如何帮助我们的程序。模块通过易于理解、更新和跟踪项目依赖项，使开发团队更容易维护。随着项目的演变，很容易跟上外部包的变化。
- en: Go modules promote isolation and modularity. They also provide a natural mechanism
    for isolating your project from the global workspace. This isolation fosters modularity,
    allowing you to focus on building self-contained, reusable components that are
    easy to manage and share. This builds on the idiomatic nature of Go and promotes
    best practices for development teams for their Go projects.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Go模块促进了隔离和模块化。它们还提供了一个自然机制来隔离你的项目与全局工作空间。这种隔离促进了模块化，让你能够专注于构建自包含、可重用且易于管理和共享的组件。这建立在Go的惯用特性之上，并促进了开发团队在Go项目中的最佳实践。
- en: Go modules were officially introduced in Go 1.11, and they provide a more sophisticated,
    structured, and version-aware way of managing project dependencies. Developers
    are encouraged to migrate to Go modules for modern Go project development.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Go模块在Go 1.11版本中正式引入，它们提供了一种更复杂、结构化和版本感知的方式来管理项目依赖。鼓励开发者迁移到Go模块以进行现代Go项目开发。
- en: Exercise 09.01 – creating and using your first module
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习09.01 – 创建和使用你的第一个模块
- en: 'In this exercise, we will see how to create our first Go module with ease:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看到如何轻松地创建我们的第一个Go模块：
- en: 'Create a new directory called `bookutil` and navigate into it:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`bookutil`的新目录并进入它：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Initialize a Go module named `bookutil`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个名为`bookutil`的Go模块：
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Verify that `go.mod` is created within your project directory with the module
    path set as `bookutil`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`go.mod`是否在你的项目目录中创建，并且模块路径设置为`bookutil`。
- en: Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: No `go.sum` file is created after running `go mod init`. It will be generated
    and updated as you interact with your module and add to its dependencies.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`go mod init`之后不会创建`go.sum`文件。它将在你与模块交互并添加其依赖时生成和更新。
- en: Now, let’s create a Go package for the author information while focusing on
    functions related to book chapters by creating a directory named `author` within
    our module’s project directory.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在模块的项目目录内创建一个名为`author`的目录，以专注于通过创建与书籍章节相关的函数来创建一个Go包。
- en: Inside the `author` directory, create a file named `author.go` to define the
    package and functions.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`author`目录内，创建一个名为`author.go`的文件来定义包和函数。
- en: 'Here is the starting code for `author.go`:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是`author.go`的起始代码：
- en: '[PRE4]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we can add the necessary functions to create our author and define actions
    that our author can perform:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以添加必要的函数来创建我们的作者并定义作者可以执行的操作：
- en: '[PRE5]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With the author package defined, we can create a Go file in our module to demonstrate
    how to use it. Let’s name this file `main.go` at the root of our directory:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义了作者包后，我们可以在模块中创建一个Go文件来演示如何使用它。让我们将这个文件命名为`main.go`，放在我们的目录根目录下：
- en: '[PRE6]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Save the file in the folder and run the following command:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件夹中保存文件并运行以下命令：
- en: '[PRE7]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running the preceding code results in the following output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this exercise, we learned how to create a Go module and run a program using
    it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何创建Go模块并使用它来运行程序。
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Your Go module does not have to be named the same as your Go package since you
    can have many packages to one Go module and project. It is good practice to name
    your module based on the main purpose of the project.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你的Go模块不必与你的Go包同名，因为你可以有一个Go模块包含多个包，并且一个项目也可以有一个Go模块。根据项目的主要目的命名模块是一个好的实践。
- en: In this case, the primary purpose of the module is to manage and work with book
    chapters and authors, so the module’s name reflects the broader context. The name
    `bookutil` provides flexibility to include multiple packages related to book-related
    operations, including the `author` package.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，模块的主要目的是管理和处理书籍章节和作者，因此模块的名称反映了更广泛的环境。名称`bookutil`提供了灵活性，可以包括与书籍相关操作相关的多个包，包括`author`包。
- en: 'In addition, there are best practices for module naming, such as `<prefix>/<descriptive-text>`
    and `github.com/<project-name>/`, that you can read more about in the Go documentation:
    [https://go.dev/doc/modules/managing-dependencies#naming_module](https://go.dev/doc/modules/managing-dependencies#naming_module).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些关于模块命名的最佳实践，如`<prefix>/<descriptive-text>`和`github.com/<project-name/>`，你可以在Go文档中了解更多信息：[https://go.dev/doc/modules/managing-dependencies#naming_module](https://go.dev/doc/modules/managing-dependencies#naming_module)。
- en: Now that you have successfully created a Go module named `bookutil` with an
    `author` package focused on book chapters, let’s explore the importance of using
    external Go modules and how they can enhance your project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功创建了一个名为`bookutil`的Go模块，其中包含一个专注于书籍章节的`author`包，让我们来探讨使用外部Go模块的重要性以及它们如何增强你的项目。
- en: When should you use external modules, and why?
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你应该在何时使用外部模块，为什么？
- en: In Go development, leveraging external modules is a frequent practice that can
    benefit your projects. External modules, also known as third-party dependencies,
    offer many advantages when used judiciously. In this section, we will explore
    when to use external modules and the compelling reasons behind their adoption.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 开发中，利用外部模块是一种常见的做法，这可以给你的项目带来好处。外部模块，也称为第三方依赖，在合理使用时提供了许多优势。在本节中，我们将探讨何时使用外部模块以及它们被采用背后的有力理由。
- en: 'You should use external modules to do the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用外部模块来完成以下操作：
- en: Promote code reusability and efficiency
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高代码的可重用性和效率
- en: Expand project functionality
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展项目功能
- en: Offload dependency management
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转移依赖项管理
- en: Enable collaborative development with the open source community
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过开源社区促进协作开发
- en: Utilize proven reliability, community support, and documentation by open source
    code
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过开源代码利用经过验证的可靠性、社区支持和文档
- en: However, always exercise caution and select dependencies and modules that align
    with your project’s goals and long-term sustainability plans.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，始终要谨慎行事，选择与你的项目目标和长期可持续性计划相一致的依赖项和模块。
- en: Exercise 09.02 – using an external module within our module
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习 09.02 – 在我们的模块中使用外部模块
- en: 'Sometimes, in code, you need a unique identifier for an identity you provide
    to something. This unique identifier is often called a **universally unique identifier**
    (**UUID**). Google provides a package to create such a UUID. Let’s look at how
    to use it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在代码中，你需要为提供给某物的身份提供一个唯一的标识符。这个唯一的标识符通常被称为**通用唯一标识符**（**UUID**）。Google 提供了一个包来创建这样的
    UUID。让我们看看如何使用它：
- en: 'Create a new directory called `myuuidapp` and navigate into it:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `myuuidapp` 的新目录并进入它：
- en: '[PRE9]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Initialize a Go module named `myuuidapp`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个名为 `myuuidapp` 的 Go 模块：
- en: '[PRE10]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Verify that the `go.mod` file is created within your project directory with
    the module path set as `myuuidapp`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 `go.mod` 文件是否已创建在你的项目目录中，并将模块路径设置为 `myuuidapp`。
- en: Add a `main.go` file.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `main.go` 文件。
- en: 'In `main.go`, add the main package name to the top of the file:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中，将主包名添加到文件顶部：
- en: '[PRE11]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, add the imports we will use in this file:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加我们将在这个文件中使用的导入：
- en: '[PRE12]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create the `main()` function:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main()` 函数：
- en: '[PRE13]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Generate a new UUID using the external module package:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用外部模块包生成一个新的 UUID：
- en: '[PRE14]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Print the generated UUID:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印生成的 UUID：
- en: '[PRE15]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Close the `main()` function:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 `main()` 函数：
- en: '[PRE16]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Save the file and then run the following command to fetch the external dependencies,
    thereby updating your `go.mod` file with the dependency information:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，然后运行以下命令以获取外部依赖项，从而更新你的 `go.mod` 文件并包含依赖信息：
- en: '[PRE17]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Verify that our `go.mod` file has now been updated with the package dependency
    with a new `require` line. Your version number may be different for the package,
    depending on what release version they are on:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证我们的 `go.mod` 文件现在已更新为包含新的 `require` 行的包依赖项。根据它们的发布版本，你的包版本号可能不同：
- en: '[PRE18]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Verify that our `go.sum` file has now been updated with the new dependencies.
    Again, your version numbers may be different for the package, depending on what
    release version they are on:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证我们的 `go.sum` 文件现在已更新为新的依赖项。再次提醒，根据它们的发布版本，你的包版本号可能不同：
- en: '[PRE19]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码：
- en: '[PRE20]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running the preceding code results in the following output, with a random UUID:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出，包含一个随机的 UUID：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With that, you’ve learned how to use an external module’s package within your
    module by generating a unique identifier using Google’s open source code. In this
    example, we trusted that Google has well-tested code and that it meets the standards
    we set for our code base. If we ever want to upgrade or downgrade the version
    of the external package, then that is offloaded to our Go module. Next, we’ll
    look at expanding our understanding of modules by looking at when to use multiple
    modules within their project.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经学会了如何在你的模块中使用外部模块的包，通过使用 Google 的开源代码生成一个唯一的标识符。在这个例子中，我们相信 Google 有经过良好测试的代码，并且它符合我们为代码库设定的标准。如果我们想要升级或降级外部包的版本，那么这将被转移到我们的
    Go 模块上。接下来，我们将通过查看在项目中何时使用多个模块来扩展我们对模块的理解。
- en: Note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: More information on the UUID module and package can be found on GitHub at [https://github.com/google/uuid/tree/master](https://github.com/google/uuid/tree/master).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 UUID 模块和包的信息可以在 GitHub 上找到：[https://github.com/google/uuid/tree/master](https://github.com/google/uuid/tree/master)。
- en: Consuming multiple modules within a project
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在项目中消耗多个模块
- en: You can consume multiple Go modules within a project. Just as you saw with the
    Google module example earlier, you can use that module alongside other Go modules
    that you may need in your project.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在项目中消费多个 Go 模块。就像你之前看到的 Google 模块示例一样，你可以在项目中使用该模块，同时使用你可能需要的其他 Go 模块。
- en: Activity 9.01 – consuming multiple modules
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 9.01 – 消费多个模块
- en: 'In this activity, we will use multiple Go modules within our code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将在我们的代码中使用多个 Go 模块：
- en: Create a new UUID and print the UUID.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 UUID 并打印该 UUID。
- en: Fetch and print a random quote using the `rsc.io/quote` module.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `rsc.io/quote` 模块获取并打印一个随机引言。
- en: 'Your output should look like this, with a different UUID and a different random
    sentence for your second line:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应该看起来像这样，第二行有不同的 UUID 和不同的随机句子：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter09/Activity09.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter09/Activity09.01).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在本章 GitHub 仓库文件夹中找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter09/Activity09.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter09/Activity09.01).
- en: Defining multiple modules within a project
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在项目中定义多个模块
- en: The Go module system is designed to manage dependencies and versions for the
    entire module, not for subsets or subprojects within a module. However, there
    might be situations where you have multiple distinct components or subprojects
    within your main project, and each of these components or subprojects has dependencies
    and version requirements. In such cases, you can structure your project in a way
    that each component is its own module, separate from the main project module.
    These submodules can be maintained as separate Go modules, each with its own `go.mod`
    file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Go 模块系统旨在管理整个模块的依赖项和版本，而不是模块内的子集或子项目。然而，可能存在这样的情况，即你的主项目中有多个不同的组件或子项目，并且这些组件或子项目都有自己的依赖项和版本要求。在这种情况下，你可以以这种方式组织你的项目，即每个组件都是其自己的模块，与主项目模块分开。这些子模块可以作为独立的
    Go 模块进行维护，每个子模块都有自己的 `go.mod` 文件。
- en: 'For example, if you have a project with a main component and two other components,
    and each component has unique dependencies, you can structure your project like
    this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个包含主组件和其他两个组件的项目，并且每个组件都有独特的依赖项，你可以这样组织你的项目：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Each subcomponent/module (that is, `secondmodule` and `thirdmodule`) is treated
    as a separate Go module with its own `go.mod` file and dependencies.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每个子组件/模块（即 `secondmodule` 和 `thirdmodule`）被视为一个独立的 Go 模块，具有自己的 `go.mod` 文件和依赖项。
- en: 'It makes sense to create submodules in the following situations:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下情况下创建子模块是有意义的：
- en: '**Components have different dependencies**: When different components within
    your project have distinct sets of dependencies, creating submodules allows you
    to manage these dependencies separately'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件有不同的依赖项**：当项目中的不同组件有不同的依赖项集合时，创建子模块可以让你分别管理这些依赖项'
- en: '**There are separate versioning requirements**: If different components need
    different versions of the same dependency, using submodules can help manage these
    version conflicts more effectively'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有单独的版本要求**：如果不同的组件需要同一依赖项的不同版本，使用子模块可以帮助更有效地管理这些版本冲突'
- en: '**There’s component reusability**: When you intend to reuse a component across
    multiple projects, structuring it as a separate module can facilitate its reuse
    in various contexts'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有组件可重用性**：当你打算在多个项目中重用组件时，将其作为单独的模块可以促进其在各种环境中的重用'
- en: '**There’s maintainability**: Submodules can enhance code organization and maintainability
    as each component can be developed, tested, and maintained separately'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有可维护性**：子模块可以提高代码组织性和可维护性，因为每个组件都可以单独开发、测试和维护'
- en: While you can technically create submodules within a project, it is not a customary
    practice, and it should be done when there is a clear need for separate dependency
    management, versioning, or code organization for distinct components within your
    project. Each submodule should have its own `go.mod` file that defines its specific
    dependencies and version requirements.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然技术上可以在项目中创建子模块，但这不是常规做法，并且应该在需要为项目中的不同组件进行单独的依赖项管理、版本控制或代码组织时进行。每个子模块都应该有自己的
    `go.mod` 文件，该文件定义了其特定的依赖项和版本要求。
- en: Go workspaces
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 工作空间
- en: In Go 1.18, the *Go workspaces* feature was released, which improved the experience
    of working with multiple `Go` modules within the same project locally. Originally,
    when working with multiple Go modules in the same project, you would need to manually
    edit the Go module files for each module with the replace directive to use your
    local changes. Now, with Go workspaces, we can define a `go.work` file, specifying
    to use our local changes, and not have to worry about managing several `go.mod`
    files manually ourselves. This is particularly useful when working with larger
    projects, or projects that span multiple repositories.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go 1.18中，发布了*Go工作区*功能，这改善了在同一项目本地处理多个`Go`模块的体验。最初，当在同一项目中处理多个Go模块时，您需要手动为每个模块编辑Go模块文件，使用`replace`指令来使用您的本地更改。现在，使用Go工作区，我们可以定义一个`go.work`文件，指定使用我们的本地更改，而无需手动管理多个`go.mod`文件。这对于处理大型项目或跨多个存储库的项目尤其有用。
- en: Exercise 09.03 – working with workspaces
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习09.03 – 使用工作区
- en: 'In this exercise, we will look at what it used to be like when working with
    projects that had multiple Go modules that needed their dependencies to be replaced
    so that they could use local changes. We will then update the example code so
    that it uses Go workspaces to show the improvements:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将回顾在处理需要替换依赖项以使用本地更改的多个Go模块的项目时的情况。然后我们将更新示例代码，使其使用Go工作区来展示改进：
- en: Create a new folder called `printer` and add a `printer.go` file.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`printer`的新文件夹并添加一个`printer.go`文件。
- en: 'In `printer.go`, add the `printer` package name to the top of the file:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`printer.go`中，将`printer`包名添加到文件顶部：
- en: '[PRE24]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, add the imports we will use in this file:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加我们将在此文件中使用的导入：
- en: '[PRE25]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create the exported `PrintNewUUID()` function, returning a string:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建导出的`PrintNewUUID()`函数，返回一个字符串：
- en: '[PRE26]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Generate a new UUID using the external module package:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用外部模块包生成新的UUID：
- en: '[PRE27]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create and return a string to print the generated UUID:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并返回一个字符串以打印生成的UUID：
- en: '[PRE28]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Close the `PrintNewUUID()` function:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`PrintNewUUID()`函数：
- en: '[PRE29]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create a Go module and install the necessary dependencies:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Go模块并安装必要的依赖项：
- en: '[PRE30]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Go back a folder and create a new folder sitting side-by-side with the `printer`
    folder called `othermodule` and add a `main.go` file.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回退一个文件夹并创建一个与`printer`文件夹并排的新文件夹，命名为`othermodule`，并添加一个`main.go`文件。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将`main`包名添加到文件顶部：
- en: '[PRE31]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, add the imports we will use in this file:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加我们将在此文件中使用的导入：
- en: '[PRE32]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create the `main()` function:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE33]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Use the `PrintNewUUID()` function we defined in our `printer` module:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们在`printer`模块中定义的`PrintNewUUID()`函数：
- en: '[PRE34]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Print the generated UUID message string:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印生成的UUID消息字符串：
- en: '[PRE35]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Close the `main()` function:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main()`函数：
- en: '[PRE36]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Initialize a Go module named `othermodule`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化名为`othermodule`的Go模块：
- en: '[PRE37]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the module’s requirements:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加模块的要求：
- en: '[PRE38]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'View the error message when Go tries to retrieve the module dependencies; the
    `printer` package includes only local changes that are not published externally
    on GitHub:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看Go尝试检索模块依赖项时的错误消息；`printer`包仅包含未在GitHub上公开的本地更改：
- en: '[PRE39]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The old way of addressing this before Go workspaces included editing the Go
    module with a replacement inside the `othermodule` directory:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Go工作区之前解决此问题的旧方法包括在`othermodule`目录内编辑Go模块以替换内容：
- en: '[PRE40]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Verify that the `othermodule/go.mod` file was updated to include the following
    contents:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证`othermodule/go.mod`文件是否已更新以包含以下内容：
- en: '[PRE41]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we can successfully tidy our dependencies:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以成功整理我们的依赖项：
- en: '[PRE42]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Run the code:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码：
- en: '[PRE43]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Running the preceding code shows the following output, with a random UUID:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码，显示以下输出，包含一个随机UUID：
- en: '[PRE44]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We’ve just seen what the flow was like before Go workspaces were introduced.
    Now, let’s see what changes with this new feature.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了在引入Go工作区之前的工作流程。现在，让我们看看这个新功能带来的变化。
- en: 'Replace the entirety of `othermodule/go.mod` with the following contents:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`othermodule/go.mod`的全部内容替换为以下内容：
- en: '[PRE45]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Run the tidying command; you’ll see that the error finds the `printer` module:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行整理命令；您将看到错误找到`printer`模块：
- en: '[PRE46]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run the following command in the `printer` directory to initialize a Go workspace:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`printer`目录中运行以下命令以初始化Go工作区：
- en: '[PRE47]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Use your local changes within the workspace:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工作区中使用您的本地更改：
- en: '[PRE48]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Run the code:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下代码：
- en: '[PRE49]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Running the preceding code shows the following output, with a random UUID:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行前面的代码，显示以下输出，包含一个随机UUID：
- en: '[PRE50]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This exercise demonstrated the flow both before and after the Go workspaces
    feature was introduced. This feature gives developers a way to better manage local
    changes among larger projects and across different repositories that include multiple
    `go.mod` files that might need updating.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习演示了在引入 Go 工作空间功能之前和之后的流程。这个功能为开发者提供了一种更好地管理大型项目之间以及包含多个可能需要更新的 `go.mod`
    文件的不同存储库中的本地更改的方法。
- en: We’ve covered a lot of ground in this chapter. Let’s take a look at everything
    that we covered.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们覆盖了很多内容。让我们回顾一下我们所学到的所有内容。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the world of Go modules, beginning with an understanding
    of what modules are and how they provide structured project organization and management
    of project dependencies. We introduced the two key module files – `go.mod` and
    `go.sum` – that handle dependencies. We also delved into external modules, emphasizing
    their role in expanding project functionality and their impact on maintainability.
    We discussed using and consuming multiple modules in a single project, and the
    concept of Go workspaces for managing multiple modules within a project directory.
    Hands-on exercises and activities reinforced our understanding.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Go 模块的世界，从了解模块是什么以及它们如何提供结构化的项目组织和项目依赖管理开始。我们介绍了两个关键的模块文件——`go.mod`
    和 `go.sum`——它们负责处理依赖关系。我们还深入探讨了外部模块，强调它们在扩展项目功能以及对其可维护性产生的影响。我们讨论了在单个项目中使用和消费多个模块，以及
    Go 工作空间的概念，用于在项目目录内管理多个模块。动手练习和活动加深了我们的理解。
- en: In the next chapter, we will enhance our module understanding by covering how
    packages help keep projects more manageable for teams as they iterate, reuse,
    and maintain projects using packages.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过介绍包如何帮助团队在迭代、重用和维护项目时使项目更易于管理来增强我们对模块的理解。
