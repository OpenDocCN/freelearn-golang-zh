<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer127">
			<h1 id="_idParaDest-284" class="chapter-number"><a id="_idTextAnchor1405"/>10</h1>
			<h1 id="_idParaDest-285"><a id="_idTextAnchor1406"/>Packages Keep Projects Manageable</h1>
			<p class="callout-heading"><a id="_idTextAnchor1407"/>Overview</p>
			<p class="callout">This chapter aims to demonstrate the importance of the use of packages in our Go programs. We will discuss how packages can be used to assist our code in being more maintainable, reusable, and modular. In this chapter, you will see how they can be used to bring structure and organization to our code. This will also be seen in our exercises, activities, and some examples from the Go <span class="No-Break">standard library.</span></p>
			<p class="callout">By the end of the chapter, you will be able to describe a package and its structure and declare a package. You will learn to evaluate exported and unexported names in a package, create your own package, and import your custom package. You will also be able to distinguish between executable packages and non-executable packages and create an alias for <span class="No-Break">a package.</span></p>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor1408"/><a id="_idTextAnchor1409"/>Technical requirements</h1>
			<p>For this chapter, you'll require Go version 1.21 or higher. The code for this chapter can be found <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter10"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter10</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-287"><a id="_idTextAnchor1410"/>Introduction</h1>
			<p>In the previous chapter, we looked at interfaces. We saw how we can use interfaces to describe the behavior of a type. We also discovered that we can pass different types to functions that accept an interface, as long as the type satisfies the interface’s method sets. We also saw how we can achieve polymorphism <span class="No-Break">using interfaces.</span></p>
			<p>In this chapter, we will look at how Go organizes its code into packages. We will see how we can hide or expose different Go constructs such as<a id="_idIndexMarker688"/> structs, interfaces, functions, and more, using packages. Our programs have been rather small in the number of lines of code and in complexity to a certain extent. Most of our programs have been contained in a single code file, often named <strong class="source-inline">main.go</strong>, and inside a single package named <strong class="source-inline">main</strong>. Later in this chapter, we will explore the significance of <strong class="source-inline">package main</strong>, so do not be worried at this juncture if you do not understand it. This will not always be the case when you are working on a development team. Often, your code base can become rather large, with multiple files, multiple libraries, and multiple members of the team. It would be rather restrictive if we could not break our code into smaller, manageable parts. The Go programming language solves the complexity of managing large code bases with the ability to modularize similar concepts into packages. The creators of Go use packages for their own standard libraries to tackle this problem. In this book, you have been working with many Go packages, such as <strong class="source-inline">fmt</strong>, <strong class="source-inline">string</strong>, <strong class="source-inline">os</strong>, and <span class="No-Break">so on.</span></p>
			<p>Let’s look at an example of a package structure from the Go standard library. The Go <strong class="source-inline">strings</strong> package encapsulates string functions<a id="_idIndexMarker689"/> that manipulate strings. By keeping the <strong class="source-inline">strings</strong> package focused on only the functions that manipulate strings, we, as Go developers, know that this function should contain all that we need for <span class="No-Break">string manipulation.</span></p>
			<p>The Go <strong class="source-inline">strings</strong> package is structured as <span class="No-Break">follows (</span><a href="https://pkg.go.dev/strings#section-sourcefiles"><span class="No-Break">https://pkg.go.dev/strings#section-sourcefiles</span></a><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B18621_10_1.jpg" alt="Figure 10.1: The strings package along with the files contained within it as of Go 1.21" width="354" height="1112"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1: The strings package along with the files contained within it as of Go 1.21</p>
			<p>The preceding diagram shows the <strong class="source-inline">strings</strong> package and the files that are in the package. Each file in the <strong class="source-inline">strings</strong> package is named after the functionality it is supporting. The logical organization of the code<a id="_idIndexMarker690"/> goes from package to file. We can easily conclude that the <strong class="source-inline">strings</strong> package contains code for manipulating strings. We can then further conclude that the <strong class="source-inline">replace.go</strong> file contains functions for replacing strings. You can already see that the conceptual structure of packages can organize your code into modular chunks. You start with code that is working together to serve a purpose, string manipulation, and it gets stored in a package called <strong class="source-inline">strings</strong>. You can then further organize the code into <strong class="source-inline">.go</strong> files and name them according to their purpose. The next step is keeping functions in there that perform a single purpose that reflects the name of the file and the name of the package. We will discuss these conceptual ideas later in the chapter when we discuss <span class="No-Break">structuring code.</span></p>
			<p>It is important to develop software that is maintainable, reusable, and modular. Let’s briefly discuss each of these core components of <span class="No-Break">software development<a id="_idTextAnchor1411"/><a id="_idTextAnchor1412"/>.</span></p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor1413"/>Maintainable</h2>
			<p>For code to be maintainable, it must be <a id="_idIndexMarker691"/>easy to change, and any changes must have a low risk of having an adverse impact on the program. Maintainable code is easy to modify and extend and is readable. As code progresses through the different stages of the <strong class="bold">software development life cycle</strong> (<strong class="bold">SDLC</strong>), the cost<a id="_idIndexMarker692"/> of changes to the code increases. These changes can be due to bugs, enhancements, or a change in requirements. Costs also increase when code is not easily maintainable. Another reason that code needs to be maintainable is the need to be competitive in the industry. If your code is not easily maintainable, it may be hard to react to a competitor who is releasing a software feature that could be used to outsell your application. These are just some of the reasons for code needing to <span class="No-Break">be maintainab<a id="_idTextAnchor1414"/><a id="_idTextAnchor1415"/>le.</span></p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor1416"/>Reusable</h2>
			<p>Reusable code is code that can be<a id="_idIndexMarker693"/> used in new software. For example, I have code in my existing application that has a function that returns an address for my mailing application; that function may be used in a new piece of software. That function that returns the address could be used in my new software that returns a customer address for an order the customer <span class="No-Break">has placed.</span></p>
			<p>The advantages of having reusable code are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>It decreases future project costs by using <span class="No-Break">existing packages</span></li>
				<li>It decreases the time it takes to deliver an application, due to not having to reinvent <span class="No-Break">the wheel</span></li>
				<li>The quality of the program will increase through increased testing and <span class="No-Break">more usage</span></li>
				<li>More time can be spent on other areas of innovation during the <span class="No-Break">development cycle</span></li>
				<li>As your packages grow, it becomes easier to lay the foundations for future projects in a <span class="No-Break">timely manner</span></li>
			</ul>
			<p>It is easy to see the many<a id="_idIndexMarker694"/> benefits of making reusable code for <span class="No-Break">our proj<a id="_idTextAnchor1417"/><a id="_idTextAnchor1418"/>ects.</span></p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor1419"/>Modular</h2>
			<p>Modular and reusable code is related to a certain extent, in the sense that having modular code makes it more<a id="_idIndexMarker695"/> likely that it will be reusable. One of the prominent problems when developing code is the organization of the code. Finding code that performs a certain function in a large program that is unorganized would be near to impossible, and even finding out whether there is code that performs a certain task would be difficult to ascertain without some code organization. Modularization aids in that area. The idea is that each discrete task that your code performs has its own section of code located in a <span class="No-Break">specific spot.</span></p>
			<p>Go encourages you to develop maintainable, reusable, and modular code by using packages. It was designed to encourage good software practices. We will be diving into how Go utilizes packages to accomplish <span class="No-Break">those tasks:</span></p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B18621_10_2.jpg" alt="Figure 10.2: The types of code packages can provide" width="1089" height="410"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2: The types of code packages can provide</p>
			<p>In the next topic, we are going to discuss what a package is and what the components that make up a <span class="No-Break">package<a id="_idTextAnchor1420"/><a id="_idTextAnchor1421"/> are.</span></p>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor1422"/>What is a package?</h1>
			<p>Go follows the <strong class="bold">Don’t Repeat Yourself</strong> (<strong class="bold">DRY</strong>) principle. This means that you should not write the same code twice. Refactoring your code<a id="_idIndexMarker696"/> into functions is the first step of the DRY principle. What if you had <a id="_idIndexMarker697"/>hundreds or even thousands of functions that you used regularly? How would you keep track of all those functions? Some of those functions might even have common characteristics. You could have a group of functions that perform math operations, string manipulations, printing, or file-based operations. You may be thinking of breaking them up into <span class="No-Break">individual files:</span></p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B18621_10_3.jpg" alt="Figure 10.3: Group functions by files" width="1072" height="426"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3: Group functions by files</p>
			<p>That could alleviate some of the issues. However, what if your string’s functionality started to grow further? You would then have a ton of string functions in one file or even multiple files. Every program you build would also have to include all of the code for <strong class="source-inline">string</strong>, <strong class="source-inline">math</strong>, and <strong class="source-inline">io</strong>. You would be copying code to every application that you built. Bugs in one code base would have to be fixed in multiple programs. That kind of code structure is not maintainable, nor does it encourage code reusability. The packages in Go are the next step to organizing your code in a way that makes it easy to reuse the components of your code. The following diagram shows the progression of organizing code from functions to source files <span class="No-Break">to packages:</span></p>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B18621_10_4.jpg" alt="Figure 10.4: Code progression organization" width="968" height="98"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4: Code progression organization</p>
			<p>Go organizes its code for reusability into directories called packages. A package is essentially a directory inside your workspace that contains one or more Go source files, which is used for grouping<a id="_idIndexMarker698"/> code that performs a task. It exposes only the necessary parts in order for those using your package to get a job done. The package concept is akin to using directories to organize files on <span class="No-Break">a com<a id="_idTextAnchor1423"/><a id="_idTextAnchor1424"/>puter.</span></p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor1425"/>Package structure</h2>
			<p>It does not matter to Go how<a id="_idIndexMarker699"/> many different files are in a package. You should separate code into as many files as makes sense for readability and logic grouping. However, all the files that are in a package must live in the same directory. The source files should contain code that is related, meaning that if the package is for configuration parsing, you should not have code in there for connecting to a database. The basic structure of a package consists of a directory and contains one or more Go files and related code. The following diagram summarizes the core components of a <span class="No-Break">package structure:</span></p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B18621_10_5.jpg" alt="Figure 10.5: Package structure" width="1099" height="170"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5: Package structure</p>
			<p>One of the commonly used packages in Go is the <strong class="source-inline">strings</strong> package. It contains several Go files that are referred to in the Go documentation as package files. Package files are <strong class="source-inline">.go</strong> source files that are part of the package; <span class="No-Break">for example:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">builder.go</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">compare.go</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">reader.go</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">replace.go</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">search.go</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">stri<a id="_idTextAnchor1426"/><a id="_idTextAnchor1427"/>ngs.go</strong></span></li>
			</ul>
			<p>The files in the preceding list all play their part in sharing related code for string operations within the standard library. Before we discuss how to declare a package, we need to discuss proper Go<a id="_idIndexMarker700"/> naming conventions for <span class="No-Break">a package.</span></p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor1428"/>Package naming</h2>
			<p>The name of your package is <a id="_idIndexMarker701"/>significant. It represents what your package contains and identifies its purpose. You can think of a package name as self-documentation. Careful consideration needs to go into naming a package. The name of the package should be short and concise. It should not be verbose. Simple nouns are often chosen for a package name. The following would be poor names for <span class="No-Break">a package:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">stringconversion</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">synchronizationprimitives</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">measuringtime</strong></span></li>
			</ul>
			<p>Better alternatives would be <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">strconv</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">sync</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">time</strong></span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">strconv</strong>, <strong class="source-inline">sync</strong>, and <strong class="source-inline">time</strong> are actual Go packages found in the <span class="No-Break">standard library.</span></p>
			<p>Also, the styling of a package is something to take into consideration. The following would be poor style choices for a Go <span class="No-Break">package name:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">StringConversion</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">synchronization_primitives</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">measuringTime</strong></span></li>
			</ul>
			<p>In Go, package names should be all lowercase with no underscores. Don’t use camel-case or snake-case styling. There are multiple packages with <span class="No-Break">pluralized names.</span></p>
			<p>Abbreviations are encouraged, just as long as they are familiar or common in the programming community. The user of the package should easily understand what the package is used for just <a id="_idIndexMarker702"/>from its name; <span class="No-Break">for example:</span></p>
			<ul>
				<li><strong class="source-inline">strconv</strong> (<span class="No-Break">string conversion)</span></li>
				<li><strong class="source-inline">regexp</strong> (regular <span class="No-Break">expression search)</span></li>
				<li><span class="No-Break"><strong class="source-inline">sync</strong></span><span class="No-Break"> (synchronization)</span></li>
				<li><strong class="source-inline">os</strong> (<span class="No-Break">operating system)</span></li>
			</ul>
			<p>Avoid package names such as <strong class="source-inline">misc</strong>, <strong class="source-inline">util</strong>, <strong class="source-inline">common</strong>, or <strong class="source-inline">data</strong>. These package names make it harder for the user of your package to understand its purpose. In some cases, there is a deviation from these guidelines, but for the most part, it is something we should <span class="No-Break">strive for:</span></p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B18621_10_6.jpg" alt="Figure 10.6: Package naming conventions" width="642" height="642"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6: Package naming conventions</p>
			<p>You can see how there is almost an art to making a good package name. You want to be concise, descriptive, and clear on the package usage when picking package names. Now that we’ve discussed package names, let’s take a peek at <span class="No-Break">package decla<a id="_idTextAnchor1429"/><a id="_idTextAnchor1430"/>rations.</span></p>
			<h2 id="_idParaDest-294"><a id="_idTextAnchor1431"/>Package declarations</h2>
			<p>Every Go file starts with a package <a id="_idIndexMarker703"/>declaration. The package declaration is the name of the package. The first line of each file in a package must be the <span class="No-Break">package declaration:</span></p>
			<pre class="source-code">
package &lt;packageName&gt;</pre>			<p>Recall that the <strong class="source-inline">strings</strong> package from the standard library has the following Go <span class="No-Break">source files:</span></p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B18621_10_7.jpg" alt="Figure 10.7: The strings package along with the files contained within it as of Go 1.21" width="354" height="1112"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7: The strings package along with the files contained within it as of Go 1.21</p>
			<p>Each one of those files starts with a package declaration, even though they are all separate files. We will look at <a id="_idIndexMarker704"/>an example from the Go standard library. In the Go standard library, there is a package called <strong class="source-inline">strings\</strong>. It is made up of multiple files. We will only be looking at a snippet of code from the files in the package: <strong class="source-inline">builder.go</strong>, <strong class="source-inline">compare.go</strong>, and <strong class="source-inline">replace.go</strong>. We have removed comments and some code just to demonstrate that the package files start with the package name. There will be no output from the code snippet. This is an example of how Go organizes code into multiple files but in the same <span class="No-Break">package (</span><a href="https://golang.org/src/strings/builder.go"><span class="No-Break">https://golang.org/src/strings/builder.go</span></a><span class="No-Break">):</span></p>
			<pre class="source-code">
package strings
import (
    "unicode/utf8"
    "unsafe"
)
type Builder struct {
    addr *Builder // of receiver, to detect copies by value
    buf []byte
}
// https://golang.org/src/strings/compare.go
package strings
func Compare(a, b string) int {
    if a == b {
        return 0
    }
    if a &lt; b {
        return -1
    }
    return +1
}</pre>			<p>The full code is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Example10.01/strings.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Example10.01/strings.go</span></a><span class="No-Break">.</span></p>
			<p>All functions, types, and variables that are defined in the Go source file are accessible within that package. Though your package could spread across multiple files, it is all part of the same package. Internally, all code is accessible across the files. Simply stated, the code is visible within the package. Notice that not all of the code is visible outside of the package. The preceding <a id="_idIndexMarker705"/>snippet is from the official Go libraries. For a further explanation of the code, visit the links in the preceding <span class="No-Break">G<a id="_idTextAnchor1432"/><a id="_idTextAnchor1433"/>o snippet.</span></p>
			<h1 id="_idParaDest-295"><a id="_idTextAnchor1434"/>Exported and unexported code</h1>
			<p>Go has a very simple way to determine whether code is exported or unexported. Exported means that variables, types, functions, and so on are visible from outside of the package. Unexported means it is only visible <a id="_idIndexMarker706"/>from inside the package. If a function, type, variable, and so on starts with an uppercase letter, it is exportable; if it starts with<a id="_idIndexMarker707"/> a lowercase letter, it is unexportable. There are no access modifiers to be concerned with in Go. If the function name is capitalized, then it is exported, and if it is lowercase, then it <span class="No-Break">is unexported.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is good practice to only expose code that we want other packages to see. We should hide everything else that is not needed by <span class="No-Break">external packages.</span></p>
			<p>Let’s look at the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
package main
import (
    "strings"
    "fmt"
)
func main() {
    str := "found me"
    if strings.Contains(str, "found") {
        fmt.Println("value found in str")
    }
}</pre>			<p>This code snippet uses the <strong class="source-inline">strings</strong> package. We are calling a <strong class="source-inline">strings</strong> function called <strong class="source-inline">Contains</strong>. The <strong class="source-inline">strings.Contains</strong> function searches the <strong class="source-inline">str</strong> variable to see whether it has the<a id="_idIndexMarker708"/> value <strong class="source-inline">"found"</strong> within it. If <strong class="source-inline">"found"</strong> is within the <strong class="source-inline">str</strong> variable, the <strong class="source-inline">strings.Contains</strong> function will return <strong class="source-inline">true</strong>; if <strong class="source-inline">"found"</strong> is not within<a id="_idIndexMarker709"/> the <strong class="source-inline">str</strong> variable, the <strong class="source-inline">strings.Contains</strong> function will <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
strings.Contains(str, "found")</pre>			<p>To call the function, we prefix it with the package name and then the <span class="No-Break">function name.</span></p>
			<p>This function is exportable and thus is accessible to others outside of the <strong class="source-inline">strings</strong> package. We know it is an exported function because the first letter of the function <span class="No-Break">is capitalized.</span></p>
			<p>When you import a package, you only have access to the <span class="No-Break">exported names.</span></p>
			<p>We can validate whether the function exists in the <strong class="source-inline">strings</strong> package by looking at the <span class="No-Break"><strong class="source-inline">strings.go</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
// https://golang.org/src/strings/strings.go
// Contains reports whether substr is within s.
func Contains(s, substr string) bool {
    return Index(s, substr) &gt;= 0
}</pre>			<p>The next code snippet will attempt to access an unexported function in the <span class="No-Break"><strong class="source-inline">strings</strong></span><span class="No-Break"> package:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
    "strings"
)
func main() {
    str := "found me"
    slc := strings.explode(str, 3)
    fmt.Println(slc)
}</pre>			<p>The function is unexported<a id="_idIndexMarker710"/> because it starts with a lowercase letter. Only code within the package <a id="_idIndexMarker711"/>can access the function; it is not visible outside of <span class="No-Break">the package.</span></p>
			<p>The code is attempting to call an unexported function in the <strong class="source-inline">strings.go</strong> <span class="No-Break">package file:</span></p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B18621_10_8.jpg" alt="Figure 10.8: Program output" width="1098" height="146"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8: Program output</p>
			<p>The following code snippet is from the Go standard library <strong class="source-inline">strings</strong> package and from the <strong class="source-inline">strings.go</strong> file inside of that package (<a href="https://packt.live/2RMxXqh">https://packt.live/2RMxXqh</a>). You can see that the <strong class="source-inline">explode()</strong> function is unexportable because the function name starts with a <span class="No-Break">lowercase letter:</span></p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">main.go</p>
			<pre class="source-code">
1  // https://golang.org/src/strings/strings.go
2  // explode splits s into a slice of UTF-8 strings,
3  // one string per Unicode character up to a maximum of n (n &lt; 0 means no limit).
4  // Invalid UTF-8 sequences become correct encodings of U+FFFD.
5  func explode(s string, n int) []string {
6      l := utf8.RuneCountInString(s)
7      if n &lt; 0 || n &gt; l {
8          n = l
9      }
10      a := make([]string, n)
11      for i := 0; i &lt; n-1; i++ {
12          ch, size := utf8.DecodeRuneInString(s)
13          a[i] = s[:size]
14          s = s[size:]
15          if ch == utf8.RuneError {
16              a[i] = string(utf8.RuneError)</pre>			<p>The full code is<a id="_idIndexMarker712"/> available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Example10.02/strings.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Example10.02/strings.go</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor1435"/>Package alias</h2>
			<p>Go also has the ability to alias package names. There are a few reasons that you may want to use <span class="No-Break">alias names:</span></p>
			<ul>
				<li>The package name may not <a id="_idIndexMarker713"/>make it easy to understand its purpose. For clarity, it might be better to alias (use) a different name for <span class="No-Break">the package.</span></li>
				<li>The package name might be too long. In this case, you want the alias to be more concise and <span class="No-Break">less verbose.</span></li>
				<li>There could be scenarios where the package path is unique but both package names are the same. You would need to then use aliasing to differentiate between the <span class="No-Break">two packages.</span></li>
			</ul>
			<p>The package-aliasing syntax is very simple. You place the alias name before the <strong class="source-inline">import</strong> <span class="No-Break">package path:</span></p>
			<pre class="source-code">
import "fmt"</pre>			<p>Here is a simple example showing how to use <span class="No-Break">package aliasing:</span></p>
			<pre class="source-code">
package main
import (
    f "fmt")
func main() {
    f.Println("Hello, Gophers")</pre>			<p>We are aliasing the <strong class="source-inline">fmt</strong> package <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">f</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    f.Println("Hello, Gophers")</pre>			<p>In the <strong class="source-inline">main()</strong> function, we are<a id="_idIndexMarker714"/> now able to call the <strong class="source-inline">Println()</strong> function <a id="_idTextAnchor1436"/><a id="_idTextAnchor1437"/>using the <span class="No-Break"><strong class="source-inline">f</strong></span><span class="No-Break"> alias.</span></p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor1438"/>Main package</h2>
			<p>The <strong class="source-inline">main</strong> package is a special package. There<a id="_idIndexMarker715"/> are two basic types of packages in Go: executable and non-executable. The <strong class="source-inline">main</strong> package is an executable package in Go. Logic that resides in this package may not be consumed by other packages. The <strong class="source-inline">main </strong>package requires there to be a <strong class="source-inline">main()</strong> function in its package. The <strong class="source-inline">main()</strong> function is the entry point for a Go executable. When you perform <strong class="source-inline">go build</strong> on the <strong class="source-inline">main</strong> package, it will compile the package and create a binary. The binary is created inside the directory where the <strong class="source-inline">main</strong> package is located. The name of the binary will be the name of the folder it <span class="No-Break">resides in:</span></p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B18621_10_9.jpg" alt="Figure 10.9: Why main package is special" width="1207" height="594"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9: Why main package is special</p>
			<p>Here’s a simple<a id="_idIndexMarker716"/> example of the <strong class="source-inline">main</strong> <span class="No-Break">package code:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
)
func main() {
    fmt.Println("Hello Gophers!")
}</pre>			<p>The expected output is <span class="No-Break">as foll<a id="_idTextAnchor1439"/><a id="_idTextAnchor1440"/>ows:</span></p>
			<pre class="console">
Hello Gophers!</pre>			<h2 id="_idParaDest-298"><a id="_idTextAnchor1441"/>Exercise 10.01 – Creating a package to calculate areas of various shapes</h2>
			<p>In <a href="B18621_07.xhtml#_idTextAnchor1291"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Getting Flexible with Interfaces</em>, we implemented code to calculate areas of different shapes. In this exercise, we will <a id="_idIndexMarker717"/>move all the code about shapes into a package called <strong class="source-inline">shape</strong>. We will then update the code in the <strong class="source-inline">shape</strong> package to be exportable. Then, we will update <strong class="source-inline">main</strong> to import our new <strong class="source-inline">shape</strong> package. However, we want it to still perform the same functionality in the <strong class="source-inline">main()</strong> function of the <span class="No-Break"><strong class="source-inline">main </strong></span><span class="No-Break">package.</span></p>
			<p>Here is the code that we will be converting <span class="No-Break">into packages:</span></p>
			<p><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Exercise07.02/main.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Exercise07.02/main.go</span></a></p>
			<p>You should have a directory structure, as displayed in the <a id="_idTextAnchor1442"/><span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B18621_10_10.jpg" alt="Figure 10.10: Program directory structure" width="1009" height="314"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10: Program directory structure</p>
			<p>The <strong class="source-inline">shape.go</strong> file should contain the entire <span class="No-Break">code: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.01/pkg/shape/shape.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.01/pkg/shape/shape.go</span></a><span class="No-Break">.</span></p>
			<p>We will only be going over changes that are relevant to making this code a package; for details on the parts of the code that we have gone over in a previous chapter, please see <a href="B18621_07.xhtml#_idTextAnchor1291"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Getting Flexible </em><span class="No-Break"><em class="italic">with Interfaces</em></span><span class="No-Break">:</span></p>
			<ol>
				<li>Create a directory called <strong class="source-inline">Exercise10.01</strong> <span class="No-Break">inside </span><span class="No-Break"><strong class="source-inline">Chapter10</strong></span><span class="No-Break">.</span></li>
				<li>Create a new Go module within the <span class="No-Break"><strong class="source-inline">Exercise10.01</strong></span><span class="No-Break"> directory:</span><pre class="source-code">
go mod init exercise10.01</pre></li>				<li>Create two more directories called <strong class="source-inline">cmd</strong> and a nested directory of <strong class="source-inline">pkg/shape</strong> inside the <span class="No-Break"><strong class="source-inline">Exercise10.01</strong></span><span class="No-Break"> directory.</span></li>
				<li>Create a file called <strong class="source-inline">main.go</strong> inside the <span class="No-Break"><strong class="source-inline">Exercise10.01/cmd</strong></span><span class="No-Break"> directory.</span></li>
				<li>Create a file<a id="_idIndexMarker718"/> called <strong class="source-inline">shape.go</strong> inside the <span class="No-Break"><strong class="source-inline">Exercise10.01/pkg/shape</strong></span><span class="No-Break"> directory.</span></li>
				<li>Open the <span class="No-Break"><strong class="source-inline">Exercise10.01/pkg/shape.go</strong></span><span class="No-Break"> file.</span></li>
				<li>Add the <span class="No-Break">following code:</span><pre class="source-code">
package shape
import "fmt"</pre><p class="list-inset">The first line of code in this file tells us this is a non-executable package called <strong class="source-inline">shape</strong>. A non-executable package, when compiled, does not result in binary or executable code. Recall that the <strong class="source-inline">main</strong> package is an <span class="No-Break">executable package.</span></p></li>				<li>Next, we need to make the types exportable. For each <strong class="source-inline">struct</strong> type, we have to capitalize on the type name<a id="_idIndexMarker719"/> and its fields to make it exportable. Exportable means that it is visible outside of <span class="No-Break">this package:</span><pre class="source-code">
type Shape interface {
    area() float64
    name() string
}
type Triangle struct {
    Base float64
    Height float64
}
type Rectangle struct {
    Length float64
    Width float64
}
type Square struct {
    Side float64
}</pre></li>				<li>We also have to make the methods non-exportable by changing the method name to lowercase. There is no need at the moment to make those methods visible outside of <span class="No-Break">the package.</span></li>
				<li>The <strong class="source-inline">shape.go</strong> file contents should now include <span class="No-Break">the following:</span><pre class="source-code">
func PrintShapeDetails(shapes ...Shape) {
    for _, item := range shapes {
        fmt.Printf("The area of %s is: %.2f\n", item.name(), item.area())
    }
}
func (t Triangle) area() float64 {
    return (t.Base * t.Height) / 2
}
func (t Triangle) name() string {
    return "Triangle"
}
func (r Rectangle) area() float64 {
    return r.Length * r.Width
}
func (r Rectangle) name() string {
    return "Rectangle"
}
func (s Square) area() float64 {
    return s.Side * s.Side
}
func (s Square) name() string {
    return "Square"
}</pre></li>				<li>The full code for this step is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.01/pkg/shape/shape.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.01/pkg/shape/shape.go</span></a><span class="No-Break">.</span></li>
				<li>The <strong class="source-inline">PrintShapeDetails()</strong> function<a id="_idIndexMarker720"/> also needs to <span class="No-Break">be capitalized:</span><pre class="source-code">
func PrintShapeDetails(shapes ...Shape) {
    for _, item := range shapes {
        fmt.Printf("The area of %s is: %.2f\n", item.name(), item.area())
    }
}</pre></li>				<li>Perform a build to ensure that there are no <span class="No-Break">compilation errors:</span><pre class="source-code">
go build</pre></li>				<li>Here is the listing for the <strong class="source-inline">main.go</strong> file. By having a package as <strong class="source-inline">main</strong>, we know that this <span class="No-Break">is executable:</span><pre class="source-code">
package main</pre></li>				<li>The <strong class="source-inline">import</strong> declaration only has one import. It is the <strong class="source-inline">shape</strong> package. We can see the name of the package is <strong class="source-inline">shape</strong> since it is the last directory name in the path declaration. The path for where my package is located may differ <span class="No-Break">from yours:</span><pre class="source-code">
import  "exercise10.01/pkg/shape"</pre></li>				<li>In the <strong class="source-inline">main()</strong> function, we are initializing the <strong class="source-inline">shape</strong> package’s <span class="No-Break">exportable types:</span><pre class="source-code">
func main() {
    t := shape.Triangle{Base: 15.5, Height: 20.1}
    r := shape.Rectangle{Length: 20, Width: 10}
    s := shape.Square{Side: 10}</pre></li>				<li>We then call the <strong class="source-inline">shape()</strong> function, <strong class="source-inline">PrintShapeDetails</strong>, to get the area of <span class="No-Break">each shape:</span><pre class="source-code">
    shape.PrintShapeDetails(t, r, s)
}</pre></li>				<li>At the command line, go <a id="_idIndexMarker721"/>to the <strong class="source-inline">Exercise10.01/cmd</strong> <span class="No-Break">directory structure.</span></li>
				<li>Type <span class="No-Break">the following:</span><pre class="source-code">
go build</pre></li>				<li>The <strong class="source-inline">go build</strong> command will compile your program and create an executable named after the <span class="No-Break">directory, </span><span class="No-Break"><strong class="source-inline">cmd</strong></span><span class="No-Break">.</span></li>
				<li>Type the executable name and <span class="No-Break">hit </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">:</span><pre class="source-code">
./cmd</pre></li>			</ol>
			<p>The expected output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
The area of Triangle is: 155.78
The area of Rectangle is: 200.00
The area of Square is 100.00</pre>			<p>We now have the functionality that we previously had in the interface chapter’s implementation of <strong class="source-inline">shape</strong>. We have the <strong class="source-inline">shape</strong> functionality now encapsulated in the <strong class="source-inline">shape</strong> package. We exposed or made visible only functions or methods that are needed to maintain the previous implementation. The <strong class="source-inline">main</strong> package has less clutter and imports the local <strong class="source-inline">shape</strong> package to <a id="_idIndexMarker722"/>provide the functionality that was in the <a id="_idTextAnchor1443"/><a id="_idTextAnchor1444"/><span class="No-Break">previous implementation.</span></p>
			<h1 id="_idParaDest-299"><a id="_idTextAnchor1445"/>The init() function</h1>
			<p>As we have discussed, every Go<a id="_idIndexMarker723"/> program (executable) starts in the <strong class="source-inline">main</strong> package and the entry point is the <strong class="source-inline">main()</strong> function. There is another special function that we should be aware of, called <strong class="source-inline">init()</strong>. Each source file can have an <strong class="source-inline">init()</strong> function, but for now, we will look at the <strong class="source-inline">init()</strong> function in the context of the <strong class="source-inline">main</strong> package. When you start writing packages, you might need to provide some initialization (the <strong class="source-inline">init()</strong> function) for the package. The <strong class="source-inline">init()</strong> function is used to set up states or values. The <strong class="source-inline">init()</strong> function adds initialization logic for your package. Here are some examples of uses of the <span class="No-Break"><strong class="source-inline">init()</strong></span><span class="No-Break"> function:</span></p>
			<ul>
				<li>Setting database objects <span class="No-Break">and connections</span></li>
				<li>The initialization of <span class="No-Break">package variables</span></li>
				<li><span class="No-Break">Creating files</span></li>
				<li>Loading <span class="No-Break">configuration data</span></li>
				<li>Verifying or repairing the <span class="No-Break">program state</span></li>
			</ul>
			<p>The <strong class="source-inline">init()</strong> function requires <span class="No-Break">the following:</span></p>
			<ul>
				<li>Imported packages are <span class="No-Break">initialized first</span></li>
				<li>Package-level variables <span class="No-Break">are initialized</span></li>
				<li>The package’s <strong class="source-inline">init()</strong> function <span class="No-Break">is called</span></li>
				<li><strong class="source-inline">main()</strong> <span class="No-Break">is executed</span></li>
			</ul>
			<p>The following diagram shows the execution order that a typical Go <span class="No-Break">program follows:</span></p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B18621_10_11.jpg" alt="Figure 10.11: Order of execution" width="722" height="546"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11: Order of execution</p>
			<p>Here is a simple example that<a id="_idIndexMarker724"/> demonstrates the <strong class="source-inline">package main</strong> order <span class="No-Break">of execution:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
)
var name = "Gopher"
func init() {
    fmt.Println("Hello,", name)
}
func main() {
    fmt.Println("Hello, main function")
}</pre>			<p>The output of the code is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Hello, Gopher
Hello, main function</pre>			<p>Let’s understand the code <span class="No-Break">in parts:</span></p>
			<pre class="source-code">
var name = "Gopher"</pre>			<p>Based on the output of the code, the package-level variable declaration gets executed first. We know this because the <strong class="source-inline">name</strong> variable is <a id="_idIndexMarker725"/>printed in the <span class="No-Break"><strong class="source-inline">init()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func init() {
    fmt.Println("Hello,", name)
}</pre>			<p>The <strong class="source-inline">init()</strong> function then gets called and prints out <strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">Hello, Gopher"</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func main() {
    fmt.Println("Hello, main function")
}</pre>			<p>Finally, the <strong class="source-inline">main()</strong> function <span class="No-Break">is executed:</span></p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B18621_10_12.jpg" alt="Figure 10.12: Execution flow of the code snippet" width="706" height="370"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12: Execution flow of the code snippet</p>
			<p>The <strong class="source-inline">init()</strong> function cannot have any arguments or <span class="No-Break">return values:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
)
var name = "Gopher"
func init(age int) {
    fmt.Println("Hello, ", name)
}
func main() {
    fmt.Println("Hello, main function")
}</pre>			<p>Running this code snippet will result in <a id="_idIndexMarker726"/>the <span class="No-Break">following error:</span></p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/B18621_10_13.jpg" alt="Figure 10.13: Program output" width="1178" height="114"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Fig<a id="_idTextAnchor1446"/><a id="_idTextAnchor1447"/>ure 10.13: Program output</p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor1448"/>Exercise 10.02 – Loading budget categories</h2>
			<p>Write a program that will load budget categories into a <a id="_idIndexMarker727"/>global map, before the <strong class="source-inline">main()</strong> function runs. The <strong class="source-inline">main()</strong> function should then print out the data on <span class="No-Break">the map:</span></p>
			<ol>
				<li>Create a <span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break"> file.</span></li>
				<li>The code file will belong to <strong class="source-inline">package main</strong> and will need to import the <span class="No-Break"><strong class="source-inline">fmt</strong></span><span class="No-Break"> package:</span><pre class="source-code">
package main
import "fmt"</pre></li>				<li>Create a global variable that will contain a map of budget categories with a key of <strong class="source-inline">int</strong> and a value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break">:</span><pre class="source-code">
var budgetCategories = make(map[int]string)</pre></li>				<li>We will need to use an <strong class="source-inline">init()</strong> function to load our budget categories before <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> runs:</span><pre class="source-code">
func init() {
    fmt.Println("Initializing our budgetCategories")
    budgetCategories[1] = "Car Insurance"
    budgetCategories[2] = "Mortgage"
    budgetCategories[3] = "Electricity"
    budgetCategories[4] = "Retirement"
    budgetCategories[5] = "Vacation"
    budgetCategories[7] = "Groceries"
    budgetCategories[8] = "Car Payment"
}</pre></li>				<li>Since our budget categories have<a id="_idIndexMarker728"/> been loaded, we can now iterate over the map and <span class="No-Break">print them:</span><pre class="source-code">
func main() {
    for k, v := range budgetCategories {
        fmt.Printf("key: %d, value: %s\n", k, v)
    }
}</pre></li>			</ol>
			<p>We will get the <span class="No-Break">following output:</span></p>
			<pre class="console">
Initializing our budgetCategories
key: 5, value: Vacation
key: 7, value: Groceries
key: 8, value: Car Payment
key: 1, value: Car Insurance
key: 2, value: Mortgage
key: 3, value: Electricity
key: 4, value: Retirement</pre>			<p class="callout-heading">Note</p>
			<p class="callout">The output may differ in terms of the order displayed; Go maps do not guarantee the order <span class="No-Break">of data.</span></p>
			<p>The aim here was to <a id="_idIndexMarker729"/>demonstrate how the <strong class="source-inline">init()</strong> function can be used to perform data initialization and loading before the <strong class="source-inline">main()</strong> function executes. Data that generally needs to be loaded before <strong class="source-inline">main()</strong> runs is static data, such as picklist values or some sort of configuration. As demonstrated, after the data gets loaded through the <strong class="source-inline">init()</strong> function, it can be used by the <strong class="source-inline">main()</strong> function. In the next topic, we will see how multiple <strong class="source-inline">in<a id="_idTextAnchor1449"/><a id="_idTextAnchor1450"/>it()</strong> functions <span class="No-Break">get executed.</span></p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor1451"/>Executing multiple init() functions</h2>
			<p>There can be more than one <strong class="source-inline">init()</strong> function in a<a id="_idIndexMarker730"/> package. This enables you to modularize your initialization for better code maintenance. For example, suppose you need to set up various files and database connections and repair the state of the environment your program will be executed in. Doing all that in one <strong class="source-inline">init()</strong> function would make it complicated for maintaining and debugging. The order of execution of multiple <strong class="source-inline">init()</strong> functions is the order in which the functions are placed in <span class="No-Break">the code:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
)
var name = "Gopher"
func init() {
    fmt.Println("Hello,", name)
}
func init() {
    fmt.Println("Second")
}
func init() {
    fmt.Println("Third")
}
func main() {
    fmt.Println("Hello, main function")
}</pre>			<p>Let’s break the code into parts and <a id="_idIndexMarker731"/><span class="No-Break">evaluate it:</span></p>
			<pre class="source-code">
var name = "Gopher"</pre>			<p>Go initializes the <strong class="source-inline">name</strong> variable first, before the <strong class="source-inline">init()</strong> function <span class="No-Break">gets executed:</span></p>
			<pre class="source-code">
func init() {
    fmt.Println("Hello,", name)
}</pre>			<p>This prints out first since it is the first <strong class="source-inline">init</strong> in <span class="No-Break">the function:</span></p>
			<pre class="source-code">
func init() {
    fmt.Println("Second")
}</pre>			<p>The preceding gets printed out second since it is the second <strong class="source-inline">init</strong> in <span class="No-Break">the function:</span></p>
			<pre class="source-code">
func init() {
    fmt.Println("Third")
}</pre>			<p>The preceding gets printed out third since it is the third <strong class="source-inline">init</strong> in <span class="No-Break">the function:</span></p>
			<pre class="source-code">
func main() {
    fmt.Println("Hello, main function")
}</pre>			<p>Finally, the <strong class="source-inline">main()</strong> function<a id="_idIndexMarker732"/> <span class="No-Break">gets executed.</span></p>
			<p>The results would be <span class="No-Break">as follows:</span></p>
			<pre class="console">
Hello, Gopher
Se<a id="_idTextAnchor1452"/><a id="_idTextAnchor1453"/>cond
Third
Hello, main function</pre>			<h2 id="_idParaDest-302"><a id="_idTextAnchor1454"/>Exercise 10.03 – Assigning payees to budget categories</h2>
			<p>We are going to expand our program from <em class="italic">Exercise 10.02</em>, <em class="italic">Loading budget categories</em>, to now assign payees to <a id="_idIndexMarker733"/>budget categories. This is similar to many budgeting applications that try to match payees to commonly used categories. We will then print the mapping of a payee to <span class="No-Break">a category:</span></p>
			<ol>
				<li>Create a <span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break"> file.</span></li>
				<li>Copy the code from <em class="italic">Exercise 10.02</em>, <em class="italic">Loading Budget Categories</em>, (https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.02/main.go) into the <span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break"> file.</span></li>
				<li>Add a <strong class="source-inline">payeeToCategory</strong> map <span class="No-Break">after </span><span class="No-Break"><strong class="source-inline">budgetCategories</strong></span><span class="No-Break">:</span><pre class="source-code">
var budgetCategories = make(map[int]string)
var payeeToCategory = make(map[string]int)</pre></li>				<li>Add another <strong class="source-inline">init()</strong> function. This <strong class="source-inline">init()</strong> function will be used to populate our new <strong class="source-inline">payeeToCategory</strong> map. We will assign payees to the key value of <span class="No-Break">the categories:</span><pre class="source-code">
func init() {
    fmt.Println("Initializing our budgetCategories")
    budgetCategories[1] = "Car Insurance"
    budgetCategories[2] = "Mortgage"
    budgetCategories[3] = "Electricity"
    budgetCategories[4] = "Retirement"
    budgetCategories[5] = "Vacation"
    budgetCategories[7] = "Groceries"
    budgetCategories[8] = "Car Payment"
}</pre></li>				<li>The full code for this step is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.03/main.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.03/main.go</span></a><span class="No-Break">.</span></li>
				<li>In the <strong class="source-inline">main()</strong> function, we will print out <a id="_idIndexMarker734"/>the payees to categories. We iterate over the <strong class="source-inline">payeeToCategory</strong> map, printing the key (<strong class="source-inline">payee</strong>). We print the category by passing the value of the <strong class="source-inline">payeeToCategory</strong> map as a key to the <span class="No-Break"><strong class="source-inline">budgetCategories</strong></span><span class="No-Break"> map:</span><pre class="source-code">
func main() {
    fmt.Println("In main, printing payee to category")
    for k, v := range payeeToCategory {
        fmt.Printf("Payee: %s, Category: %s\n", k, budgetCategories[v])
    }
}</pre></li>			</ol>
			<p>Here’s the <span class="No-Break">expected output:</span></p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/B18621_10_14.jpg" alt="Figure 10.14: Assigning a payee to budget categories" width="742" height="336"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14: Assigning a payee to budget categories</p>
			<p>You have now created a program that <a id="_idIndexMarker735"/>executes multiple <strong class="source-inline">init()</strong> functions before the execution of the <strong class="source-inline">main()</strong> function. Each of the <strong class="source-inline">init()</strong> functions loaded data into our global map variables. We have determined the order of <strong class="source-inline">init()</strong> functions executing because of the <strong class="source-inline">print</strong> statements that get displayed. This demonstrates that the <strong class="source-inline">init()</strong> functions print in the order they are present in the code. It is important to be aware of the order of your <strong class="source-inline">init()</strong> functions as you may have unforeseen results based on the order of the <span class="No-Break">code execution.</span></p>
			<p>In the upcoming activity, we will be using all these concepts that we have looked at with packages an<a id="_idTextAnchor1455"/><a id="_idTextAnchor1456"/>d see how they all <span class="No-Break">work together.</span></p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor1457"/>Activity 10.01 – Creating a function to calculate payroll and performance review</h2>
			<p>In this activity, we are going to take <em class="italic">Activity 7.01</em>, <em class="italic">Calculating pay and performance review</em>, from <a href="B18621_07.xhtml#_idTextAnchor1291"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> and modularize it <a id="_idIndexMarker736"/>using packages. We will be refactoring the code <span class="No-Break">from </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Activity7.01/main.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Activity7.01/main.go</span></a><span class="No-Break">:</span></p>
			<ol>
				<li>Move the types and methods of <strong class="source-inline">Developer</strong>, <strong class="source-inline">Employee</strong>, and <strong class="source-inline">Manager</strong> into their own package under <strong class="source-inline">pkg/payroll</strong>. Types, methods, and functions must be properly exported <span class="No-Break">or unexported.</span></li>
				<li>Name the <span class="No-Break">package </span><span class="No-Break"><strong class="source-inline">payroll</strong></span><span class="No-Break">.</span></li>
				<li>Logically separate the types and their methods into different package files. Recall that good code organization involves separating similar functionality into <span class="No-Break">separate files.</span></li>
				<li>Create a <strong class="source-inline">main()</strong> function as an alias to the <span class="No-Break"><strong class="source-inline">payroll</strong></span><span class="No-Break"> package.</span></li>
				<li>Introduce two <strong class="source-inline">init()</strong> functions in the <strong class="source-inline">main</strong> package under the <strong class="source-inline">cmd</strong> directory. The first <strong class="source-inline">init()</strong> function should simply print a greeting message to <strong class="source-inline">stdout</strong>. The second <strong class="source-inline">init()</strong> function should initialize/set up <span class="No-Break">key-value pairs.</span></li>
			</ol>
			<p>The expected output would be <span class="No-Break">as follows:</span></p>
			<pre class="console">
Welcome to the Employee Pay and Performance Review
++++++++++++++++++++++++++++++++++++++++++++++++++
Initializing variables
Eric Davis got a review rating of 2.80
Eric Davis got paid 84000.00 for the year
Mr. Boss got paid 160500.00 for the year</pre>			<p>In this activity, we have seen<a id="_idIndexMarker737"/> how to use packages to separate our code and then logically separate the code into individual files. We can see that each of those files makes up a package. Each file of the package has internal access to the other files regardless of the fact that they are in separate files. This activity demonstrates how to create a package with multiple files and how those separate files can be used to further organize <span class="No-Break">our code.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found in<a id="_idTextAnchor1458"/><a id="_idTextAnchor1459"/> the GitHub repository folder for this chapter: <a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter10/Activity10.01"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter10/Activity10.01</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor1460"/>Summary</h1>
			<p>In this chapter, we looked at the importance of developing software that is maintainable, reusable, and modular. We discovered how Go’s packages play an important part in meeting those criteria for developing software. We looked at the overall structure of a package. It is made up of a directory, can contain one or more files, and has code that is related. A package is essentially a directory inside of your workspace that contains one or more files that are used for grouping code that is to perform a task. It exposes only the necessary parts to those using your package to get a job done. We discussed the importance of naming packages properly. We also learned how to name a package; that is, concisely, in lowercase, descriptively, using non-plural names, and avoiding generic names. Packages can be executable or non-executable. If a package is the <strong class="source-inline">main</strong> package, then it is an executable package. The <strong class="source-inline">main</strong> package must have a <strong class="source-inline">main()</strong> function, and that is where the entry point is for <span class="No-Break">our package.</span></p>
			<p>We also talked about what is exportable and unexportable code. When we capitalize the name of a function, type, or method, it is visible to others using our package. Lowercasing a function, type, or method makes it not visible to other users from outside our package. We learned that <strong class="source-inline">init()</strong> functions can perform the following duties: initializing variables, loading configuration data, setting database connections, or verifying that our program state is ready for execution. <strong class="source-inline">init()</strong> functions have certain rules when they get executed and on how to utilize them. This chapter will help you to write highly manageable, reusable, and <span class="No-Break">modular code.</span></p>
			<p>In the ne<a id="_idTextAnchor1461"/>xt chapter, we will start exploring debugging skills, a crucial aspect of software development. This will include learning about effective troubleshooting to enable a robust <span class="No-Break">development experience.</span></p>
		</div>
	</div></div></body></html>