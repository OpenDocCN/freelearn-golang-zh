- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packages Keep Projects Manageable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter aims to demonstrate the importance of the use of packages in our
    Go programs. We will discuss how packages can be used to assist our code in being
    more maintainable, reusable, and modular. In this chapter, you will see how they
    can be used to bring structure and organization to our code. This will also be
    seen in our exercises, activities, and some examples from the Go standard library.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to describe a package and its structure
    and declare a package. You will learn to evaluate exported and unexported names
    in a package, create your own package, and import your custom package. You will
    also be able to distinguish between executable packages and non-executable packages
    and create an alias for a package.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you''ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter10](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter10).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at interfaces. We saw how we can use interfaces
    to describe the behavior of a type. We also discovered that we can pass different
    types to functions that accept an interface, as long as the type satisfies the
    interface’s method sets. We also saw how we can achieve polymorphism using interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at how Go organizes its code into packages. We
    will see how we can hide or expose different Go constructs such as structs, interfaces,
    functions, and more, using packages. Our programs have been rather small in the
    number of lines of code and in complexity to a certain extent. Most of our programs
    have been contained in a single code file, often named `main.go`, and inside a
    single package named `main`. Later in this chapter, we will explore the significance
    of `package main`, so do not be worried at this juncture if you do not understand
    it. This will not always be the case when you are working on a development team.
    Often, your code base can become rather large, with multiple files, multiple libraries,
    and multiple members of the team. It would be rather restrictive if we could not
    break our code into smaller, manageable parts. The Go programming language solves
    the complexity of managing large code bases with the ability to modularize similar
    concepts into packages. The creators of Go use packages for their own standard
    libraries to tackle this problem. In this book, you have been working with many
    Go packages, such as `fmt`, `string`, `os`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example of a package structure from the Go standard library.
    The Go `strings` package encapsulates string functions that manipulate strings.
    By keeping the `strings` package focused on only the functions that manipulate
    strings, we, as Go developers, know that this function should contain all that
    we need for string manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go `strings` package is structured as follows ([https://pkg.go.dev/strings#section-sourcefiles](https://pkg.go.dev/strings#section-sourcefiles)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: The strings package along with the files contained within it
    as of Go 1.21](img/B18621_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: The strings package along with the files contained within it as
    of Go 1.21'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram shows the `strings` package and the files that are in
    the package. Each file in the `strings` package is named after the functionality
    it is supporting. The logical organization of the code goes from package to file.
    We can easily conclude that the `strings` package contains code for manipulating
    strings. We can then further conclude that the `replace.go` file contains functions
    for replacing strings. You can already see that the conceptual structure of packages
    can organize your code into modular chunks. You start with code that is working
    together to serve a purpose, string manipulation, and it gets stored in a package
    called `strings`. You can then further organize the code into `.go` files and
    name them according to their purpose. The next step is keeping functions in there
    that perform a single purpose that reflects the name of the file and the name
    of the package. We will discuss these conceptual ideas later in the chapter when
    we discuss structuring code.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to develop software that is maintainable, reusable, and modular.
    Let’s briefly discuss each of these core components of software development.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For code to be maintainable, it must be easy to change, and any changes must
    have a low risk of having an adverse impact on the program. Maintainable code
    is easy to modify and extend and is readable. As code progresses through the different
    stages of the **software development life cycle** (**SDLC**), the cost of changes
    to the code increases. These changes can be due to bugs, enhancements, or a change
    in requirements. Costs also increase when code is not easily maintainable. Another
    reason that code needs to be maintainable is the need to be competitive in the
    industry. If your code is not easily maintainable, it may be hard to react to
    a competitor who is releasing a software feature that could be used to outsell
    your application. These are just some of the reasons for code needing to be maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Reusable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reusable code is code that can be used in new software. For example, I have
    code in my existing application that has a function that returns an address for
    my mailing application; that function may be used in a new piece of software.
    That function that returns the address could be used in my new software that returns
    a customer address for an order the customer has placed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of having reusable code are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It decreases future project costs by using existing packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It decreases the time it takes to deliver an application, due to not having
    to reinvent the wheel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The quality of the program will increase through increased testing and more
    usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More time can be spent on other areas of innovation during the development cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As your packages grow, it becomes easier to lay the foundations for future projects
    in a timely manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to see the many benefits of making reusable code for our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Modular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modular and reusable code is related to a certain extent, in the sense that
    having modular code makes it more likely that it will be reusable. One of the
    prominent problems when developing code is the organization of the code. Finding
    code that performs a certain function in a large program that is unorganized would
    be near to impossible, and even finding out whether there is code that performs
    a certain task would be difficult to ascertain without some code organization.
    Modularization aids in that area. The idea is that each discrete task that your
    code performs has its own section of code located in a specific spot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go encourages you to develop maintainable, reusable, and modular code by using
    packages. It was designed to encourage good software practices. We will be diving
    into how Go utilizes packages to accomplish those tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: The types of code packages can provide](img/B18621_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: The types of code packages can provide'
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, we are going to discuss what a package is and what the components
    that make up a package are.
  prefs: []
  type: TYPE_NORMAL
- en: What is a package?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go follows the **Don’t Repeat Yourself** (**DRY**) principle. This means that
    you should not write the same code twice. Refactoring your code into functions
    is the first step of the DRY principle. What if you had hundreds or even thousands
    of functions that you used regularly? How would you keep track of all those functions?
    Some of those functions might even have common characteristics. You could have
    a group of functions that perform math operations, string manipulations, printing,
    or file-based operations. You may be thinking of breaking them up into individual
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: Group functions by files](img/B18621_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Group functions by files'
  prefs: []
  type: TYPE_NORMAL
- en: 'That could alleviate some of the issues. However, what if your string’s functionality
    started to grow further? You would then have a ton of string functions in one
    file or even multiple files. Every program you build would also have to include
    all of the code for `string`, `math`, and `io`. You would be copying code to every
    application that you built. Bugs in one code base would have to be fixed in multiple
    programs. That kind of code structure is not maintainable, nor does it encourage
    code reusability. The packages in Go are the next step to organizing your code
    in a way that makes it easy to reuse the components of your code. The following
    diagram shows the progression of organizing code from functions to source files
    to packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4: Code progression organization](img/B18621_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Code progression organization'
  prefs: []
  type: TYPE_NORMAL
- en: Go organizes its code for reusability into directories called packages. A package
    is essentially a directory inside your workspace that contains one or more Go
    source files, which is used for grouping code that performs a task. It exposes
    only the necessary parts in order for those using your package to get a job done.
    The package concept is akin to using directories to organize files on a computer.
  prefs: []
  type: TYPE_NORMAL
- en: Package structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It does not matter to Go how many different files are in a package. You should
    separate code into as many files as makes sense for readability and logic grouping.
    However, all the files that are in a package must live in the same directory.
    The source files should contain code that is related, meaning that if the package
    is for configuration parsing, you should not have code in there for connecting
    to a database. The basic structure of a package consists of a directory and contains
    one or more Go files and related code. The following diagram summarizes the core
    components of a package structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5: Package structure](img/B18621_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Package structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the commonly used packages in Go is the `strings` package. It contains
    several Go files that are referred to in the Go documentation as package files.
    Package files are `.go` source files that are part of the package; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`builder.go`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compare.go`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reader.go`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace.go`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search.go`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strings.go`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The files in the preceding list all play their part in sharing related code
    for string operations within the standard library. Before we discuss how to declare
    a package, we need to discuss proper Go naming conventions for a package.
  prefs: []
  type: TYPE_NORMAL
- en: Package naming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The name of your package is significant. It represents what your package contains
    and identifies its purpose. You can think of a package name as self-documentation.
    Careful consideration needs to go into naming a package. The name of the package
    should be short and concise. It should not be verbose. Simple nouns are often
    chosen for a package name. The following would be poor names for a package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stringconversion`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`synchronizationprimitives`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`measuringtime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Better alternatives would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`strconv`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sync`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`strconv`, `sync`, and `time` are actual Go packages found in the standard
    library.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the styling of a package is something to take into consideration. The
    following would be poor style choices for a Go package name:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StringConversion`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`synchronization_primitives`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`measuringTime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Go, package names should be all lowercase with no underscores. Don’t use
    camel-case or snake-case styling. There are multiple packages with pluralized
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Abbreviations are encouraged, just as long as they are familiar or common in
    the programming community. The user of the package should easily understand what
    the package is used for just from its name; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`strconv` (string conversion)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regexp` (regular expression search)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sync` (synchronization)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os` (operating system)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoid package names such as `misc`, `util`, `common`, or `data`. These package
    names make it harder for the user of your package to understand its purpose. In
    some cases, there is a deviation from these guidelines, but for the most part,
    it is something we should strive for:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6: Package naming conventions](img/B18621_10_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Package naming conventions'
  prefs: []
  type: TYPE_NORMAL
- en: You can see how there is almost an art to making a good package name. You want
    to be concise, descriptive, and clear on the package usage when picking package
    names. Now that we’ve discussed package names, let’s take a peek at package declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Package declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every Go file starts with a package declaration. The package declaration is
    the name of the package. The first line of each file in a package must be the
    package declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that the `strings` package from the standard library has the following
    Go source files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7: The strings package along with the files contained within it
    as of Go 1.21](img/B18621_10_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: The strings package along with the files contained within it as
    of Go 1.21'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each one of those files starts with a package declaration, even though they
    are all separate files. We will look at an example from the Go standard library.
    In the Go standard library, there is a package called `strings\`. It is made up
    of multiple files. We will only be looking at a snippet of code from the files
    in the package: `builder.go`, `compare.go`, and `replace.go`. We have removed
    comments and some code just to demonstrate that the package files start with the
    package name. There will be no output from the code snippet. This is an example
    of how Go organizes code into multiple files but in the same package ([https://golang.org/src/strings/builder.go](https://golang.org/src/strings/builder.go)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The full code is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Example10.01/strings.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Example10.01/strings.go).
  prefs: []
  type: TYPE_NORMAL
- en: All functions, types, and variables that are defined in the Go source file are
    accessible within that package. Though your package could spread across multiple
    files, it is all part of the same package. Internally, all code is accessible
    across the files. Simply stated, the code is visible within the package. Notice
    that not all of the code is visible outside of the package. The preceding snippet
    is from the official Go libraries. For a further explanation of the code, visit
    the links in the preceding Go snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Exported and unexported code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go has a very simple way to determine whether code is exported or unexported.
    Exported means that variables, types, functions, and so on are visible from outside
    of the package. Unexported means it is only visible from inside the package. If
    a function, type, variable, and so on starts with an uppercase letter, it is exportable;
    if it starts with a lowercase letter, it is unexportable. There are no access
    modifiers to be concerned with in Go. If the function name is capitalized, then
    it is exported, and if it is lowercase, then it is unexported.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice to only expose code that we want other packages to see.
    We should hide everything else that is not needed by external packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet uses the `strings` package. We are calling a `strings` function
    called `Contains`. The `strings.Contains` function searches the `str` variable
    to see whether it has the value `"found"` within it. If `"found"` is within the
    `str` variable, the `strings.Contains` function will return `true`; if `"found"`
    is not within the `str` variable, the `strings.Contains` function will return
    `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To call the function, we prefix it with the package name and then the function
    name.
  prefs: []
  type: TYPE_NORMAL
- en: This function is exportable and thus is accessible to others outside of the
    `strings` package. We know it is an exported function because the first letter
    of the function is capitalized.
  prefs: []
  type: TYPE_NORMAL
- en: When you import a package, you only have access to the exported names.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can validate whether the function exists in the `strings` package by looking
    at the `strings.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code snippet will attempt to access an unexported function in the
    `strings` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The function is unexported because it starts with a lowercase letter. Only code
    within the package can access the function; it is not visible outside of the package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is attempting to call an unexported function in the `strings.go` package
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8: Program output](img/B18621_10_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Program output'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is from the Go standard library `strings` package
    and from the `strings.go` file inside of that package ([https://packt.live/2RMxXqh](https://packt.live/2RMxXqh)).
    You can see that the `explode()` function is unexportable because the function
    name starts with a lowercase letter:'
  prefs: []
  type: TYPE_NORMAL
- en: main.go
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The full code is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Example10.02/strings.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Example10.02/strings.go).
  prefs: []
  type: TYPE_NORMAL
- en: Package alias
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go also has the ability to alias package names. There are a few reasons that
    you may want to use alias names:'
  prefs: []
  type: TYPE_NORMAL
- en: The package name may not make it easy to understand its purpose. For clarity,
    it might be better to alias (use) a different name for the package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The package name might be too long. In this case, you want the alias to be more
    concise and less verbose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There could be scenarios where the package path is unique but both package names
    are the same. You would need to then use aliasing to differentiate between the
    two packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The package-aliasing syntax is very simple. You place the alias name before
    the `import` package path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a simple example showing how to use package aliasing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We are aliasing the `fmt` package as `f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the `main()` function, we are now able to call the `Println()` function using
    the `f` alias.
  prefs: []
  type: TYPE_NORMAL
- en: Main package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `main` package is a special package. There are two basic types of packages
    in Go: executable and non-executable. The `main` package is an executable package
    in Go. Logic that resides in this package may not be consumed by other packages.
    The `main` package requires there to be a `main()` function in its package. The
    `main()` function is the entry point for a Go executable. When you perform `go
    build` on the `main` package, it will compile the package and create a binary.
    The binary is created inside the directory where the `main` package is located.
    The name of the binary will be the name of the folder it resides in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9: Why main package is special](img/B18621_10_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Why main package is special'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple example of the `main` package code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 10.01 – Creating a package to calculate areas of various shapes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B18621_07.xhtml#_idTextAnchor1291), *Getting Flexible with
    Interfaces*, we implemented code to calculate areas of different shapes. In this
    exercise, we will move all the code about shapes into a package called `shape`.
    We will then update the code in the `shape` package to be exportable. Then, we
    will update `main` to import our new `shape` package. However, we want it to still
    perform the same functionality in the `main()` function of the `main` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code that we will be converting into packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Exercise07.02/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Exercise07.02/main.go)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should have a directory structure, as displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10: Program directory structure](img/B18621_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.10: Program directory structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shape.go` file should contain the entire code: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.01/pkg/shape/shape.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.01/pkg/shape/shape.go).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will only be going over changes that are relevant to making this code a
    package; for details on the parts of the code that we have gone over in a previous
    chapter, please see [*Chapter 7*](B18621_07.xhtml#_idTextAnchor1291), *Getting
    Flexible* *with Interfaces*:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `Exercise10.01` inside `Chapter10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Go module within the `Exercise10.01` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create two more directories called `cmd` and a nested directory of `pkg/shape`
    inside the `Exercise10.01` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `main.go` inside the `Exercise10.01/cmd` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `shape.go` inside the `Exercise10.01/pkg/shape` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Exercise10.01/pkg/shape.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first line of code in this file tells us this is a non-executable package
    called `shape`. A non-executable package, when compiled, does not result in binary
    or executable code. Recall that the `main` package is an executable package.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to make the types exportable. For each `struct` type, we have
    to capitalize on the type name and its fields to make it exportable. Exportable
    means that it is visible outside of this package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We also have to make the methods non-exportable by changing the method name
    to lowercase. There is no need at the moment to make those methods visible outside
    of the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `shape.go` file contents should now include the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The full code for this step is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.01/pkg/shape/shape.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.01/pkg/shape/shape.go).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `PrintShapeDetails()` function also needs to be capitalized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform a build to ensure that there are no compilation errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the listing for the `main.go` file. By having a package as `main`,
    we know that this is executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `import` declaration only has one import. It is the `shape` package. We
    can see the name of the package is `shape` since it is the last directory name
    in the path declaration. The path for where my package is located may differ from
    yours:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, we are initializing the `shape` package’s exportable
    types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then call the `shape()` function, `PrintShapeDetails`, to get the area of
    each shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the command line, go to the `Exercise10.01/cmd` directory structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `go build` command will compile your program and create an executable named
    after the directory, `cmd`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type the executable name and hit *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We now have the functionality that we previously had in the interface chapter’s
    implementation of `shape`. We have the `shape` functionality now encapsulated
    in the `shape` package. We exposed or made visible only functions or methods that
    are needed to maintain the previous implementation. The `main` package has less
    clutter and imports the local `shape` package to provide the functionality that
    was in the previous implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The init() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have discussed, every Go program (executable) starts in the `main` package
    and the entry point is the `main()` function. There is another special function
    that we should be aware of, called `init()`. Each source file can have an `init()`
    function, but for now, we will look at the `init()` function in the context of
    the `main` package. When you start writing packages, you might need to provide
    some initialization (the `init()` function) for the package. The `init()` function
    is used to set up states or values. The `init()` function adds initialization
    logic for your package. Here are some examples of uses of the `init()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting database objects and connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initialization of package variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading configuration data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying or repairing the program state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `init()` function requires the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Imported packages are initialized first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package-level variables are initialized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The package’s `init()` function is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main()` is executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows the execution order that a typical Go program follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11: Order of execution](img/B18621_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.11: Order of execution'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example that demonstrates the `package main` order of execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s understand the code in parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the output of the code, the package-level variable declaration gets
    executed first. We know this because the `name` variable is printed in the `init()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `init()` function then gets called and prints out `"``Hello, Gopher"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `main()` function is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12: Execution flow of the code snippet](img/B18621_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.12: Execution flow of the code snippet'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `init()` function cannot have any arguments or return values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code snippet will result in the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13: Program output](img/B18621_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.13: Program output'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 10.02 – Loading budget categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write a program that will load budget categories into a global map, before
    the `main()` function runs. The `main()` function should then print out the data
    on the map:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code file will belong to `package main` and will need to import the `fmt`
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a global variable that will contain a map of budget categories with
    a key of `int` and a value of `string`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will need to use an `init()` function to load our budget categories before
    `main()` runs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since our budget categories have been loaded, we can now iterate over the map
    and print them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The output may differ in terms of the order displayed; Go maps do not guarantee
    the order of data.
  prefs: []
  type: TYPE_NORMAL
- en: The aim here was to demonstrate how the `init()` function can be used to perform
    data initialization and loading before the `main()` function executes. Data that
    generally needs to be loaded before `main()` runs is static data, such as picklist
    values or some sort of configuration. As demonstrated, after the data gets loaded
    through the `init()` function, it can be used by the `main()` function. In the
    next topic, we will see how multiple `init()` functions get executed.
  prefs: []
  type: TYPE_NORMAL
- en: Executing multiple init() functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There can be more than one `init()` function in a package. This enables you
    to modularize your initialization for better code maintenance. For example, suppose
    you need to set up various files and database connections and repair the state
    of the environment your program will be executed in. Doing all that in one `init()`
    function would make it complicated for maintaining and debugging. The order of
    execution of multiple `init()` functions is the order in which the functions are
    placed in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break the code into parts and evaluate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Go initializes the `name` variable first, before the `init()` function gets
    executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints out first since it is the first `init` in the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding gets printed out second since it is the second `init` in the
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding gets printed out third since it is the third `init` in the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `main()` function gets executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 10.03 – Assigning payees to budget categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to expand our program from *Exercise 10.02*, *Loading budget categories*,
    to now assign payees to budget categories. This is similar to many budgeting applications
    that try to match payees to commonly used categories. We will then print the mapping
    of a payee to a category:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the code from *Exercise 10.02*, *Loading Budget Categories*, (https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.02/main.go)
    into the `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `payeeToCategory` map after `budgetCategories`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another `init()` function. This `init()` function will be used to populate
    our new `payeeToCategory` map. We will assign payees to the key value of the categories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The full code for this step is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.03/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter10/Exercise10.03/main.go).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `main()` function, we will print out the payees to categories. We iterate
    over the `payeeToCategory` map, printing the key (`payee`). We print the category
    by passing the value of the `payeeToCategory` map as a key to the `budgetCategories`
    map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14: Assigning a payee to budget categories](img/B18621_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.14: Assigning a payee to budget categories'
  prefs: []
  type: TYPE_NORMAL
- en: You have now created a program that executes multiple `init()` functions before
    the execution of the `main()` function. Each of the `init()` functions loaded
    data into our global map variables. We have determined the order of `init()` functions
    executing because of the `print` statements that get displayed. This demonstrates
    that the `init()` functions print in the order they are present in the code. It
    is important to be aware of the order of your `init()` functions as you may have
    unforeseen results based on the order of the code execution.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming activity, we will be using all these concepts that we have looked
    at with packages and see how they all work together.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 10.01 – Creating a function to calculate payroll and performance review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we are going to take *Activity 7.01*, *Calculating pay and
    performance review*, from [*Chapter 7*](B18621_07.xhtml#_idTextAnchor1291) and
    modularize it using packages. We will be refactoring the code from [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Activity7.01/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter07/Activity7.01/main.go):'
  prefs: []
  type: TYPE_NORMAL
- en: Move the types and methods of `Developer`, `Employee`, and `Manager` into their
    own package under `pkg/payroll`. Types, methods, and functions must be properly
    exported or unexported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the package `payroll`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Logically separate the types and their methods into different package files.
    Recall that good code organization involves separating similar functionality into
    separate files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `main()` function as an alias to the `payroll` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Introduce two `init()` functions in the `main` package under the `cmd` directory.
    The first `init()` function should simply print a greeting message to `stdout`.
    The second `init()` function should initialize/set up key-value pairs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this activity, we have seen how to use packages to separate our code and
    then logically separate the code into individual files. We can see that each of
    those files makes up a package. Each file of the package has internal access to
    the other files regardless of the fact that they are in separate files. This activity
    demonstrates how to create a package with multiple files and how those separate
    files can be used to further organize our code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter10/Activity10.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter10/Activity10.01).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the importance of developing software that is
    maintainable, reusable, and modular. We discovered how Go’s packages play an important
    part in meeting those criteria for developing software. We looked at the overall
    structure of a package. It is made up of a directory, can contain one or more
    files, and has code that is related. A package is essentially a directory inside
    of your workspace that contains one or more files that are used for grouping code
    that is to perform a task. It exposes only the necessary parts to those using
    your package to get a job done. We discussed the importance of naming packages
    properly. We also learned how to name a package; that is, concisely, in lowercase,
    descriptively, using non-plural names, and avoiding generic names. Packages can
    be executable or non-executable. If a package is the `main` package, then it is
    an executable package. The `main` package must have a `main()` function, and that
    is where the entry point is for our package.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also talked about what is exportable and unexportable code. When we capitalize
    the name of a function, type, or method, it is visible to others using our package.
    Lowercasing a function, type, or method makes it not visible to other users from
    outside our package. We learned that `init()` functions can perform the following
    duties: initializing variables, loading configuration data, setting database connections,
    or verifying that our program state is ready for execution. `init()` functions
    have certain rules when they get executed and on how to utilize them. This chapter
    will help you to write highly manageable, reusable, and modular code.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start exploring debugging skills, a crucial aspect
    of software development. This will include learning about effective troubleshooting
    to enable a robust development experience.
  prefs: []
  type: TYPE_NORMAL
