<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer141">
			<h1 id="_idParaDest-305" class="chapter-number"><a id="_idTextAnchor1462"/>11</h1>
			<h1 id="_idParaDest-306">Bug-Busting Debugging Skills<a id="_idTextAnchor1463"/><a id="_idTextAnchor1464"/></h1>
			<p class="callout-heading"><a id="_idTextAnchor1465"/>Overview</p>
			<p class="callout">In this chapter, we will look at basic debugging methodologies. We will look at some proactive measures we can take to reduce the number of bugs we introduce into our program. Once we understand these measures, we will investigate the ways in which we can locate <span class="No-Break">a bug.</span></p>
			<p class="callout">You will be able to acquaint yourself with debugging in Go and implement various ways to format printing. You will evaluate various techniques of basic debugging and find the general location of a bug in code. By the end of the chapter, you will know how to print out variable types and values using Go code and log the state of an application for debugging purposes. You will also see what debugging measures are available in different or restricted environments that your code may eventually be <span class="No-Break">deployed to.</span></p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor1466"/>Technical requirements</h1>
			<p>For this chapter, you'll require Go version 1.21 or higher. The code for this chapter can be found <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter11"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter11</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-308"><a id="_idTextAnchor1467"/><a id="_idTextAnchor1468"/>Introduction</h1>
			<p>As you develop software programs, there are going to be times when your program behaves in an unintended way. For instance, the program could throw an error and might crash. A crash is when our code stops functioning midway and then exits abruptly. Perhaps the program has given us unexpected results. For example, we request a video-streaming service for the movie <em class="italic">Rocky 1</em> but instead get <em class="italic">Creed 1!</em> Or you deposited a check into your bank account but, instead of being credited, the bank software debited your account. These examples of software programs behaving in an unintended way are called bugs. Sometimes, “bug” and “error” are used<a id="_idIndexMarker738"/> interchangeably. In <a href="B18621_06.xhtml#_idTextAnchor1210"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Don’t Panic! Handle Your Errors</em>, in the <em class="italic">What are errors?</em> section, we discussed how there are three different types of errors or bugs: syntax errors, runtime errors, and logic errors. We also examined examples and saw the difficulty of discovering the location of each type <span class="No-Break">of error.</span></p>
			<p>The process of determining the cause of unintended behavior is called debugging. There are various causes of bugs that get released <span class="No-Break">into production:</span></p>
			<ul>
				<li><strong class="bold">Testing is performed as an afterthought</strong>: During the development life cycle, it is tempting to not perform testing incrementally. For instance, we are creating multiple functions for an<a id="_idIndexMarker739"/> application, and once we finish all the functions, they then get tested. A possibly better way of testing our code would be to test each function as we complete it. This is known as incrementally testing or delivering code in smaller chunks. This gives us better code stability. This is accomplished by testing a function to ensure it works before continuing to the next function. The function that we just completed could be used by other functions. If we do not test it before we continue, the other functions that use our function could be using a buggy function. Depending on the bug and the change to our function, it could impact other users of our function. Later in the chapter, we will discuss more benefits of <span class="No-Break">testing incrementally.</span></li>
				<li><strong class="bold">Application enhancements or changes to requirements</strong>: Our code often changes between the development phase and when we release it to production. Once in production, we receive feedback from the users; the feedback could be additional requirements or even enhancements to the code. Changing the production-level code in one area could have a negative impact on another area. If the development team uses unit tests, then this would aid in mitigating some of the bugs introduced in a change to the code base. By using unit tests, we could run our unit test before we deliver the code to see whether our change had a negative impact. We will discuss what a unit test <span class="No-Break">is later.</span></li>
				<li><strong class="bold">Unrealistic development timeframe</strong>: There are times when functionality is requested to be delivered in very tight timeframes. This can lead to taking shortcuts in best practices, shortening the design phase, performing less testing, and receiving unclear requirements. All of those can increase the chance of <span class="No-Break">introducing bugs.</span></li>
				<li><strong class="bold">Unhandled errors</strong>: Some developers may choose not to handle errors as they occur; for example, a file that is needed for the application to load configuration data is not found, not <a id="_idIndexMarker740"/>handling an error return for an invalid mathematical operation such as dividing by zero, or perhaps a connection to a server could not be established. If your program does not properly handle these and other types of errors, this can <span class="No-Break">cause bugs.</span></li>
			</ul>
			<p>These are just a few causes of bugs. Bugs have a negative impact on our programs. The results of a bug that causes a miscalculation can be life-threatening. In the medical industry, a machine is used to administer a drug called heparin; this drug is a blood thinner and is used to prevent blood clots. If the code that determines the calculation of how often and how much heparin can be administered has a bug that causes it to malfunction, the machine could deliver too much or too little of the drug. This could have an adverse effect on the patient. As you can see, it is critical to deliver software that is as bug-free as possible. In this chapter, we are going to look at some ways to minimize the number of bugs that are introduced and ways of isolating the location <span class="No-Break">of bug<a id="_idTextAnchor1469"/><a id="_idTextAnchor1470"/>s.</span></p>
			<h1 id="_idParaDest-309"><a id="_idTextAnchor1471"/>Methods for bug-free code</h1>
			<p>We will briefly look at <a id="_idIndexMarker741"/>some methods that will help us to minimize the number of bugs that could be introduced into our code. These methods will also aid in giving us confidence as to the portions of the code that introduced <span class="No-Break">the <a id="_idTextAnchor1472"/>bug:</span></p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/B18621_11_01.jpg" alt="Figure 11.1: Different methods to debug code" width="1081" height="290"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1: Different methods to debug code</p>
			<p>Let’s look at these methods in <span class="No-Break">more detai<a id="_idTextAnchor1473"/><a id="_idTextAnchor1474"/>l.</span></p>
			<h2 id="_idParaDest-310"><a id="_idTextAnchor1475"/>Coding incrementally and testing often</h2>
			<p>Let’s consider the approach of developing incrementally. This means developing the program incrementally and testing<a id="_idIndexMarker742"/> it often after adding an incremental piece of code. This pattern will help you to track bugs easily because you are testing every small snippet of code as opposed to one <span class="No-Break">large progr<a id="_idTextAnchor1476"/><a id="_idTextAnchor1477"/>am.</span></p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor1478"/>Writing unit tests</h2>
			<p>When a test is written and code changes occur, the unit test protects the code from potential bugs being introduced. A typical unit test takes a given input and validates that a given result is produced. If the unit test is passing before the code change but is now failing after the code change, then we can conclude that we introduced some unintended behavior. The unit<a id="_idIndexMarker743"/> test needs to pass before we push our code to a production system. In other words, development teams verify that tests pass and that the code still works as expected before accepting new changes to the <span class="No-Break">code b<a id="_idTextAnchor1479"/><a id="_idTextAnchor1480"/>ase.</span></p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor1481"/>Handling all errors</h2>
			<p>This was discussed in <a href="B18621_06.xhtml#_idTextAnchor1210"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Don’t Panic! Handle Your Errors</em>. Ignoring errors can lead to potentially <a id="_idIndexMarker744"/>unintended results in our program. We need to handle errors properly to make the debugging <span class="No-Break">process ea<a id="_idTextAnchor1482"/><a id="_idTextAnchor1483"/>sier.</span></p>
			<h2 id="_idParaDest-313"><a id="_idTextAnchor1484"/>Performing logging</h2>
			<p>Logging is another technique that we can use to determine what is occurring in the program. There are various types of logging; some common logging types are debug, info, warn, error, fatal, and trace. We will not go into the details of each type; we will focus instead on performing debug-type logging. This type of logging is typically used to determine the state of the<a id="_idIndexMarker745"/> program before a bug occurs. Some of the information that is gathered includes the values of the variables, the portion of the code that is being executed (one example would be the function name), the values of the arguments being passed, the output of the function or method, and more. In this chapter, we will be performing our own custom debug logging using the built-in features of the Go standard library. The built-in <strong class="source-inline">log</strong> package of Go can provide timestamps. This is useful when trying to understand the timing of various events. When you perform logging, you will need to keep in mind the performance implications. Depending on the application and the load it is under (that is, the number of users interacting with the system around the same time), the application logging output amount could be extensive during peak times and may have a negative impact on the performance of the application. Depending on the number of logs added to the application, the more the users that interact with the system the more logs it will generate, and the more of a negative impact on the performance of the application this could create. In certain circumstances, it could cause it to <span class="No-Break">be unrespo<a id="_idTextAnchor1485"/><a id="_idTextAnchor1486"/>nsive.</span></p>
			<h2 id="_idParaDest-314"><a id="_idTextAnchor1487"/>Formatting using fmt</h2>
			<p>One of the uses of the <strong class="source-inline">fmt</strong> package is to display data to the console or to the filesystem, such as a text file, that will contain information that could be helpful in debugging the code. We have used the <strong class="source-inline">fmt.Println()</strong> function on numerous occasions. Let’s take a slightly <a id="_idIndexMarker746"/>deeper look at the functionality of <strong class="source-inline">fmt.Println()</strong>. The <strong class="source-inline">fmt.Println()</strong> function places spaces between arguments passed to the function and then appends a newline character at the end of <span class="No-Break">the string.</span></p>
			<p>Each type in Go has a default way that it is formatted when printed. For example, strings are printed as they are, and integers are printed in decimal format. The <strong class="source-inline">fmt.Println()</strong> function prints the default formats <span class="No-Break">of arg<a id="_idTextAnchor1488"/><a id="_idTextAnchor1489"/>uments.</span></p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor1490"/>Exercise 11.01 – Working with fmt.Println</h2>
			<p>In this exercise, we <a id="_idIndexMarker747"/>will print a <strong class="source-inline">hello</strong> statement <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">fmt.Println</strong></span><span class="No-Break">:</span></p>
			<ol>
				<li>Import the <span class="No-Break"><strong class="source-inline">fmt</strong></span><span class="No-Break"> package:</span><pre class="source-code">
package main
import (
    "fmt"
)</pre></li>				<li>Declare the <strong class="source-inline">fname</strong> and <strong class="source-inline">lname</strong> variables in a <strong class="source-inline">main()</strong> function and assign two strings to <span class="No-Break">a variable:</span><pre class="source-code">
func main() {
    fname:= "Edward"
    lname:= "Scissorhands"</pre></li>				<li>Call the <strong class="source-inline">Println</strong> method from the <strong class="source-inline">fmt</strong> package. It will print <strong class="source-inline">Hello:</strong> and then the value of both variables followed by a space. Then, it will print a <strong class="source-inline">\n</strong> (newline character) to the <span class="No-Break">standard output:</span><pre class="source-code">
    fmt.Println("Hello:", fname, lname)</pre></li>				<li>The following statement prints <strong class="source-inline">Next Line</strong> plus <strong class="source-inline">\n</strong> to the <span class="No-Break">standard output:</span><pre class="source-code">
    fmt.Println("Next Line")
}</pre><p class="list-inset">The output is <span class="No-Break">as follows:</span></p><pre class="source-code">Hello: Edward Scissorhands
Next Line</pre></li>			</ol>
			<p>We have demonstrated the basics of printing out messages. In the next topic, we will look at how we can format the data that we want <span class="No-Break">t<a id="_idTextAnchor1491"/><a id="_idTextAnchor1492"/>o print.</span></p>
			<h2 id="_idParaDest-316"><a id="_idTextAnchor1493"/>Formatting using fmt.Printf()</h2>
			<p>The <strong class="source-inline">fmt</strong> package also has numerous ways of formatting the output of our various <strong class="source-inline">print</strong> statements. We will look next at the <span class="No-Break"><strong class="source-inline">fmt.Printf()</strong></span><span class="No-Break"> function.</span></p>
			<p><strong class="source-inline">fmt.Printf()</strong> formats the string according to the verb and prints it to <strong class="source-inline">stdout</strong>. The standard output (<strong class="source-inline">stdout</strong>) is a stream <a id="_idIndexMarker748"/>for output. By default, the standard output is pointed to the terminal. The function uses something called format verbs, sometimes called a format specifier. The verbs tell the <strong class="source-inline">fmt</strong> function where to insert the variable. For example, <strong class="source-inline">%s</strong> prints a string; it is a placeholder for a string. These verbs are based on the <span class="No-Break">C l<a id="_idTextAnchor1494"/>anguage:</span></p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B18621_11_02.jpg" alt="Figure 11.2: Explanation of Printf" width="790" height="253"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2: Explanation of Printf</p>
			<p>Consider the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
)
func main() {
    fname := "Edward"
    fmt.Printf("Hello %s, good morning", fname)
}</pre>			<p>The <strong class="source-inline">fname</strong> variable is assigned as <strong class="source-inline">Edward</strong>. When the <strong class="source-inline">fmt.Printf()</strong> function runs, the <strong class="source-inline">%s</strong> verb will have the value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">fname</strong></span><span class="No-Break">.</span></p>
			<p>The output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Hello Edward, good morning</pre>			<p>But what happens when we have more than one variable that we want to print? How can we print more than one variable in the <strong class="source-inline">fmt.Printf()</strong> function? Let’s take <span class="No-Break">a look:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
)
func main() {
    fname := "Edward"
    lname := "Scissorhands"
    fmt.Printf("Hello Mr. %s %s", fname, lname)
}</pre>			<p>As you see in the preceding code, we now have <strong class="source-inline">fname</strong> and <strong class="source-inline">lname</strong> assigned to a string. The <strong class="source-inline">fmt.Printf()</strong> function has two <a id="_idIndexMarker749"/>verb strings and two variables. The first variable, <strong class="source-inline">fname</strong>, is assigned to the first <strong class="source-inline">%s</strong> instance. The second variable, <strong class="source-inline">lname</strong>, is assigned to the second <strong class="source-inline">%s</strong> instance. The variables replace the verbs in the order they are placed in the <span class="No-Break"><strong class="source-inline">fmt.Printf()</strong></span><span class="No-Break"> function.</span></p>
			<p>The output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Hello Mr. Edward Scissorhands</pre>			<p>The <strong class="source-inline">fmt.Printf()</strong> function does not add a new line to the end of the string that it prints. We must add a newline character in the string if we want to return the output with a <span class="No-Break">new line:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
)
func main() {
    fname := "Edward"
    lname := "Scissorhands"
    fmt.Printf("Hello my first name is %s\n", fname)
    fmt.Printf("Hello my last name is %s", lname)
}</pre>			<p>In Go, you can escape characters using <strong class="source-inline">\</strong>. If you ever wanted to print the <strong class="source-inline">\</strong> character, then you’d put <strong class="source-inline">fmt.Println("\\")</strong> to escape the character. This tells us that a character should not be printed <a id="_idIndexMarker750"/>because it has a special meaning. When you use <strong class="source-inline">\n</strong>, it denotes a newline. We can place a newline anywhere within <span class="No-Break">the string.</span></p>
			<p>The output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Hello my first name is Edward
Hello my last name is Scissorhands</pre>			<p>The following would be the result if we did not place <strong class="source-inline">\n</strong> in <span class="No-Break">the string:</span></p>
			<pre class="console">
Hello my first name is EdwardHello my last name is Scissorhands</pre>			<p>The Go language has several printing verbs. We will introduce some basic verbs that are frequently used. We will introduce others as they become pertinent to performing <span class="No-Break">basic d<a id="_idTextAnchor1495"/>ebugging:</span></p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B18621_11_03.jpg" alt="Figure 11.3: Table representing verbs and their meanings" width="1186" height="556"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3: Table representing verbs and their meanings</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A full list of verbs available with the <strong class="source-inline">fmt</strong> package can be found <span class="No-Break">at </span><a href="https://pkg.go.dev/fmt#hdr-Printing"><span class="No-Break">https://pkg.go.dev/fmt#hdr-Printing</span></a><span class="No-Break">.</span></p>
			<p>Let’s look at an example of using verbs for printing out various <span class="No-Break">data types:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
)
func main() {
    fname := "Joe"
    gpa := 3.75
    hasJob := true
    age := 24
    hourlyWage := 45.53
    fmt.Printf("%s has a gpa of %f.\n", fname, gpa)
    fmt.Printf("He has a job equals %t.\n", hasJob)
    fmt.Printf("He is %d earning %v per hour.\n", age, hourlyWage)
}</pre>			<ul>
				<li>We initialize<a id="_idIndexMarker751"/> various variables of different types that will be used in our <span class="No-Break"><strong class="source-inline">Printf()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
fmt.Printf("%s has a gpa of %f.\n", fname, gpa)</pre></li>				<li><strong class="source-inline">%s</strong> is the placeholder for a string; when the <strong class="source-inline">Printf()</strong> function runs, the value from the <strong class="source-inline">fname</strong> variable will replace <strong class="source-inline">%s</strong>. <strong class="source-inline">%f</strong> is the placeholder for a float; when the <strong class="source-inline">Printf()</strong> statement runs, the value in the <strong class="source-inline">gpa</strong> variable will <span class="No-Break">replace </span><span class="No-Break"><strong class="source-inline">%f</strong></span><span class="No-Break">.</span></li>
				<li>Check whether the person has a job <span class="No-Break">as follows:</span><pre class="source-code">
fmt.Printf("He has a job equals %t.\n", hasJob)</pre></li>				<li><strong class="source-inline">%t</strong> is the placeholder for a <strong class="source-inline">bool</strong> type. When the <strong class="source-inline">Printf()</strong> statement runs, the value in the <strong class="source-inline">hasJob</strong> variable will <span class="No-Break">replace </span><span class="No-Break"><strong class="source-inline">%t</strong></span><span class="No-Break">.</span></li>
				<li>Print the age of the person and their wage <span class="No-Break">per hour:</span><pre class="source-code">
fmt.Printf("He is %d earning %v per hour.\n", age, hourlyWage)</pre></li>				<li><strong class="source-inline">%d</strong> is the placeholder for an <strong class="source-inline">int</strong> base-10. When the <strong class="source-inline">Printf</strong> statement runs, the value in the <strong class="source-inline">age</strong> variable will <span class="No-Break">replace </span><span class="No-Break"><strong class="source-inline">%d</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">%v</strong> is the placeholder for the value in a <span class="No-Break">default format.</span></li>
			</ul>
			<p>The following is the <span class="No-Break">expected output:</span></p>
			<pre class="console">
Joe has a gpa of 3.750000.
He has a job equals true.
He is 24 earning 45.53 per hour.</pre>			<p>Next, we will demonstrate<a id="_idIndexMarker752"/> how to format verbs, such as <strong class="source-inline">gpa</strong>, to make them round to a specific number of <span class="No-Break">deci<a id="_idTextAnchor1496"/><a id="_idTextAnchor1497"/>mal places.</span></p>
			<h2 id="_idParaDest-317"><a id="_idTextAnchor1498"/>Additional options for formatting</h2>
			<p>Verbs can also be formatted by adding<a id="_idIndexMarker753"/> additional options to the verb. In our previous example, the <strong class="source-inline">gpa</strong> variable printed out some erroneous zeros. In this topic, we are going to demonstrate how to control the printing of certain verbs. If we want to round to a certain precision when using the <strong class="source-inline">%f</strong> verb, we can do so by placing a decimal and a number following the <strong class="source-inline">%</strong> symbol: <strong class="source-inline">%.2f</strong>. That would specify two decimal places, with the second one being rounded. Given the following examples, notice how the <em class="italic">n</em>th number is rounded to what is specified by the number (n) used in the<a id="_idTextAnchor1499"/> <strong class="source-inline">%.</strong><span class="No-Break"><strong class="source-inline">nf</strong></span><span class="No-Break"> verb:</span></p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B18621_11_04.jpg" alt="Figure 11.4: Rounding off decimals" width="541" height="654"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4: Rounding off decimals</p>
			<p>You can also specify the overall width of a number. The width of a number refers to the total characters of the number you are formatting, including the decimal point. You can specify the width of the number <a id="_idIndexMarker754"/>you are formatting by putting a number before the decimal point. <strong class="source-inline">%10.0f</strong> states the format will be a total width of 10; this includes the decimal point. It will pad with spaces if the width is less than what is being formatted, and it will be <span class="No-Break">right aligned.</span></p>
			<p>Let’s look at an example of formatting various numbers using the width and <strong class="source-inline">%.f</strong> <span class="No-Break">verb together:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
)
func main() {
    v := 1234.0
    v1 := 1234.6
    v2 := 1234.67
    v3 := 1234.678
    v4 := 1234.6789
    v5 := 1234.67891
    fmt.Printf("%10.0f\n", v)
    fmt.Printf("%10.1f\n", v1)
    fmt.Printf("%10.2f\n", v2)
    fmt.Printf("%10.3f\n", v3)
    fmt.Printf("%10.4f\n", v4)
    fmt.Printf("%10.5f\n", v5)
}</pre>			<p>Now, let’s understand this code <span class="No-Break">in detail:</span></p>
			<ul>
				<li>In the <strong class="source-inline">main()</strong> function, we <a id="_idIndexMarker755"/>declared variables with different <span class="No-Break">decimal places:</span><pre class="source-code">
func main() {
  v := 1234.0
  v1 := 1234.6
  v2 := 1234.67
  v3 := 1234.678
  v4 := 1234.6789
  v5 := 1234.67891</pre></li>				<li><strong class="source-inline">%10.0f</strong> states that the total width is ten with a precision <span class="No-Break">of zero:</span><pre class="source-code">
      fmt.Printf("%10.0f\n", v)</pre></li>				<li><strong class="source-inline">%10.1f</strong> states that the total width is ten with a precision <span class="No-Break">of one:</span><pre class="source-code">
      fmt.Printf("%10.1f\n", v1)</pre></li>				<li><strong class="source-inline">%10.2f</strong> states that the total width is ten with a precision <span class="No-Break">of two:</span><pre class="source-code">
      fmt.Printf("%10.2f\n", v2)</pre></li>				<li><strong class="source-inline">%10.3f</strong> states that the total width is ten with a precision <span class="No-Break">of three:</span><pre class="source-code">
      fmt.Printf("%10.3f\n", v3)</pre></li>				<li><strong class="source-inline">%10.4f</strong> states that the total width is ten with a precision <span class="No-Break">of four:</span><pre class="source-code">
      fmt.Printf("%10.4f\n", v4)</pre></li>				<li><strong class="source-inline">%10.5f</strong> states that the<a id="_idIndexMarker756"/> total width is ten with a precision <span class="No-Break">of five:</span><pre class="source-code">
      fmt.Printf("%10.5f\n", v5)
}</pre></li>			</ul>
			<p>The result i<a id="_idTextAnchor1500"/>s <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B18621_11_05.jpg" alt="Figure 11.5: Output after formatting verbs" width="95" height="108"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5: Output after formatting verbs</p>
			<ul>
				<li>To make the results left align your fields, you can use the <strong class="source-inline">–</strong> flag after the <strong class="source-inline">%</strong> symbol <span class="No-Break">as follows:</span><pre class="source-code">
    fmt.Printf("%-10.0f\n", v)
    fmt.Printf("%-10.1f\n", v1)
    fmt.Printf("%-10.2f\n", v2)
    fmt.Printf("%-10.3f\n", v3)
    fmt.Printf("%-10.4f\n", v4)
    fmt.Printf("%-10.5f\n", v5)</pre><p class="list-inset">Using the same variables as before, the results would be<a id="_idTextAnchor1501"/> <span class="No-Break">as follows:</span></p></li>			</ul>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/B18621_11_06.jpg" alt="Figure 11.6: Output after left aligning the formatted verbs" width="95" height="109"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6: Output after left aligning the formatted verbs</p>
			<p>We have just skimmed the surface of Go’s support for using verbs. You should, by now, have a fundamental understanding of how verbs work. We will continue to build on using verbs and the various <a id="_idIndexMarker757"/>ways to format <strong class="source-inline">print</strong> in the upcoming topics. This topic laid the groundwork for the techniques that we will be using to do <span class="No-Break">bas<a id="_idTextAnchor1502"/><a id="_idTextAnchor1503"/>ic debugging.</span></p>
			<h2 id="_idParaDest-318"><a id="_idTextAnchor1504"/>Exercise 11.02 – Printing decimal, binary, and hex values</h2>
			<p>In this exercise, we will be<a id="_idIndexMarker758"/> printing decimal, binary, and hex values from 1 to 255. The results should<a id="_idIndexMarker759"/> be right aligned. The decimal width should be set to 3, the binary or base 2 width set to 8, and the hex width set to 2. The aim of this<a id="_idIndexMarker760"/> exercise is to properly format the output of our data by using a Go standard <span class="No-Break">library package:</span></p>
			<ol>
				<li>Create a directory called <strong class="source-inline">Exercise11.02</strong> inside the <span class="No-Break"><strong class="source-inline">Chapter11</strong></span><span class="No-Break"> directory.</span></li>
				<li>Create a file called <strong class="source-inline">main.go</strong> inside the <span class="No-Break"><strong class="source-inline">Chapter11/Exercise11.02/</strong></span><span class="No-Break"> directory.</span></li>
				<li>Open the <span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break"> file.</span></li>
				<li>Import the <span class="No-Break">following packages:</span><pre class="source-code">
package main
import (
    "fmt"
)</pre></li>				<li>Add a <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {
}</pre></li>				<li>In the <strong class="source-inline">main()</strong> function, use a <strong class="source-inline">for</strong> loop that will loop up to <span class="No-Break">255 times:</span><pre class="source-code">
func main() {
    for i := 1; i &lt;= 255; i++ {
    }
}</pre></li>				<li>Next, we want to print the<a id="_idIndexMarker761"/> variable in three different ways, formatted<a id="_idIndexMarker762"/> to the <span class="No-Break">following specifications:</span><p class="list-inset">Display <strong class="source-inline">i</strong> as a decimal value with<a id="_idIndexMarker763"/> a width of 3 and <span class="No-Break">right aligned.</span></p><p class="list-inset">Display <strong class="source-inline">i</strong> as a base 2 value with a width of 8 and <span class="No-Break">right aligned.</span></p><p class="list-inset">Display <strong class="source-inline">i</strong> as a hex value with a width of 2 and <span class="No-Break">right aligned.</span></p><p class="list-inset">This code should be placed inside of the <span class="No-Break"><strong class="source-inline">for</strong></span><span class="No-Break"> loop:</span></p><pre class="source-code">
func main() {
    for i := 1; i &lt;= 255; i++ {
        fmt.Printf("Decimal: %3.d Base Two: %8.b Hex: %2.x\n", i, i, i)
    }
}</pre></li>				<li>At the command line, change the directory using the <span class="No-Break">following code:</span><pre class="source-code">
cd Chapter11/Exercise11.02/</pre></li>				<li>At the command line, type <span class="No-Break">the following:</span><pre class="source-code">
go build main.go</pre></li>				<li>Type the executable that was created from the <strong class="source-inline">go build</strong> command and <span class="No-Break">hit </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></li>
			</ol>
			<p>Here are the expected resul<a id="_idTextAnchor1505"/>ts of <span class="No-Break">the program:</span></p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B18621_11_07.jpg" alt="Figure 11.7: Expected output after printing the decimal, binary, and hex values" width="719" height="685"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7: Expected output after printing the decimal, binary, and hex values</p>
			<p>We have seen how to format <a id="_idIndexMarker764"/>our data using the <strong class="source-inline">Printf()</strong> function from the Go standard<a id="_idIndexMarker765"/> library <strong class="source-inline">fmt</strong> package. We will use this<a id="_idIndexMarker766"/> knowledge to perform some basic debugging of printing code markers in our programs. We will learn more about this in t<a id="_idTextAnchor1506"/><a id="_idTextAnchor1507"/>he <span class="No-Break">following section.</span></p>
			<h1 id="_idParaDest-319"><a id="_idTextAnchor1508"/>Basic debugging</h1>
			<p>We have been happily coding along. The big moment has arrived; it is time to run our program. We run our program and find the<a id="_idIndexMarker767"/> results are not as we expected them to be. In fact, something is grossly wrong. Our inputs and outputs are not matching up. So, how do we figure out what went wrong? Well, having bugs appear in our programs is something that we all face as developers. However, there is some basic debugging that we can perform to aid us in remediating or, at the very least, gathering information about <span class="No-Break">these bugs:</span></p>
			<ul>
				<li><strong class="bold">Printing out code markers in </strong><span class="No-Break"><strong class="bold">the code</strong></span><span class="No-Break">:</span><p class="list-inset">Markers in our code are <strong class="source-inline">print</strong> statements that help us to identify where we are in the program when the <span class="No-Break">bug occurred:</span></p><pre class="source-code">
fmt.Println("We are in function calculateGPA")</pre></li>				<li><strong class="bold">Printing out the type of </strong><span class="No-Break"><strong class="bold">the variable</strong></span><span class="No-Break">:</span><p class="list-inset">While debugging, it<a id="_idIndexMarker768"/> might be useful to know the variable type that we <span class="No-Break">are evaluating:</span></p><pre class="source-code">
fmt.Printf("fname is of type %T\n", fname)</pre></li>				<li><strong class="bold">Printing out the value of </strong><span class="No-Break"><strong class="bold">the variable</strong></span><span class="No-Break">:</span><p class="list-inset">Along with knowing the type of the variable, it is sometimes valuable to know the value that is stored in <span class="No-Break">the variable:</span></p><pre class="source-code">
fmt.Printf("fname value %#v\n", fname)</pre></li>				<li><strong class="bold">Performing </strong><span class="No-Break"><strong class="bold">debug logging</strong></span><span class="No-Break">:</span><p class="list-inset">At times, it might be necessary to print <strong class="source-inline">debug</strong> statements to a file: maybe there is an error that only occurs in a production environment, or perhaps we would like to compare the results of data printed in a file for different inputs to our code. This log-formatted message adjusting the message from the standard logger can help in <span class="No-Break">this case:</span></p><pre class="source-code">
log.Printf("fname value %#v\n", fname)</pre></li>			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">Formatting directives such as <strong class="source-inline">%T</strong> and <strong class="source-inline">%#v</strong> will be discussed a bit more later in <span class="No-Break">this chapter.</span></p>
			<p>Here are some ba<a id="_idTextAnchor1509"/>sic <span class="No-Break">debugging methods:</span></p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/B18621_11_08.jpg" alt="Figure 11.8: Basic debugging methods" width="662" height="665"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8: Basic debugging methods</p>
			<p>One of the first steps in <a id="_idIndexMarker769"/>debugging is to identify the general location of where the bug is in the code. Before you can start to analyze any data, we need to know where this bug is occurring. We do this by printing out markers in our code. Markers in our code are typically nothing more than <strong class="source-inline">print</strong> statements that help us to identify where we were in the program when the bug occurred. They are also used to narrow the scope of the location of the bug. Generally, this process involves placing a <strong class="source-inline">print</strong> statement with a message that shows us where we are in the code. If our code reaches that point, we can then determine, based on some conditions, whether that area is where the bug is. If we find that it is not, we potentially remove that <strong class="source-inline">print</strong> statement and place it in other spots in <span class="No-Break">the code.</span></p>
			<p>Given the following trivial example, here is a bug that returns <span class="No-Break">some output:</span></p>
			<pre class="console">
Incorrect value
Program exited: status 1.</pre>			<p>The code is reporting an error, but we do not know where the error is coming from. This code generates a random number, and that random number is passed to <strong class="source-inline">func a</strong> and <strong class="source-inline">func b</strong>. The value of the random number will depend on which function the error occurs in. The following code demonstrates the importance of having properly placed <strong class="source-inline">debug</strong> statements to help determine the area of code where a potential bug <span class="No-Break">is located:</span></p>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">main.go</p>
			<pre class="source-code">
func main() {
    r := random(1, 20)
    err := a(r)
    if err != nil {
        fmt.Println(err)
        os.Exit(1)
    }
    err = b(r)
    if err != nil {
        fmt.Println(err)
        os.Exit(1)
    }
}</pre>			<p>The full code is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter11/Example01/main.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter11/Example01/main.go</span></a><span class="No-Break">.</span></p>
			<ul>
				<li>We are using the <strong class="source-inline">rand</strong> package<a id="_idIndexMarker770"/> to generate a <span class="No-Break">random number.</span></li>
				<li><strong class="source-inline">rand.Seed()</strong> is used so that each time you run the program with <strong class="source-inline">rand.Intn</strong>, it lowers the possibility of returning the same number. <strong class="source-inline">rand.Seed()</strong> is deprecated as of Go 1.20 as there is no reason to call <strong class="source-inline">Seed</strong> with a random value. Programs that call <strong class="source-inline">Seed</strong> with a known value to get a specific sequence of results should use <strong class="source-inline">New(NewSource(seed))</strong> to obtain a local random value in future versions of Go. However, if you use the same seed each time, the random number generator will return the same number the first time you run the code. To minimize the probability of the same number being generated, we need to provide the seed function with a unique number each time. We use <strong class="source-inline">time.Now().UTC.UnixNano()</strong> to help our program get a more random number. It should be noted, though, that if you put this in a loop, the loop could iterate at a speed that <strong class="source-inline">time.Now().UTC.UnixNano()</strong> could generate the same time value. However, for our program, this is not as likely; rather, it is just <a id="_idIndexMarker771"/>something to consider in <span class="No-Break">future code.</span></li>
				<li><strong class="source-inline">rand.Intn((max-min)+1)+min</strong> is starting to generate a random number between two other numbers. In our program, it is 1 <span class="No-Break">and 20:</span><pre class="source-code">
func a(i int) error {
    if i &lt; 10 {
        fmt.Println("Error is in func a")
        return errors.New("Incorrect value")
    }
    return nil
}
func b(i int) error {
    if i &gt;= 10 {
        fmt.Println("Error is in func b.)
        return errors.New("Incorrect value")
    }
    return nil
}</pre></li>				<li>The preceding two functions evaluate <strong class="source-inline">i</strong> to see whether it falls within a given range. If the value that falls within that range returns an error, it also prints a <strong class="source-inline">debug</strong> statement to let us know where the <span class="No-Break">error occurred.</span></li>
			</ul>
			<p>By strategically placing <strong class="source-inline">print</strong> statements in our code, we can see which function an error <span class="No-Break">is in.</span></p>
			<p>The output should look something <span class="No-Break">like this:</span></p>
			<pre class="console">
Error is in func a
Incorrect value
Program exited: status 1.</pre>			<p>This section covered debugging basics. We were introduced to using <strong class="source-inline">print</strong> statements for debugging. In the next <a id="_idIndexMarker772"/>topic, we will build on our knowledge of printing and look at how to print the <span class="No-Break">variable type.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Due to the randomness of the value of <strong class="source-inline">r</strong>, it can be different, which will impact the results of the program to be either <strong class="source-inline">func a</strong> or <span class="No-Break"><strong class="source-inline">func b</strong></span><span class="No-Break">.</span></p>
			<p class="callout">Additionally, if you run the preceding program in the Go playground, it will give you the same result every time. This is due to the fact that the playground caches, so it does not adhere to the<a id="_idTextAnchor1510"/><a id="_idTextAnchor1511"/> randomness of <span class="No-Break">the answer.</span></p>
			<h2 id="_idParaDest-320"><a id="_idTextAnchor1512"/>Printing Go variable types</h2>
			<p>It is often useful to know the<a id="_idIndexMarker773"/> type of a variable when debugging. Go provides this functionality through the use of a <strong class="source-inline">%T</strong> verb. Go is case-sensitive. A capital <strong class="source-inline">%T</strong> means the type of the variable, and a lowercase <strong class="source-inline">%t</strong> means the <span class="No-Break"><strong class="source-inline">bool</strong></span><span class="No-Break"> type:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
)
type person struct {
    lname string
    age int
    salary float64
}
func main() {
    fname := "Joe"
    grades := []int{100, 87, 67}
    states := map[string]string{"KY": "Kentucky", "WV": "West Virginia", "VA": "Virginia"}
    p := person{lname:"Lincoln", age:210, salary: 25000.00}
    fmt.Printf("fname is of type %T\n", fname)
    fmt.Printf("grades is of type %T\n", grades)
    fmt.Printf("states is of type %T\n", states)
    fmt.Printf("p is of type %T\n", p)
}</pre>			<p>Here are the results of the<a id="_idIndexMarker774"/> preceding <span class="No-Break">code snippet:</span></p>
			<pre class="console">
fname is of type string
grades is of type []int
states is of type map[string]string
p is of type main.person</pre>			<p>The <strong class="source-inline">%T</strong> verb is used in each <strong class="source-inline">print</strong> statement to print the concrete type of the variable. In a previous topic, we printed out values. We can also print out a Go syntax representation of the type using <strong class="source-inline">%#v</strong>. It is useful to be able to print out the Go representation of a variable. The Go representation of a variable is the syntax that can be copied a<a id="_idTextAnchor1513"/>nd pasted into the <span class="No-Break">Go code:</span></p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B18621_11_09.jpg" alt="Figure 11.9: Syntax representation of the type using %T and the Go syntax representation, %#v" width="1003" height="267"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9: Syntax representation of the type using %T and the Go<a id="_idTextAnchor1514"/><a id="_idTextAnchor1515"/> syntax representation, %#v</p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor1516"/>Exercise 11.03 – Printing the Go representation of a variable</h2>
			<p>In this exercise, we will create a simple<a id="_idIndexMarker775"/> program that will demonstrate how to print out the Go representation of various variables. We will use various types (such as a string, slice, map, and a struct) and print the Go representations of <span class="No-Break">those types:</span></p>
			<ol>
				<li>Create a directory called <strong class="source-inline">Exercise11.03</strong> inside the <span class="No-Break"><strong class="source-inline">Chapter11</strong></span><span class="No-Break"> directory.</span></li>
				<li>Create a file called <strong class="source-inline">main.go</strong> inside the <span class="No-Break"><strong class="source-inline">Chapter11/Exercise11.03/</strong></span><span class="No-Break"> directory.</span></li>
				<li>Open the <span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break"> file.</span></li>
				<li>Add the following code <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">:</span><pre class="source-code">
package main
import (
    "fmt"
)</pre></li>				<li>Next, create a <strong class="source-inline">person</strong> struct with the same fields listed <span class="No-Break">as follows:</span><pre class="source-code">
type person struct {
    lname string
    age int
    salary float64
}</pre></li>				<li>Inside the <strong class="source-inline">main</strong> function, assign a value to the <span class="No-Break"><strong class="source-inline">fname</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
func main() {
    fname := "Joe"</pre></li>				<li>Create a <strong class="source-inline">slice</strong> literal and assign it to a <span class="No-Break"><strong class="source-inline">grades</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
    grades := []int{100, 87, 67}</pre></li>				<li>Create a <strong class="source-inline">map</strong> literal of a<a id="_idIndexMarker776"/> key string and a value string and assign it to a variable of states. This is a map of state abbreviations and their <span class="No-Break">respective names:</span><pre class="source-code">
    states := map[string]string{"KY": "Kentucky", "WV": "West Virginia", "VA": "Virginia"}</pre></li>				<li>Create a <strong class="source-inline">person</strong> literal and assign it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">p</strong></span><span class="No-Break">:</span><pre class="source-code">
    p := person{lname:"Lincoln", age:210, salary: 25000.00}</pre></li>				<li>Next, we will be printing out the Go representation of each of our variables <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">%#v</strong></span><span class="No-Break">:</span><pre class="source-code">
    fmt.Printf("fname value %#v\n", fname)
    fmt.Printf("grades value %#v\n", grades)
    fmt.Printf("states value %#v\n", states)
    fmt.Printf("p value %#v\n", p)
}</pre></li>				<li>At the command line, change the directory using the <span class="No-Break">following code:</span><pre class="source-code">
cd Chapter11/Exercise11.03/</pre></li>				<li>At the command line, type <span class="No-Break">the following:</span><pre class="source-code">
go build main.go</pre></li>				<li>Type the executable that was created from the <strong class="source-inline">go build</strong> command and <span class="No-Break">hit </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">:</span><pre class="source-code">
./main</pre></li>			</ol>
			<p>You wi<a id="_idTextAnchor1517"/>ll get the <span class="No-Break">following output:</span></p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/B18621_11_10.jpg" alt="Figure 11.10: Go representation of the types" width="1526" height="146"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10: Go representation of the types</p>
			<p>In this exercise, we saw how we can print the Go representation of simple types (the <strong class="source-inline">fname</strong> string) to more <a id="_idIndexMarker777"/>complex types such as a <strong class="source-inline">person</strong> struct. This is another tool in our toolbox that we can use for debugging; it allows us to see the data the way Go sees it. In the next topic, we will be looking at another tool to help us debug our code. We will be looking at how we log information that can be used<a id="_idTextAnchor1518"/><a id="_idTextAnchor1519"/> to further aid <span class="No-Break">in debugging.</span></p>
			<h1 id="_idParaDest-322"><a id="_idTextAnchor1520"/>Logging</h1>
			<p>Logging can be used to help debug a bug in <a id="_idIndexMarker778"/>our program. Operating systems log various information such as access to resources, what an application is doing, the overall health of the system, and much more. It is not doing this because there is an error; rather, it is logging to make it easier for the system administrator to determine what is going on with the operating system at various times. It allows for easier debugging when the operating system acts in an unusual way or performs a certain task that was not expected. This is the same attitude we should take when logging our application. We need to think about the information that we gather and how that would help us to debug the application if something is not performing the way we think <span class="No-Break">it should.</span></p>
			<p>We should be performing logging regardless of whether the program needs debugging. Logging is useful for understanding events that happen, the health of the application, any potential issues, and who is accessing our application or data. Logging is an infrastructure to your program that can be utilized when an abnormality occurs in the application. Logging helps us to track abnormalities that we would otherwise miss. In production, our code could be executed in different conditions compared to a development environment, such as an increase in the number of requests to <span class="No-Break">the server.</span></p>
			<p>If we do not have the ability to log this information and how our code performs, we could spend endless hours trying to figure out why our code behaves the way it does in production but not in development environments. Another example would be that we get some malformed data as a request in production, and our code does not handle the format properly and causes undesired behavior. Without proper logging, it could take an extraordinary amount of time to determine that we received data that we were not <span class="No-Break">adequately handling.</span></p>
			<p>The Go standard library<a id="_idIndexMarker779"/> provides a package called <strong class="source-inline">log</strong>. It includes basic logging that can be used by our programs. We will investigate how the package can be used to log <span class="No-Break">various information.</span></p>
			<p>Consider the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
package main
import (
    "log"
)
func main() {
    name := "Thanos"
    log.Println("Demo app")
    log.Printf("%s is here!", name)
    log.Print("Run")
}</pre>			<p>The <strong class="source-inline">Println()</strong>, <strong class="source-inline">Printf()</strong>, and <strong class="source-inline">Print()</strong> log functions perform the same functionality as their <strong class="source-inline">fmt</strong> counterparts, with one exception. When the log functions execute, it gives additional details such as the date and time of the execution, <span class="No-Break">as follows:</span></p>
			<pre class="console">
2019/11/10 23:00:00 Demo app
2019/11/10 23:00:00 Thanos is here!
2019/11/10 23:00:00 Run</pre>			<p>This information can be useful when investigating and reviewing the logs later and for understanding the order <a id="_idIndexMarker780"/>of events. We can even get more details to be logged by our logger. The Go <strong class="source-inline">log</strong> package has a <strong class="source-inline">SetFlags</strong> function that allows us to be <span class="No-Break">more specific.</span></p>
			<p>Here is a list of options for logging provided by the Go package that we can set in the <span class="No-Break">function (</span><a href="https://go.dev/src/log/log.go?s=8483:8506#L28"><span class="No-Break">https://go.dev/s<span id="_idTextAnchor1521"/>rc/log/log.go?s=8483:8506#L28</span></a><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/B18621_11_11.jpg" alt="Figure 11.11: List of flags in Go" width="1617" height="626"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11: List of flags in Go</p>
			<p>Let’s set some of the flags in <span class="No-Break"><em class="italic">Figure 11</em></span><em class="italic">.11</em> and observe the difference in behavior from what we <span class="No-Break">had before.</span></p>
			<p>Consider the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
package main
import (
    "log"
)
func main() {
    log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile)
    name := "Thanos"
    log.Println("Demo app")
    log.Printf("%s is here!", name)
    log.Print("Run")
}</pre>			<p>Let’s break down the code to understand <span class="No-Break">it better:</span></p>
			<pre class="source-code">
log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile)</pre>			<p><strong class="source-inline">log.Ldate</strong> is the date of the<a id="_idIndexMarker781"/> local time zone. This is the same information that was <span class="No-Break">logged before.</span></p>
			<p><strong class="source-inline">log.Lmicroseconds</strong> will give the microseconds of the formatted date. Note that we have not discussed time yet; for further details on time, please refer to <a href="B18621_12.xhtml#_idTextAnchor1532"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <span class="No-Break"><em class="italic">About Time</em></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">log.LlongFile</strong> will give us the full filename and line number that the log <span class="No-Break">comes from.</span></p>
			<p>The output is <span class="No-Break">as <a id="_idTextAnchor1522"/><a id="_idTextAnchor1523"/>follows:</span></p>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/B18621_11_12.jpg" alt="Figure 11.12: Output" width="1432" height="108"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12: Output</p>
			<h1 id="_idParaDest-323"><a id="_idTextAnchor1524"/>Logging fatal errors</h1>
			<p>Using the <strong class="source-inline">log</strong> package, we can also <a id="_idIndexMarker782"/>log fatal errors. The <strong class="source-inline">Fatal()</strong>, <strong class="source-inline">Fatalf()</strong>, and <strong class="source-inline">Fatalln()</strong> functions are similar to <strong class="source-inline">Print()</strong>, <strong class="source-inline">Printf()</strong>, and <strong class="source-inline">Println()</strong>. The difference is after logging, <strong class="source-inline">Fatal()</strong> functions are followed by an <strong class="source-inline">os.Exit(1)</strong> system call. The <strong class="source-inline">log</strong> package also has the following functions: <strong class="source-inline">Panic</strong>, <strong class="source-inline">Panicf</strong>, and <strong class="source-inline">Panicln</strong>. The difference between the <strong class="source-inline">Panic</strong> functions and the <strong class="source-inline">Fatal</strong> functions is that the <strong class="source-inline">Panic</strong> functions are recoverable. When using the <strong class="source-inline">Panic</strong> functions, you can use the <strong class="source-inline">defer()</strong> function, whereas when using the <strong class="source-inline">Fatal</strong> functions, you cannot. As stated earlier, the <strong class="source-inline">Fatal</strong> functions call <strong class="source-inline">os.Exit()</strong>; a <strong class="source-inline">defer</strong> function will not be called when <strong class="source-inline">os.Exit()</strong> gets called. There may be some instances where you want to abort the program immediately with no possibility of recovery. For example, the application may have gotten to a state where it is best to exit it before data corruption or undesired behavior results. Or, you may have developed a command-line utility that is used by others and you need to provide an exit code to the callers of your executable to signal it has completed <span class="No-Break">its tasks.</span></p>
			<p>In the following code example, we <a id="_idIndexMarker783"/>will look at how <strong class="source-inline">log.Fataln</strong> <span class="No-Break">is used:</span></p>
			<pre class="source-code">
package main
import (
    "log"
    "errors"
)
func main() {
    log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile)
    log.Println("Start of our app")
    err := errors.New("Application Aborted!")
    if err != nil {
        log.Fatalln(err)
    }
    log.Println("End of our app")
}</pre>			<p>Let’s break down the code to understand <span class="No-Break">it better:</span></p>
			<pre class="source-code">
log.Println("Start of our app")</pre>			<p>The statement prints to <strong class="source-inline">stdout</strong> with the date, time, and line number of the <span class="No-Break">log message:</span></p>
			<pre class="source-code">
err := errors.New("We crashed!")</pre>			<p>We create an error to test the logging of <span class="No-Break"><strong class="source-inline">Fatal()</strong></span><span class="No-Break"> errors:</span></p>
			<pre class="source-code">
log.Fatalln(err)</pre>			<p>We log the error, and then it exits <span class="No-Break">the program:</span></p>
			<pre class="source-code">
log.Println("End of our app")</pre>			<p>The line did not execute because we logged the error as <strong class="source-inline">fatal</strong>, and that caused the program <span class="No-Break">to exit.</span></p>
			<p>Here are the results. Notice<a id="_idIndexMarker784"/> that even though it was an error, it still logs the same details about the error as it does the print functionality, and then <span class="No-Break">it exits:</span></p>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/B18621_11_13.jpg" alt="Figure 11.13: Logging a fatal error" width="1436" height="74"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Fi<a id="_idTextAnchor1525"/><a id="_idTextAnchor1526"/>gure 11.13: Logging a fatal error</p>
			<h2 id="_idParaDest-324"><a id="_idTextAnchor1527"/>Activity 11.01 – Building a program to validate Social Security Numbers</h2>
			<p>In this activity, we are going to be validating <strong class="bold">Social Security Numbers</strong> (<strong class="bold">SSNs</strong>). Our program will be accepting SSNs without the dashes. We will want to log the validation process for the SSNs so that we can<a id="_idIndexMarker785"/> trace the entire process. Logging real SSNs in production applications is not a recommended practice as it includes sensitive information and would violate security measures; however, it is useful for a fun book activity. We do not want our application to stop if an SSN is invalid; we want it to log the invalid number and continue to the <span class="No-Break">next one:</span></p>
			<ol>
				<li>Create a custom error called <strong class="source-inline">ErrInvalidSSNLength</strong> for invalid <span class="No-Break">SSN length.</span></li>
				<li>Create a custom error called <strong class="source-inline">ErrInvalidSSNNumbers</strong> for SSNs that have <span class="No-Break">non-numeric digits.</span></li>
				<li>Create a custom error called <strong class="source-inline">ErrInvalidSSNPrefix</strong> for an SSN that has three zeros as <span class="No-Break">the prefix.</span></li>
				<li>Create a custom error called <strong class="source-inline">ErrInvalidDigitPlace</strong> for SSNs that start with a 9 if it requires 7 or 9 in the <span class="No-Break">fourth place.</span></li>
				<li>Create a function that returns an error if the SSN length is <span class="No-Break">not 9.</span></li>
				<li>Create a function that checks whether the SSN is a length of 9. The function returns an error that has the SSN that was invalid and a custom <span class="No-Break">error, </span><span class="No-Break"><strong class="source-inline">ErrInvalidSSNLength</strong></span><span class="No-Break">.</span></li>
				<li>Create a function that checks whether the SSN contains all numbers. The function returns an error that has the SSN that was invalid and a custom <span class="No-Break">error, </span><span class="No-Break"><strong class="source-inline">ErrInvalidSSNNumbers</strong></span><span class="No-Break">.</span></li>
				<li>Create a function that<a id="_idIndexMarker786"/> checks whether the SSN does not have a prefix of 000. The function returns an error that has the SSN that was invalid and a custom <span class="No-Break">error, </span><span class="No-Break"><strong class="source-inline">ErrInvalidSSNPrefix</strong></span><span class="No-Break">.</span></li>
				<li>Create a function that checks that if the SSN starts with a 9, then it requires a 7 or 9 in the fourth place. The function returns an error that has the SSN that was invalid and a custom <span class="No-Break">error, </span><span class="No-Break"><strong class="source-inline">ErrInvalidDigitPlace</strong></span><span class="No-Break">.</span></li>
				<li>In the <strong class="source-inline">main()</strong> function, create a slice of SSNs so that your program will validate each <span class="No-Break">of them.</span></li>
				<li>For each SSN that you are validating, if errors are returned from your functions that are being used to validate, then log those errors and continue processing <span class="No-Break">the slice.</span></li>
				<li>An example slice to validate is <span class="No-Break">as follows:</span><pre class="source-code">
validateSSN := []string{"123-45-6789", "012-8-678", "000-12-0962", "999-33- 3333", "087-65-4321","123-45-zzzz"}</pre></li>			</ol>
			<p>The preceding slice should have the <span class="No-Break">following output:</span></p>
			<pre class="console">
2024/02/12 07:09:14.015902 /Users/samcoyle/go/src/github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter11/Activity11.01/main.go:21: Checking data []string{"123-45-6789", "012-8-678", "000-12-0962", "999-33-3333", "087-65-4321", "123-45-zzzz"}
2024/02/12 07:09:14.016070 /Users/samcoyle/go/src/github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter11/Activity11.01/main.go:23: Validate data "123-45-6789" 1 of 6
2024/02/12 07:09:14.016085 /Users/samcoyle/go/src/github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter11/Activity11.01/main.go:23: Validate data "012-8-678" 2 of 6
2024/02/12 07:09:14.016089 /Users/samcoyle/go/src/github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter11/Activity11.01/main.go:31: the value of 0128678 caused an error: ssn is not nine characters long
2024/02/12 07:09:14.016092 /Users/samcoyle/go/src/github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter11/Activity11.01/main.go:23: Validate data "000-12-0962" 3 of 6
2024/02/12 07:09:14.016127 /Users/samcoyle/go/src/github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter11/Activity11.01/main.go:35: the value of 000120962 caused an error: ssn has three zeros as a prefix
2024/02/12 07:09:14.016132 /Users/samcoyle/go/src/github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter11/Activity11.01/main.go:23: Validate data "999-33-3333" 4 of 6
2024/02/12 07:09:14.016139 /Users/samcoyle/go/src/github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter11/Activity11.01/main.go:39: the value of 999333333 caused an error: ssn starts with a 9 requires 7 or 9 in the fourth place
2024/02/12 07:09:14.016141 /Users/samcoyle/go/src/github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter11/Activity11.01/main.go:23: Validate data "087-65-4321" 5 of 6
2024/02/12 07:09:14.016201 /Users/samcoyle/go/src/github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter11/Activity11.01/main.go:23: Validate data "123-45-zzzz" 6 of 6
2024/02/12 07:09:14.016204 /Users/samcoyle/go/src/github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter11/Activity11.01/main.go:27: the value of 12345zzzz caused an error: ssn has non-numeric digits</pre>			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found in the GitHub repository folder for this chapter: <a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter11/Activity11.01"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter11/Activity11.01</span></a><span class="No-Break">.</span></p>
			<p>In this activity, we used the <strong class="source-inline">log</strong> package to capture information to trace the process of validating an SSN. If we ever<a id="_idIndexMarker787"/> need to debug the validation process for our SSN, then we can look at the logging messages and follow the validation failures of the SSN. We also demonstrated how to format logging messages to contain information that would be needed <span class="No-Break">for debugging.</span></p>
			<h1 id="_idParaDest-325"><a id="_idTextAnchor1528"/>Debugging in live or restricted environments</h1>
			<p>Debugging is an indispensable skill in software development, especially when dealing with elusive bugs that only manifest in certain <a id="_idIndexMarker788"/>environments. In real-world scenarios, modifying code on the fly might not be feasible, making it crucial to <a id="_idIndexMarker789"/>master techniques that work seamlessly in live or <span class="No-Break">restricted environments.</span></p>
			<p>To best debug in those kinds of environments, you should consider the <span class="No-Break">following points:</span></p>
			<ul>
				<li><strong class="bold">Understand the environment</strong>: Before diving into debugging, take a step back. Understand the deployment setup, network configurations, and any security constraints. This information helps to anticipate potential issues and <span class="No-Break">streamline debugging.</span></li>
				<li><strong class="bold">Remote debugging with proper tools</strong>: Delve is a powerful debugger for Go that supports remote debugging. By using Delve, you can connect to a running Go process and inspect variables, set breakpoints, and step through code. This is an invaluable <span class="No-Break">debugging tool.</span></li>
				<li><strong class="bold">Observability of the code</strong>: Go’s built-in profiling tools, such as <strong class="source-inline">pprof</strong>, allow you to gather runtime statistics and profile your application’s performance. By exposing a profiling endpoint in your code, you can collect data from live systems without modifying the code after it’s deployed. The same can be said if you add metrics and additional observability to your application. There are also tools available to capture application logs and aggregate them to be searchable in the future. This provides additional context that can assist the <span class="No-Break">debugging process.</span></li>
				<li><strong class="bold">Utilize log levels</strong>: Utilizing the different log levels available in the language is useful in different environments. However, you should be cautious to not over-share information via logging – especially in the event of dealing with <span class="No-Break">private data.</span></li>
				<li><strong class="bold">Set up integrated development environment (IDE) debuggers</strong>: Modern IDEs such as Visual Studio Code or JetBrains GoLand provide robust debugging capabilities. You can use breakpoints, watch expressions, and walk-through code using your debugger in the IDE. This is extremely efficient in pinpointing problems but is not something you can do in every <span class="No-Break">deployment environment.</span></li>
				<li><strong class="bold">Feature flags and canary releases</strong>: Leveraging feature flags and/or canary releases enables you to selectively enable or disable specific functionalities in production. By gradually <a id="_idIndexMarker790"/>rolling out changes, you can observe the impact on a subset of users. This makes it easier to identify and address issues before a <span class="No-Break">widespread release.</span></li>
			</ul>
			<p>Overall, it’s important to note that debugging can be an art. What works in some environments may not work in others. For example, you cannot set up an IDE debugger on code already running in a production environment, but you can leverage this approach easily in developing <a id="_idIndexMarker791"/>your code. You may also only have issues that plague certain environments. This is the classic tale of “it works locally for me,” but you are plagued with dealing with the issue and could end up spending several hours/days<a id="_idIndexMarker792"/> testing code commits by committing against your <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) environment. It happens to the best of us and is also a fair approach to debugging, trying out changes in small increments until <span class="No-Break">it’s fixed.</span></p>
			<p>At the end of the day, knowledge is power, and knowing the tools available to best debug an issue can drastically reduce your debugging time. In addition, practicing debugging in different environments and forcing issues/incidents sometimes upon a team in planned scenarios can be a great way to prepare teams for produc<a id="_idTextAnchor1529"/><a id="_idTextAnchor1530"/>tion-level incidents where speed <span class="No-Break">is key.</span></p>
			<h1 id="_idParaDest-326"><a id="_idTextAnchor1531"/>Summary</h1>
			<p>In this chapter, we studied various methodologies for easing the debugging process such as coding incrementally and testing the code often, writing unit tests, handling all errors, and performing logging on <span class="No-Break">the code.</span></p>
			<p>Looking at the <strong class="source-inline">fmt</strong> package, we discovered various ways to output information to help us to find bugs. The <strong class="source-inline">fmt</strong> package offered different print formatting, verbs, and ways to control the output of verbs by the use of <span class="No-Break">various flags.</span></p>
			<p>With the usage of logging from Go’s standard library, we were able to see details of how our application was executed. The <strong class="source-inline">log</strong> package allowed us to see the file path and line number on which the log event took place. The <strong class="source-inline">log</strong> package came with various print functions that mimic some of the <strong class="source-inline">fmt</strong> print functions, which provided us with various insights into the usage of the verbs we learned in this chapter. We were able to perform basic debugging by using the standard library that is provided by Go. We looked at the <strong class="source-inline">log</strong> package and were introduced to the <strong class="source-inline">time</strong> type. We did not go into the details of Go’s implementations of time. We also saw various additional methodologies to debug code in live or <span class="No-Break">restricted environments.</span></p>
			<p>In the next chapter, we will be looking at how time is represented in Go. We will be discussing the various functions used with the <strong class="source-inline">time.Time</strong> type. We will also demonstrate how to convert time to various time constructs (such as nanoseconds, microseconds, milliseconds, seconds, minutes, hours, and so on). Then, we will finally learn about the underlying type <span class="No-Break">of time.</span></p>
		</div>
	</div></div></body></html>