- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: About Time
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于时间
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter demonstrates how Go handles variables representing time data, which
    is a very important aspect of the language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了 Go 如何处理表示时间数据的变量，这是语言的一个重要方面。
- en: By the end of this chapter, you will be able to create your own time format,
    compare and manage time, calculate the duration of time series, and format time
    according to user requirements.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够创建自己的时间格式，比较和管理时间，计算时间序列的持续时间，并根据用户要求格式化时间。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you''ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter12](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter12).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要 Go 版本 1.21 或更高。本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter12](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter12)。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The previous chapter introduced you to basic debugging in Go. The more you develop
    code in Go, the better you get; however, developing and deploying code may come
    with corner cases that need to be debugged. The previous chapter showed you how
    to use the `fmt` package, how to log in to files, and how to use printing verbs
    for string formatting.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章向您介绍了 Go 中的基本调试。在 Go 中编写代码越多，您就会变得越好；然而，开发和部署代码可能会遇到需要调试的边缘情况。上一章展示了如何使用
    `fmt` 包，如何将日志写入文件，以及如何使用打印动词进行字符串格式化。
- en: This chapter is dedicated to teaching you all you need to know about handling
    variables that represent time data. You will learn how to do it the “Go way.”
    First, we will start out with basic time creation, timestamps, and more; then,
    we will learn how to compare and manipulate time, calculate the duration between
    two dates, and create timestamps. Finally, we will learn how to format time according
    to our needs. So, let’s not waste any more time and jump right in.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于向您传授关于处理表示时间数据的变量所需的所有知识。您将学习如何以“Go 方式”来做这件事。首先，我们将从基本的时间创建、时间戳等开始；然后，我们将学习如何比较和操作时间，计算两个日期之间的持续时间，并创建时间戳。最后，我们将学习如何根据我们的需求格式化时间。所以，让我们不要浪费时间，直接开始吧。
- en: Making time
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建时间
- en: 'Making time means declaring a variable that holds the time formatted in a specific
    way. Formatting time will be covered at the end of this chapter; so, for now,
    we will use the default formatting that is provided by Go. In this topic, we will
    be executing everything in the `main()` function of our script, so the skeleton
    should look like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 创建时间意味着声明一个变量，该变量以特定方式格式化时间。时间格式化将在本章末尾介绍；因此，现在我们将使用 Go 提供的默认格式化。在本主题中，我们将在脚本中的
    `main()` 函数中执行一切，因此骨架应该如下所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s look at our skeleton first and learn how to create and manipulate `time`
    variables. Our skeleton has the standard `package main` definition that is necessary.
    We use the `fmt` package to print the output to the console. Since we’ll be using
    the `time` package, we’ll need to import that as well.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们的骨架，并学习如何创建和操作 `time` 变量。我们的骨架包含必要的标准 `package main` 定义。我们使用 `fmt` 包将输出打印到控制台。由于我们将使用
    `time` 包，因此我们还需要导入它。
- en: Whenever we issue `go run <script>.go`, the `main()` function gets called and
    executes whatever is declared in it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们执行 `go run <script>.go` 时，`main()` 函数会被调用并执行其中声明的任何内容。
- en: 'One of the most common jobs for the `time` package is to measure the duration
    of the execution of the script. We can do this by capturing the current time in
    a variable, at the beginning, and at the end so that we can calculate the difference
    and know how long the specific action took to complete. The time difference will
    be shown later in the book chapter. The very first example is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`time` 包最常见的任务之一是测量脚本的执行持续时间。我们可以通过在开始和结束时捕获当前时间到变量中来实现这一点，以便我们可以计算差异并知道特定操作完成所需的时间。时间差将在本书的后续章节中展示。第一个示例如下：'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output from our script should look like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本的输出应该看起来像这样：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, this does not look very fancy; however, by the end of this chapter,
    you will have learned how to make it more readable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这看起来并不十分花哨；然而，到本章结束时，您将学会如何使它更加易读。
- en: 'Consider the following scenario: your employer gives you a task to develop
    a small Go application that tests a web application based on the day of the week.
    Your employer has the main release of a new web app every Monday at 12:00 A.M.
    CEST. With a downtime window from 12:00 A.M. CEST to 2:00 P.M. CEST, and the deployment
    being about 30 minutes, you have 1.5 hours to test the app. This is where Go’s
    `time` package comes to your rescue. The script performs a `hit-n-run` test on
    the other days of the week, but on release day, you are required to perform a
    `full-blown` functionality test. The first version of the script took the argument
    to see which test to perform, but the second script version made the decision
    based on the day and the hour:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景：你的雇主给你一个任务，让你开发一个小型的 Go 应用程序，该应用程序基于星期几测试一个网络应用程序。你的雇主每周一凌晨 12:00 CEST
    发布新的网络应用程序的主要版本。从凌晨 12:00 CEST 到下午 2:00 CEST 有一个停机窗口，部署大约需要 30 分钟，你有一小时 30 分钟的时间来测试应用程序。这就是
    Go 的 `time` 包能帮助你解决问题的地方。脚本在周的其他天进行 `hit-n-run` 测试，但在发布日，你需要执行一个完整的 `full-blown`
    功能测试。脚本的第一个版本接受一个参数来决定执行哪种测试，但第二个版本的脚本基于日期和小时来做出决定：
- en: '![Figure 12.1: Testing strategies](img/B18621_12_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1：测试策略](img/B18621_12_01.jpg)'
- en: 'Figure 12.1: Testing strategies'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：测试策略
- en: 'Consider the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The current day of the week is captured in the variable called `day`. The hour
    of execution is also captured in the variable called `hour`. When this script
    is executed, there are two types of output.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当前星期几被捕获在名为 `day` 的变量中。执行的小时也被捕获在名为 `hour` 的变量中。当这个脚本执行时，有两种类型的输出。
- en: 'The first one is a simple `hit-n-run` output, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是一个简单的 `hit-n-run` 输出，如下所示：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The second one is the `full blown` output, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是 `full blown` 输出，如下所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we have seen how the day of execution modifies the behavior
    of the application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到了执行日期如何修改应用程序的行为。
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The actual test was left out intentionally as this is not part of the chapter’s
    topic. However, the output clearly shows which part was responsible for the control
    of the test.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的测试被有意省略，因为这不是本章主题的一部分。然而，输出清楚地显示了哪个部分负责控制测试。
- en: 'Another example would be to create the log filenames for scripts in Go. The
    basic idea is to collect a log per day and have a timestamp concatenated with
    the name of the log file. The skeleton looks like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是在 Go 中创建脚本的日志文件名。基本思路是每天收集一个日志，并将时间戳连接到日志文件名中。其结构如下：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In Go, there is an elegant and simple way to do it within your main function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，在你的主函数中有一个优雅且简单的方法来做这件事：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output appears as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, there is a catch. If you want to concatenate strings with `time` types,
    which are not implicitly convertible, use the `strconv` package, which needs to
    be imported on top of your script:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题。如果你想要将 `time` 类型的字符串连接起来，这些类型不是隐式可转换的，你需要使用 `strconv` 包，这需要在你的脚本顶部导入：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In turn, this allows you to call the `strconv.Itoa()` function, which converts
    your `Year` and `Day` values and, finally, lets you concatenate them into a single
    string.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 依次，这允许你调用 `strconv.Itoa()` 函数，该函数将你的 `Year` 和 `Day` 值转换为字符串，最终让你将它们连接成一个单一的字符串。
- en: Now that we have learned how to make `time` variables, let’s learn to compare
    them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何创建 `time` 变量，接下来让我们学习如何比较它们。
- en: Exercise 12.01 – Creating a function to return a timestamp
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.01 – 创建一个返回时间戳的函数
- en: 'In this exercise, we will create a function called `whatstheclock`. The goal
    of this function is to demonstrate how you can create a function that wraps a
    nice, formatted `time.Now()` function and returns the date in an `ANSIC` format.
    The `ANSIC` format will be explained in further detail in the *Formatting* *time*
    section:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个名为 `whatstheclock` 的函数。这个函数的目标是展示如何创建一个函数，该函数封装了一个格式化的 `time.Now()`
    函数，并以 `ANSIC` 格式返回日期。`ANSIC` 格式将在 *格式化* *时间* 部分中进一步详细说明：
- en: Create a new folder and add a `main.go` file.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个 `main.go` 文件。
- en: 'Initialize the script with `package` and `import` statements:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `package` 和 `import` 语句初始化脚本：
- en: '[PRE10]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define a function called `whatstheclock()`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `whatstheclock()` 的函数：
- en: '[PRE11]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `main()` function, define a call to the `whatstheclock()` function and
    print the result to the console:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，定义对 `whatstheclock()` 函数的调用，并将结果打印到控制台：
- en: '[PRE12]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Save the file and run the code:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并运行代码：
- en: '[PRE13]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should see the following output:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE14]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this exercise, we demonstrated how you can create a small function that returns
    the current time in an `ANSIC` format.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们展示了如何创建一个返回当前时间的 `ANSIC` 格式的小函数。
- en: Note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Any type of operating system that you work with will provide two types of clocks
    to measure the time; one is called the “monotonic clock,” and the other is called
    the “wall clock.” The wall clock is what you see on a Windows machine in the taskbar;
    it’s subject to change and is usually synchronized with a public or corporate
    **Network Time Protocol** (**NTP**) server based on your current location. NTP
    is used to tell clients the time based on an atomic clock or from a satellite
    reference.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你所使用的任何类型的操作系统都会提供两种类型的时钟来测量时间；一种称为“单调时钟”，另一种称为“墙钟”。墙钟是你可以在 Windows 机器的任务栏上看到的时间；它会发生变化，通常根据你的当前位置与公共或企业
    **网络时间协议** (**NTP**) 服务器同步。NTP 用于根据原子钟或卫星参考向客户端告知时间。
- en: Comparing time
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较时间
- en: Most of the time, when working with Go on smaller scripts, it is very important
    for your statistics to know when a script should run, or between what hours and
    minutes a script should be completed. By statistics, we mean knowing how much
    time the app saves by executing a specific operation compared to what time cost
    it would have if we had to perform these manually. This allows us to measure the
    improvement of the script over time when we develop the functionality further.
    In this topic, we will look at some live examples demonstrating how you can solve
    this problem.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，当在较小的脚本上使用 Go 时，了解脚本何时应该运行，或者脚本应该在什么小时和分钟内完成，对于你的统计信息来说非常重要。通过统计，我们指的是知道通过执行特定操作节省了多少时间，与如果我们必须手动执行这些操作所花费的时间相比。这允许我们在进一步开发功能时，测量脚本随时间改进的情况。在这个主题中，我们将查看一些实际例子，展示你如何解决这个问题。
- en: Let’s look at the logic for the first script, which was intended not to run
    before or after a specified time. This time can arrive either via another automation
    or when a trigger file is manually placed there; every day, the script needs to
    run at different times –specifically, after the specified time as soon as possible.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第一个脚本的逻辑，该脚本旨在在指定时间之前或之后不运行。这个时间可以通过另一个自动化或当手动放置触发文件来到达；每天，脚本需要在不同时间运行——具体来说，尽可能在指定时间之后运行。
- en: 'The time was in the following `2023-09-27T22:08:41+00:00` format:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 时间格式如下所示：`2023-09-27T22:08:41+00:00`
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the script when we are not yet at the deadline is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们还没有到达截止日期时，脚本的输出如下：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we meet the criteria, the output looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们满足条件时，输出如下所示：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s examine what is happening here. We create a `now` variable, which is
    crucial for the execution. We have the `time` string parsed based on `RFC3339`.
    `RFC3339` specifies the format that should be used for the `date` and `time` strings.
    This function returns two values: one value is the output if the conversion succeeds,
    and the other is the error if there is one. We capture the output in the onlyAfter
    variable, along with the error, err. We could use a standard variable such as
    onlyAfterError, but unless we use that variable later in time, the compiler will
    throw an error that the variable was declared but never used. This is circumvented
    using the _ variable. Based on this logic, we could implement the `onlyBefore`
    argument or variable very simply. The `time` package has two particularly useful
    functions: one is called `After()`, and the other is called `Before()`. They allow
    us to simply compare two `time` variables.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这里发生了什么。我们创建了一个 `now` 变量，这对于执行至关重要。我们根据 `RFC3339` 解析了 `time` 字符串。`RFC3339`
    指定了应该用于 `date` 和 `time` 字符串的格式。这个函数返回两个值：一个值是转换成功时的输出，另一个是存在错误时的错误。我们将输出捕获在 onlyAfter
    变量中，以及错误 err。我们本可以使用一个标准变量，如 onlyAfterError，但除非我们在稍后使用该变量，否则编译器会抛出一个错误，指出该变量已声明但未使用。我们使用
    _ 变量来规避这个问题。基于这个逻辑，我们可以非常简单地实现 `onlyBefore` 参数或变量。`time` 包有两个特别有用的函数：一个是名为 `After()`
    的函数，另一个是名为 `Before()` 的函数。它们允许我们简单地比较两个 `time` 变量。
- en: There is a third function in the package called `Equal()`. This function allows
    you to compare two `time` variables and returns `true` or `false` depending on
    whether they are equal.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 包含一个名为 `Equal()` 的第三个函数。这个函数允许你比较两个 `time` 变量，并根据它们是否相等返回 `true` 或 `false`。
- en: 'Let us look at an example of the `Equal()` function in action:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Equal()` 函数的实际应用例子：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来是这样的：
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let’s see what happens here. We have three `time` variables, which are called
    `now`, `now_too`, and `later`. The `time` module’s `Sleep()` function is used
    to simulate the latency of 2 seconds. This function takes an integer argument
    and waits for the given time to pass and then continues the execution. The result
    of this is that the `later` variable holds different time values and allows us
    to demonstrate the `Equal()` function’s purpose, which you can see in the output.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里会发生什么。我们有三个`时间`变量，分别称为`now`、`now_too`和`later`。`time`模块的`Sleep()`函数用于模拟2秒的延迟。这个函数接受一个整数参数，等待给定时间过去后继续执行。结果是`later`变量持有不同的时间值，使我们能够展示`Equal()`函数的目的，您可以在输出中看到。
- en: Now, the time has come to check what facilities are provided to calculate the
    duration or difference between the two `time` variables.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候检查计算两个`时间`变量之间的持续时间或差异所提供的设施了。
- en: Duration calculation
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续时间计算
- en: The ability to calculate the duration of an execution comes in handy during
    many aspects of programming. In our everyday lives, we can monitor discrepancies
    and performance bottlenecks that our infrastructure might face. For example, if
    you have a script that takes only 5 seconds to complete on average and the monitoring
    execution time shows you a huge bump during certain hours of a day or certain
    days, it might be wise to investigate. The other aspect is related to web applications.
    Measuring the duration of request-response in your scripts can give you an insight
    into how well invested you are in your apps to serve high loads, and it even allows
    you to expand your capacity on certain days or weeks of the year. For example,
    if you have an online shop dealing with products, it might be wise to size your
    capacity according to patterns such as Black Friday or Christmas.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程的许多方面，计算执行时间的能力都很有用。在我们的日常生活中，我们可以监控我们的基础设施可能面临的不一致性和性能瓶颈。例如，如果您有一个脚本平均只需要5秒钟就能完成，而监控执行时间显示您在一天中的某些小时或某些天有巨大的波动，那么进行调查可能很明智。另一个方面与Web应用程序有关。测量脚本中请求-响应的持续时间可以让你了解您在应用程序中投入了多少来应对高负载，甚至允许你在一年中的某些日子或周扩展您的容量。例如，如果您有一个在线商店处理产品，根据像黑色星期五或圣诞节这样的模式来调整您的容量可能很明智。
- en: 'You may do well with a lower capacity during most of the year, but those holidays
    can result in revenue loss if the infrastructure is not sufficiently well sized.
    There is very little coding required to add such functionality to your scripts.
    Let’s now look at how to do it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数时间里，你可能可以用较低的能力完成工作，但如果基础设施规模不够，那些假期可能会导致收入损失。向你的脚本添加此类功能所需的编码非常少。现在让我们看看如何实现：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you execute this script, the result will be something like this, depending
    on the PC’s performance:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行此脚本，结果将类似于以下内容，具体取决于PC的性能：
- en: '![Figure 12.2: Measuring the execution time](img/B18621_12_02.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2：测量执行时间](img/B18621_12_02.jpg)'
- en: 'Figure 12.2: Measuring the execution time'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：测量执行时间
- en: All that needs to be done is to capture the time when the script starts and
    ends. Then, we can calculate the duration by subtracting the start time and the
    end time. After that, we can utilize the `Duration` variable’s functions to get
    the `Hours()`, `Minutes()`, `Seconds()`, and `Nanoseconds()` values of the time
    it took to complete the task.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所需做的只是捕捉脚本开始和结束的时间。然后，我们可以通过减去开始时间和结束时间来计算持续时间。之后，我们可以利用`Duration`变量的函数来获取完成任务所需时间的`小时()`、`分钟()`、`秒()`和`纳秒()`值。
- en: 'There are four resolutions you will be provided with – namely, the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您将获得四种分辨率，具体如下：
- en: '`Hours`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`小时`'
- en: '`Minutes`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`分钟`'
- en: '`Seconds`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`秒`'
- en: '`Nanoseconds`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`纳秒`'
- en: If you need, for example, days, weeks, or months, then you can calculate it
    from the resolutions provided.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要，例如，天、周或月，则可以从提供的分辨率中计算出来。
- en: 'Back in the day, we had a requirement to measure the duration of transactions,
    and we had a **service-level agreement** (**SLA**) that needed to be met. This
    meant that there were applications that needed to process a request in, let’s
    say, 1,000 ms or 5 s depending on the criticality of the product. The next script
    will show you how this was implemented. There are six different resolutions that
    you have the option to choose from:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我们有一个要求测量事务持续时间的任务，并且我们需要满足一个**服务级别协议**（**SLA**）。这意味着有一些应用程序需要处理请求，比如1,000毫秒或5秒，这取决于产品的关键性。接下来的脚本将向你展示这是如何实现的。你有六个不同的分辨率可供选择：
- en: '`Hour`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`小时`'
- en: '`Minute`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`分钟`'
- en: '`Second`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`秒`'
- en: '`Millisecond`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`毫秒`'
- en: '`Microsecond`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`微秒`'
- en: '`Nanosecond`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`纳秒`'
- en: 'Let’s consider the following example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we don’t meet the deadline, the output is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们没有满足截止时间时，输出如下：
- en: '![Figure 12.3: Transaction deadline not met](img/B18621_12_03.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3：未满足事务截止时间](img/B18621_12_03.jpg)'
- en: 'Figure 12.3: Transaction deadline not met'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：未满足事务截止时间
- en: 'When we meet the deadline, it looks like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们满足截止时间时，看起来是这样的：
- en: '![Figure 12.4: Transaction deadline met](img/B18621_12_04.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4：事务截止时间满足](img/B18621_12_04.jpg)'
- en: 'Figure 12.4: Transaction deadline met'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：事务截止时间满足
- en: Let’s dissect our example. First, we define a deadline for the transaction with
    the `time.Duration()` variable. In my experience, the `Millisecond` resolution
    is optimal; however, it does take some time to get used to calculating it. Feel
    free to use whichever resolution you prefer. We mark the beginning with the `start`
    variable, do some calculations, and mark the completion with the `end` variable.
    The magic happens after this. We would like to calculate the difference between
    the deadline and the transaction duration, but we cannot do it directly. We need
    to convert the `duration` value to `transaction` time. This was done the same
    way when we created our deadline. We simply use the `Nanosecond` resolution, which
    is the lowest resolution we should go to. However, in this case, you can use the
    resolution you would like. After conversion, we can easily compare and decide
    whether the transaction is fine or not.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们剖析我们的示例。首先，我们使用`time.Duration()`变量定义事务的截止时间。根据我的经验，`毫秒`的分辨率是最优的；然而，适应计算它需要一些时间。你可以自由选择你喜欢的任何分辨率。我们用`start`变量标记开始，做一些计算，然后用`end`变量标记完成。魔法就在这里发生。我们想要计算截止时间和事务持续时间之间的差异，但我们不能直接这样做。我们需要将`duration`值转换为`transaction`时间。我们在创建截止时间时也是这样做的。我们简单地使用`纳秒`分辨率，这是我们应达到的最低分辨率。然而，在这种情况下，你可以使用你想要的任何分辨率。转换后，我们可以轻松地比较并决定事务是否正常。
- en: Now, let’s see how we can manipulate time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何可以操作时间。
- en: Managing time
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间管理
- en: The Go programming language’s `time` package provides two functions that allow
    you to manipulate time. One of them is called `Sub()`, and the other one is called
    `Add()`. There have not been many cases, in my experience, where this has been
    used. Mostly, when calculating the elapsed time of a script’s execution, the `Sub()`
    function is used to tell the difference.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Go编程语言的`time`包提供了两个函数，允许你操作时间。其中一个被称为`Sub()`，另一个被称为`Add()`。在我的经验中，这种情况并不常见。大多数情况下，当计算脚本的执行时间时，使用`Sub()`函数来告知差异。
- en: 'Let’s see what the addition looks like:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看加法看起来是什么样子：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After execution, the following output welcomes us:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，以下输出欢迎我们：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s inspect what happened here. We created a variable to hold our time, which
    requires some manipulation. The `toBeAdded` variable represents a duration of
    10 seconds, which we would like to add. The `Add()` function of the `time` package
    expects a variable of the `time.Duration()` type. Then, we simply call the `Add()`
    function of our date, and the result is visible on the console. The functionality
    of the `Sub()` function is rather cumbersome, and it is not really intended to
    remove a specific duration from the time we have. It can be done, but you need
    many more lines of code to achieve this. What you can do is craft your duration
    with a negative value. Swap out the second line for this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这里发生了什么。我们创建了一个变量来保存我们的时间，这需要一些操作。`toBeAdded`变量代表10秒的持续时间，这是我们想要添加的。`time`包的`Add()`函数期望一个`time.Duration()`类型的变量。然后，我们简单地调用我们的日期的`Add()`函数，结果在控制台上可见。`Sub()`函数的功能相当繁琐，它并不是真正用来从我们拥有的时间中移除特定持续时间的。这是可以做到的，但你需要更多的代码行来实现这一点。你可以通过使用负值来构建你的持续时间。将第二行替换为以下内容：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It will work just fine and output you this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This works as we expected; we have successfully calculated what time it was
    10 minutes ago.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.02 – Duration of execution
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will craft a function that allows you to calculate the
    duration of the execution between two `time.Time` variables and return a string
    that tells you how long the execution took to complete.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps in order:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize the script with the following `package` and `import` statements:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s now define our `elapsedTime()` function:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, we are ready to define our `main()` function:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following should appear as the output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this exercise, we created a function that shows us how many hours, minutes,
    and seconds it took to execute the action. This is useful because you can reuse
    this function in other Go apps.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s turn our eyes toward the formatting of time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Formatting time
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far in this chapter, you may have noticed that the dates are pretty ugly.
    I mean, take a look at the following lines:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These were intentionally left there to force you to think about whether this
    is all that Go can do. Is there a way to format these lines to make them more
    convenient and easier to read? If so, what are those extra lines?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will answer those questions. When we talk about time formatting, there
    are two main concepts we are referring to. The first option is for instances when
    we would like our `time` variable to output a desirable-looking string when we
    use it in print, and the second option is for when we would like to take a string
    and parse it to a specific format. Both have their own use cases; we are going
    to look at them in more detail as I teach you how to use both.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to learn about the `Parse()` function. This function has
    essentially two arguments. The first one is the format string to parse against,
    and the second one is the string that needs to be parsed. The end of this parse
    will result in a `time` variable that can utilize built-in Go functions. Go uses
    a POSIX-based date format, where `Parse()` is very useful when you have an application
    that is working with time values from different time zones and you would like
    to convert them, for example, to the same time zone for better understanding and
    easier comparison:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This date format is equal to “`123456`” in POSIX, which can be decoded from
    the preceding example. There are constants provided in the language to help you
    deal with parsing different time strings.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main time formats against which we can parse:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '`RFC3339`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnixDate`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ANSIC`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at how `Parse()` works:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'What happens behind the scenes is as follows. We have the `t1`, `t2`, and `t3`
    variables that hold the time, which is parsed against the specified format. The
    `err` variables hold the error results if there are any during the conversion.
    The output from the `t1` variable is the only one that makes sense; `UnixDate`
    and `ANSIC` are wrong because the wrong string is parsed against the format. `UnixDate`
    expects something that they call `epoch`. The epoch is a very unique date; on
    Unix systems, it marks the beginning of time, which starts at January 1, 1970\.
    It expects a huge integer, which is the number of seconds elapsed since this date.
    The format expects something like this as the input: `Mon Sep _27 18:24:05 2019`.
    Providing such time allows the `Parse()` function to provide the correct output.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 背后发生的事情如下。我们有 `t1`、`t2` 和 `t3` 变量，它们持有时间，这些时间与指定的格式进行解析。`err` 变量持有转换过程中可能出现的错误结果。`t1`
    变量的输出是唯一有意义的；`UnixDate` 和 `ANSIC` 是错误的，因为它们解析了错误的字符串。`UnixDate` 期望一些它们称之为 `epoch`
    的东西。epoch 是一个非常独特的日期；在 Unix 系统中，它标志着时间的开始，始于 1970 年 1 月 1 日。它期望一个巨大的整数，这是从这个日期开始经过的秒数。格式期望类似以下的输入：`Mon
    Sep _27 18:24:05 2019`。提供这样的时间允许 `Parse()` 函数提供正确的输出。
- en: Now that we have clarified the `Parse()` function, it’s time to look at the
    `Format()` function.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经明确了 `Parse()` 函数，那么是时候看看 `Format()` 函数了。
- en: 'Go allows you to craft your own `time` variables. Let’s learn how we can do
    that and, afterward, we will format them:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Go 允许你自定义 `时间` 变量。让我们学习如何实现这一点，然后我们将对它们进行格式化：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code demonstrates how you can craft the time for yourself; however,
    we are going to look at what all those numbers are. The skeleton syntax for that
    is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码演示了如何自己构建时间；然而，我们将看看所有这些数字代表什么。那个骨架语法如下：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Essentially, we need to specify the year, month, day, hour, and so on. We would
    like to reformat our output based on the input variables; this should appear as
    follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们需要指定年、月、日、小时等等。我们希望根据输入变量重新格式化输出；这应该看起来如下：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Time zones were not important until people started working in big enterprise
    environments. When you have a global fleet of interconnected devices, it is important
    to be able to differentiate between time zones. If you want to have an `AddDate()`
    function, which can be used to add `Year`, `Month`, and `Day` to your current
    time, then this must enable you to dynamically add to your dates. Let’s look at
    an example. Given our previous date, let’s add 1 year, 2 months, and 3 days:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在人们开始在大企业环境中工作之前，时区并不重要。当你拥有一个全球性的互联设备群时，能够区分时区就变得很重要了。如果你想要一个 `AddDate()` 函数，它可以用来将
    `年`、`月` 和 `日` 添加到当前时间，那么这必须允许你动态地添加到你的日期中。让我们看看一个例子。给定我们之前的日期，让我们添加 1 年、2 个月和
    3 天：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You will get the following output upon execution of this program:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会得到以下输出：
- en: '[PRE39]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `AddDate()` function takes three arguments: the first is `years`, the second
    is `months`, and the third is `days`. This gives you the opportunity to fine-tune
    the scripts you have. To properly understand how formatting works, you need to
    know what is under the hood.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddDate()` 函数接受三个参数：第一个是 `years`，第二个是 `months`，第三个是 `days`。这给了你调整你脚本的精细机会。为了正确理解格式化是如何工作的，你需要知道内部是如何运作的。'
- en: One last important aspect of time formatting is to understand how you can utilize
    the `LoadLocation()` function of the `time` package to convert your local time
    to the local time of another time zone. Our reference time zone will be the `Los
    Angeles` time zone. The `Format()` function is used to tell Go how we would like
    to see our output formatted. The `In()` function is a reference to a specific
    time zone we want our formatting to be present in.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 时间格式化中的一个最后重要方面是了解你如何利用 `time` 包中的 `LoadLocation()` 函数将你的本地时间转换为另一个时区的本地时间。我们的参考时区将是
    `洛杉矶` 时区。`Format()` 函数用于告诉 Go 我们希望如何格式化输出。`In()` 函数是指定我们希望格式化存在的特定时区的引用。
- en: 'Let’s find out what the time is in Los Angeles:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出洛杉矶的时间：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Depending on your day of execution, you should see the following output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你执行的日子，你应该看到以下输出：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The key here is that we get our local time in a variable, and then we use the
    `In()` function of the `time` package to, say, convert that value to a specific
    time zone’s value. It’s simple, yet useful.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于我们得到本地时间在一个变量中，然后我们使用 `time` 包中的 `In()` 函数，比如说，将那个值转换为特定时区的值。这很简单，但很有用。
- en: Exercise 12.03 – What is the time in your zone?
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.03 – 您所在时区的时间是什么？
- en: In this exercise, we will create a function that tells the difference between
    the current time zone and the specified time zone. The function will utilize the
    `LoadLocation()` function to specify the location based on which a variable will
    be set to a specific time. The `In()` location will be used to convert a specific
    time value to a given time zone value. The output format should be in the `ANSIC`
    standard.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，我们将创建一个函数，它将告诉当前时区与指定时区之间的差异。该函数将利用 `LoadLocation()` 函数根据位置指定变量，该变量将被设置为特定的时间。`In()`
    位置将用于将特定的时间值转换为给定时区的时间值。输出格式应为 `ANSIC` 标准。
- en: 'Perform the following steps in order:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下顺序执行以下步骤：
- en: Create a new folder and add a `main.go` file.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个 `main.go` 文件。
- en: 'Initialize the script with the following `package` and `import` statements:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下 `package` 和 `import` 语句初始化脚本：
- en: '[PRE42]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now is the time to create our function called `timeDiff()`, which will also
    return the `current` and the `remoteTime` variable formatted with `ANSIC`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是创建我们称为 `timeDiff()` 的函数的时候了，它还将返回格式化为 `ANSIC` 的 `current` 和 `remoteTime`
    变量：
- en: '[PRE43]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Define a `main()` function:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `main()` 函数：
- en: '[PRE44]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the code:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码：
- en: '[PRE45]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output looks as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE46]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The time printed out will be different depending on the time you run your code.
    In this exercise, we saw how easy it is to navigate between different time zones.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出的时间将根据您运行代码的时间而有所不同。在本练习中，我们看到了在时区之间导航是多么容易。
- en: Activity 12.01 – Formatting a date according to user requirements
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 12.01 – 根据用户要求格式化日期
- en: 'In this activity, you need to create a small script that takes the current
    date and outputs it in the following format: `02:49:21 31/01/2023`. You need to
    utilize what you have learned so far regarding the conversion of an integer to
    a string. This will allow you to concatenate different parts of your `time` variable.
    Remember that the `Month()` function omits the name and not the number of the
    month.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，您需要创建一个小脚本，它接受当前日期并以以下格式输出：`02:49:21 31/01/2023`。您需要利用您迄今为止学到的有关将整数转换为字符串的知识。这将允许您连接
    `time` 变量的不同部分。请记住，`Month()` 函数省略了月份名称而不是月份数字。
- en: 'You must perform the following steps to get the desired output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须执行以下步骤以获得所需的输出：
- en: Use the `time.Now()` function to capture the current date in a variable.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `time.Now()` 函数将当前日期捕获到一个变量中。
- en: Dissect the captured date to `day`, `month`, `year`, `hour`, `minute`, and `seconds`
    variables by converting them into strings.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将捕获的日期分解为 `day`、`month`、`year`、`hour`、`minute` 和 `seconds` 变量，通过将它们转换为字符串来实现。
- en: Print out the concatenated variables in order.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按顺序打印出连接的变量。
- en: 'Once the script is complete, the output should appear as follows (note that
    this depends on when you run the code):'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦脚本完成，输出应如下所示（请注意，这取决于您何时运行代码）：
- en: '[PRE47]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: By the end of this activity, you should have learned how you can craft your
    custom `time` variables and use `strconv.Itoa()` to convert a number to a string
    and concatenate the result.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到此活动结束时，您应该已经学会了如何创建自定义的 `time` 变量，并使用 `strconv.Itoa()` 将数字转换为字符串并连接结果。
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution for this activity can be found in the GitHub repository of the
    book: GitHub repository folder for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.01).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在本书的 GitHub 仓库中找到：本书本章的 GitHub 仓库文件夹：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.01)。
- en: Activity 12.02 – Enforcing a specific format of date and time
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 12.02 – 强制执行日期和时间的特定格式
- en: 'This activity requires you to use the knowledge you have accumulated in this
    chapter about time. We would like to create a small script that prints out a date
    with the following format: `02:49:21 31/01/2023`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动要求您使用本章关于时间的知识。我们希望创建一个小脚本，以以下格式打印日期：`02:49:21 31/01/2023`。
- en: First, you need to create a `date` variable by utilizing the `time.Date()` function.
    You then need to recall how we accessed the `Year`, `Month`, and `Day` properties
    of the variable, and create a concatenation with an appropriate order. Remember
    that you cannot concatenate string and integer variables. The `strconv()` function
    is there to help you. You also need to remember that when you omit the `date.Month()`
    command, it prints the name of the month, but it also needs to be converted into
    an integer and then back into a string with a number.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要通过使用 `time.Date()` 函数创建一个 `date` 变量。然后你需要回忆我们是如何访问变量的 `Year`、`Month` 和
    `Day` 属性的，并按照适当的顺序创建一个连接。记住，你不能连接字符串和整数变量。`strconv()` 函数就在那里帮助你。你还需要记住，当你省略 `date.Month()`
    命令时，它会打印出月份的名称，但它也需要被转换成整数，然后再转换回带有数字的字符串。
- en: 'You must perform the following steps to get the desired output:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须执行以下步骤以获得所需的输出：
- en: Capture the current date with the `time.Now()` function in a variable.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `time.Now()` 函数将当前日期保存在一个变量中。
- en: 'Use the `strconv.Itoa()` function to save the appropriate parts of the captured
    `date` variable into the following variables: `day`, `month`, `year`, `hour`,
    `minute`, and `second`.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `strconv.Itoa()` 函数将捕获的 `date` 变量的适当部分保存到以下变量中：`day`、`month`、`year`、`hour`、`minute`
    和 `second`。
- en: Finally, print these out using the appropriate concatenation.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用适当的连接打印这些信息。
- en: 'The expected output should look like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出应该看起来像这样：
- en: '[PRE48]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: By the end of this activity, you should have learned how to format the current
    date to a specific custom format.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本活动结束时，你应该已经学会了如何将当前日期格式化为特定的自定义格式。
- en: Note
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found in the [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.02).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.02)找到。
- en: Activity 12.03 – Measuring elapsed time
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 12.03 – 测量经过的时间
- en: This activity requires you to measure the duration of sleep. You should use
    the `time.Sleep()` function to sleep for 2 seconds, and once the sleep is complete,
    you need to calculate the difference between the start and end times and show
    how many seconds it took.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动要求你测量睡眠的持续时间。你应该使用 `time.Sleep()` 函数休眠 2 秒，一旦休眠完成，你需要计算开始时间和结束时间之间的差异，并展示它花费了多少秒。
- en: First, you mark the start of the execution, sleep for 2 seconds, and then capture
    the end of the execution time in a variable. By utilizing the `time.Sub()` function,
    we can use the `Seconds()` function to output the result. The output will be a
    bit strange as it will be slightly longer than expected.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你标记执行的开始，休眠 2 秒，然后在一个变量中捕获执行结束的时间。通过使用 `time.Sub()` 函数，我们可以使用 `Seconds()`
    函数输出结果。输出将有点奇怪，因为它将比预期的稍长。
- en: 'You must perform the following steps to get the desired output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须执行以下步骤以获得所需的输出：
- en: Capture the start time in a variable.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将开始时间保存在一个变量中。
- en: Craft a `sleep` variable that is 2 seconds long.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个持续 2 秒的 `sleep` 变量。
- en: Capture the end time in a variable.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结束时间保存在一个变量中。
- en: Calculate the length by subtracting the start time from the end time.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从结束时间减去开始时间来计算长度。
- en: Print out the result.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出结果。
- en: 'Depending on the speed of your PC, you should expect the following output:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你电脑的速度，你应该期望以下输出：
- en: '[PRE49]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: By the end of this activity, you should have learned how to measure the elapsed
    time for a specific activity.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本活动结束时，你应该已经学会了如何测量特定活动的经过时间。
- en: Note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.03](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.03).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在本章节的 GitHub 仓库文件夹中找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.03](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.03)。
- en: Activity 12.04 – Calculating the future date and time
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 12.04 – 计算未来的日期和时间
- en: In this activity, we are going to calculate the date that is 6 hours, 6 minutes,
    and 6 seconds from `Now()`. You will need to capture the current time in a variable.
    Then, utilize the `Add()` function on the given date to add the previously mentioned
    length. Please use the `time.ANSIC` format for convenience. There is a catch,
    however. Because the `Add()` function expects a duration, you need to pick a resolution
    such as `Second` and craft the duration before you can add it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'You must perform the following steps to get the desired output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Capture the current time in a variable.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print out this value as a reference in `ANSIC` format.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the duration with seconds as input.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the duration to the current time.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print out the future date in `ANSIC` format.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure your output looks like this, with the string formatting:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: By the end of this activity, you should have learned how you can calculate specific
    dates in the future by utilizing the `time.Duration()` and `time.Add()` functions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.04](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.04).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Activity 12.05 – Printing the local time in different time zones
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This activity requires you to utilize what you learned in the *Formatting time*
    section. You need to load an east coast city and a west coast city. Then, print
    out the current time for each city.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The key here is the `LoadLocation()` function, and you need to use the `ANSIC`
    format for the output. Remember that the `LoadLocation()` function returns two
    values!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'You must perform the following steps to get the desired output:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Capture the current time in a variable.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create reference time zone variables for `NyTime` and `LaTime` using the `time.LoadLocation()`
    function.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print out, in `ANSIC` format, the current time in the respective time zones.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Depending on your day of execution, the following could be your expected output:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: By the end of this activity, you should have learned how to convert your time
    variables to a specific time zone.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.05](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.05).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduced you to the `time` package of Go, which allows you to
    reuse code that has been invented by other programmers and incorporated into the
    language. The goal was to teach you how to create, manipulate, and format `time`
    variables, and, in general, make you familiar with what you can do with the help
    of the `time` package. If you would like to further improve or dig deeper into
    what the package has to offer, you should check out the following link: [https://golang.org/pkg/time/](https://golang.org/pkg/time/).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了Go语言的`time`包，它允许您重用其他程序员发明并融入语言的代码。目标是教会您如何创建、操作和格式化`time`变量，并使您熟悉在`time`包的帮助下可以做什么。如果您想进一步改进或深入了解该包提供的功能，请查看以下链接：[https://golang.org/pkg/time/](https://golang.org/pkg/time/)。
- en: Timestamps and time manipulation are essential skills for every developer. Whether
    you have a big or small script put into production, the `time` module helps you
    to measure the elapsed time of actions and provide you with the logging of actions
    that happen during the execution. The most important thing about it, if used correctly,
    is that it helps you to easily trace back production problems to their roots.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳和时间操作是每个开发人员必备的技能。无论您是将大或小的脚本投入生产，`time`模块都能帮助您测量操作的执行时间，并提供在执行过程中发生的操作日志。最重要的是，如果使用得当，它可以帮助您轻松地将生产问题追溯到其根源。
- en: 'Part 4: Applications'
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分：应用
- en: Applications come in various sizes and functionalities, ranging from small tools
    with a single purpose to extensive systems with numerous features. Regardless
    of their complexity, all applications feature interfaces, whether for human interaction
    (user interface/UI) or for communication with other applications (Application
    Programming Interface/API).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的大小和功能各不相同，从单一目的的小工具到具有众多功能的大型系统。无论它们的复杂程度如何，所有应用程序都具备接口，无论是用于人机交互（用户界面/UI）还是与其他应用程序通信（应用程序编程接口/API）。
- en: In this section, you’ll explore the development of applications, from command-line
    tools to systems interacting with files, databases, and more.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将探索应用程序的开发，从命令行工具到与文件、数据库等交互的系统。
- en: 'This part has the following chapters:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 13*](B18621_13.xhtml#_idTextAnchor1578), *Programming from the Command
    Line*'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18621_13.xhtml#_idTextAnchor1578)，*从命令行进行编程*'
- en: '[*Chapter 14*](B18621_14.xhtml#_idTextAnchor1623), *Files and Systems*'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B18621_14.xhtml#_idTextAnchor1623)，*文件和系统*'
- en: '[*Chapter 15*](B18621_15.xhtml#_idTextAnchor1649), *SQL and Databases*'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B18621_15.xhtml#_idTextAnchor1649)，*SQL和数据库*'
