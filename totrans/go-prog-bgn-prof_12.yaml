- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: About Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter demonstrates how Go handles variables representing time data, which
    is a very important aspect of the language.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to create your own time format,
    compare and manage time, calculate the duration of time series, and format time
    according to user requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you''ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter12](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter12).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter introduced you to basic debugging in Go. The more you develop
    code in Go, the better you get; however, developing and deploying code may come
    with corner cases that need to be debugged. The previous chapter showed you how
    to use the `fmt` package, how to log in to files, and how to use printing verbs
    for string formatting.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is dedicated to teaching you all you need to know about handling
    variables that represent time data. You will learn how to do it the “Go way.”
    First, we will start out with basic time creation, timestamps, and more; then,
    we will learn how to compare and manipulate time, calculate the duration between
    two dates, and create timestamps. Finally, we will learn how to format time according
    to our needs. So, let’s not waste any more time and jump right in.
  prefs: []
  type: TYPE_NORMAL
- en: Making time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Making time means declaring a variable that holds the time formatted in a specific
    way. Formatting time will be covered at the end of this chapter; so, for now,
    we will use the default formatting that is provided by Go. In this topic, we will
    be executing everything in the `main()` function of our script, so the skeleton
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at our skeleton first and learn how to create and manipulate `time`
    variables. Our skeleton has the standard `package main` definition that is necessary.
    We use the `fmt` package to print the output to the console. Since we’ll be using
    the `time` package, we’ll need to import that as well.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we issue `go run <script>.go`, the `main()` function gets called and
    executes whatever is declared in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common jobs for the `time` package is to measure the duration
    of the execution of the script. We can do this by capturing the current time in
    a variable, at the beginning, and at the end so that we can calculate the difference
    and know how long the specific action took to complete. The time difference will
    be shown later in the book chapter. The very first example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from our script should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this does not look very fancy; however, by the end of this chapter,
    you will have learned how to make it more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following scenario: your employer gives you a task to develop
    a small Go application that tests a web application based on the day of the week.
    Your employer has the main release of a new web app every Monday at 12:00 A.M.
    CEST. With a downtime window from 12:00 A.M. CEST to 2:00 P.M. CEST, and the deployment
    being about 30 minutes, you have 1.5 hours to test the app. This is where Go’s
    `time` package comes to your rescue. The script performs a `hit-n-run` test on
    the other days of the week, but on release day, you are required to perform a
    `full-blown` functionality test. The first version of the script took the argument
    to see which test to perform, but the second script version made the decision
    based on the day and the hour:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Testing strategies](img/B18621_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Testing strategies'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The current day of the week is captured in the variable called `day`. The hour
    of execution is also captured in the variable called `hour`. When this script
    is executed, there are two types of output.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is a simple `hit-n-run` output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one is the `full blown` output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have seen how the day of execution modifies the behavior
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The actual test was left out intentionally as this is not part of the chapter’s
    topic. However, the output clearly shows which part was responsible for the control
    of the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example would be to create the log filenames for scripts in Go. The
    basic idea is to collect a log per day and have a timestamp concatenated with
    the name of the log file. The skeleton looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In Go, there is an elegant and simple way to do it within your main function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there is a catch. If you want to concatenate strings with `time` types,
    which are not implicitly convertible, use the `strconv` package, which needs to
    be imported on top of your script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In turn, this allows you to call the `strconv.Itoa()` function, which converts
    your `Year` and `Day` values and, finally, lets you concatenate them into a single
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to make `time` variables, let’s learn to compare
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.01 – Creating a function to return a timestamp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a function called `whatstheclock`. The goal
    of this function is to demonstrate how you can create a function that wraps a
    nice, formatted `time.Now()` function and returns the date in an `ANSIC` format.
    The `ANSIC` format will be explained in further detail in the *Formatting* *time*
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize the script with `package` and `import` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function called `whatstheclock()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, define a call to the `whatstheclock()` function and
    print the result to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file and run the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we demonstrated how you can create a small function that returns
    the current time in an `ANSIC` format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Any type of operating system that you work with will provide two types of clocks
    to measure the time; one is called the “monotonic clock,” and the other is called
    the “wall clock.” The wall clock is what you see on a Windows machine in the taskbar;
    it’s subject to change and is usually synchronized with a public or corporate
    **Network Time Protocol** (**NTP**) server based on your current location. NTP
    is used to tell clients the time based on an atomic clock or from a satellite
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, when working with Go on smaller scripts, it is very important
    for your statistics to know when a script should run, or between what hours and
    minutes a script should be completed. By statistics, we mean knowing how much
    time the app saves by executing a specific operation compared to what time cost
    it would have if we had to perform these manually. This allows us to measure the
    improvement of the script over time when we develop the functionality further.
    In this topic, we will look at some live examples demonstrating how you can solve
    this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the logic for the first script, which was intended not to run
    before or after a specified time. This time can arrive either via another automation
    or when a trigger file is manually placed there; every day, the script needs to
    run at different times –specifically, after the specified time as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The time was in the following `2023-09-27T22:08:41+00:00` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the script when we are not yet at the deadline is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When we meet the criteria, the output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s examine what is happening here. We create a `now` variable, which is
    crucial for the execution. We have the `time` string parsed based on `RFC3339`.
    `RFC3339` specifies the format that should be used for the `date` and `time` strings.
    This function returns two values: one value is the output if the conversion succeeds,
    and the other is the error if there is one. We capture the output in the onlyAfter
    variable, along with the error, err. We could use a standard variable such as
    onlyAfterError, but unless we use that variable later in time, the compiler will
    throw an error that the variable was declared but never used. This is circumvented
    using the _ variable. Based on this logic, we could implement the `onlyBefore`
    argument or variable very simply. The `time` package has two particularly useful
    functions: one is called `After()`, and the other is called `Before()`. They allow
    us to simply compare two `time` variables.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a third function in the package called `Equal()`. This function allows
    you to compare two `time` variables and returns `true` or `false` depending on
    whether they are equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at an example of the `Equal()` function in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see what happens here. We have three `time` variables, which are called
    `now`, `now_too`, and `later`. The `time` module’s `Sleep()` function is used
    to simulate the latency of 2 seconds. This function takes an integer argument
    and waits for the given time to pass and then continues the execution. The result
    of this is that the `later` variable holds different time values and allows us
    to demonstrate the `Equal()` function’s purpose, which you can see in the output.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the time has come to check what facilities are provided to calculate the
    duration or difference between the two `time` variables.
  prefs: []
  type: TYPE_NORMAL
- en: Duration calculation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to calculate the duration of an execution comes in handy during
    many aspects of programming. In our everyday lives, we can monitor discrepancies
    and performance bottlenecks that our infrastructure might face. For example, if
    you have a script that takes only 5 seconds to complete on average and the monitoring
    execution time shows you a huge bump during certain hours of a day or certain
    days, it might be wise to investigate. The other aspect is related to web applications.
    Measuring the duration of request-response in your scripts can give you an insight
    into how well invested you are in your apps to serve high loads, and it even allows
    you to expand your capacity on certain days or weeks of the year. For example,
    if you have an online shop dealing with products, it might be wise to size your
    capacity according to patterns such as Black Friday or Christmas.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may do well with a lower capacity during most of the year, but those holidays
    can result in revenue loss if the infrastructure is not sufficiently well sized.
    There is very little coding required to add such functionality to your scripts.
    Let’s now look at how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you execute this script, the result will be something like this, depending
    on the PC’s performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: Measuring the execution time](img/B18621_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: Measuring the execution time'
  prefs: []
  type: TYPE_NORMAL
- en: All that needs to be done is to capture the time when the script starts and
    ends. Then, we can calculate the duration by subtracting the start time and the
    end time. After that, we can utilize the `Duration` variable’s functions to get
    the `Hours()`, `Minutes()`, `Seconds()`, and `Nanoseconds()` values of the time
    it took to complete the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four resolutions you will be provided with – namely, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Hours`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Minutes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Seconds`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Nanoseconds`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need, for example, days, weeks, or months, then you can calculate it
    from the resolutions provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the day, we had a requirement to measure the duration of transactions,
    and we had a **service-level agreement** (**SLA**) that needed to be met. This
    meant that there were applications that needed to process a request in, let’s
    say, 1,000 ms or 5 s depending on the criticality of the product. The next script
    will show you how this was implemented. There are six different resolutions that
    you have the option to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Hour`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Minute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Second`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Millisecond`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsecond`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Nanosecond`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When we don’t meet the deadline, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: Transaction deadline not met](img/B18621_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: Transaction deadline not met'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we meet the deadline, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4: Transaction deadline met](img/B18621_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: Transaction deadline met'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dissect our example. First, we define a deadline for the transaction with
    the `time.Duration()` variable. In my experience, the `Millisecond` resolution
    is optimal; however, it does take some time to get used to calculating it. Feel
    free to use whichever resolution you prefer. We mark the beginning with the `start`
    variable, do some calculations, and mark the completion with the `end` variable.
    The magic happens after this. We would like to calculate the difference between
    the deadline and the transaction duration, but we cannot do it directly. We need
    to convert the `duration` value to `transaction` time. This was done the same
    way when we created our deadline. We simply use the `Nanosecond` resolution, which
    is the lowest resolution we should go to. However, in this case, you can use the
    resolution you would like. After conversion, we can easily compare and decide
    whether the transaction is fine or not.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how we can manipulate time.
  prefs: []
  type: TYPE_NORMAL
- en: Managing time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go programming language’s `time` package provides two functions that allow
    you to manipulate time. One of them is called `Sub()`, and the other one is called
    `Add()`. There have not been many cases, in my experience, where this has been
    used. Mostly, when calculating the elapsed time of a script’s execution, the `Sub()`
    function is used to tell the difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what the addition looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After execution, the following output welcomes us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s inspect what happened here. We created a variable to hold our time, which
    requires some manipulation. The `toBeAdded` variable represents a duration of
    10 seconds, which we would like to add. The `Add()` function of the `time` package
    expects a variable of the `time.Duration()` type. Then, we simply call the `Add()`
    function of our date, and the result is visible on the console. The functionality
    of the `Sub()` function is rather cumbersome, and it is not really intended to
    remove a specific duration from the time we have. It can be done, but you need
    many more lines of code to achieve this. What you can do is craft your duration
    with a negative value. Swap out the second line for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It will work just fine and output you this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This works as we expected; we have successfully calculated what time it was
    10 minutes ago.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.02 – Duration of execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will craft a function that allows you to calculate the
    duration of the execution between two `time.Time` variables and return a string
    that tells you how long the execution took to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps in order:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize the script with the following `package` and `import` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now define our `elapsedTime()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are ready to define our `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following should appear as the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we created a function that shows us how many hours, minutes,
    and seconds it took to execute the action. This is useful because you can reuse
    this function in other Go apps.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s turn our eyes toward the formatting of time.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far in this chapter, you may have noticed that the dates are pretty ugly.
    I mean, take a look at the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: These were intentionally left there to force you to think about whether this
    is all that Go can do. Is there a way to format these lines to make them more
    convenient and easier to read? If so, what are those extra lines?
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will answer those questions. When we talk about time formatting, there
    are two main concepts we are referring to. The first option is for instances when
    we would like our `time` variable to output a desirable-looking string when we
    use it in print, and the second option is for when we would like to take a string
    and parse it to a specific format. Both have their own use cases; we are going
    to look at them in more detail as I teach you how to use both.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to learn about the `Parse()` function. This function has
    essentially two arguments. The first one is the format string to parse against,
    and the second one is the string that needs to be parsed. The end of this parse
    will result in a `time` variable that can utilize built-in Go functions. Go uses
    a POSIX-based date format, where `Parse()` is very useful when you have an application
    that is working with time values from different time zones and you would like
    to convert them, for example, to the same time zone for better understanding and
    easier comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This date format is equal to “`123456`” in POSIX, which can be decoded from
    the preceding example. There are constants provided in the language to help you
    deal with parsing different time strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main time formats against which we can parse:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RFC3339`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UnixDate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ANSIC`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s look at how `Parse()` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens behind the scenes is as follows. We have the `t1`, `t2`, and `t3`
    variables that hold the time, which is parsed against the specified format. The
    `err` variables hold the error results if there are any during the conversion.
    The output from the `t1` variable is the only one that makes sense; `UnixDate`
    and `ANSIC` are wrong because the wrong string is parsed against the format. `UnixDate`
    expects something that they call `epoch`. The epoch is a very unique date; on
    Unix systems, it marks the beginning of time, which starts at January 1, 1970\.
    It expects a huge integer, which is the number of seconds elapsed since this date.
    The format expects something like this as the input: `Mon Sep _27 18:24:05 2019`.
    Providing such time allows the `Parse()` function to provide the correct output.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have clarified the `Parse()` function, it’s time to look at the
    `Format()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go allows you to craft your own `time` variables. Let’s learn how we can do
    that and, afterward, we will format them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code demonstrates how you can craft the time for yourself; however,
    we are going to look at what all those numbers are. The skeleton syntax for that
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Essentially, we need to specify the year, month, day, hour, and so on. We would
    like to reformat our output based on the input variables; this should appear as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Time zones were not important until people started working in big enterprise
    environments. When you have a global fleet of interconnected devices, it is important
    to be able to differentiate between time zones. If you want to have an `AddDate()`
    function, which can be used to add `Year`, `Month`, and `Day` to your current
    time, then this must enable you to dynamically add to your dates. Let’s look at
    an example. Given our previous date, let’s add 1 year, 2 months, and 3 days:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output upon execution of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddDate()` function takes three arguments: the first is `years`, the second
    is `months`, and the third is `days`. This gives you the opportunity to fine-tune
    the scripts you have. To properly understand how formatting works, you need to
    know what is under the hood.'
  prefs: []
  type: TYPE_NORMAL
- en: One last important aspect of time formatting is to understand how you can utilize
    the `LoadLocation()` function of the `time` package to convert your local time
    to the local time of another time zone. Our reference time zone will be the `Los
    Angeles` time zone. The `Format()` function is used to tell Go how we would like
    to see our output formatted. The `In()` function is a reference to a specific
    time zone we want our formatting to be present in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s find out what the time is in Los Angeles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on your day of execution, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The key here is that we get our local time in a variable, and then we use the
    `In()` function of the `time` package to, say, convert that value to a specific
    time zone’s value. It’s simple, yet useful.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 12.03 – What is the time in your zone?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create a function that tells the difference between
    the current time zone and the specified time zone. The function will utilize the
    `LoadLocation()` function to specify the location based on which a variable will
    be set to a specific time. The `In()` location will be used to convert a specific
    time value to a given time zone value. The output format should be in the `ANSIC`
    standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps in order:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize the script with the following `package` and `import` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now is the time to create our function called `timeDiff()`, which will also
    return the `current` and the `remoteTime` variable formatted with `ANSIC`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The time printed out will be different depending on the time you run your code.
    In this exercise, we saw how easy it is to navigate between different time zones.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 12.01 – Formatting a date according to user requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, you need to create a small script that takes the current
    date and outputs it in the following format: `02:49:21 31/01/2023`. You need to
    utilize what you have learned so far regarding the conversion of an integer to
    a string. This will allow you to concatenate different parts of your `time` variable.
    Remember that the `Month()` function omits the name and not the number of the
    month.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You must perform the following steps to get the desired output:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `time.Now()` function to capture the current date in a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dissect the captured date to `day`, `month`, `year`, `hour`, `minute`, and `seconds`
    variables by converting them into strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print out the concatenated variables in order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the script is complete, the output should appear as follows (note that
    this depends on when you run the code):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By the end of this activity, you should have learned how you can craft your
    custom `time` variables and use `strconv.Itoa()` to convert a number to a string
    and concatenate the result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository of the
    book: GitHub repository folder for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.01).'
  prefs: []
  type: TYPE_NORMAL
- en: Activity 12.02 – Enforcing a specific format of date and time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This activity requires you to use the knowledge you have accumulated in this
    chapter about time. We would like to create a small script that prints out a date
    with the following format: `02:49:21 31/01/2023`.'
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to create a `date` variable by utilizing the `time.Date()` function.
    You then need to recall how we accessed the `Year`, `Month`, and `Day` properties
    of the variable, and create a concatenation with an appropriate order. Remember
    that you cannot concatenate string and integer variables. The `strconv()` function
    is there to help you. You also need to remember that when you omit the `date.Month()`
    command, it prints the name of the month, but it also needs to be converted into
    an integer and then back into a string with a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must perform the following steps to get the desired output:'
  prefs: []
  type: TYPE_NORMAL
- en: Capture the current date with the `time.Now()` function in a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `strconv.Itoa()` function to save the appropriate parts of the captured
    `date` variable into the following variables: `day`, `month`, `year`, `hour`,
    `minute`, and `second`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, print these out using the appropriate concatenation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: By the end of this activity, you should have learned how to format the current
    date to a specific custom format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found in the [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.02).
  prefs: []
  type: TYPE_NORMAL
- en: Activity 12.03 – Measuring elapsed time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This activity requires you to measure the duration of sleep. You should use
    the `time.Sleep()` function to sleep for 2 seconds, and once the sleep is complete,
    you need to calculate the difference between the start and end times and show
    how many seconds it took.
  prefs: []
  type: TYPE_NORMAL
- en: First, you mark the start of the execution, sleep for 2 seconds, and then capture
    the end of the execution time in a variable. By utilizing the `time.Sub()` function,
    we can use the `Seconds()` function to output the result. The output will be a
    bit strange as it will be slightly longer than expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must perform the following steps to get the desired output:'
  prefs: []
  type: TYPE_NORMAL
- en: Capture the start time in a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Craft a `sleep` variable that is 2 seconds long.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Capture the end time in a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the length by subtracting the start time from the end time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print out the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Depending on the speed of your PC, you should expect the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: By the end of this activity, you should have learned how to measure the elapsed
    time for a specific activity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.03](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.03).'
  prefs: []
  type: TYPE_NORMAL
- en: Activity 12.04 – Calculating the future date and time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we are going to calculate the date that is 6 hours, 6 minutes,
    and 6 seconds from `Now()`. You will need to capture the current time in a variable.
    Then, utilize the `Add()` function on the given date to add the previously mentioned
    length. Please use the `time.ANSIC` format for convenience. There is a catch,
    however. Because the `Add()` function expects a duration, you need to pick a resolution
    such as `Second` and craft the duration before you can add it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You must perform the following steps to get the desired output:'
  prefs: []
  type: TYPE_NORMAL
- en: Capture the current time in a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print out this value as a reference in `ANSIC` format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the duration with seconds as input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the duration to the current time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print out the future date in `ANSIC` format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure your output looks like this, with the string formatting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: By the end of this activity, you should have learned how you can calculate specific
    dates in the future by utilizing the `time.Duration()` and `time.Add()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.04](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.04).'
  prefs: []
  type: TYPE_NORMAL
- en: Activity 12.05 – Printing the local time in different time zones
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This activity requires you to utilize what you learned in the *Formatting time*
    section. You need to load an east coast city and a west coast city. Then, print
    out the current time for each city.
  prefs: []
  type: TYPE_NORMAL
- en: The key here is the `LoadLocation()` function, and you need to use the `ANSIC`
    format for the output. Remember that the `LoadLocation()` function returns two
    values!
  prefs: []
  type: TYPE_NORMAL
- en: 'You must perform the following steps to get the desired output:'
  prefs: []
  type: TYPE_NORMAL
- en: Capture the current time in a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create reference time zone variables for `NyTime` and `LaTime` using the `time.LoadLocation()`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print out, in `ANSIC` format, the current time in the respective time zones.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Depending on your day of execution, the following could be your expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: By the end of this activity, you should have learned how to convert your time
    variables to a specific time zone.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution for this activity can be found in the GitHub repository folder
    for this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.05](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter12/Activity12.05).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduced you to the `time` package of Go, which allows you to
    reuse code that has been invented by other programmers and incorporated into the
    language. The goal was to teach you how to create, manipulate, and format `time`
    variables, and, in general, make you familiar with what you can do with the help
    of the `time` package. If you would like to further improve or dig deeper into
    what the package has to offer, you should check out the following link: [https://golang.org/pkg/time/](https://golang.org/pkg/time/).'
  prefs: []
  type: TYPE_NORMAL
- en: Timestamps and time manipulation are essential skills for every developer. Whether
    you have a big or small script put into production, the `time` module helps you
    to measure the elapsed time of actions and provide you with the logging of actions
    that happen during the execution. The most important thing about it, if used correctly,
    is that it helps you to easily trace back production problems to their roots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications come in various sizes and functionalities, ranging from small tools
    with a single purpose to extensive systems with numerous features. Regardless
    of their complexity, all applications feature interfaces, whether for human interaction
    (user interface/UI) or for communication with other applications (Application
    Programming Interface/API).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll explore the development of applications, from command-line
    tools to systems interacting with files, databases, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B18621_13.xhtml#_idTextAnchor1578), *Programming from the Command
    Line*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B18621_14.xhtml#_idTextAnchor1623), *Files and Systems*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B18621_15.xhtml#_idTextAnchor1649), *SQL and Databases*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
