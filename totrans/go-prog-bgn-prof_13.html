<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer149">
			<h1 id="_idParaDest-346" class="chapter-number"><a id="_idTextAnchor1578"/>13</h1>
			<h1 id="_idParaDest-347"><a id="_idTextAnchor1579"/>Programming from the Command Line<a id="_idTextAnchor1580"/><a id="_idTextAnchor1581"/></h1>
			<p class="callout-heading"><a id="_idTextAnchor1582"/>Overview</p>
			<p class="callout">In this chapter, we will look at programming from the command line. We will see how Go is an excellent choice for creating powerful command-line utilities and applications, as well as discuss the many tools available for working with the command line <span class="No-Break">using Go.</span></p>
			<p class="callout">By reading this chapter, you will acquaint yourself with developing powerful command-line utilities and applications in Go. We will start with the basics of reading in command-line arguments and employing those flag values to control application behavior, take a peek at dealing with larger amounts of data inside and outside the application, and evaluate exit codes and best practices along the way. Then, we will dive a bit deeper and discuss strategies for gracefully handling interrupts, initiating external commands from our application, and using <strong class="source-inline">go install</strong>. Finally, we will learn how to create <strong class="bold">terminal user interfaces</strong> (<strong class="bold">TUIs</strong>), which allow us to craft robust, user-friendly command-line tools <span class="No-Break">in Go.</span></p>
			<h1 id="_idParaDest-348"><a id="_idTextAnchor1583"/>Technical requirements</h1>
			<p>For this chapter, you’ll require Go version 1.21 or higher. The code for this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter13"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter13</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-349"><a id="_idTextAnchor1584"/><a id="_idTextAnchor1585"/>Introduction</h1>
			<p>In the previous chapter, we looked at how Go provides powerful constructs when dealing with time data. We will be shifting gears a bit in this chapter to discuss one of the many ways that Go is beneficial in creating a powerful interface <span class="No-Break">for applications.</span></p>
			<p>UIs don’t always have to be a web application frontend web page. End users can interact with software through engaging command-line interfaces, as well as by using a <strong class="bold">command-line </strong><span class="No-Break"><strong class="bold">interface</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">CLI</strong></span><span class="No-Break">).</span></p>
			<p>Go provides many packages that allow us to program for the command line. We’ll look at some of these packages, see where Go is at in terms of creating powerful command-line utilities, and learn about some of the current efforts in <span class="No-Break">this space.</span></p>
			<h1 id="_idParaDest-350"><a id="_idTextAnchor1586"/>Reading arguments</h1>
			<p>Command-line arguments are a fundamental aspect of building versatile and interactive command-line applications. Reading<a id="_idIndexMarker833"/> arguments allow developers to make their applications more dynamic and adaptable to user input. Command-line arguments serve as a means for users to customize the behavior of a program without modifying its source code. By capturing input parameters from the command line, developers can create versatile applications that cater to different use cases <span class="No-Break">and scenarios.</span></p>
			<p>In Go, the <strong class="source-inline">os</strong> package serves as a straightforward way to access these arguments. The <strong class="source-inline">os.Args</strong> slice provides a convenient way to access command-line arguments. This allows developers to retrieve information such as file paths, configuration parameters, or any other input relevant to the application’s functionality. The ability to read command-line arguments enhances the user experience by making applications more interactive <span class="No-Break">and user-friendly.</span></p>
			<p>Moreover, command-line arguments enable automation and scripting, allowing users to pass inputs programmatically. This flexibility is particularly valuable in scenarios where the same program needs to be executed with different parameters, making it a powerful tool for scripting and <span class="No-Break">automation tasks.</span></p>
			<p>Let’s dive into the process of reading command-line arguments and illustrate this with a simple example that greets users with a <span class="No-Break">personalized message.</span></p>
			<h2 id="_idParaDest-351"><a id="_idTextAnchor1587"/>Exercise 13.01 – saying hello using a name passed as an argument</h2>
			<p>In this exercise, we will <a id="_idIndexMarker834"/>print a <strong class="source-inline">hello</strong> statement using arguments that have been passed in from the <span class="No-Break">command line:</span></p>
			<ol>
				<li>Import the <strong class="source-inline">fmt</strong> and <span class="No-Break"><strong class="source-inline">os</strong></span><span class="No-Break"> packages:</span><pre class="source-code">
package main
import (
  "fmt"
  "os"
)</pre></li>				<li>Utilize the <strong class="source-inline">args</strong> slice mentioned previously to capture the <span class="No-Break">command-line arguments:</span><pre class="source-code">
func main() {
  args := os.Args</pre></li>				<li>Perform validation on the number of arguments supplied, excluding the executable <span class="No-Break">name provided:</span><pre class="source-code">
  if len(args) &lt; 2 {
    fmt.Println("Usage: go run main.go &lt;name&gt;")
    return
  }</pre></li>				<li>Extract the name from the <span class="No-Break">arguments supplied:</span><pre class="source-code">
  name := args[1]</pre></li>				<li>Display a personalized <span class="No-Break">greeting message:</span><pre class="source-code">
  greeting := fmt.Sprintf("Hello, %s! Welcome to the command line.", name)
  fmt.Println(greeting)
}</pre></li>				<li>Run the following command <a id="_idIndexMarker835"/>to execute <span class="No-Break">the code:</span><pre class="source-code">
go run main.go Sam</pre></li>			</ol>
			<p>The output is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Hello, Sam! Welcome to the command line.</pre>			<p>With that, we have demonstrated the basics of capturing a command-line argument using Go, and seen some of the benefits of capturing input data in an easy way for our program. While we used the <strong class="source-inline">os</strong> package in this example, other packages can assist in achieving the same goal of reading the input provided to the application, such as using the <strong class="source-inline">flags</strong> package. Let’s look at how useful flags can be in programming for the <span class="No-Break">command line.</span></p>
			<h1 id="_idParaDest-352"><a id="_idTextAnchor1588"/>Using flags to control behavior</h1>
			<p>The <strong class="source-inline">flags</strong> package provides a higher-level and more structured approach to reading arguments compared to directly using the <strong class="source-inline">os</strong> package. Flags simplify the process of parsing and <a id="_idIndexMarker836"/>handling command-line input, making it easier for developers to create robust and user-friendly <span class="No-Break">command-line applications.</span></p>
			<p>The <strong class="source-inline">flags</strong> package allows you to define flags with associated types and default values, making it clear what kind of input a user is expected to provide. It also automatically generates help messages, making your program more self-documenting. Here’s a brief overview of how the <strong class="source-inline">flags</strong> package can help in reading and handling <span class="No-Break">command-line arguments:</span></p>
			<ul>
				<li><strong class="bold">Define flags</strong>: You can define flags, along with their types and default values. This provides a clear and structured way to specify <span class="No-Break">expected inputs.</span></li>
				<li><strong class="bold">Parse flags</strong>: After defining flags, you can parse the command-line arguments. This initializes flag variables with the<a id="_idIndexMarker837"/> values provided by <span class="No-Break">a user.</span></li>
				<li><strong class="bold">Access flag values</strong>: Once you have parsed the flag values that have been passed in, you can access the defined<a id="_idIndexMarker838"/> flags through variables and continue to work with them throughout <span class="No-Break">the application.</span></li>
			</ul>
			<p>Flags allow you to customize the behavior of your program without the need to modify the source code. For example, you can create flags that allow you to toggle behavior based on if a flag value is set. You <a id="_idIndexMarker839"/>can also use basic conditional logic pending the values set for certain flags. Let’s complete an exercise and utilize the <strong class="source-inline">flags</strong> package to <span class="No-Break">say hello.</span></p>
			<h2 id="_idParaDest-353"><a id="_idTextAnchor1589"/>Exercise 13.02 – using flags to say hello conditionally</h2>
			<p>In this exercise, we <a id="_idIndexMarker840"/>will print a <strong class="source-inline">hello</strong> statement using the <span class="No-Break"><strong class="source-inline">flags</strong></span><span class="No-Break"> package:</span></p>
			<ol>
				<li>Import the <strong class="source-inline">fmt</strong> and <span class="No-Break"><strong class="source-inline">os</strong></span><span class="No-Break"> packages:</span><pre class="source-code">
package main
import (
  "flag"
  "fmt"
)</pre></li>				<li>Create our flags for the utility and set the <span class="No-Break">default values:</span><pre class="source-code">
var (
  nameFlag = flag.String("name", "Sam", "Name of the person to say hello to")
  quietFlag = flag.Bool("quiet", false, "Toggle to be quiet when saying hello")
)
Parse the flags and conditionally say hello pending the value of the quiet flag:
func main(){
  flag.Parse()
  if !*quietFlag {
    greeting := fmt.Sprintf("Hello, %s! Welcome to the command line.", *nameFlag)
    fmt.Println(greeting)
  }
}</pre></li>			</ol>
			<p>Here’s the output you’ll receive if<a id="_idIndexMarker841"/> you run <strong class="source-inline">go run main.go</strong>. This is because <strong class="source-inline">quietFlag</strong> defaults to <strong class="source-inline">false</strong> and <strong class="source-inline">nameFlag</strong> defaults <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Sam</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
Hello, Sam! Welcome to the command line.</pre>			<p>However, you can set values for the flags. For this, you can use <strong class="source-inline">nameFlag</strong> and set the <strong class="source-inline">quietFlag</strong> value. The output of running <strong class="source-inline">go run main.go --name=Cassie –-quiet=false</strong> is listed here. This is because <strong class="source-inline">quietFlag</strong> is set to false and <strong class="source-inline">nameFlag</strong> is set <span class="No-Break">to Sam:</span></p>
			<pre class="console">
Hello, Cassie! Welcome to the command line.</pre>			<p>Alternatively, you will get no output if you use <strong class="source-inline">quietFlag</strong> with a value of <strong class="source-inline">true</strong>. So, if you run <strong class="source-inline">go run main.go --quiet=true</strong>, then you’ll see no output as we have just used flags to control the expected output behavior of <span class="No-Break">our program.</span></p>
			<p>This code demonstrated how you can use flags to control the behavior of a program. If you are working with someone else’s command-line interface, then you can seamlessly use the <strong class="source-inline">help</strong> flag to list the defined flags available. The <strong class="source-inline">flag</strong> package in Go automatically generates a help message based on the flags in the program. To see the available help message for the preceding code, you can run <strong class="source-inline">go run main.go --help</strong>. That will provide the <span class="No-Break">following output:</span></p>
			<pre class="console">
Usage of /var/folders/qt/5jjdv1bj3h33t2rl40tpt56w0000gn/T/go-build1361710947/b001/exe/main:
-name string
Name of the person to say hello to (default "Sam")
-quiet
Toggle to be quiet when saying hello</pre>			<p>By utilizing the <strong class="source-inline">flags</strong> package, you enhance the readability and maintainability of your code, as well as provide a more user-friendly experience. It simplifies the process of handling various types of input <a id="_idIndexMarker842"/>and automates the generation of usage information, making it easier for users to understand and interact with your command-line application. Now, let’s see what it looks like to stream data in and out of <span class="No-Break">the application.</span></p>
			<h1 id="_idParaDest-354"><a id="_idTextAnchor1590"/>Streaming large amounts of data in and out of your application</h1>
			<p>In command-line applications, it is crucial to<a id="_idIndexMarker843"/> handle large amounts of data efficiently for performance and responsiveness purposes. Often, command-line applications may be a small part of a larger pipeline processing data. Most people are not going to want to sit around typing out a large amount of data, such as a dataset, piece <span class="No-Break">by piece.</span></p>
			<p>Go allows you to stream data to your applications so that you can process information in chunks, rather than all at once. This allows you to effectively process large amounts of data, reduce memory overhead, and provide better scalability in <span class="No-Break">the future.</span></p>
			<p>When dealing with large amounts of data, it’s often stored in files. This can range from financial CSV files, analysis Excel files, or machine learning datasets. There are a few main benefits of streaming data <span class="No-Break">with Go:</span></p>
			<ul>
				<li><strong class="bold">Memory efficiency</strong>: The program can<a id="_idIndexMarker844"/> read and process data line by line, reducing memory consumption, as you then don’t have to read the entire data <span class="No-Break">into memory</span></li>
				<li><strong class="bold">Real-time analysis</strong>: Users can observe a real-time analysis of the results of processing <span class="No-Break">their data</span></li>
				<li><strong class="bold">Interactive interface</strong>: You can enhance the command-line interface so that it accepts dynamic information or <a id="_idIndexMarker845"/>displays additional details when processing large amounts <span class="No-Break">of data</span></li>
			</ul>
			<p>Data confidentiality might be<a id="_idIndexMarker846"/> top of mind, depending on the type of data you may be streaming to your command-line application. For this reason, different encoding mechanisms may be employed to hide text without providing real security on the data, or as a first step toward securing <span class="No-Break">the data.</span></p>
			<p><em class="italic">Rot13</em>, or rotate by 13 places, is a simple letter substitution cipher that replaces a letter with the 13<span class="superscript">th</span> letter after it in the alphabet. For example, the letter A would become N, and B would become C, and so forth. It is a symmetric key algorithm that is often used as a trivial form of encryption to obscure text. This algorithm provides no significant security and is mainly used for fun, typically never used in a production-level environment to secure data. It is also fully self-reversible, meaning that applying Rot13 twice would result in the same originating data. This can be useful for sending and receiving text in environments where the receiving end may or may not know if the data has <span class="No-Break">been encoded.</span></p>
			<p>Let’s expand our new Rot13 knowledge so that we can work on a fun streaming data example for a <span class="No-Break">command-line application.</span></p>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor1591"/>Exercise 13.03 – using pipes, stdin, and stdout to apply a Rot13 encoding to a file</h2>
			<p>In this exercise, we will <a id="_idIndexMarker847"/>work with the Rot13 encoding for<a id="_idIndexMarker848"/> some <span class="No-Break">input </span><span class="No-Break"><a id="_idIndexMarker849"/></span><span class="No-Break">data:</span></p>
			<ol>
				<li>Import the <span class="No-Break">required packages:</span><pre class="source-code">
package main
import (
  "bufio"
  "fmt"
  "io"
  "os"
)</pre></li>				<li>Define <a id="_idIndexMarker850"/>the <strong class="source-inline">rot13</strong> function to apply Rot13<a id="_idIndexMarker851"/> encoding to a<a id="_idIndexMarker852"/> <span class="No-Break">given string:</span><pre class="source-code">
func rot13(s string) string {
  result := make([]byte, len(s))
  for i := 0; i &lt; len(s); i++ {
    char := s[i]
    switch {
    case char &gt;= 'a' &amp;&amp; char &lt;= 'z':
      result[i] = 'a' + (char-'a'+13)%26
    case char &gt;= 'A' &amp;&amp; char &lt;= 'Z':
      result[i] = 'A' + (char-'A'+13)%26
    default:
      result[i] = char
    }
  }
  return string(result)
}</pre></li>				<li>Define the function to read data from <strong class="source-inline">stdin</strong>, apply the Rot13 encoding, and write the output <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">stdout</strong></span><span class="No-Break">:</span><pre class="source-code">
func processStdin() {
  reader := bufio.NewReader(os.Stdin)
  for {
    input, err := reader.ReadString('\n')
    if err == io.EOF {
      break
    } else if err != nil {
      fmt.Println("Error reading stdin:", err)
      return
    }
    encoded := rot13(input)
    fmt.Print(encoded)
  }
}</pre></li>				<li>Define the function to process <a id="_idIndexMarker853"/>file or user input, apply the Rot13<a id="_idIndexMarker854"/> encoding, and write<a id="_idIndexMarker855"/> the output <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">stdout</strong></span><span class="No-Break">:</span><pre class="source-code">
func processFileOrInput() {
  var inputReader io.Reader
  // Check if a file path is provided
  if len(os.Args) &gt; 1 {
    file, err := os.Open(os.Args[1])
    if err != nil {
      fmt.Println("Error opening file:", err)
      return
    }
    defer file.Close()
    inputReader = file
  } else {
    // No file provided, read user input
    fmt.Print("Enter text: ")
    inputReader = os.Stdin
  }
  // Process input and apply rot13 encoding
  scanner := bufio.NewScanner(inputReader)
  for scanner.Scan() {
    // Apply rot13 encoding to the input line
    encoded := rot13(scanner.Text())
    fmt.Println(encoded)
  }
  if err := scanner.Err(); err != nil {
    fmt.Println("Error reading input:", err)
  }
}</pre></li>				<li>Define<a id="_idIndexMarker856"/> the <span class="No-Break">main</span><span class="No-Break"><a id="_idIndexMarker857"/></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {
  // Check if data is available on stdin
  stat, _ := os.Stdin.Stat()
  if (stat.Mode() &amp; os.ModeCharDevice) == 0 {
    // Data available on stdin, process it
    processStdin()
  } else {
    // No data on stdin, process file or user input
    processFileOrInput()
  }
}</pre></li>			</ol>
			<p>If you run <strong class="source-inline">go run main.go</strong> and enter <a id="_idIndexMarker858"/>some text when prompted, you’ll receive the<a id="_idIndexMarker859"/> <span class="No-Break">following output:</span></p>
			<pre class="console">
Enter text: enjoy
rawbl
the
gur
book
obbx</pre>			<p>To exit the program, you can<a id="_idIndexMarker860"/> type Ctrl + C. Also, the program can be used in a pipeline, where the output of one command becomes the input of the command-line application if you use <strong class="source-inline">cat data.txt</strong> | <strong class="source-inline">go run main.go</strong>. <strong class="source-inline">cat</strong> is a command that you can use to concatenate files together (For Windows, the <strong class="source-inline">type</strong> command is used for concatenation). In the event you use it on a single file, then it gives you an easy way of printing out the contents of the file. If you declare a <strong class="source-inline">data.txt</strong> file and pipe the contents of the file to the command-line application with the following command, then you will see a <span class="No-Break">similar output:</span></p>
			<pre class="console">
cat data.txt | go run main.go</pre>			<p>Here’s the <span class="No-Break">resulting output:</span></p>
			<pre class="console">
rawbl
gur
obbx</pre>			<p>The preceding exercise demonstrated a few things. First, we saw how we could process <strong class="source-inline">stdin</strong> data line by line using <strong class="source-inline">bufio.NewReader</strong> until an end-of-file error is encountered. We also saw how to process files or input data and Rot13 encode it. Lastly, we saw how we could use the<a id="_idIndexMarker861"/> same code and pipe large amounts of data into the program to encode it. This code<a id="_idIndexMarker862"/> demonstrated Go’s capabilities to stream large data in and out of a command-line application. The program had to be <em class="italic">Ctrl</em> + <em class="italic">C</em> terminated to interrupt the reading from <strong class="source-inline">stdin</strong> and exit the program. That’s a perfect segway into exploring exit codes and<a id="_idIndexMarker863"/> best practices in more detail before we explore interrupts, where we’ll learn more about terminating programs using interrupts such as <em class="italic">Ctrl</em> + <span class="No-Break"><em class="italic">C</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-356"><a id="_idTextAnchor1592"/>Exit codes and command line best practices</h1>
			<p>Ensuring proper exit codes and following best practices is essential for a seamless user experience. Exit codes provide<a id="_idIndexMarker864"/> a way for command-line applications to communicate their status to the calling application. A well-defined exit code system allows users and the other scripts to understand whether the application executed successfully or encountered an issue <span class="No-Break">when running.</span></p>
			<p>In Go, the <strong class="source-inline">os</strong> package provides a straightforward way to set exit codes using the <strong class="source-inline">ox.Exit</strong> function. Conventionally, an exit code of 0 indicates success, while any non-zero code signals <span class="No-Break">an error.</span></p>
			<p>For example, you can check the status code of the previous exercise and verify the successful status code. To do this, run <strong class="source-inline">echo $?</strong> in the terminal. <strong class="source-inline">$?</strong> Is a special shell variable that holds the exit status of the last command that was executed, and the <strong class="source-inline">echo </strong>command prints it out. You’ll see the 0 exit code printout denoting a successful execution status, and no error. You can manually catch errors in the program and return non-zero code signals to denote errors. You can even create custom exit codes, such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const (
  ExitCodeSuccess = 0
  ExitCodeInvalidInput = 1
  ExitCodeFileNotFound = 2
)</pre>			<p>These can easily be used using <strong class="source-inline">os.Exit</strong>, by placing <strong class="source-inline">os.Exit(ExitCodeSuccess)</strong> in successful cases you want to exit, and by using one of the other error codes when you want to exit in <span class="No-Break">certain circumstances.</span></p>
			<p>While using proper exit codes is an<a id="_idIndexMarker865"/> important command line best practice, there are a few others to keep <span class="No-Break">in mind:</span></p>
			<ul>
				<li><strong class="bold">Consistent logging</strong>: Use meaningful messages to <span class="No-Break">aid troubleshooting.</span></li>
				<li><strong class="bold">Clear usage information</strong>: Provide clear and concise usage information, including flags and arguments. Also, some packages allow you to provide example commands. Those should be used to let others see how to use the <span class="No-Break">commands easily.</span></li>
				<li><strong class="bold">Handle help and versioning</strong>: Implement flags to display help and version information. This is good for making your application more user-friendly and providing a means to ensure they are on the latest version by checking the <span class="No-Break">version information.</span></li>
				<li><strong class="bold">Graceful termination</strong>: Exit codes should be considered and terminated gracefully, ensuring proper cleanup tasks are performed <span class="No-Break">as needed.</span></li>
			</ul>
			<p>You are now well on your way when it comes to command-line application best practices and exit code considerations. However, there are times when end users will provide interrupts to cancel an application. Let’s learn what to do and consider when <span class="No-Break">that happens.</span></p>
			<h1 id="_idParaDest-357"><a id="_idTextAnchor1593"/>Knowing when to stop by watching for interrupts</h1>
			<p>When building robust applications, it’s crucial to handle interrupts gracefully, ensuring the software can respond appropriately to<a id="_idIndexMarker866"/> signals indicating it should stop or perform a specific action. In Go, the standard way to achieve this is by monitoring interrupt signals, allowing the application to shut down or clean up resources in an <span class="No-Break">orderly manner.</span></p>
			<p>Graceful shutdown, or termination, is an important concept in computer science in general. Unforeseen events, server maintenance, or external factors might require your application to stop gracefully. This could involve releasing resources, saving state, or notifying connected clients. A graceful shutdown ensures your application remains reliable and predictable, minimizing<a id="_idIndexMarker867"/> the risk of data corruption <span class="No-Break">or loss.</span></p>
			<p>Abruptly terminating an application without proper cleanup can lead to various issues, such as incomplete transactions, resource leaks, corrupted data, and more. Graceful shutdowns mitigate these risks by providing an opportunity to finish ongoing tasks and release <span class="No-Break">acquired resources.</span></p>
			<p>The operating systems communicate with running processes through signals. A process is simply a program running on a computer. The <strong class="source-inline">os/signal</strong> package provides a convenient way to handle these signals within Go programs. There are common interrupt signals, such<a id="_idIndexMarker868"/> as <strong class="bold">SIGINT</strong> (<em class="italic">Ctrl</em> + <em class="italic">C</em>) and <strong class="bold">SIGTERM</strong>, that provide a comprehensive strategy for graceful terminations. We <a id="_idIndexMarker869"/>saw the SIGINT interrupt in <em class="italic">Exercise 13.03</em>. That program had to be <em class="italic">Ctrl</em> + <em class="italic">C</em> terminated to interrupt the reading from <strong class="source-inline">stdin</strong> and exit <span class="No-Break">the program.</span></p>
			<p>The <strong class="source-inline">signal.Notify</strong> function allows you to register channels to receive specified signals. This sets the foundation for creating a mechanism to gracefully shut down your application upon receiving an interrupt signal. There are also effective shutdown patterns and best practices to keep in mind, such as ensuring closed network connections, saving state, and signaling goroutines, to finish up their tasks before exiting. Additionally, using timeouts and the <strong class="source-inline">context</strong> package enhances your application’s responsiveness during shutdown, preventing it from getting <span class="No-Break">stuck indefinitely.</span></p>
			<p>Gracefully handling interrupt signals is a fundamental skill for building robust and reliable command-line applications in Go. By following best practices and patterns to ensure graceful termination, you can ensure that your software behaves predictably, even in the face of <span class="No-Break">unexpected interruptions.</span></p>
			<p>Not only can you stop programs gracefully with different interrupts, but you can also start other commands from the <span class="No-Break">command-line application.</span></p>
			<h1 id="_idParaDest-358"><a id="_idTextAnchor1594"/>Starting other commands from your application</h1>
			<p>Launching external <a id="_idIndexMarker870"/>commands from your Go application opens opportunities for interaction with other programs, processes, and system utilities. The <strong class="source-inline">os/exec</strong> package in Go provides functionalities for starting and interacting with external processes. You can run basic commands, capture their output, and handle errors seamlessly with this package. It serves as a foundation for more advanced command <span class="No-Break">execution scenarios.</span></p>
			<p>For example, the <strong class="source-inline">os/exec</strong> package allows you to customize the execution of commands by configuring attributes such as the working directory, environment variables, and more. You can also provide inputs to the subcommand through standard input streams from the originating <span class="No-Break">command-line application.</span></p>
			<p>By running other commands from within your command-line application, you can run some processes in the background, allowing the application to continue its execution while monitoring or interacting with parallel processes. You can even establish bidirectional communication with commands, enabling real-time interaction and data exchange between the command-line application and the <span class="No-Break">external processes.</span></p>
			<p>When starting other applications, cross-platform considerations must be kept in mind. There are differences in shell behavior and command paths across different operating systems. So, when executing subcommands from a command-line application, it is important to keep a consistent and reliable command execution in mind, regardless of the compute an end user may be using. Thankfully, the <strong class="source-inline">os/exec</strong> package provides a cross-platform solution for executing external commands in Go, making it easier to write code across different <span class="No-Break">operating systems.</span></p>
			<p>Now that we’ve discussed how useful it can be to execute other commands from a Go command-line application, let’s see an example <span class="No-Break">in action.</span></p>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor1595"/>Exercise 13.04 – creating a stopwatch with a time limit</h2>
			<p>In this exercise, we will <a id="_idIndexMarker871"/>create a stopwatch with a time limit and start another command from <span class="No-Break">the application:</span></p>
			<ol>
				<li>Import the <span class="No-Break">necessary packages:</span><pre class="source-code">
package main
import (
  "fmt"
  "os"
  "os/exec"
  "time"
)</pre></li>				<li>Within the main function, set<a id="_idIndexMarker872"/> the time limit for the stopwatch and allow user input to start <span class="No-Break">the clock:</span><pre class="source-code">
func main() {
  timeLimit := 5 * time.Second
  fmt.Println("Press Enter to start the stopwatch...")
  _, err := fmt.Scanln() // Wait for user to press Enter
  if err != nil {
    fmt.Println("Error reading from stdin:", err)
    return
  }
  fmt.Println("Stopwatch started. Waiting for", timeLimit)</pre></li>				<li>Sleep for the time limit, execute the other command from within the command-line application, and close the <span class="No-Break">main function:</span><pre class="source-code">
  time.Sleep(timeLimit)
  fmt.Println("Time's up! Executing the other command.")
  cmd := exec.Command("echo", "Hello")
  cmd.Stdout = os.Stdout
  cmd.Stderr = os.Stderr
  err = cmd.Run()
  if err != nil {
    fmt.Println("Error executing command:", err)
  }
}</pre></li>			</ol>
			<p>If you run <strong class="source-inline">go run main.go</strong> and press Enter to start the timer when prompted, you will receive the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker873"/></span><span class="No-Break">output:</span></p>
			<pre class="console">
Press Enter to start the stopwatch...
Stopwatch started. Waiting for 5s
Time's up! Executing the other command.
Hello</pre>			<p>Executing external commands is a powerful capability that allows your Go applications to interact with the broader system environment. While this was a simple echo command, it shows how strong this capability is if you expand this code to start other applications, run commands in parallel or in the background, <span class="No-Break">and more.</span></p>
			<h1 id="_idParaDest-360"><a id="_idTextAnchor1596"/>Terminal UIs</h1>
			<p>Some of the latest updates to command-line programming with Go have included <strong class="bold">terminal UIs</strong>, or <strong class="bold">TUIs</strong> for short. Creating a <a id="_idIndexMarker874"/>TUI in Go opens a world of possibilities for building interactive command-line applications. There are a few fundamental concepts that are involved with <a id="_idIndexMarker875"/>building UIs for <span class="No-Break">the terminal:</span></p>
			<ul>
				<li><strong class="bold">Components</strong>: TUIs are composed of various components, such as buttons, input fields, <span class="No-Break">and/or lists</span></li>
				<li><strong class="bold">Layouts</strong>: Arranging components in a structured layout is crucial for a clean and <span class="No-Break">intuitive design</span></li>
				<li><strong class="bold">User input handling</strong>: Processing user input from keyboard events is fundamental to <span class="No-Break">interactive interfaces</span></li>
			</ul>
			<p>Some TUI packages provide support for event handling, such as mouse events and key presses, dynamic updates based on input data, or customizing the appearance of UI components. There are several <a id="_idIndexMarker876"/>popular TUI packages available. We will look at one in the following exercise, where we’ll build on a previous exercise in <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor1597"/>Exercise 13.05 – creating a wrapper for our Rot13 pipeline</h2>
			<p>In this exercise, we will <a id="_idIndexMarker877"/>create a TUI wrapper for the Rot13 pipeline that we created in <span class="No-Break"><em class="italic">Exercise 13.03</em></span><span class="No-Break">:</span></p>
			<ol>
				<li>Import the <span class="No-Break">necessary packages:</span><pre class="source-code">
package main
import (
  "bufio"
  "fmt"
  "io"
  "os"
  "strings"
  tea "github.com/charmbracelet/bubbletea"
)</pre></li>				<li>Denote TUI choices and <span class="No-Break">model specifics:</span><pre class="source-code">
var choices = []string{"File input", "Type in input"}
type model struct {
  cursor int
  choice string
}
func (m model) Init() tea.Cmd {
  return nil
}</pre></li>				<li>Define the function to<a id="_idIndexMarker878"/> handle <span class="No-Break">model updates:</span><pre class="source-code">
func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
  switch msg := msg.(type) {
  case tea.KeyMsg:
    switch msg.String() {
    case "ctrl+c", "q", "esc":
      return m, tea.Quit
    case "enter":
      m.choice = choices[m.cursor]
      return m, tea.Quit
    case "down", "j":
      m.cursor++
      if m.cursor &gt;= len(choices) {
        m.cursor = 0
      }
    case "up", "k":
      m.cursor--
      if m.cursor &lt; 0 {
        m.cursor = len(choices) - 1
      }
    }
  }
  return m, nil
}</pre></li>				<li>Define the <a id="_idIndexMarker879"/><span class="No-Break">TUI view:</span><pre class="source-code">
func (m model) View() string {
  s := strings.Builder{}
  s.WriteString("Select if you would like to work with file input or type in input:\n\n")
  for i := 0; i &lt; len(choices); i++ {
    if m.cursor == i {
      s.WriteString("(•) ")
    } else {
      s.WriteString("( ) ")
    }
    s.WriteString(choices[i])
    s.WriteString("\n")
  }
  s.WriteString("\n(press q to quit)\n")
  return s.String()
}</pre></li>				<li>Define the same Rot13 encoding function <span class="No-Break">from earlier:</span><pre class="source-code">
func rot13(s string) string {
  result := make([]byte, len(s))
  for i := 0; i &lt; len(s); i++ {
    char := s[i]
    switch {
    case char &gt;= 'a' &amp;&amp; char &lt;= 'z':
      result[i] = 'a' + (char-'a'+13)%26
    case char &gt;= 'A' &amp;&amp; char &lt;= 'Z':
      result[i] = 'A' + (char-'A'+13)%26
    default:
      result[i] = char
    }
  }
  return string(result)
}</pre></li>				<li>Define the function to read in <a id="_idIndexMarker880"/>data from <strong class="source-inline">stdin</strong> to apply Rot13 <span class="No-Break">encoding to:</span><pre class="source-code">
func processStdin() {
  reader := bufio.NewReader(os.Stdin)
  for {
    input, err := reader.ReadString('\n')
    if err == io.EOF {
      break
    } else if err != nil {
      fmt.Println("Error reading stdin:", err)
      return
    }
    encoded := rot13(input)
    fmt.Print(encoded)
  }
}</pre></li>				<li>Define the modified<a id="_idIndexMarker881"/> function to handle <span class="No-Break">file input:</span><pre class="source-code">
func processFile(filename string) {
  var inputReader io.Reader
  file, err := os.Open(filename)
  if err != nil {
    fmt.Println("Error opening file:", err)
    return
  }
  defer file.Close()
  inputReader = file
  // Process input and apply rot13 encoding
  scanner := bufio.NewScanner(inputReader)
  for scanner.Scan() {
    encoded := rot13(scanner.Text())
    fmt.Println(encoded)
  }
  if err := scanner.Err(); err != nil {
    fmt.Println("Error reading input:", err)
  }
}</pre></li>				<li>Define the main function to start <span class="No-Break">the TUI:</span><pre class="source-code">
func main() {
  p := tea.NewProgram(model{})
  m, err := p.Run()
  if err != nil {
    fmt.Println("Error running program:", err)
    os.Exit(1)
  }
  if m, ok := m.(model); ok &amp;&amp; m.choice != "" {
    fmt.Printf("\n---\nYou chose %s!\n", m.choice)
  }
  if m, ok := m.(model); ok &amp;&amp; m.choice != "" &amp;&amp; m.choice == "File input" {
    processFile("data.txt")
  }
  if m, ok := m.(model); ok &amp;&amp; m.choice != "" &amp;&amp; m.choice == "Type in input" {
    processStdin()
  }
}</pre></li>			</ol>
			<p>You’ll receive the following<a id="_idIndexMarker882"/> output<a id="_idTextAnchor1598"/><a id="_idTextAnchor1599"/><a id="_idTextAnchor1600"/><a id="_idTextAnchor1601"/><a id="_idTextAnchor1602"/><a id="_idTextAnchor1603"/><a id="_idTextAnchor1604"/><a id="_idTextAnchor1605"/><a id="_idTextAnchor1606"/><a id="_idTextAnchor1607"/><a id="_idTextAnchor1608"/><a id="_idTextAnchor1609"/><a id="_idTextAnchor1610"/><a id="_idTextAnchor1611"/><a id="_idTextAnchor1612"/><a id="_idTextAnchor1613"/><a id="_idTextAnchor1614"/><a id="_idTextAnchor1615"/><a id="_idTextAnchor1616"/><a id="_idTextAnchor1617"/> if you run <strong class="source-inline">go run main.go</strong> and select <span class="No-Break"><strong class="source-inline">File input</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
Select if you would like to work with file input or type in input:
(•) File input
( ) Type in input
(press q to quit)
---
You chose File input!
rawbl
gur
obbx</pre>			<p>You’ll receive the following <a id="_idIndexMarker883"/>output if you run <strong class="source-inline">go run main.go</strong> and select <strong class="source-inline">Type </strong><span class="No-Break"><strong class="source-inline">in input</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
Select if you would like to work with file input or type in input:
( ) File input
(•) Type in input
(press q to quit)
---
You chose Type in input!
enjoy
rawbl
the
gur
book
obbx</pre>			<p>The preceding example expanded upon our previous exercise. Here, we provided a very simple wrapper for the entrance to the Rot13 coding exercise, providing a nice UI to input if you are going to use the default data file for input or provide your own input. This TUI was simple on purpose to demonstrate that quite a bit is involved when it comes to defining the model interface so that it can work with the <span class="No-Break">terminal UI.</span></p>
			<p>Now, let’s see what it looks like to consume other people’s command-line applications using <span class="No-Break"><strong class="source-inline">go install</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-362"><a id="_idTextAnchor1618"/>go install</h1>
			<p>You can install Go command-line applications using the <strong class="source-inline">go install</strong> command. This command is a powerful tool that’s<a id="_idIndexMarker884"/> provided (among the many) by the Go toolchain to compile and install Go applications in your workspace’s bin directory. This allows you to run your applications globally from any terminal window. To install a Go application, you can simply navigate to the project’s root directory and run <span class="No-Break"><strong class="source-inline">go install</strong></span><span class="No-Break">.</span></p>
			<p>This command considers cross-platform compilation by providing the <strong class="source-inline">GOOS</strong> flag, where you can specify which operating system to target, as well as the <strong class="source-inline">GOARCH</strong> flag, where you can specify the underlying architecture <span class="No-Break">to target.</span></p>
			<p>An example of a common Go package that you can use to generate command-line interfaces in Go is the <strong class="source-inline">cobra</strong> package. This is also a tool you can use to bootstrap application scaffolding to rapidly develop Cobra-based applications if you would like to dive further into developing your programming in terms of command-line skills. This package provides a simple example of using the <strong class="source-inline">go </strong><span class="No-Break"><strong class="source-inline">install</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
go install github.com/spf13/cobra-cli@latest</pre>			<p>The preceding command installs all of the dependencies to use the Cobra CLI. As a result, my machine knows about the tool, and you can easily work with the command-line program that you just installed, as <span class="No-Break">shown here:</span></p>
			<pre class="console">
cobra-cli –help</pre>			<p>Cobra is a CLI library for Go that <span class="No-Break">empowers applications.</span></p>
			<p>It can generate the necessary files to quickly create a <span class="No-Break">Cobra application:</span></p>
			<pre class="console">
Usage:
 cobra-cli [command]
Available Commands:
 add Add a command to a Cobra Application
completion Generate the autocompletion script for the specified shell
help Help about any command
init Initialize a Cobra Application
Flags:
-a, --author string author name for copyright attribution (default "YOUR NAME")
--config string config file (default is $HOME/.cobra.yaml)
-h, --help help for cobra-cli
-l, --license string name of license for the project
--viper use Viper for configuration
Use "cobra-cli [command] --help" for more information about a command.</pre>			<p>With that, you know how to install <a id="_idIndexMarker885"/>someone else’s command-line application. N<a id="_idTextAnchor1619"/><a id="_idTextAnchor1620"/>ow, let’s summarize what we learned in <span class="No-Break">this chapter.</span></p>
			<h1 id="_idParaDest-363"><a id="_idTextAnchor1621"/>Summary</h1>
			<p>In this chapter, we studied various methodologies of programming via the command line. We uncovered how Go is an excellent choice for creating command-line applications with ease, as well as how to use the native <span class="No-Break">Go toolchain.</span></p>
			<p>Starting with the <strong class="source-inline">os</strong> and <strong class="source-inline">flag</strong> packages, we looked at how to read arguments from the command line for our application. Then, we looked at flags to control the behavior of our program and looked at how streaming large amounts of data in and out of an application can shed light on how command-line applications in Go can be part of a bigger <span class="No-Break">programmatic pipeline.</span></p>
			<p>We also took a peak at handling the CLI shutdown process gracefully by discussing exit codes and interrupts, as well as invoking other commands from within our command-line application. We ended this chapter by looking at terminal UIs, taking our CLI to the next level, and installing other CLIs using the native <span class="No-Break">Go toolchain.</span></p>
			<p>In the next chapter, we will look at files and systems using Go. While we did touch on that in this chapter so that we could read input data for our CLI application, we wil<a id="_idTextAnchor1622"/>l do a deep dive into reading and writing <span class="No-Break">files next.</span></p>
		</div>
	</div></div></body></html>