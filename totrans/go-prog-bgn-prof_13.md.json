["```go\n    package main\n    import (\n      \"fmt\"\n      \"os\"\n    )\n    ```", "```go\n    func main() {\n      args := os.Args\n    ```", "```go\n      if len(args) < 2 {\n        fmt.Println(\"Usage: go run main.go <name>\")\n        return\n      }\n    ```", "```go\n      name := args[1]\n    ```", "```go\n      greeting := fmt.Sprintf(\"Hello, %s! Welcome to the command line.\", name)\n      fmt.Println(greeting)\n    }\n    ```", "```go\n    go run main.go Sam\n    ```", "```go\nHello, Sam! Welcome to the command line.\n```", "```go\n    package main\n    import (\n      \"flag\"\n      \"fmt\"\n    )\n    ```", "```go\n    var (\n      nameFlag = flag.String(\"name\", \"Sam\", \"Name of the person to say hello to\")\n      quietFlag = flag.Bool(\"quiet\", false, \"Toggle to be quiet when saying hello\")\n    )\n    Parse the flags and conditionally say hello pending the value of the quiet flag:\n    func main(){\n      flag.Parse()\n      if !*quietFlag {\n        greeting := fmt.Sprintf(\"Hello, %s! Welcome to the command line.\", *nameFlag)\n        fmt.Println(greeting)\n      }\n    }\n    ```", "```go\nHello, Sam! Welcome to the command line.\n```", "```go\nHello, Cassie! Welcome to the command line.\n```", "```go\nUsage of /var/folders/qt/5jjdv1bj3h33t2rl40tpt56w0000gn/T/go-build1361710947/b001/exe/main:\n-name string\nName of the person to say hello to (default \"Sam\")\n-quiet\nToggle to be quiet when saying hello\n```", "```go\n    package main\n    import (\n      \"bufio\"\n      \"fmt\"\n      \"io\"\n      \"os\"\n    )\n    ```", "```go\n    func rot13(s string) string {\n      result := make([]byte, len(s))\n      for i := 0; i < len(s); i++ {\n        char := s[i]\n        switch {\n        case char >= 'a' && char <= 'z':\n          result[i] = 'a' + (char-'a'+13)%26\n        case char >= 'A' && char <= 'Z':\n          result[i] = 'A' + (char-'A'+13)%26\n        default:\n          result[i] = char\n        }\n      }\n      return string(result)\n    }\n    ```", "```go\n    func processStdin() {\n      reader := bufio.NewReader(os.Stdin)\n      for {\n        input, err := reader.ReadString('\\n')\n        if err == io.EOF {\n          break\n        } else if err != nil {\n          fmt.Println(\"Error reading stdin:\", err)\n          return\n        }\n        encoded := rot13(input)\n        fmt.Print(encoded)\n      }\n    }\n    ```", "```go\n    func processFileOrInput() {\n      var inputReader io.Reader\n      // Check if a file path is provided\n      if len(os.Args) > 1 {\n        file, err := os.Open(os.Args[1])\n        if err != nil {\n          fmt.Println(\"Error opening file:\", err)\n          return\n        }\n        defer file.Close()\n        inputReader = file\n      } else {\n        // No file provided, read user input\n        fmt.Print(\"Enter text: \")\n        inputReader = os.Stdin\n      }\n      // Process input and apply rot13 encoding\n      scanner := bufio.NewScanner(inputReader)\n      for scanner.Scan() {\n        // Apply rot13 encoding to the input line\n        encoded := rot13(scanner.Text())\n        fmt.Println(encoded)\n      }\n      if err := scanner.Err(); err != nil {\n        fmt.Println(\"Error reading input:\", err)\n      }\n    }\n    ```", "```go\n    func main() {\n      // Check if data is available on stdin\n      stat, _ := os.Stdin.Stat()\n      if (stat.Mode() & os.ModeCharDevice) == 0 {\n        // Data available on stdin, process it\n        processStdin()\n      } else {\n        // No data on stdin, process file or user input\n        processFileOrInput()\n      }\n    }\n    ```", "```go\nEnter text: enjoy\nrawbl\nthe\ngur\nbook\nobbx\n```", "```go\ncat data.txt | go run main.go\n```", "```go\nrawbl\ngur\nobbx\n```", "```go\nconst (\n  ExitCodeSuccess = 0\n  ExitCodeInvalidInput = 1\n  ExitCodeFileNotFound = 2\n)\n```", "```go\n    package main\n    import (\n      \"fmt\"\n      \"os\"\n      \"os/exec\"\n      \"time\"\n    )\n    ```", "```go\n    func main() {\n      timeLimit := 5 * time.Second\n      fmt.Println(\"Press Enter to start the stopwatch...\")\n      _, err := fmt.Scanln() // Wait for user to press Enter\n      if err != nil {\n        fmt.Println(\"Error reading from stdin:\", err)\n        return\n      }\n      fmt.Println(\"Stopwatch started. Waiting for\", timeLimit)\n    ```", "```go\n      time.Sleep(timeLimit)\n      fmt.Println(\"Time's up! Executing the other command.\")\n      cmd := exec.Command(\"echo\", \"Hello\")\n      cmd.Stdout = os.Stdout\n      cmd.Stderr = os.Stderr\n      err = cmd.Run()\n      if err != nil {\n        fmt.Println(\"Error executing command:\", err)\n      }\n    }\n    ```", "```go\nPress Enter to start the stopwatch...\nStopwatch started. Waiting for 5s\nTime's up! Executing the other command.\nHello\n```", "```go\n    package main\n    import (\n      \"bufio\"\n      \"fmt\"\n      \"io\"\n      \"os\"\n      \"strings\"\n      tea \"github.com/charmbracelet/bubbletea\"\n    )\n    ```", "```go\n    var choices = []string{\"File input\", \"Type in input\"}\n    type model struct {\n      cursor int\n      choice string\n    }\n    func (m model) Init() tea.Cmd {\n      return nil\n    }\n    ```", "```go\n    func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n      switch msg := msg.(type) {\n      case tea.KeyMsg:\n        switch msg.String() {\n        case \"ctrl+c\", \"q\", \"esc\":\n          return m, tea.Quit\n        case \"enter\":\n          m.choice = choices[m.cursor]\n          return m, tea.Quit\n        case \"down\", \"j\":\n          m.cursor++\n          if m.cursor >= len(choices) {\n            m.cursor = 0\n          }\n        case \"up\", \"k\":\n          m.cursor--\n          if m.cursor < 0 {\n            m.cursor = len(choices) - 1\n          }\n        }\n      }\n      return m, nil\n    }\n    ```", "```go\n    func (m model) View() string {\n      s := strings.Builder{}\n      s.WriteString(\"Select if you would like to work with file input or type in input:\\n\\n\")\n      for i := 0; i < len(choices); i++ {\n        if m.cursor == i {\n          s.WriteString(\"(•) \")\n        } else {\n          s.WriteString(\"( ) \")\n        }\n        s.WriteString(choices[i])\n        s.WriteString(\"\\n\")\n      }\n      s.WriteString(\"\\n(press q to quit)\\n\")\n      return s.String()\n    }\n    ```", "```go\n    func rot13(s string) string {\n      result := make([]byte, len(s))\n      for i := 0; i < len(s); i++ {\n        char := s[i]\n        switch {\n        case char >= 'a' && char <= 'z':\n          result[i] = 'a' + (char-'a'+13)%26\n        case char >= 'A' && char <= 'Z':\n          result[i] = 'A' + (char-'A'+13)%26\n        default:\n          result[i] = char\n        }\n      }\n      return string(result)\n    }\n    ```", "```go\n    func processStdin() {\n      reader := bufio.NewReader(os.Stdin)\n      for {\n        input, err := reader.ReadString('\\n')\n        if err == io.EOF {\n          break\n        } else if err != nil {\n          fmt.Println(\"Error reading stdin:\", err)\n          return\n        }\n        encoded := rot13(input)\n        fmt.Print(encoded)\n      }\n    }\n    ```", "```go\n    func processFile(filename string) {\n      var inputReader io.Reader\n      file, err := os.Open(filename)\n      if err != nil {\n        fmt.Println(\"Error opening file:\", err)\n        return\n      }\n      defer file.Close()\n      inputReader = file\n      // Process input and apply rot13 encoding\n      scanner := bufio.NewScanner(inputReader)\n      for scanner.Scan() {\n        encoded := rot13(scanner.Text())\n        fmt.Println(encoded)\n      }\n      if err := scanner.Err(); err != nil {\n        fmt.Println(\"Error reading input:\", err)\n      }\n    }\n    ```", "```go\n    func main() {\n      p := tea.NewProgram(model{})\n      m, err := p.Run()\n      if err != nil {\n        fmt.Println(\"Error running program:\", err)\n        os.Exit(1)\n      }\n      if m, ok := m.(model); ok && m.choice != \"\" {\n        fmt.Printf(\"\\n---\\nYou chose %s!\\n\", m.choice)\n      }\n      if m, ok := m.(model); ok && m.choice != \"\" && m.choice == \"File input\" {\n        processFile(\"data.txt\")\n      }\n      if m, ok := m.(model); ok && m.choice != \"\" && m.choice == \"Type in input\" {\n        processStdin()\n      }\n    }\n    ```", "```go\nSelect if you would like to work with file input or type in input:\n(•) File input\n( ) Type in input\n(press q to quit)\n---\nYou chose File input!\nrawbl\ngur\nobbx\n```", "```go\nSelect if you would like to work with file input or type in input:\n( ) File input\n(•) Type in input\n(press q to quit)\n---\nYou chose Type in input!\nenjoy\nrawbl\nthe\ngur\nbook\nobbx\n```", "```go\ngo install github.com/spf13/cobra-cli@latest\n```", "```go\ncobra-cli –help\n```", "```go\nUsage:\n cobra-cli [command]\nAvailable Commands:\n add Add a command to a Cobra Application\ncompletion Generate the autocompletion script for the specified shell\nhelp Help about any command\ninit Initialize a Cobra Application\nFlags:\n-a, --author string author name for copyright attribution (default \"YOUR NAME\")\n--config string config file (default is $HOME/.cobra.yaml)\n-h, --help help for cobra-cli\n-l, --license string name of license for the project\n--viper use Viper for configuration\nUse \"cobra-cli [command] --help\" for more information about a command.\n```"]