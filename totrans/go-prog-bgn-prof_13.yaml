- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Programming from the Command Line
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行编程
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will look at programming from the command line. We will
    see how Go is an excellent choice for creating powerful command-line utilities
    and applications, as well as discuss the many tools available for working with
    the command line using Go.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨从命令行进行编程。我们将看到 Go 是创建强大命令行工具和应用程序的绝佳选择，并讨论使用 Go 处理命令行的许多工具。
- en: By reading this chapter, you will acquaint yourself with developing powerful
    command-line utilities and applications in Go. We will start with the basics of
    reading in command-line arguments and employing those flag values to control application
    behavior, take a peek at dealing with larger amounts of data inside and outside
    the application, and evaluate exit codes and best practices along the way. Then,
    we will dive a bit deeper and discuss strategies for gracefully handling interrupts,
    initiating external commands from our application, and using `go install`. Finally,
    we will learn how to create **terminal user interfaces** (**TUIs**), which allow
    us to craft robust, user-friendly command-line tools in Go.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读本章，您将熟悉在 Go 中开发强大的命令行工具和应用程序。我们将从读取命令行参数和利用这些标志值来控制应用程序行为的基础知识开始，一瞥在应用程序内外处理大量数据的方法，并在过程中评估退出代码和最佳实践。然后，我们将进一步深入探讨优雅地处理中断、从我们的应用程序中启动外部命令以及使用
    `go install` 的策略。最后，我们将学习如何创建**终端用户界面**（**TUIs**），这允许我们用 Go 编写强大且用户友好的命令行工具。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you’ll require Go version 1.21 or higher. The code for this
    chapter can be found at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter13](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter13).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要 Go 版本 1.21 或更高。本章的代码可以在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter13](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter13)找到。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we looked at how Go provides powerful constructs when
    dealing with time data. We will be shifting gears a bit in this chapter to discuss
    one of the many ways that Go is beneficial in creating a powerful interface for
    applications.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了 Go 在处理时间数据时提供的强大结构。在本章中，我们将稍微转换一下方向，讨论 Go 在为应用程序创建强大界面方面有益的许多方法之一。
- en: UIs don’t always have to be a web application frontend web page. End users can
    interact with software through engaging command-line interfaces, as well as by
    using a **command-line** **interface** (**CLI**).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面不总是必须是网络应用程序的前端网页。最终用户可以通过引人入胜的命令行界面以及使用**命令行****界面**（**CLI**）与软件进行交互。
- en: Go provides many packages that allow us to program for the command line. We’ll
    look at some of these packages, see where Go is at in terms of creating powerful
    command-line utilities, and learn about some of the current efforts in this space.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了许多允许我们为命令行编程的包。我们将查看其中的一些包，了解 Go 在创建强大命令行工具方面的位置，并了解一些当前在这个领域的努力。
- en: Reading arguments
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取参数
- en: Command-line arguments are a fundamental aspect of building versatile and interactive
    command-line applications. Reading arguments allow developers to make their applications
    more dynamic and adaptable to user input. Command-line arguments serve as a means
    for users to customize the behavior of a program without modifying its source
    code. By capturing input parameters from the command line, developers can create
    versatile applications that cater to different use cases and scenarios.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行参数是构建灵活和交互式命令行应用程序的基本方面。读取参数允许开发者使他们的应用程序更加动态和适应用户输入。命令行参数为用户提供了一种自定义程序行为的方式，而无需修改其源代码。通过从命令行捕获输入参数，开发者可以创建适应不同用例和场景的通用应用程序。
- en: In Go, the `os` package serves as a straightforward way to access these arguments.
    The `os.Args` slice provides a convenient way to access command-line arguments.
    This allows developers to retrieve information such as file paths, configuration
    parameters, or any other input relevant to the application’s functionality. The
    ability to read command-line arguments enhances the user experience by making
    applications more interactive and user-friendly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 语言中，`os` 包提供了一种直接访问这些参数的简单方法。`os.Args` 切片提供了一种方便的方式来访问命令行参数。这使得开发者能够检索有关文件路径、配置参数或与应用程序功能相关的任何其他输入信息。读取命令行参数的能力通过使应用程序更加交互性和用户友好来增强用户体验。
- en: Moreover, command-line arguments enable automation and scripting, allowing users
    to pass inputs programmatically. This flexibility is particularly valuable in
    scenarios where the same program needs to be executed with different parameters,
    making it a powerful tool for scripting and automation tasks.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，命令行参数可以实现自动化和脚本化，使用户能够以编程方式传递输入。这种灵活性在需要以不同参数执行相同程序的场景中尤其有价值，使其成为脚本化和自动化任务的强大工具。
- en: Let’s dive into the process of reading command-line arguments and illustrate
    this with a simple example that greets users with a personalized message.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解读取命令行参数的过程，并通过一个简单的示例来展示，该示例使用个性化消息问候用户。
- en: Exercise 13.01 – saying hello using a name passed as an argument
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.01 – 使用作为参数传递的名称说“你好”
- en: 'In this exercise, we will print a `hello` statement using arguments that have
    been passed in from the command line:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用从命令行传递的参数来打印一个 `hello` 语句：
- en: 'Import the `fmt` and `os` packages:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `fmt` 和 `os` 包：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Utilize the `args` slice mentioned previously to capture the command-line arguments:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用前面提到的 `args` 切片来捕获命令行参数：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Perform validation on the number of arguments supplied, excluding the executable
    name provided:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对提供的参数数量进行验证，不包括提供的可执行文件名：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Extract the name from the arguments supplied:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从提供的参数中提取名称：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Display a personalized greeting message:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示个性化的问候信息：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Run the following command to execute the code:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以执行代码：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With that, we have demonstrated the basics of capturing a command-line argument
    using Go, and seen some of the benefits of capturing input data in an easy way
    for our program. While we used the `os` package in this example, other packages
    can assist in achieving the same goal of reading the input provided to the application,
    such as using the `flags` package. Let’s look at how useful flags can be in programming
    for the command line.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经展示了使用 Go 语言捕获命令行参数的基本方法，并看到了以简单方式捕获输入数据的一些好处。虽然在这个例子中我们使用了 `os` 包，但其他包可以帮助实现读取应用程序提供的输入的相同目标，例如使用
    `flags` 包。让我们看看标志在编程中对于命令行有多有用。
- en: Using flags to control behavior
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标志来控制行为
- en: The `flags` package provides a higher-level and more structured approach to
    reading arguments compared to directly using the `os` package. Flags simplify
    the process of parsing and handling command-line input, making it easier for developers
    to create robust and user-friendly command-line applications.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`flags` 包提供了一种比直接使用 `os` 包更高级和更结构化的方法来读取参数。标志简化了解析和处理命令行输入的过程，使得开发者更容易创建健壮且用户友好的命令行应用程序。'
- en: 'The `flags` package allows you to define flags with associated types and default
    values, making it clear what kind of input a user is expected to provide. It also
    automatically generates help messages, making your program more self-documenting.
    Here’s a brief overview of how the `flags` package can help in reading and handling
    command-line arguments:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`flags` 包允许您定义带有相关类型和默认值的标志，从而清楚地表明用户应提供何种类型的输入。它还自动生成帮助信息，使您的程序更具自文档性。以下是
    `flags` 包如何帮助读取和处理命令行参数的简要概述：'
- en: '**Define flags**: You can define flags, along with their types and default
    values. This provides a clear and structured way to specify expected inputs.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义标志**: 您可以定义标志，包括它们的类型和默认值。这提供了一种清晰且结构化的方式来指定预期的输入。'
- en: '**Parse flags**: After defining flags, you can parse the command-line arguments.
    This initializes flag variables with the values provided by a user.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解析标志**: 在定义标志之后，您可以解析命令行参数。这将使用用户提供的值初始化标志变量。'
- en: '**Access flag values**: Once you have parsed the flag values that have been
    passed in, you can access the defined flags through variables and continue to
    work with them throughout the application.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问标志值**：一旦你解析了传递给程序的标志值，你就可以通过变量访问定义的标志，并在整个应用程序中继续使用它们。'
- en: Flags allow you to customize the behavior of your program without the need to
    modify the source code. For example, you can create flags that allow you to toggle
    behavior based on if a flag value is set. You can also use basic conditional logic
    pending the values set for certain flags. Let’s complete an exercise and utilize
    the `flags` package to say hello.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 标志允许你自定义程序的行为，而无需修改源代码。例如，你可以创建允许你根据标志值切换行为的标志。你还可以使用基于某些标志值设置的基本条件逻辑。让我们完成一个练习，并利用`flags`包来有条件地说“你好”。
- en: Exercise 13.02 – using flags to say hello conditionally
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.02 – 使用标志有条件地说“你好”
- en: 'In this exercise, we will print a `hello` statement using the `flags` package:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`flags`包打印一个`hello`语句：
- en: 'Import the `fmt` and `os` packages:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`fmt`和`os`包：
- en: '[PRE7]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create our flags for the utility and set the default values:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为实用程序创建标志并设置默认值：
- en: '[PRE8]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here’s the output you’ll receive if you run `go run main.go`. This is because
    `quietFlag` defaults to `false` and `nameFlag` defaults to `Sam`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行`go run main.go`，你会收到以下输出。这是因为`quietFlag`默认为`false`，而`nameFlag`默认为`Sam`：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'However, you can set values for the flags. For this, you can use `nameFlag`
    and set the `quietFlag` value. The output of running `go run main.go --name=Cassie
    –-quiet=false` is listed here. This is because `quietFlag` is set to false and
    `nameFlag` is set to Sam:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以为标志设置值。为此，你可以使用`nameFlag`并设置`quietFlag`的值。运行`go run main.go --name=Cassie
    –-quiet=false`的输出如下。这是因为`quietFlag`被设置为`false`，而`nameFlag`被设置为`Sam`：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Alternatively, you will get no output if you use `quietFlag` with a value of
    `true`. So, if you run `go run main.go --quiet=true`, then you’ll see no output
    as we have just used flags to control the expected output behavior of our program.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你使用`quietFlag`的值为`true`，则不会输出任何内容。所以，如果你运行`go run main.go --quiet=true`，那么你将看不到任何输出，因为我们已经使用了标志来控制程序预期的输出行为。
- en: 'This code demonstrated how you can use flags to control the behavior of a program.
    If you are working with someone else’s command-line interface, then you can seamlessly
    use the `help` flag to list the defined flags available. The `flag` package in
    Go automatically generates a help message based on the flags in the program. To
    see the available help message for the preceding code, you can run `go run main.go
    --help`. That will provide the following output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了如何使用标志来控制程序的行为。如果你在使用他人的命令行界面，那么你可以无缝地使用`help`标志来列出可用的定义标志。Go语言中的`flag`包会根据程序中的标志自动生成帮助信息。要查看前面代码的可用帮助信息，你可以运行`go
    run main.go --help`。这将提供以下输出：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By utilizing the `flags` package, you enhance the readability and maintainability
    of your code, as well as provide a more user-friendly experience. It simplifies
    the process of handling various types of input and automates the generation of
    usage information, making it easier for users to understand and interact with
    your command-line application. Now, let’s see what it looks like to stream data
    in and out of the application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`flags`包，你可以提高代码的可读性和可维护性，同时提供更友好的用户体验。它简化了处理各种类型输入的过程，并自动生成使用信息，使用户更容易理解和与命令行应用程序交互。现在，让我们看看如何将数据流进和流出应用程序。
- en: Streaming large amounts of data in and out of your application
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在应用程序中流进和流出大量数据
- en: In command-line applications, it is crucial to handle large amounts of data
    efficiently for performance and responsiveness purposes. Often, command-line applications
    may be a small part of a larger pipeline processing data. Most people are not
    going to want to sit around typing out a large amount of data, such as a dataset,
    piece by piece.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行应用程序中，为了性能和响应性，高效地处理大量数据至关重要。通常，命令行应用程序可能是更大数据处理管道中的一小部分。大多数人都不愿意坐下来逐个输入大量数据，比如数据集。
- en: Go allows you to stream data to your applications so that you can process information
    in chunks, rather than all at once. This allows you to effectively process large
    amounts of data, reduce memory overhead, and provide better scalability in the
    future.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言允许你将数据流到你的应用程序中，这样你就可以分块处理信息，而不是一次性处理。这允许你有效地处理大量数据，减少内存开销，并为未来的可扩展性提供更好的支持。
- en: 'When dealing with large amounts of data, it’s often stored in files. This can
    range from financial CSV files, analysis Excel files, or machine learning datasets.
    There are a few main benefits of streaming data with Go:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大量数据时，它们通常存储在文件中。这可以是从金融CSV文件、分析Excel文件到机器学习数据集。使用Go流式传输数据的几个主要优点包括：
- en: '**Memory efficiency**: The program can read and process data line by line,
    reducing memory consumption, as you then don’t have to read the entire data into
    memory'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存效率**：程序可以逐行读取和处理数据，减少内存消耗，因为您不必将整个数据读入内存'
- en: '**Real-time analysis**: Users can observe a real-time analysis of the results
    of processing their data'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时分析**：用户可以观察处理数据结果的真实时分析'
- en: '**Interactive interface**: You can enhance the command-line interface so that
    it accepts dynamic information or displays additional details when processing
    large amounts of data'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互式界面**：您可以通过增强命令行界面使其接受动态信息或在大数据处理时显示额外详细信息'
- en: Data confidentiality might be top of mind, depending on the type of data you
    may be streaming to your command-line application. For this reason, different
    encoding mechanisms may be employed to hide text without providing real security
    on the data, or as a first step toward securing the data.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 数据机密性可能取决于您可能流式传输到命令行应用程序的数据类型。因此，可能采用不同的编码机制来隐藏文本，而不提供真实的安全性，或者作为保护数据的第一步。
- en: '*Rot13*, or rotate by 13 places, is a simple letter substitution cipher that
    replaces a letter with the 13th letter after it in the alphabet. For example,
    the letter A would become N, and B would become C, and so forth. It is a symmetric
    key algorithm that is often used as a trivial form of encryption to obscure text.
    This algorithm provides no significant security and is mainly used for fun, typically
    never used in a production-level environment to secure data. It is also fully
    self-reversible, meaning that applying Rot13 twice would result in the same originating
    data. This can be useful for sending and receiving text in environments where
    the receiving end may or may not know if the data has been encoded.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rot13*，或旋转13个位置，是一种简单的字母替换密码，用字母表中该字母之后的第13个字母替换它。例如，字母A将变成N，B将变成C，以此类推。它是一种对称密钥算法，通常用作加密的简单形式，以掩盖文本。此算法不提供显著的安全性，主要用于娱乐，通常不会在生产环境中用于保护数据。它也是完全可逆的，这意味着应用Rot13两次将产生相同的数据。这在发送和接收文本的环境中可能很有用，接收端可能知道或不知道数据是否已被编码。'
- en: Let’s expand our new Rot13 knowledge so that we can work on a fun streaming
    data example for a command-line application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展我们新的Rot13知识，以便我们可以为一个命令行应用程序工作在有趣的流数据示例。
- en: Exercise 13.03 – using pipes, stdin, and stdout to apply a Rot13 encoding to
    a file
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.03 – 使用管道、stdin和stdout应用Rot13编码到文件
- en: 'In this exercise, we will work with the Rot13 encoding for some input data:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用Rot13编码处理一些输入数据：
- en: 'Import the required packages:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的包：
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Define the `rot13` function to apply Rot13 encoding to a given string:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`rot13`函数，将Rot13编码应用于给定的字符串：
- en: '[PRE13]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Define the function to read data from `stdin`, apply the Rot13 encoding, and
    write the output to `stdout`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，从`stdin`读取数据，应用Rot13编码，并将输出写入`stdout`：
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Define the function to process file or user input, apply the Rot13 encoding,
    and write the output to `stdout`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个处理文件或用户输入的函数，应用Rot13编码，并将输出写入`stdout`：
- en: '[PRE15]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Define the main function:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义主函数：
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you run `go run main.go` and enter some text when prompted, you’ll receive
    the following output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行`go run main.go`并输入一些文本，您将收到以下输出：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To exit the program, you can type Ctrl + C. Also, the program can be used in
    a pipeline, where the output of one command becomes the input of the command-line
    application if you use `cat data.txt` | `go run main.go`. `cat` is a command that
    you can use to concatenate files together (For Windows, the `type` command is
    used for concatenation). In the event you use it on a single file, then it gives
    you an easy way of printing out the contents of the file. If you declare a `data.txt`
    file and pipe the contents of the file to the command-line application with the
    following command, then you will see a similar output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出程序，您可以输入 Ctrl + C。此外，程序可以用于管道中，其中一条命令的输出成为命令行应用程序的输入，如果您使用 `cat data.txt`
    | `go run main.go`。`cat` 是一个可以将文件连接在一起的命令（对于 Windows，使用 `type` 命令进行连接）。如果您单独使用它，那么它提供了一个打印文件内容的简单方法。如果您声明一个
    `data.txt` 文件，并使用以下命令将文件内容传递给命令行应用程序，那么您将看到类似的输出：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here’s the resulting output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成的输出：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding exercise demonstrated a few things. First, we saw how we could
    process `stdin` data line by line using `bufio.NewReader` until an end-of-file
    error is encountered. We also saw how to process files or input data and Rot13
    encode it. Lastly, we saw how we could use the same code and pipe large amounts
    of data into the program to encode it. This code demonstrated Go’s capabilities
    to stream large data in and out of a command-line application. The program had
    to be *Ctrl* + *C* terminated to interrupt the reading from `stdin` and exit the
    program. That’s a perfect segway into exploring exit codes and best practices
    in more detail before we explore interrupts, where we’ll learn more about terminating
    programs using interrupts such as *Ctrl* + *C*.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的练习演示了一些内容。首先，我们看到了如何使用 `bufio.NewReader` 逐行处理 `stdin` 数据，直到遇到文件结束错误。我们还看到了如何处理文件或输入数据并对其进行
    Rot13 编码。最后，我们看到了如何使用相同的代码将大量数据通过管道输入程序进行编码。此代码展示了 Go 在命令行应用程序中流式传输大量数据的能力。程序必须通过
    *Ctrl* + *C* 终止以中断从 `stdin` 的读取并退出程序。这为我们探索退出代码和最佳实践提供了完美的过渡，在我们探索中断之前，我们将更详细地探讨中断，我们将学习更多关于使用中断（如
    *Ctrl* + *C*）来终止程序的知识。
- en: Exit codes and command line best practices
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 退出代码和命令行最佳实践
- en: Ensuring proper exit codes and following best practices is essential for a seamless
    user experience. Exit codes provide a way for command-line applications to communicate
    their status to the calling application. A well-defined exit code system allows
    users and the other scripts to understand whether the application executed successfully
    or encountered an issue when running.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 确保适当的退出代码并遵循最佳实践对于无缝的用户体验至关重要。退出代码为命令行应用程序提供了一种向调用应用程序传达其状态的方式。一个定义良好的退出代码系统使用户和其他脚本能够理解应用程序是否成功执行或在运行时遇到了问题。
- en: In Go, the `os` package provides a straightforward way to set exit codes using
    the `ox.Exit` function. Conventionally, an exit code of 0 indicates success, while
    any non-zero code signals an error.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，`os` 包提供了一个使用 `os.Exit` 函数设置退出代码的直接方法。传统上，退出代码 0 表示成功，而任何非零代码表示错误。
- en: 'For example, you can check the status code of the previous exercise and verify
    the successful status code. To do this, run `echo $?` in the terminal. `$?` Is
    a special shell variable that holds the exit status of the last command that was
    executed, and the `echo` command prints it out. You’ll see the 0 exit code printout
    denoting a successful execution status, and no error. You can manually catch errors
    in the program and return non-zero code signals to denote errors. You can even
    create custom exit codes, such as the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以检查上一个练习的状态代码并验证成功状态代码。为此，请在终端中运行 `echo $?`。`$?` 是一个特殊的 shell 变量，它保存了最后执行命令的退出状态，而
    `echo` 命令将其打印出来。您将看到 0 退出代码的打印输出，表示成功执行状态，没有错误。您可以在程序中手动捕获错误并返回非零代码以表示错误。您甚至可以创建自定义退出代码，如下所示：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These can easily be used using `os.Exit`, by placing `os.Exit(ExitCodeSuccess)`
    in successful cases you want to exit, and by using one of the other error codes
    when you want to exit in certain circumstances.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以通过 `os.Exit` 容易地使用，通过在希望退出的成功情况下放置 `os.Exit(ExitCodeSuccess)`，并在特定情况下使用其他错误代码来退出。
- en: 'While using proper exit codes is an important command line best practice, there
    are a few others to keep in mind:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用适当的退出代码是重要的命令行最佳实践的同时，还有一些其他事项需要考虑：
- en: '**Consistent logging**: Use meaningful messages to aid troubleshooting.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致的日志记录**：使用有意义的消息来帮助故障排除。'
- en: '**Clear usage information**: Provide clear and concise usage information, including
    flags and arguments. Also, some packages allow you to provide example commands.
    Those should be used to let others see how to use the commands easily.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供清晰的用法信息**：提供清晰简洁的用法信息，包括标志和参数。此外，一些包允许您提供示例命令。应该使用这些命令让其他人轻松了解如何使用命令。'
- en: '**Handle help and versioning**: Implement flags to display help and version
    information. This is good for making your application more user-friendly and providing
    a means to ensure they are on the latest version by checking the version information.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理帮助和版本控制**：实现标志以显示帮助和版本信息。这有助于使您的应用程序更加用户友好，并提供一种确保他们使用最新版本的方法，通过检查版本信息。'
- en: '**Graceful termination**: Exit codes should be considered and terminated gracefully,
    ensuring proper cleanup tasks are performed as needed.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优雅终止**：应考虑退出代码并优雅地终止，确保按需执行适当的清理任务。'
- en: You are now well on your way when it comes to command-line application best
    practices and exit code considerations. However, there are times when end users
    will provide interrupts to cancel an application. Let’s learn what to do and consider
    when that happens.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您在命令行应用程序最佳实践和退出代码考虑方面已经取得了很好的进展。然而，有时最终用户会提供中断来取消应用程序。让我们学习在这种情况下应该做什么和考虑什么。
- en: Knowing when to stop by watching for interrupts
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过观察中断来了解何时停止
- en: When building robust applications, it’s crucial to handle interrupts gracefully,
    ensuring the software can respond appropriately to signals indicating it should
    stop or perform a specific action. In Go, the standard way to achieve this is
    by monitoring interrupt signals, allowing the application to shut down or clean
    up resources in an orderly manner.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建健壮的应用程序时，优雅地处理中断至关重要，确保软件能够适当地响应表示它应该停止或执行特定操作的信号。在Go中，实现这一点的标准方式是通过监控中断信号，允许应用程序以有序的方式关闭或清理资源。
- en: Graceful shutdown, or termination, is an important concept in computer science
    in general. Unforeseen events, server maintenance, or external factors might require
    your application to stop gracefully. This could involve releasing resources, saving
    state, or notifying connected clients. A graceful shutdown ensures your application
    remains reliable and predictable, minimizing the risk of data corruption or loss.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 优雅关闭或终止是计算机科学中一个重要的概念。不可预见的事件、服务器维护或外部因素可能需要您的应用程序优雅地停止。这可能包括释放资源、保存状态或通知已连接的客户端。优雅的关闭确保您的应用程序保持可靠和可预测，最大限度地减少数据损坏或丢失的风险。
- en: Abruptly terminating an application without proper cleanup can lead to various
    issues, such as incomplete transactions, resource leaks, corrupted data, and more.
    Graceful shutdowns mitigate these risks by providing an opportunity to finish
    ongoing tasks and release acquired resources.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有适当清理的情况下突然终止应用程序可能导致各种问题，如未完成的交易、资源泄露、数据损坏等。优雅的关闭通过提供完成正在进行中的任务和释放已获取资源的机会来减轻这些风险。
- en: The operating systems communicate with running processes through signals. A
    process is simply a program running on a computer. The `os/signal` package provides
    a convenient way to handle these signals within Go programs. There are common
    interrupt signals, such as `stdin` and exit the program.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统通过信号与运行中的进程进行通信。进程只是计算机上运行的程序。`os/signal` 包为在Go程序中方便地处理这些信号提供了方法。有常见的中断信号，如
    `stdin` 和退出程序。
- en: The `signal.Notify` function allows you to register channels to receive specified
    signals. This sets the foundation for creating a mechanism to gracefully shut
    down your application upon receiving an interrupt signal. There are also effective
    shutdown patterns and best practices to keep in mind, such as ensuring closed
    network connections, saving state, and signaling goroutines, to finish up their
    tasks before exiting. Additionally, using timeouts and the `context` package enhances
    your application’s responsiveness during shutdown, preventing it from getting
    stuck indefinitely.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`signal.Notify` 函数允许您注册通道以接收指定的信号。这为在接收到中断信号时优雅地关闭您的应用程序奠定了基础。还有一些有效的关闭模式和最佳实践需要牢记，例如确保关闭网络连接、保存状态和向goroutines发送信号，以便在退出前完成其任务。此外，使用超时和
    `context` 包增强了应用程序在关闭期间的响应性，防止其无限期地卡住。'
- en: Gracefully handling interrupt signals is a fundamental skill for building robust
    and reliable command-line applications in Go. By following best practices and
    patterns to ensure graceful termination, you can ensure that your software behaves
    predictably, even in the face of unexpected interruptions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 优雅地处理中断信号是构建健壮且可靠的Go命令行应用程序的基本技能。通过遵循最佳实践和模式以确保优雅的终止，你可以确保你的软件即使在面对意外中断的情况下也能表现出可预测的行为。
- en: Not only can you stop programs gracefully with different interrupts, but you
    can also start other commands from the command-line application.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以用不同的中断优雅地停止程序，还可以从命令行应用程序中启动其他命令。
- en: Starting other commands from your application
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从你的应用程序启动其他命令
- en: Launching external commands from your Go application opens opportunities for
    interaction with other programs, processes, and system utilities. The `os/exec`
    package in Go provides functionalities for starting and interacting with external
    processes. You can run basic commands, capture their output, and handle errors
    seamlessly with this package. It serves as a foundation for more advanced command
    execution scenarios.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从你的Go应用程序中启动外部命令为你打开了与其他程序、进程和系统工具交互的机会。Go中的`os/exec`包提供了启动和与外部进程交互的功能。你可以使用这个包运行基本命令，捕获它们的输出，并无缝地处理错误。它为更高级的命令执行场景提供了一个基础。
- en: For example, the `os/exec` package allows you to customize the execution of
    commands by configuring attributes such as the working directory, environment
    variables, and more. You can also provide inputs to the subcommand through standard
    input streams from the originating command-line application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`os/exec`包允许你通过配置工作目录、环境变量等属性来自定义命令的执行。你还可以通过来自原始命令行应用程序的标准输入流向子命令提供输入。
- en: By running other commands from within your command-line application, you can
    run some processes in the background, allowing the application to continue its
    execution while monitoring or interacting with parallel processes. You can even
    establish bidirectional communication with commands, enabling real-time interaction
    and data exchange between the command-line application and the external processes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在命令行应用程序中运行其他命令，你可以将一些进程放在后台运行，允许应用程序继续执行，同时监控或与并行进程交互。你甚至可以与命令建立双向通信，使命令行应用程序和外部进程之间实现实时交互和数据交换。
- en: When starting other applications, cross-platform considerations must be kept
    in mind. There are differences in shell behavior and command paths across different
    operating systems. So, when executing subcommands from a command-line application,
    it is important to keep a consistent and reliable command execution in mind, regardless
    of the compute an end user may be using. Thankfully, the `os/exec` package provides
    a cross-platform solution for executing external commands in Go, making it easier
    to write code across different operating systems.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动其他应用程序时，必须考虑到跨平台的问题。不同操作系统之间在shell行为和命令路径上存在差异。因此，当从命令行应用程序中执行子命令时，重要的是要考虑到无论最终用户使用哪种计算设备，都要保持一致和可靠的命令执行。幸运的是，`os/exec`包为Go中执行外部命令提供了一个跨平台解决方案，这使得在不同操作系统上编写代码变得更加容易。
- en: Now that we’ve discussed how useful it can be to execute other commands from
    a Go command-line application, let’s see an example in action.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了从Go命令行应用程序中执行其他命令的有用性，让我们看看一个实际操作的例子。
- en: Exercise 13.04 – creating a stopwatch with a time limit
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.04 – 创建有时间限制的秒表
- en: 'In this exercise, we will create a stopwatch with a time limit and start another
    command from the application:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个有时间限制的秒表，并从应用程序中启动另一个命令：
- en: 'Import the necessary packages:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的包：
- en: '[PRE21]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Within the main function, set the time limit for the stopwatch and allow user
    input to start the clock:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主函数中，设置秒表的计时限制，并允许用户输入来启动时钟：
- en: '[PRE22]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Sleep for the time limit, execute the other command from within the command-line
    application, and close the main function:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待时间限制，从命令行应用程序中执行其他命令，并关闭主函数：
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you run `go run main.go` and press Enter to start the timer when prompted,
    you will receive the following output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行`go run main.go`并在提示时按下Enter键来启动计时器，你将收到以下输出：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Executing external commands is a powerful capability that allows your Go applications
    to interact with the broader system environment. While this was a simple echo
    command, it shows how strong this capability is if you expand this code to start
    other applications, run commands in parallel or in the background, and more.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 执行外部命令是一种强大的功能，允许你的 Go 应用程序与更广泛的环境交互。虽然这是一个简单的 echo 命令，但它展示了如果你扩展此代码以启动其他应用程序、并行或后台运行命令等，这一功能有多强大。
- en: Terminal UIs
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终端用户界面
- en: 'Some of the latest updates to command-line programming with Go have included
    **terminal UIs**, or **TUIs** for short. Creating a TUI in Go opens a world of
    possibilities for building interactive command-line applications. There are a
    few fundamental concepts that are involved with building UIs for the terminal:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Go 命令行编程的最新更新中包括了一些**终端用户界面**，简称**TUI**。在 Go 中创建一个 TUI 打开了构建交互式命令行应用的新世界。构建终端用户界面的过程中涉及一些基本概念：
- en: '**Components**: TUIs are composed of various components, such as buttons, input
    fields, and/or lists'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**：TUI 由各种组件组成，如按钮、输入字段和/或列表'
- en: '**Layouts**: Arranging components in a structured layout is crucial for a clean
    and intuitive design'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局**：在结构化的布局中排列组件对于整洁直观的设计至关重要'
- en: '**User input handling**: Processing user input from keyboard events is fundamental
    to interactive interfaces'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户输入处理**：处理键盘事件中的用户输入是交互式界面的基本要素'
- en: Some TUI packages provide support for event handling, such as mouse events and
    key presses, dynamic updates based on input data, or customizing the appearance
    of UI components. There are several popular TUI packages available. We will look
    at one in the following exercise, where we’ll build on a previous exercise in
    this chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 TUI 包提供了对事件处理的支持，例如鼠标事件和按键，基于输入数据的动态更新，或自定义 UI 组件的外观。有几个流行的 TUI 包可用。在接下来的练习中，我们将查看其中一个，我们将在此基础上构建本章之前的练习。
- en: Exercise 13.05 – creating a wrapper for our Rot13 pipeline
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.05 – 为我们的 Rot13 管道创建包装器
- en: 'In this exercise, we will create a TUI wrapper for the Rot13 pipeline that
    we created in *Exercise 13.03*:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将为我们在 *练习 13.03* 中创建的 Rot13 管道创建一个 TUI 包装器。
- en: 'Import the necessary packages:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的包：
- en: '[PRE25]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Denote TUI choices and model specifics:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表示 TUI 选择和模型具体信息：
- en: '[PRE26]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Define the function to handle model updates:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义处理模型更新的函数：
- en: '[PRE27]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Define the TUI view:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 TUI 视图：
- en: '[PRE28]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Define the same Rot13 encoding function from earlier:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义与之前相同的 Rot13 编码函数：
- en: '[PRE29]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Define the function to read in data from `stdin` to apply Rot13 encoding to:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义从 `stdin` 读取数据以应用 Rot13 编码的函数：
- en: '[PRE30]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define the modified function to handle file input:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义处理文件输入的修改后的函数：
- en: '[PRE31]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Define the main function to start the TUI:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义启动 TUI 的主函数：
- en: '[PRE32]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You’ll receive the following output if you run `go run main.go` and select
    `File input`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `go run main.go` 并选择“文件输入”，你会收到以下输出：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You’ll receive the following output if you run `go run main.go` and select
    `Type` `in input`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `go run main.go` 并选择“类型”输入，你会收到以下输出：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding example expanded upon our previous exercise. Here, we provided
    a very simple wrapper for the entrance to the Rot13 coding exercise, providing
    a nice UI to input if you are going to use the default data file for input or
    provide your own input. This TUI was simple on purpose to demonstrate that quite
    a bit is involved when it comes to defining the model interface so that it can
    work with the terminal UI.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是在我们之前的练习基础上进行的扩展。在这里，我们提供了一个非常简单的包装器，用于 Rot13 编码练习的入口，提供了一个很好的用户界面，如果你打算使用默认的数据文件作为输入或提供自己的输入。这个
    TUI 故意设计得简单，以展示在定义模型接口以便它与终端用户界面一起工作时，涉及的内容相当多。
- en: Now, let’s see what it looks like to consume other people’s command-line applications
    using `go install`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看使用 `go install` 消费其他人的命令行应用的样子。
- en: go install
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: go install
- en: You can install Go command-line applications using the `go install` command.
    This command is a powerful tool that’s provided (among the many) by the Go toolchain
    to compile and install Go applications in your workspace’s bin directory. This
    allows you to run your applications globally from any terminal window. To install
    a Go application, you can simply navigate to the project’s root directory and
    run `go install`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `go install` 命令安装 Go 命令行应用。这个命令是 Go 工具链提供的一个强大工具，它可以在你的工作空间的 bin 目录中编译和安装
    Go 应用程序。这允许你从任何终端窗口全局运行你的应用程序。要安装一个 Go 应用程序，你只需导航到项目的根目录并运行 `go install`。
- en: This command considers cross-platform compilation by providing the `GOOS` flag,
    where you can specify which operating system to target, as well as the `GOARCH`
    flag, where you can specify the underlying architecture to target.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令通过提供 `GOOS` 标志来考虑跨平台编译，您可以使用该标志指定要针对哪个操作系统，以及 `GOARCH` 标志，您可以使用该标志指定要针对的底层架构。
- en: 'An example of a common Go package that you can use to generate command-line
    interfaces in Go is the `cobra` package. This is also a tool you can use to bootstrap
    application scaffolding to rapidly develop Cobra-based applications if you would
    like to dive further into developing your programming in terms of command-line
    skills. This package provides a simple example of using the `go` `install` command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的 Go 语言包示例，您可以使用它来生成 Go 语言的命令行界面，是 `cobra` 包。这也是一个工具，如果您想进一步深入开发您的编程技能，可以使用它来快速开发基于
    Cobra 的应用程序。此包提供了一个使用 `go install` 命令的简单示例：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding command installs all of the dependencies to use the Cobra CLI.
    As a result, my machine knows about the tool, and you can easily work with the
    command-line program that you just installed, as shown here:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令安装了所有使用 Cobra CLI 所需的依赖项。因此，我的机器知道了这个工具，您现在可以轻松地使用您刚刚安装的命令行程序，如下所示：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Cobra is a CLI library for Go that empowers applications.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Cobra 是一个用于 Go 语言的 CLI 库，它赋予了应用程序强大的功能。
- en: 'It can generate the necessary files to quickly create a Cobra application:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以生成必要的文件，以快速创建 Cobra 应用程序：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With that, you know how to install someone else’s command-line application.
    Now, let’s summarize what we learned in this chapter.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，您就知道了如何安装他人的命令行应用程序。现在，让我们总结一下本章所学的内容。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we studied various methodologies of programming via the command
    line. We uncovered how Go is an excellent choice for creating command-line applications
    with ease, as well as how to use the native Go toolchain.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了通过命令行进行编程的各种方法。我们揭示了 Go 语言如何成为创建命令行应用程序的绝佳选择，以及如何使用原生 Go 工具链。
- en: Starting with the `os` and `flag` packages, we looked at how to read arguments
    from the command line for our application. Then, we looked at flags to control
    the behavior of our program and looked at how streaming large amounts of data
    in and out of an application can shed light on how command-line applications in
    Go can be part of a bigger programmatic pipeline.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `os` 和 `flag` 包开始，我们探讨了如何从命令行读取应用程序的参数。然后，我们研究了用于控制程序行为的标志，并探讨了如何通过在应用程序中流式传输大量数据来阐明
    Go 语言中的命令行应用程序如何成为更大程序管道的一部分。
- en: We also took a peak at handling the CLI shutdown process gracefully by discussing
    exit codes and interrupts, as well as invoking other commands from within our
    command-line application. We ended this chapter by looking at terminal UIs, taking
    our CLI to the next level, and installing other CLIs using the native Go toolchain.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如何优雅地处理 CLI 关闭过程，包括讨论退出码和中断，以及在我们的命令行应用程序中调用其他命令。我们通过查看终端 UI，将 CLI 提升到下一个层次，并使用原生
    Go 工具链安装其他 CLI 来结束这一章。
- en: In the next chapter, we will look at files and systems using Go. While we did
    touch on that in this chapter so that we could read input data for our CLI application,
    we will do a deep dive into reading and writing files next.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 Go 语言查看文件和系统。虽然我们在本章中已经涉及了这一点，以便为我们的 CLI 应用程序读取输入数据，但我们将在下一章深入探讨读取和写入文件。
