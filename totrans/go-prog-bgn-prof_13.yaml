- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming from the Command Line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at programming from the command line. We will
    see how Go is an excellent choice for creating powerful command-line utilities
    and applications, as well as discuss the many tools available for working with
    the command line using Go.
  prefs: []
  type: TYPE_NORMAL
- en: By reading this chapter, you will acquaint yourself with developing powerful
    command-line utilities and applications in Go. We will start with the basics of
    reading in command-line arguments and employing those flag values to control application
    behavior, take a peek at dealing with larger amounts of data inside and outside
    the application, and evaluate exit codes and best practices along the way. Then,
    we will dive a bit deeper and discuss strategies for gracefully handling interrupts,
    initiating external commands from our application, and using `go install`. Finally,
    we will learn how to create **terminal user interfaces** (**TUIs**), which allow
    us to craft robust, user-friendly command-line tools in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you’ll require Go version 1.21 or higher. The code for this
    chapter can be found at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter13](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how Go provides powerful constructs when
    dealing with time data. We will be shifting gears a bit in this chapter to discuss
    one of the many ways that Go is beneficial in creating a powerful interface for
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: UIs don’t always have to be a web application frontend web page. End users can
    interact with software through engaging command-line interfaces, as well as by
    using a **command-line** **interface** (**CLI**).
  prefs: []
  type: TYPE_NORMAL
- en: Go provides many packages that allow us to program for the command line. We’ll
    look at some of these packages, see where Go is at in terms of creating powerful
    command-line utilities, and learn about some of the current efforts in this space.
  prefs: []
  type: TYPE_NORMAL
- en: Reading arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command-line arguments are a fundamental aspect of building versatile and interactive
    command-line applications. Reading arguments allow developers to make their applications
    more dynamic and adaptable to user input. Command-line arguments serve as a means
    for users to customize the behavior of a program without modifying its source
    code. By capturing input parameters from the command line, developers can create
    versatile applications that cater to different use cases and scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, the `os` package serves as a straightforward way to access these arguments.
    The `os.Args` slice provides a convenient way to access command-line arguments.
    This allows developers to retrieve information such as file paths, configuration
    parameters, or any other input relevant to the application’s functionality. The
    ability to read command-line arguments enhances the user experience by making
    applications more interactive and user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, command-line arguments enable automation and scripting, allowing users
    to pass inputs programmatically. This flexibility is particularly valuable in
    scenarios where the same program needs to be executed with different parameters,
    making it a powerful tool for scripting and automation tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into the process of reading command-line arguments and illustrate
    this with a simple example that greets users with a personalized message.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 13.01 – saying hello using a name passed as an argument
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will print a `hello` statement using arguments that have
    been passed in from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `fmt` and `os` packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Utilize the `args` slice mentioned previously to capture the command-line arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform validation on the number of arguments supplied, excluding the executable
    name provided:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extract the name from the arguments supplied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Display a personalized greeting message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to execute the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With that, we have demonstrated the basics of capturing a command-line argument
    using Go, and seen some of the benefits of capturing input data in an easy way
    for our program. While we used the `os` package in this example, other packages
    can assist in achieving the same goal of reading the input provided to the application,
    such as using the `flags` package. Let’s look at how useful flags can be in programming
    for the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Using flags to control behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `flags` package provides a higher-level and more structured approach to
    reading arguments compared to directly using the `os` package. Flags simplify
    the process of parsing and handling command-line input, making it easier for developers
    to create robust and user-friendly command-line applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flags` package allows you to define flags with associated types and default
    values, making it clear what kind of input a user is expected to provide. It also
    automatically generates help messages, making your program more self-documenting.
    Here’s a brief overview of how the `flags` package can help in reading and handling
    command-line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Define flags**: You can define flags, along with their types and default
    values. This provides a clear and structured way to specify expected inputs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parse flags**: After defining flags, you can parse the command-line arguments.
    This initializes flag variables with the values provided by a user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access flag values**: Once you have parsed the flag values that have been
    passed in, you can access the defined flags through variables and continue to
    work with them throughout the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flags allow you to customize the behavior of your program without the need to
    modify the source code. For example, you can create flags that allow you to toggle
    behavior based on if a flag value is set. You can also use basic conditional logic
    pending the values set for certain flags. Let’s complete an exercise and utilize
    the `flags` package to say hello.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 13.02 – using flags to say hello conditionally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will print a `hello` statement using the `flags` package:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `fmt` and `os` packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create our flags for the utility and set the default values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the output you’ll receive if you run `go run main.go`. This is because
    `quietFlag` defaults to `false` and `nameFlag` defaults to `Sam`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you can set values for the flags. For this, you can use `nameFlag`
    and set the `quietFlag` value. The output of running `go run main.go --name=Cassie
    –-quiet=false` is listed here. This is because `quietFlag` is set to false and
    `nameFlag` is set to Sam:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you will get no output if you use `quietFlag` with a value of
    `true`. So, if you run `go run main.go --quiet=true`, then you’ll see no output
    as we have just used flags to control the expected output behavior of our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code demonstrated how you can use flags to control the behavior of a program.
    If you are working with someone else’s command-line interface, then you can seamlessly
    use the `help` flag to list the defined flags available. The `flag` package in
    Go automatically generates a help message based on the flags in the program. To
    see the available help message for the preceding code, you can run `go run main.go
    --help`. That will provide the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By utilizing the `flags` package, you enhance the readability and maintainability
    of your code, as well as provide a more user-friendly experience. It simplifies
    the process of handling various types of input and automates the generation of
    usage information, making it easier for users to understand and interact with
    your command-line application. Now, let’s see what it looks like to stream data
    in and out of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming large amounts of data in and out of your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In command-line applications, it is crucial to handle large amounts of data
    efficiently for performance and responsiveness purposes. Often, command-line applications
    may be a small part of a larger pipeline processing data. Most people are not
    going to want to sit around typing out a large amount of data, such as a dataset,
    piece by piece.
  prefs: []
  type: TYPE_NORMAL
- en: Go allows you to stream data to your applications so that you can process information
    in chunks, rather than all at once. This allows you to effectively process large
    amounts of data, reduce memory overhead, and provide better scalability in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: 'When dealing with large amounts of data, it’s often stored in files. This can
    range from financial CSV files, analysis Excel files, or machine learning datasets.
    There are a few main benefits of streaming data with Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory efficiency**: The program can read and process data line by line,
    reducing memory consumption, as you then don’t have to read the entire data into
    memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time analysis**: Users can observe a real-time analysis of the results
    of processing their data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interactive interface**: You can enhance the command-line interface so that
    it accepts dynamic information or displays additional details when processing
    large amounts of data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data confidentiality might be top of mind, depending on the type of data you
    may be streaming to your command-line application. For this reason, different
    encoding mechanisms may be employed to hide text without providing real security
    on the data, or as a first step toward securing the data.
  prefs: []
  type: TYPE_NORMAL
- en: '*Rot13*, or rotate by 13 places, is a simple letter substitution cipher that
    replaces a letter with the 13th letter after it in the alphabet. For example,
    the letter A would become N, and B would become C, and so forth. It is a symmetric
    key algorithm that is often used as a trivial form of encryption to obscure text.
    This algorithm provides no significant security and is mainly used for fun, typically
    never used in a production-level environment to secure data. It is also fully
    self-reversible, meaning that applying Rot13 twice would result in the same originating
    data. This can be useful for sending and receiving text in environments where
    the receiving end may or may not know if the data has been encoded.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s expand our new Rot13 knowledge so that we can work on a fun streaming
    data example for a command-line application.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 13.03 – using pipes, stdin, and stdout to apply a Rot13 encoding to
    a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will work with the Rot13 encoding for some input data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the required packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `rot13` function to apply Rot13 encoding to a given string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the function to read data from `stdin`, apply the Rot13 encoding, and
    write the output to `stdout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the function to process file or user input, apply the Rot13 encoding,
    and write the output to `stdout`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the main function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run `go run main.go` and enter some text when prompted, you’ll receive
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To exit the program, you can type Ctrl + C. Also, the program can be used in
    a pipeline, where the output of one command becomes the input of the command-line
    application if you use `cat data.txt` | `go run main.go`. `cat` is a command that
    you can use to concatenate files together (For Windows, the `type` command is
    used for concatenation). In the event you use it on a single file, then it gives
    you an easy way of printing out the contents of the file. If you declare a `data.txt`
    file and pipe the contents of the file to the command-line application with the
    following command, then you will see a similar output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the resulting output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding exercise demonstrated a few things. First, we saw how we could
    process `stdin` data line by line using `bufio.NewReader` until an end-of-file
    error is encountered. We also saw how to process files or input data and Rot13
    encode it. Lastly, we saw how we could use the same code and pipe large amounts
    of data into the program to encode it. This code demonstrated Go’s capabilities
    to stream large data in and out of a command-line application. The program had
    to be *Ctrl* + *C* terminated to interrupt the reading from `stdin` and exit the
    program. That’s a perfect segway into exploring exit codes and best practices
    in more detail before we explore interrupts, where we’ll learn more about terminating
    programs using interrupts such as *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: Exit codes and command line best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensuring proper exit codes and following best practices is essential for a seamless
    user experience. Exit codes provide a way for command-line applications to communicate
    their status to the calling application. A well-defined exit code system allows
    users and the other scripts to understand whether the application executed successfully
    or encountered an issue when running.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, the `os` package provides a straightforward way to set exit codes using
    the `ox.Exit` function. Conventionally, an exit code of 0 indicates success, while
    any non-zero code signals an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can check the status code of the previous exercise and verify
    the successful status code. To do this, run `echo $?` in the terminal. `$?` Is
    a special shell variable that holds the exit status of the last command that was
    executed, and the `echo` command prints it out. You’ll see the 0 exit code printout
    denoting a successful execution status, and no error. You can manually catch errors
    in the program and return non-zero code signals to denote errors. You can even
    create custom exit codes, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These can easily be used using `os.Exit`, by placing `os.Exit(ExitCodeSuccess)`
    in successful cases you want to exit, and by using one of the other error codes
    when you want to exit in certain circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'While using proper exit codes is an important command line best practice, there
    are a few others to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consistent logging**: Use meaningful messages to aid troubleshooting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clear usage information**: Provide clear and concise usage information, including
    flags and arguments. Also, some packages allow you to provide example commands.
    Those should be used to let others see how to use the commands easily.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handle help and versioning**: Implement flags to display help and version
    information. This is good for making your application more user-friendly and providing
    a means to ensure they are on the latest version by checking the version information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graceful termination**: Exit codes should be considered and terminated gracefully,
    ensuring proper cleanup tasks are performed as needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are now well on your way when it comes to command-line application best
    practices and exit code considerations. However, there are times when end users
    will provide interrupts to cancel an application. Let’s learn what to do and consider
    when that happens.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing when to stop by watching for interrupts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building robust applications, it’s crucial to handle interrupts gracefully,
    ensuring the software can respond appropriately to signals indicating it should
    stop or perform a specific action. In Go, the standard way to achieve this is
    by monitoring interrupt signals, allowing the application to shut down or clean
    up resources in an orderly manner.
  prefs: []
  type: TYPE_NORMAL
- en: Graceful shutdown, or termination, is an important concept in computer science
    in general. Unforeseen events, server maintenance, or external factors might require
    your application to stop gracefully. This could involve releasing resources, saving
    state, or notifying connected clients. A graceful shutdown ensures your application
    remains reliable and predictable, minimizing the risk of data corruption or loss.
  prefs: []
  type: TYPE_NORMAL
- en: Abruptly terminating an application without proper cleanup can lead to various
    issues, such as incomplete transactions, resource leaks, corrupted data, and more.
    Graceful shutdowns mitigate these risks by providing an opportunity to finish
    ongoing tasks and release acquired resources.
  prefs: []
  type: TYPE_NORMAL
- en: The operating systems communicate with running processes through signals. A
    process is simply a program running on a computer. The `os/signal` package provides
    a convenient way to handle these signals within Go programs. There are common
    interrupt signals, such as `stdin` and exit the program.
  prefs: []
  type: TYPE_NORMAL
- en: The `signal.Notify` function allows you to register channels to receive specified
    signals. This sets the foundation for creating a mechanism to gracefully shut
    down your application upon receiving an interrupt signal. There are also effective
    shutdown patterns and best practices to keep in mind, such as ensuring closed
    network connections, saving state, and signaling goroutines, to finish up their
    tasks before exiting. Additionally, using timeouts and the `context` package enhances
    your application’s responsiveness during shutdown, preventing it from getting
    stuck indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: Gracefully handling interrupt signals is a fundamental skill for building robust
    and reliable command-line applications in Go. By following best practices and
    patterns to ensure graceful termination, you can ensure that your software behaves
    predictably, even in the face of unexpected interruptions.
  prefs: []
  type: TYPE_NORMAL
- en: Not only can you stop programs gracefully with different interrupts, but you
    can also start other commands from the command-line application.
  prefs: []
  type: TYPE_NORMAL
- en: Starting other commands from your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Launching external commands from your Go application opens opportunities for
    interaction with other programs, processes, and system utilities. The `os/exec`
    package in Go provides functionalities for starting and interacting with external
    processes. You can run basic commands, capture their output, and handle errors
    seamlessly with this package. It serves as a foundation for more advanced command
    execution scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `os/exec` package allows you to customize the execution of
    commands by configuring attributes such as the working directory, environment
    variables, and more. You can also provide inputs to the subcommand through standard
    input streams from the originating command-line application.
  prefs: []
  type: TYPE_NORMAL
- en: By running other commands from within your command-line application, you can
    run some processes in the background, allowing the application to continue its
    execution while monitoring or interacting with parallel processes. You can even
    establish bidirectional communication with commands, enabling real-time interaction
    and data exchange between the command-line application and the external processes.
  prefs: []
  type: TYPE_NORMAL
- en: When starting other applications, cross-platform considerations must be kept
    in mind. There are differences in shell behavior and command paths across different
    operating systems. So, when executing subcommands from a command-line application,
    it is important to keep a consistent and reliable command execution in mind, regardless
    of the compute an end user may be using. Thankfully, the `os/exec` package provides
    a cross-platform solution for executing external commands in Go, making it easier
    to write code across different operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve discussed how useful it can be to execute other commands from
    a Go command-line application, let’s see an example in action.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 13.04 – creating a stopwatch with a time limit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a stopwatch with a time limit and start another
    command from the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the main function, set the time limit for the stopwatch and allow user
    input to start the clock:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Sleep for the time limit, execute the other command from within the command-line
    application, and close the main function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run `go run main.go` and press Enter to start the timer when prompted,
    you will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Executing external commands is a powerful capability that allows your Go applications
    to interact with the broader system environment. While this was a simple echo
    command, it shows how strong this capability is if you expand this code to start
    other applications, run commands in parallel or in the background, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Terminal UIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the latest updates to command-line programming with Go have included
    **terminal UIs**, or **TUIs** for short. Creating a TUI in Go opens a world of
    possibilities for building interactive command-line applications. There are a
    few fundamental concepts that are involved with building UIs for the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Components**: TUIs are composed of various components, such as buttons, input
    fields, and/or lists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layouts**: Arranging components in a structured layout is crucial for a clean
    and intuitive design'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User input handling**: Processing user input from keyboard events is fundamental
    to interactive interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some TUI packages provide support for event handling, such as mouse events and
    key presses, dynamic updates based on input data, or customizing the appearance
    of UI components. There are several popular TUI packages available. We will look
    at one in the following exercise, where we’ll build on a previous exercise in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 13.05 – creating a wrapper for our Rot13 pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a TUI wrapper for the Rot13 pipeline that
    we created in *Exercise 13.03*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Denote TUI choices and model specifics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the function to handle model updates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the TUI view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the same Rot13 encoding function from earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the function to read in data from `stdin` to apply Rot13 encoding to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the modified function to handle file input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the main function to start the TUI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll receive the following output if you run `go run main.go` and select
    `File input`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll receive the following output if you run `go run main.go` and select
    `Type` `in input`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example expanded upon our previous exercise. Here, we provided
    a very simple wrapper for the entrance to the Rot13 coding exercise, providing
    a nice UI to input if you are going to use the default data file for input or
    provide your own input. This TUI was simple on purpose to demonstrate that quite
    a bit is involved when it comes to defining the model interface so that it can
    work with the terminal UI.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see what it looks like to consume other people’s command-line applications
    using `go install`.
  prefs: []
  type: TYPE_NORMAL
- en: go install
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can install Go command-line applications using the `go install` command.
    This command is a powerful tool that’s provided (among the many) by the Go toolchain
    to compile and install Go applications in your workspace’s bin directory. This
    allows you to run your applications globally from any terminal window. To install
    a Go application, you can simply navigate to the project’s root directory and
    run `go install`.
  prefs: []
  type: TYPE_NORMAL
- en: This command considers cross-platform compilation by providing the `GOOS` flag,
    where you can specify which operating system to target, as well as the `GOARCH`
    flag, where you can specify the underlying architecture to target.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a common Go package that you can use to generate command-line
    interfaces in Go is the `cobra` package. This is also a tool you can use to bootstrap
    application scaffolding to rapidly develop Cobra-based applications if you would
    like to dive further into developing your programming in terms of command-line
    skills. This package provides a simple example of using the `go` `install` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command installs all of the dependencies to use the Cobra CLI.
    As a result, my machine knows about the tool, and you can easily work with the
    command-line program that you just installed, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Cobra is a CLI library for Go that empowers applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can generate the necessary files to quickly create a Cobra application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: With that, you know how to install someone else’s command-line application.
    Now, let’s summarize what we learned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied various methodologies of programming via the command
    line. We uncovered how Go is an excellent choice for creating command-line applications
    with ease, as well as how to use the native Go toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the `os` and `flag` packages, we looked at how to read arguments
    from the command line for our application. Then, we looked at flags to control
    the behavior of our program and looked at how streaming large amounts of data
    in and out of an application can shed light on how command-line applications in
    Go can be part of a bigger programmatic pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: We also took a peak at handling the CLI shutdown process gracefully by discussing
    exit codes and interrupts, as well as invoking other commands from within our
    command-line application. We ended this chapter by looking at terminal UIs, taking
    our CLI to the next level, and installing other CLIs using the native Go toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at files and systems using Go. While we did
    touch on that in this chapter so that we could read input data for our CLI application,
    we will do a deep dive into reading and writing files next.
  prefs: []
  type: TYPE_NORMAL
