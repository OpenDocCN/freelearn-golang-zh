<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer160">
			<h1 id="_idParaDest-364" class="chapter-number"><a id="_idTextAnchor1623"/>14</h1>
			<h1 id="_idParaDest-365"><a id="_idTextAnchor1624"/>File and Systems</h1>
			<p class="callout-heading">Overview</p>
			<p class="callout">We will see in this chapter how to interact with the filesystem, which means we will read files, manipulate them, store them for later use, and get information about them. We will also cover how to read folders so that we can search for the files we need, and will examine some specific file formats such as CSV, which is commonly used to share information in <span class="No-Break">tabular form.</span></p>
			<p class="callout">Another thing you will learn in this chapter is how to send some information to your application in the form <span class="No-Break">of flags.</span></p>
			<h1 id="_idParaDest-366"><a id="_idTextAnchor1625"/>Technical requirements</h1>
			<p>For this chapter, you'll require Go version 1.21 or higher. The code for this chapter can be found at: <a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter14"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter14</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-367"><a id="_idTextAnchor1626"/>Introduction</h1>
			<p>In the previous chapter, we looked at how to write simple command-line applications. We will carry on with this here, introducing ways to pass parameters to our application so that it behaves differently depending on the values <span class="No-Break">we send.</span></p>
			<p>After that, we will interact <a id="_idIndexMarker886"/>with the filesystem. The levels we are going to be working with the filesystem at are the file, directory, and permission levels. We will tackle everyday issues that developers face when working with <span class="No-Break">the filesystem.</span></p>
			<p>We will learn how to create a command-line application that will read and write files. Along with discussing what happens when we get a signal interrupt from the OS, we will demonstrate how to perform cleanup actions before our application stops running. We will also handle a scenario of receiving an interrupt to our application and handling how the application exits. There are times when your application is running, and a signal comes from the OS to shut down <span class="No-Break">the application.</span></p>
			<p>In such instances, we may want to log information at the time of the shutdown for debugging purposes; this will help us to understand why the application shuts down. We will look at how we can do that in this chapter. However, before we start tackling these issues, let’s get a basic understanding of <span class="No-Break">the filesystem.</span><a id="_idTextAnchor1627"/></p>
			<h1 id="_idParaDest-368"><a id="_idTextAnchor1628"/>Filesystem</h1>
			<p>A filesystem controls how data<a id="_idIndexMarker887"/> is named, stored, accessed, and retrieved on a device such as a hard drive, USB, DVD, or another medium. There is no one filesystem, and how it behaves largely depends on what OS you are using. You must have heard of <strong class="source-inline">FAT</strong>, <strong class="source-inline">FAT32</strong>, <strong class="source-inline">NFTS</strong>, and so on, which are all different filesystems and are used normally by Windows. Linux can read and write to them, but it generally uses a different family of filesystems that have names starting with <strong class="source-inline">ext</strong>, which stands for <em class="italic">extended</em>. You do not need to have a deep understanding of filesystems, but, as a software engineer, it is good to at least have a basic understanding of <span class="No-Break">the subject.</span></p>
			<p>What interests us in this chapter, however, is that each filesystem has its conventions for naming files, such as the length of the filename, the specific characters that can be used, how long the suffix or file extension can be, and so on. Each file has information or metadata, data embedded within a file or associated with it that describes or provides information about the file. This metadata about a file can contain information such as file size, location, access permissions, date created, date modified, and more. This is all the information that can be accessed by <span class="No-Break">our applications.</span></p>
			<p>Files are generally placed in some sort of hierarchal structure. This structure typically consists of multiple directories and sub-directories. The placement of the files within the directories is a way to organize your data and get access to the file <span class="No-Break">or directory:</span></p>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/B18621_14_01.jpg" alt="Figure 14.1 – The Linux filesystem" width="1650" height="488"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – The Linux filesystem</p>
			<p>As shown in <span class="No-Break"><em class="italic">Figure 14</em></span><em class="italic">.1</em>, directories can be<a id="_idIndexMarker888"/> nested. In a normal Linux filesystem, we will see that there is a root<a id="_idIndexMarker889"/> directory, which is defined by the name <strong class="bold">/</strong>, and everything else is a subdirectory of it. The <strong class="bold">home</strong> directory generally holds data for each user of the system, and in the case shown above, <strong class="bold">matt</strong> is a directory holding a <strong class="bold">docs</strong> and an <strong class="bold">mp3</strong> directory, which are subdirectories of <strong class="bold">matt</strong>, but <strong class="bold">matt</strong> itself is a subdirectory <span class="No-Break">of </span><span class="No-Break"><strong class="bold">home</strong></span><span class="No-Break">.</span></p>
			<p>In the next topic, we will be looking at <span class="No-Break">file permission<a id="_idTextAnchor1629"/>s.</span></p>
			<h2 id="_idParaDest-369"><a id="_idTextAnchor1630"/>File permissions</h2>
			<p>Permissions are an important<a id="_idIndexMarker890"/> aspect that you need to understand when dealing with file creation <span class="No-Break">and modifications.</span></p>
			<p>We need to look at various permission types that can be assigned to a file. We also need to consider how those permission types are represented in symbolic and <span class="No-Break">octal notation.</span></p>
			<p>Go uses the Unix nomenclature to represent permission types. They are represented in symbolic notation or octal notation. The three permission types are <em class="italic">Read</em>, <em class="italic">Write</em>, <span class="No-Break">and </span><span class="No-Break"><em class="italic">Execute</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer151" class="IMG---Figure">
					<img src="image/B18621_14_02.jpg" alt="Figure 14.2 – File permissions" width="763" height="896"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – File permissions</p>
			<p>Permissions for every file are assigned to three different entities that can be individuals or groups. This means that a user can be part of a group that has access to some files, as a result of which the user inherits access to those files. It is not possible to assign permissions for a file to a specific<a id="_idIndexMarker891"/> user; rather, we add the user to a group and then assign permissions to that group. That said, it is possible to assign permission for a file to <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Owner</strong>: This is an individual, a single<a id="_idIndexMarker892"/> person such as John Smith, or the root user who is the owner of the file. In general, it is the individual who created <span class="No-Break">the file.</span></li>
				<li><strong class="bold">Group</strong>: A group typically consists<a id="_idIndexMarker893"/> of multiple individuals or <span class="No-Break">other groups.</span></li>
				<li><strong class="bold">Others</strong>: Those that are not in a group<a id="_idIndexMarker894"/> or <span class="No-Break">the owner.</span></li>
			</ul>
			<p>Let’s see now, how permissions are indicated via symbolic notation. The following diagram is an example of a file and its permissions<a id="_idIndexMarker895"/> on a <span class="No-Break">Unix machine:</span></p>
			<div>
				<div id="_idContainer152" class="IMG---Figure">
					<img src="image/B18621_14_03.jpg" alt="Figure 14.3 – Permissions notation" width="937" height="361"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – Permissions notation</p>
			<p>The first dash (<strong class="source-inline">-</strong>) in the figure above means that the entity is a file. If it was a directory, it would have been the character <span class="No-Break"><strong class="source-inline">d</strong></span><span class="No-Break"> instead.</span></p>
			<p>Another way to specify the permissions is the octal notation, which expresses multiple permissions types with a single number. For example, if you want to indicate read and write permissions using symbolic notation, it would be <strong class="source-inline">rw-</strong>. If this was to be represented as an octal number, it would be <strong class="source-inline">6</strong>, because <strong class="source-inline">4</strong> means read permission and <strong class="source-inline">2</strong> means write permission. Full permission would be <strong class="source-inline">7</strong>, which means <em class="italic">4+2+1</em> or <span class="No-Break"><em class="italic">read+write+execute</em></span><span class="No-Break"> (</span><span class="No-Break"><strong class="source-inline">rwx</strong></span><span class="No-Break">).</span></p>
			<p>The following recaps the permissions<a id="_idIndexMarker896"/> and <span class="No-Break">their explanations:</span></p>
			<div>
				<div id="_idContainer153" class="IMG---Figure">
					<img src="image/B18621_14_04.jpg" alt="Figure 14.4 – Groups and permission examples" width="1650" height="602"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – Groups and permission examples</p>
			<p>As you can see, each permission can be expressed with a number <strong class="source-inline">&lt;=7</strong>, which is in one digit. Permissions for owner, group, and others can then be expressed in octal notation with three digits, as we can see in <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer154" class="IMG---Figure">
					<img src="image/B18621_14_05.jpg" alt="Figure 14.5 – Permission representations examples" width="1243" height="763"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.5 – Permission representations examples</p>
			<p>You might notice that in octal representation<a id="_idIndexMarker897"/> all numbers start with a <em class="italic">0</em>. When working with the filesystem via the command line you can omit the leading zero. However, in many cases, when programming, you need to pass it so that the compiler will understand that you are writing something in octal notation. You might argue that <strong class="source-inline">0777</strong> and <strong class="source-inline">777</strong> are the same number, but the leading zero is just a <em class="italic">convention</em> that tells the compiler that you are using an octal notation and the number is octal and not decimal. In other words, <strong class="source-inline">777</strong> is interpreted as the decimal<a id="_idIndexMarker898"/> number <strong class="source-inline">777</strong>, while <strong class="source-inline">0777</strong> is interpreted as the octal number <strong class="source-inline">0777</strong>, which is the decimal <span class="No-Break">numb<a id="_idTextAnchor1631"/>er </span><span class="No-Break"><strong class="source-inline">511</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-370"><a id="_idTextAnchor1632"/>Flags and arguments</h1>
			<p>Go provides support for creating<a id="_idIndexMarker899"/> command-line interface tools. Often, when we write Go programs that are executables, they need to accept various inputs. These inputs could include the location of a file, a value to run the program in the debug state, getting help to run the program and more. All of this is made possible by a package in the Go standard library called <strong class="source-inline">flag</strong>. It is used to allow the passing of arguments to the program. A flag is an argument that is passed to a Go program. The order of the flags being passed to the Go program using the <strong class="source-inline">flag</strong> package does not matter <span class="No-Break">to Go.</span></p>
			<p>To define your <strong class="source-inline">flag</strong>, you must know the <strong class="source-inline">flag</strong> type you will be accepting. The <strong class="source-inline">flag</strong> package provides many functions for defining flags. Here is a <span class="No-Break">sample list:</span></p>
			<pre class="source-code">
func Bool(name string, value bool, usage string) *bool
func Duration(name string, value time.Duration, usage string) *time.Duration
func Float64(name string, value float64, usage string) *float64
func Int(name string, value int, usage string) *int
func Int64(name string, value int64, usage string) *int64</pre>			<p>These are some of the functions<a id="_idIndexMarker900"/> allowing you to create flags and accept parameters, and there is one for each default type <span class="No-Break">in Go.</span></p>
			<p>The parameters of the preceding functions can be explained <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">name</strong>: This parameter is the name of the flag; it is a string type. For example, if you pass <em class="italic">file</em> as an argument, you would access that flag from the command line with <span class="No-Break">the following:</span><pre class="source-code">
./app -file</pre></li>				<li><strong class="bold">value</strong>: This parameter is the default value that the flag is <span class="No-Break">set to.</span></li>
				<li><strong class="bold">usage</strong>: This parameter is used to describe the flag’s purpose. It will often show up on the command line when you incorrectly set the value. Passing the wrong type for a flag will stop the program and cause an error; the usage will <span class="No-Break">be printed.</span></li>
				<li><strong class="bold">return value</strong>: This is the address of the variable that stores the value of <span class="No-Break">the flag.</span></li>
			</ul>
			<p>Let’s take a look at a <span class="No-Break">simple example:</span></p>
			<pre class="source-code">
package main
import (
    "flag"
    "fmt"
)
func main() {
    v := flag.Int("value", -1, "Needs a value for the flag.")
    flag.Parse()
    fmt.Println(*v)
}</pre>			<p>Let’s go over <a id="_idIndexMarker901"/>the preceding code<a id="_idIndexMarker902"/> block and <span class="No-Break">analyze it:</span></p>
			<ol>
				<li>First, we define the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> package.</span></li>
				<li>Then we import the <strong class="source-inline">flag</strong> and <span class="No-Break"><strong class="source-inline">fmt</strong></span><span class="No-Break"> packages.</span></li>
				<li>The <strong class="source-inline">v</strong> variable will reference the value for either <strong class="source-inline">-value</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">--value</strong></span><span class="No-Break">.</span></li>
				<li>The initial value of <strong class="source-inline">*v</strong> is the default value of <strong class="source-inline">-1</strong> before <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">flag.Parse()</strong></span></li>
				<li>After defining the flags, you must call <strong class="source-inline">flag.Parse()</strong> to parse the defined flags into the <span class="No-Break">command line.</span></li>
				<li>Calling <strong class="source-inline">flag.Parse()</strong> places the argument for <strong class="source-inline">-value</strong> <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">*v</strong></span><span class="No-Break">.</span></li>
				<li>Once you have called the <strong class="source-inline">flag.Parse()</strong> function, the flags will <span class="No-Break">be available.</span></li>
				<li>On the command line, execute the following command and you will get the executable in the <span class="No-Break">same </span><span class="No-Break">directory:</span><pre class="source-code">
go build -o flagapp main.go</pre></li>			</ol>
			<p>To get the executable on <span class="No-Break">Windows, run:</span></p>
			<p><strong class="source-inline">go build -o </strong><span class="No-Break"><strong class="source-inline">flagapp.exe main.go</strong></span></p>
			<p>There is another way, however, to define these flags. It can be done using the <span class="No-Break">following functions:</span></p>
			<pre class="source-code">
func BoolVar(p *bool, name string, value bool, usage string)
func DurationVar(p *time.Duration, name string, value time.Duration, usage string)
func Float64Var(p *float64, name string, value float64, usage string)
func Int64Var(p *int64, name string, value int64, usage string)
func IntVar(p *int, name string, value int, usage string)</pre>			<p>As you can see, for each type, there<a id="_idIndexMarker903"/> is a function similar<a id="_idIndexMarker904"/> to those we’ve already seen, whose names end with <strong class="source-inline">Var</strong>. They all accept a pointer to the type of the flag as the first argument, and can be used as in the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
package main
import (
    "flag"
    "fmt"
)
func main() {
    var v int
    flag.IntVar(&amp;v, "value", -1, "Needs a value for the flag.")
    flag.Parse()
    fmt.Println(v)
}</pre>			<p>This code does the same as the previous snippet, however, here’s a <span class="No-Break">quick breakdown:</span></p>
			<ul>
				<li>First, we define an integer <span class="No-Break">variable </span><span class="No-Break"><strong class="source-inline">v</strong></span></li>
				<li>Use its reference as the first parameter of the <span class="No-Break"><strong class="source-inline">IntVar</strong></span><span class="No-Break"> function</span></li>
				<li>Parse <span class="No-Break">the flags</span></li>
				<li>Print the <strong class="source-inline">v</strong> variable, which now does not need to be dereferenced as it is not the flag but an <span class="No-Break">actual integer</span></li>
			</ul>
			<p>If we compile our application, using any of the preceding snippets, as an executable called <strong class="source-inline">flagapp</strong>, with the following call in the same directory as the executable, we will see that it will print the <span class="No-Break">number </span><span class="No-Break"><strong class="source-inline">5</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
flagapp -value=5</pre>			<p>If we call it without<a id="_idIndexMarker905"/> the parameter<a id="_idIndexMarker906"/> with the following call in the same directory as the executable, we will see that it will just <span class="No-Break">print </span><span class="No-Break"><strong class="source-inline">-1</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
flagapp</pre>			<p>This is because <strong class="source-inline">-1</strong> is the<a id="_idTextAnchor1633"/> <span class="No-Break">default value.</span></p>
			<h2 id="_idParaDest-371"><a id="_idTextAnchor1634"/>Signals</h2>
			<p>A signal is an interrupt that is sent<a id="_idIndexMarker907"/> to our program or a process by the OS. When a signal is delivered to our program, the program will stop what it is doing; either it will handle the signal or, if possible, <span class="No-Break">ignore it.</span></p>
			<p>The following is a list of the top three most often used interrupt signals for <span class="No-Break">Go programs:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">SIGINT</strong></span><span class="No-Break"> (interrupt):</span><ul><li>Situation: This signal is commonly used when a user presses <em class="italic">Ctrl + C</em> in the terminal to interrupt the execution of <span class="No-Break">a program.</span></li><li>Definition: SIGINT is the interrupt signal. It is used to gracefully terminate a program and perform cleanup operations <span class="No-Break">before exiting.</span></li></ul></li>
				<li><span class="No-Break"><strong class="source-inline">SIGTERM</strong></span><span class="No-Break"> (termination):</span><ul><li>Situation: This signal is often used to request the termination of a program in a controlled manner. It is a generic signal to terminate <span class="No-Break">a process.</span></li><li>Definition: SIGTERM is the termination signal. It allows a program to perform cleanup operations before exiting, similar to SIGINT, but it can be caught and <span class="No-Break">handled differently.</span></li></ul></li>
				<li><span class="No-Break"><strong class="source-inline">SIGKILL</strong></span><span class="No-Break"> (kill):</span><ul><li>Situation: This signal is used to forcefully terminate a program. It doesn’t allow the program to perform any <span class="No-Break">cleanup operations.</span></li><li>Definition: SIGKILL is the kill signal. It immediately terminates a process without giving it a chance to clean up resources. It is a more forceful way of ending a program compared <span class="No-Break">to SIGTERM.</span></li></ul></li>
			</ul>
			<p>We have seen other Go commands<a id="_idIndexMarker908"/> that change the flow of the program; you may be wondering which one <span class="No-Break">to use.</span></p>
			<p>We use <strong class="source-inline">defer</strong> statements in our applications to perform various cleanup activities, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li>The release <span class="No-Break">of resources</span></li>
				<li>The closing <span class="No-Break">of files</span></li>
				<li>The closing of <span class="No-Break">database connections</span></li>
				<li>Performing the removal of configuration or <span class="No-Break">temporary files</span></li>
			</ul>
			<p>In some use cases, it is important that these activities are completed. Using a <strong class="source-inline">defer</strong> function will execute it just before returning to the caller. However, this does not guarantee that it will always run. There are certain scenarios in which the <strong class="source-inline">defer</strong> function won’t execute; for example, an OS interrupt to <span class="No-Break">your program:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">os.Exit(1)</strong></span></li>
				<li><em class="italic">Ctrl + C</em></li>
				<li>Other instructions from <span class="No-Break">the OS</span></li>
			</ul>
			<p>The preceding scenarios indicate where it may warrant using signals. Signals can help us control the exit of our program. Depending on the signal, it could terminate our program. For example, the application is running and encounters an OS interrupt signal after executing <strong class="source-inline">employee.CalculateSalary()</strong>. In this scenario, the <strong class="source-inline">defer</strong> function will not run, thus, <strong class="source-inline">employee.DepositCheck()</strong> does not execute and the employee does not get paid. A signal can change the flow of the program. The following diagram goes over the scenario we <span class="No-Break">discussed previously:</span></p>
			<div>
				<div id="_idContainer155" class="IMG---Figure">
					<img src="image/B18621_14_06.jpg" alt="Figure 14.6 – Example program with signals" width="694" height="366"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.6 – Example program with signals</p>
			<p>Support for handling signals<a id="_idIndexMarker909"/> is built into the Go standard library; it is in the <strong class="source-inline">os/signal</strong> package. This package will allow us to make our programs more resilient. We want to gracefully shut down when we receive certain signals. The first thing to do when handling signals in Go is to trap or catch the signal that you are interested in. This is done by using the <span class="No-Break">following function:</span></p>
			<pre class="source-code">
func Notify(c chan&lt;- os.Signal, sig ...os.Signal)</pre>			<p>This function accepts an <strong class="source-inline">os.Signal</strong> data type on a channel, <strong class="source-inline">c</strong>. The <strong class="source-inline">sig</strong> argument is a variadic variable of <strong class="source-inline">os.Signal</strong>; we specify zero or more <strong class="source-inline">os.Signal</strong> data types that we are interested in. Let’s see a code snippet showing how we can use this function to stop the execution<a id="_idIndexMarker910"/> of <span class="No-Break">an application:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
    "os"
    "os/signal"
    "syscall"
)
func main() {
    sigs := make(chan os.Signal, 1)
    done := make(chan struct{})
    signal.Notify(sigs,syscall.SIGINT)
    go func() {
    for {
        s := &lt;-sigs
        switch s {
            case syscall.SIGINT:
                fmt.Println()
                fmt.Println("My process has been interrupted. Someone might of pressed CTRL-C")
                fmt.Println("Some clean up is occuring")
                done &lt;-struct{}{}
            }
        }
    }()
    fmt.Println("Program is blocked until a signal is caught")
    done &lt;- struct{}{}
    fmt.Println("Out of here")
}</pre>			<p>After the definition of the package and importing the packages, we do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Define a channel to <span class="No-Break">send signals</span></li>
				<li>Define a channel that we can use as a flag to stop <span class="No-Break">the execution</span></li>
				<li>Use <strong class="source-inline">Notify</strong> to send a <span class="No-Break"><strong class="source-inline">SIGINT</strong></span><span class="No-Break"> signal</span></li>
				<li>Create a goroutine that listens indefinitely to signals and if the signal is <strong class="source-inline">SIGINT</strong>, it does some printouts and sends a message to the <strong class="source-inline">done</strong> channel with the <span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break"> value</span></li>
				<li>Print a message stating we are waiting for the <strong class="source-inline">done</strong> message to <span class="No-Break">be received</span></li>
				<li>Wait for the <span class="No-Break"><strong class="source-inline">done</strong></span><span class="No-Break"> message</span></li>
				<li>Print the <span class="No-Break">final message</span></li>
			</ul>
			<p>When we run the application, we will actually see the application terminate quite quickly, because we manually send the <strong class="source-inline">SIGINT</strong> signal. In a real-world scenario, the application would just wait<a id="_idIndexMarker911"/> for the <strong class="source-inline">SIGKILL</strong> signal, which we can manually send with <em class="italic">Ctrl</em> + <span class="No-Break"><em class="italic">X</em></span><span class="No-Break">.</span></p>
			<p>Let’s see now how we can <a id="_idTextAnchor1635"/>simulate <span class="No-Break">a cleanup.</span></p>
			<h2 id="_idParaDest-372"><a id="_idTextAnchor1636"/>Exercise 14.01 – simulating a cleanup</h2>
			<p>In this exercise, we will be catching<a id="_idIndexMarker912"/> two signals: <strong class="source-inline">SIGINT</strong> and <strong class="source-inline">SIGTSTP</strong>. Once those signals have been caught, we will simulate a cleanup of the files. We have not gone over how to remove files yet, so, in this example, we will simply create a delay to demonstrate how we can run a function after a signal is caught. This is the desired output from <span class="No-Break">this exercise:</span></p>
			<ol>
				<li>Create a file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></li>
				<li>Add to this file the <strong class="source-inline">main</strong> package<a id="_idIndexMarker913"/> and the following <span class="No-Break"><strong class="source-inline">import</strong></span><span class="No-Break"> statements:</span><pre class="source-code">
package main
import (
    "fmt"
    "os"
    "os/signal"
    "syscall"
    "time"
)</pre></li>				<li>In the <strong class="source-inline">main()</strong> function, create a channel of the <strong class="source-inline">os.Signal</strong> type. The <strong class="source-inline">sigs</strong> channel is used to receive these notifications from the <span class="No-Break"><strong class="source-inline">Notify</strong></span><span class="No-Break"> method:</span><pre class="source-code">
func main() {
    sigs := make(chan os.Signal, 1)</pre></li>				<li>Next, add a <strong class="source-inline">done</strong> channel. The <strong class="source-inline">done</strong> channel is used to let us know when the program <span class="No-Break">can exit:</span><pre class="source-code">
    done := make(chan struct{})</pre></li>				<li>We will then add a <strong class="source-inline">signal.Notify</strong> method. The <strong class="source-inline">Notify</strong> method works by sending values of the <strong class="source-inline">os.Signal</strong> type to <span class="No-Break">a channel.</span></li>
				<li>Recall that the last parameter of the <strong class="source-inline">signal.Notify</strong> method is a variadic parameter of the <span class="No-Break"><strong class="source-inline">os.Signal</strong></span><span class="No-Break"> type.</span></li>
				<li>The <strong class="source-inline">signal.Notify</strong> method will receive notifications on the <strong class="source-inline">sigs</strong> channel that are of the <strong class="source-inline">syscall.SIGINT</strong> and <span class="No-Break"><strong class="source-inline">syscall.SIGTSTP</strong></span><span class="No-Break"> types.</span></li>
				<li>Generally speaking, the <strong class="source-inline">syscall.SIGINT</strong> type can occur when you press <em class="italic">Ctrl</em> + <span class="No-Break"><em class="italic">C</em></span><span class="No-Break">.</span></li>
				<li>Generally speaking, the <strong class="source-inline">syscall.SIGTSTP</strong> type can occur when you press <em class="italic">Ctrl</em> + <span class="No-Break"><em class="italic">Z</em></span><span class="No-Break">:</span><pre class="source-code">
    signal.Notify(sigs, syscall.SIGINT, syscall.SIGTSTP)</pre></li>				<li>Create an anonymous function as <span class="No-Break">a goroutine:</span><pre class="source-code">
    go func() {</pre></li>				<li>Inside the goroutine, create an infinite loop. Inside the infinite loop, we will receive<a id="_idIndexMarker914"/> a value from the <strong class="source-inline">sigs</strong> channel and store it in the <strong class="source-inline">s</strong> variable, <strong class="source-inline">s := &lt;-</strong><span class="No-Break"><strong class="source-inline">sigs</strong></span><span class="No-Break">:</span><pre class="source-code">
    for {
      s := &lt;-sigs</pre></li>				<li>Create a <strong class="source-inline">switch</strong> statement that evaluates what is received from <span class="No-Break">the channel.</span></li>
				<li>We will have two case statements that will check for the <strong class="source-inline">syscall.SIGINT</strong> and <span class="No-Break"><strong class="source-inline">syscall.SIGTSP</strong></span><span class="No-Break"> types.</span><p class="list-inset">Each case statement will have a message <span class="No-Break">being printed.</span></p></li>
				<li>We will also call our <span class="No-Break"><strong class="source-inline">cleanup()</strong></span><span class="No-Break"> function.</span></li>
				<li>The last statement in the case statement is sending <strong class="source-inline">true</strong> to the <strong class="source-inline">done</strong> channel to stop <span class="No-Break">the blocking:</span><pre class="source-code">
      switch s {
      case syscall.SIGINT:
        fmt.Println()
        fmt.Println("My process has been interrupted. Someone might have pressed CTRL-C")
        fmt.Println("Some clean up is occuring")
        cleanUp()
        done &lt;- struct{}{}
      case syscall.SIGTSTP:
        fmt.Println()
        fmt.Println("Someone pressed CTRL-Z")
        fmt.Println("Some clean up is occuring")
        cleanUp()
        done &lt;- struct{}{}
      }
    }
  }()
  fmt.Println("Program is blocked until a signal is caught(ctrl-z, ctrl-c)")
  done &lt;- struct{}{}
  fmt.Println("Out of here")
}</pre></li>				<li>Create a simple function<a id="_idIndexMarker915"/> to mimic a process performing <span class="No-Break">a cleanup:</span><pre class="source-code">
func cleanUp() {
  fmt.Println("Simulating clean up")
  for i := 0; i &lt;= 10; i++ {
    fmt.Println("Deleting Files.. Not really.", i)
    time.Sleep(1 * time.Second)
  }
}</pre></li>				<li>You can try running this program and pressing <em class="italic">Ctrl</em> + <em class="italic">Z</em> and <em class="italic">Ctrl</em> + <em class="italic">C</em> to examine the different results of the program. This only works on Linux <span class="No-Break">and macOS:</span></li>
				<li>Now run <span class="No-Break">the code:</span><pre class="source-code">
go run main.go</pre></li>				<li>The following is <span class="No-Break">the output:</span></li>
			</ol>
			<div>
				<div id="_idContainer156" class="IMG---Figure">
					<img src="image/B18621_14_07.jpg" alt="Figure 14.7 – Example output" width="1006" height="561"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.7 – Example output</p>
			<p>In this exercise, we have demonstrated<a id="_idIndexMarker916"/> the ability to intercept an interrupt and perform a task before the application closes. We have the ability to control our exit. This is a powerful feature that allows us to perform cleanup actions that include removing files, performing a last-minute log, freeing up memory, and more. In the next topic, we are going to be creating and writing to files. We will be using functions that come from the G<a id="_idTextAnchor1637"/>o standard <span class="No-Break">package, </span><span class="No-Break"><strong class="source-inline">os</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-373"><a id="_idTextAnchor1638"/>Create and write to files</h1>
			<p>The Go language provides<a id="_idIndexMarker917"/> support in various<a id="_idIndexMarker918"/> ways to create and write to new files. We will examine some of the most common ways in which this <span class="No-Break">is performed.</span></p>
			<p>The <strong class="source-inline">os</strong> package provides a simple way in which to create a file. For those who are familiar with the <strong class="source-inline">touch</strong> command from the Unix world, it is similar to this. Here is the signature of <span class="No-Break">the function:</span></p>
			<pre class="source-code">
func Create(name string(*File, error)</pre>			<p>The function will create an empty file much as the <strong class="source-inline">touch</strong> command does. It is important to note that if the file already exists, then it will truncate <span class="No-Break">the file.</span></p>
			<p>The <strong class="source-inline">os</strong> package’s <strong class="source-inline">Create</strong> function has an input parameter, which is the name of the file to create and its location. If successful, it will return a <strong class="source-inline">File</strong> type. It is worth noting that the <strong class="source-inline">File</strong> type satisfies the <strong class="source-inline">io.Write</strong> and <strong class="source-inline">io.Read</strong> interfaces. This is important to know for later in <span class="No-Break">the chapter:</span></p>
			<pre class="source-code">
package main
import (
    "os"
)
func main() {
    f, err := os.Create("test.txt")
    if err != nil {
        panic(err)
    }
    defer f.Close()
}</pre>			<p>The preceding code simply defines the imports and then, in the <strong class="source-inline">main</strong> function, tries to create a file called <strong class="source-inline">test.txt</strong>. If there is an error as a result, it panics. The last line before the closing brackets makes sure that whenever the application is interrupted, either because it terminates successfully or it panics, the file will be closed. We want to make sure we never keep files in an <span class="No-Break">open state.</span></p>
			<p>Creating an empty file<a id="_idIndexMarker919"/> is straightforward, but let’s continue<a id="_idIndexMarker920"/> with <strong class="source-inline">os.Create</strong> and write to the file we just created. Recall that <strong class="source-inline">os.Create</strong> returns an <strong class="source-inline">*os.File</strong> type. There are two methods of interest that can be used to write to <span class="No-Break">the file:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">Write</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">WriteString</strong></span></li>
			</ul>
			<p>Let’s see some examples of how to <span class="No-Break">use them:</span></p>
			<pre class="source-code">
package main
import (
    "os"
)
func main() {
    f, err := os.Create("test.txt")
    if err != nil {
        panic(err)
    }
    defer f.Close()
    f.Write([]byte("Using Write function.\n"))
    f.WriteString("Using Writestring function.\n")
}</pre>			<p>This code is pretty similar to the previous one. We just added two lines where we write two sentences to <span class="No-Break">the file.</span></p>
			<p>The first function call is <span class="No-Break">the following:</span></p>
			<pre class="source-code">
f.Write([]byte("Using Write function.\n"))</pre>			<p>Here, we can see that the function needs bytes to be sent, hence we convert a string into a slice of bytes with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
[]byte("Using Write function.\n")</pre>			<p>The second function just accepts a string and is straightforward <span class="No-Break">to use.</span></p>
			<p>We can, however, use the package to write to the file directly without having to open it first. We can do this using the <span class="No-Break"><strong class="source-inline">os.WriteFile</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func WriteFile(filename string, data []byte, perm os.FileMode) error</pre>			<p>The method writes the data<a id="_idIndexMarker921"/> to the file specified<a id="_idIndexMarker922"/> in the <strong class="source-inline">filename</strong> parameter, with the given permissions. It will return an error if one exists. Let’s take a look at this <span class="No-Break">in action:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
    "os
)
func main() {
    message := []byte("Look!")
    err := os.WriteFile("test.txt", message, 0644)
    if err != nil {
        fmt.Println(err)
    }
}</pre>			<p>As we can see, we can create a file, send a string transformed into a slice of bytes, and assign the permission to it, all in one line. It is important to also send the permission level and note that we need to use the octal notation with the leading zero (this is because without the leading zero, the permission will not work <span class="No-Break">as expected).</span></p>
			<p>One important thing that we haven’t seen till now is how to check whether a file exists or not. This is important<a id="_idIndexMarker923"/> because if a file does exist, we might<a id="_idIndexMarker924"/> not want to truncate it and override it with new content. Let’s see how we can <span class="No-Break">do that:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
    "s"
    "flag"
)
func main() {
    var name tring
    flag.StringVar(&amp;name, "name", "", "File name")
    flag.Parse()
    file, err := os.Stat(name)
    if err != nil {
        if os.IsNotExist(err) {
            fmt.Printf("%s: File does not exist!\n", name)
            fmt.Println(file)
            return
        }
        fmt.Println(err)
        return
      }
    fmt.Printf("file name: %s\nIsDir: %t\nModTime: %v\nMode: %v\nSize: %d\n", file.Name(),
    file.IsDir(), file.ModTime(), file.Mode(), file.Size())
}</pre>			<p>Let’s review what the preceding <span class="No-Break">code does:</span></p>
			<ol>
				<li>Firstly, we import all the <span class="No-Break">needed packages.</span></li>
				<li>We then define a string flag that represents <span class="No-Break">the filename:</span><pre class="source-code">
flag.StringVar(&amp;name, "name", "", "File name")</pre></li>				<li>Next, we parse the flags; in this case, the only one is the one <span class="No-Break">we created.</span></li>
				<li>We then get the stats for <span class="No-Break">the file:</span><pre class="source-code">
file, err := os.Stat(name)</pre></li>				<li>If there is an error, we check whether this is because the file does <span class="No-Break">not exist:</span><pre class="source-code">
if os.IsNotExist(err) {</pre></li>				<li>If the file does not exist, we print a message and we then terminate <span class="No-Break">the application.</span></li>
				<li>If the error is different from <strong class="source-inline">IsNotExist</strong>, we just then print <span class="No-Break">the error.</span></li>
				<li>If, finally, the file exists, we then print a set of information related to it. The file implements the <strong class="source-inline">FileInfo</strong> interface, which includes in its details the modification time, the size, the octal permissions (<em class="italic">mode</em>), the name, and whether it is a directory <span class="No-Break">or not.</span></li>
			</ol>
			<p>You can try to run this application<a id="_idIndexMarker925"/> and pass the name<a id="_idIndexMarker926"/> of any file. If it exists in the directory from which you run the application, you will see all this information printed out <span class="No-Break">for you.</span></p>
			<p>Let’s now <a id="_idTextAnchor1639"/>see how can we read a <span class="No-Break">whole file.</span></p>
			<h2 id="_idParaDest-374"><a id="_idTextAnchor1640"/>Reading the whole file at once</h2>
			<p>In this topic, we will look at two methods<a id="_idIndexMarker927"/> that read all the contents of the file. These two functions are good to use when your file size is small. While these two methods are convenient and easy to use, they have one major drawback. That is, if the file size is too large, then it could exhaust the memory available on the system. It is important to keep this in mind and understand the limitations of the two methods we will be going over in this topic. Even though these methods are some of the quickest and easiest ways to load data, it is important to understand that they should be limited to small files<a id="_idIndexMarker928"/> and not large ones. The method’s signature is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
func ReadFile(filename string) ([]byte, error)</pre>			<p>The <strong class="source-inline">ReadFile</strong> function reads the contents<a id="_idIndexMarker929"/> of the file and returns it as a slice of bytes along with any reported errors. We will look at the error return when the <strong class="source-inline">ReadFile</strong> method <span class="No-Break">is used:</span></p>
			<ul>
				<li>A successful call returns <strong class="source-inline">err == </strong><span class="No-Break"><strong class="source-inline">nil</strong></span><span class="No-Break">.</span></li>
				<li>In some of the other read<a id="_idIndexMarker930"/> methods for files, <strong class="bold">end of file</strong> (<strong class="bold">EOF</strong>) is treated as an error. This is not the case for functions that read the entire file <span class="No-Break">into memory.</span></li>
			</ul>
			<p>Let’s see a code snippet that explains how to use <span class="No-Break">this function:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
    "os"
)
func main() {
    content, err := os.ReadFile("test.txt")
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println("File contents: ")
    fmt.Println(string(content))
}</pre>			<p>As we can see, what we do in this code is <span class="No-Break">as follows:</span></p>
			<ul>
				<li>We do <span class="No-Break">our imports</span></li>
				<li>We read the contents of the whole <span class="No-Break"><strong class="source-inline">test.txt</strong></span><span class="No-Break"> file</span></li>
				<li>We print an error if <span class="No-Break">it occurs</span></li>
				<li>Else, we print the content of <span class="No-Break">the file:</span><pre class="source-code">
  fmt.Println("File contents: ")
  fmt.Println(string(content))</pre></li>			</ul>
			<p>As the content is retrieved<a id="_idIndexMarker931"/> as a slice of bytes, we need to convert it to a string to visualize it. Let’s see how to read, instead, the file character by character in the <span class="No-Break">next snippet:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
    "io"
    "log"
    "os"
)
func main() {
    f, err := os.Open("test.txt")
    if err != nil {
        log.Fatalf("unable to read file: %v", err)
    }
    buf := make([]byte, 1)
    for {
        n, err := f.Read(buf)
        if err == io.EOF {
            break
        }
        if err != nil {
            fmt.Println(err)
            continue
        }
    if n &gt; 0 {
            fmt.Print(string(buf[:n]))
    }
    }
}</pre>			<p>Let’s analyze this snippet in more<a id="_idIndexMarker932"/> detail as it is a bit complicated. In this case, after importing the required packages, we do <span class="No-Break">the following:</span></p>
			<ol>
				<li>Open the file using the <span class="No-Break"><strong class="source-inline">Open</strong></span><span class="No-Break"> function:</span><pre class="source-code">
f, err := os.Open("test.txt")</pre></li>				<li>We check whether the error is <strong class="source-inline">nil</strong>, and if is not, we print the error <span class="No-Break">and exit:</span><pre class="source-code">
if err != nil {
    log.Fatalf("unable to read file: %v", err)
}</pre></li>				<li>We then create a slice of bytes of <span class="No-Break">size </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">:</span><pre class="source-code">
  buf := make([]byte, 1)</pre></li>				<li>We then make an infinite loop, and inside it, we read the file into <span class="No-Break">the buffer:</span><pre class="source-code">
n, err := f.Read(buf)</pre></li>				<li>We then check whether there is an error, which also means that we reached the end of the file, in which case we stop <span class="No-Break">the loop:</span><pre class="source-code">
if err == io.EOF {
    break
}</pre></li>				<li>If the error is not <strong class="source-inline">nil</strong> but is not <strong class="source-inline">end of file</strong>, we carry on with the loop, ignoring <span class="No-Break">the error.</span></li>
				<li>If there is no error and the content has been read, then we display <span class="No-Break">the content:</span><pre class="source-code">
if n &gt; 0 {
  fmt.Print(string(buf[:n]))
}</pre></li>			</ol>
			<p>Notice that we read one character<a id="_idIndexMarker933"/> at a time, as we made a buffer (slice of bytes) of size one. This might be resource intensive, so you might change this value to any other v<a id="_idTextAnchor1641"/>alue for your particular case <span class="No-Break">and needs.</span></p>
			<h2 id="_idParaDest-375"><a id="_idTextAnchor1642"/>Exercise 14.02 – backing up files</h2>
			<p>Oftentimes, when working with files, we need<a id="_idIndexMarker934"/> to back up a file before making changes to it. This is for instances where we might make mistakes or want the original file for auditing purposes. In this exercise, we will take an existing file called <strong class="source-inline">note.txt</strong> and back it up to <strong class="source-inline">backupFile.txt</strong>. We will then open <strong class="source-inline">note.txt</strong> and add some additional notes to the end of the file. Our directory will contain the <span class="No-Break">following files:</span></p>
			<div>
				<div id="_idContainer157" class="IMG---Figure">
					<img src="image/B18621_14_08.jpg" alt="Figure 14.8 – Backing up files to the directory" width="1228" height="222"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.8 – Backing up files to the directory</p>
			<ol>
				<li>We must first create the <strong class="source-inline">note.txt</strong> file in the same directory<a id="_idIndexMarker935"/> as our executable. This file can be blank or contain some sample data such <span class="No-Break">as this:</span></li>
			</ol>
			<div>
				<div id="_idContainer158" class="IMG---Figure">
					<img src="image/B18621_14_09.jpg" alt="Figure 14.9 – Example of the notes.txt file content" width="1268" height="80"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.9 – Example of the notes.txt file content</p>
			<ol>
				<li value="2">Create a Go file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></li>
				<li>This program will be part of the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> package.</span></li>
				<li>Include the imports, as seen in the <span class="No-Break">following code:</span><pre class="source-code">
package main
import (
    "errors"
    "fmt"
    "io"
    "os"
    "strconv"
)</pre></li>				<li>Create a custom error that will be used when the working file (<strong class="source-inline">note.txt</strong>) is <span class="No-Break">not found:</span><pre class="source-code">
var (
    ErrWorkingFileNotFound = errors.New("The working file is not found.")
)</pre></li>				<li>Create a function to perform<a id="_idIndexMarker936"/> the backup. This function is responsible for taking the working file and storing its content in the <strong class="source-inline">backup</strong> file. This function accepts two arguments. The <strong class="source-inline">working</strong> parameter is the file path of the file that you currently are <span class="No-Break">working on:</span><pre class="source-code">
func createBackup(working, backup string) error {
}</pre></li>				<li>Inside this function, we will need to check to see whether the working file exists. It must first exist before we can read its contents and store them in our <span class="No-Break">backup file.</span><p class="list-inset">We are able to check to see whether the error is one where the file does not exist by <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">os.IsNotExist(err)</strong></span><span class="No-Break">.</span></p><p class="list-inset">If the file does not exist, we will return with our custom <span class="No-Break">error, </span><span class="No-Break"><strong class="source-inline">ErrWorkingFileNotFound</strong></span><span class="No-Break">:</span></p><pre class="source-code">
    // check to see if our working file exists,
    // before backing it up
    _, err := os.Stat(working)
    if err != nil {
    if os.IsNotExist(err) {
        return ErrWorkingFileNotFound
    }
    return err
  }</pre></li>				<li>Next, we need to open the working file<a id="_idIndexMarker937"/> and store the <strong class="source-inline">os.File</strong> returned by the function to the <span class="No-Break"><strong class="source-inline">workFile</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
    workFile, err := os.Open(working)
    if err != nil {
        return err
    }</pre></li>				<li>We need to read the contents of <strong class="source-inline">workFile</strong>. We will be using the <strong class="source-inline">io.ReadAll</strong> method to get all the contents of <strong class="source-inline">workFile</strong>. <strong class="source-inline">workFile</strong> is of the <strong class="source-inline">os.File</strong> type, which satisfies the <strong class="source-inline">io.Reader</strong> interface; this allows us to pass it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">ioutil.ReadFile</strong></span><span class="No-Break">.</span></li>
				<li>Check to see whether there is <span class="No-Break">an error:</span><pre class="source-code">
  content, err := io.ReadAll(workFile)
  if err != nil {
    return err
  }</pre></li>				<li>The <strong class="source-inline">content</strong> variable contains the data of the <strong class="source-inline">workFile</strong> represented as a slice of bytes. That data needs to be written to the backup file. We will implement the code that will write the data of the <strong class="source-inline">content</strong> variable to the <span class="No-Break">backup file.</span></li>
				<li>The content stores the <strong class="source-inline">[]byte</strong> data that gets returned from the function. This is the entire contents of the file stored in <span class="No-Break">the variable.</span></li>
				<li>We can use the <strong class="source-inline">os.Writefile</strong> method. If the backup file does not exist, it will create the file. If the backup file does exist, it will overwrite the file with the content <span class="No-Break">variable data:</span><pre class="source-code">
  err = os.WriteFile(backup, content, 0644)
  if err != nil {
      fmt.Println(err)
  }</pre></li>				<li>We need to return nil, indicating that, at this juncture, we have not encountered <span class="No-Break">any errors:</span><pre class="source-code">
  return nil
}</pre></li>				<li>Create a function that will append data to our <span class="No-Break">working file.</span></li>
				<li>Name the function <strong class="source-inline">addNotes</strong>; this will accept the location of our working file and a string argument that will be appended to the working file. The function will need to return <span class="No-Break">an error:</span><pre class="source-code">
func addNotes(workingFile, notes string) error {
//…
  return nil
}</pre></li>				<li>Inside the <strong class="source-inline">addNotes</strong> function, add a line<a id="_idIndexMarker938"/> that will append a new line to each note’s string. This will place each note on a <span class="No-Break">separate line:</span><pre class="source-code">
func addNotes(workingFile, notes string) error {
  notes += "\n"
  //…
  return nil
}</pre></li>				<li>Next, we will open the working<a id="_idIndexMarker939"/> file and allow for appending to the file. The <strong class="source-inline">os.OpenFile()</strong> function will create the file if it does not exist. Check for <span class="No-Break">any errors:</span><pre class="source-code">
func addNotes(workingFile, notes string) error {
  notes += "\n"
  f, err := os.OpenFile(
    workingFile,
    os.O_APPEND|os.O_CREATE|os.O_WRONLY,
    0644,
  )
  if err != nil {
    return err
  }
  // …
  return nil
}</pre></li>				<li>After opening a file and checking for an error, we should make sure that it closes when the function exits by using the defer <span class="No-Break">function, </span><span class="No-Break"><strong class="source-inline">f.Close()</strong></span><span class="No-Break">:</span><pre class="source-code">
func addNotes(workingFile, notes string) error {
  notes += "\n"
  f, err := os.OpenFile(
    workingFile,
    os.O_APPEND|os.O_CREATE|os.O_WRONLY,
    0644,
  )
  if err != nil {
     return err
  }
  defer f.Close()
//…
  return nil
}</pre></li>				<li>The final step of the function<a id="_idIndexMarker940"/> is to write the contents of the note to the <strong class="source-inline">workingFile</strong> variable. We can use the <strong class="source-inline">Write</strong> method to <span class="No-Break">accomplish this:</span><pre class="source-code">
func addNotes(workingFile, notes string) error {
  notes += "\n"
  f, err := os.OpenFile(workingFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
  if err != nil {
      return err
  }
  defer f.Close()
  if _, err := f.Write([]byte(notes)); err != nil {
    return err
  }
  return nil
}</pre></li>				<li>In the <strong class="source-inline">main()</strong> function, we will initialize three variables; the <strong class="source-inline">backupFile</strong> variable contains the name of the file for backing up our <strong class="source-inline">workingFile</strong> variable, while the <strong class="source-inline">data</strong> variable is what we will be writing to our <span class="No-Break"><strong class="source-inline">workingFile</strong></span><span class="No-Break"> variable:</span><pre class="source-code">
func main() {
    backupFile := "backupFile.txt"
    workingFile := "note.txt"
    data := "note"</pre></li>				<li>Call our <strong class="source-inline">createBackup()</strong> function to back up our <strong class="source-inline">workingFile</strong>. Check for errors after calling <span class="No-Break">the function:</span><pre class="source-code">
    err := createBackup(workingFile, backupFile)
    if err != nil {
        fmt.Println(err)
    os.Exit(1)
    }</pre></li>				<li>Create a <strong class="source-inline">for</strong> loop that<a id="_idIndexMarker941"/> will iterate <span class="No-Break"><strong class="source-inline">10</strong></span><span class="No-Break"> times.</span><p class="list-inset">With each iteration, we set our <strong class="source-inline">note</strong> variable to the <strong class="source-inline">data</strong> variable plus the <strong class="source-inline">i</strong> variable of <span class="No-Break">our loop.</span></p><p class="list-inset">Since our <strong class="source-inline">note</strong> variable is a string and our <strong class="source-inline">i</strong> variable is an <strong class="source-inline">int</strong>, we will need to convert <strong class="source-inline">i</strong> to a string using the <span class="No-Break"><strong class="source-inline">strconv.Itoa(i)</strong></span><span class="No-Break"> method.</span></p><p class="list-inset">Call our <strong class="source-inline">addNotes()</strong> function and pass the <strong class="source-inline">workingFile</strong> and our <span class="No-Break"><strong class="source-inline">note</strong></span><span class="No-Break"> variables.</span></p><p class="list-inset">Check for any errors returned from <span class="No-Break">the function:</span></p><pre class="source-code">
    for i := 1; i &lt;= 10; i++ {
    note := data + " " + strconv.Itoa(i)
    err := addNotes(workingFile, note)
    if err != nil {
        fmt.Println(err)
        os.Exit(1)
        }
    }
}</pre></li>				<li>Run <span class="No-Break">the program:</span><pre class="source-code">
go run main.go</pre></li>				<li>Evaluate the changes to the files after running <span class="No-Break">the program.</span></li>
			</ol>
			<p>The following are the results<a id="_idIndexMarker942"/> after running <a id="_idTextAnchor1643"/><span class="No-Break">the program:</span></p>
			<div>
				<div id="_idContainer159" class="IMG---Figure">
					<img src="image/B18621_14_10.jpg" alt="Figure 14.10 – Result of backup" width="1348" height="513"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.10 – Result of backup</p>
			<p>Let’s see next how to handle CSV files <span class="No-Break">with Go.</span></p>
			<h1 id="_idParaDest-376"><a id="_idTextAnchor1644"/>CSV</h1>
			<p>One of the most common ways a file<a id="_idIndexMarker943"/> is structured is as a comma-separated value. This is a clear-text file that contains data, which is basically represented as rows and columns. Frequently, these files are used to exchange data. A CSV file has a simple structure. Each piece of data is separated by a comma and then a new line for another record. An example of a CSV file is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
firstName, lastName, age
Celina, Jones, 18
Cailyn, Henderson, 13
Cayden, Smith, 42</pre>			<p>You will, at some point<a id="_idIndexMarker944"/> in your life, come across CSV files as they are very common. The Go programming language has a standard library that is used for handling CSV <span class="No-Break">files: </span><span class="No-Break"><strong class="source-inline">encoding/csv</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
package main
import (
    "encoding/csv"
    "fmt"
    "io"
    "log"
    "strings"
)
func main() {
    in := `firstName, lastName, age
Celina, Jones, 18
Cailyn, Henderson, 13
Cayden, Smith, 42
`
    r := csv.NewReader(strings.NewReader(in))
    for {
        record, err := r.Read()
        if err == io.EOF {
            break
        }
        if err != nil {
            log.Fatal(err)
        }
        fmt.Println(record)
    }
}</pre>			<p>Here we are defining a string with the content of our <span class="No-Break">CSV file:</span></p>
			<pre class="source-code">
func main() {
    in := `firstName, lastName, age
Celina, Jones, 18
Cailyn, Henderson, 13
Cayden, Smith, 42`</pre>			<p>And then we use the following line to read the content of the <span class="No-Break">whole CSV:</span></p>
			<pre class="source-code">
  r := csv.NewReader(strings.NewReader(in))</pre>			<p>The following code line creates a string<a id="_idIndexMarker945"/> reader that can be used by the <strong class="source-inline">csv.NewReader</strong> function. We cannot, in fact, pass just a string to the CSV reader as it needs an <strong class="source-inline">io.Reader</strong> instance, which in this case is provided <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">strings.NewReader</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
strings.NewReader(in)</pre>			<p>We then make an infinite loop, which gets terminated when we reach the end of <span class="No-Break">the CSV:</span></p>
			<pre class="source-code">
if err == io.EOF {
   break
}</pre>			<p>As we did earlier in this chapter, we then check for another error and we exit if we find it; otherwise, we print the record, which is retrieved via the <strong class="source-inline">Read()</strong> method of the <span class="No-Break">CSV reader.</span></p>
			<p>In the previous example, we saw how to get a whole record at once, meaning one row of our CSV. However, there is a way to access each column in the returned row, that is, each single element of <span class="No-Break">the row.</span></p>
			<p>If you look back at the previous snippet of code, you will see that the rows are returned with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
 record, err := r.Read()</pre>			<p>We then just printed the content, but this is an actual slice of strings, so we can get each item with its index. Let’s say we are just interested in visualizing the names of the people in the CSV. To do so, we can modify the <strong class="source-inline">fmt.Println(record)</strong> line <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
  fmt.Println(record<a id="_idTextAnchor1645"/>[0])</pre>			<p>With this, we will only<a id="_idIndexMarker946"/> see a list <span class="No-Break">of names.</span></p>
			<h1 id="_idParaDest-377"><a id="_idTextAnchor1646"/>Embedding</h1>
			<p>Often, you will need to present<a id="_idIndexMarker947"/> to the user some complex text, maybe an HTML page, and it might be impractical to define the whole file as a string. You might read the file, as we learned in this chapter, and then use it as a template. You might want to display an image, again by opening and reading the file containing the image. One of the great features of Go is that even if you can build your application as a single binary, you will also have external dependencies that need to be distributed with your binary. Another issue is that reading from a file might be slow, so it would be great if we could embed files inside our Go application. This will allow us to just distribute one binary including all our assets. In the past, this required external libraries, but now Go includes a package called <strong class="source-inline">embed</strong> that allows you to easily embed any file into your binary so that you do not need to share other dependencies. Let’s see an example of how we can <span class="No-Break">do that.</span></p>
			<p>In the next snippet, we will create a very simple template file and will read and parse it. Then we will use it to display some greetings. Let’s start with the template. We need a folder structure like this: <strong class="source-inline">embedding_example/main.go </strong><span class="No-Break"><strong class="source-inline">and</strong></span><span class="No-Break"> </span><span class="No-Break"><strong class="source-inline">templates/template.txt</strong></span><span class="No-Break">.</span></p>
			<p>The content of the <strong class="source-inline">template.txt</strong> file is <strong class="source-inline">Hello {{.Name}}</strong>, which is pretty simple. This simply means that when we use this template and pass a variable called <strong class="source-inline">Name</strong>, the engine will substitute the variable with anything we pass as a value. You do not need, at this stage, to understand much more about the <span class="No-Break">templating system.</span></p>
			<p>Let’s see now how we can make use<a id="_idIndexMarker948"/> of this template written in an external file, without having to read it every time we run <span class="No-Break">the application:</span></p>
			<pre class="source-code">
package main
import (
    "embed"
    "os"
    "text/template"
)
type Person struct {
    Name string
}
var (
    //go:embed templates
    f embed.FS
)
func main() {
    p := Person{"John"}
    tmpl, err := template.ParseFS(f, "templates/template.txt")
    if err != nil {
        panic(err)
    }
    err = tmpl.Execute(os.Stdout, p)
    if err != nil {
        panic(err)
    }
}</pre>			<ol>
				<li>We start importing all the necessary packages. After that, we define a struct called <strong class="source-inline">Person</strong> that will hold the name of the person to greet. The next part is the <span class="No-Break">important bit:</span><pre class="source-code">
var (
    //go:embed templates
    f embed.FS
)</pre></li>			</ol>
			<p>This defines an <strong class="source-inline">f</strong> variable of type <strong class="source-inline">embed.FS</strong>, which stands for <em class="italic">embedded file system</em> and will work as a virtual filesystem for us. The directive on top of the declaration needs to be just above the variable we define, otherwise the compiler will prompt us with an error. This directive tells the Go compiler<a id="_idIndexMarker949"/> that it needs to read and embed whatever is inside the <strong class="source-inline">templates</strong> folder and make it available. Be careful if you add a folder with too many big files, as your final binary will increase <span class="No-Break">in size.</span></p>
			<ol>
				<li>Inside the <strong class="source-inline">main</strong> function, we then instantiate a struct of type <strong class="source-inline">Person</strong> where the <strong class="source-inline">Name</strong> attribute has the <span class="No-Break">value </span><span class="No-Break"><strong class="source-inline">John</strong></span><span class="No-Break">.</span></li>
				<li>After that, we use the <strong class="source-inline">ParseFS</strong> function of the <strong class="source-inline">template</strong> package, and we use it to read from the embedded file system, represented by the variable <strong class="source-inline">f</strong>, the file called <strong class="source-inline">template.txt</strong> from inside the <span class="No-Break"><strong class="source-inline">templates</strong></span><span class="No-Break"> folder.</span></li>
				<li>Next, we just execute the templating engine, passing the previously created struct. If you run the application, you will see the message printed out <span class="No-Break">as follows:</span><pre class="source-code">
Hello John</pre></li>				<li>Now, this does not seem much, but try running the <span class="No-Break">following command:</span><pre class="source-code">
go build -o embtest main.go</pre></li>				<li>Then, copy your executable to a different location where the <strong class="source-inline">template</strong> folder is not available. If you now run from that new folder, you will still see the exact <span class="No-Break">same message:</span><pre class="source-code">
./embtest</pre></li>			</ol>
			<p>The key takeaway here is that the directive takes the whole filesystem from the point you specify, in this case, the <strong class="source-inline">templates</strong> folder, and creates a virtual filesystem. From this virtual filesystem, you can read all the files, but the content of the whole folder will actually be stored inside the final binary<a id="_idIndexMarker950"/> of your application. This feature is very powerful but should be used wis<a id="_idTextAnchor1647"/>ely, as the final binary could easily become <span class="No-Break">very big.</span></p>
			<h1 id="_idParaDest-378"><a id="_idTextAnchor1648"/>Summary</h1>
			<p>In this chapter, we gained an understanding of how Go views and uses file permissions. We learned that file permissions can be represented as symbolic and octal notations. We discovered that the Go standard library has built-in support for opening, reading, writing, creating, deleting, and appending data to a file. We looked at the <strong class="source-inline">flag</strong> package and how it provides functionality to create command-line applications to <span class="No-Break">accept arguments.</span></p>
			<p>Using the <strong class="source-inline">flag</strong> package, we could also print out <strong class="source-inline">usage</strong> statements that pertained to our <span class="No-Break">command-line application.</span></p>
			<p>Then, we demonstrated how OS signals can impact our Go program; however, by using the Go standard library, we can capture OS signals and, if applicable, control how we want to exit <span class="No-Break">our program.</span></p>
			<p>We also learned that Go has a standard library for working with CSV files. In our previous work with files, we saw that we can also work with files that are structured as CSV files. That Go CSV package provides the ability to iterate over the contents of the file. The CSV file can be viewed as rows and columns similar to <span class="No-Break">database tables.</span></p>
			<p>Finally, we saw how to embed files inside the final binary of the application and how to use this feature to speed up the application and avoid shipping external dependencies with the binary. In the next chapter, we will look at how to connect to databases and execute SQL statements against a database. This will demonstrate the ability of Go to be used for applications that require a backend for <span class="No-Break">storing data.</span></p>
		</div>
	</div></div></body></html>