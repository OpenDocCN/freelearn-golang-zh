["```go\nfunc Bool(name string, value bool, usage string) *bool\nfunc Duration(name string, value time.Duration, usage string) *time.Duration\nfunc Float64(name string, value float64, usage string) *float64\nfunc Int(name string, value int, usage string) *int\nfunc Int64(name string, value int64, usage string) *int64\n```", "```go\n    ./app -file\n    ```", "```go\npackage main\nimport (\n    \"flag\"\n    \"fmt\"\n)\nfunc main() {\n    v := flag.Int(\"value\", -1, \"Needs a value for the flag.\")\n    flag.Parse()\n    fmt.Println(*v)\n}\n```", "```go\n    go build -o flagapp main.go\n    ```", "```go\nfunc BoolVar(p *bool, name string, value bool, usage string)\nfunc DurationVar(p *time.Duration, name string, value time.Duration, usage string)\nfunc Float64Var(p *float64, name string, value float64, usage string)\nfunc Int64Var(p *int64, name string, value int64, usage string)\nfunc IntVar(p *int, name string, value int, usage string)\n```", "```go\npackage main\nimport (\n    \"flag\"\n    \"fmt\"\n)\nfunc main() {\n    var v int\n    flag.IntVar(&v, \"value\", -1, \"Needs a value for the flag.\")\n    flag.Parse()\n    fmt.Println(v)\n}\n```", "```go\nflagapp -value=5\n```", "```go\nflagapp\n```", "```go\nfunc Notify(c chan<- os.Signal, sig ...os.Signal)\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"os\"\n    \"os/signal\"\n    \"syscall\"\n)\nfunc main() {\n    sigs := make(chan os.Signal, 1)\n    done := make(chan struct{})\n    signal.Notify(sigs,syscall.SIGINT)\n    go func() {\n    for {\n        s := <-sigs\n        switch s {\n            case syscall.SIGINT:\n                fmt.Println()\n                fmt.Println(\"My process has been interrupted. Someone might of pressed CTRL-C\")\n                fmt.Println(\"Some clean up is occuring\")\n                done <-struct{}{}\n            }\n        }\n    }()\n    fmt.Println(\"Program is blocked until a signal is caught\")\n    done <- struct{}{}\n    fmt.Println(\"Out of here\")\n}\n```", "```go\n    package main\n    import (\n        \"fmt\"\n        \"os\"\n        \"os/signal\"\n        \"syscall\"\n        \"time\"\n    )\n    ```", "```go\n    func main() {\n        sigs := make(chan os.Signal, 1)\n    ```", "```go\n        done := make(chan struct{})\n    ```", "```go\n        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTSTP)\n    ```", "```go\n        go func() {\n    ```", "```go\n        for {\n          s := <-sigs\n    ```", "```go\n          switch s {\n          case syscall.SIGINT:\n            fmt.Println()\n            fmt.Println(\"My process has been interrupted. Someone might have pressed CTRL-C\")\n            fmt.Println(\"Some clean up is occuring\")\n            cleanUp()\n            done <- struct{}{}\n          case syscall.SIGTSTP:\n            fmt.Println()\n            fmt.Println(\"Someone pressed CTRL-Z\")\n            fmt.Println(\"Some clean up is occuring\")\n            cleanUp()\n            done <- struct{}{}\n          }\n        }\n      }()\n      fmt.Println(\"Program is blocked until a signal is caught(ctrl-z, ctrl-c)\")\n      done <- struct{}{}\n      fmt.Println(\"Out of here\")\n    }\n    ```", "```go\n    func cleanUp() {\n      fmt.Println(\"Simulating clean up\")\n      for i := 0; i <= 10; i++ {\n        fmt.Println(\"Deleting Files.. Not really.\", i)\n        time.Sleep(1 * time.Second)\n      }\n    }\n    ```", "```go\n    go run main.go\n    ```", "```go\nfunc Create(name string(*File, error)\n```", "```go\npackage main\nimport (\n    \"os\"\n)\nfunc main() {\n    f, err := os.Create(\"test.txt\")\n    if err != nil {\n        panic(err)\n    }\n    defer f.Close()\n}\n```", "```go\npackage main\nimport (\n    \"os\"\n)\nfunc main() {\n    f, err := os.Create(\"test.txt\")\n    if err != nil {\n        panic(err)\n    }\n    defer f.Close()\n    f.Write([]byte(\"Using Write function.\\n\"))\n    f.WriteString(\"Using Writestring function.\\n\")\n}\n```", "```go\nf.Write([]byte(\"Using Write function.\\n\"))\n```", "```go\n[]byte(\"Using Write function.\\n\")\n```", "```go\nfunc WriteFile(filename string, data []byte, perm os.FileMode) error\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"os\n)\nfunc main() {\n    message := []byte(\"Look!\")\n    err := os.WriteFile(\"test.txt\", message, 0644)\n    if err != nil {\n        fmt.Println(err)\n    }\n}\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"s\"\n    \"flag\"\n)\nfunc main() {\n    var name tring\n    flag.StringVar(&name, \"name\", \"\", \"File name\")\n    flag.Parse()\n    file, err := os.Stat(name)\n    if err != nil {\n        if os.IsNotExist(err) {\n            fmt.Printf(\"%s: File does not exist!\\n\", name)\n            fmt.Println(file)\n            return\n        }\n        fmt.Println(err)\n        return\n      }\n    fmt.Printf(\"file name: %s\\nIsDir: %t\\nModTime: %v\\nMode: %v\\nSize: %d\\n\", file.Name(),\n    file.IsDir(), file.ModTime(), file.Mode(), file.Size())\n}\n```", "```go\n    flag.StringVar(&name, \"name\", \"\", \"File name\")\n    ```", "```go\n    file, err := os.Stat(name)\n    ```", "```go\n    if os.IsNotExist(err) {\n    ```", "```go\nfunc ReadFile(filename string) ([]byte, error)\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"os\"\n)\nfunc main() {\n    content, err := os.ReadFile(\"test.txt\")\n    if err != nil {\n        fmt.Println(err)\n    }\n    fmt.Println(\"File contents: \")\n    fmt.Println(string(content))\n}\n```", "```go\n      fmt.Println(\"File contents: \")\n      fmt.Println(string(content))\n    ```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"os\"\n)\nfunc main() {\n    f, err := os.Open(\"test.txt\")\n    if err != nil {\n        log.Fatalf(\"unable to read file: %v\", err)\n    }\n    buf := make([]byte, 1)\n    for {\n        n, err := f.Read(buf)\n        if err == io.EOF {\n            break\n        }\n        if err != nil {\n            fmt.Println(err)\n            continue\n        }\n    if n > 0 {\n            fmt.Print(string(buf[:n]))\n    }\n    }\n}\n```", "```go\n    f, err := os.Open(\"test.txt\")\n    ```", "```go\n    if err != nil {\n        log.Fatalf(\"unable to read file: %v\", err)\n    }\n    ```", "```go\n      buf := make([]byte, 1)\n    ```", "```go\n    n, err := f.Read(buf)\n    ```", "```go\n    if err == io.EOF {\n        break\n    }\n    ```", "```go\n    if n > 0 {\n      fmt.Print(string(buf[:n]))\n    }\n    ```", "```go\n    package main\n    import (\n        \"errors\"\n        \"fmt\"\n        \"io\"\n        \"os\"\n        \"strconv\"\n    )\n    ```", "```go\n    var (\n        ErrWorkingFileNotFound = errors.New(\"The working file is not found.\")\n    )\n    ```", "```go\n    func createBackup(working, backup string) error {\n    }\n    ```", "```go\n        // check to see if our working file exists,\n        // before backing it up\n        _, err := os.Stat(working)\n        if err != nil {\n        if os.IsNotExist(err) {\n            return ErrWorkingFileNotFound\n        }\n        return err\n      }\n    ```", "```go\n        workFile, err := os.Open(working)\n        if err != nil {\n            return err\n        }\n    ```", "```go\n      content, err := io.ReadAll(workFile)\n      if err != nil {\n        return err\n      }\n    ```", "```go\n      err = os.WriteFile(backup, content, 0644)\n      if err != nil {\n          fmt.Println(err)\n      }\n    ```", "```go\n      return nil\n    }\n    ```", "```go\n    func addNotes(workingFile, notes string) error {\n    //…\n      return nil\n    }\n    ```", "```go\n    func addNotes(workingFile, notes string) error {\n      notes += \"\\n\"\n      //…\n      return nil\n    }\n    ```", "```go\n    func addNotes(workingFile, notes string) error {\n      notes += \"\\n\"\n      f, err := os.OpenFile(\n        workingFile,\n        os.O_APPEND|os.O_CREATE|os.O_WRONLY,\n        0644,\n      )\n      if err != nil {\n        return err\n      }\n      // …\n      return nil\n    }\n    ```", "```go\n    func addNotes(workingFile, notes string) error {\n      notes += \"\\n\"\n      f, err := os.OpenFile(\n        workingFile,\n        os.O_APPEND|os.O_CREATE|os.O_WRONLY,\n        0644,\n      )\n      if err != nil {\n         return err\n      }\n      defer f.Close()\n    //…\n      return nil\n    }\n    ```", "```go\n    func addNotes(workingFile, notes string) error {\n      notes += \"\\n\"\n      f, err := os.OpenFile(workingFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n      if err != nil {\n          return err\n      }\n      defer f.Close()\n      if _, err := f.Write([]byte(notes)); err != nil {\n        return err\n      }\n      return nil\n    }\n    ```", "```go\n    func main() {\n        backupFile := \"backupFile.txt\"\n        workingFile := \"note.txt\"\n        data := \"note\"\n    ```", "```go\n        err := createBackup(workingFile, backupFile)\n        if err != nil {\n            fmt.Println(err)\n        os.Exit(1)\n        }\n    ```", "```go\n        for i := 1; i <= 10; i++ {\n        note := data + \" \" + strconv.Itoa(i)\n        err := addNotes(workingFile, note)\n        if err != nil {\n            fmt.Println(err)\n            os.Exit(1)\n            }\n        }\n    }\n    ```", "```go\n    go run main.go\n    ```", "```go\nfirstName, lastName, age\nCelina, Jones, 18\nCailyn, Henderson, 13\nCayden, Smith, 42\n```", "```go\npackage main\nimport (\n    \"encoding/csv\"\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"strings\"\n)\nfunc main() {\n    in := `firstName, lastName, age\nCelina, Jones, 18\nCailyn, Henderson, 13\nCayden, Smith, 42\n`\n    r := csv.NewReader(strings.NewReader(in))\n    for {\n        record, err := r.Read()\n        if err == io.EOF {\n            break\n        }\n        if err != nil {\n            log.Fatal(err)\n        }\n        fmt.Println(record)\n    }\n}\n```", "```go\nfunc main() {\n    in := `firstName, lastName, age\nCelina, Jones, 18\nCailyn, Henderson, 13\nCayden, Smith, 42`\n```", "```go\n  r := csv.NewReader(strings.NewReader(in))\n```", "```go\nstrings.NewReader(in)\n```", "```go\nif err == io.EOF {\n   break\n}\n```", "```go\n record, err := r.Read()\n```", "```go\n  fmt.Println(record[0])\n```", "```go\npackage main\nimport (\n    \"embed\"\n    \"os\"\n    \"text/template\"\n)\ntype Person struct {\n    Name string\n}\nvar (\n    //go:embed templates\n    f embed.FS\n)\nfunc main() {\n    p := Person{\"John\"}\n    tmpl, err := template.ParseFS(f, \"templates/template.txt\")\n    if err != nil {\n        panic(err)\n    }\n    err = tmpl.Execute(os.Stdout, p)\n    if err != nil {\n        panic(err)\n    }\n}\n```", "```go\n    var (\n        //go:embed templates\n        f embed.FS\n    )\n    ```", "```go\n    Hello John\n    ```", "```go\n    go build -o embtest main.go\n    ```", "```go\n    ./embtest\n    ```"]