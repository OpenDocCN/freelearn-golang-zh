- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: File and Systems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件和系统
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: We will see in this chapter how to interact with the filesystem, which means
    we will read files, manipulate them, store them for later use, and get information
    about them. We will also cover how to read folders so that we can search for the
    files we need, and will examine some specific file formats such as CSV, which
    is commonly used to share information in tabular form.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何与文件系统交互，这意味着我们将读取文件、操作它们、为以后使用存储它们，并获取有关它们的信息。我们还将介绍如何读取文件夹，以便我们可以搜索所需的文件，并检查一些特定的文件格式，例如CSV，它通常用于以表格形式共享信息。
- en: Another thing you will learn in this chapter is how to send some information
    to your application in the form of flags.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你还将学习如何以标志的形式将一些信息发送到你的应用程序中。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you''ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter14](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter14).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要Go版本1.21或更高版本。本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter14](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter14)。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we looked at how to write simple command-line applications.
    We will carry on with this here, introducing ways to pass parameters to our application
    so that it behaves differently depending on the values we send.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了如何编写简单的命令行应用程序。在这里，我们将继续这一主题，介绍向应用程序传递参数的方法，以便它根据我们发送的值以不同的方式表现。
- en: After that, we will interact with the filesystem. The levels we are going to
    be working with the filesystem at are the file, directory, and permission levels.
    We will tackle everyday issues that developers face when working with the filesystem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将与文件系统交互。我们将要处理的文件系统级别是文件、目录和权限级别。我们将解决开发人员在处理文件系统时面临的日常问题。
- en: We will learn how to create a command-line application that will read and write
    files. Along with discussing what happens when we get a signal interrupt from
    the OS, we will demonstrate how to perform cleanup actions before our application
    stops running. We will also handle a scenario of receiving an interrupt to our
    application and handling how the application exits. There are times when your
    application is running, and a signal comes from the OS to shut down the application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何创建一个命令行应用程序，该程序可以读取和写入文件。除了讨论从操作系统接收到信号中断时会发生什么之外，我们还将演示在应用程序停止运行之前执行清理操作的方法。我们还将处理应用程序接收到中断的情况，并处理应用程序退出的方式。有时，当你的应用程序正在运行时，操作系统会发送一个信号来关闭应用程序。
- en: In such instances, we may want to log information at the time of the shutdown
    for debugging purposes; this will help us to understand why the application shuts
    down. We will look at how we can do that in this chapter. However, before we start
    tackling these issues, let’s get a basic understanding of the filesystem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能希望在关闭时记录信息以进行调试；这将帮助我们了解应用程序为何关闭。在本章中，我们将探讨如何做到这一点。然而，在我们开始处理这些问题之前，让我们先对文件系统有一个基本的了解。
- en: Filesystem
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统
- en: A filesystem controls how data is named, stored, accessed, and retrieved on
    a device such as a hard drive, USB, DVD, or another medium. There is no one filesystem,
    and how it behaves largely depends on what OS you are using. You must have heard
    of `FAT`, `FAT32`, `NFTS`, and so on, which are all different filesystems and
    are used normally by Windows. Linux can read and write to them, but it generally
    uses a different family of filesystems that have names starting with `ext`, which
    stands for *extended*. You do not need to have a deep understanding of filesystems,
    but, as a software engineer, it is good to at least have a basic understanding
    of the subject.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统控制数据在硬盘、USB、DVD或其他介质上的命名、存储、访问和检索方式。没有统一的文件系统，其行为在很大程度上取决于你使用的操作系统。你一定听说过`FAT`、`FAT32`、`NFTS`等等，这些都是不同的文件系统，通常在Windows中使用。Linux可以读写这些文件系统，但通常使用以`ext`开头的不同文件系统家族，`ext`代表*扩展*。你不需要对文件系统有深入的了解，但作为一个软件工程师，至少对这一主题有一个基本了解是好的。
- en: What interests us in this chapter, however, is that each filesystem has its
    conventions for naming files, such as the length of the filename, the specific
    characters that can be used, how long the suffix or file extension can be, and
    so on. Each file has information or metadata, data embedded within a file or associated
    with it that describes or provides information about the file. This metadata about
    a file can contain information such as file size, location, access permissions,
    date created, date modified, and more. This is all the information that can be
    accessed by our applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章中，我们感兴趣的是每个文件系统都有自己的文件命名约定，例如文件名的长度、可以使用的特定字符、后缀或文件扩展名的长度等。每个文件都有信息或元数据，这些信息或元数据是嵌入在文件中或与文件关联的，用于描述或提供有关文件的信息。关于文件的这个元数据可以包含诸如文件大小、位置、访问权限、创建日期、修改日期等信息。这是我们应用程序可以访问的所有信息。
- en: 'Files are generally placed in some sort of hierarchal structure. This structure
    typically consists of multiple directories and sub-directories. The placement
    of the files within the directories is a way to organize your data and get access
    to the file or directory:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 文件通常被放置在某种层次结构中。这种结构通常由多个目录和子目录组成。文件在目录中的放置是一种组织数据并获得对文件或目录访问的方式：
- en: '![Figure 14.1 – The Linux filesystem](img/B18621_14_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1 – Linux 文件系统](img/B18621_14_01.jpg)'
- en: Figure 14.1 – The Linux filesystem
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – Linux 文件系统
- en: As shown in *Figure 14**.1*, directories can be nested. In a normal Linux filesystem,
    we will see that there is a root directory, which is defined by the name **/**,
    and everything else is a subdirectory of it. The **home** directory generally
    holds data for each user of the system, and in the case shown above, **matt**
    is a directory holding a **docs** and an **mp3** directory, which are subdirectories
    of **matt**, but **matt** itself is a subdirectory of **home**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 14.1* 所示，目录可以嵌套。在正常的 Linux 文件系统中，我们将看到有一个根目录，它由名称 **/** 定义，而其他所有内容都是它的子目录。**家**目录通常包含系统每个用户的文件，在上面的示例中，**matt**
    是一个包含 **docs** 和 **mp3** 目录的目录，它们是 **matt** 的子目录，但 **matt** 本身是 **home** 的子目录。
- en: In the next topic, we will be looking at file permissions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将探讨文件权限。
- en: File permissions
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件权限
- en: Permissions are an important aspect that you need to understand when dealing
    with file creation and modifications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文件创建和修改时，权限是一个重要的方面，你需要理解。
- en: We need to look at various permission types that can be assigned to a file.
    We also need to consider how those permission types are represented in symbolic
    and octal notation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要查看可以分配给文件的各个权限类型。我们还需要考虑这些权限类型在符号和八进制表示法中的表示方式。
- en: Go uses the Unix nomenclature to represent permission types. They are represented
    in symbolic notation or octal notation. The three permission types are *Read*,
    *Write*, and *Execute*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Go 使用 Unix 命名法来表示权限类型。它们以符号表示法或八进制表示法表示。三种权限类型是 *读取*、*写入* 和 *执行*。
- en: '![Figure 14.2 – File permissions](img/B18621_14_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2 – 文件权限](img/B18621_14_02.jpg)'
- en: Figure 14.2 – File permissions
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – 文件权限
- en: 'Permissions for every file are assigned to three different entities that can
    be individuals or groups. This means that a user can be part of a group that has
    access to some files, as a result of which the user inherits access to those files.
    It is not possible to assign permissions for a file to a specific user; rather,
    we add the user to a group and then assign permissions to that group. That said,
    it is possible to assign permission for a file to the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件的权限都分配给了三个不同的实体，这些实体可以是个人或组。这意味着一个用户可以是某个有权访问某些文件的组的成员，因此用户继承了这些文件的访问权限。无法将文件权限分配给特定用户；相反，我们将用户添加到组中，然后为该组分配权限。话虽如此，将文件权限分配给以下内容是可能的：
- en: '**Owner**: This is an individual, a single person such as John Smith, or the
    root user who is the owner of the file. In general, it is the individual who created
    the file.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有者**：这是一个个人，如约翰·史密斯这样的单个个人，或者是文件的所有者 root 用户。一般来说，这是创建文件的个人。'
- en: '**Group**: A group typically consists of multiple individuals or other groups.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组**：组通常由多个个人或其他组组成。'
- en: '**Others**: Those that are not in a group or the owner.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他用户**：那些不在组中或不是所有者的用户。'
- en: 'Let’s see now, how permissions are indicated via symbolic notation. The following
    diagram is an example of a file and its permissions on a Unix machine:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看，如何通过符号表示法来表示权限。以下图表是一个文件及其在 Unix 机器上权限的示例：
- en: '![Figure 14.3 – Permissions notation](img/B18621_14_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3 – 权限表示](img/B18621_14_03.jpg)'
- en: Figure 14.3 – Permissions notation
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – 权限表示
- en: The first dash (`-`) in the figure above means that the entity is a file. If
    it was a directory, it would have been the character `d` instead.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上图中的第一个破折号（`-`）表示该实体是一个文件。如果它是一个目录，它将是字符`d`。
- en: Another way to specify the permissions is the octal notation, which expresses
    multiple permissions types with a single number. For example, if you want to indicate
    read and write permissions using symbolic notation, it would be `rw-`. If this
    was to be represented as an octal number, it would be `6`, because `4` means read
    permission and `2` means write permission. Full permission would be `7`, which
    means *4+2+1* or *read+write+execute* (`rwx`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 指定权限的另一种方式是八进制表示法，它用一个数字表示多种权限类型。例如，如果你想使用符号表示法来指示读和写权限，它将是`rw-`。如果要用八进制数表示，它将是`6`，因为`4`表示读权限，`2`表示写权限。完全权限将是`7`，意味着`4+2+1`或`read+write+execute`（`rwx`）。
- en: 'The following recaps the permissions and their explanations:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对权限及其解释的总结：
- en: '![Figure 14.4 – Groups and permission examples](img/B18621_14_04.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4 – 组和权限示例](img/B18621_14_04.jpg)'
- en: Figure 14.4 – Groups and permission examples
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 – 组和权限示例
- en: 'As you can see, each permission can be expressed with a number `<=7`, which
    is in one digit. Permissions for owner, group, and others can then be expressed
    in octal notation with three digits, as we can see in the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个权限都可以用一个`<=7`的数字表示，这是一个一位数。所有者、组和其他人的权限可以用三位八进制数表示，如下所示：
- en: '![Figure 14.5 – Permission representations examples](img/B18621_14_05.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5 – 权限表示示例](img/B18621_14_05.jpg)'
- en: Figure 14.5 – Permission representations examples
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 – 权限表示示例
- en: You might notice that in octal representation all numbers start with a *0*.
    When working with the filesystem via the command line you can omit the leading
    zero. However, in many cases, when programming, you need to pass it so that the
    compiler will understand that you are writing something in octal notation. You
    might argue that `0777` and `777` are the same number, but the leading zero is
    just a *convention* that tells the compiler that you are using an octal notation
    and the number is octal and not decimal. In other words, `777` is interpreted
    as the decimal number `777`, while `0777` is interpreted as the octal number `0777`,
    which is the decimal number `511`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在八进制表示法中，所有数字都以一个`0`开头。当你通过命令行与文件系统交互时，你可以省略前导零。然而，在许多情况下，当你编程时，你需要传递它，以便编译器理解你正在使用八进制表示法。你可能会争辩说`0777`和`777`是相同的数字，但前导零只是一个*约定*，告诉编译器你正在使用八进制表示法，数字是八进制而不是十进制。换句话说，`777`被解释为十进制数`777`，而`0777`被解释为八进制数`0777`，这是十进制数`511`。
- en: Flags and arguments
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标志和参数
- en: Go provides support for creating command-line interface tools. Often, when we
    write Go programs that are executables, they need to accept various inputs. These
    inputs could include the location of a file, a value to run the program in the
    debug state, getting help to run the program and more. All of this is made possible
    by a package in the Go standard library called `flag`. It is used to allow the
    passing of arguments to the program. A flag is an argument that is passed to a
    Go program. The order of the flags being passed to the Go program using the `flag`
    package does not matter to Go.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了创建命令行界面工具的支持。通常，当我们编写可执行的Go程序时，它们需要接受各种输入。这些输入可能包括文件位置、以调试状态运行程序的价值、获取运行程序的帮助等等。所有这些都可以通过Go标准库中的一个名为`flag`的包来实现。它用于允许将参数传递给程序。标志是传递给Go程序的参数。使用`flag`包传递给Go程序的标志顺序对Go来说并不重要。
- en: 'To define your `flag`, you must know the `flag` type you will be accepting.
    The `flag` package provides many functions for defining flags. Here is a sample
    list:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义你的`flag`，你必须知道你将接受的`flag`类型。`flag`包提供了许多用于定义标志的函数。以下是一个示例列表：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These are some of the functions allowing you to create flags and accept parameters,
    and there is one for each default type in Go.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些允许你创建标志并接受参数的函数，Go中的每个默认类型都有一个。
- en: 'The parameters of the preceding functions can be explained as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数的参数可以这样解释：
- en: '**name**: This parameter is the name of the flag; it is a string type. For
    example, if you pass *file* as an argument, you would access that flag from the
    command line with the following:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：此参数是标志的名称；它是一个字符串类型。例如，如果您传递 *file* 作为参数，您将使用以下方式从命令行访问该标志：'
- en: '[PRE1]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**value**: This parameter is the default value that the flag is set to.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**：此参数是标志设置的默认值。'
- en: '**usage**: This parameter is used to describe the flag’s purpose. It will often
    show up on the command line when you incorrectly set the value. Passing the wrong
    type for a flag will stop the program and cause an error; the usage will be printed.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用法**：此参数用于描述标志的用途。当您错误地设置值时，它通常会出现在命令行上。传递错误的标志类型将停止程序并导致错误；将打印用法。'
- en: '**return value**: This is the address of the variable that stores the value
    of the flag.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回值**：这是存储标志值的变量的地址。'
- en: 'Let’s take a look at a simple example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s go over the preceding code block and analyze it:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面的代码块并分析它：
- en: First, we define the `main` package.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义 `main` 包。
- en: Then we import the `flag` and `fmt` packages.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们导入 `flag` 和 `fmt` 包。
- en: The `v` variable will reference the value for either `-value` or `--value`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`v` 变量将引用 `-value` 或 `--value` 的值。'
- en: The initial value of `*v` is the default value of `-1` before calling `flag.Parse()`
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用 `flag.Parse()` 之前，`*v` 的初始值是 `-1` 的默认值。
- en: After defining the flags, you must call `flag.Parse()` to parse the defined
    flags into the command line.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义标志之后，您必须调用 `flag.Parse()` 将定义的标志解析到命令行中。
- en: Calling `flag.Parse()` places the argument for `-value` into `*v`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `flag.Parse()` 将 `-value` 参数的值放入 `*v`。
- en: Once you have called the `flag.Parse()` function, the flags will be available.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您调用了 `flag.Parse()` 函数，标志将可用。
- en: 'On the command line, execute the following command and you will get the executable
    in the same directory:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行上，执行以下命令，您将在同一目录中获取可执行文件：
- en: '[PRE3]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To get the executable on Windows, run:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 上获取可执行文件，请运行：
- en: '`go build -o` `flagapp.exe main.go`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`go build -o` `flagapp.exe main.go`'
- en: 'There is another way, however, to define these flags. It can be done using
    the following functions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有另一种定义这些标志的方法。可以使用以下函数来完成：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, for each type, there is a function similar to those we’ve already
    seen, whose names end with `Var`. They all accept a pointer to the type of the
    flag as the first argument, and can be used as in the following code snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于每种类型，都有一个类似于我们之前看到的函数，其名称以 `Var` 结尾。它们都接受一个指向标志类型的指针作为第一个参数，并且可以像以下代码片段中那样使用：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code does the same as the previous snippet, however, here’s a quick breakdown:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码与前面的代码片段做的是相同的事情，但是这里有一个简短的分解：
- en: First, we define an integer variable `v`
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个整数变量 `v`
- en: Use its reference as the first parameter of the `IntVar` function
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其引用作为 `IntVar` 函数的第一个参数
- en: Parse the flags
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析标志
- en: Print the `v` variable, which now does not need to be dereferenced as it is
    not the flag but an actual integer
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印 `v` 变量，现在不需要解引用，因为它不是标志而是一个实际的整数
- en: 'If we compile our application, using any of the preceding snippets, as an executable
    called `flagapp`, with the following call in the same directory as the executable,
    we will see that it will print the number `5`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用任何前面的代码片段将我们的应用程序编译为名为 `flagapp` 的可执行文件，并在可执行文件相同的目录中使用以下调用，我们会看到它会打印数字
    `5`：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we call it without the parameter with the following call in the same directory
    as the executable, we will see that it will just print `-1`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在可执行文件相同的目录中使用以下调用而不带参数调用它，我们会看到它只会打印 `-1`：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is because `-1` is the default value.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `-1` 是默认值。
- en: Signals
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号
- en: A signal is an interrupt that is sent to our program or a process by the OS.
    When a signal is delivered to our program, the program will stop what it is doing;
    either it will handle the signal or, if possible, ignore it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是操作系统发送到我们的程序或进程的中断。当信号被发送到我们的程序时，程序将停止正在执行的操作；要么处理信号，要么如果可能的话忽略它。
- en: 'The following is a list of the top three most often used interrupt signals
    for Go programs:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常用于 Go 程序的前三个中断信号列表：
- en: '`SIGINT` (interrupt):'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SIGINT**（中断）：'
- en: 'Situation: This signal is commonly used when a user presses *Ctrl + C* in the
    terminal to interrupt the execution of a program.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**情况**：此信号通常在用户在终端中按下 *Ctrl + C* 以中断程序的执行时使用。'
- en: 'Definition: SIGINT is the interrupt signal. It is used to gracefully terminate
    a program and perform cleanup operations before exiting.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义：SIGINT是中断信号。它用于优雅地终止程序并在退出之前执行清理操作。
- en: '`SIGTERM` (termination):'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGTERM`（终止）：'
- en: 'Situation: This signal is often used to request the termination of a program
    in a controlled manner. It is a generic signal to terminate a process.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 情况：这个信号通常用于以受控方式请求程序终止。它是一个用于终止进程的通用信号。
- en: 'Definition: SIGTERM is the termination signal. It allows a program to perform
    cleanup operations before exiting, similar to SIGINT, but it can be caught and
    handled differently.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义：SIGTERM是终止信号。它允许程序在退出之前执行清理操作，类似于SIGINT，但它可以被捕获并不同方式处理。
- en: '`SIGKILL` (kill):'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGKILL`（终止）：'
- en: 'Situation: This signal is used to forcefully terminate a program. It doesn’t
    allow the program to perform any cleanup operations.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 情况：这个信号用于强制终止程序。它不允许程序执行任何清理操作。
- en: 'Definition: SIGKILL is the kill signal. It immediately terminates a process
    without giving it a chance to clean up resources. It is a more forceful way of
    ending a program compared to SIGTERM.'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义：SIGKILL是终止信号。它立即终止进程，不给它清理资源的机会。与SIGTERM相比，这是一种更加强力的结束程序的方式。
- en: We have seen other Go commands that change the flow of the program; you may
    be wondering which one to use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了其他改变程序流程的Go命令；你可能想知道应该使用哪一个。
- en: 'We use `defer` statements in our applications to perform various cleanup activities,
    such as the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的应用程序中使用`defer`语句来执行各种清理活动，如下所示：
- en: The release of resources
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放资源
- en: The closing of files
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭文件
- en: The closing of database connections
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭数据库连接
- en: Performing the removal of configuration or temporary files
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行移除配置或临时文件的操作
- en: 'In some use cases, it is important that these activities are completed. Using
    a `defer` function will execute it just before returning to the caller. However,
    this does not guarantee that it will always run. There are certain scenarios in
    which the `defer` function won’t execute; for example, an OS interrupt to your
    program:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些用例中，完成这些活动非常重要。使用`defer`函数将在返回调用者之前执行它。然而，这并不能保证它总是会运行。在某些场景中，`defer`函数不会执行；例如，操作系统对程序的干扰：
- en: '`os.Exit(1)`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Exit(1)`'
- en: '*Ctrl + C*'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl + C*'
- en: Other instructions from the OS
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自操作系统的其他指令
- en: 'The preceding scenarios indicate where it may warrant using signals. Signals
    can help us control the exit of our program. Depending on the signal, it could
    terminate our program. For example, the application is running and encounters
    an OS interrupt signal after executing `employee.CalculateSalary()`. In this scenario,
    the `defer` function will not run, thus, `employee.DepositCheck()` does not execute
    and the employee does not get paid. A signal can change the flow of the program.
    The following diagram goes over the scenario we discussed previously:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的场景表明了可能需要使用信号的情况。信号可以帮助我们控制程序的退出。根据信号，它可能会终止我们的程序。例如，应用程序正在运行，并在执行`employee.CalculateSalary()`后遇到操作系统中断信号。在这种情况下，`defer`函数将不会运行，因此，`employee.DepositCheck()`不会执行，员工没有得到工资。信号可以改变程序的流程。以下图表概述了我们之前讨论的场景：
- en: '![Figure 14.6 – Example program with signals](img/B18621_14_06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6 – 带有信号的示例程序](img/B18621_14_06.jpg)'
- en: Figure 14.6 – Example program with signals
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 – 带有信号的示例程序
- en: 'Support for handling signals is built into the Go standard library; it is in
    the `os/signal` package. This package will allow us to make our programs more
    resilient. We want to gracefully shut down when we receive certain signals. The
    first thing to do when handling signals in Go is to trap or catch the signal that
    you are interested in. This is done by using the following function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 处理信号的支持内置在Go标准库中；它在`os/signal`包中。这个包将使我们能够使我们的程序更具弹性。我们希望在接收到某些信号时优雅地关闭。在Go中处理信号的第一件事是捕获或拦截你感兴趣的信号。这是通过使用以下函数来完成的：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function accepts an `os.Signal` data type on a channel, `c`. The `sig`
    argument is a variadic variable of `os.Signal`; we specify zero or more `os.Signal`
    data types that we are interested in. Let’s see a code snippet showing how we
    can use this function to stop the execution of an application:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个`os.Signal`数据类型在通道`c`上，`sig`参数是一个`os.Signal`的可变变量；我们指定零个或多个我们感兴趣的`os.Signal`数据类型。让我们看看一个代码片段，展示我们如何使用这个函数来停止应用程序的执行：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After the definition of the package and importing the packages, we do the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Define a channel to send signals
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a channel that we can use as a flag to stop the execution
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `Notify` to send a `SIGINT` signal
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a goroutine that listens indefinitely to signals and if the signal is
    `SIGINT`, it does some printouts and sends a message to the `done` channel with
    the `true` value
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print a message stating we are waiting for the `done` message to be received
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wait for the `done` message
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print the final message
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we run the application, we will actually see the application terminate
    quite quickly, because we manually send the `SIGINT` signal. In a real-world scenario,
    the application would just wait for the `SIGKILL` signal, which we can manually
    send with *Ctrl* + *X*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see now how we can simulate a cleanup.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 14.01 – simulating a cleanup
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will be catching two signals: `SIGINT` and `SIGTSTP`.
    Once those signals have been caught, we will simulate a cleanup of the files.
    We have not gone over how to remove files yet, so, in this example, we will simply
    create a delay to demonstrate how we can run a function after a signal is caught.
    This is the desired output from this exercise:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `main.go`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add to this file the `main` package and the following `import` statements:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `main()` function, create a channel of the `os.Signal` type. The `sigs`
    channel is used to receive these notifications from the `Notify` method:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, add a `done` channel. The `done` channel is used to let us know when
    the program can exit:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will then add a `signal.Notify` method. The `Notify` method works by sending
    values of the `os.Signal` type to a channel.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recall that the last parameter of the `signal.Notify` method is a variadic parameter
    of the `os.Signal` type.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `signal.Notify` method will receive notifications on the `sigs` channel
    that are of the `syscall.SIGINT` and `syscall.SIGTSTP` types.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generally speaking, the `syscall.SIGINT` type can occur when you press *Ctrl*
    + *C*.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Generally speaking, the `syscall.SIGTSTP` type can occur when you press *Ctrl*
    + *Z*:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create an anonymous function as a goroutine:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Inside the goroutine, create an infinite loop. Inside the infinite loop, we
    will receive a value from the `sigs` channel and store it in the `s` variable,
    `s := <-``sigs`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Create a `switch` statement that evaluates what is received from the channel.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will have two case statements that will check for the `syscall.SIGINT` and
    `syscall.SIGTSP` types.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each case statement will have a message being printed.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will also call our `cleanup()` function.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last statement in the case statement is sending `true` to the `done` channel
    to stop the blocking:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a simple function to mimic a process performing a cleanup:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can try running this program and pressing *Ctrl* + *Z* and *Ctrl* + *C*
    to examine the different results of the program. This only works on Linux and
    macOS:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now run the code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the output:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.7 – Example output](img/B18621_14_07.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – Example output
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have demonstrated the ability to intercept an interrupt
    and perform a task before the application closes. We have the ability to control
    our exit. This is a powerful feature that allows us to perform cleanup actions
    that include removing files, performing a last-minute log, freeing up memory,
    and more. In the next topic, we are going to be creating and writing to files.
    We will be using functions that come from the Go standard package, `os`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Create and write to files
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go language provides support in various ways to create and write to new
    files. We will examine some of the most common ways in which this is performed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'The `os` package provides a simple way in which to create a file. For those
    who are familiar with the `touch` command from the Unix world, it is similar to
    this. Here is the signature of the function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The function will create an empty file much as the `touch` command does. It
    is important to note that if the file already exists, then it will truncate the
    file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'The `os` package’s `Create` function has an input parameter, which is the name
    of the file to create and its location. If successful, it will return a `File`
    type. It is worth noting that the `File` type satisfies the `io.Write` and `io.Read`
    interfaces. This is important to know for later in the chapter:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code simply defines the imports and then, in the `main` function,
    tries to create a file called `test.txt`. If there is an error as a result, it
    panics. The last line before the closing brackets makes sure that whenever the
    application is interrupted, either because it terminates successfully or it panics,
    the file will be closed. We want to make sure we never keep files in an open state.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating an empty file is straightforward, but let’s continue with `os.Create`
    and write to the file we just created. Recall that `os.Create` returns an `*os.File`
    type. There are two methods of interest that can be used to write to the file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '`Write`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WriteString`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see some examples of how to use them:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code is pretty similar to the previous one. We just added two lines where
    we write two sentences to the file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'The first function call is the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we can see that the function needs bytes to be sent, hence we convert
    a string into a slice of bytes with the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The second function just accepts a string and is straightforward to use.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, however, use the package to write to the file directly without having
    to open it first. We can do this using the `os.WriteFile` function:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The method writes the data to the file specified in the `filename` parameter,
    with the given permissions. It will return an error if one exists. Let’s take
    a look at this in action:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As we can see, we can create a file, send a string transformed into a slice
    of bytes, and assign the permission to it, all in one line. It is important to
    also send the permission level and note that we need to use the octal notation
    with the leading zero (this is because without the leading zero, the permission
    will not work as expected).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们可以在一行中创建一个文件，发送一个转换为字节切片的字符串，并为其分配权限。同时，我们也需要发送权限级别，并注意我们需要使用带前导零的八进制表示法（这是因为如果没有前导零，权限将不会按预期工作）。
- en: 'One important thing that we haven’t seen till now is how to check whether a
    file exists or not. This is important because if a file does exist, we might not
    want to truncate it and override it with new content. Let’s see how we can do
    that:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前还没有看到的一个重要问题是，如何检查文件是否存在。这很重要，因为如果文件确实存在，我们可能不想截断它并用新内容覆盖它。让我们看看我们如何做到这一点：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s review what the preceding code does:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面的代码做了什么：
- en: Firstly, we import all the needed packages.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所有需要的包。
- en: 'We then define a string flag that represents the filename:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个表示文件名的字符串标志：
- en: '[PRE27]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, we parse the flags; in this case, the only one is the one we created.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们解析标志；在这种情况下，只有一个是我们创建的。
- en: 'We then get the stats for the file:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们获取文件的状态信息：
- en: '[PRE28]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If there is an error, we check whether this is because the file does not exist:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果出现错误，我们检查这是否是因为文件不存在：
- en: '[PRE29]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If the file does not exist, we print a message and we then terminate the application.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件不存在，我们打印一条消息，然后终止应用程序。
- en: If the error is different from `IsNotExist`, we just then print the error.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果错误与 `IsNotExist` 不同，我们就打印错误信息。
- en: If, finally, the file exists, we then print a set of information related to
    it. The file implements the `FileInfo` interface, which includes in its details
    the modification time, the size, the octal permissions (*mode*), the name, and
    whether it is a directory or not.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果最终文件存在，我们就打印与它相关的一系列信息。该文件实现了 `FileInfo` 接口，其中包含修改时间、大小、八进制权限（*mode*）、名称以及它是否是目录。
- en: You can try to run this application and pass the name of any file. If it exists
    in the directory from which you run the application, you will see all this information
    printed out for you.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试运行这个应用程序并传递任何文件的名称。如果它存在于你运行应用程序的目录中，你将看到所有这些信息被打印出来。
- en: Let’s now see how can we read a whole file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何读取整个文件。
- en: Reading the whole file at once
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一次性读取整个文件
- en: 'In this topic, we will look at two methods that read all the contents of the
    file. These two functions are good to use when your file size is small. While
    these two methods are convenient and easy to use, they have one major drawback.
    That is, if the file size is too large, then it could exhaust the memory available
    on the system. It is important to keep this in mind and understand the limitations
    of the two methods we will be going over in this topic. Even though these methods
    are some of the quickest and easiest ways to load data, it is important to understand
    that they should be limited to small files and not large ones. The method’s signature
    is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将探讨两种读取文件所有内容的方法。这两个函数在文件大小较小时使用起来很好。虽然这两个方法方便且易于使用，但它们有一个主要的缺点。那就是，如果文件太大，可能会耗尽系统上的内存。这一点很重要，我们需要记住，并理解我们将在这个主题中讨论的两个方法的限制。尽管这些方法是一些最快和最简单加载数据的方法，但重要的是要理解它们应该仅限于小文件，而不是大文件。该方法的签名如下：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `ReadFile` function reads the contents of the file and returns it as a
    slice of bytes along with any reported errors. We will look at the error return
    when the `ReadFile` method is used:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadFile` 函数读取文件内容，并以字节切片的形式返回，同时报告任何错误。当使用 `ReadFile` 方法时，我们将查看错误返回值：'
- en: A successful call returns `err ==` `nil`.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功调用返回 `err ==` `nil`。
- en: In some of the other read methods for files, **end of file** (**EOF**) is treated
    as an error. This is not the case for functions that read the entire file into
    memory.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件的其他一些读取方法中，**文件结束**（**EOF**）被视为错误。对于将整个文件读入内存的函数来说，情况并非如此。
- en: 'Let’s see a code snippet that explains how to use this function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个代码片段，解释如何使用这个函数：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As we can see, what we do in this code is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们在代码中执行的操作如下：
- en: We do our imports
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们执行导入操作
- en: We read the contents of the whole `test.txt` file
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们读取整个 `test.txt` 文件的内容
- en: We print an error if it occurs
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发生错误，我们打印错误信息
- en: 'Else, we print the content of the file:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，我们打印文件的内容：
- en: '[PRE32]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As the content is retrieved as a slice of bytes, we need to convert it to a
    string to visualize it. Let’s see how to read, instead, the file character by
    character in the next snippet:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s analyze this snippet in more detail as it is a bit complicated. In this
    case, after importing the required packages, we do the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file using the `Open` function:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We check whether the error is `nil`, and if is not, we print the error and
    exit:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We then create a slice of bytes of size `1`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We then make an infinite loop, and inside it, we read the file into the buffer:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We then check whether there is an error, which also means that we reached the
    end of the file, in which case we stop the loop:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If the error is not `nil` but is not `end of file`, we carry on with the loop,
    ignoring the error.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If there is no error and the content has been read, then we display the content:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice that we read one character at a time, as we made a buffer (slice of bytes)
    of size one. This might be resource intensive, so you might change this value
    to any other value for your particular case and needs.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 14.02 – backing up files
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Oftentimes, when working with files, we need to back up a file before making
    changes to it. This is for instances where we might make mistakes or want the
    original file for auditing purposes. In this exercise, we will take an existing
    file called `note.txt` and back it up to `backupFile.txt`. We will then open `note.txt`
    and add some additional notes to the end of the file. Our directory will contain
    the following files:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8 – Backing up files to the directory](img/B18621_14_08.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: Figure 14.8 – Backing up files to the directory
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'We must first create the `note.txt` file in the same directory as our executable.
    This file can be blank or contain some sample data such as this:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.9 – Example of the notes.txt file content](img/B18621_14_09.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: Figure 14.9 – Example of the notes.txt file content
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Create a Go file called `main.go`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This program will be part of the `main` package.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the imports, as seen in the following code:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a custom error that will be used when the working file (`note.txt`)
    is not found:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a function to perform the backup. This function is responsible for taking
    the working file and storing its content in the `backup` file. This function accepts
    two arguments. The `working` parameter is the file path of the file that you currently
    are working on:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Inside this function, we will need to check to see whether the working file
    exists. It must first exist before we can read its contents and store them in
    our backup file.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are able to check to see whether the error is one where the file does not
    exist by using `os.IsNotExist(err)`.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the file does not exist, we will return with our custom error, `ErrWorkingFileNotFound`:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we need to open the working file and store the `os.File` returned by
    the function to the `workFile` variable:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We need to read the contents of `workFile`. We will be using the `io.ReadAll`
    method to get all the contents of `workFile`. `workFile` is of the `os.File` type,
    which satisfies the `io.Reader` interface; this allows us to pass it to `ioutil.ReadFile`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check to see whether there is an error:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `content` variable contains the data of the `workFile` represented as a
    slice of bytes. That data needs to be written to the backup file. We will implement
    the code that will write the data of the `content` variable to the backup file.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The content stores the `[]byte` data that gets returned from the function. This
    is the entire contents of the file stored in the variable.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use the `os.Writefile` method. If the backup file does not exist, it
    will create the file. If the backup file does exist, it will overwrite the file
    with the content variable data:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We need to return nil, indicating that, at this juncture, we have not encountered
    any errors:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Create a function that will append data to our working file.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the function `addNotes`; this will accept the location of our working
    file and a string argument that will be appended to the working file. The function
    will need to return an error:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Inside the `addNotes` function, add a line that will append a new line to each
    note’s string. This will place each note on a separate line:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we will open the working file and allow for appending to the file. The
    `os.OpenFile()` function will create the file if it does not exist. Check for
    any errors:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After opening a file and checking for an error, we should make sure that it
    closes when the function exits by using the defer function, `f.Close()`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The final step of the function is to write the contents of the note to the
    `workingFile` variable. We can use the `Write` method to accomplish this:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the `main()` function, we will initialize three variables; the `backupFile`
    variable contains the name of the file for backing up our `workingFile` variable,
    while the `data` variable is what we will be writing to our `workingFile` variable:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Call our `createBackup()` function to back up our `workingFile`. Check for
    errors after calling the function:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Create a `for` loop that will iterate `10` times.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With each iteration, we set our `note` variable to the `data` variable plus
    the `i` variable of our loop.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since our `note` variable is a string and our `i` variable is an `int`, we will
    need to convert `i` to a string using the `strconv.Itoa(i)` method.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Call our `addNotes()` function and pass the `workingFile` and our `note` variables.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check for any errors returned from the function:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Run the program:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Evaluate the changes to the files after running the program.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are the results after running the program:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10 – Result of backup](img/B18621_14_10.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: Figure 14.10 – Result of backup
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see next how to handle CSV files with Go.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: CSV
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common ways a file is structured is as a comma-separated value.
    This is a clear-text file that contains data, which is basically represented as
    rows and columns. Frequently, these files are used to exchange data. A CSV file
    has a simple structure. Each piece of data is separated by a comma and then a
    new line for another record. An example of a CSV file is as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You will, at some point in your life, come across CSV files as they are very
    common. The Go programming language has a standard library that is used for handling
    CSV files: `encoding/csv`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here we are defining a string with the content of our CSV file:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And then we use the following line to read the content of the whole CSV:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The following code line creates a string reader that can be used by the `csv.NewReader`
    function. We cannot, in fact, pass just a string to the CSV reader as it needs
    an `io.Reader` instance, which in this case is provided by `strings.NewReader`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We then make an infinite loop, which gets terminated when we reach the end
    of the CSV:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As we did earlier in this chapter, we then check for another error and we exit
    if we find it; otherwise, we print the record, which is retrieved via the `Read()`
    method of the CSV reader.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we saw how to get a whole record at once, meaning one
    row of our CSV. However, there is a way to access each column in the returned
    row, that is, each single element of the row.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look back at the previous snippet of code, you will see that the rows
    are returned with the following:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We then just printed the content, but this is an actual slice of strings, so
    we can get each item with its index. Let’s say we are just interested in visualizing
    the names of the people in the CSV. To do so, we can modify the `fmt.Println(record)`
    line as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: With this, we will only see a list of names.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Embedding
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, you will need to present to the user some complex text, maybe an HTML
    page, and it might be impractical to define the whole file as a string. You might
    read the file, as we learned in this chapter, and then use it as a template. You
    might want to display an image, again by opening and reading the file containing
    the image. One of the great features of Go is that even if you can build your
    application as a single binary, you will also have external dependencies that
    need to be distributed with your binary. Another issue is that reading from a
    file might be slow, so it would be great if we could embed files inside our Go
    application. This will allow us to just distribute one binary including all our
    assets. In the past, this required external libraries, but now Go includes a package
    called `embed` that allows you to easily embed any file into your binary so that
    you do not need to share other dependencies. Let’s see an example of how we can
    do that.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next snippet, we will create a very simple template file and will read
    and parse it. Then we will use it to display some greetings. Let’s start with
    the template. We need a folder structure like this: `embedding_example/main.go`
    `and` `templates/template.txt`.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: The content of the `template.txt` file is `Hello {{.Name}}`, which is pretty
    simple. This simply means that when we use this template and pass a variable called
    `Name`, the engine will substitute the variable with anything we pass as a value.
    You do not need, at this stage, to understand much more about the templating system.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see now how we can make use of this template written in an external file,
    without having to read it every time we run the application:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We start importing all the necessary packages. After that, we define a struct
    called `Person` that will hold the name of the person to greet. The next part
    is the important bit:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This defines an `f` variable of type `embed.FS`, which stands for *embedded
    file system* and will work as a virtual filesystem for us. The directive on top
    of the declaration needs to be just above the variable we define, otherwise the
    compiler will prompt us with an error. This directive tells the Go compiler that
    it needs to read and embed whatever is inside the `templates` folder and make
    it available. Be careful if you add a folder with too many big files, as your
    final binary will increase in size.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `main` function, we then instantiate a struct of type `Person` where
    the `Name` attribute has the value `John`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we use the `ParseFS` function of the `template` package, and we
    use it to read from the embedded file system, represented by the variable `f`,
    the file called `template.txt` from inside the `templates` folder.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we just execute the templating engine, passing the previously created
    struct. If you run the application, you will see the message printed out as follows:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, this does not seem much, but try running the following command:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, copy your executable to a different location where the `template` folder
    is not available. If you now run from that new folder, you will still see the
    exact same message:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The key takeaway here is that the directive takes the whole filesystem from
    the point you specify, in this case, the `templates` folder, and creates a virtual
    filesystem. From this virtual filesystem, you can read all the files, but the
    content of the whole folder will actually be stored inside the final binary of
    your application. This feature is very powerful but should be used wisely, as
    the final binary could easily become very big.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gained an understanding of how Go views and uses file permissions.
    We learned that file permissions can be represented as symbolic and octal notations.
    We discovered that the Go standard library has built-in support for opening, reading,
    writing, creating, deleting, and appending data to a file. We looked at the `flag`
    package and how it provides functionality to create command-line applications
    to accept arguments.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Using the `flag` package, we could also print out `usage` statements that pertained
    to our command-line application.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Then, we demonstrated how OS signals can impact our Go program; however, by
    using the Go standard library, we can capture OS signals and, if applicable, control
    how we want to exit our program.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that Go has a standard library for working with CSV files. In
    our previous work with files, we saw that we can also work with files that are
    structured as CSV files. That Go CSV package provides the ability to iterate over
    the contents of the file. The CSV file can be viewed as rows and columns similar
    to database tables.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how to embed files inside the final binary of the application
    and how to use this feature to speed up the application and avoid shipping external
    dependencies with the binary. In the next chapter, we will look at how to connect
    to databases and execute SQL statements against a database. This will demonstrate
    the ability of Go to be used for applications that require a backend for storing
    data.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
