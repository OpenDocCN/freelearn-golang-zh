- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: File and Systems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件和系统
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: We will see in this chapter how to interact with the filesystem, which means
    we will read files, manipulate them, store them for later use, and get information
    about them. We will also cover how to read folders so that we can search for the
    files we need, and will examine some specific file formats such as CSV, which
    is commonly used to share information in tabular form.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何与文件系统交互，这意味着我们将读取文件、操作它们、为以后使用存储它们，并获取有关它们的信息。我们还将介绍如何读取文件夹，以便我们可以搜索所需的文件，并检查一些特定的文件格式，例如CSV，它通常用于以表格形式共享信息。
- en: Another thing you will learn in this chapter is how to send some information
    to your application in the form of flags.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你还将学习如何以标志的形式将一些信息发送到你的应用程序中。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you''ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter14](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter14).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要Go版本1.21或更高版本。本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter14](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter14)。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we looked at how to write simple command-line applications.
    We will carry on with this here, introducing ways to pass parameters to our application
    so that it behaves differently depending on the values we send.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了如何编写简单的命令行应用程序。在这里，我们将继续这一主题，介绍向应用程序传递参数的方法，以便它根据我们发送的值以不同的方式表现。
- en: After that, we will interact with the filesystem. The levels we are going to
    be working with the filesystem at are the file, directory, and permission levels.
    We will tackle everyday issues that developers face when working with the filesystem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将与文件系统交互。我们将要处理的文件系统级别是文件、目录和权限级别。我们将解决开发人员在处理文件系统时面临的日常问题。
- en: We will learn how to create a command-line application that will read and write
    files. Along with discussing what happens when we get a signal interrupt from
    the OS, we will demonstrate how to perform cleanup actions before our application
    stops running. We will also handle a scenario of receiving an interrupt to our
    application and handling how the application exits. There are times when your
    application is running, and a signal comes from the OS to shut down the application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何创建一个命令行应用程序，该程序可以读取和写入文件。除了讨论从操作系统接收到信号中断时会发生什么之外，我们还将演示在应用程序停止运行之前执行清理操作的方法。我们还将处理应用程序接收到中断的情况，并处理应用程序退出的方式。有时，当你的应用程序正在运行时，操作系统会发送一个信号来关闭应用程序。
- en: In such instances, we may want to log information at the time of the shutdown
    for debugging purposes; this will help us to understand why the application shuts
    down. We will look at how we can do that in this chapter. However, before we start
    tackling these issues, let’s get a basic understanding of the filesystem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能希望在关闭时记录信息以进行调试；这将帮助我们了解应用程序为何关闭。在本章中，我们将探讨如何做到这一点。然而，在我们开始处理这些问题之前，让我们先对文件系统有一个基本的了解。
- en: Filesystem
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统
- en: A filesystem controls how data is named, stored, accessed, and retrieved on
    a device such as a hard drive, USB, DVD, or another medium. There is no one filesystem,
    and how it behaves largely depends on what OS you are using. You must have heard
    of `FAT`, `FAT32`, `NFTS`, and so on, which are all different filesystems and
    are used normally by Windows. Linux can read and write to them, but it generally
    uses a different family of filesystems that have names starting with `ext`, which
    stands for *extended*. You do not need to have a deep understanding of filesystems,
    but, as a software engineer, it is good to at least have a basic understanding
    of the subject.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统控制数据在硬盘、USB、DVD或其他介质上的命名、存储、访问和检索方式。没有统一的文件系统，其行为在很大程度上取决于你使用的操作系统。你一定听说过`FAT`、`FAT32`、`NFTS`等等，这些都是不同的文件系统，通常在Windows中使用。Linux可以读写这些文件系统，但通常使用以`ext`开头的不同文件系统家族，`ext`代表*扩展*。你不需要对文件系统有深入的了解，但作为一个软件工程师，至少对这一主题有一个基本了解是好的。
- en: What interests us in this chapter, however, is that each filesystem has its
    conventions for naming files, such as the length of the filename, the specific
    characters that can be used, how long the suffix or file extension can be, and
    so on. Each file has information or metadata, data embedded within a file or associated
    with it that describes or provides information about the file. This metadata about
    a file can contain information such as file size, location, access permissions,
    date created, date modified, and more. This is all the information that can be
    accessed by our applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在本章中，我们感兴趣的是每个文件系统都有自己的文件命名约定，例如文件名的长度、可以使用的特定字符、后缀或文件扩展名的长度等。每个文件都有信息或元数据，这些信息或元数据是嵌入在文件中或与文件关联的，用于描述或提供有关文件的信息。关于文件的这个元数据可以包含诸如文件大小、位置、访问权限、创建日期、修改日期等信息。这是我们应用程序可以访问的所有信息。
- en: 'Files are generally placed in some sort of hierarchal structure. This structure
    typically consists of multiple directories and sub-directories. The placement
    of the files within the directories is a way to organize your data and get access
    to the file or directory:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 文件通常被放置在某种层次结构中。这种结构通常由多个目录和子目录组成。文件在目录中的放置是一种组织数据并获得对文件或目录访问的方式：
- en: '![Figure 14.1 – The Linux filesystem](img/B18621_14_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.1 – Linux 文件系统](img/B18621_14_01.jpg)'
- en: Figure 14.1 – The Linux filesystem
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – Linux 文件系统
- en: As shown in *Figure 14**.1*, directories can be nested. In a normal Linux filesystem,
    we will see that there is a root directory, which is defined by the name **/**,
    and everything else is a subdirectory of it. The **home** directory generally
    holds data for each user of the system, and in the case shown above, **matt**
    is a directory holding a **docs** and an **mp3** directory, which are subdirectories
    of **matt**, but **matt** itself is a subdirectory of **home**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *图 14.1* 所示，目录可以嵌套。在正常的 Linux 文件系统中，我们将看到有一个根目录，它由名称 **/** 定义，而其他所有内容都是它的子目录。**家**目录通常包含系统每个用户的文件，在上面的示例中，**matt**
    是一个包含 **docs** 和 **mp3** 目录的目录，它们是 **matt** 的子目录，但 **matt** 本身是 **home** 的子目录。
- en: In the next topic, we will be looking at file permissions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将探讨文件权限。
- en: File permissions
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件权限
- en: Permissions are an important aspect that you need to understand when dealing
    with file creation and modifications.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文件创建和修改时，权限是一个重要的方面，你需要理解。
- en: We need to look at various permission types that can be assigned to a file.
    We also need to consider how those permission types are represented in symbolic
    and octal notation.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要查看可以分配给文件的各个权限类型。我们还需要考虑这些权限类型在符号和八进制表示法中的表示方式。
- en: Go uses the Unix nomenclature to represent permission types. They are represented
    in symbolic notation or octal notation. The three permission types are *Read*,
    *Write*, and *Execute*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Go 使用 Unix 命名法来表示权限类型。它们以符号表示法或八进制表示法表示。三种权限类型是 *读取*、*写入* 和 *执行*。
- en: '![Figure 14.2 – File permissions](img/B18621_14_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.2 – 文件权限](img/B18621_14_02.jpg)'
- en: Figure 14.2 – File permissions
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – 文件权限
- en: 'Permissions for every file are assigned to three different entities that can
    be individuals or groups. This means that a user can be part of a group that has
    access to some files, as a result of which the user inherits access to those files.
    It is not possible to assign permissions for a file to a specific user; rather,
    we add the user to a group and then assign permissions to that group. That said,
    it is possible to assign permission for a file to the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件的权限都分配给了三个不同的实体，这些实体可以是个人或组。这意味着一个用户可以是某个有权访问某些文件的组的成员，因此用户继承了这些文件的访问权限。无法将文件权限分配给特定用户；相反，我们将用户添加到组中，然后为该组分配权限。话虽如此，将文件权限分配给以下内容是可能的：
- en: '**Owner**: This is an individual, a single person such as John Smith, or the
    root user who is the owner of the file. In general, it is the individual who created
    the file.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有者**：这是一个个人，如约翰·史密斯这样的单个个人，或者是文件的所有者 root 用户。一般来说，这是创建文件的个人。'
- en: '**Group**: A group typically consists of multiple individuals or other groups.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组**：组通常由多个个人或其他组组成。'
- en: '**Others**: Those that are not in a group or the owner.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他用户**：那些不在组中或不是所有者的用户。'
- en: 'Let’s see now, how permissions are indicated via symbolic notation. The following
    diagram is an example of a file and its permissions on a Unix machine:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看，如何通过符号表示法来表示权限。以下图表是一个文件及其在 Unix 机器上权限的示例：
- en: '![Figure 14.3 – Permissions notation](img/B18621_14_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3 – 权限表示](img/B18621_14_03.jpg)'
- en: Figure 14.3 – Permissions notation
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – 权限表示
- en: The first dash (`-`) in the figure above means that the entity is a file. If
    it was a directory, it would have been the character `d` instead.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上图中的第一个破折号（`-`）表示该实体是一个文件。如果它是一个目录，它将是字符`d`。
- en: Another way to specify the permissions is the octal notation, which expresses
    multiple permissions types with a single number. For example, if you want to indicate
    read and write permissions using symbolic notation, it would be `rw-`. If this
    was to be represented as an octal number, it would be `6`, because `4` means read
    permission and `2` means write permission. Full permission would be `7`, which
    means *4+2+1* or *read+write+execute* (`rwx`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 指定权限的另一种方式是八进制表示法，它用一个数字表示多种权限类型。例如，如果你想使用符号表示法来指示读和写权限，它将是`rw-`。如果要用八进制数表示，它将是`6`，因为`4`表示读权限，`2`表示写权限。完全权限将是`7`，意味着`4+2+1`或`read+write+execute`（`rwx`）。
- en: 'The following recaps the permissions and their explanations:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对权限及其解释的总结：
- en: '![Figure 14.4 – Groups and permission examples](img/B18621_14_04.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4 – 组和权限示例](img/B18621_14_04.jpg)'
- en: Figure 14.4 – Groups and permission examples
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 – 组和权限示例
- en: 'As you can see, each permission can be expressed with a number `<=7`, which
    is in one digit. Permissions for owner, group, and others can then be expressed
    in octal notation with three digits, as we can see in the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个权限都可以用一个`<=7`的数字表示，这是一个一位数。所有者、组和其他人的权限可以用三位八进制数表示，如下所示：
- en: '![Figure 14.5 – Permission representations examples](img/B18621_14_05.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5 – 权限表示示例](img/B18621_14_05.jpg)'
- en: Figure 14.5 – Permission representations examples
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 – 权限表示示例
- en: You might notice that in octal representation all numbers start with a *0*.
    When working with the filesystem via the command line you can omit the leading
    zero. However, in many cases, when programming, you need to pass it so that the
    compiler will understand that you are writing something in octal notation. You
    might argue that `0777` and `777` are the same number, but the leading zero is
    just a *convention* that tells the compiler that you are using an octal notation
    and the number is octal and not decimal. In other words, `777` is interpreted
    as the decimal number `777`, while `0777` is interpreted as the octal number `0777`,
    which is the decimal number `511`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，在八进制表示法中，所有数字都以一个`0`开头。当你通过命令行与文件系统交互时，你可以省略前导零。然而，在许多情况下，当你编程时，你需要传递它，以便编译器理解你正在使用八进制表示法。你可能会争辩说`0777`和`777`是相同的数字，但前导零只是一个*约定*，告诉编译器你正在使用八进制表示法，数字是八进制而不是十进制。换句话说，`777`被解释为十进制数`777`，而`0777`被解释为八进制数`0777`，这是十进制数`511`。
- en: Flags and arguments
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标志和参数
- en: Go provides support for creating command-line interface tools. Often, when we
    write Go programs that are executables, they need to accept various inputs. These
    inputs could include the location of a file, a value to run the program in the
    debug state, getting help to run the program and more. All of this is made possible
    by a package in the Go standard library called `flag`. It is used to allow the
    passing of arguments to the program. A flag is an argument that is passed to a
    Go program. The order of the flags being passed to the Go program using the `flag`
    package does not matter to Go.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了创建命令行界面工具的支持。通常，当我们编写可执行的Go程序时，它们需要接受各种输入。这些输入可能包括文件位置、以调试状态运行程序的价值、获取运行程序的帮助等等。所有这些都可以通过Go标准库中的一个名为`flag`的包来实现。它用于允许将参数传递给程序。标志是传递给Go程序的参数。使用`flag`包传递给Go程序的标志顺序对Go来说并不重要。
- en: 'To define your `flag`, you must know the `flag` type you will be accepting.
    The `flag` package provides many functions for defining flags. Here is a sample
    list:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义你的`flag`，你必须知道你将接受的`flag`类型。`flag`包提供了许多用于定义标志的函数。以下是一个示例列表：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These are some of the functions allowing you to create flags and accept parameters,
    and there is one for each default type in Go.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些允许你创建标志并接受参数的函数，Go中的每个默认类型都有一个。
- en: 'The parameters of the preceding functions can be explained as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数的参数可以这样解释：
- en: '**name**: This parameter is the name of the flag; it is a string type. For
    example, if you pass *file* as an argument, you would access that flag from the
    command line with the following:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：此参数是标志的名称；它是一个字符串类型。例如，如果您传递 *file* 作为参数，您将使用以下方式从命令行访问该标志：'
- en: '[PRE1]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**value**: This parameter is the default value that the flag is set to.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**：此参数是标志设置的默认值。'
- en: '**usage**: This parameter is used to describe the flag’s purpose. It will often
    show up on the command line when you incorrectly set the value. Passing the wrong
    type for a flag will stop the program and cause an error; the usage will be printed.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用法**：此参数用于描述标志的用途。当您错误地设置值时，它通常会出现在命令行上。传递错误的标志类型将停止程序并导致错误；将打印用法。'
- en: '**return value**: This is the address of the variable that stores the value
    of the flag.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回值**：这是存储标志值的变量的地址。'
- en: 'Let’s take a look at a simple example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s go over the preceding code block and analyze it:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面的代码块并分析它：
- en: First, we define the `main` package.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义 `main` 包。
- en: Then we import the `flag` and `fmt` packages.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们导入 `flag` 和 `fmt` 包。
- en: The `v` variable will reference the value for either `-value` or `--value`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`v` 变量将引用 `-value` 或 `--value` 的值。'
- en: The initial value of `*v` is the default value of `-1` before calling `flag.Parse()`
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在调用 `flag.Parse()` 之前，`*v` 的初始值是 `-1` 的默认值。
- en: After defining the flags, you must call `flag.Parse()` to parse the defined
    flags into the command line.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义标志之后，您必须调用 `flag.Parse()` 将定义的标志解析到命令行中。
- en: Calling `flag.Parse()` places the argument for `-value` into `*v`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `flag.Parse()` 将 `-value` 参数的值放入 `*v`。
- en: Once you have called the `flag.Parse()` function, the flags will be available.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您调用了 `flag.Parse()` 函数，标志将可用。
- en: 'On the command line, execute the following command and you will get the executable
    in the same directory:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行上，执行以下命令，您将在同一目录中获取可执行文件：
- en: '[PRE3]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To get the executable on Windows, run:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Windows 上获取可执行文件，请运行：
- en: '`go build -o` `flagapp.exe main.go`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`go build -o` `flagapp.exe main.go`'
- en: 'There is another way, however, to define these flags. It can be done using
    the following functions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有另一种定义这些标志的方法。可以使用以下函数来完成：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As you can see, for each type, there is a function similar to those we’ve already
    seen, whose names end with `Var`. They all accept a pointer to the type of the
    flag as the first argument, and can be used as in the following code snippet:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，对于每种类型，都有一个类似于我们之前看到的函数，其名称以 `Var` 结尾。它们都接受一个指向标志类型的指针作为第一个参数，并且可以像以下代码片段中那样使用：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code does the same as the previous snippet, however, here’s a quick breakdown:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码与前面的代码片段做的是相同的事情，但是这里有一个简短的分解：
- en: First, we define an integer variable `v`
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个整数变量 `v`
- en: Use its reference as the first parameter of the `IntVar` function
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其引用作为 `IntVar` 函数的第一个参数
- en: Parse the flags
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析标志
- en: Print the `v` variable, which now does not need to be dereferenced as it is
    not the flag but an actual integer
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印 `v` 变量，现在不需要解引用，因为它不是标志而是一个实际的整数
- en: 'If we compile our application, using any of the preceding snippets, as an executable
    called `flagapp`, with the following call in the same directory as the executable,
    we will see that it will print the number `5`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用任何前面的代码片段将我们的应用程序编译为名为 `flagapp` 的可执行文件，并在可执行文件相同的目录中使用以下调用，我们会看到它会打印数字
    `5`：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we call it without the parameter with the following call in the same directory
    as the executable, we will see that it will just print `-1`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在可执行文件相同的目录中使用以下调用而不带参数调用它，我们会看到它只会打印 `-1`：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is because `-1` is the default value.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `-1` 是默认值。
- en: Signals
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号
- en: A signal is an interrupt that is sent to our program or a process by the OS.
    When a signal is delivered to our program, the program will stop what it is doing;
    either it will handle the signal or, if possible, ignore it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 信号是操作系统发送到我们的程序或进程的中断。当信号被发送到我们的程序时，程序将停止正在执行的操作；要么处理信号，要么如果可能的话忽略它。
- en: 'The following is a list of the top three most often used interrupt signals
    for Go programs:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最常用于 Go 程序的前三个中断信号列表：
- en: '`SIGINT` (interrupt):'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SIGINT**（中断）：'
- en: 'Situation: This signal is commonly used when a user presses *Ctrl + C* in the
    terminal to interrupt the execution of a program.'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**情况**：此信号通常在用户在终端中按下 *Ctrl + C* 以中断程序的执行时使用。'
- en: 'Definition: SIGINT is the interrupt signal. It is used to gracefully terminate
    a program and perform cleanup operations before exiting.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义：SIGINT是中断信号。它用于优雅地终止程序并在退出之前执行清理操作。
- en: '`SIGTERM` (termination):'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGTERM`（终止）：'
- en: 'Situation: This signal is often used to request the termination of a program
    in a controlled manner. It is a generic signal to terminate a process.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 情况：这个信号通常用于以受控方式请求程序终止。它是一个用于终止进程的通用信号。
- en: 'Definition: SIGTERM is the termination signal. It allows a program to perform
    cleanup operations before exiting, similar to SIGINT, but it can be caught and
    handled differently.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义：SIGTERM是终止信号。它允许程序在退出之前执行清理操作，类似于SIGINT，但它可以被捕获并不同方式处理。
- en: '`SIGKILL` (kill):'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGKILL`（终止）：'
- en: 'Situation: This signal is used to forcefully terminate a program. It doesn’t
    allow the program to perform any cleanup operations.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 情况：这个信号用于强制终止程序。它不允许程序执行任何清理操作。
- en: 'Definition: SIGKILL is the kill signal. It immediately terminates a process
    without giving it a chance to clean up resources. It is a more forceful way of
    ending a program compared to SIGTERM.'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义：SIGKILL是终止信号。它立即终止进程，不给它清理资源的机会。与SIGTERM相比，这是一种更加强力的结束程序的方式。
- en: We have seen other Go commands that change the flow of the program; you may
    be wondering which one to use.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了其他改变程序流程的Go命令；你可能想知道应该使用哪一个。
- en: 'We use `defer` statements in our applications to perform various cleanup activities,
    such as the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的应用程序中使用`defer`语句来执行各种清理活动，如下所示：
- en: The release of resources
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 释放资源
- en: The closing of files
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭文件
- en: The closing of database connections
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭数据库连接
- en: Performing the removal of configuration or temporary files
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行移除配置或临时文件的操作
- en: 'In some use cases, it is important that these activities are completed. Using
    a `defer` function will execute it just before returning to the caller. However,
    this does not guarantee that it will always run. There are certain scenarios in
    which the `defer` function won’t execute; for example, an OS interrupt to your
    program:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些用例中，完成这些活动非常重要。使用`defer`函数将在返回调用者之前执行它。然而，这并不能保证它总是会运行。在某些场景中，`defer`函数不会执行；例如，操作系统对程序的干扰：
- en: '`os.Exit(1)`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Exit(1)`'
- en: '*Ctrl + C*'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl + C*'
- en: Other instructions from the OS
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自操作系统的其他指令
- en: 'The preceding scenarios indicate where it may warrant using signals. Signals
    can help us control the exit of our program. Depending on the signal, it could
    terminate our program. For example, the application is running and encounters
    an OS interrupt signal after executing `employee.CalculateSalary()`. In this scenario,
    the `defer` function will not run, thus, `employee.DepositCheck()` does not execute
    and the employee does not get paid. A signal can change the flow of the program.
    The following diagram goes over the scenario we discussed previously:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的场景表明了可能需要使用信号的情况。信号可以帮助我们控制程序的退出。根据信号，它可能会终止我们的程序。例如，应用程序正在运行，并在执行`employee.CalculateSalary()`后遇到操作系统中断信号。在这种情况下，`defer`函数将不会运行，因此，`employee.DepositCheck()`不会执行，员工没有得到工资。信号可以改变程序的流程。以下图表概述了我们之前讨论的场景：
- en: '![Figure 14.6 – Example program with signals](img/B18621_14_06.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6 – 带有信号的示例程序](img/B18621_14_06.jpg)'
- en: Figure 14.6 – Example program with signals
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 – 带有信号的示例程序
- en: 'Support for handling signals is built into the Go standard library; it is in
    the `os/signal` package. This package will allow us to make our programs more
    resilient. We want to gracefully shut down when we receive certain signals. The
    first thing to do when handling signals in Go is to trap or catch the signal that
    you are interested in. This is done by using the following function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 处理信号的支持内置在Go标准库中；它在`os/signal`包中。这个包将使我们能够使我们的程序更具弹性。我们希望在接收到某些信号时优雅地关闭。在Go中处理信号的第一件事是捕获或拦截你感兴趣的信号。这是通过使用以下函数来完成的：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This function accepts an `os.Signal` data type on a channel, `c`. The `sig`
    argument is a variadic variable of `os.Signal`; we specify zero or more `os.Signal`
    data types that we are interested in. Let’s see a code snippet showing how we
    can use this function to stop the execution of an application:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个`os.Signal`数据类型在通道`c`上，`sig`参数是一个`os.Signal`的可变变量；我们指定零个或多个我们感兴趣的`os.Signal`数据类型。让我们看看一个代码片段，展示我们如何使用这个函数来停止应用程序的执行：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After the definition of the package and importing the packages, we do the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义包和导入包之后，我们进行以下操作：
- en: Define a channel to send signals
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个用于发送信号的通道。
- en: Define a channel that we can use as a flag to stop the execution
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个我们可以用作停止执行的标志的通道。
- en: Use `Notify` to send a `SIGINT` signal
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Notify` 发送 `SIGINT` 信号。
- en: Create a goroutine that listens indefinitely to signals and if the signal is
    `SIGINT`, it does some printouts and sends a message to the `done` channel with
    the `true` value
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个无限监听信号的协程，如果信号是 `SIGINT`，则进行一些打印输出，并向 `done` 通道发送带有 `true` 值的消息。
- en: Print a message stating we are waiting for the `done` message to be received
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印一条消息，说明我们正在等待接收 `done` 消息。
- en: Wait for the `done` message
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待 `done` 消息。
- en: Print the final message
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印最终的消息。
- en: When we run the application, we will actually see the application terminate
    quite quickly, because we manually send the `SIGINT` signal. In a real-world scenario,
    the application would just wait for the `SIGKILL` signal, which we can manually
    send with *Ctrl* + *X*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，实际上我们会看到应用程序很快就会终止，因为我们手动发送了 `SIGINT` 信号。在现实世界的场景中，应用程序会等待 `SIGKILL`
    信号，我们可以通过手动发送 *Ctrl* + *X* 来发送这个信号。
- en: Let’s see now how we can simulate a cleanup.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何模拟清理操作。
- en: Exercise 14.01 – simulating a cleanup
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 14.01 – 模拟清理操作。
- en: 'In this exercise, we will be catching two signals: `SIGINT` and `SIGTSTP`.
    Once those signals have been caught, we will simulate a cleanup of the files.
    We have not gone over how to remove files yet, so, in this example, we will simply
    create a delay to demonstrate how we can run a function after a signal is caught.
    This is the desired output from this exercise:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将捕获两个信号：`SIGINT` 和 `SIGTSTP`。一旦捕获到这些信号，我们将模拟文件清理。我们还没有讲解如何删除文件，所以在这个例子中，我们将简单地创建一个延迟来演示我们如何在捕获到信号后运行一个函数。这是这个练习期望的输出：
- en: Create a file called `main.go`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件。
- en: 'Add to this file the `main` package and the following `import` statements:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向这个文件添加 `main` 包和以下 `import` 语句：
- en: '[PRE10]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `main()` function, create a channel of the `os.Signal` type. The `sigs`
    channel is used to receive these notifications from the `Notify` method:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，创建一个 `os.Signal` 类型的通道。`sigs` 通道用于接收来自 `Notify` 方法的这些通知：
- en: '[PRE11]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, add a `done` channel. The `done` channel is used to let us know when
    the program can exit:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个 `done` 通道。`done` 通道用于通知我们程序何时可以退出：
- en: '[PRE12]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will then add a `signal.Notify` method. The `Notify` method works by sending
    values of the `os.Signal` type to a channel.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将添加一个 `signal.Notify` 方法。`Notify` 方法通过向通道发送 `os.Signal` 类型的值来工作。
- en: Recall that the last parameter of the `signal.Notify` method is a variadic parameter
    of the `os.Signal` type.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回想一下，`signal.Notify` 方法的最后一个参数是 `os.Signal` 类型的可变参数。
- en: The `signal.Notify` method will receive notifications on the `sigs` channel
    that are of the `syscall.SIGINT` and `syscall.SIGTSTP` types.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`signal.Notify` 方法将在 `sigs` 通道上接收 `syscall.SIGINT` 和 `syscall.SIGTSTP` 类型的通知。'
- en: Generally speaking, the `syscall.SIGINT` type can occur when you press *Ctrl*
    + *C*.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常情况下，`syscall.SIGINT` 类型会在你按下 *Ctrl* + *C* 时发生。
- en: 'Generally speaking, the `syscall.SIGTSTP` type can occur when you press *Ctrl*
    + *Z*:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常情况下，`syscall.SIGTSTP` 类型会在你按下 *Ctrl* + *Z* 时发生：
- en: '[PRE13]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create an anonymous function as a goroutine:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个匿名函数作为协程：
- en: '[PRE14]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Inside the goroutine, create an infinite loop. Inside the infinite loop, we
    will receive a value from the `sigs` channel and store it in the `s` variable,
    `s := <-``sigs`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在协程内部，创建一个无限循环。在无限循环内部，我们将从 `sigs` 通道接收一个值并将其存储在 `s` 变量中，`s := <-sigs`：
- en: '[PRE15]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Create a `switch` statement that evaluates what is received from the channel.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `switch` 语句来评估从通道接收到的内容。
- en: We will have two case statements that will check for the `syscall.SIGINT` and
    `syscall.SIGTSP` types.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将有两个情况语句来检查 `syscall.SIGINT` 和 `syscall.SIGTSP` 类型。
- en: Each case statement will have a message being printed.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个情况语句都会打印一条消息。
- en: We will also call our `cleanup()` function.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将调用我们的 `cleanup()` 函数。
- en: 'The last statement in the case statement is sending `true` to the `done` channel
    to stop the blocking:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 情况语句中的最后一个语句是向 `done` 通道发送 `true` 以停止阻塞：
- en: '[PRE16]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a simple function to mimic a process performing a cleanup:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的函数来模拟执行清理操作的过程：
- en: '[PRE17]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can try running this program and pressing *Ctrl* + *Z* and *Ctrl* + *C*
    to examine the different results of the program. This only works on Linux and
    macOS:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以尝试运行这个程序，然后按下 *Ctrl* + *Z* 和 *Ctrl* + *C* 来检查程序的不同结果。这仅在 Linux 和 macOS 上有效：
- en: 'Now run the code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行代码：
- en: '[PRE18]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the output:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![Figure 14.7 – Example output](img/B18621_14_07.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.7 – 示例输出](img/B18621_14_07.jpg)'
- en: Figure 14.7 – Example output
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7 – 示例输出
- en: In this exercise, we have demonstrated the ability to intercept an interrupt
    and perform a task before the application closes. We have the ability to control
    our exit. This is a powerful feature that allows us to perform cleanup actions
    that include removing files, performing a last-minute log, freeing up memory,
    and more. In the next topic, we are going to be creating and writing to files.
    We will be using functions that come from the Go standard package, `os`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们展示了拦截中断并在应用程序关闭前执行任务的 ability。我们有控制退出 ability。这是一个强大的功能，允许我们执行清理操作，包括删除文件、进行最后的日志记录、释放内存等。在下一个主题中，我们将创建并写入文件。我们将使用来自
    Go 标准包的`os`函数。
- en: Create and write to files
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并写入文件
- en: The Go language provides support in various ways to create and write to new
    files. We will examine some of the most common ways in which this is performed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言以各种方式提供支持来创建和写入新文件。我们将检查一些最常见的方法，这些方法是如何执行的。
- en: 'The `os` package provides a simple way in which to create a file. For those
    who are familiar with the `touch` command from the Unix world, it is similar to
    this. Here is the signature of the function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`包提供了一种简单的方式来创建文件。对于那些熟悉 Unix 世界中的`touch`命令的人来说，它与此类似。以下是该函数的签名：'
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The function will create an empty file much as the `touch` command does. It
    is important to note that if the file already exists, then it will truncate the
    file.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将创建一个空文件，就像`touch`命令一样。重要的是要注意，如果文件已经存在，它将截断文件。
- en: 'The `os` package’s `Create` function has an input parameter, which is the name
    of the file to create and its location. If successful, it will return a `File`
    type. It is worth noting that the `File` type satisfies the `io.Write` and `io.Read`
    interfaces. This is important to know for later in the chapter:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`包的`Create`函数有一个输入参数，即要创建的文件名及其位置。如果成功，它将返回一个`File`类型。值得注意的是，`File`类型满足`io.Write`和`io.Read`接口。这对于本章后面的内容很重要：'
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code simply defines the imports and then, in the `main` function,
    tries to create a file called `test.txt`. If there is an error as a result, it
    panics. The last line before the closing brackets makes sure that whenever the
    application is interrupted, either because it terminates successfully or it panics,
    the file will be closed. We want to make sure we never keep files in an open state.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码只是定义了导入，然后在`main`函数中尝试创建一个名为`test.txt`的文件。如果因此出现错误，它将引发恐慌。在括号关闭前的最后一行确保，无论应用程序是成功终止还是恐慌，文件都将被关闭。我们想确保我们永远不会保持文件处于打开状态。
- en: 'Creating an empty file is straightforward, but let’s continue with `os.Create`
    and write to the file we just created. Recall that `os.Create` returns an `*os.File`
    type. There are two methods of interest that can be used to write to the file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空文件很简单，但让我们继续使用`os.Create`并写入我们刚刚创建的文件。回想一下，`os.Create`返回一个`*os.File`类型。有两个有趣的方法可以用来写入文件：
- en: '`Write`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Write`'
- en: '`WriteString`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WriteString`'
- en: 'Let’s see some examples of how to use them:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些如何使用它们的例子：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code is pretty similar to the previous one. We just added two lines where
    we write two sentences to the file.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前的代码非常相似。我们只是添加了两行，将两句话写入文件。
- en: 'The first function call is the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次函数调用如下：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we can see that the function needs bytes to be sent, hence we convert
    a string into a slice of bytes with the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到该函数需要发送字节，因此我们使用以下方式将字符串转换为字节数组：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The second function just accepts a string and is straightforward to use.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个函数仅接受一个字符串，并且使用起来很简单。
- en: 'We can, however, use the package to write to the file directly without having
    to open it first. We can do this using the `os.WriteFile` function:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用该包直接写入文件，而无需先打开它。我们可以使用`os.WriteFile`函数来完成这个操作：
- en: '[PRE24]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The method writes the data to the file specified in the `filename` parameter,
    with the given permissions. It will return an error if one exists. Let’s take
    a look at this in action:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法将数据写入由`filename`参数指定的文件，并使用给定的权限。如果存在错误，它将返回一个错误。让我们看看它是如何工作的：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As we can see, we can create a file, send a string transformed into a slice
    of bytes, and assign the permission to it, all in one line. It is important to
    also send the permission level and note that we need to use the octal notation
    with the leading zero (this is because without the leading zero, the permission
    will not work as expected).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们可以在一行中创建一个文件，发送一个转换为字节切片的字符串，并为其分配权限。同时，我们也需要发送权限级别，并注意我们需要使用带前导零的八进制表示法（这是因为如果没有前导零，权限将不会按预期工作）。
- en: 'One important thing that we haven’t seen till now is how to check whether a
    file exists or not. This is important because if a file does exist, we might not
    want to truncate it and override it with new content. Let’s see how we can do
    that:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前还没有看到的一个重要问题是，如何检查文件是否存在。这很重要，因为如果文件确实存在，我们可能不想截断它并用新内容覆盖它。让我们看看我们如何做到这一点：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let’s review what the preceding code does:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面的代码做了什么：
- en: Firstly, we import all the needed packages.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们导入所有需要的包。
- en: 'We then define a string flag that represents the filename:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个表示文件名的字符串标志：
- en: '[PRE27]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, we parse the flags; in this case, the only one is the one we created.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们解析标志；在这种情况下，只有一个是我们创建的。
- en: 'We then get the stats for the file:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们获取文件的状态信息：
- en: '[PRE28]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If there is an error, we check whether this is because the file does not exist:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果出现错误，我们检查这是否是因为文件不存在：
- en: '[PRE29]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If the file does not exist, we print a message and we then terminate the application.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件不存在，我们打印一条消息，然后终止应用程序。
- en: If the error is different from `IsNotExist`, we just then print the error.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果错误与 `IsNotExist` 不同，我们就打印错误信息。
- en: If, finally, the file exists, we then print a set of information related to
    it. The file implements the `FileInfo` interface, which includes in its details
    the modification time, the size, the octal permissions (*mode*), the name, and
    whether it is a directory or not.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果最终文件存在，我们就打印与它相关的一系列信息。该文件实现了 `FileInfo` 接口，其中包含修改时间、大小、八进制权限（*mode*）、名称以及它是否是目录。
- en: You can try to run this application and pass the name of any file. If it exists
    in the directory from which you run the application, you will see all this information
    printed out for you.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试运行这个应用程序并传递任何文件的名称。如果它存在于你运行应用程序的目录中，你将看到所有这些信息被打印出来。
- en: Let’s now see how can we read a whole file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何读取整个文件。
- en: Reading the whole file at once
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一次性读取整个文件
- en: 'In this topic, we will look at two methods that read all the contents of the
    file. These two functions are good to use when your file size is small. While
    these two methods are convenient and easy to use, they have one major drawback.
    That is, if the file size is too large, then it could exhaust the memory available
    on the system. It is important to keep this in mind and understand the limitations
    of the two methods we will be going over in this topic. Even though these methods
    are some of the quickest and easiest ways to load data, it is important to understand
    that they should be limited to small files and not large ones. The method’s signature
    is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将探讨两种读取文件所有内容的方法。这两个函数在文件大小较小时使用起来很好。虽然这两个方法方便且易于使用，但它们有一个主要的缺点。那就是，如果文件太大，可能会耗尽系统上的内存。这一点很重要，我们需要记住，并理解我们将在这个主题中讨论的两个方法的限制。尽管这些方法是一些最快和最简单加载数据的方法，但重要的是要理解它们应该仅限于小文件，而不是大文件。该方法的签名如下：
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `ReadFile` function reads the contents of the file and returns it as a
    slice of bytes along with any reported errors. We will look at the error return
    when the `ReadFile` method is used:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadFile` 函数读取文件内容，并以字节切片的形式返回，同时报告任何错误。当使用 `ReadFile` 方法时，我们将查看错误返回值：'
- en: A successful call returns `err ==` `nil`.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功调用返回 `err ==` `nil`。
- en: In some of the other read methods for files, **end of file** (**EOF**) is treated
    as an error. This is not the case for functions that read the entire file into
    memory.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件的其他一些读取方法中，**文件结束**（**EOF**）被视为错误。对于将整个文件读入内存的函数来说，情况并非如此。
- en: 'Let’s see a code snippet that explains how to use this function:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个代码片段，解释如何使用这个函数：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As we can see, what we do in this code is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们在代码中执行的操作如下：
- en: We do our imports
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们执行导入操作
- en: We read the contents of the whole `test.txt` file
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们读取整个 `test.txt` 文件的内容
- en: We print an error if it occurs
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发生错误，我们打印错误信息
- en: 'Else, we print the content of the file:'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，我们打印文件的内容：
- en: '[PRE32]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As the content is retrieved as a slice of bytes, we need to convert it to a
    string to visualize it. Let’s see how to read, instead, the file character by
    character in the next snippet:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 由于内容是以字节数组的形式检索的，我们需要将其转换为字符串以可视化它。让我们看看如何在下一个片段中逐字符读取文件：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s analyze this snippet in more detail as it is a bit complicated. In this
    case, after importing the required packages, we do the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地分析这个片段，因为它有点复杂。在这种情况下，在导入所需的包之后，我们执行以下操作：
- en: 'Open the file using the `Open` function:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Open`函数打开文件：
- en: '[PRE34]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We check whether the error is `nil`, and if is not, we print the error and
    exit:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们检查错误是否为`nil`，如果不是，我们打印错误并退出：
- en: '[PRE35]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We then create a slice of bytes of size `1`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个大小为`1`的字节数组切片：
- en: '[PRE36]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We then make an infinite loop, and inside it, we read the file into the buffer:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个无限循环，并在其中读取文件到缓冲区：
- en: '[PRE37]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We then check whether there is an error, which also means that we reached the
    end of the file, in which case we stop the loop:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们检查是否有错误，这也意味着我们到达了文件末尾，在这种情况下我们停止循环：
- en: '[PRE38]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If the error is not `nil` but is not `end of file`, we carry on with the loop,
    ignoring the error.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果错误不是`nil`但也不是文件结束，我们将继续循环，忽略错误。
- en: 'If there is no error and the content has been read, then we display the content:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有错误并且已经读取了内容，那么我们显示内容：
- en: '[PRE39]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice that we read one character at a time, as we made a buffer (slice of bytes)
    of size one. This might be resource intensive, so you might change this value
    to any other value for your particular case and needs.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们一次读取一个字符，因为我们创建了一个大小为1的缓冲区（字节数组）。这可能会很耗费资源，所以你可能需要根据你特定的案例和需求更改这个值。
- en: Exercise 14.02 – backing up files
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习14.02 – 备份文件
- en: 'Oftentimes, when working with files, we need to back up a file before making
    changes to it. This is for instances where we might make mistakes or want the
    original file for auditing purposes. In this exercise, we will take an existing
    file called `note.txt` and back it up to `backupFile.txt`. We will then open `note.txt`
    and add some additional notes to the end of the file. Our directory will contain
    the following files:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们处理文件时，在对其做出更改之前需要备份文件。这是在可能犯错或需要原始文件进行审计目的的情况下。在这个练习中，我们将取一个名为`note.txt`的现有文件，并将其备份到`backupFile.txt`。然后我们将打开`note.txt`并在文件的末尾添加一些额外的注释。我们的目录将包含以下文件：
- en: '![Figure 14.8 – Backing up files to the directory](img/B18621_14_08.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图14.8 – 将文件备份到目录](img/B18621_14_08.jpg)'
- en: Figure 14.8 – Backing up files to the directory
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8 – 将文件备份到目录
- en: 'We must first create the `note.txt` file in the same directory as our executable.
    This file can be blank or contain some sample data such as this:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须首先在可执行文件相同的目录下创建`note.txt`文件。此文件可以是空的，也可以包含一些示例数据，如下所示：
- en: '![Figure 14.9 – Example of the notes.txt file content](img/B18621_14_09.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图14.9 – notes.txt文件内容的示例](img/B18621_14_09.jpg)'
- en: Figure 14.9 – Example of the notes.txt file content
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9 – notes.txt文件内容的示例
- en: Create a Go file called `main.go`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的Go文件。
- en: This program will be part of the `main` package.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个程序将是`main`包的一部分。
- en: 'Include the imports, as seen in the following code:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含如以下代码所示的导入：
- en: '[PRE40]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Create a custom error that will be used when the working file (`note.txt`)
    is not found:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自定义错误，当工作文件（`note.txt`）未找到时使用：
- en: '[PRE41]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a function to perform the backup. This function is responsible for taking
    the working file and storing its content in the `backup` file. This function accepts
    two arguments. The `working` parameter is the file path of the file that you currently
    are working on:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个执行备份的函数。这个函数负责将工作文件的内容存储在`backup`文件中。这个函数接受两个参数。`working`参数是你当前正在工作的文件的文件路径：
- en: '[PRE42]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Inside this function, we will need to check to see whether the working file
    exists. It must first exist before we can read its contents and store them in
    our backup file.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数内部，我们需要检查工作文件是否存在。在我们能够读取其内容并将其存储在我们的备份文件之前，它必须首先存在。
- en: We are able to check to see whether the error is one where the file does not
    exist by using `os.IsNotExist(err)`.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们能够通过使用`os.IsNotExist(err)`来检查错误是否是文件不存在的情况。
- en: 'If the file does not exist, we will return with our custom error, `ErrWorkingFileNotFound`:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果文件不存在，我们将返回我们的自定义错误，`ErrWorkingFileNotFound`：
- en: '[PRE43]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we need to open the working file and store the `os.File` returned by
    the function to the `workFile` variable:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要打开工作文件并将函数返回的`os.File`存储到`workFile`变量中：
- en: '[PRE44]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We need to read the contents of `workFile`. We will be using the `io.ReadAll`
    method to get all the contents of `workFile`. `workFile` is of the `os.File` type,
    which satisfies the `io.Reader` interface; this allows us to pass it to `ioutil.ReadFile`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要读取`workFile`的内容。我们将使用`io.ReadAll`方法来获取`workFile`的所有内容。`workFile`是`os.File`类型，它满足`io.Reader`接口；这允许我们将其传递给`ioutil.ReadFile`。
- en: 'Check to see whether there is an error:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否有错误：
- en: '[PRE45]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `content` variable contains the data of the `workFile` represented as a
    slice of bytes. That data needs to be written to the backup file. We will implement
    the code that will write the data of the `content` variable to the backup file.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`content`变量包含以字节切片形式表示的`workFile`数据。这些数据需要写入备份文件。我们将实现将`content`变量的数据写入备份文件的代码。'
- en: The content stores the `[]byte` data that gets returned from the function. This
    is the entire contents of the file stored in the variable.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`content`变量存储从函数返回的`[]byte`数据。这是存储在变量中的整个文件内容。'
- en: 'We can use the `os.Writefile` method. If the backup file does not exist, it
    will create the file. If the backup file does exist, it will overwrite the file
    with the content variable data:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`os.Writefile`方法。如果备份文件不存在，它将创建文件。如果备份文件已存在，它将使用内容变量`data`覆盖文件：
- en: '[PRE46]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We need to return nil, indicating that, at this juncture, we have not encountered
    any errors:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要返回`nil`，表示在这个阶段，我们没有遇到任何错误：
- en: '[PRE47]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Create a function that will append data to our working file.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，将数据附加到我们的工作文件。
- en: 'Name the function `addNotes`; this will accept the location of our working
    file and a string argument that will be appended to the working file. The function
    will need to return an error:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名函数`addNotes`；这个函数将接受我们工作文件的地址和一个将被附加到工作文件的字符串参数。该函数需要返回一个错误：
- en: '[PRE48]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Inside the `addNotes` function, add a line that will append a new line to each
    note’s string. This will place each note on a separate line:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`addNotes`函数内部，添加一行代码，将新行附加到每个笔记的字符串上。这将使每个笔记单独占一行：
- en: '[PRE49]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we will open the working file and allow for appending to the file. The
    `os.OpenFile()` function will create the file if it does not exist. Check for
    any errors:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将打开工作文件，并允许向文件追加内容。`os.OpenFile()`函数将在文件不存在时创建文件。检查是否有任何错误：
- en: '[PRE50]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'After opening a file and checking for an error, we should make sure that it
    closes when the function exits by using the defer function, `f.Close()`:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开文件并检查错误后，我们应该确保使用`defer`函数`f.Close()`在函数退出时关闭文件：
- en: '[PRE51]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The final step of the function is to write the contents of the note to the
    `workingFile` variable. We can use the `Write` method to accomplish this:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的最终步骤是将笔记的内容写入`workingFile`变量。我们可以使用`Write`方法来完成这个任务：
- en: '[PRE52]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In the `main()` function, we will initialize three variables; the `backupFile`
    variable contains the name of the file for backing up our `workingFile` variable,
    while the `data` variable is what we will be writing to our `workingFile` variable:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们将初始化三个变量；`backupFile`变量包含备份我们的`workingFile`变量的文件名，而`data`变量是我们将要写入`workingFile`变量的内容：
- en: '[PRE53]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Call our `createBackup()` function to back up our `workingFile`. Check for
    errors after calling the function:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用我们的`createBackup()`函数来备份我们的`workingFile`。在调用函数后检查错误：
- en: '[PRE54]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Create a `for` loop that will iterate `10` times.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环，该循环将迭代`10`次。
- en: With each iteration, we set our `note` variable to the `data` variable plus
    the `i` variable of our loop.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在每次迭代中，我们将我们的`note`变量设置为`data`变量加上循环的`i`变量。
- en: Since our `note` variable is a string and our `i` variable is an `int`, we will
    need to convert `i` to a string using the `strconv.Itoa(i)` method.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们的`note`变量是字符串，而`i`变量是`int`类型，我们需要使用`strconv.Itoa(i)`方法将`i`转换为字符串。
- en: Call our `addNotes()` function and pass the `workingFile` and our `note` variables.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用我们的`addNotes()`函数，并传递`workingFile`和我们的`note`变量。
- en: 'Check for any errors returned from the function:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 检查函数返回的任何错误：
- en: '[PRE55]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Run the program:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序：
- en: '[PRE56]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Evaluate the changes to the files after running the program.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行程序后评估文件的变化。
- en: 'The following are the results after running the program:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行程序后的结果：
- en: '![Figure 14.10 – Result of backup](img/B18621_14_10.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图14.10 – 备份结果](img/B18621_14_10.jpg)'
- en: Figure 14.10 – Result of backup
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10 – 备份结果
- en: Let’s see next how to handle CSV files with Go.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Go处理CSV文件。
- en: CSV
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSV
- en: 'One of the most common ways a file is structured is as a comma-separated value.
    This is a clear-text file that contains data, which is basically represented as
    rows and columns. Frequently, these files are used to exchange data. A CSV file
    has a simple structure. Each piece of data is separated by a comma and then a
    new line for another record. An example of a CSV file is as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 文件结构中最常见的方式之一是逗号分隔值。这是一个包含数据的纯文本文件，基本上以行和列的形式表示。这些文件通常用于交换数据。CSV文件具有简单的结构。每条数据由逗号分隔，然后是新的一行以表示另一个记录。以下是一个CSV文件的示例：
- en: '[PRE57]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You will, at some point in your life, come across CSV files as they are very
    common. The Go programming language has a standard library that is used for handling
    CSV files: `encoding/csv`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的一生中，你可能会遇到CSV文件，因为它们非常常见。Go编程语言有一个用于处理CSV文件的标准库：`encoding/csv`：
- en: '[PRE58]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here we are defining a string with the content of our CSV file:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个包含我们CSV文件内容的字符串：
- en: '[PRE59]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And then we use the following line to read the content of the whole CSV:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用以下行来读取整个CSV的内容：
- en: '[PRE60]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The following code line creates a string reader that can be used by the `csv.NewReader`
    function. We cannot, in fact, pass just a string to the CSV reader as it needs
    an `io.Reader` instance, which in this case is provided by `strings.NewReader`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行创建了一个字符串读取器，它可以由`csv.NewReader`函数使用。实际上，我们不能直接将字符串传递给CSV读取器，因为它需要一个`io.Reader`实例，在这种情况下由`strings.NewReader`提供：
- en: '[PRE61]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We then make an infinite loop, which gets terminated when we reach the end
    of the CSV:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个无限循环，当达到CSV的末尾时终止：
- en: '[PRE62]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As we did earlier in this chapter, we then check for another error and we exit
    if we find it; otherwise, we print the record, which is retrieved via the `Read()`
    method of the CSV reader.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面所做的那样，我们接着检查另一个错误，如果找到错误则退出；否则，我们打印记录，该记录是通过CSV读取器的`Read()`方法检索到的。
- en: In the previous example, we saw how to get a whole record at once, meaning one
    row of our CSV. However, there is a way to access each column in the returned
    row, that is, each single element of the row.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了如何一次性获取整个记录，即我们的CSV中的一行。然而，有一种方法可以访问返回行中的每一列，即每一行的单个元素。
- en: 'If you look back at the previous snippet of code, you will see that the rows
    are returned with the following:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下之前的代码片段，你会看到行是以以下方式返回的：
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We then just printed the content, but this is an actual slice of strings, so
    we can get each item with its index. Let’s say we are just interested in visualizing
    the names of the people in the CSV. To do so, we can modify the `fmt.Println(record)`
    line as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只是打印了内容，但这实际上是一个字符串切片，因此我们可以通过索引获取每个项目。假设我们只对可视化CSV中的人名感兴趣。为此，我们可以修改`fmt.Println(record)`行如下：
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: With this, we will only see a list of names.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个库，我们只会看到名字列表。
- en: Embedding
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入
- en: Often, you will need to present to the user some complex text, maybe an HTML
    page, and it might be impractical to define the whole file as a string. You might
    read the file, as we learned in this chapter, and then use it as a template. You
    might want to display an image, again by opening and reading the file containing
    the image. One of the great features of Go is that even if you can build your
    application as a single binary, you will also have external dependencies that
    need to be distributed with your binary. Another issue is that reading from a
    file might be slow, so it would be great if we could embed files inside our Go
    application. This will allow us to just distribute one binary including all our
    assets. In the past, this required external libraries, but now Go includes a package
    called `embed` that allows you to easily embed any file into your binary so that
    you do not need to share other dependencies. Let’s see an example of how we can
    do that.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你需要向用户展示一些复杂的文本，可能是一个HTML页面，将整个文件定义为字符串可能不太实际。你可能像在本章中学到的那样读取文件，然后将其用作模板。你可能还想显示一张图片，同样是通过打开和读取包含图片的文件。Go的一个伟大特性是，即使你可以将你的应用程序构建为一个单一的二进制文件，你也将有需要与你的二进制文件一起分发的外部依赖。另一个问题是，从文件中读取可能很慢，所以如果我们可以将文件嵌入到我们的Go应用程序中，那就太好了。这将允许我们只分发一个包含所有资源的二进制文件。在过去，这需要外部库，但现在Go包含一个名为`embed`的包，它允许你轻松地将任何文件嵌入到你的二进制文件中，这样你就不需要共享其他依赖。让我们看看如何做到这一点。
- en: 'In the next snippet, we will create a very simple template file and will read
    and parse it. Then we will use it to display some greetings. Let’s start with
    the template. We need a folder structure like this: `embedding_example/main.go`
    `and` `templates/template.txt`.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个片段中，我们将创建一个非常简单的模板文件，并读取和解析它。然后我们将使用它来显示一些问候语。让我们从模板开始。我们需要一个如下的文件夹结构：`embedding_example/main.go`和`templates/template.txt`。
- en: The content of the `template.txt` file is `Hello {{.Name}}`, which is pretty
    simple. This simply means that when we use this template and pass a variable called
    `Name`, the engine will substitute the variable with anything we pass as a value.
    You do not need, at this stage, to understand much more about the templating system.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`template.txt`文件的内容是`Hello {{.Name}}`，这很简单。这仅仅意味着当我们使用这个模板并传递一个名为`Name`的变量时，引擎将用我们传递的任何值来替换这个变量。在这个阶段，你不需要对模板系统有更多的了解。'
- en: 'Let’s see now how we can make use of this template written in an external file,
    without having to read it every time we run the application:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何利用这个在外部文件编写的模板，而无需每次运行应用程序时都读取它：
- en: '[PRE65]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We start importing all the necessary packages. After that, we define a struct
    called `Person` that will hold the name of the person to greet. The next part
    is the important bit:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们开始导入所有必要的包。之后，我们定义一个名为`Person`的结构体，它将保存要问候的人的名字。接下来的部分是重要的部分：
- en: '[PRE66]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This defines an `f` variable of type `embed.FS`, which stands for *embedded
    file system* and will work as a virtual filesystem for us. The directive on top
    of the declaration needs to be just above the variable we define, otherwise the
    compiler will prompt us with an error. This directive tells the Go compiler that
    it needs to read and embed whatever is inside the `templates` folder and make
    it available. Be careful if you add a folder with too many big files, as your
    final binary will increase in size.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个类型为`embed.FS`的`f`变量，代表*嵌入文件系统*，将为我们作为一个虚拟文件系统工作。声明顶部的指令需要正好位于我们定义的变量之上，否则编译器会提示我们错误。这个指令告诉Go编译器它需要读取并嵌入`templates`文件夹中的内容，并使其可用。如果你添加一个包含太多大文件的文件夹，请注意，你的最终二进制文件的大小将会增加。
- en: Inside the `main` function, we then instantiate a struct of type `Person` where
    the `Name` attribute has the value `John`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数内部，我们随后实例化了一个类型为`Person`的结构体，其中`Name`属性具有值`John`。
- en: After that, we use the `ParseFS` function of the `template` package, and we
    use it to read from the embedded file system, represented by the variable `f`,
    the file called `template.txt` from inside the `templates` folder.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们使用`template`包的`ParseFS`函数，我们用它从嵌入的文件系统（变量`f`表示）中读取`templates`文件夹内的`template.txt`文件。
- en: 'Next, we just execute the templating engine, passing the previously created
    struct. If you run the application, you will see the message printed out as follows:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们只需执行模板引擎，传递之前创建的结构体。如果你运行应用程序，你会看到以下消息打印出来：
- en: '[PRE67]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, this does not seem much, but try running the following command:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，这似乎并不多，但尝试运行以下命令：
- en: '[PRE68]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, copy your executable to a different location where the `template` folder
    is not available. If you now run from that new folder, you will still see the
    exact same message:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将你的可执行文件复制到另一个位置，那里没有`template`文件夹。如果你现在从这个新文件夹运行，你仍然会看到完全相同的信息：
- en: '[PRE69]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The key takeaway here is that the directive takes the whole filesystem from
    the point you specify, in this case, the `templates` folder, and creates a virtual
    filesystem. From this virtual filesystem, you can read all the files, but the
    content of the whole folder will actually be stored inside the final binary of
    your application. This feature is very powerful but should be used wisely, as
    the final binary could easily become very big.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要收获是，该指令从指定的点开始获取整个文件系统，在本例中是`templates`文件夹，并创建一个虚拟文件系统。从这个虚拟文件系统中，你可以读取所有文件，但实际上整个文件夹的内容将实际存储在你的应用程序的最终二进制文件中。这个功能非常强大，但应该明智地使用，因为最终的二进制文件可能会轻易变得非常大。
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we gained an understanding of how Go views and uses file permissions.
    We learned that file permissions can be represented as symbolic and octal notations.
    We discovered that the Go standard library has built-in support for opening, reading,
    writing, creating, deleting, and appending data to a file. We looked at the `flag`
    package and how it provides functionality to create command-line applications
    to accept arguments.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Go如何看待和使用文件权限。我们了解到文件权限可以用符号和八进制表示。我们发现Go标准库内置了对打开、读取、写入、创建、删除和向文件追加数据的功能的支持。我们研究了`flag`包以及它如何提供创建命令行应用程序以接受参数的功能。
- en: Using the `flag` package, we could also print out `usage` statements that pertained
    to our command-line application.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`flag`包，我们还可以打印出与我们的命令行应用程序相关的`usage`语句。
- en: Then, we demonstrated how OS signals can impact our Go program; however, by
    using the Go standard library, we can capture OS signals and, if applicable, control
    how we want to exit our program.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们演示了操作系统信号如何影响我们的Go程序；然而，通过使用Go标准库，我们可以捕获操作系统信号，并在适用的情况下控制我们希望如何退出我们的程序。
- en: We also learned that Go has a standard library for working with CSV files. In
    our previous work with files, we saw that we can also work with files that are
    structured as CSV files. That Go CSV package provides the ability to iterate over
    the contents of the file. The CSV file can be viewed as rows and columns similar
    to database tables.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到Go有一个用于处理CSV文件的标准库。在我们之前的工作中，我们看到了我们还可以处理结构化为CSV文件的文件。Go CSV包提供了遍历文件内容的能力。CSV文件可以看作是类似于数据库表的行和列。
- en: Finally, we saw how to embed files inside the final binary of the application
    and how to use this feature to speed up the application and avoid shipping external
    dependencies with the binary. In the next chapter, we will look at how to connect
    to databases and execute SQL statements against a database. This will demonstrate
    the ability of Go to be used for applications that require a backend for storing
    data.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了如何在应用程序的最终二进制文件中嵌入文件，以及如何使用此功能来加快应用程序的速度并避免将外部依赖项与二进制文件一起分发。在下一章中，我们将探讨如何连接到数据库并执行针对数据库的SQL语句。这将展示Go在需要后端存储数据的应用程序中的使用能力。
