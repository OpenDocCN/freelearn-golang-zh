- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File and Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: We will see in this chapter how to interact with the filesystem, which means
    we will read files, manipulate them, store them for later use, and get information
    about them. We will also cover how to read folders so that we can search for the
    files we need, and will examine some specific file formats such as CSV, which
    is commonly used to share information in tabular form.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing you will learn in this chapter is how to send some information
    to your application in the form of flags.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you''ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter14](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter14).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how to write simple command-line applications.
    We will carry on with this here, introducing ways to pass parameters to our application
    so that it behaves differently depending on the values we send.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will interact with the filesystem. The levels we are going to
    be working with the filesystem at are the file, directory, and permission levels.
    We will tackle everyday issues that developers face when working with the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to create a command-line application that will read and write
    files. Along with discussing what happens when we get a signal interrupt from
    the OS, we will demonstrate how to perform cleanup actions before our application
    stops running. We will also handle a scenario of receiving an interrupt to our
    application and handling how the application exits. There are times when your
    application is running, and a signal comes from the OS to shut down the application.
  prefs: []
  type: TYPE_NORMAL
- en: In such instances, we may want to log information at the time of the shutdown
    for debugging purposes; this will help us to understand why the application shuts
    down. We will look at how we can do that in this chapter. However, before we start
    tackling these issues, let’s get a basic understanding of the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A filesystem controls how data is named, stored, accessed, and retrieved on
    a device such as a hard drive, USB, DVD, or another medium. There is no one filesystem,
    and how it behaves largely depends on what OS you are using. You must have heard
    of `FAT`, `FAT32`, `NFTS`, and so on, which are all different filesystems and
    are used normally by Windows. Linux can read and write to them, but it generally
    uses a different family of filesystems that have names starting with `ext`, which
    stands for *extended*. You do not need to have a deep understanding of filesystems,
    but, as a software engineer, it is good to at least have a basic understanding
    of the subject.
  prefs: []
  type: TYPE_NORMAL
- en: What interests us in this chapter, however, is that each filesystem has its
    conventions for naming files, such as the length of the filename, the specific
    characters that can be used, how long the suffix or file extension can be, and
    so on. Each file has information or metadata, data embedded within a file or associated
    with it that describes or provides information about the file. This metadata about
    a file can contain information such as file size, location, access permissions,
    date created, date modified, and more. This is all the information that can be
    accessed by our applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Files are generally placed in some sort of hierarchal structure. This structure
    typically consists of multiple directories and sub-directories. The placement
    of the files within the directories is a way to organize your data and get access
    to the file or directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – The Linux filesystem](img/B18621_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – The Linux filesystem
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 14**.1*, directories can be nested. In a normal Linux filesystem,
    we will see that there is a root directory, which is defined by the name **/**,
    and everything else is a subdirectory of it. The **home** directory generally
    holds data for each user of the system, and in the case shown above, **matt**
    is a directory holding a **docs** and an **mp3** directory, which are subdirectories
    of **matt**, but **matt** itself is a subdirectory of **home**.
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, we will be looking at file permissions.
  prefs: []
  type: TYPE_NORMAL
- en: File permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Permissions are an important aspect that you need to understand when dealing
    with file creation and modifications.
  prefs: []
  type: TYPE_NORMAL
- en: We need to look at various permission types that can be assigned to a file.
    We also need to consider how those permission types are represented in symbolic
    and octal notation.
  prefs: []
  type: TYPE_NORMAL
- en: Go uses the Unix nomenclature to represent permission types. They are represented
    in symbolic notation or octal notation. The three permission types are *Read*,
    *Write*, and *Execute*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – File permissions](img/B18621_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – File permissions
  prefs: []
  type: TYPE_NORMAL
- en: 'Permissions for every file are assigned to three different entities that can
    be individuals or groups. This means that a user can be part of a group that has
    access to some files, as a result of which the user inherits access to those files.
    It is not possible to assign permissions for a file to a specific user; rather,
    we add the user to a group and then assign permissions to that group. That said,
    it is possible to assign permission for a file to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Owner**: This is an individual, a single person such as John Smith, or the
    root user who is the owner of the file. In general, it is the individual who created
    the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group**: A group typically consists of multiple individuals or other groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Others**: Those that are not in a group or the owner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see now, how permissions are indicated via symbolic notation. The following
    diagram is an example of a file and its permissions on a Unix machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Permissions notation](img/B18621_14_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – Permissions notation
  prefs: []
  type: TYPE_NORMAL
- en: The first dash (`-`) in the figure above means that the entity is a file. If
    it was a directory, it would have been the character `d` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to specify the permissions is the octal notation, which expresses
    multiple permissions types with a single number. For example, if you want to indicate
    read and write permissions using symbolic notation, it would be `rw-`. If this
    was to be represented as an octal number, it would be `6`, because `4` means read
    permission and `2` means write permission. Full permission would be `7`, which
    means *4+2+1* or *read+write+execute* (`rwx`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following recaps the permissions and their explanations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Groups and permission examples](img/B18621_14_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – Groups and permission examples
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, each permission can be expressed with a number `<=7`, which
    is in one digit. Permissions for owner, group, and others can then be expressed
    in octal notation with three digits, as we can see in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Permission representations examples](img/B18621_14_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – Permission representations examples
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that in octal representation all numbers start with a *0*.
    When working with the filesystem via the command line you can omit the leading
    zero. However, in many cases, when programming, you need to pass it so that the
    compiler will understand that you are writing something in octal notation. You
    might argue that `0777` and `777` are the same number, but the leading zero is
    just a *convention* that tells the compiler that you are using an octal notation
    and the number is octal and not decimal. In other words, `777` is interpreted
    as the decimal number `777`, while `0777` is interpreted as the octal number `0777`,
    which is the decimal number `511`.
  prefs: []
  type: TYPE_NORMAL
- en: Flags and arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go provides support for creating command-line interface tools. Often, when we
    write Go programs that are executables, they need to accept various inputs. These
    inputs could include the location of a file, a value to run the program in the
    debug state, getting help to run the program and more. All of this is made possible
    by a package in the Go standard library called `flag`. It is used to allow the
    passing of arguments to the program. A flag is an argument that is passed to a
    Go program. The order of the flags being passed to the Go program using the `flag`
    package does not matter to Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define your `flag`, you must know the `flag` type you will be accepting.
    The `flag` package provides many functions for defining flags. Here is a sample
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These are some of the functions allowing you to create flags and accept parameters,
    and there is one for each default type in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters of the preceding functions can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**name**: This parameter is the name of the flag; it is a string type. For
    example, if you pass *file* as an argument, you would access that flag from the
    command line with the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**value**: This parameter is the default value that the flag is set to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**usage**: This parameter is used to describe the flag’s purpose. It will often
    show up on the command line when you incorrectly set the value. Passing the wrong
    type for a flag will stop the program and cause an error; the usage will be printed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**return value**: This is the address of the variable that stores the value
    of the flag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s go over the preceding code block and analyze it:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define the `main` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we import the `flag` and `fmt` packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `v` variable will reference the value for either `-value` or `--value`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The initial value of `*v` is the default value of `-1` before calling `flag.Parse()`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After defining the flags, you must call `flag.Parse()` to parse the defined
    flags into the command line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling `flag.Parse()` places the argument for `-value` into `*v`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have called the `flag.Parse()` function, the flags will be available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the command line, execute the following command and you will get the executable
    in the same directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the executable on Windows, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '`go build -o` `flagapp.exe main.go`'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another way, however, to define these flags. It can be done using
    the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, for each type, there is a function similar to those we’ve already
    seen, whose names end with `Var`. They all accept a pointer to the type of the
    flag as the first argument, and can be used as in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the same as the previous snippet, however, here’s a quick breakdown:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define an integer variable `v`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use its reference as the first parameter of the `IntVar` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parse the flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print the `v` variable, which now does not need to be dereferenced as it is
    not the flag but an actual integer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we compile our application, using any of the preceding snippets, as an executable
    called `flagapp`, with the following call in the same directory as the executable,
    we will see that it will print the number `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we call it without the parameter with the following call in the same directory
    as the executable, we will see that it will just print `-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is because `-1` is the default value.
  prefs: []
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A signal is an interrupt that is sent to our program or a process by the OS.
    When a signal is delivered to our program, the program will stop what it is doing;
    either it will handle the signal or, if possible, ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of the top three most often used interrupt signals
    for Go programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGINT` (interrupt):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Situation: This signal is commonly used when a user presses *Ctrl + C* in the
    terminal to interrupt the execution of a program.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Definition: SIGINT is the interrupt signal. It is used to gracefully terminate
    a program and perform cleanup operations before exiting.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTERM` (termination):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Situation: This signal is often used to request the termination of a program
    in a controlled manner. It is a generic signal to terminate a process.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Definition: SIGTERM is the termination signal. It allows a program to perform
    cleanup operations before exiting, similar to SIGINT, but it can be caught and
    handled differently.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGKILL` (kill):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Situation: This signal is used to forcefully terminate a program. It doesn’t
    allow the program to perform any cleanup operations.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Definition: SIGKILL is the kill signal. It immediately terminates a process
    without giving it a chance to clean up resources. It is a more forceful way of
    ending a program compared to SIGTERM.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have seen other Go commands that change the flow of the program; you may
    be wondering which one to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `defer` statements in our applications to perform various cleanup activities,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The release of resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The closing of files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The closing of database connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing the removal of configuration or temporary files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In some use cases, it is important that these activities are completed. Using
    a `defer` function will execute it just before returning to the caller. However,
    this does not guarantee that it will always run. There are certain scenarios in
    which the `defer` function won’t execute; for example, an OS interrupt to your
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '`os.Exit(1)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl + C*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other instructions from the OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding scenarios indicate where it may warrant using signals. Signals
    can help us control the exit of our program. Depending on the signal, it could
    terminate our program. For example, the application is running and encounters
    an OS interrupt signal after executing `employee.CalculateSalary()`. In this scenario,
    the `defer` function will not run, thus, `employee.DepositCheck()` does not execute
    and the employee does not get paid. A signal can change the flow of the program.
    The following diagram goes over the scenario we discussed previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6 – Example program with signals](img/B18621_14_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – Example program with signals
  prefs: []
  type: TYPE_NORMAL
- en: 'Support for handling signals is built into the Go standard library; it is in
    the `os/signal` package. This package will allow us to make our programs more
    resilient. We want to gracefully shut down when we receive certain signals. The
    first thing to do when handling signals in Go is to trap or catch the signal that
    you are interested in. This is done by using the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This function accepts an `os.Signal` data type on a channel, `c`. The `sig`
    argument is a variadic variable of `os.Signal`; we specify zero or more `os.Signal`
    data types that we are interested in. Let’s see a code snippet showing how we
    can use this function to stop the execution of an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After the definition of the package and importing the packages, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a channel to send signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a channel that we can use as a flag to stop the execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `Notify` to send a `SIGINT` signal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a goroutine that listens indefinitely to signals and if the signal is
    `SIGINT`, it does some printouts and sends a message to the `done` channel with
    the `true` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print a message stating we are waiting for the `done` message to be received
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wait for the `done` message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print the final message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we run the application, we will actually see the application terminate
    quite quickly, because we manually send the `SIGINT` signal. In a real-world scenario,
    the application would just wait for the `SIGKILL` signal, which we can manually
    send with *Ctrl* + *X*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see now how we can simulate a cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 14.01 – simulating a cleanup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will be catching two signals: `SIGINT` and `SIGTSTP`.
    Once those signals have been caught, we will simulate a cleanup of the files.
    We have not gone over how to remove files yet, so, in this example, we will simply
    create a delay to demonstrate how we can run a function after a signal is caught.
    This is the desired output from this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add to this file the `main` package and the following `import` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, create a channel of the `os.Signal` type. The `sigs`
    channel is used to receive these notifications from the `Notify` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add a `done` channel. The `done` channel is used to let us know when
    the program can exit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will then add a `signal.Notify` method. The `Notify` method works by sending
    values of the `os.Signal` type to a channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recall that the last parameter of the `signal.Notify` method is a variadic parameter
    of the `os.Signal` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `signal.Notify` method will receive notifications on the `sigs` channel
    that are of the `syscall.SIGINT` and `syscall.SIGTSTP` types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generally speaking, the `syscall.SIGINT` type can occur when you press *Ctrl*
    + *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Generally speaking, the `syscall.SIGTSTP` type can occur when you press *Ctrl*
    + *Z*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an anonymous function as a goroutine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the goroutine, create an infinite loop. Inside the infinite loop, we
    will receive a value from the `sigs` channel and store it in the `s` variable,
    `s := <-``sigs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a `switch` statement that evaluates what is received from the channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will have two case statements that will check for the `syscall.SIGINT` and
    `syscall.SIGTSP` types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each case statement will have a message being printed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will also call our `cleanup()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last statement in the case statement is sending `true` to the `done` channel
    to stop the blocking:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a simple function to mimic a process performing a cleanup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can try running this program and pressing *Ctrl* + *Z* and *Ctrl* + *C*
    to examine the different results of the program. This only works on Linux and
    macOS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now run the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.7 – Example output](img/B18621_14_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – Example output
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have demonstrated the ability to intercept an interrupt
    and perform a task before the application closes. We have the ability to control
    our exit. This is a powerful feature that allows us to perform cleanup actions
    that include removing files, performing a last-minute log, freeing up memory,
    and more. In the next topic, we are going to be creating and writing to files.
    We will be using functions that come from the Go standard package, `os`.
  prefs: []
  type: TYPE_NORMAL
- en: Create and write to files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go language provides support in various ways to create and write to new
    files. We will examine some of the most common ways in which this is performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `os` package provides a simple way in which to create a file. For those
    who are familiar with the `touch` command from the Unix world, it is similar to
    this. Here is the signature of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The function will create an empty file much as the `touch` command does. It
    is important to note that if the file already exists, then it will truncate the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `os` package’s `Create` function has an input parameter, which is the name
    of the file to create and its location. If successful, it will return a `File`
    type. It is worth noting that the `File` type satisfies the `io.Write` and `io.Read`
    interfaces. This is important to know for later in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code simply defines the imports and then, in the `main` function,
    tries to create a file called `test.txt`. If there is an error as a result, it
    panics. The last line before the closing brackets makes sure that whenever the
    application is interrupted, either because it terminates successfully or it panics,
    the file will be closed. We want to make sure we never keep files in an open state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating an empty file is straightforward, but let’s continue with `os.Create`
    and write to the file we just created. Recall that `os.Create` returns an `*os.File`
    type. There are two methods of interest that can be used to write to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Write`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WriteString`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see some examples of how to use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty similar to the previous one. We just added two lines where
    we write two sentences to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first function call is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the function needs bytes to be sent, hence we convert
    a string into a slice of bytes with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The second function just accepts a string and is straightforward to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can, however, use the package to write to the file directly without having
    to open it first. We can do this using the `os.WriteFile` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The method writes the data to the file specified in the `filename` parameter,
    with the given permissions. It will return an error if one exists. Let’s take
    a look at this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we can create a file, send a string transformed into a slice
    of bytes, and assign the permission to it, all in one line. It is important to
    also send the permission level and note that we need to use the octal notation
    with the leading zero (this is because without the leading zero, the permission
    will not work as expected).
  prefs: []
  type: TYPE_NORMAL
- en: 'One important thing that we haven’t seen till now is how to check whether a
    file exists or not. This is important because if a file does exist, we might not
    want to truncate it and override it with new content. Let’s see how we can do
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s review what the preceding code does:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we import all the needed packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then define a string flag that represents the filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we parse the flags; in this case, the only one is the one we created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then get the stats for the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If there is an error, we check whether this is because the file does not exist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the file does not exist, we print a message and we then terminate the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the error is different from `IsNotExist`, we just then print the error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If, finally, the file exists, we then print a set of information related to
    it. The file implements the `FileInfo` interface, which includes in its details
    the modification time, the size, the octal permissions (*mode*), the name, and
    whether it is a directory or not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can try to run this application and pass the name of any file. If it exists
    in the directory from which you run the application, you will see all this information
    printed out for you.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see how can we read a whole file.
  prefs: []
  type: TYPE_NORMAL
- en: Reading the whole file at once
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this topic, we will look at two methods that read all the contents of the
    file. These two functions are good to use when your file size is small. While
    these two methods are convenient and easy to use, they have one major drawback.
    That is, if the file size is too large, then it could exhaust the memory available
    on the system. It is important to keep this in mind and understand the limitations
    of the two methods we will be going over in this topic. Even though these methods
    are some of the quickest and easiest ways to load data, it is important to understand
    that they should be limited to small files and not large ones. The method’s signature
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ReadFile` function reads the contents of the file and returns it as a
    slice of bytes along with any reported errors. We will look at the error return
    when the `ReadFile` method is used:'
  prefs: []
  type: TYPE_NORMAL
- en: A successful call returns `err ==` `nil`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some of the other read methods for files, **end of file** (**EOF**) is treated
    as an error. This is not the case for functions that read the entire file into
    memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s see a code snippet that explains how to use this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, what we do in this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We do our imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We read the contents of the whole `test.txt` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We print an error if it occurs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Else, we print the content of the file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As the content is retrieved as a slice of bytes, we need to convert it to a
    string to visualize it. Let’s see how to read, instead, the file character by
    character in the next snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s analyze this snippet in more detail as it is a bit complicated. In this
    case, after importing the required packages, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file using the `Open` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We check whether the error is `nil`, and if is not, we print the error and
    exit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then create a slice of bytes of size `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then make an infinite loop, and inside it, we read the file into the buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then check whether there is an error, which also means that we reached the
    end of the file, in which case we stop the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the error is not `nil` but is not `end of file`, we carry on with the loop,
    ignoring the error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If there is no error and the content has been read, then we display the content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we read one character at a time, as we made a buffer (slice of bytes)
    of size one. This might be resource intensive, so you might change this value
    to any other value for your particular case and needs.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 14.02 – backing up files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Oftentimes, when working with files, we need to back up a file before making
    changes to it. This is for instances where we might make mistakes or want the
    original file for auditing purposes. In this exercise, we will take an existing
    file called `note.txt` and back it up to `backupFile.txt`. We will then open `note.txt`
    and add some additional notes to the end of the file. Our directory will contain
    the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8 – Backing up files to the directory](img/B18621_14_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.8 – Backing up files to the directory
  prefs: []
  type: TYPE_NORMAL
- en: 'We must first create the `note.txt` file in the same directory as our executable.
    This file can be blank or contain some sample data such as this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.9 – Example of the notes.txt file content](img/B18621_14_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.9 – Example of the notes.txt file content
  prefs: []
  type: TYPE_NORMAL
- en: Create a Go file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This program will be part of the `main` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the imports, as seen in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a custom error that will be used when the working file (`note.txt`)
    is not found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to perform the backup. This function is responsible for taking
    the working file and storing its content in the `backup` file. This function accepts
    two arguments. The `working` parameter is the file path of the file that you currently
    are working on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside this function, we will need to check to see whether the working file
    exists. It must first exist before we can read its contents and store them in
    our backup file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are able to check to see whether the error is one where the file does not
    exist by using `os.IsNotExist(err)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the file does not exist, we will return with our custom error, `ErrWorkingFileNotFound`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to open the working file and store the `os.File` returned by
    the function to the `workFile` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to read the contents of `workFile`. We will be using the `io.ReadAll`
    method to get all the contents of `workFile`. `workFile` is of the `os.File` type,
    which satisfies the `io.Reader` interface; this allows us to pass it to `ioutil.ReadFile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check to see whether there is an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `content` variable contains the data of the `workFile` represented as a
    slice of bytes. That data needs to be written to the backup file. We will implement
    the code that will write the data of the `content` variable to the backup file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The content stores the `[]byte` data that gets returned from the function. This
    is the entire contents of the file stored in the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use the `os.Writefile` method. If the backup file does not exist, it
    will create the file. If the backup file does exist, it will overwrite the file
    with the content variable data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to return nil, indicating that, at this juncture, we have not encountered
    any errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a function that will append data to our working file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the function `addNotes`; this will accept the location of our working
    file and a string argument that will be appended to the working file. The function
    will need to return an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `addNotes` function, add a line that will append a new line to each
    note’s string. This will place each note on a separate line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will open the working file and allow for appending to the file. The
    `os.OpenFile()` function will create the file if it does not exist. Check for
    any errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After opening a file and checking for an error, we should make sure that it
    closes when the function exits by using the defer function, `f.Close()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step of the function is to write the contents of the note to the
    `workingFile` variable. We can use the `Write` method to accomplish this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, we will initialize three variables; the `backupFile`
    variable contains the name of the file for backing up our `workingFile` variable,
    while the `data` variable is what we will be writing to our `workingFile` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call our `createBackup()` function to back up our `workingFile`. Check for
    errors after calling the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a `for` loop that will iterate `10` times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With each iteration, we set our `note` variable to the `data` variable plus
    the `i` variable of our loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since our `note` variable is a string and our `i` variable is an `int`, we will
    need to convert `i` to a string using the `strconv.Itoa(i)` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Call our `addNotes()` function and pass the `workingFile` and our `note` variables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check for any errors returned from the function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Evaluate the changes to the files after running the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are the results after running the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10 – Result of backup](img/B18621_14_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.10 – Result of backup
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see next how to handle CSV files with Go.
  prefs: []
  type: TYPE_NORMAL
- en: CSV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common ways a file is structured is as a comma-separated value.
    This is a clear-text file that contains data, which is basically represented as
    rows and columns. Frequently, these files are used to exchange data. A CSV file
    has a simple structure. Each piece of data is separated by a comma and then a
    new line for another record. An example of a CSV file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You will, at some point in your life, come across CSV files as they are very
    common. The Go programming language has a standard library that is used for handling
    CSV files: `encoding/csv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are defining a string with the content of our CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we use the following line to read the content of the whole CSV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code line creates a string reader that can be used by the `csv.NewReader`
    function. We cannot, in fact, pass just a string to the CSV reader as it needs
    an `io.Reader` instance, which in this case is provided by `strings.NewReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We then make an infinite loop, which gets terminated when we reach the end
    of the CSV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As we did earlier in this chapter, we then check for another error and we exit
    if we find it; otherwise, we print the record, which is retrieved via the `Read()`
    method of the CSV reader.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, we saw how to get a whole record at once, meaning one
    row of our CSV. However, there is a way to access each column in the returned
    row, that is, each single element of the row.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look back at the previous snippet of code, you will see that the rows
    are returned with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We then just printed the content, but this is an actual slice of strings, so
    we can get each item with its index. Let’s say we are just interested in visualizing
    the names of the people in the CSV. To do so, we can modify the `fmt.Println(record)`
    line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: With this, we will only see a list of names.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, you will need to present to the user some complex text, maybe an HTML
    page, and it might be impractical to define the whole file as a string. You might
    read the file, as we learned in this chapter, and then use it as a template. You
    might want to display an image, again by opening and reading the file containing
    the image. One of the great features of Go is that even if you can build your
    application as a single binary, you will also have external dependencies that
    need to be distributed with your binary. Another issue is that reading from a
    file might be slow, so it would be great if we could embed files inside our Go
    application. This will allow us to just distribute one binary including all our
    assets. In the past, this required external libraries, but now Go includes a package
    called `embed` that allows you to easily embed any file into your binary so that
    you do not need to share other dependencies. Let’s see an example of how we can
    do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next snippet, we will create a very simple template file and will read
    and parse it. Then we will use it to display some greetings. Let’s start with
    the template. We need a folder structure like this: `embedding_example/main.go`
    `and` `templates/template.txt`.'
  prefs: []
  type: TYPE_NORMAL
- en: The content of the `template.txt` file is `Hello {{.Name}}`, which is pretty
    simple. This simply means that when we use this template and pass a variable called
    `Name`, the engine will substitute the variable with anything we pass as a value.
    You do not need, at this stage, to understand much more about the templating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see now how we can make use of this template written in an external file,
    without having to read it every time we run the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We start importing all the necessary packages. After that, we define a struct
    called `Person` that will hold the name of the person to greet. The next part
    is the important bit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This defines an `f` variable of type `embed.FS`, which stands for *embedded
    file system* and will work as a virtual filesystem for us. The directive on top
    of the declaration needs to be just above the variable we define, otherwise the
    compiler will prompt us with an error. This directive tells the Go compiler that
    it needs to read and embed whatever is inside the `templates` folder and make
    it available. Be careful if you add a folder with too many big files, as your
    final binary will increase in size.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `main` function, we then instantiate a struct of type `Person` where
    the `Name` attribute has the value `John`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, we use the `ParseFS` function of the `template` package, and we
    use it to read from the embedded file system, represented by the variable `f`,
    the file called `template.txt` from inside the `templates` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we just execute the templating engine, passing the previously created
    struct. If you run the application, you will see the message printed out as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, this does not seem much, but try running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, copy your executable to a different location where the `template` folder
    is not available. If you now run from that new folder, you will still see the
    exact same message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The key takeaway here is that the directive takes the whole filesystem from
    the point you specify, in this case, the `templates` folder, and creates a virtual
    filesystem. From this virtual filesystem, you can read all the files, but the
    content of the whole folder will actually be stored inside the final binary of
    your application. This feature is very powerful but should be used wisely, as
    the final binary could easily become very big.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gained an understanding of how Go views and uses file permissions.
    We learned that file permissions can be represented as symbolic and octal notations.
    We discovered that the Go standard library has built-in support for opening, reading,
    writing, creating, deleting, and appending data to a file. We looked at the `flag`
    package and how it provides functionality to create command-line applications
    to accept arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `flag` package, we could also print out `usage` statements that pertained
    to our command-line application.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we demonstrated how OS signals can impact our Go program; however, by
    using the Go standard library, we can capture OS signals and, if applicable, control
    how we want to exit our program.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that Go has a standard library for working with CSV files. In
    our previous work with files, we saw that we can also work with files that are
    structured as CSV files. That Go CSV package provides the ability to iterate over
    the contents of the file. The CSV file can be viewed as rows and columns similar
    to database tables.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we saw how to embed files inside the final binary of the application
    and how to use this feature to speed up the application and avoid shipping external
    dependencies with the binary. In the next chapter, we will look at how to connect
    to databases and execute SQL statements against a database. This will demonstrate
    the ability of Go to be used for applications that require a backend for storing
    data.
  prefs: []
  type: TYPE_NORMAL
