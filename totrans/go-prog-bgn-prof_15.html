<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer172">
			<h1 id="_idParaDest-379" class="chapter-number"><a id="_idTextAnchor1649"/>15</h1>
			<h1 id="_idParaDest-380">SQL and Databases<a id="_idTextAnchor1650"/><a id="_idTextAnchor1651"/></h1>
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter will introduce you to databases – specifically relational databases – and how to access them via the Go <span class="No-Break">programming language.</span></p>
			<p class="callout">This chapter will guide you through how to connect to the SQL database engine, how to create a database, how to create tables in a database, and how to insert and retrieve data in and from tables. By the end of this chapter, you will be able to update and delete data in specific tables, as well as truncate and <span class="No-Break">drop tables.</span></p>
			<h1 id="_idParaDest-381"><a id="_idTextAnchor1652"/>Technical requirements</h1>
			<p>For this chapter, you’ll require Go version 1.21 or higher. The code for this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter15"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter15</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-382">Introduction<a id="_idTextAnchor1653"/></h1>
			<p>In the previous chapter, you learned how to interact with the filesystem your Go app is running on. You learned about the importance of exit codes and how to customize your scripts to take arguments, thus adding flexibility to your applications. You also learned how to handle different signals that your <span class="No-Break">application receives.</span></p>
			<p>In this chapter, you will further master your Go skills by learning how to use SQL and databases in Go. As a developer, it is impossible to get by without a proper understanding of persistent data storage and databases. Our applications process input and produce output, but most of the time, if not in all cases, a database is involved in the process. This database can be in-memory (stored in the computer’s RAM) or file-based (a single file in a directory), and it can live on local or remote storage. A database engine can be installed locally, as we will do later in this chapter, but it is also possible to use cloud providers, which allow you to use a database as a service; some of the cloud providers that offer several different database engine options are Azure, AWS, and <span class="No-Break">Google Cloud.</span></p>
			<p>What we aim to do in this chapter is make you fluent in talking to these databases and understanding the basic concepts of what a database is. Finally, you will have extended your skillset to make you a better Go developer as you progress through <span class="No-Break">this chapter.</span></p>
			<p>Let’s say your boss wants you to create a Go app that can communicate with a database. By <em class="italic">communicate</em>, we mean that any transaction that is <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">DELETE</strong>, or <strong class="source-inline">CREATE</strong> can and should be handled by the application. This chapter will show you how to <span class="No-Break">do that.</span></p>
			<h1 id="_idParaDest-383"><a id="_idTextAnchor1654"/>Understanding the database</h1>
			<p><a id="_idTextAnchor1655"/>We commonly use the word <a id="_idIndexMarker951"/>database in different ways, but let’s be a bit more <span class="No-Break">formal here:</span></p>
			<p class="author-quote">A database is where we store our data, where we persist it (if we want), and where we can run some queries to insert new data and retrieve or modify existing data.</p>
			<p>You might think that a filesystem fits this description, but actually, this is not the case; a real database allows us to perform very complex and precise queries to gather data based on very specific conditions. To do so, we will have a language to perform these queries or other operations. In our case, we will focus on a language <span class="No-Break">called SQL.</span></p>
			<p>We’ve stated what a database is, but this is still quite abstract. To create a database and fill it with data, we need an engine – essentially, an application – that will allow us to perform all these operations. In this section, we’ll learn how to use a database engine called <strong class="bold">Postgres SQL</strong>. As its name suggests, this engine will allow us to perform operations using the <span class="No-Break">SQL language.</span></p>
			<h2 id="_idParaDest-384"><a id="_idTextAnchor1656"/>Installing and configuring Postgres SQL</h2>
			<p>As a first step, you need to<a id="_idIndexMarker952"/> install Postgres SQL and configure it for yourself so that you can<a id="_idIndexMarker953"/> try out the <span class="No-Break">following examples.</span></p>
			<p>First, you need to grab the installer from <a href="https://www.postgresql.org/download/">https://www.postgresql.org/download/</a>. Select the one that is appropriate for your system; we will go through the Windows installer here, but things are <a id="_idIndexMarker954"/>pretty similar for other systems. The installer is very easy to <a id="_idIndexMarker955"/>use, and I suggest that you accept <span class="No-Break">the defaults:</span></p>
			<ol>
				<li>Run <span class="No-Break">the installe<a id="_idTextAnchor1657"/>r:</span></li>
			</ol>
			<div>
				<div id="_idContainer161" class="IMG---Figure">
					<img src="image/B18621_15_01.jpg" alt="Figure 15.1: Selecting the installation directory" width="496" height="142"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1: Selecting the installation directory</p>
			<ol>
				<li value="2">Leave the default <span class="No-Break">components as-is<a id="_idTextAnchor1658"/>:</span></li>
			</ol>
			<div>
				<div id="_idContainer162" class="IMG---Figure">
					<img src="image/B18621_15_02.jpg" alt="Figure 15.2: Selecting components to install" width="543" height="196"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2: Selecting components to install</p>
			<ol>
				<li value="3">Leave the default <span class="No-Break">data directory:</span><a id="_idTextAnchor1659"/></li>
			</ol>
			<div>
				<div id="_idContainer163" class="IMG---Figure">
					<img src="image/B18621_15_03.jpg" alt="Figure 15.3: Selecting the data directory" width="557" height="147"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3: Selecting the data directory</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You will be asked for a password. You need to remember this because this is the master password for <span class="No-Break">your database.</span></p>
			<p><strong class="source-inline">Start!123</strong> is the password for<a id="_idIndexMarker956"/> this example. The database is running on local port <strong class="source-inline">5432</strong>. The <strong class="source-inline">pgAdmin</strong> GUI tool will also be installed, and, once the installer completes, you can<a id="_idIndexMarker957"/> start <strong class="source-inline">pgAdmin</strong> to connect to <span class="No-Break">the database.</span></p>
			<p>In your browser, go to <a href="https://packt.live/2PKWc5w">https://packt.live/2PKWc5w</a> to access the <span class="No-Break">admin interface<a id="_idTextAnchor1660"/>:</span></p>
			<div>
				<div id="_idContainer164" class="IMG---Figure">
					<img src="image/B18621_15_04.jpg" alt="Figure 15.4: The admin interface" width="800" height="176"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.4: The admin interface</p>
			<p>Once the installation is complete, you can create new databases through <strong class="source-inline">pgAdmin</strong> and call them whatever you want, but for the next few steps, make sure you have one database called just <strong class="source-inline">postgres</strong> to which we will connect via Go. We are now ready to proceed to the next part and connect to the database <span class="No-Break">via G<a id="_idTextAnchor1661"/>o.</span></p>
			<h1 id="_idParaDest-385">Database API and driv<a id="_idTextAnchor1662"/>ers</h1>
			<p>A database is a place where data is stored; we normally use database engines, which are software applications that allow us to create and interact with databases. A lot of different database engines exist, and they give us different ways of structuring the data. Nowadays, many different kinds of databases exist, but <a id="_idIndexMarker958"/>the most used and solid are the ones called <em class="italic">SQL databases</em>. <strong class="bold">SQL</strong> is a standard that stands for <strong class="bold">Structured Query Language</strong>. This is a standardized language<a id="_idIndexMarker959"/> that specifies how a database engine should respond to specific commands from the user. As its name suggests, it’s a language that allows us to perform queries on a<a id="_idIndexMarker960"/> database engine – that is, ask it to perform <span class="No-Break">those actions.</span></p>
			<p>To work with databases, there is<a id="_idIndexMarker961"/> something called the <em class="italic">pure</em> Go approach, which means Go has an API that allows you to use different drivers to connect to databases. The API comes from the <strong class="source-inline">database/sql</strong> package, and the drivers can be of two types. There is native support for a wide variety of drivers, all of which can be found on the official GitHub page (<a href="https://packt.live/2LMzcC4">https://packt.live/2LMzcC4</a>), and there are third-party drivers that need additional packages to function, such as the <strong class="source-inline">SQLlite3</strong> package, which requires you to have <strong class="source-inline">GCC</strong> installed because it is a pure <span class="No-Break">C implementation.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">GCC is a compiler system produced by the GNU Project. It takes your source code and translates it into machine code so that your computer can run <span class="No-Break">the application.</span></p>
			<p>Here is a list of a couple <span class="No-Break">of drivers:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="bold">MySQL</strong></span><span class="No-Break"> (</span><a href="https://packt.live/38zk9Fw"><span class="No-Break">https://packt.live/38zk9Fw</span></a><span class="No-Break">)</span></li>
				<li><span class="No-Break"><strong class="bold">Oracle</strong></span><span class="No-Break"> (</span><a href="https://packt.live/34cxwrP"><span class="No-Break">https://packt.live/34cxwrP</span></a><span class="No-Break">)</span></li>
				<li><span class="No-Break"><strong class="bold">ODBC</strong></span><span class="No-Break"> (</span><a href="https://packt.live/2EfETV8"><span class="No-Break">https://packt.live/2EfETV8</span></a><span class="No-Break">)</span></li>
				<li><span class="No-Break"><strong class="bold">Postgres</strong></span><span class="No-Break"> (</span><a href="https://packt.live/35jKEwL"><span class="No-Break">https://packt.live/35jKEwL</span></a><span class="No-Break">)</span></li>
			</ul>
			<p>The idea behind the API and driver approach is that Go provides a unified interface that allows developers to talk to different types of databases. All you need to do is import the API and the necessary driver and you can talk to the database. You don’t need to learn driver-specific implementations or how that driver works because the API’s sole purpose is to create an abstraction layer that <span class="No-Break">accelerates development.</span></p>
			<p>Let’s consider an example. Let’s say we would like to have a script that queries a database. This database is MySQL. One approach is to take the driver and learn how to code in its language, and then you are good <a id="_idIndexMarker962"/>to go. Some time passes by, and you build lots of small scripts that do their job <a id="_idIndexMarker963"/>properly. Now, the time has come for a management decision that will make you unhappy. They decide that MySQL is not good enough, and they are going to replace the database with AWS Athena, a <span class="No-Break">cloud-based database.</span></p>
			<p>Now, since you wrote your scripts specifically for a certain driver, you will be busy rewriting your scripts for them to work properly. The safeguard here is to use a unified API and driver combination. This means writing the scripts against the API and not the driver. The API will translate your wishes for the specific driver. This way, all you need to do is swap out the driver, and the scripts are guaranteed to work. You just saved yourself many hours of scripting and rewriting code, even though the underlying database has been <span class="No-Break">completely replaced.</span></p>
			<p>When we are working with databases in Go, we can differentiate between the following types <span class="No-Break">of databases:</span></p>
			<ul>
				<li><span class="No-Break">Relational databases</span></li>
				<li><span class="No-Break">NoSQL databases</span></li>
				<li>Search and <span class="No-Break">analytic databases</span></li>
			</ul>
			<p>In our case, we will focus on relational databases, which mostly use the <span class="No-Break">SQL l<a id="_idTextAnchor1663"/>anguage.</span></p>
			<h1 id="_idParaDest-386">Connecting to <a id="_idTextAnchor1664"/>databases</h1>
			<p>Connecting to a database is by far the <a id="_idIndexMarker964"/>easiest thing to do; however, we need to keep a few things in mind. To connect to any database, we need at least four things to be <span class="No-Break">in place:</span></p>
			<ul>
				<li>We need a host to <span class="No-Break">connect to</span></li>
				<li>We need a database to connect to that is running on <span class="No-Break">a port</span></li>
				<li>We need <span class="No-Break">a username</span></li>
				<li>We need <span class="No-Break">a password</span></li>
			</ul>
			<p>The user needs to have appropriate privileges because we not only want to connect but we would like to perform specific operations, such as query, insert, or remove data, create or delete databases, and manage users and views. Let’s imagine that connecting to a database is like walking up to a door as a specific person with a specific key. Whether the door opens or not depends on the key, but what we can do after we have crossed the threshold will depend on<a id="_idIndexMarker965"/> the person (which is defined by <span class="No-Break">their privileges).</span></p>
			<p>In most cases, the database server supports multiple databases, and the databases hold one or <span class="No-Break">more tables:</span></p>
			<div>
				<div id="_idContainer165" class="IMG---Figure">
					<img src="image/B18621_15_05.jpg" alt="Figure 15.5 – Databases in a server" width="771" height="341"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.5 – Databases in a server</p>
			<p>Imagine that the databases are logical containers that <span class="No-Break">belong together.</span></p>
			<h2 id="_idParaDest-387"><a id="_idTextAnchor1665"/>Creating a new project</h2>
			<p>First, let’s create a new project. To do so, create <a id="_idIndexMarker966"/>a folder called <strong class="source-inline">database1</strong> and go to this folder with your terminal. Inside the folder, write <span class="No-Break">the following:</span></p>
			<pre class="console">
go mod init</pre>			<p>Let’s take a look at how we can connect to a database in Go. To connect, we need to get the appropriate module from GitHub, which needs internet connectivity. We need to issue the following command to get <a id="_idIndexMarker967"/>the package needed to interact with the <span class="No-Break">Postgres instance:</span></p>
			<pre class="console">
go get github.com/lib/pq</pre>			<p class="callout-heading">Note</p>
			<p class="callout">This chapter uses the <strong class="source-inline">pq</strong> package to connect to the database. However, alternative packages are available that can be used <span class="No-Break">here instead.</span></p>
			<p>Remember to run it from within your project’s folder. Once this is completed, you are ready to start scripting. First, we will initialize <span class="No-Break">our script:</span></p>
			<pre class="source-code">
package main
import "fmt"
import "database/sql"
import _ "github.com/lib/pq"
<strong class="source-inline">// import _ &lt;package name&gt;</strong> is a special <strong class="source-inline">import</strong> statement that tells Go to import a package solely for its side effects.</pre>			<p class="callout-heading">Note</p>
			<p class="callout">If you would like further information, please <span class="No-Break">visit </span><a href="https://packt.live/2PByusw"><span class="No-Break">https://packt.live/2PByusw</span></a><span class="No-Break">.</span></p>
			<p>Now that we have initialized our script, we can connect to <span class="No-Break">our database:</span></p>
			<pre class="source-code">
db, err := sql.Open("postgres", "user=postgres password=Start!123 host=127.0.0.1 port=5432 dbname=postgres sslmode=disable")</pre>			<p>This topic is special because the API gives us an <strong class="source-inline">Open()</strong> function, which takes a variety of arguments. There are shorthand ways of doing this, but I would like you to know about all the components that are involved in making the connections, so I will use the longer way. Later, you can decide which one <span class="No-Break">to use.</span></p>
			<p>The <strong class="source-inline">postgres</strong> string, used as the first parameter in the <strong class="source-inline">Open</strong> function call, tells the function to use the <strong class="source-inline">Postgres</strong> driver to make the connection. The second argument is a so-called connection string, which holds the <strong class="source-inline">user</strong>, <strong class="source-inline">password</strong>, <strong class="source-inline">host</strong>, <strong class="source-inline">port</strong>, <strong class="source-inline">dbname</strong>, and <strong class="source-inline">sslmode</strong> arguments; these will be used to initialize the connection. In this example, we’re connecting to the local host marked by <strong class="source-inline">127.0.0.1</strong> on the default port of <strong class="source-inline">5432</strong>, and we don’t use <strong class="source-inline">ssl</strong>. For production systems, people tend to change the default port and enforce encrypted traffic via <strong class="source-inline">ssl</strong> toward the database server; you should always follow the best <a id="_idIndexMarker968"/>practices concerning the type of database you’re <span class="No-Break">working with.</span></p>
			<p>As you can see, the <strong class="source-inline">Open()</strong> function <a id="_idIndexMarker969"/>returns two values. One is for the database connection and the other is for the error, if one occurred during initialization. How do we check whether the initialization was successful? Well, we can check whether there were any errors by writing the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
if err != nil {
  panic(err)
}else{
  fmt.Println("The connection to the DB was successfully initialized!")
}</pre>			<p>The <strong class="source-inline">panic()</strong> function in Go is used to indicate that something went wrong unexpectedly, and we are not prepared to handle it gracefully, thus stopping the execution. If the connection succeeds, we print out a message stating <strong class="source-inline">The connection to the DB was successfully initialized!</strong>. When you have a long-running application, it is worth incorporating a way to check whether the database is still reachable because due to intermittent network errors, you could lose the connection and fail to execute whatever you want to execute. This can be checked with the following small <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
connectivity := db.Ping()
if connectivity != nil{
  panic(err)
}else{
  fmt.Println("Good to go!")
}</pre>			<p>You can run this check constantly on a different Go routine every few seconds. It will check if the database is on but also help keep the connection open; otherwise, it will go idle. This is a proactive solution as<a id="_idIndexMarker970"/> you check the status of the <span class="No-Break">database connection.</span></p>
			<p>In this case, we used the <strong class="source-inline">panic()</strong> function to indicate that the connection has been lost. Finally, once our job is done, we need to terminate our connection to the database to remove user sessions and free <a id="_idIndexMarker971"/>up resources. This can happen either if you are building a script that will run as a job, hence will run and finish, or if you are building a long-running service. In the first case, you can use the following command at the end of <span class="No-Break">the script:</span></p>
			<pre class="source-code">
db.Close()</pre>			<p>This ensures that before terminating the script, the connection will be dropped. If you are building a long-running service, you don’t have a specific point in your code where you know that the script will terminate, but it can happen at any time. You can use the following code to ensure the connections <span class="No-Break">are dropped:</span></p>
			<pre class="source-code">
defer db.Close()</pre>			<p>The difference is the scope. <strong class="source-inline">db.Close()</strong> will terminate the connection to the database once the execution arrives at the specific line, while <strong class="source-inline">defer db.Close()</strong> indicates that the database connection should be executed once the function in which it was called goes out of scope. The idiomatic way to do this is with <span class="No-Break"><strong class="source-inline">defer db.Close()</strong></span><span class="No-Break">.</span></p>
			<p>In the next section, we will start using the connection for something more purposeful, and we will start by <span class="No-Break">creating tables.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The official <strong class="source-inline">Postgres</strong> library for Go can be found <span class="No-Break">at </span><a href="https://packt.live/35jKEwL"><span class="No-Break">https://pack<span id="_idTextAnchor1666"/>t.live/35jKEwL</span></a><span class="No-Break">.</span><a id="_idTextAnchor1667"/></p>
			<h1 id="_idParaDest-388"><a id="_idTextAnchor1668"/>Creating tables</h1>
			<p>The act of creating tables aims to make logical containers that persistently hold data that belongs together. You will need to create tables for many reasons – for example, tracking employee attendance, revenue<a id="_idIndexMarker972"/> tracking, and statistics. The common goal is to provide a service for applications that make sense of it. How do these database engines control who can access what data? There are <span class="No-Break">two approaches:</span></p>
			<ul>
				<li>The first one is <strong class="bold">access control lists</strong> (<strong class="bold">ACLs</strong>), which is a<a id="_idIndexMarker973"/> simple yet powerful approach. ACL security logic tells us which user has which permissions, such as <strong class="source-inline">CREATE</strong>, <strong class="source-inline">UPDATE</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break">.</span></li>
				<li>The second approach involves inheritance and roles. This is more robust and is better suited for <span class="No-Break">big enterprises.</span></li>
			</ul>
			<p><strong class="source-inline">Postgres</strong> uses the second approach, and in this section, we will learn how to create a SQL table and how to create one specifically <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">Postgres</strong></span><span class="No-Break">.</span></p>
			<p>The general syntax for table creation looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
CREATE TABLE table_name (
  column1 datatype constrain,
  column2 datatype constrain,
  column3 datatype constrain,
  ....
);</pre>			<p>When we talk via SQL to the <strong class="source-inline">Postgres</strong>, <strong class="source-inline">mysql</strong>, or <strong class="source-inline">mssql</strong> server, they all respond in the same way to a <strong class="source-inline">CREATE TABLE</strong> or <strong class="source-inline">INSERT</strong> command because they are SQL compliant. The idea of the standard is not to specify how the engine works internally but how the interaction with it should happen. These database engines usually differ in terms of functionality, speed, and storage approaches; that’s where the variety comes from. This is not, however, a full SQL or database engine tutorial, so we just gave you a brief introduction to what SQL is without going into a lot <span class="No-Break">of details</span><span class="No-Break">.</span></p>
			<p>Let’s see some of the general statements of the SQL language, with which we will then experiment a bit later. The statement for table creation is <strong class="source-inline">CREATE TABLE</strong>. This command is understood in the context of the database you are connected to. One server can host multiple databases, and connecting to the wrong one can cause headaches when issuing a command that modifies the structure. The command usually takes a column name, which is <strong class="source-inline">column1</strong> in our case, and the type of data in our column, which is <strong class="source-inline">datatype</strong>. Finally, we can set <a id="_idIndexMarker974"/>constraints on our columns, which will imbue them with special properties. The supported data types for our columns depend on the <span class="No-Break">database engine.</span></p>
			<p>Here are some common <span class="No-Break">data types:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">INT</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">DOUBLE</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">FLOAT</strong></span></li>
				<li><strong class="source-inline">VARCHAR</strong>, which is a string with a <span class="No-Break">specific length</span></li>
			</ul>
			<p>The constraints also depend on the database engine, but some of them are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">NOT NULL</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">PRIMARY KEY</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Named function</strong></span></li>
			</ul>
			<p>The named function is executed every time a new record is inserted or an old one is updated and, based on the evaluation of the transaction, is either allowed <span class="No-Break">or denied.</span></p>
			<p>We are not only able to create a table, but we can also empty the table – that is, remove all of its contents, or remove the table itself from the database. To empty a table, we can use the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
TRUNCATE TABLE table_name</pre>			<p>To remove the table, we can use <span class="No-Break">the following:</span></p>
			<pre class="source-code">
DROP TABLE table_name</pre>			<p>Now, create a new table. In <strong class="source-inline">Postgres</strong>, you have a default database you can use; we are not going to create a separate database for the examples in <span class="No-Break">this chapter.</span></p>
			<p>We would like to initialize our script, which you can find in the examples folder, and it’s <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">DBInit.go</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
package main
import (
  "fmt"
  "database/sql"
_ "github.com/lib/pq"
)</pre>			<p>Now, we are ready to define<a id="_idIndexMarker975"/> our <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span></p>
			<p><span class="No-Break"><strong class="source-inline">DBInit.go</strong></span></p>
			<pre class="source-code">
func main(){
  db, err := sql.Open("postgres", "user=postgres password=Start!123 host=127.0.0.1 port=5432 dbname=postgres sslmode=disable")
  if err != nil {
    panic(err)
  }else{
    fmt.Println("The connection to the DB was successfully initialized!")
  }
  DBCreate := `
  CREATE TABLE public.test (
    id integer,
    name character varying COLLATE pg_catalog."default"
  )
  WITH (
    OIDS = FALSE
  )
`
  _, err = db.Exec(DBCreate),
  if err != nil {
    panic(err)
  } else{
    fmt.Println("The table was successfully created!")
  }
  db.Close()</pre>			<p>The full code is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBInit.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBInit.go</span></a><span class="No-Break">.</span></p>
			<p>Let’s dissect what is happening here. We initialize our connection to the database without the default username and password <a id="_idIndexMarker976"/>that was previously mentioned, and now, we have the <strong class="source-inline">db</strong> variable to interact with the database. Unless there was an error upon execution, the following output will be visible in <span class="No-Break">our console:</span></p>
			<div>
				<div id="_idContainer166" class="IMG---Figure">
					<img src="image/B18621_15_06.jpg" alt="Figure 15.6 – The desired output, as visible in the console" width="520" height="39"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.6 – The desired output, as visible in the console</p>
			<p>If we were to rerun the script, the following error <span class="No-Break">would occur:</span></p>
			<div>
				<div id="_idContainer167" class="IMG---Figure">
					<img src="image/B18621_15_07.jpg" alt="Figure 15.7 – Output of failure after consecutive execution" width="587" height="148"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.7 – Output of failure after consecutive execution</p>
			<p>This says that the table already exists. We created a multiline string called <strong class="source-inline">DBCreate</strong> that holds all the table creation information. In this, we have a table called <strong class="source-inline">test</strong>, which has an integer column called <strong class="source-inline">id</strong> and a string column called <strong class="source-inline">name</strong>. The rest of it is Postgres-specific configuration. The tablespace defines where our table lives. The <strong class="source-inline">_, err</strong> line with <strong class="source-inline">db.Exec()</strong> is responsible for executing <span class="No-Break">the query.</span></p>
			<p>The table we are creating will have an ID (unique identifier) per row, which will be of the integer type, and a name column, which will be of the character type. The names have a few characteristics; for example, <em class="italic">COLLATE</em> defines how the data will be ordered, or better, what comes first or after when requesting data in ascending or descending order. We are taking the default<a id="_idIndexMarker977"/> collate for <strong class="source-inline">postgres</strong>, which is defined by the localization currently in <span class="No-Break">the database.</span></p>
			<p>As we’ve just said, we are going to create a table with an ID, and we will use that to identify the rows. <strong class="source-inline">Postgres</strong> provides a unique identifier for each row automatically, which is called <strong class="bold">oid</strong> (<strong class="bold">Object Identifier</strong>), but we don’t <a id="_idIndexMarker978"/>need this as we are handling it manually. Note that not all other database engines provide <span class="No-Break">the oid.</span></p>
			<p>Since our goal now is to create the table, we only care whether there are any errors; otherwise, we can use a throwaway variable to capture the output. If <strong class="source-inline">err</strong> is not <strong class="source-inline">nil</strong>, there was an error, as we saw previously. Otherwise, we assume the table was created as expected. Finally, the connection to the database <span class="No-Break">is closed.</span></p>
			<p>Now that we can connect to the database and we have a table, we c<a id="_idTextAnchor1669"/>an insert <span class="No-Break">some<a id="_idTextAnchor1670"/> data.</span></p>
			<h1 id="_idParaDest-389"><a id="_idTextAnchor1671"/>Inserting data</h1>
			<p>Long ago, when the era of web applications backed by SQL databases started to bloom, some gutsy people invented the SQL injection attack. Here, a type of authentication is done against a database via SQL<a id="_idIndexMarker979"/> queries and, for example, after converting the password with mathematical magic into hash functions, the web app executes the query with the username and password coming from the input of the form. Many servers executed something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
"SELECT password FROM Auth WHERE username=&lt;input from user&gt;"</pre>			<p>Then, the password gets rehashed; if the two hashes match, the password is good for <span class="No-Break">the user.</span></p>
			<p>The problem with this came from the <strong class="source-inline">&lt;input from user&gt;</strong> part because if the attacker was smart enough, they could reformulate the query and run additional commands. Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
"SELECT password FROM Auth WHERE username=&lt;input from user&gt; OR '1'='1'"</pre>			<p>The problem with this query is that <strong class="source-inline">OR '1' = '1'</strong> always evaluates to <strong class="source-inline">true</strong>, and it does not matter what the username is; the user’s password hash would be returned. This can be further reused to formulate an additional attack. To prevent this, Go uses something called the <strong class="source-inline">Prepare()</strong> statement, which protects against <span class="No-Break">these attacks.</span></p>
			<p>Go has two types <span class="No-Break">of substitutions:</span></p>
			<ul>
				<li>We use <strong class="source-inline">WHERE col = $1</strong> in the case <span class="No-Break">of queries</span></li>
				<li>We use <strong class="source-inline">VALUES($1,$2)</strong> in the case of inserts <span class="No-Break">or updates</span></li>
			</ul>
			<p>Let’s add some values to our tables. We are <a id="_idIndexMarker980"/>going to initialize our script in the usual way. This script can be found under the examples folder and is <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">DBInsert.go</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
package main
................
  insert, err := db.Prepare("INSERT INTO test VALUES ($1, $2)")
  if err != nil {
    panic(err)
  }
  _, err = insert.Exec(2, "second")
  if err != nil {
    panic(err)
  }
  fmt.Println("The value was successfully inserted!")
  defer db.Close()
}</pre>			<p>Upon successful execution, we’ll get the <span class="No-Break">following output:</span></p>
			<pre class="console">
The connection to the DB was successfully initialized!
The value was successfully inserted!</pre>			<p>Let’s see what’s happening with the insert part. <strong class="source-inline">db.Prepare()</strong> takes a SQL statement and imbues it with protection against<a id="_idIndexMarker981"/> SQL injection attacks. It works by restricting the values of the variable substitutions. In our case, we have two columns, so for the substitution to work, we use <strong class="source-inline">$1</strong> and <strong class="source-inline">$2</strong>. You can use any number of substitutions; you only need to make sure they result in a valid SQL statement when evaluated. When the <strong class="source-inline">insert</strong> variable is initialized without errors, it will be responsible for executing the SQL statement. It finds out how many arguments the prepared statement expects, and its sole purpose is to call the statement and perform the operation. <strong class="source-inline">insert.Exec(2,"second")</strong> inserts a new element with <strong class="source-inline">id=2</strong> and <strong class="source-inline">name='second'</strong>. If we were to check what we have in our database, we would see <span class="No-Break">the results.</span></p>
			<p>Now that we have some data in our <a id="_idTextAnchor1672"/>table, we can <span class="No-Break">query it.</span></p>
			<h2 id="_idParaDest-390">Exercise 15.01 – creating a table that h<a id="_idTextAnchor1673"/>olds a series of numbers</h2>
			<p>In this exercise, we are going to write a<a id="_idIndexMarker982"/> script that is going to create a table called <strong class="source-inline">Numbers</strong>, in which we are going to store numbers. These numbers will be inserted at a <span class="No-Break">later time.</span></p>
			<p>Create two columns, <strong class="source-inline">Number</strong> and <strong class="source-inline">Property</strong>. The <strong class="source-inline">Number</strong> column will hold numbers, while the <strong class="source-inline">Property</strong> column will be <strong class="source-inline">Odd</strong> or <strong class="source-inline">Even</strong> when <span class="No-Break">it’s created.</span></p>
			<p>Use the default <strong class="source-inline">Postgres</strong> database for the connection. The numbers should range from 0 <span class="No-Break">to 99.</span></p>
			<p>Perform the following steps to complete <span class="No-Break">this exercise:</span></p>
			<ol>
				<li>Create a file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></li>
				<li>Initialize the package with the <span class="No-Break">following lines:</span><pre class="source-code">
package main
import "fmt"
import "database/sql"
import _ "github.com/lib/pq"
func main(){</pre></li>				<li>Create a <strong class="source-inline">property</strong> <strong class="source-inline">string</strong> variable for <span class="No-Break">later use:</span><pre class="source-code">
  var property string</pre></li>				<li>Initialize the <span class="No-Break">database </span><span class="No-Break"><a id="_idIndexMarker983"/></span><span class="No-Break">connection:</span><pre class="source-code">
  db, err := sql.Open("postgres", "user=postgres password=Start!123 host=127.0.0.1 port=5432 dbname=postgres sslmode=disable")
  if err != nil {
    panic(err)
  }else{
    fmt.Println("The connection to the DB was successfully initialized!")
  }</pre></li>				<li>Create a multiline string to create <span class="No-Break">the table:</span><pre class="source-code">
  TableCreate := `
CREATE TABLE Number
(
  Number integer NOT NULL,
  Property text COLLATE pg_catalog."default" NOT NULL
)
WITH (
  OIDS = FALSE
)
TABLESPACE pg_default;
ALTER TABLE Number
  OWNER to postgres;
`</pre></li>				<li>Create <span class="No-Break">the</span><span class="No-Break"><a id="_idIndexMarker984"/></span><span class="No-Break"> table:</span><pre class="source-code">
  _, err = db.Exec(TableCreate)
  if err != nil {
    panic(err)
  } else{
    fmt.Println("The table called Numbers was successfully created!")
  }</pre></li>				<li>Insert <span class="No-Break">the numbers:</span><pre class="source-code">
  insert, insertErr := db.Prepare("INSERT INTO Number VALUES($1,$2)")
  if insertErr != nil{
    panic(insertErr)
  }
  for i := 0; i &lt; 100; i++ {
    if i % 2 == 0{
      prop = "Even"
    }else{
      prop = "Odd"
    }
    _, err = insert.Exec(i,prop)
    if err != nil{
      panic(err)
    }else{
      fmt.Println("The number:",i,"is:",prop)
    }
  }
  insert.Close()
  fmt.Println("The numbers are ready.")</pre></li>				<li>Close the database <a id="_idIndexMarker985"/>connection <span class="No-Break">and function:</span><pre class="source-code">
  db.Close()
}</pre><p class="list-inset">When you execute the script, you should <a id="_idTextAnchor1674"/>see t<a id="_idTextAnchor1675"/>he <span class="No-Break">following output:</span></p></li>			</ol>
			<div>
				<div id="_idContainer168" class="IMG---Figure">
					<img src="image/B18621_15_08.jpg" alt="Figure 15.8 – Output of the successful property update" width="524" height="180"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.8 – Output of the successful property update</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Part of the output has been omitted from <span class="No-Break"><em class="italic">Figure 15</em></span><em class="italic">.8</em> due to <span class="No-Break">its length.</span></p>
			<p>In this exercise, we saw how to create a new table in our database and how to insert new records with the help of a <strong class="source-inline">for</strong> loop <a id="_idTextAnchor1676"/>and a <span class="No-Break"><strong class="source-inline">Prepare()<a id="_idTextAnchor1677"/></strong></span><span class="No-Break"> statement.</span></p>
			<h1 id="_idParaDest-391"><a id="_idTextAnchor1678"/>Retrieving data</h1>
			<p>SQL injection does not only concern the data being inserted. It also concerns any data that is manipulated in the database. Retrieving data and, most importantly, retrieving it safely is also something we must <a id="_idIndexMarker986"/>prioritize and handle with proper caution. When we query data, our results depend on the database we connect to and the table we would like to query. However, we must also mention that the security mechanisms that are implemented by the database engine may also prevent a successful query unless the user has <span class="No-Break">appropriate privileges.</span></p>
			<p>We can differentiate between two types <span class="No-Break">of queries:</span></p>
			<ul>
				<li>Some queries do not take an argument, such as <strong class="source-inline">SELECT * </strong><span class="No-Break"><strong class="source-inline">FROM table</strong></span></li>
				<li>Some queries require you to specify <span class="No-Break">filter criteria</span></li>
			</ul>
			<p>Go provides two functions that allow you to query data. One is called <strong class="source-inline">Query()</strong> and the other is called <strong class="source-inline">QueryRow()</strong>. As a rule of thumb, you should remember that <strong class="source-inline">Query()</strong> is used to return any number of results, while <strong class="source-inline">QueryRow</strong> is used when you expect to retrieve at most one row. You can also wrap them with the <strong class="source-inline">Prepare()</strong> statement, though we won’t cover this here as it was demonstrated before. Instead, we want to see how these <span class="No-Break">functions work.</span></p>
			<p>Let’s create a script for <strong class="source-inline">Query()</strong>. As always, we’ll initialize the script. It can be found in the examples and is <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">DBQuery.go</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
package main
import "fmt"
import "database/sql"
import _ "github.com/lib/pq"</pre>			<p>Our <strong class="source-inline">main()</strong> function will be a little bit different because we would like to introduce the <span class="No-Break"><strong class="source-inline">Scan()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func main(){
  var id int
  var name string
  db, err := sql.Open("postgres", "user=postgres password=Start!123 host=127.0.0.1 port=5432 dbname=postgres sslmode=disable")
  if err != nil {
    panic(err)
  }else{
    fmt.Println("The connection to the DB was successfully initialized!")
  }
  rows, err := db.Query("SELECT * FROM test")
  if err != nil {
    panic(err)
  }
  for rows.Next() {
    err := rows.Scan(&amp;id, &amp;name)
    if err != nil {
      panic(err)
    }
    fmt.Printf("Retrieved data from db: %d %s\n", id, name)
  }
  err = rows.Err()
  if err != nil {
    panic(err)
  }
  err = rows.Close()
  if err != nil {
    panic(err)
  }
  db.Close()
}</pre>			<p>The output should look <span class="No-Break">like this:</span></p>
			<pre class="console">
The connection to the DB was successfully initialized!
Retrieved data from db: 2 second</pre>			<p class="callout-heading">Note</p>
			<p class="callout">A <strong class="source-inline">SELECT *</strong> query string is not likely to be seen in professional environments due to performance and security concerns. You will typically have more specific query strings for the <span class="No-Break">specific data.</span></p>
			<p>As we inserted this data into our <a id="_idIndexMarker987"/>database previously, feel free to add some more data based on the previous example. We have defined the <strong class="source-inline">id</strong> and <strong class="source-inline">name</strong> variables, which will help our <strong class="source-inline">Scan()</strong> function. We connect to the database and create our <strong class="source-inline">db</strong> variable. After that, we fill our <strong class="source-inline">rows</strong> variable with the result of the <strong class="source-inline">Query()</strong> function, which will hold all the elements from <span class="No-Break">the table.</span></p>
			<p>Here comes the tricky part: we use <strong class="source-inline">for rows.Next()</strong> to iterate over the resulting rows. But that is not enough; we would like to assign the results of the query to the corresponding variable, which is returned by <strong class="source-inline">rows.Scan(&amp;id, &amp;name)</strong>. This allows us to refer to the current row’s ID and <strong class="source-inline">NAME</strong>, which makes it easier to do whatever we would like to do with the value. Finally, the rows and the database connections are <span class="No-Break">gracefully closed.</span></p>
			<p>Let’s query a single row with <strong class="source-inline">Prepare()</strong>. The initialization looks the same <span class="No-Break">as before:</span></p>
			<p><span class="No-Break"><strong class="source-inline">DBPrepare.go</strong></span></p>
			<pre class="source-code">
package main
import "fmt"
import "database/sql"
import _ "github.com/lib/pq"</pre>			<p>The full code is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBPrepare.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBPrepare.go</span></a><span class="No-Break">.</span></p>
			<p>The main difference is at<a id="_idIndexMarker988"/> the beginning of the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func main(){
  var name string
  var id int
  id = 2
  db, err := sql.Open("postgres", "user=postgres password=Start!123 host=127.0.0.1 port=5432 dbname=postgres sslmode=disable")
  if err != nil {
    panic(err)
  }else{
    fmt.Println("The connection to the DB was successfully initialized!")
  }
  qryrow, err := db.Prepare("SELECT name FROM test WHERE id=$1")
  if err != nil{
    panic(err)
  }
  err = qryrow.QueryRow(id).Scan(&amp;name)
  if err != nil {
    panic(err)
  }
  fmt.Printf("The name with id %d is %s", id, name)
  err = qryrow.Close()
  if err != nil {
    panic(err)
  }
  db.Close()
}</pre>			<p>The output, if you did everything <a id="_idIndexMarker989"/>correctly, should look something <span class="No-Break">like this:</span></p>
			<pre class="console">
The connection to the DB was successfully initialized!
The name with id 2 is second</pre>			<p>Let’s inspect our <strong class="source-inline">main</strong> function closely. We defined two variables: the <strong class="source-inline">name</strong> variable, which will be used when we process the query result, and the <strong class="source-inline">id</strong> variable, which serves as a flexible input for the query we execute. The usual connection initialization toward our database happens <span class="No-Break">as before.</span></p>
			<p>Then comes the <strong class="source-inline">SQL Injection</strong> proof part. We prepare a query that is dynamic in the sense that it accepts a parameter that will be the ID we are looking for. Then, <strong class="source-inline">qryrow</strong> is used to execute the <strong class="source-inline">QueryRow()</strong> function, which, in turn, takes the <strong class="source-inline">id</strong> variable we specified previously and returns the result in the <strong class="source-inline">name</strong> variable. Then, we output the string with an explanation that the value of the column is based on the <strong class="source-inline">id</strong> variable that was specified. In the end, the <strong class="source-inline">qryrow</strong> and <strong class="source-inline">db</strong> resources <span class="No-Break">are closed.</span></p>
			<p>Now that we know how to retrieve data from the database, we need to see how to update <a id="_idTextAnchor1679"/>existing data in <span class="No-Break">our d<a id="_idTextAnchor1680"/>atabase.</span></p>
			<h1 id="_idParaDest-392"><a id="_idTextAnchor1681"/>Updating existing data</h1>
			<p>When you are updating a<a id="_idIndexMarker990"/> row or multiple rows with Go, you are in trouble. The <strong class="source-inline">sql</strong> package does not provide any function called <strong class="source-inline">Update()</strong>; however, there is the <strong class="source-inline">Exec()</strong> function, which serves as a universal executor for your queries. You can execute <strong class="source-inline">SELECT</strong>, <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">DELETE</strong>, or whatever you need to execute with this function. This section will show you how you can do <span class="No-Break">this safely.</span></p>
			<p>We would like to start our script in the usual way. It can be found in the examples folder and is <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">DBUpdate.go</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
package main
import "fmt"
import "database/sql"
import _ "github.com/lib/pq"</pre>			<p>Then the magic comes. The idea is to update the <strong class="source-inline">name</strong> column’s value for a specific <strong class="source-inline">id</strong> variable that we give as an<a id="_idIndexMarker991"/> argument. So, the <strong class="source-inline">main()</strong> function looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
func main(){
  db, err := sql.Open("postgres", "user=postgres password=Start!123 host=127.0.0.1 port=5432 dbname=postgres sslmode=disable")
  if err != nil {
    panic(err)
  }else{
    fmt.Println("The connection to the DB was successfully initialized!")
  }
  UpdateStatement :=`
  UPDATE test
  SET name = $1
  WHERE id = $2
  `
  updateResult, updateResultErr := db.Exec(updateStatement,"well",2)
  if updateResultErr != nil {
    panic(updateResultErr)
  }
  updatedRecords, updatedRecordsErr := updateResult.RowsAffected()
  if updatedRecordsErr != nil {
    panic(UpdatedRecordsErr)
  }
  fmt.Println("Number of records updated: ",UpdatedRecords)
  db.Close()
}</pre>			<p>If everything has gone well, we’ll see<a id="_idIndexMarker992"/> the <span class="No-Break">following output:</span></p>
			<pre class="console">
The connection to the DB was successfully initialized!
Number of records updated: 1</pre>			<p>Note that you can and should experiment with different inputs and see how the script reacts to <span class="No-Break">different problems/errors.</span></p>
			<p>Let’s dissect what’s happening here. We initialize our database connection as we did before. We create the <strong class="source-inline">UpdateStatement</strong> variable, which is a multiline string, and it is crafted so that it can be fed to the <strong class="source-inline">Exec()</strong> function, which takes arguments. We want to update the name of the column that has the specified ID. This function either runs the specified statement on its own or can be used to pass arguments that are substituted in the appropriate place. This would be perfectly fine and would do the job for us, but we would like to make sure that the <strong class="source-inline">UPDATE</strong> command updates at least <span class="No-Break">one record.</span></p>
			<p>To this end, we could use <strong class="source-inline">RowsAffected()</strong>. It will return the number of rows that were updated and any errors that were faced along the way. Finally, we print how many rows were updated to the console and close <span class="No-Break">the connection.</span></p>
			<p>The time has come <a id="_idTextAnchor1682"/>to delete dat<a id="_idTextAnchor1683"/>a from <span class="No-Break">our database.</span></p>
			<h1 id="_idParaDest-393"><a id="_idTextAnchor1684"/>Deleting data</h1>
			<p>Data can be deleted for multiple reasons: we don’t need the data anymore, we are migrating to another database, or we are replacing the current solution. We are in luck because the current Go facilities provide a<a id="_idIndexMarker993"/> very nice way to do this. The analogy is the same as for the <strong class="source-inline">UPDATE</strong> statement of our records. We formulate a <strong class="source-inline">DELETE</strong> statement and execute it; we can technically modify the action of our <strong class="source-inline">UPDATE</strong> script to delete it from <span class="No-Break">the database.</span></p>
			<p>For the sake of simplicity, we’ll only modify the relevant lines. Our <strong class="source-inline">DELETE</strong> statement will replace the <strong class="source-inline">UPDATE</strong> statement, <span class="No-Break">like this:</span></p>
			<p><span class="No-Break"><strong class="source-inline">DBDelete.go</strong></span></p>
			<pre class="source-code">
12  DeleteStatement :=`
13  DELETE FROM test
14  WHERE id = $1
15  `</pre>			<p>The full code is available at <a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBDelete.go">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBDelete.go</a>. We’ll update the line with the <span class="No-Break"><strong class="source-inline">Exec()</strong></span><span class="No-Break"> statement:</span></p>
			<pre class="source-code">
  deleteResult, deleteResultErr := db.Exec(deleteStatement,2)
  if deleteResultErr != nil {
    panic(deleteResultErr)
  }</pre>			<p>Also, we must update the line with the calculation of <span class="No-Break">updated records:</span></p>
			<pre class="source-code">
  deletedRecords, deletedRecordsErr := deleteResult.RowsAffected()
  if deletedRecordsErr != nil {
    panic(deletedRecordsErr)
  }
  fmt.Println("Number of records deleted: ",deletedRecords)</pre>			<p>Our result should look <span class="No-Break">like this:</span></p>
			<pre class="console">
The connection to the DB was successfully initialized!
Number of records deleted: 1</pre>			<p>That’s it. With a little modification, we<a id="_idIndexMarker994"/> have a script that can either update or delete records <span class="No-Break">with verification.</span></p>
			<p>Now, let’s see how we can creat<a id="_idTextAnchor1685"/>e a table that holds <span class="No-Break">prime numbers.</span></p>
			<h2 id="_idParaDest-394">Exercise 15.02 –<a id="_idTextAnchor1686"/> holding prime numbers in a database</h2>
			<p>In this exercise, we will build on <em class="italic">Exercise 15.01 – creating a table that holds a series of numbers</em>. We would like to create a script that will tell us how many prime numbers are in our table and give them to us in <a id="_idIndexMarker995"/>order of appearance. We would like to see the sum of prime numbers in the output. Then, we would like to remove every even number from the table and see how many were removed. We would like to add the sum of prime numbers to the remaining odd numbers and update the table with the records, changing the property if necessary. Use the <strong class="source-inline">math/big</strong> package for the <span class="No-Break">primality test.</span></p>
			<p>Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Create a script <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></li>
				<li>Initialize our script to perform the <span class="No-Break">specific actions:</span><pre class="source-code">
package main
import "fmt"
import "database/sql"
import _ "github.com/lib/pq"
import "math/big"
func main(){</pre></li>				<li>Define four variables for <span class="No-Break">later use:</span><pre class="source-code">
  var number int64
  var prop string
  var primeSum int64
  var newNumber int64</pre></li>				<li>Initialize the <span class="No-Break">database </span><span class="No-Break"><a id="_idIndexMarker996"/></span><span class="No-Break">connection:</span><pre class="source-code">
  db, err := sql.Open("postgres", "user=postgres password=Start!123 host=127.0.0.1 port=5432 dbname=postgres sslmode=disable")
  if err != nil {
    panic(err)
  }else{
    fmt.Println("The connection to the DB was successfully initialized!")
  }</pre></li>				<li>Get a list of all the <span class="No-Break">prime numbers:</span><pre class="source-code">
  allTheNumbers := "SELECT * FROM Number"
  numbers, err := db.Prepare(allTheNumbers)
  if err != nil {
    panic(err)
  }
  primeSum = 0
  result, err := numbers.Query()
  fmt.Println("The list of prime numbers:")
  for result.Next(){
    err = result.Scan(&amp;number, &amp;prop)
    if err != nil{
      panic(err)
    }
    if big.NewInt(number).ProbablyPrime(0) {
      primeSum += number
      fmt.Print(" ",number)
    }
  }
  err := numbers.Close()
  if err != nil{
    panic(err)
  }</pre></li>				<li>Print the sum of the <span class="No-Break">prime</span><span class="No-Break"><a id="_idIndexMarker997"/></span><span class="No-Break"> numbers:</span><pre class="source-code">
  fmt.Println("\nThe total sum of prime numbers in this range is:", primeSum)</pre></li>				<li>Remove the <span class="No-Break">even numbers:</span><pre class="source-code">
  remove := "DELETE FROM Number WHERE Property=$1"
  removeResult, err := db.Exec(remove,"Even")
  if err != nil {
    panic(err)
  }
  modifiedRecords, err := removeResult.RowsAffected()
  fmt.Println("The number of rows removed:",ModifiedRecords)
  fmt.Println("Updating numbers...")</pre></li>				<li>Update the remaining records with <strong class="source-inline">primeSum</strong> and print a <span class="No-Break">closing sentence:</span><pre class="source-code">
  update := "UPDATE Number SET Number=$1 WHERE Number=$2 AND Property=$3"
  allTheNumbers = "SELECT * FROM Number"
  numbers, err = db.Prepare(allTheNumbers)
  if err != nil {
    panic(err)
  }
  result, err = numbers.Query()
for result.Next(){
    err = result.Scan(&amp;number, &amp;prop)
    if err != nil{
      panic(err)
    }
    newNumber = number + primeSum
    _, err = db.Exec(update,newNumber,number,prop)
    if err != nil {
      panic(err)
    }
  }
  numbers.Close()
  if err != nil{
    panic(err)
  }
  fmt.Println("The execution is now complete...")</pre></li>				<li>Close the <span class="No-Break">database </span><span class="No-Break"><a id="_idIndexMarker998"/></span><span class="No-Break">connection:</span><pre class="source-code">
  db.Close() 
  }</pre><p class="list-inset">Once the script has been executed, th<a id="_idTextAnchor1687"/>e following output should <span class="No-Break">be visible:</span></p></li>			</ol>
			<div>
				<div id="_idContainer169" class="IMG---Figure">
					<img src="image/B18621_15_09.jpg" alt="Figure 15.9 – Output of the calculations" width="606" height="115"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.9 – Output of the calculations</p>
			<p>In this exercise, we saw how to<a id="_idIndexMarker999"/> utilize a built-in Go function to find prime numbers. We also manipulated the table by removing numbers, and then we performed <span class="No-Break">update actions.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Closing the database is important because once our job is done, <a id="_idTextAnchor1688"/>we do want to release <span class="No-Break">unused <a id="_idTextAnchor1689"/>resources.</span></p>
			<h1 id="_idParaDest-395"><a id="_idTextAnchor1690"/>Truncating and deleting table</h1>
			<p>In this section, we want to empty a table and get rid of it. To empty the table, we can simply formulate <strong class="source-inline">DELETE</strong> statements that <a id="_idIndexMarker1000"/>match every record in our table and thus remove every single record from our table. However, there is a more elegant way to do this: we can use the <strong class="source-inline">TRUNCATE TABLE</strong> SQL statement. The result of this statement is an empty table. We<a id="_idIndexMarker1001"/> can use the <strong class="source-inline">Exec()</strong> function from our <strong class="source-inline">sql</strong> package for this. You already know how to initialize the package with imports. You also know how to connect to the database. This time, we’ll only focus on <span class="No-Break">the statements.</span></p>
			<p>The following statement will achieve a <span class="No-Break">full </span><span class="No-Break"><strong class="source-inline">TRUNCATE</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
emptyTable, emptyTableErr := db.Exec("TRUNCATE TABLE test")
if emptyTableErr != nil {
  panic(emptyTableErr)
}</pre>			<p>The result of this is an empty table called <strong class="source-inline">test</strong>. To get rid of the table completely, we can modify our statement <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
dropTable, dropTableErr := db.Exec("DROP TABLE test")
if dropTableErr != nil {
  panic(dropTableErr)
}</pre>			<p>If you need a table but do not need any more old data, you might want to truncate it and carry on adding new data to the existing table. If you do not need the table anymore because you changed your schema, you might want to just delete it using the <span class="No-Break"><strong class="source-inline">DROP</strong></span><span class="No-Break"> command.</span></p>
			<p>If we inspect our database engine, we<a id="_idIndexMarker1002"/> won’t find any trace of the <strong class="source-inline">test</strong> table. This eradicated the whole table from<a id="_idIndexMarker1003"/> the very face of <span class="No-Break">the database.</span></p>
			<p>This section was all about interacting with databases via the Go programming language. Now, you have a decent understanding of how to <span class="No-Break">get started.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">For further information and extra details, you should check out the official documentation <a id="_idTextAnchor1691"/>of the SQL <span class="No-Break">API: </span><a href="https://packt.live/2Pi5oj5"><span class="No-Break">https://packt.live/2Pi5oj5</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-396">A<a id="_idTextAnchor1692"/>ctivity 15.01 – holding user data in a table</h2>
			<p>In this activity, we are going to create a table that is going to hold user information such as <strong class="source-inline">ID</strong>, <strong class="source-inline">Name</strong>, and <strong class="source-inline">Email</strong>. We’ll build on<a id="_idIndexMarker1004"/> the knowledge you gathered in the <em class="italic">Creating tables</em> and <em class="italic">Inserting </em><span class="No-Break"><em class="italic">data</em></span><span class="No-Break"> sections.</span></p>
			<p>Follow these steps to complete <span class="No-Break">this activity:</span></p>
			<ol>
				<li>Create a small script that will create a table called <strong class="source-inline">Users</strong>. This table must have three columns: <strong class="source-inline">ID</strong>, <strong class="source-inline">Name</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Email</strong></span><span class="No-Break">.</span></li>
				<li>Add the details of two users, along with their data, to the table. They should have unique names, IDs, and <span class="No-Break">email addresses.</span></li>
				<li>Then, you need to update the email of the first user to <strong class="source-inline">user@packt.com</strong> and remove the second user. Make sure that none of the fields are <strong class="source-inline">NULL</strong>. Since the ID is the primary key, it needs to <span class="No-Break">be unique.</span></li>
				<li>When you are inserting, updating, and deleting from the table, please use the <strong class="source-inline">Prepare()</strong> function to protect against SQL <span class="No-Break">injection attacks.</span></li>
				<li>You should use a struct to store the user information you would like to insert, and when you are inserting, iterate over the struct with a <span class="No-Break"><strong class="source-inline">for</strong></span><span class="No-Break"> loop.</span></li>
				<li>Once the <strong class="source-inline">insert</strong>, <strong class="source-inline">update</strong>, and <strong class="source-inline">delete</strong> calls are complete, make sure you use <strong class="source-inline">Close()</strong> when<a id="_idIndexMarker1005"/> appropriate and close the connection to <span class="No-Break">the database.</span><p class="list-inset">Upon successful compl<a id="_idTextAnchor1693"/>etion, you should see the <span class="No-Break">following output:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer170" class="IMG---Figure">
					<img src="image/B18621_15_10.jpg" alt="Figure 15.10 – Possible output" width="1650" height="288"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.10 – Possible output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found <span class="No-Break">on </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Activity15.01/main.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Activity15.01/main.go</span></a><span class="No-Break">.</span></p>
			<p>By the end of this activity, you should have learned how to create a new table <a id="_idTextAnchor1694"/>called <strong class="source-inline">users</strong> and how to insert data <span class="No-Break">into it.</span></p>
			<h2 id="_idParaDest-397">Activity 1<a id="_idTextAnchor1695"/>5.02 – finding the messages of specific users</h2>
			<p>In this activity, we will build on <em class="italic">Activity 15.01 – holding user data in </em><span class="No-Break"><em class="italic">a table</em></span><span class="No-Break">.</span></p>
			<p>We need to create a new table <a id="_idIndexMarker1006"/>called <strong class="source-inline">Messages</strong>. This table will have two columns, both of which should have a 280-character limit: one is <strong class="source-inline">UserID</strong> and the other <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Message</strong></span><span class="No-Break">.</span></p>
			<p>When your table is ready, you should add some messages with user IDs. Make sure you add <strong class="source-inline">UserID</strong>, which is not present in the <span class="No-Break"><strong class="source-inline">users</strong></span><span class="No-Break"> table.</span></p>
			<p>Once you have added the data, write a query that returns all the messages a specified user has sent. Use the <strong class="source-inline">Prepare()</strong> function to protect against <span class="No-Break">SQL injection.</span></p>
			<p>If the specified user cannot be found, print <strong class="source-inline">The query returned nothing, no such user: &lt;username&gt;</strong>. You <a id="_idIndexMarker1007"/>should take the username as input from <span class="No-Break">the keyboard.</span></p>
			<p>Perform these steps to complete <span class="No-Break">this activity:</span></p>
			<ol>
				<li>Define a struct that holds <strong class="source-inline">UserID</strong> and <span class="No-Break">its messages.</span></li>
				<li>Messages should be inserted with a <strong class="source-inline">for</strong> loop that iterates over the previously <span class="No-Break">defined struct.</span></li>
				<li>When the user input is received, make sure you use the <strong class="source-inline">Prepare()</strong> statement to craft <span class="No-Break">your query.</span><p class="list-inset">If everything has gone well, you should get the following output, depending on how you fil<a id="_idTextAnchor1696"/>l your database with usernames <span class="No-Break">and messages:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer171" class="IMG---Figure">
					<img src="image/B18621_15_11.jpg" alt="Figure 15.11: Expected output" width="1650" height="307"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.11: Expected output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found <span class="No-Break">on </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Activity15.02/main.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Activity15.02/main.go</span></a><span class="No-Break">.</span></p>
			<p>If you want, you can tweak the script so that you don’t recreate the database on <span class="No-Break">consecutive runs.</span></p>
			<p>By the end of this activity, you should have learned how to create a new table called <strong class="source-inline">Messages</strong>, then take input<a id="_idIndexMarker1008"/> from the user and search for related users and messages based on <span class="No-Break">the input.</span></p>
			<h1 id="_idParaDest-398"><a id="_idTextAnchor1697"/>Adding users with GORM</h1>
			<p>So far, we’ve interacted with the database by writing some SQL queries directly. What we’ve done is create and run Go code, which was used to then run SQL code. This is perfectly fine, but there is also a way to run just Go code to interact with a SQL database. On top of this, the data that we are storing in the database will then be unwrapped into Go variables, and the content of a row might define the values of an instance of a Go struct. What we can do to improve and simplify the whole process is abstract the database even more and use an <strong class="bold">object-relational mapper</strong> (<strong class="bold">ORM</strong>). This is a library that matches the tables and their relations as Go structs so that <a id="_idIndexMarker1009"/>you can insert and retrieve data the same way you would instantiate and delete any instance of a Go struct. An<a id="_idIndexMarker1010"/> ORM is not generally part of a language, and Go does not provide one by itself. There is, however, a set of third-party libraries, one of which is the de facto ORM for Go, and this is GORM. You can find all the details <a id="_idIndexMarker1011"/>of this package at <a href="https://gorm.io/">https://gorm.io/</a>, but we will briefly learn how to use it to add and search for data in <span class="No-Break">our database.</span></p>
			<p>To use GORM, we must import it. <span class="No-Break">Here’s how:</span></p>
			<pre class="source-code">
import (
  "gorm.io/gorm"
  "gorm.io/driver/postgres"
)</pre>			<p>As you can see, we do not have just one line but two. The first loads the GORM library, while the second specifies the driver to use. GORM can be used to interact with a lot of different database engines, including MySQL, Postgres, and SQLite. While the library itself is available from <a href="http://gorm.io/gorm">gorm.io/gorm</a>, the specific way to interact with the engine is handled by the driver – in this case, the <span class="No-Break">Postgres driver.</span></p>
			<p>The next step will be to define a schema – that is, a Go struct representing what’s inside a table. Let’s define a struct representing <span class="No-Break">a user:</span></p>
			<pre class="source-code">
type User struct {
  gorm.Model
  FirstName  string
  LastName   string
  Email      string
}</pre>			<p>This is pretty straightforward – we define a struct called <strong class="source-inline">User</strong> and we add some fields that will hold the first and last name of a user, together with their email address. The first important thing, however, is that we embed the <strong class="source-inline">gorm.Model</strong> struct into our struct, making it effectively a GORM model. This struct will add some fields, such as an ID, and set it as a primary<a id="_idIndexMarker1012"/> key, as well as some other fields, such as creation and update date, and will also add some methods that will be used by the library to make it interact with <span class="No-Break">a database.</span></p>
			<p>Now that we have a struct defining a user, let’s see how we can insert a user into the database. To interact with the database, we must connect to it. Earlier, we saw how to connect to PostgreSQL; we will do something <span class="No-Break">similar here:</span></p>
			<pre class="source-code">
connection_string = "user=postgres password=Start!123 host=127.0.0.1 port=5432 dbname=postgres sslmode=disable"
db, err := gorm.Open(postgres.Open(connection_string), &amp;gorm.Config{})
if err != nil {
   panic("failed to connect database")
}</pre>			<p>As you can see, we can use the same connection string as earlier, but we will do so inside the <strong class="source-inline">gorm.Open</strong> call, which allows GORM to interact with the underlying <span class="No-Break">database engine.</span></p>
			<p>So far, we haven’t created a table for the users, and we’ve seen how to create one using SQL and call it via Go. With GORM, we do not need to do that. After defining the type that will go inside the table that will hold users, we can have GORM create that table for us, if it does not exist already. We can do this with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
db.AutoMigrate(&amp;User{})</pre>			<p>This call ensures that there is a table holding users that contains all the required columns, and by default will call it <em class="italic">users</em>. There are ways to change the name of the table, but in general, it is better to follow the conventions. So, a table holding users’ data will be called <em class="italic">users</em>, while a struct holding the details of a user will be <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">User</strong></span><span class="No-Break">.</span></p>
			<p>What remains now is just to add an actual user – we will call him John Smith and use <strong class="source-inline">john.smith@gmail.com</strong> as his email address. This is how we can instantiate the struct with <span class="No-Break">his details:</span></p>
			<pre class="source-code">
u := &amp;User{FirstName: "John", LastName: "Smith", Email: "john.smith@gmail.com"}</pre>			<p>Finally, we can insert it into <a id="_idIndexMarker1013"/><span class="No-Break">the database:</span></p>
			<pre class="source-code">
db.Create(u)</pre>			<p>As you can see, this is pretty straightforward and allows us to write just Go code and model our data as <span class="No-Break">Go structs.</span></p>
			<p>GORM has quite a few functionalities; in this section, we learned how to create structs and use them to match a schema in a database, as well as add data to a specific table. Now, let’s learn how to find users <span class="No-Break">with GORM.</span></p>
			<h2 id="_idParaDest-399"><a id="_idTextAnchor1698"/>Finding Users with GORM</h2>
			<p>Once we’ve added users, we would like to retrieve them. Let’s add a few other users using what we learned in the <span class="No-Break">previous</span><span class="No-Break"><a id="_idIndexMarker1014"/></span><span class="No-Break"> section:</span></p>
			<pre class="source-code">
db.Create(&amp;User{FirstName: "John", LastName: "Doe", Email: "john.doe@gmail.com"
db.Create(&amp;User{FirstName: "James", LastName: "Smith", Email: "james.smith@gmail.com"})</pre>			<p>Let’s assume that we had already inserted the record for John Smith. So, starting from a clean database and clean table, we should have users with IDs of 1, 2, and <span class="No-Break">3, respectively.</span></p>
			<p>Now, we want to retrieve details about the first user we inserted. We can do that with the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
var user User
db.First(&amp;user, 1)</pre>			<p>This will return the first user matching the condition where the user’s ID is equal to 1. The returned record is un-marshaled into the <strong class="source-inline">user</strong> variable, which is an instance of the <strong class="source-inline">User</strong> struct. We can search for every other user via their ID and substitute the number 1 with 2 or 3. This, however, is not very interesting, as we might not know the user’s ID but only their name or surname. Let’s see how to retrieve John Doe from <span class="No-Break">his surname:</span></p>
			<pre class="source-code">
db.First(&amp;user, "last_name = ?", "Doe")</pre>			<p>Note that we did not use “LastName” but <strong class="source-inline">last_name</strong> as GORM automatically transforms every attribute of the<a id="_idIndexMarker1015"/> struct that’s camel case into snake case; this is the usual convention for database column names. The other important thing to notice is that we use <span class="No-Break">two parameters:</span></p>
			<pre class="source-code">
"last_name = ?" and "Doe"</pre>			<p>The first one represents the column we want to search in, and we have a question mark after the equals sign. The question mark is a placeholder and will be replaced by the next parameter, which is <em class="italic">Doe</em>. As we have two people with the surname Smith, the function we just used will retrieve the first person with that surname, but this is not necessarily the one we are looking for. We could use the <strong class="source-inline">Last</strong> function, which returns the last result that matches the query, but we could have more users with the same surname. The solution for this is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
db.First(&amp;user, "last_name = ? AND first_name= ?", "Smith", "James")</pre>			<p>Here, we created a query that includes more conditions – the first few parameters express the condition, while the following parameters fill the values <span class="No-Break">with placeholders.</span></p>
			<p>The issue we could face here is that we might get confused with the names of the struct’s attributes and the actual column names. If we need to do a simple matching query, we can substitute the previous code with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
db.First(&amp;user, &amp;User{FirstName: "James", LastName: "Smith"})</pre>			<p>Here, we just pass an instance of the <strong class="source-inline">User</strong> struct with a few attributes set, leaving the other ones to the <span class="No-Break">default values.</span></p>
			<p>These examples allow us to search for a specific record, but often, we need a list of objects. Of course, the <strong class="source-inline">First</strong> and <strong class="source-inline">Last</strong> functions return only one item, but GORM also gives us a function to return all the records that match our criteria. If the criteria is simply an ID, or if the field we search for is unique, we are better off sticking with <strong class="source-inline">First</strong>, but if our criteria are not unique, we should use the <span class="No-Break">following function:</span></p>
			<pre class="source-code">
var users []User
db.Find(&amp;users, &amp;User{LastName: "Smith"})</pre>			<p>The <strong class="source-inline">Find</strong> function returns all the matching records, but we cannot just un-marshal it into a single user instance. So, we<a id="_idIndexMarker1016"/> must define a <strong class="source-inline">users</strong> variable, which is a slice of <strong class="source-inline">User</strong> instances, rather than using the previously seen <strong class="source-inline">user</strong>, which was an instance of a <span class="No-Break"><strong class="source-inline">User</strong></span><span class="No-Break"> struct.</span></p>
			<p>This gives us an idea of how to use GORM to insert and retrieve data, but we’ve forgotten one important thing: errors. These functions are contacting the database, but the queries might somehow error for several reasons, and we need to control that. The previously seen function does not return an error but a pointer to the database struct, which we can use to get <span class="No-Break">the errors:</span></p>
			<pre class="source-code">
tx := db.Find(&amp;users, &amp;User{LastName: "Smith"})
if tx.Error != nil {
  fmt.Println(tx.Error)
}</pre>			<p>Here, the <strong class="source-inline">tx</strong> variable stands for <em class="italic">transaction</em> and returns a set of values with a potential error among them. We can check if there is an error by comparing the <strong class="source-inline">tx.Error </strong>value with <strong class="source-inline">nil</strong>. When we use a transaction, whatever we do to the database is not definitive; it does not affect the state of the database that’s accessed by any other client, so any change is temporary. To make any change effective, we need to commit the transaction. In this case, we are just returning results, and not modifying the database, so we do not need to commit. We are using the transactions because GORM returns a transaction from the <span class="No-Break"><strong class="source-inline">Find</strong></span><span class="No-Break"> call.</span></p>
			<p>This gives us a starting point to use GORM<a id="_idTextAnchor1699"/> to mod<a id="_idTextAnchor1700"/>el and use data while storing it in <span class="No-Break">a database.</span></p>
			<h1 id="_idParaDest-400"><a id="_idTextAnchor1701"/>Summary</h1>
			<p>This chapter made you efficient in interacting with SQL databases. You learned how to create, delete, and manipulate database tables. You also become aware of all the different types of databases Go is suited to interact with. As this chapter was made with the PostgreSQL engine in mind, you should familiarize yourself with its Go <span class="No-Break">module too.</span></p>
			<p>With this knowledge, you will now be able to step foot into the realm of database programming with the Go language and be self-sufficient in the sense that you know where to look for solutions to problems and extra knowledge. The most common use case for this knowledge is when you must build automated reporting apps that pull data from a database and report it as an email. The other use case is when you have an automated app for pushing data to the database server that processes a CSV file or an XML file. This depends on the situation you <span class="No-Break">are in.</span></p>
			<p>This chapter also introduced you to the concept of ORM and has given you an introduction to the most famous ORM for the Go <span class="No-Break">language: GORM.</span></p>
			<p>In the next chapter, you will learn how to interact with web interfaces via HTTP clients, which is one of the most interesting topics <span class="No-Break">in Go.</span></p>
		</div>
	</div></div>
<div id="book-content"><div id="sbo-rt-content"><div id="_idContainer173" class="Content">
			<h1 id="_idParaDest-401" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor1702"/>Part 5: Building For The Web</h1>
			<p>The modern world has been profoundly influenced by the Internet and the World Wide Web. Go, born in the internet age, was meticulously crafted to thrive in this <span class="No-Break">digital landscape.</span></p>
			<p>This section delves into the realm of web development with Go, empowering you to create robust and efficient <span class="No-Break">web applications.</span></p>
			<p>This section includes the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18621_16.xhtml#_idTextAnchor1704"><em class="italic">Chapter 16</em></a>, <em class="italic">Web Servers</em></li>
				<li><a href="B18621_17.xhtml#_idTextAnchor1790"><em class="italic">Chapter 17</em></a>, <em class="italic">Using the Go HTTP Client</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer174">
			</div>
		</div>
	</div></div></body></html>