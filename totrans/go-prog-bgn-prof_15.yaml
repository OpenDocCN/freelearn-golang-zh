- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: SQL and Databases
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 和数据库
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will introduce you to databases – specifically relational databases
    – and how to access them via the Go programming language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍数据库——特别是关系数据库——以及如何通过 Go 编程语言访问它们。
- en: This chapter will guide you through how to connect to the SQL database engine,
    how to create a database, how to create tables in a database, and how to insert
    and retrieve data in and from tables. By the end of this chapter, you will be
    able to update and delete data in specific tables, as well as truncate and drop
    tables.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将指导你如何连接到 SQL 数据库引擎，如何创建数据库，如何在数据库中创建表，以及如何在表中插入和检索数据。到本章结束时，你将能够更新和删除特定表中的数据，以及截断和删除表。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you’ll require Go version 1.21 or higher. The code for this
    chapter can be found at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter15](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter15).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要 Go 版本 1.21 或更高。本章的代码可以在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter15](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter15)找到。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, you learned how to interact with the filesystem your
    Go app is running on. You learned about the importance of exit codes and how to
    customize your scripts to take arguments, thus adding flexibility to your applications.
    You also learned how to handle different signals that your application receives.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何与你的 Go 应用程序运行的文件系统交互。你学习了退出代码的重要性以及如何自定义脚本以接受参数，从而增加应用程序的灵活性。你还学习了如何处理应用程序接收到的不同信号。
- en: In this chapter, you will further master your Go skills by learning how to use
    SQL and databases in Go. As a developer, it is impossible to get by without a
    proper understanding of persistent data storage and databases. Our applications
    process input and produce output, but most of the time, if not in all cases, a
    database is involved in the process. This database can be in-memory (stored in
    the computer’s RAM) or file-based (a single file in a directory), and it can live
    on local or remote storage. A database engine can be installed locally, as we
    will do later in this chapter, but it is also possible to use cloud providers,
    which allow you to use a database as a service; some of the cloud providers that
    offer several different database engine options are Azure, AWS, and Google Cloud.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将通过学习如何在 Go 中使用 SQL 和数据库来进一步提高你的 Go 技能。作为一名开发者，没有对持久数据存储和数据库的适当理解是无法立足的。我们的应用程序处理输入并产生输出，但大多数情况下，如果不是所有情况，数据库都会涉及这个过程。这个数据库可以是内存中的（存储在计算机的
    RAM 中），也可以是基于文件的（目录中的一个文件），它可以存在于本地或远程存储上。数据库引擎可以本地安装，就像我们将在本章后面做的那样，但也可以使用云提供商，这些提供商允许你将数据库作为一项服务使用；提供多种数据库引擎选项的云提供商包括
    Azure、AWS 和 Google Cloud。
- en: What we aim to do in this chapter is make you fluent in talking to these databases
    and understanding the basic concepts of what a database is. Finally, you will
    have extended your skillset to make you a better Go developer as you progress
    through this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中旨在让你能够流利地与这些数据库进行交流，并理解数据库的基本概念。最后，随着你通过本章的学习，你将扩展你的技能集，使你成为一个更好的 Go 开发者。
- en: Let’s say your boss wants you to create a Go app that can communicate with a
    database. By *communicate*, we mean that any transaction that is `INSERT`, `UPDATE`,
    `DELETE`, or `CREATE` can and should be handled by the application. This chapter
    will show you how to do that.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的老板想要你创建一个可以与数据库通信的 Go 应用程序。这里的“通信”意味着任何 `INSERT`、`UPDATE`、`DELETE` 或 `CREATE`
    事务都可以并由应用程序处理。本章将展示如何做到这一点。
- en: Understanding the database
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解数据库
- en: 'We commonly use the word database in different ways, but let’s be a bit more
    formal here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常以不同的方式使用“数据库”这个词，但让我们在这里更加正式一些：
- en: A database is where we store our data, where we persist it (if we want), and
    where we can run some queries to insert new data and retrieve or modify existing
    data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是我们存储数据的地方，是我们持久化数据的地方（如果我们想的话），我们还可以在其中运行一些查询来插入新数据，检索或修改现有数据。
- en: You might think that a filesystem fits this description, but actually, this
    is not the case; a real database allows us to perform very complex and precise
    queries to gather data based on very specific conditions. To do so, we will have
    a language to perform these queries or other operations. In our case, we will
    focus on a language called SQL.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为文件系统符合这个描述，但实际上并非如此；真正的数据库允许我们根据非常具体的条件执行非常复杂和精确的查询来收集数据。为此，我们将有一个用于执行这些查询或其他操作的语言。在我们的案例中，我们将专注于一种称为SQL的语言。
- en: We’ve stated what a database is, but this is still quite abstract. To create
    a database and fill it with data, we need an engine – essentially, an application
    – that will allow us to perform all these operations. In this section, we’ll learn
    how to use a database engine called **Postgres SQL**. As its name suggests, this
    engine will allow us to perform operations using the SQL language.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说明了什么是数据库，但这仍然相当抽象。为了创建数据库并填充数据，我们需要一个引擎——本质上是一个应用程序——它将允许我们执行所有这些操作。在本节中，我们将学习如何使用名为
    **PostgreSQL** 的数据库引擎。正如其名称所暗示的，这个引擎将允许我们使用SQL语言执行操作。
- en: Installing and configuring Postgres SQL
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置PostgreSQL
- en: As a first step, you need to install Postgres SQL and configure it for yourself
    so that you can try out the following examples.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，您需要安装PostgreSQL并为您自己配置它，以便您可以尝试以下示例。
- en: 'First, you need to grab the installer from [https://www.postgresql.org/download/](https://www.postgresql.org/download/).
    Select the one that is appropriate for your system; we will go through the Windows
    installer here, but things are pretty similar for other systems. The installer
    is very easy to use, and I suggest that you accept the defaults:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要从 [https://www.postgresql.org/download/](https://www.postgresql.org/download/)
    下载安装程序。选择适合您系统的版本；我们将在这里介绍Windows安装程序，但其他系统的情况也相当相似。安装程序非常易于使用，我建议您接受默认设置：
- en: 'Run the installer:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行安装程序：
- en: '![Figure 15.1: Selecting the installation directory](img/B18621_15_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1：选择安装目录](img/B18621_15_01.jpg)'
- en: 'Figure 15.1: Selecting the installation directory'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：选择安装目录
- en: 'Leave the default components as-is:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持默认组件不变：
- en: '![Figure 15.2: Selecting components to install](img/B18621_15_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图15.2：选择要安装的组件](img/B18621_15_02.jpg)'
- en: 'Figure 15.2: Selecting components to install'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：选择要安装的组件
- en: 'Leave the default data directory:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持默认的数据目录：
- en: '![Figure 15.3: Selecting the data directory](img/B18621_15_03.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图15.3：选择数据目录](img/B18621_15_03.jpg)'
- en: 'Figure 15.3: Selecting the data directory'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：选择数据目录
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will be asked for a password. You need to remember this because this is
    the master password for your database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您将被要求输入密码。您需要记住这个密码，因为这是您数据库的主密码。
- en: '`Start!123` is the password for this example. The database is running on local
    port `5432`. The `pgAdmin` GUI tool will also be installed, and, once the installer
    completes, you can start `pgAdmin` to connect to the database.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start!123` 是本例的密码。数据库运行在本地的端口 `5432` 上。`pgAdmin` 图形界面工具也将被安装，一旦安装程序完成，您就可以启动
    `pgAdmin` 来连接到数据库。'
- en: 'In your browser, go to [https://packt.live/2PKWc5w](https://packt.live/2PKWc5w)
    to access the admin interface:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中，访问 [https://packt.live/2PKWc5w](https://packt.live/2PKWc5w) 以访问管理员界面：
- en: '![Figure 15.4: The admin interface](img/B18621_15_04.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图15.4：管理员界面](img/B18621_15_04.jpg)'
- en: 'Figure 15.4: The admin interface'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：管理员界面
- en: Once the installation is complete, you can create new databases through `pgAdmin`
    and call them whatever you want, but for the next few steps, make sure you have
    one database called just `postgres` to which we will connect via Go. We are now
    ready to proceed to the next part and connect to the database via Go.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，您可以通过 `pgAdmin` 创建新的数据库，并命名为您想要的任何名称，但在接下来的几个步骤中，请确保您有一个名为 `postgres`
    的数据库，我们将通过Go连接到它。我们现在可以继续到下一部分，并通过Go连接到数据库。
- en: Database API and drivers
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库API和驱动程序
- en: A database is a place where data is stored; we normally use database engines,
    which are software applications that allow us to create and interact with databases.
    A lot of different database engines exist, and they give us different ways of
    structuring the data. Nowadays, many different kinds of databases exist, but the
    most used and solid are the ones called *SQL databases*. **SQL** is a standard
    that stands for **Structured Query Language**. This is a standardized language
    that specifies how a database engine should respond to specific commands from
    the user. As its name suggests, it’s a language that allows us to perform queries
    on a database engine – that is, ask it to perform those actions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库是一个存储数据的地方；我们通常使用数据库引擎，这些是软件应用程序，允许我们创建和与数据库交互。存在许多不同的数据库引擎，它们为我们提供了不同的数据结构方式。如今，存在许多不同类型的数据库，但最常用且稳固的是被称为
    *SQL 数据库* 的那些。**SQL** 是一个代表 **结构化查询语言** 的标准。这是一种标准化的语言，它指定了数据库引擎应该如何响应用户的特定命令。正如其名所示，这是一种允许我们在数据库引擎上执行查询的语言——也就是说，要求它执行那些操作。
- en: To work with databases, there is something called the *pure* Go approach, which
    means Go has an API that allows you to use different drivers to connect to databases.
    The API comes from the `database/sql` package, and the drivers can be of two types.
    There is native support for a wide variety of drivers, all of which can be found
    on the official GitHub page ([https://packt.live/2LMzcC4](https://packt.live/2LMzcC4)),
    and there are third-party drivers that need additional packages to function, such
    as the `SQLlite3` package, which requires you to have `GCC` installed because
    it is a pure C implementation.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要与数据库一起工作，有一种称为 *纯 Go* 的方法，这意味着 Go 有一个 API 允许你使用不同的驱动程序连接到数据库。该 API 来自 `database/sql`
    包，驱动程序有两种类型。对许多驱动程序有原生支持，所有这些都可以在官方 GitHub 页面找到（[https://packt.live/2LMzcC4](https://packt.live/2LMzcC4)），还有第三方驱动程序需要额外的包才能运行，例如
    `SQLlite3` 包，它要求你安装 `GCC`，因为它是一个纯 C 实现。
- en: Note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: GCC is a compiler system produced by the GNU Project. It takes your source code
    and translates it into machine code so that your computer can run the application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 是由 GNU 项目生产的编译器系统。它将你的源代码转换成机器码，以便你的电脑能够运行应用程序。
- en: 'Here is a list of a couple of drivers:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些驱动程序的列表：
- en: '**MySQL** ([https://packt.live/38zk9Fw](https://packt.live/38zk9Fw))'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MySQL** ([https://packt.live/38zk9Fw](https://packt.live/38zk9Fw))'
- en: '**Oracle** ([https://packt.live/34cxwrP](https://packt.live/34cxwrP))'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Oracle** ([https://packt.live/34cxwrP](https://packt.live/34cxwrP))'
- en: '**ODBC** ([https://packt.live/2EfETV8](https://packt.live/2EfETV8))'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ODBC** ([https://packt.live/2EfETV8](https://packt.live/2EfETV8))'
- en: '**Postgres** ([https://packt.live/35jKEwL](https://packt.live/35jKEwL))'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Postgres** ([https://packt.live/35jKEwL](https://packt.live/35jKEwL))'
- en: The idea behind the API and driver approach is that Go provides a unified interface
    that allows developers to talk to different types of databases. All you need to
    do is import the API and the necessary driver and you can talk to the database.
    You don’t need to learn driver-specific implementations or how that driver works
    because the API’s sole purpose is to create an abstraction layer that accelerates
    development.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: API 和驱动程序方法背后的理念是，Go 提供了一个统一的接口，允许开发者与不同类型的数据库进行通信。你所需要做的就是导入 API 和必要的驱动程序，然后你就可以与数据库进行通信了。你不需要学习特定驱动程序的实现或驱动程序是如何工作的，因为
    API 的唯一目的是创建一个抽象层，以加速开发。
- en: Let’s consider an example. Let’s say we would like to have a script that queries
    a database. This database is MySQL. One approach is to take the driver and learn
    how to code in its language, and then you are good to go. Some time passes by,
    and you build lots of small scripts that do their job properly. Now, the time
    has come for a management decision that will make you unhappy. They decide that
    MySQL is not good enough, and they are going to replace the database with AWS
    Athena, a cloud-based database.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子。假设我们想要一个查询数据库的脚本。这个数据库是 MySQL。一种方法是从驱动程序开始学习如何用其语言编码，然后你就可以开始了。过了一段时间，你编写了许多小脚本，它们都能正确地完成工作。现在，是时候做出一个让你不高兴的管理决策了。他们决定
    MySQL 不够好，他们打算用基于云的数据库 AWS Athena 来替换数据库。
- en: Now, since you wrote your scripts specifically for a certain driver, you will
    be busy rewriting your scripts for them to work properly. The safeguard here is
    to use a unified API and driver combination. This means writing the scripts against
    the API and not the driver. The API will translate your wishes for the specific
    driver. This way, all you need to do is swap out the driver, and the scripts are
    guaranteed to work. You just saved yourself many hours of scripting and rewriting
    code, even though the underlying database has been completely replaced.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然你为特定的驱动程序编写了脚本，你将忙于重写脚本以使其正常工作。这里的保障是使用统一的API和驱动程序组合。这意味着编写针对API而不是驱动程序的脚本。API将翻译你对特定驱动程序的需求。这样，你唯一需要做的就是更换驱动程序，脚本就能保证工作。你刚刚节省了许多小时编写脚本和重写代码的时间，即使底层数据库已经被完全替换。
- en: 'When we are working with databases in Go, we can differentiate between the
    following types of databases:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Go中使用数据库时，我们可以区分以下类型的数据库：
- en: Relational databases
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系型数据库
- en: NoSQL databases
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL数据库
- en: Search and analytic databases
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索和分析数据库
- en: In our case, we will focus on relational databases, which mostly use the SQL
    language.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将专注于关系型数据库，这些数据库主要使用SQL语言。
- en: Connecting to databases
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'Connecting to a database is by far the easiest thing to do; however, we need
    to keep a few things in mind. To connect to any database, we need at least four
    things to be in place:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到数据库到目前为止是最容易的事情；然而，我们需要记住一些事情。要连接到任何数据库，我们需要至少以下四个条件满足：
- en: We need a host to connect to
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个主机来连接
- en: We need a database to connect to that is running on a port
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个在端口上运行的数据库来连接
- en: We need a username
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个用户名
- en: We need a password
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个密码
- en: The user needs to have appropriate privileges because we not only want to connect
    but we would like to perform specific operations, such as query, insert, or remove
    data, create or delete databases, and manage users and views. Let’s imagine that
    connecting to a database is like walking up to a door as a specific person with
    a specific key. Whether the door opens or not depends on the key, but what we
    can do after we have crossed the threshold will depend on the person (which is
    defined by their privileges).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 用户需要具有适当的权限，因为我们不仅想要连接，我们还希望执行特定的操作，例如查询、插入或删除数据，创建或删除数据库，以及管理用户和视图。让我们想象一下，连接到数据库就像作为一个特定的人拿着特定的钥匙走到门前。门是否打开取决于钥匙，但我们越过门槛后能做什么将取决于这个人（由他们的权限定义）。
- en: 'In most cases, the database server supports multiple databases, and the databases
    hold one or more tables:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，数据库服务器支持多个数据库，数据库包含一个或多个表：
- en: '![Figure 15.5 – Databases in a server](img/B18621_15_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图15.5 – 服务器中的数据库](img/B18621_15_05.jpg)'
- en: Figure 15.5 – Databases in a server
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5 – 服务器中的数据库
- en: Imagine that the databases are logical containers that belong together.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，数据库是相互关联的逻辑容器。
- en: Creating a new project
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的项目
- en: 'First, let’s create a new project. To do so, create a folder called `database1`
    and go to this folder with your terminal. Inside the folder, write the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个新的项目。为此，创建一个名为`database1`的文件夹，并使用终端进入该文件夹。在文件夹内，写下以下内容：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s take a look at how we can connect to a database in Go. To connect, we
    need to get the appropriate module from GitHub, which needs internet connectivity.
    We need to issue the following command to get the package needed to interact with
    the Postgres instance:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Go中连接到数据库。要连接，我们需要从GitHub获取适当的模块，这需要互联网连接。我们需要执行以下命令来获取与Postgres实例交互所需的包：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter uses the `pq` package to connect to the database. However, alternative
    packages are available that can be used here instead.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用`pq`包来连接到数据库。然而，这里还有其他可用的替代包。
- en: 'Remember to run it from within your project’s folder. Once this is completed,
    you are ready to start scripting. First, we will initialize our script:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在项目文件夹内运行它。一旦完成，你就可以开始编写脚本了。首先，我们将初始化我们的脚本：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you would like further information, please visit [https://packt.live/2PByusw](https://packt.live/2PByusw).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多信息，请访问[https://packt.live/2PByusw](https://packt.live/2PByusw)。
- en: 'Now that we have initialized our script, we can connect to our database:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了脚本，我们可以连接到我们的数据库：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This topic is special because the API gives us an `Open()` function, which takes
    a variety of arguments. There are shorthand ways of doing this, but I would like
    you to know about all the components that are involved in making the connections,
    so I will use the longer way. Later, you can decide which one to use.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题很特殊，因为API提供了一个`Open()`函数，它接受多种参数。虽然有一些简写方式可以做到这一点，但我希望你知道所有参与建立连接的组件，所以我将使用较长的方法。稍后，你可以决定使用哪一种。
- en: The `postgres` string, used as the first parameter in the `Open` function call,
    tells the function to use the `Postgres` driver to make the connection. The second
    argument is a so-called connection string, which holds the `user`, `password`,
    `host`, `port`, `dbname`, and `sslmode` arguments; these will be used to initialize
    the connection. In this example, we’re connecting to the local host marked by
    `127.0.0.1` on the default port of `5432`, and we don’t use `ssl`. For production
    systems, people tend to change the default port and enforce encrypted traffic
    via `ssl` toward the database server; you should always follow the best practices
    concerning the type of database you’re working with.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Open`函数调用中作为第一个参数使用的`postgres`字符串，告诉函数使用`Postgres`驱动程序来建立连接。第二个参数是一个所谓的连接字符串，它包含`user`、`password`、`host`、`port`、`dbname`和`sslmode`参数；这些将用于初始化连接。在这个例子中，我们正在连接到标记为`127.0.0.1`的本地主机上的默认端口`5432`，并且我们不使用`ssl`。对于生产系统，人们倾向于更改默认端口并通过`ssl`对数据库服务器强制加密流量；你应该始终遵循你正在处理的数据库类型的最佳实践。
- en: 'As you can see, the `Open()` function returns two values. One is for the database
    connection and the other is for the error, if one occurred during initialization.
    How do we check whether the initialization was successful? Well, we can check
    whether there were any errors by writing the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`Open()`函数返回两个值。一个是数据库连接，另一个是错误，如果在初始化期间发生了错误。我们如何检查初始化是否成功？嗯，我们可以通过编写以下代码来检查是否有任何错误：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `panic()` function in Go is used to indicate that something went wrong
    unexpectedly, and we are not prepared to handle it gracefully, thus stopping the
    execution. If the connection succeeds, we print out a message stating `The connection
    to the DB was successfully initialized!`. When you have a long-running application,
    it is worth incorporating a way to check whether the database is still reachable
    because due to intermittent network errors, you could lose the connection and
    fail to execute whatever you want to execute. This can be checked with the following
    small code snippet:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的`panic()`函数用于指示某些事情意外出错，我们无法优雅地处理它，因此停止执行。如果连接成功，我们打印出一条消息，声明`The connection
    to the DB was successfully initialized!`。当你有一个长期运行的应用程序时，值得加入一种检查数据库是否仍然可访问的方法，因为由于间歇性的网络错误，你可能会丢失连接并无法执行你想要执行的操作。这可以通过以下小代码片段进行检查：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can run this check constantly on a different Go routine every few seconds.
    It will check if the database is on but also help keep the connection open; otherwise,
    it will go idle. This is a proactive solution as you check the status of the database
    connection.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以每隔几秒在不同的Go协程上运行这个检查。它将检查数据库是否开启，同时也有助于保持连接打开；否则，它将进入空闲状态。这是一个主动解决方案，因为你正在检查数据库连接的状态。
- en: 'In this case, we used the `panic()` function to indicate that the connection
    has been lost. Finally, once our job is done, we need to terminate our connection
    to the database to remove user sessions and free up resources. This can happen
    either if you are building a script that will run as a job, hence will run and
    finish, or if you are building a long-running service. In the first case, you
    can use the following command at the end of the script:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了`panic()`函数来指示连接已丢失。最后，一旦我们的工作完成，我们需要终止与数据库的连接以删除用户会话并释放资源。这可以发生在你构建一个作为作业运行的脚本的情况下，因此它会运行并完成，或者如果你正在构建一个长期运行的服务。在前一种情况下，你可以在脚本末尾使用以下命令：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This ensures that before terminating the script, the connection will be dropped.
    If you are building a long-running service, you don’t have a specific point in
    your code where you know that the script will terminate, but it can happen at
    any time. You can use the following code to ensure the connections are dropped:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了在终止脚本之前，连接将被断开。如果你正在构建一个长期运行的服务，你代码中并没有一个特定的点可以知道脚本将终止，但它可能随时发生。你可以使用以下代码来确保连接被断开：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The difference is the scope. `db.Close()` will terminate the connection to the
    database once the execution arrives at the specific line, while `defer db.Close()`
    indicates that the database connection should be executed once the function in
    which it was called goes out of scope. The idiomatic way to do this is with `defer
    db.Close()`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 差别在于范围。`db.Close()`将在执行到达特定行时终止与数据库的连接，而`defer db.Close()`表示数据库连接应该在调用它的函数超出作用域时执行。这样做的一种习惯用法是`defer
    db.Close()`。
- en: In the next section, we will start using the connection for something more purposeful,
    and we will start by creating tables.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始使用连接进行更有目的的操作，并且我们将从创建表开始。
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The official `Postgres` library for Go can be found at [https://packt.live/35jKEwL](https://packt.live/35jKEwL).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言的官方`Postgres`库可以在[https://packt.live/35jKEwL](https://packt.live/35jKEwL)找到。
- en: Creating tables
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表
- en: 'The act of creating tables aims to make logical containers that persistently
    hold data that belongs together. You will need to create tables for many reasons
    – for example, tracking employee attendance, revenue tracking, and statistics.
    The common goal is to provide a service for applications that make sense of it.
    How do these database engines control who can access what data? There are two
    approaches:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表的行为旨在创建逻辑容器，以持久地保存属于一起的数据。你将需要出于许多原因创建表——例如，跟踪员工出勤、收入跟踪和统计数据。共同的目标是为理解这些的应用程序提供服务。这些数据库引擎如何控制谁可以访问什么数据？有两种方法：
- en: The first one is `CREATE`, `UPDATE`, and `DELETE`.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个涉及的是 `CREATE`、`UPDATE` 和 `DELETE`。
- en: The second approach involves inheritance and roles. This is more robust and
    is better suited for big enterprises.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法涉及继承和角色。这更健壮，更适合大型企业。
- en: '`Postgres` uses the second approach, and in this section, we will learn how
    to create a SQL table and how to create one specifically in `Postgres`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Postgres`使用第二种方法，在本节中，我们将学习如何创建一个SQL表，以及如何在`Postgres`中特别创建一个表。'
- en: 'The general syntax for table creation looks like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表的通用语法看起来像这样：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we talk via SQL to the `Postgres`, `mysql`, or `mssql` server, they all
    respond in the same way to a `CREATE TABLE` or `INSERT` command because they are
    SQL compliant. The idea of the standard is not to specify how the engine works
    internally but how the interaction with it should happen. These database engines
    usually differ in terms of functionality, speed, and storage approaches; that’s
    where the variety comes from. This is not, however, a full SQL or database engine
    tutorial, so we just gave you a brief introduction to what SQL is without going
    into a lot of details.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过SQL与`Postgres`、`mysql`或`mssql`服务器通信时，它们对`CREATE TABLE`或`INSERT`命令的响应方式相同，因为它们都遵循SQL规范。标准的理念不是指定引擎内部的工作方式，而是指定与它的交互方式。这些数据库引擎在功能、速度和存储方法方面通常有所不同；这就是多样性的来源。然而，这并不是一个完整的SQL或数据库引擎教程，所以我们只是简要介绍了SQL是什么，而没有深入细节。
- en: Let’s see some of the general statements of the SQL language, with which we
    will then experiment a bit later. The statement for table creation is `CREATE
    TABLE`. This command is understood in the context of the database you are connected
    to. One server can host multiple databases, and connecting to the wrong one can
    cause headaches when issuing a command that modifies the structure. The command
    usually takes a column name, which is `column1` in our case, and the type of data
    in our column, which is `datatype`. Finally, we can set constraints on our columns,
    which will imbue them with special properties. The supported data types for our
    columns depend on the database engine.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看SQL语言的一些一般性声明，稍后我们将对其进行一些实验。创建表的语句是`CREATE TABLE`。这个命令在你连接的数据库上下文中被理解。一个服务器可以托管多个数据库，连接到错误的数据库在执行修改结构的命令时可能会引起麻烦。该命令通常需要一个列名，在我们的例子中是`column1`，以及我们列中的数据类型，即`datatype`。最后，我们可以对我们的列设置约束，这将赋予它们特殊属性。我们列支持的数据类型取决于数据库引擎。
- en: 'Here are some common data types:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些常见的数据类型：
- en: '`INT`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INT`'
- en: '`DOUBLE`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOUBLE`'
- en: '`FLOAT`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FLOAT`'
- en: '`VARCHAR`, which is a string with a specific length'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VARCHAR`，这是一个具有特定长度的字符串'
- en: 'The constraints also depend on the database engine, but some of them are as
    follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 约束也取决于数据库引擎，但以下是一些例子：
- en: '`NOT NULL`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NOT NULL`'
- en: '`PRIMARY KEY`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PRIMARY KEY`'
- en: '`Named function`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`命名函数`'
- en: The named function is executed every time a new record is inserted or an old
    one is updated and, based on the evaluation of the transaction, is either allowed
    or denied.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数在每次插入新记录或更新旧记录时都会执行，并且根据事务的评估结果，要么允许要么拒绝。
- en: 'We are not only able to create a table, but we can also empty the table – that
    is, remove all of its contents, or remove the table itself from the database.
    To empty a table, we can use the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅能够创建一个表格，还可以清空表格——也就是说，移除其所有内容，或者从数据库中移除该表格本身。要清空一个表格，我们可以使用以下命令：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To remove the table, we can use the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除表格，我们可以使用以下命令：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, create a new table. In `Postgres`, you have a default database you can
    use; we are not going to create a separate database for the examples in this chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个新的表格。在`Postgres`中，你可以使用一个默认的数据库；我们不会为本章的示例创建一个单独的数据库。
- en: 'We would like to initialize our script, which you can find in the examples
    folder, and it’s called `DBInit.go`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望初始化我们的脚本，该脚本位于示例文件夹中，名为`DBInit.go`：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we are ready to define our `main()` function:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备定义我们的`main()`函数：
- en: '`DBInit.go`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`DBInit.go`'
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The full code is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBInit.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBInit.go).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码可在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBInit.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBInit.go)找到。
- en: 'Let’s dissect what is happening here. We initialize our connection to the database
    without the default username and password that was previously mentioned, and now,
    we have the `db` variable to interact with the database. Unless there was an error
    upon execution, the following output will be visible in our console:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这里发生了什么。我们初始化了数据库连接，没有使用之前提到的默认用户名和密码，现在我们有了`db`变量来与数据库交互。除非执行过程中出现错误，否则以下输出将在我们的控制台中可见：
- en: '![Figure 15.6 – The desired output, as visible in the console](img/B18621_15_06.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图15.6 – 在控制台可见的期望输出](img/B18621_15_06.jpg)'
- en: Figure 15.6 – The desired output, as visible in the console
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6 – 在控制台可见的期望输出
- en: 'If we were to rerun the script, the following error would occur:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新运行脚本，将会出现以下错误：
- en: '![Figure 15.7 – Output of failure after consecutive execution](img/B18621_15_07.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图15.7 – 连续执行失败后的输出](img/B18621_15_07.jpg)'
- en: Figure 15.7 – Output of failure after consecutive execution
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7 – 连续执行失败后的输出
- en: This says that the table already exists. We created a multiline string called
    `DBCreate` that holds all the table creation information. In this, we have a table
    called `test`, which has an integer column called `id` and a string column called
    `name`. The rest of it is Postgres-specific configuration. The tablespace defines
    where our table lives. The `_, err` line with `db.Exec()` is responsible for executing
    the query.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示表格已经存在。我们创建了一个名为`DBCreate`的多行字符串，其中包含所有表格创建信息。在这个字符串中，有一个名为`test`的表格，它有一个名为`id`的整型列和一个名为`name`的字符串列。其余的是Postgres特定的配置。表空间定义了我们的表格存储的位置。带有`db.Exec()`的`_,
    err`行负责执行查询。
- en: The table we are creating will have an ID (unique identifier) per row, which
    will be of the integer type, and a name column, which will be of the character
    type. The names have a few characteristics; for example, *COLLATE* defines how
    the data will be ordered, or better, what comes first or after when requesting
    data in ascending or descending order. We are taking the default collate for `postgres`,
    which is defined by the localization currently in the database.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建的表格将为每一行分配一个ID（唯一标识符），这将是一个整型，还有一个名称列，这将是一个字符型。名称有一些特性；例如，*COLLATE*定义了数据将如何排序，或者说在请求数据时，按照升序或降序排列时，什么会排在第一位或之后。我们正在使用`postgres`的默认排序规则，该规则由当前数据库中的本地化定义。
- en: As we’ve just said, we are going to create a table with an ID, and we will use
    that to identify the rows. `Postgres` provides a unique identifier for each row
    automatically, which is called **oid** (**Object Identifier**), but we don’t need
    this as we are handling it manually. Note that not all other database engines
    provide the oid.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才说的，我们将创建一个带有ID的表格，并使用它来识别行。`Postgres`为每一行自动提供一个唯一标识符，称为**oid**（**对象标识符**），但我们需要手动处理它，所以我们不需要这个。请注意，并非所有其他数据库引擎都提供oid。
- en: Since our goal now is to create the table, we only care whether there are any
    errors; otherwise, we can use a throwaway variable to capture the output. If `err`
    is not `nil`, there was an error, as we saw previously. Otherwise, we assume the
    table was created as expected. Finally, the connection to the database is closed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的目标现在是创建表，我们只关心是否有任何错误；如果没有错误，我们可以使用一个临时变量来捕获输出。如果`err`不是`nil`，那么就像我们之前看到的那样，有错误。否则，我们假设表已按预期创建。最后，关闭与数据库的连接。
- en: Now that we can connect to the database and we have a table, we can insert some
    data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以连接到数据库并且我们有一个表，我们可以插入一些数据。
- en: Inserting data
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入数据
- en: 'Long ago, when the era of web applications backed by SQL databases started
    to bloom, some gutsy people invented the SQL injection attack. Here, a type of
    authentication is done against a database via SQL queries and, for example, after
    converting the password with mathematical magic into hash functions, the web app
    executes the query with the username and password coming from the input of the
    form. Many servers executed something like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，当支持SQL数据库的Web应用程序时代开始繁荣起来时，一些勇敢的人发明了SQL注入攻击。在这里，通过SQL查询对数据库进行一种身份验证，例如，将密码通过数学魔法转换为散列函数后，Web应用程序执行带有来自表单输入的用户名和密码的查询。许多服务器执行了类似以下的内容：
- en: '[PRE13]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Then, the password gets rehashed; if the two hashes match, the password is good
    for the user.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，密码会被重新散列；如果两个散列匹配，密码对用户来说是有效的。
- en: 'The problem with this came from the `<input from user>` part because if the
    attacker was smart enough, they could reformulate the query and run additional
    commands. Here’s an example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题出在`<用户输入>`部分，因为如果攻击者足够聪明，他们可以重新构造查询并运行额外的命令。以下是一个例子：
- en: '[PRE14]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The problem with this query is that `OR '1' = '1'` always evaluates to `true`,
    and it does not matter what the username is; the user’s password hash would be
    returned. This can be further reused to formulate an additional attack. To prevent
    this, Go uses something called the `Prepare()` statement, which protects against
    these attacks.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询的问题在于`OR '1' = '1'`总是评估为`true`，并且用户名是什么并不重要；用户的密码散列会被返回。这可以进一步用于制定额外的攻击。为了防止这种情况，Go使用了一个名为`Prepare()`的语句，它可以防止这些攻击。
- en: 'Go has two types of substitutions:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Go有两种类型的替换：
- en: We use `WHERE col = $1` in the case of queries
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在查询的情况下，我们使用`WHERE col = $1`
- en: We use `VALUES($1,$2)` in the case of inserts or updates
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在插入或更新的情况下，我们使用`VALUES($1,$2)`
- en: 'Let’s add some values to our tables. We are going to initialize our script
    in the usual way. This script can be found under the examples folder and is called
    `DBInsert.go`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的表中添加一些值。我们将以通常的方式初始化我们的脚本。这个脚本可以在示例文件夹下找到，名为`DBInsert.go`：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Upon successful execution, we’ll get the following output:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 执行成功后，我们将得到以下输出：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let’s see what’s happening with the insert part. `db.Prepare()` takes a SQL
    statement and imbues it with protection against SQL injection attacks. It works
    by restricting the values of the variable substitutions. In our case, we have
    two columns, so for the substitution to work, we use `$1` and `$2`. You can use
    any number of substitutions; you only need to make sure they result in a valid
    SQL statement when evaluated. When the `insert` variable is initialized without
    errors, it will be responsible for executing the SQL statement. It finds out how
    many arguments the prepared statement expects, and its sole purpose is to call
    the statement and perform the operation. `insert.Exec(2,"second")` inserts a new
    element with `id=2` and `name='second'`. If we were to check what we have in our
    database, we would see the results.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看插入部分发生了什么。`db.Prepare()`接受一个SQL语句，并赋予它防止SQL注入攻击的保护。它是通过限制变量替换的值来工作的。在我们的例子中，我们有两个列，所以为了使替换工作，我们使用`$1`和`$2`。你可以使用任意数量的替换；你只需要确保它们在评估时产生一个有效的SQL语句。当`insert`变量初始化时没有错误，它将负责执行SQL语句。它找出预定义语句期望的参数数量，它的唯一目的是调用语句并执行操作。`insert.Exec(2,"second")`插入一个新元素，其`id=2`和`name='second'`。如果我们检查我们的数据库中有什么，我们会看到结果。
- en: Now that we have some data in our table, we can query it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在我们的表中有了数据，我们可以查询它。
- en: Exercise 15.01 – creating a table that holds a series of numbers
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.01 – 创建一个存储一系列数字的表
- en: In this exercise, we are going to write a script that is going to create a table
    called `Numbers`, in which we are going to store numbers. These numbers will be
    inserted at a later time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个脚本，该脚本将创建一个名为`Numbers`的表，我们将存储数字。这些数字将在稍后插入。
- en: Create two columns, `Number` and `Property`. The `Number` column will hold numbers,
    while the `Property` column will be `Odd` or `Even` when it’s created.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个列，`Number` 和 `Property`。`Number` 列将存储数字，而 `Property` 列在创建时将是 `Odd` 或 `Even`。
- en: Use the default `Postgres` database for the connection. The numbers should range
    from 0 to 99.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认的 `Postgres` 数据库进行连接。数字应该从0到99。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成这个练习：
- en: Create a file called `main.go`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件。
- en: 'Initialize the package with the following lines:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下行初始化包：
- en: '[PRE17]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a `property` `string` variable for later use:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于后续使用的 `property` `string` 变量：
- en: '[PRE18]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Initialize the database connection:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化数据库连接：
- en: '[PRE19]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a multiline string to create the table:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个多行字符串来创建表：
- en: '[PRE20]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create the table:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建表：
- en: '[PRE21]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Insert the numbers:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入数字：
- en: '[PRE22]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Close the database connection and function:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭数据库连接和函数：
- en: '[PRE23]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When you execute the script, you should see the following output:'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你执行脚本时，你应该看到以下输出：
- en: '![Figure 15.8 – Output of the successful property update](img/B18621_15_08.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图15.8 – 成功属性更新的输出](img/B18621_15_08.jpg)'
- en: Figure 15.8 – Output of the successful property update
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8 – 成功属性更新的输出
- en: Note
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Part of the output has been omitted from *Figure 15**.8* due to its length.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 由于长度原因，*图15.8* 的一部分输出已被省略。
- en: In this exercise, we saw how to create a new table in our database and how to
    insert new records with the help of a `for` loop and a `Prepare()` statement.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何使用 `for` 循环和 `Prepare()` 语句在我们的数据库中创建新表以及如何插入新记录。
- en: Retrieving data
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索数据
- en: SQL injection does not only concern the data being inserted. It also concerns
    any data that is manipulated in the database. Retrieving data and, most importantly,
    retrieving it safely is also something we must prioritize and handle with proper
    caution. When we query data, our results depend on the database we connect to
    and the table we would like to query. However, we must also mention that the security
    mechanisms that are implemented by the database engine may also prevent a successful
    query unless the user has appropriate privileges.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 注入不仅关注要插入的数据。它还关注数据库中任何被操作的数据。检索数据，尤其是安全地检索数据，也是我们必须优先考虑和处理的事项。当我们查询数据时，我们的结果取决于我们连接的数据库和我们想要查询的表。然而，我们也必须提到，数据库引擎实现的安全机制可能也会阻止查询成功，除非用户具有适当的权限。
- en: 'We can differentiate between two types of queries:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分两种类型的查询：
- en: Some queries do not take an argument, such as `SELECT *` `FROM table`
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些查询不需要参数，例如 `SELECT *` `FROM table`
- en: Some queries require you to specify filter criteria
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些查询需要你指定过滤条件
- en: Go provides two functions that allow you to query data. One is called `Query()`
    and the other is called `QueryRow()`. As a rule of thumb, you should remember
    that `Query()` is used to return any number of results, while `QueryRow` is used
    when you expect to retrieve at most one row. You can also wrap them with the `Prepare()`
    statement, though we won’t cover this here as it was demonstrated before. Instead,
    we want to see how these functions work.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了两个允许你查询数据的函数。一个叫做 `Query()`，另一个叫做 `QueryRow()`。一般来说，你应该记住 `Query()` 用于返回任意数量的结果，而
    `QueryRow` 用于你预期最多检索一行的情况。你也可以用 `Prepare()` 语句来包装它们，尽管我们在这里不会介绍，因为之前已经演示过了。相反，我们想看看这些函数是如何工作的。
- en: 'Let’s create a script for `Query()`. As always, we’ll initialize the script.
    It can be found in the examples and is called `DBQuery.go`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `Query()` 创建一个脚本。像往常一样，我们将初始化脚本。它可以在示例中找到，并命名为 `DBQuery.go`：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Our `main()` function will be a little bit different because we would like
    to introduce the `Scan()` function:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `main()` 函数将略有不同，因为我们想介绍 `Scan()` 函数：
- en: '[PRE25]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output should look like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A `SELECT *` query string is not likely to be seen in professional environments
    due to performance and security concerns. You will typically have more specific
    query strings for the specific data.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在专业环境中，由于性能和安全问题，不太可能看到 `SELECT *` 查询字符串。你通常会有更具体的查询字符串来针对特定的数据。
- en: As we inserted this data into our database previously, feel free to add some
    more data based on the previous example. We have defined the `id` and `name` variables,
    which will help our `Scan()` function. We connect to the database and create our
    `db` variable. After that, we fill our `rows` variable with the result of the
    `Query()` function, which will hold all the elements from the table.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将这些数据插入到我们的数据库中，您可以在此基础上添加更多数据。我们已经定义了`id`和`name`变量，这将有助于我们的`Scan()`函数。我们连接到数据库并创建我们的`db`变量。之后，我们用`Query()`函数的结果填充我们的`rows`变量，这将包含表中的所有元素。
- en: 'Here comes the tricky part: we use `for rows.Next()` to iterate over the resulting
    rows. But that is not enough; we would like to assign the results of the query
    to the corresponding variable, which is returned by `rows.Scan(&id, &name)`. This
    allows us to refer to the current row’s ID and `NAME`, which makes it easier to
    do whatever we would like to do with the value. Finally, the rows and the database
    connections are gracefully closed.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是棘手的部分：我们使用`for rows.Next()`来遍历结果行。但这还不够；我们希望将查询的结果分配给相应的变量，该变量由`rows.Scan(&id,
    &name)`返回。这允许我们引用当前行的ID和`NAME`，这使得我们可以更容易地处理这些值。最后，优雅地关闭行和数据库连接。
- en: 'Let’s query a single row with `Prepare()`. The initialization looks the same
    as before:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`Prepare()`查询一行。初始化看起来和之前一样：
- en: '`DBPrepare.go`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`DBPrepare.go`'
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The full code is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBPrepare.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBPrepare.go).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码可在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBPrepare.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBPrepare.go)找到。
- en: 'The main difference is at the beginning of the `main()` function:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于`main()`函数的开始部分：
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output, if you did everything correctly, should look something like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一切操作正确，输出应该看起来像这样：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s inspect our `main` function closely. We defined two variables: the `name`
    variable, which will be used when we process the query result, and the `id` variable,
    which serves as a flexible input for the query we execute. The usual connection
    initialization toward our database happens as before.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细检查我们的`main`函数。我们定义了两个变量：`name`变量，当我们处理查询结果时将使用它，以及`id`变量，它作为我们执行的查询的灵活输入。通常的数据库连接初始化和之前一样发生。
- en: Then comes the `SQL Injection` proof part. We prepare a query that is dynamic
    in the sense that it accepts a parameter that will be the ID we are looking for.
    Then, `qryrow` is used to execute the `QueryRow()` function, which, in turn, takes
    the `id` variable we specified previously and returns the result in the `name`
    variable. Then, we output the string with an explanation that the value of the
    column is based on the `id` variable that was specified. In the end, the `qryrow`
    and `db` resources are closed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是`SQL注入`证明部分。我们准备了一个查询，它在某种程度上是动态的，因为它接受一个参数，这个参数将是我们要查找的ID。然后，使用`qryrow`执行`QueryRow()`函数，该函数反过来又接受我们之前指定的`id`变量，并将结果返回到`name`变量中。然后，我们输出带有解释的字符串，说明列的值基于指定的`id`变量。最后，关闭`qryrow`和`db`资源。
- en: Now that we know how to retrieve data from the database, we need to see how
    to update existing data in our database.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何从数据库中检索数据，我们需要看看如何更新数据库中的现有数据。
- en: Updating existing data
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新现有数据
- en: When you are updating a row or multiple rows with Go, you are in trouble. The
    `sql` package does not provide any function called `Update()`; however, there
    is the `Exec()` function, which serves as a universal executor for your queries.
    You can execute `SELECT`, `UPDATE`, `DELETE`, or whatever you need to execute
    with this function. This section will show you how you can do this safely.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用Go更新一行或多行时，您会遇到麻烦。`sql`包没有提供名为`Update()`的任何函数；然而，有一个`Exec()`函数，它作为您查询的通用执行器。您可以使用此函数执行`SELECT`、`UPDATE`、`DELETE`或您需要执行的任何操作。本节将向您展示如何安全地执行这些操作。
- en: 'We would like to start our script in the usual way. It can be found in the
    examples folder and is called `DBUpdate.go`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望以通常的方式开始我们的脚本。它可以在示例文件夹中找到，并命名为`DBUpdate.go`：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then the magic comes. The idea is to update the `name` column’s value for a
    specific `id` variable that we give as an argument. So, the `main()` function
    looks like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然后就是魔法时刻。想法是更新特定`id`变量对应的`name`列的值，我们将这个变量作为参数传递。所以，`main()`函数看起来是这样的：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If everything has gone well, we’ll see the following output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将看到以下输出：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that you can and should experiment with different inputs and see how the
    script reacts to different problems/errors.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以也应该尝试不同的输入，并观察脚本如何对不同的问题/错误做出反应。
- en: Let’s dissect what’s happening here. We initialize our database connection as
    we did before. We create the `UpdateStatement` variable, which is a multiline
    string, and it is crafted so that it can be fed to the `Exec()` function, which
    takes arguments. We want to update the name of the column that has the specified
    ID. This function either runs the specified statement on its own or can be used
    to pass arguments that are substituted in the appropriate place. This would be
    perfectly fine and would do the job for us, but we would like to make sure that
    the `UPDATE` command updates at least one record.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析一下这里发生了什么。我们像之前一样初始化数据库连接。我们创建了一个名为`UpdateStatement`的变量，它是一个多行字符串，并且被设计成可以传递给`Exec()`函数，该函数接受参数。我们想要更新具有指定ID的列的名称。这个函数要么自己运行指定的语句，要么可以用来传递将被替换到适当位置的参数。这完全没问题，可以完成我们的工作，但我们需要确保`UPDATE`命令至少更新了一条记录。
- en: To this end, we could use `RowsAffected()`. It will return the number of rows
    that were updated and any errors that were faced along the way. Finally, we print
    how many rows were updated to the console and close the connection.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们可以使用`RowsAffected()`。它将返回更新的行数以及过程中遇到的任何错误。最后，我们将更新的行数打印到控制台并关闭连接。
- en: The time has come to delete data from our database.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 删除数据库中的数据的时候到了。
- en: Deleting data
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除数据
- en: 'Data can be deleted for multiple reasons: we don’t need the data anymore, we
    are migrating to another database, or we are replacing the current solution. We
    are in luck because the current Go facilities provide a very nice way to do this.
    The analogy is the same as for the `UPDATE` statement of our records. We formulate
    a `DELETE` statement and execute it; we can technically modify the action of our
    `UPDATE` script to delete it from the database.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可能因多种原因被删除：我们不再需要这些数据，我们正在迁移到另一个数据库，或者我们正在替换当前解决方案。我们很幸运，因为当前的Go功能提供了一种非常优雅的方式来完成这项工作。这与我们记录的`UPDATE`语句的类比相同。我们制定一个`DELETE`语句并执行它；技术上，我们可以修改我们的`UPDATE`脚本来从数据库中删除它。
- en: 'For the sake of simplicity, we’ll only modify the relevant lines. Our `DELETE`
    statement will replace the `UPDATE` statement, like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们只修改相关的行。我们的`DELETE`语句将替换`UPDATE`语句，如下所示：
- en: '`DBDelete.go`'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`DBDelete.go`'
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The full code is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBDelete.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBDelete.go).
    We’ll update the line with the `Exec()` statement:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBDelete.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBDelete.go)找到。我们将更新包含`Exec()`语句的行：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Also, we must update the line with the calculation of updated records:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还必须更新计算更新记录的行：
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Our result should look like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的结果应该看起来像这样：
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That’s it. With a little modification, we have a script that can either update
    or delete records with verification.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。经过一点修改，我们得到了一个可以更新或删除记录并带有验证的脚本。
- en: Now, let’s see how we can create a table that holds prime numbers.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何创建一个存储素数的表。
- en: Exercise 15.02 – holding prime numbers in a database
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.02 – 在数据库中存储素数
- en: In this exercise, we will build on *Exercise 15.01 – creating a table that holds
    a series of numbers*. We would like to create a script that will tell us how many
    prime numbers are in our table and give them to us in order of appearance. We
    would like to see the sum of prime numbers in the output. Then, we would like
    to remove every even number from the table and see how many were removed. We would
    like to add the sum of prime numbers to the remaining odd numbers and update the
    table with the records, changing the property if necessary. Use the `math/big`
    package for the primality test.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将基于 *练习 15.01 – 创建一个包含一系列数字的表格* 来构建。我们希望创建一个脚本，告诉我们表格中有多少素数，并按出现顺序提供给我们。我们希望在输出中看到素数的总和。然后，我们希望从表格中删除所有偶数，并查看删除了多少个。我们希望将素数的总和添加到剩余的奇数中，并使用记录更新表格，必要时更改属性。使用
    `math/big` 包进行素性测试。
- en: 'Follow these steps:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Create a script called `main.go`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的脚本。
- en: 'Initialize our script to perform the specific actions:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化我们的脚本以执行特定操作：
- en: '[PRE37]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Define four variables for later use:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义四个变量以供以后使用：
- en: '[PRE38]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Initialize the database connection:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化数据库连接：
- en: '[PRE39]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Get a list of all the prime numbers:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有素数的列表：
- en: '[PRE40]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Print the sum of the prime numbers:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印素数的总和：
- en: '[PRE41]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Remove the even numbers:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除偶数：
- en: '[PRE42]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Update the remaining records with `primeSum` and print a closing sentence:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `primeSum` 更新剩余记录并打印结束语：
- en: '[PRE43]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Close the database connection:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭数据库连接：
- en: '[PRE44]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once the script has been executed, the following output should be visible:'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦脚本执行完毕，以下输出应该可见：
- en: '![Figure 15.9 – Output of the calculations](img/B18621_15_09.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.9 – 计算输出](img/B18621_15_09.jpg)'
- en: Figure 15.9 – Output of the calculations
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.9 – 计算输出
- en: In this exercise, we saw how to utilize a built-in Go function to find prime
    numbers. We also manipulated the table by removing numbers, and then we performed
    update actions.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何利用内置的 Go 函数来查找素数。我们还通过删除数字来操作表格，然后执行更新操作。
- en: Note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Closing the database is important because once our job is done, we do want to
    release unused resources.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭数据库很重要，因为一旦我们的工作完成，我们确实想释放未使用的资源。
- en: Truncating and deleting table
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 截断和删除表格
- en: 'In this section, we want to empty a table and get rid of it. To empty the table,
    we can simply formulate `DELETE` statements that match every record in our table
    and thus remove every single record from our table. However, there is a more elegant
    way to do this: we can use the `TRUNCATE TABLE` SQL statement. The result of this
    statement is an empty table. We can use the `Exec()` function from our `sql` package
    for this. You already know how to initialize the package with imports. You also
    know how to connect to the database. This time, we’ll only focus on the statements.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们想要清空一个表格并将其删除。为了清空表格，我们可以简单地制定匹配我们表格中每个记录的 `DELETE` 语句，从而从我们的表格中删除每个记录。然而，有一种更优雅的方法来做这件事：我们可以使用
    `TRUNCATE TABLE` SQL 语句。这个语句的结果是一个空表。我们可以使用我们的 `sql` 包的 `Exec()` 函数来做这件事。你已经知道如何通过导入初始化包。你也知道如何连接到数据库。这次，我们只关注语句。
- en: 'The following statement will achieve a full `TRUNCATE`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句将实现完整的 `TRUNCATE`：
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The result of this is an empty table called `test`. To get rid of the table
    completely, we can modify our statement as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这的结果是一个名为 `test` 的空表。要完全删除表格，我们可以修改我们的语句如下：
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you need a table but do not need any more old data, you might want to truncate
    it and carry on adding new data to the existing table. If you do not need the
    table anymore because you changed your schema, you might want to just delete it
    using the `DROP` command.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个表格但不需要更多的旧数据，你可能想要截断它，并继续向现有表格中添加新数据。如果你因为更改了模式而不再需要表格，你可能想使用 `DROP`
    命令将其删除。
- en: If we inspect our database engine, we won’t find any trace of the `test` table.
    This eradicated the whole table from the very face of the database.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查我们的数据库引擎，我们不会找到 `test` 表的任何痕迹。这彻底从数据库的表面消除了整个表。
- en: This section was all about interacting with databases via the Go programming
    language. Now, you have a decent understanding of how to get started.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节主要介绍了如何通过 Go 编程语言与数据库进行交互。现在，你对如何开始有了相当的了解。
- en: Note
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For further information and extra details, you should check out the official
    documentation of the SQL API: [https://packt.live/2Pi5oj5](https://packt.live/2Pi5oj5).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多信息及额外细节，你应该查看 SQL API 的官方文档：[https://packt.live/2Pi5oj5](https://packt.live/2Pi5oj5)。
- en: Activity 15.01 – holding user data in a table
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十五点零一 - 在表中存储用户数据
- en: In this activity, we are going to create a table that is going to hold user
    information such as `ID`, `Name`, and `Email`. We’ll build on the knowledge you
    gathered in the *Creating tables* and *Inserting* *data* sections.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，我们将创建一个将存储用户信息（如`ID`、`Name`和`Email`）的表。我们将基于你在*创建表*和*插入数据*部分获得的知识来构建。
- en: 'Follow these steps to complete this activity:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: 'Create a small script that will create a table called `Users`. This table must
    have three columns: `ID`, `Name`, and `Email`.'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个小的脚本，该脚本将创建一个名为`Users`的表。此表必须有三列：`ID`、`Name`和`Email`。
- en: Add the details of two users, along with their data, to the table. They should
    have unique names, IDs, and email addresses.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两位用户及其详细信息添加到表中。他们应该有独特的名字、ID和电子邮件地址。
- en: Then, you need to update the email of the first user to `user@packt.com` and
    remove the second user. Make sure that none of the fields are `NULL`. Since the
    ID is the primary key, it needs to be unique.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你需要将第一个用户的电子邮件更新为`user@packt.com`并删除第二个用户。确保所有字段都不是`NULL`。由于ID是主键，它需要是唯一的。
- en: When you are inserting, updating, and deleting from the table, please use the
    `Prepare()` function to protect against SQL injection attacks.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在表中插入、更新和删除数据时，请使用`Prepare()`函数来防止SQL注入攻击。
- en: You should use a struct to store the user information you would like to insert,
    and when you are inserting, iterate over the struct with a `for` loop.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该使用结构体来存储你想要插入的用户信息，并在插入时使用`for`循环遍历结构体。
- en: Once the `insert`, `update`, and `delete` calls are complete, make sure you
    use `Close()` when appropriate and close the connection to the database.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成`insert`、`update`和`delete`调用，确保在适当的时候使用`Close()`并关闭与数据库的连接。
- en: 'Upon successful completion, you should see the following output:'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 成功完成后，你应该看到以下输出：
- en: '![Figure 15.10 – Possible output](img/B18621_15_10.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图十五点一零 - 可能的输出](img/B18621_15_10.jpg)'
- en: Figure 15.10 – Possible output
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图十五点一零 - 可能的输出
- en: Note
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Activity15.01/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Activity15.01/main.go).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Activity15.01/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Activity15.01/main.go)找到。
- en: By the end of this activity, you should have learned how to create a new table
    called `users` and how to insert data into it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动结束时，你应该学会如何创建一个名为`users`的新表，以及如何向其中插入数据。
- en: Activity 15.02 – finding the messages of specific users
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十五点零二 - 查找特定用户的消息
- en: In this activity, we will build on *Activity 15.01 – holding user data in* *a
    table*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，我们将基于*活动十五点零一 - 在表中存储用户数据*继续。
- en: 'We need to create a new table called `Messages`. This table will have two columns,
    both of which should have a 280-character limit: one is `UserID` and the other
    is `Message`.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个名为`Messages`的新表。此表将有两个列，这两个列都应该有280个字符的限制：一个是`UserID`，另一个是`Message`。
- en: When your table is ready, you should add some messages with user IDs. Make sure
    you add `UserID`, which is not present in the `users` table.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的表准备就绪时，你应该添加一些带有用户ID的消息。确保添加`UserID`，它不在`users`表中。
- en: Once you have added the data, write a query that returns all the messages a
    specified user has sent. Use the `Prepare()` function to protect against SQL injection.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了数据，编写一个查询，返回指定用户发送的所有消息。使用`Prepare()`函数来防止SQL注入。
- en: 'If the specified user cannot be found, print `The query returned nothing, no
    such user: <username>`. You should take the username as input from the keyboard.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到指定的用户，请打印`查询未返回任何内容，没有这样的用户：<username>`。你应该从键盘输入用户名。
- en: 'Perform these steps to complete this activity:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动：
- en: Define a struct that holds `UserID` and its messages.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个结构体，用于存储`UserID`及其消息。
- en: Messages should be inserted with a `for` loop that iterates over the previously
    defined struct.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该使用一个遍历先前定义结构的`for`循环来插入消息。
- en: When the user input is received, make sure you use the `Prepare()` statement
    to craft your query.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当接收到用户输入时，请确保使用`Prepare()`语句来构建你的查询。
- en: 'If everything has gone well, you should get the following output, depending
    on how you fill your database with usernames and messages:'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该会得到以下输出，具体取决于您如何用用户名和消息填充您的数据库：
- en: '![Figure 15.11: Expected output](img/B18621_15_11.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.11：预期输出](img/B18621_15_11.jpg)'
- en: 'Figure 15.11: Expected output'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.11：预期输出
- en: Note
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Activity15.02/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Activity15.02/main.go).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在 [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Activity15.02/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Activity15.02/main.go)
    找到。
- en: If you want, you can tweak the script so that you don’t recreate the database
    on consecutive runs.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以调整脚本，以便在连续运行时不重新创建数据库。
- en: By the end of this activity, you should have learned how to create a new table
    called `Messages`, then take input from the user and search for related users
    and messages based on the input.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本活动结束时，您应该学会如何创建一个名为 `Messages` 的新表，然后从用户那里获取输入，并根据输入搜索相关的用户和消息。
- en: Adding users with GORM
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GORM 添加用户
- en: So far, we’ve interacted with the database by writing some SQL queries directly.
    What we’ve done is create and run Go code, which was used to then run SQL code.
    This is perfectly fine, but there is also a way to run just Go code to interact
    with a SQL database. On top of this, the data that we are storing in the database
    will then be unwrapped into Go variables, and the content of a row might define
    the values of an instance of a Go struct. What we can do to improve and simplify
    the whole process is abstract the database even more and use an **object-relational
    mapper** (**ORM**). This is a library that matches the tables and their relations
    as Go structs so that you can insert and retrieve data the same way you would
    instantiate and delete any instance of a Go struct. An ORM is not generally part
    of a language, and Go does not provide one by itself. There is, however, a set
    of third-party libraries, one of which is the de facto ORM for Go, and this is
    GORM. You can find all the details of this package at [https://gorm.io/](https://gorm.io/),
    but we will briefly learn how to use it to add and search for data in our database.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们通过与直接编写一些 SQL 查询来与数据库交互。我们所做的是创建并运行 Go 代码，然后使用这些代码来运行 SQL 代码。这完全没问题，但还有一种方法可以直接运行
    Go 代码来与 SQL 数据库交互。在此基础上，我们存储在数据库中的数据将被解包到 Go 变量中，一行内容可能定义了一个 Go 结构体实例的值。为了改进和简化整个过程，我们可以进一步抽象数据库并使用
    **对象关系映射器**（**ORM**）。这是一个将表及其关系与 Go 结构体匹配的库，这样您就可以以实例化和删除任何 Go 结构体实例相同的方式插入和检索数据。ORM
    通常不是语言的一部分，Go 本身也不提供。然而，存在一系列第三方库，其中之一是 Go 的既定 ORM，即 GORM。您可以在 [https://gorm.io/](https://gorm.io/)
    找到该包的所有详细信息，但我们将简要学习如何使用它来添加和搜索数据库中的数据。
- en: 'To use GORM, we must import it. Here’s how:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 GORM，我们必须导入它。以下是导入方法：
- en: '[PRE47]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, we do not have just one line but two. The first loads the GORM
    library, while the second specifies the driver to use. GORM can be used to interact
    with a lot of different database engines, including MySQL, Postgres, and SQLite.
    While the library itself is available from [gorm.io/gorm](http://gorm.io/gorm),
    the specific way to interact with the engine is handled by the driver – in this
    case, the Postgres driver.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们不仅仅只有一行代码，而是有两行。第一行加载了 GORM 库，而第二行指定了要使用的驱动程序。GORM 可以用来与许多不同的数据库引擎交互，包括
    MySQL、Postgres 和 SQLite。虽然库本身可以从 [gorm.io/gorm](http://gorm.io/gorm) 获取，但与引擎交互的具体方式由驱动程序处理——在本例中，是
    Postgres 驱动程序。
- en: 'The next step will be to define a schema – that is, a Go struct representing
    what’s inside a table. Let’s define a struct representing a user:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是定义一个模式——即一个代表表内内容的 Go 结构体。让我们定义一个代表用户的结构体：
- en: '[PRE48]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is pretty straightforward – we define a struct called `User` and we add
    some fields that will hold the first and last name of a user, together with their
    email address. The first important thing, however, is that we embed the `gorm.Model`
    struct into our struct, making it effectively a GORM model. This struct will add
    some fields, such as an ID, and set it as a primary key, as well as some other
    fields, such as creation and update date, and will also add some methods that
    will be used by the library to make it interact with a database.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常直接——我们定义一个名为 `User` 的 struct，并添加一些字段来存储用户的姓名和电子邮件地址。然而，第一件重要的事情是，我们将 `gorm.Model`
    struct 嵌入到我们的 struct 中，使其成为一个 GORM 模型。这个 struct 将添加一些字段，例如 ID，并将其设置为主键，以及一些其他字段，例如创建和更新日期，并且还会添加一些库将用于与数据库交互的方法。
- en: 'Now that we have a struct defining a user, let’s see how we can insert a user
    into the database. To interact with the database, we must connect to it. Earlier,
    we saw how to connect to PostgreSQL; we will do something similar here:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了一个用户结构的 struct，让我们看看我们如何将一个用户插入到数据库中。为了与数据库交互，我们必须连接到它。之前，我们看到了如何连接到
    PostgreSQL；这里我们将做类似的事情：
- en: '[PRE49]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, we can use the same connection string as earlier, but we will
    do so inside the `gorm.Open` call, which allows GORM to interact with the underlying
    database engine.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以使用之前相同的连接字符串，但我们将这样做是在 `gorm.Open` 调用内部，这允许 GORM 与底层数据库引擎交互。
- en: 'So far, we haven’t created a table for the users, and we’ve seen how to create
    one using SQL and call it via Go. With GORM, we do not need to do that. After
    defining the type that will go inside the table that will hold users, we can have
    GORM create that table for us, if it does not exist already. We can do this with
    the following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有为用户创建一个表格，我们也看到了如何使用 SQL 创建一个表格并通过 Go 调用它。使用 GORM，我们不需要这样做。在定义将放入存储用户的表格中的类型之后，我们可以让
    GORM 为我们创建该表格，如果它尚未存在的话。我们可以用以下代码来完成：
- en: '[PRE50]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This call ensures that there is a table holding users that contains all the
    required columns, and by default will call it *users*. There are ways to change
    the name of the table, but in general, it is better to follow the conventions.
    So, a table holding users’ data will be called *users*, while a struct holding
    the details of a user will be called `User`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用确保有一个包含所有必需列的表格，并且默认情况下会将其命名为 *users*。有方法可以更改表格的名称，但通常，遵循约定会更好。因此，存储用户数据的表格将被称为
    *users*，而存储用户详细信息的 struct 将被称为 `User`。
- en: 'What remains now is just to add an actual user – we will call him John Smith
    and use `john.smith@gmail.com` as his email address. This is how we can instantiate
    the struct with his details:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只是添加一个实际的用户——我们将称他为 John Smith，并使用 `john.smith@gmail.com` 作为他的电子邮件地址。这就是我们如何使用他的详细信息实例化
    struct 的方法：
- en: '[PRE51]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, we can insert it into the database:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将其插入到数据库中：
- en: '[PRE52]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see, this is pretty straightforward and allows us to write just Go
    code and model our data as Go structs.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这非常直接，它允许我们只编写 Go 代码并将我们的数据建模为 Go structs。
- en: GORM has quite a few functionalities; in this section, we learned how to create
    structs and use them to match a schema in a database, as well as add data to a
    specific table. Now, let’s learn how to find users with GORM.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: GORM 有很多功能；在本节中，我们学习了如何创建 structs 并使用它们来匹配数据库中的模式，以及如何向特定表格添加数据。现在，让我们学习如何使用
    GORM 查找用户。
- en: Finding Users with GORM
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GORM 查找用户
- en: 'Once we’ve added users, we would like to retrieve them. Let’s add a few other
    users using what we learned in the previous section:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了用户，我们希望检索它们。让我们使用上一节中学到的知识添加几个其他用户：
- en: '[PRE53]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Let’s assume that we had already inserted the record for John Smith. So, starting
    from a clean database and clean table, we should have users with IDs of 1, 2,
    and 3, respectively.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已为 John Smith 插入了记录。因此，从一个干净的数据库和干净的表格开始，我们应该有 ID 为 1、2 和 3 的用户。
- en: 'Now, we want to retrieve details about the first user we inserted. We can do
    that with the following command:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要检索我们插入的第一个用户的详细信息。我们可以用以下命令来完成：
- en: '[PRE54]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This will return the first user matching the condition where the user’s ID
    is equal to 1\. The returned record is un-marshaled into the `user` variable,
    which is an instance of the `User` struct. We can search for every other user
    via their ID and substitute the number 1 with 2 or 3\. This, however, is not very
    interesting, as we might not know the user’s ID but only their name or surname.
    Let’s see how to retrieve John Doe from his surname:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回第一个用户，其 ID 等于 1。返回的记录被反序列化到 `user` 变量中，它是 `User` 结构体的一个实例。我们可以通过他们的 ID 搜索每个其他用户，并将数字
    1 替换为 2 或 3。然而，这并不很有趣，因为我们可能不知道用户的 ID，只知道他们的名字或姓氏。让我们看看如何通过姓氏检索 John Doe：
- en: '[PRE55]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Note that we did not use “LastName” but `last_name` as GORM automatically transforms
    every attribute of the struct that’s camel case into snake case; this is the usual
    convention for database column names. The other important thing to notice is that
    we use two parameters:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有使用 “LastName” 而是使用 `last_name`，因为 GORM 自动将结构体的每个驼峰式命名的属性转换为蛇形命名；这是数据库列名称的常用约定。另一个需要注意的重要事情是我们使用了两个参数：
- en: '[PRE56]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The first one represents the column we want to search in, and we have a question
    mark after the equals sign. The question mark is a placeholder and will be replaced
    by the next parameter, which is *Doe*. As we have two people with the surname
    Smith, the function we just used will retrieve the first person with that surname,
    but this is not necessarily the one we are looking for. We could use the `Last`
    function, which returns the last result that matches the query, but we could have
    more users with the same surname. The solution for this is as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表示我们想要搜索的列，等号后面有一个问号。问号是一个占位符，将被下一个参数替换，即 *Doe*。由于有两个姓氏为 Smith 的人，我们刚才使用的函数将检索到第一个同姓的人，但这并不一定是我们要找的人。我们可以使用
    `Last` 函数，它返回与查询匹配的最后结果，但我们可能有更多同姓的用户。这个解决方案如下：
- en: '[PRE57]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we created a query that includes more conditions – the first few parameters
    express the condition, while the following parameters fill the values with placeholders.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个包含更多条件的查询——前几个参数表示条件，而后续的参数使用占位符填充值。
- en: 'The issue we could face here is that we might get confused with the names of
    the struct’s attributes and the actual column names. If we need to do a simple
    matching query, we can substitute the previous code with the following:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能面临的问题是，我们可能会混淆结构体属性的名称和实际的列名称。如果我们需要执行一个简单的匹配查询，我们可以用以下代码替换之前的代码：
- en: '[PRE58]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, we just pass an instance of the `User` struct with a few attributes set,
    leaving the other ones to the default values.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们只传递一个设置了几个属性的 `User` 结构体实例，其他属性使用默认值。
- en: 'These examples allow us to search for a specific record, but often, we need
    a list of objects. Of course, the `First` and `Last` functions return only one
    item, but GORM also gives us a function to return all the records that match our
    criteria. If the criteria is simply an ID, or if the field we search for is unique,
    we are better off sticking with `First`, but if our criteria are not unique, we
    should use the following function:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例允许我们搜索特定的记录，但通常，我们需要一个对象的列表。当然，`First` 和 `Last` 函数只返回一个项目，但 GORM 也提供了一个函数来返回所有符合我们标准的记录。如果标准是一个简单的
    ID，或者如果我们搜索的字段是唯一的，我们最好坚持使用 `First`，但如果我们的标准不是唯一的，我们应该使用以下函数：
- en: '[PRE59]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `Find` function returns all the matching records, but we cannot just un-marshal
    it into a single user instance. So, we must define a `users` variable, which is
    a slice of `User` instances, rather than using the previously seen `user`, which
    was an instance of a `User` struct.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`Find` 函数返回所有匹配的记录，但我们不能直接将其反序列化为单个用户实例。因此，我们必须定义一个 `users` 变量，它是一个 `User`
    实例的切片，而不是使用之前看到的 `user`，它是一个 `User` 结构体的实例。'
- en: 'This gives us an idea of how to use GORM to insert and retrieve data, but we’ve
    forgotten one important thing: errors. These functions are contacting the database,
    but the queries might somehow error for several reasons, and we need to control
    that. The previously seen function does not return an error but a pointer to the
    database struct, which we can use to get the errors:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们有了一个如何使用 GORM 插入和检索数据的概念，但我们忘记了一件事：错误。这些函数正在联系数据库，但查询可能会因为几个原因而出错，我们需要控制这一点。之前看到的函数不返回错误，而是一个指向数据库结构的指针，我们可以用它来获取错误：
- en: '[PRE60]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, the `tx` variable stands for *transaction* and returns a set of values
    with a potential error among them. We can check if there is an error by comparing
    the `tx.Error` value with `nil`. When we use a transaction, whatever we do to
    the database is not definitive; it does not affect the state of the database that’s
    accessed by any other client, so any change is temporary. To make any change effective,
    we need to commit the transaction. In this case, we are just returning results,
    and not modifying the database, so we do not need to commit. We are using the
    transactions because GORM returns a transaction from the `Find` call.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: This gives us a starting point to use GORM to model and use data while storing
    it in a database.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter made you efficient in interacting with SQL databases. You learned
    how to create, delete, and manipulate database tables. You also become aware of
    all the different types of databases Go is suited to interact with. As this chapter
    was made with the PostgreSQL engine in mind, you should familiarize yourself with
    its Go module too.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you will now be able to step foot into the realm of database
    programming with the Go language and be self-sufficient in the sense that you
    know where to look for solutions to problems and extra knowledge. The most common
    use case for this knowledge is when you must build automated reporting apps that
    pull data from a database and report it as an email. The other use case is when
    you have an automated app for pushing data to the database server that processes
    a CSV file or an XML file. This depends on the situation you are in.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter also introduced you to the concept of ORM and has given you an
    introduction to the most famous ORM for the Go language: GORM.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to interact with web interfaces via
    HTTP clients, which is one of the most interesting topics in Go.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 5: Building For The Web'
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The modern world has been profoundly influenced by the Internet and the World
    Wide Web. Go, born in the internet age, was meticulously crafted to thrive in
    this digital landscape.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: This section delves into the realm of web development with Go, empowering you
    to create robust and efficient web applications.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'This section includes the following chapters:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B18621_16.xhtml#_idTextAnchor1704), *Web Servers*'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 17*](B18621_17.xhtml#_idTextAnchor1790), *Using the Go HTTP Client*'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
