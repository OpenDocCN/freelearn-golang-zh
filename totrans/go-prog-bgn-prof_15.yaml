- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL and Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce you to databases – specifically relational databases
    – and how to access them via the Go programming language.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will guide you through how to connect to the SQL database engine,
    how to create a database, how to create tables in a database, and how to insert
    and retrieve data in and from tables. By the end of this chapter, you will be
    able to update and delete data in specific tables, as well as truncate and drop
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you’ll require Go version 1.21 or higher. The code for this
    chapter can be found at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter15](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter15).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to interact with the filesystem your
    Go app is running on. You learned about the importance of exit codes and how to
    customize your scripts to take arguments, thus adding flexibility to your applications.
    You also learned how to handle different signals that your application receives.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will further master your Go skills by learning how to use
    SQL and databases in Go. As a developer, it is impossible to get by without a
    proper understanding of persistent data storage and databases. Our applications
    process input and produce output, but most of the time, if not in all cases, a
    database is involved in the process. This database can be in-memory (stored in
    the computer’s RAM) or file-based (a single file in a directory), and it can live
    on local or remote storage. A database engine can be installed locally, as we
    will do later in this chapter, but it is also possible to use cloud providers,
    which allow you to use a database as a service; some of the cloud providers that
    offer several different database engine options are Azure, AWS, and Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: What we aim to do in this chapter is make you fluent in talking to these databases
    and understanding the basic concepts of what a database is. Finally, you will
    have extended your skillset to make you a better Go developer as you progress
    through this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say your boss wants you to create a Go app that can communicate with a
    database. By *communicate*, we mean that any transaction that is `INSERT`, `UPDATE`,
    `DELETE`, or `CREATE` can and should be handled by the application. This chapter
    will show you how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We commonly use the word database in different ways, but let’s be a bit more
    formal here:'
  prefs: []
  type: TYPE_NORMAL
- en: A database is where we store our data, where we persist it (if we want), and
    where we can run some queries to insert new data and retrieve or modify existing
    data.
  prefs: []
  type: TYPE_NORMAL
- en: You might think that a filesystem fits this description, but actually, this
    is not the case; a real database allows us to perform very complex and precise
    queries to gather data based on very specific conditions. To do so, we will have
    a language to perform these queries or other operations. In our case, we will
    focus on a language called SQL.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve stated what a database is, but this is still quite abstract. To create
    a database and fill it with data, we need an engine – essentially, an application
    – that will allow us to perform all these operations. In this section, we’ll learn
    how to use a database engine called **Postgres SQL**. As its name suggests, this
    engine will allow us to perform operations using the SQL language.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Postgres SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a first step, you need to install Postgres SQL and configure it for yourself
    so that you can try out the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to grab the installer from [https://www.postgresql.org/download/](https://www.postgresql.org/download/).
    Select the one that is appropriate for your system; we will go through the Windows
    installer here, but things are pretty similar for other systems. The installer
    is very easy to use, and I suggest that you accept the defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the installer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.1: Selecting the installation directory](img/B18621_15_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.1: Selecting the installation directory'
  prefs: []
  type: TYPE_NORMAL
- en: 'Leave the default components as-is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.2: Selecting components to install](img/B18621_15_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.2: Selecting components to install'
  prefs: []
  type: TYPE_NORMAL
- en: 'Leave the default data directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.3: Selecting the data directory](img/B18621_15_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.3: Selecting the data directory'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You will be asked for a password. You need to remember this because this is
    the master password for your database.
  prefs: []
  type: TYPE_NORMAL
- en: '`Start!123` is the password for this example. The database is running on local
    port `5432`. The `pgAdmin` GUI tool will also be installed, and, once the installer
    completes, you can start `pgAdmin` to connect to the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your browser, go to [https://packt.live/2PKWc5w](https://packt.live/2PKWc5w)
    to access the admin interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4: The admin interface](img/B18621_15_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.4: The admin interface'
  prefs: []
  type: TYPE_NORMAL
- en: Once the installation is complete, you can create new databases through `pgAdmin`
    and call them whatever you want, but for the next few steps, make sure you have
    one database called just `postgres` to which we will connect via Go. We are now
    ready to proceed to the next part and connect to the database via Go.
  prefs: []
  type: TYPE_NORMAL
- en: Database API and drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A database is a place where data is stored; we normally use database engines,
    which are software applications that allow us to create and interact with databases.
    A lot of different database engines exist, and they give us different ways of
    structuring the data. Nowadays, many different kinds of databases exist, but the
    most used and solid are the ones called *SQL databases*. **SQL** is a standard
    that stands for **Structured Query Language**. This is a standardized language
    that specifies how a database engine should respond to specific commands from
    the user. As its name suggests, it’s a language that allows us to perform queries
    on a database engine – that is, ask it to perform those actions.
  prefs: []
  type: TYPE_NORMAL
- en: To work with databases, there is something called the *pure* Go approach, which
    means Go has an API that allows you to use different drivers to connect to databases.
    The API comes from the `database/sql` package, and the drivers can be of two types.
    There is native support for a wide variety of drivers, all of which can be found
    on the official GitHub page ([https://packt.live/2LMzcC4](https://packt.live/2LMzcC4)),
    and there are third-party drivers that need additional packages to function, such
    as the `SQLlite3` package, which requires you to have `GCC` installed because
    it is a pure C implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: GCC is a compiler system produced by the GNU Project. It takes your source code
    and translates it into machine code so that your computer can run the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of a couple of drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MySQL** ([https://packt.live/38zk9Fw](https://packt.live/38zk9Fw))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Oracle** ([https://packt.live/34cxwrP](https://packt.live/34cxwrP))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ODBC** ([https://packt.live/2EfETV8](https://packt.live/2EfETV8))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Postgres** ([https://packt.live/35jKEwL](https://packt.live/35jKEwL))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea behind the API and driver approach is that Go provides a unified interface
    that allows developers to talk to different types of databases. All you need to
    do is import the API and the necessary driver and you can talk to the database.
    You don’t need to learn driver-specific implementations or how that driver works
    because the API’s sole purpose is to create an abstraction layer that accelerates
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider an example. Let’s say we would like to have a script that queries
    a database. This database is MySQL. One approach is to take the driver and learn
    how to code in its language, and then you are good to go. Some time passes by,
    and you build lots of small scripts that do their job properly. Now, the time
    has come for a management decision that will make you unhappy. They decide that
    MySQL is not good enough, and they are going to replace the database with AWS
    Athena, a cloud-based database.
  prefs: []
  type: TYPE_NORMAL
- en: Now, since you wrote your scripts specifically for a certain driver, you will
    be busy rewriting your scripts for them to work properly. The safeguard here is
    to use a unified API and driver combination. This means writing the scripts against
    the API and not the driver. The API will translate your wishes for the specific
    driver. This way, all you need to do is swap out the driver, and the scripts are
    guaranteed to work. You just saved yourself many hours of scripting and rewriting
    code, even though the underlying database has been completely replaced.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are working with databases in Go, we can differentiate between the
    following types of databases:'
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoSQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search and analytic databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, we will focus on relational databases, which mostly use the SQL
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Connecting to a database is by far the easiest thing to do; however, we need
    to keep a few things in mind. To connect to any database, we need at least four
    things to be in place:'
  prefs: []
  type: TYPE_NORMAL
- en: We need a host to connect to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a database to connect to that is running on a port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need a password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user needs to have appropriate privileges because we not only want to connect
    but we would like to perform specific operations, such as query, insert, or remove
    data, create or delete databases, and manage users and views. Let’s imagine that
    connecting to a database is like walking up to a door as a specific person with
    a specific key. Whether the door opens or not depends on the key, but what we
    can do after we have crossed the threshold will depend on the person (which is
    defined by their privileges).
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, the database server supports multiple databases, and the databases
    hold one or more tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – Databases in a server](img/B18621_15_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.5 – Databases in a server
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that the databases are logical containers that belong together.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s create a new project. To do so, create a folder called `database1`
    and go to this folder with your terminal. Inside the folder, write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look at how we can connect to a database in Go. To connect, we
    need to get the appropriate module from GitHub, which needs internet connectivity.
    We need to issue the following command to get the package needed to interact with
    the Postgres instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This chapter uses the `pq` package to connect to the database. However, alternative
    packages are available that can be used here instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to run it from within your project’s folder. Once this is completed,
    you are ready to start scripting. First, we will initialize our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you would like further information, please visit [https://packt.live/2PByusw](https://packt.live/2PByusw).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have initialized our script, we can connect to our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This topic is special because the API gives us an `Open()` function, which takes
    a variety of arguments. There are shorthand ways of doing this, but I would like
    you to know about all the components that are involved in making the connections,
    so I will use the longer way. Later, you can decide which one to use.
  prefs: []
  type: TYPE_NORMAL
- en: The `postgres` string, used as the first parameter in the `Open` function call,
    tells the function to use the `Postgres` driver to make the connection. The second
    argument is a so-called connection string, which holds the `user`, `password`,
    `host`, `port`, `dbname`, and `sslmode` arguments; these will be used to initialize
    the connection. In this example, we’re connecting to the local host marked by
    `127.0.0.1` on the default port of `5432`, and we don’t use `ssl`. For production
    systems, people tend to change the default port and enforce encrypted traffic
    via `ssl` toward the database server; you should always follow the best practices
    concerning the type of database you’re working with.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the `Open()` function returns two values. One is for the database
    connection and the other is for the error, if one occurred during initialization.
    How do we check whether the initialization was successful? Well, we can check
    whether there were any errors by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `panic()` function in Go is used to indicate that something went wrong
    unexpectedly, and we are not prepared to handle it gracefully, thus stopping the
    execution. If the connection succeeds, we print out a message stating `The connection
    to the DB was successfully initialized!`. When you have a long-running application,
    it is worth incorporating a way to check whether the database is still reachable
    because due to intermittent network errors, you could lose the connection and
    fail to execute whatever you want to execute. This can be checked with the following
    small code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can run this check constantly on a different Go routine every few seconds.
    It will check if the database is on but also help keep the connection open; otherwise,
    it will go idle. This is a proactive solution as you check the status of the database
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we used the `panic()` function to indicate that the connection
    has been lost. Finally, once our job is done, we need to terminate our connection
    to the database to remove user sessions and free up resources. This can happen
    either if you are building a script that will run as a job, hence will run and
    finish, or if you are building a long-running service. In the first case, you
    can use the following command at the end of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This ensures that before terminating the script, the connection will be dropped.
    If you are building a long-running service, you don’t have a specific point in
    your code where you know that the script will terminate, but it can happen at
    any time. You can use the following code to ensure the connections are dropped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The difference is the scope. `db.Close()` will terminate the connection to the
    database once the execution arrives at the specific line, while `defer db.Close()`
    indicates that the database connection should be executed once the function in
    which it was called goes out of scope. The idiomatic way to do this is with `defer
    db.Close()`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will start using the connection for something more purposeful,
    and we will start by creating tables.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The official `Postgres` library for Go can be found at [https://packt.live/35jKEwL](https://packt.live/35jKEwL).
  prefs: []
  type: TYPE_NORMAL
- en: Creating tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The act of creating tables aims to make logical containers that persistently
    hold data that belongs together. You will need to create tables for many reasons
    – for example, tracking employee attendance, revenue tracking, and statistics.
    The common goal is to provide a service for applications that make sense of it.
    How do these database engines control who can access what data? There are two
    approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is `CREATE`, `UPDATE`, and `DELETE`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second approach involves inheritance and roles. This is more robust and
    is better suited for big enterprises.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Postgres` uses the second approach, and in this section, we will learn how
    to create a SQL table and how to create one specifically in `Postgres`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax for table creation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When we talk via SQL to the `Postgres`, `mysql`, or `mssql` server, they all
    respond in the same way to a `CREATE TABLE` or `INSERT` command because they are
    SQL compliant. The idea of the standard is not to specify how the engine works
    internally but how the interaction with it should happen. These database engines
    usually differ in terms of functionality, speed, and storage approaches; that’s
    where the variety comes from. This is not, however, a full SQL or database engine
    tutorial, so we just gave you a brief introduction to what SQL is without going
    into a lot of details.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see some of the general statements of the SQL language, with which we
    will then experiment a bit later. The statement for table creation is `CREATE
    TABLE`. This command is understood in the context of the database you are connected
    to. One server can host multiple databases, and connecting to the wrong one can
    cause headaches when issuing a command that modifies the structure. The command
    usually takes a column name, which is `column1` in our case, and the type of data
    in our column, which is `datatype`. Finally, we can set constraints on our columns,
    which will imbue them with special properties. The supported data types for our
    columns depend on the database engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some common data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOUBLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FLOAT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VARCHAR`, which is a string with a specific length'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The constraints also depend on the database engine, but some of them are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NOT NULL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PRIMARY KEY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Named function`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The named function is executed every time a new record is inserted or an old
    one is updated and, based on the evaluation of the transaction, is either allowed
    or denied.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not only able to create a table, but we can also empty the table – that
    is, remove all of its contents, or remove the table itself from the database.
    To empty a table, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove the table, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, create a new table. In `Postgres`, you have a default database you can
    use; we are not going to create a separate database for the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to initialize our script, which you can find in the examples
    folder, and it’s called `DBInit.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to define our `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DBInit.go`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The full code is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBInit.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBInit.go).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dissect what is happening here. We initialize our connection to the database
    without the default username and password that was previously mentioned, and now,
    we have the `db` variable to interact with the database. Unless there was an error
    upon execution, the following output will be visible in our console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – The desired output, as visible in the console](img/B18621_15_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.6 – The desired output, as visible in the console
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to rerun the script, the following error would occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7 – Output of failure after consecutive execution](img/B18621_15_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.7 – Output of failure after consecutive execution
  prefs: []
  type: TYPE_NORMAL
- en: This says that the table already exists. We created a multiline string called
    `DBCreate` that holds all the table creation information. In this, we have a table
    called `test`, which has an integer column called `id` and a string column called
    `name`. The rest of it is Postgres-specific configuration. The tablespace defines
    where our table lives. The `_, err` line with `db.Exec()` is responsible for executing
    the query.
  prefs: []
  type: TYPE_NORMAL
- en: The table we are creating will have an ID (unique identifier) per row, which
    will be of the integer type, and a name column, which will be of the character
    type. The names have a few characteristics; for example, *COLLATE* defines how
    the data will be ordered, or better, what comes first or after when requesting
    data in ascending or descending order. We are taking the default collate for `postgres`,
    which is defined by the localization currently in the database.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve just said, we are going to create a table with an ID, and we will use
    that to identify the rows. `Postgres` provides a unique identifier for each row
    automatically, which is called **oid** (**Object Identifier**), but we don’t need
    this as we are handling it manually. Note that not all other database engines
    provide the oid.
  prefs: []
  type: TYPE_NORMAL
- en: Since our goal now is to create the table, we only care whether there are any
    errors; otherwise, we can use a throwaway variable to capture the output. If `err`
    is not `nil`, there was an error, as we saw previously. Otherwise, we assume the
    table was created as expected. Finally, the connection to the database is closed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can connect to the database and we have a table, we can insert some
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Long ago, when the era of web applications backed by SQL databases started
    to bloom, some gutsy people invented the SQL injection attack. Here, a type of
    authentication is done against a database via SQL queries and, for example, after
    converting the password with mathematical magic into hash functions, the web app
    executes the query with the username and password coming from the input of the
    form. Many servers executed something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Then, the password gets rehashed; if the two hashes match, the password is good
    for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with this came from the `<input from user>` part because if the
    attacker was smart enough, they could reformulate the query and run additional
    commands. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this query is that `OR '1' = '1'` always evaluates to `true`,
    and it does not matter what the username is; the user’s password hash would be
    returned. This can be further reused to formulate an additional attack. To prevent
    this, Go uses something called the `Prepare()` statement, which protects against
    these attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go has two types of substitutions:'
  prefs: []
  type: TYPE_NORMAL
- en: We use `WHERE col = $1` in the case of queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `VALUES($1,$2)` in the case of inserts or updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s add some values to our tables. We are going to initialize our script
    in the usual way. This script can be found under the examples folder and is called
    `DBInsert.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon successful execution, we’ll get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let’s see what’s happening with the insert part. `db.Prepare()` takes a SQL
    statement and imbues it with protection against SQL injection attacks. It works
    by restricting the values of the variable substitutions. In our case, we have
    two columns, so for the substitution to work, we use `$1` and `$2`. You can use
    any number of substitutions; you only need to make sure they result in a valid
    SQL statement when evaluated. When the `insert` variable is initialized without
    errors, it will be responsible for executing the SQL statement. It finds out how
    many arguments the prepared statement expects, and its sole purpose is to call
    the statement and perform the operation. `insert.Exec(2,"second")` inserts a new
    element with `id=2` and `name='second'`. If we were to check what we have in our
    database, we would see the results.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some data in our table, we can query it.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 15.01 – creating a table that holds a series of numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we are going to write a script that is going to create a table
    called `Numbers`, in which we are going to store numbers. These numbers will be
    inserted at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: Create two columns, `Number` and `Property`. The `Number` column will hold numbers,
    while the `Property` column will be `Odd` or `Even` when it’s created.
  prefs: []
  type: TYPE_NORMAL
- en: Use the default `Postgres` database for the connection. The numbers should range
    from 0 to 99.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize the package with the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `property` `string` variable for later use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the database connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a multiline string to create the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert the numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the database connection and function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you execute the script, you should see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.8 – Output of the successful property update](img/B18621_15_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.8 – Output of the successful property update
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Part of the output has been omitted from *Figure 15**.8* due to its length.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw how to create a new table in our database and how to
    insert new records with the help of a `for` loop and a `Prepare()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL injection does not only concern the data being inserted. It also concerns
    any data that is manipulated in the database. Retrieving data and, most importantly,
    retrieving it safely is also something we must prioritize and handle with proper
    caution. When we query data, our results depend on the database we connect to
    and the table we would like to query. However, we must also mention that the security
    mechanisms that are implemented by the database engine may also prevent a successful
    query unless the user has appropriate privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can differentiate between two types of queries:'
  prefs: []
  type: TYPE_NORMAL
- en: Some queries do not take an argument, such as `SELECT *` `FROM table`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some queries require you to specify filter criteria
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go provides two functions that allow you to query data. One is called `Query()`
    and the other is called `QueryRow()`. As a rule of thumb, you should remember
    that `Query()` is used to return any number of results, while `QueryRow` is used
    when you expect to retrieve at most one row. You can also wrap them with the `Prepare()`
    statement, though we won’t cover this here as it was demonstrated before. Instead,
    we want to see how these functions work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a script for `Query()`. As always, we’ll initialize the script.
    It can be found in the examples and is called `DBQuery.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `main()` function will be a little bit different because we would like
    to introduce the `Scan()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A `SELECT *` query string is not likely to be seen in professional environments
    due to performance and security concerns. You will typically have more specific
    query strings for the specific data.
  prefs: []
  type: TYPE_NORMAL
- en: As we inserted this data into our database previously, feel free to add some
    more data based on the previous example. We have defined the `id` and `name` variables,
    which will help our `Scan()` function. We connect to the database and create our
    `db` variable. After that, we fill our `rows` variable with the result of the
    `Query()` function, which will hold all the elements from the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here comes the tricky part: we use `for rows.Next()` to iterate over the resulting
    rows. But that is not enough; we would like to assign the results of the query
    to the corresponding variable, which is returned by `rows.Scan(&id, &name)`. This
    allows us to refer to the current row’s ID and `NAME`, which makes it easier to
    do whatever we would like to do with the value. Finally, the rows and the database
    connections are gracefully closed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s query a single row with `Prepare()`. The initialization looks the same
    as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DBPrepare.go`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The full code is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBPrepare.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBPrepare.go).
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference is at the beginning of the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, if you did everything correctly, should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s inspect our `main` function closely. We defined two variables: the `name`
    variable, which will be used when we process the query result, and the `id` variable,
    which serves as a flexible input for the query we execute. The usual connection
    initialization toward our database happens as before.'
  prefs: []
  type: TYPE_NORMAL
- en: Then comes the `SQL Injection` proof part. We prepare a query that is dynamic
    in the sense that it accepts a parameter that will be the ID we are looking for.
    Then, `qryrow` is used to execute the `QueryRow()` function, which, in turn, takes
    the `id` variable we specified previously and returns the result in the `name`
    variable. Then, we output the string with an explanation that the value of the
    column is based on the `id` variable that was specified. In the end, the `qryrow`
    and `db` resources are closed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to retrieve data from the database, we need to see how
    to update existing data in our database.
  prefs: []
  type: TYPE_NORMAL
- en: Updating existing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are updating a row or multiple rows with Go, you are in trouble. The
    `sql` package does not provide any function called `Update()`; however, there
    is the `Exec()` function, which serves as a universal executor for your queries.
    You can execute `SELECT`, `UPDATE`, `DELETE`, or whatever you need to execute
    with this function. This section will show you how you can do this safely.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to start our script in the usual way. It can be found in the
    examples folder and is called `DBUpdate.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the magic comes. The idea is to update the `name` column’s value for a
    specific `id` variable that we give as an argument. So, the `main()` function
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything has gone well, we’ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can and should experiment with different inputs and see how the
    script reacts to different problems/errors.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dissect what’s happening here. We initialize our database connection as
    we did before. We create the `UpdateStatement` variable, which is a multiline
    string, and it is crafted so that it can be fed to the `Exec()` function, which
    takes arguments. We want to update the name of the column that has the specified
    ID. This function either runs the specified statement on its own or can be used
    to pass arguments that are substituted in the appropriate place. This would be
    perfectly fine and would do the job for us, but we would like to make sure that
    the `UPDATE` command updates at least one record.
  prefs: []
  type: TYPE_NORMAL
- en: To this end, we could use `RowsAffected()`. It will return the number of rows
    that were updated and any errors that were faced along the way. Finally, we print
    how many rows were updated to the console and close the connection.
  prefs: []
  type: TYPE_NORMAL
- en: The time has come to delete data from our database.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data can be deleted for multiple reasons: we don’t need the data anymore, we
    are migrating to another database, or we are replacing the current solution. We
    are in luck because the current Go facilities provide a very nice way to do this.
    The analogy is the same as for the `UPDATE` statement of our records. We formulate
    a `DELETE` statement and execute it; we can technically modify the action of our
    `UPDATE` script to delete it from the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, we’ll only modify the relevant lines. Our `DELETE`
    statement will replace the `UPDATE` statement, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DBDelete.go`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The full code is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBDelete.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Examples/DBDelete.go).
    We’ll update the line with the `Exec()` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we must update the line with the calculation of updated records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Our result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: That’s it. With a little modification, we have a script that can either update
    or delete records with verification.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how we can create a table that holds prime numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 15.02 – holding prime numbers in a database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will build on *Exercise 15.01 – creating a table that holds
    a series of numbers*. We would like to create a script that will tell us how many
    prime numbers are in our table and give them to us in order of appearance. We
    would like to see the sum of prime numbers in the output. Then, we would like
    to remove every even number from the table and see how many were removed. We would
    like to add the sum of prime numbers to the remaining odd numbers and update the
    table with the records, changing the property if necessary. Use the `math/big`
    package for the primality test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a script called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize our script to perform the specific actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define four variables for later use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the database connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get a list of all the prime numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the sum of the prime numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the even numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the remaining records with `primeSum` and print a closing sentence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the database connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the script has been executed, the following output should be visible:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.9 – Output of the calculations](img/B18621_15_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.9 – Output of the calculations
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw how to utilize a built-in Go function to find prime
    numbers. We also manipulated the table by removing numbers, and then we performed
    update actions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Closing the database is important because once our job is done, we do want to
    release unused resources.
  prefs: []
  type: TYPE_NORMAL
- en: Truncating and deleting table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we want to empty a table and get rid of it. To empty the table,
    we can simply formulate `DELETE` statements that match every record in our table
    and thus remove every single record from our table. However, there is a more elegant
    way to do this: we can use the `TRUNCATE TABLE` SQL statement. The result of this
    statement is an empty table. We can use the `Exec()` function from our `sql` package
    for this. You already know how to initialize the package with imports. You also
    know how to connect to the database. This time, we’ll only focus on the statements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following statement will achieve a full `TRUNCATE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this is an empty table called `test`. To get rid of the table
    completely, we can modify our statement as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you need a table but do not need any more old data, you might want to truncate
    it and carry on adding new data to the existing table. If you do not need the
    table anymore because you changed your schema, you might want to just delete it
    using the `DROP` command.
  prefs: []
  type: TYPE_NORMAL
- en: If we inspect our database engine, we won’t find any trace of the `test` table.
    This eradicated the whole table from the very face of the database.
  prefs: []
  type: TYPE_NORMAL
- en: This section was all about interacting with databases via the Go programming
    language. Now, you have a decent understanding of how to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For further information and extra details, you should check out the official
    documentation of the SQL API: [https://packt.live/2Pi5oj5](https://packt.live/2Pi5oj5).'
  prefs: []
  type: TYPE_NORMAL
- en: Activity 15.01 – holding user data in a table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we are going to create a table that is going to hold user
    information such as `ID`, `Name`, and `Email`. We’ll build on the knowledge you
    gathered in the *Creating tables* and *Inserting* *data* sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a small script that will create a table called `Users`. This table must
    have three columns: `ID`, `Name`, and `Email`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the details of two users, along with their data, to the table. They should
    have unique names, IDs, and email addresses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you need to update the email of the first user to `user@packt.com` and
    remove the second user. Make sure that none of the fields are `NULL`. Since the
    ID is the primary key, it needs to be unique.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you are inserting, updating, and deleting from the table, please use the
    `Prepare()` function to protect against SQL injection attacks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should use a struct to store the user information you would like to insert,
    and when you are inserting, iterate over the struct with a `for` loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the `insert`, `update`, and `delete` calls are complete, make sure you
    use `Close()` when appropriate and close the connection to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upon successful completion, you should see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.10 – Possible output](img/B18621_15_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.10 – Possible output
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Activity15.01/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Activity15.01/main.go).
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this activity, you should have learned how to create a new table
    called `users` and how to insert data into it.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 15.02 – finding the messages of specific users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we will build on *Activity 15.01 – holding user data in* *a
    table*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a new table called `Messages`. This table will have two columns,
    both of which should have a 280-character limit: one is `UserID` and the other
    is `Message`.'
  prefs: []
  type: TYPE_NORMAL
- en: When your table is ready, you should add some messages with user IDs. Make sure
    you add `UserID`, which is not present in the `users` table.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have added the data, write a query that returns all the messages a
    specified user has sent. Use the `Prepare()` function to protect against SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the specified user cannot be found, print `The query returned nothing, no
    such user: <username>`. You should take the username as input from the keyboard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform these steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a struct that holds `UserID` and its messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Messages should be inserted with a `for` loop that iterates over the previously
    defined struct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user input is received, make sure you use the `Prepare()` statement
    to craft your query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If everything has gone well, you should get the following output, depending
    on how you fill your database with usernames and messages:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.11: Expected output](img/B18621_15_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 15.11: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Activity15.02/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter15/Activity15.02/main.go).
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can tweak the script so that you don’t recreate the database
    on consecutive runs.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this activity, you should have learned how to create a new table
    called `Messages`, then take input from the user and search for related users
    and messages based on the input.
  prefs: []
  type: TYPE_NORMAL
- en: Adding users with GORM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve interacted with the database by writing some SQL queries directly.
    What we’ve done is create and run Go code, which was used to then run SQL code.
    This is perfectly fine, but there is also a way to run just Go code to interact
    with a SQL database. On top of this, the data that we are storing in the database
    will then be unwrapped into Go variables, and the content of a row might define
    the values of an instance of a Go struct. What we can do to improve and simplify
    the whole process is abstract the database even more and use an **object-relational
    mapper** (**ORM**). This is a library that matches the tables and their relations
    as Go structs so that you can insert and retrieve data the same way you would
    instantiate and delete any instance of a Go struct. An ORM is not generally part
    of a language, and Go does not provide one by itself. There is, however, a set
    of third-party libraries, one of which is the de facto ORM for Go, and this is
    GORM. You can find all the details of this package at [https://gorm.io/](https://gorm.io/),
    but we will briefly learn how to use it to add and search for data in our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use GORM, we must import it. Here’s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we do not have just one line but two. The first loads the GORM
    library, while the second specifies the driver to use. GORM can be used to interact
    with a lot of different database engines, including MySQL, Postgres, and SQLite.
    While the library itself is available from [gorm.io/gorm](http://gorm.io/gorm),
    the specific way to interact with the engine is handled by the driver – in this
    case, the Postgres driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step will be to define a schema – that is, a Go struct representing
    what’s inside a table. Let’s define a struct representing a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty straightforward – we define a struct called `User` and we add
    some fields that will hold the first and last name of a user, together with their
    email address. The first important thing, however, is that we embed the `gorm.Model`
    struct into our struct, making it effectively a GORM model. This struct will add
    some fields, such as an ID, and set it as a primary key, as well as some other
    fields, such as creation and update date, and will also add some methods that
    will be used by the library to make it interact with a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a struct defining a user, let’s see how we can insert a user
    into the database. To interact with the database, we must connect to it. Earlier,
    we saw how to connect to PostgreSQL; we will do something similar here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can use the same connection string as earlier, but we will
    do so inside the `gorm.Open` call, which allows GORM to interact with the underlying
    database engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we haven’t created a table for the users, and we’ve seen how to create
    one using SQL and call it via Go. With GORM, we do not need to do that. After
    defining the type that will go inside the table that will hold users, we can have
    GORM create that table for us, if it does not exist already. We can do this with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This call ensures that there is a table holding users that contains all the
    required columns, and by default will call it *users*. There are ways to change
    the name of the table, but in general, it is better to follow the conventions.
    So, a table holding users’ data will be called *users*, while a struct holding
    the details of a user will be called `User`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What remains now is just to add an actual user – we will call him John Smith
    and use `john.smith@gmail.com` as his email address. This is how we can instantiate
    the struct with his details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can insert it into the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is pretty straightforward and allows us to write just Go
    code and model our data as Go structs.
  prefs: []
  type: TYPE_NORMAL
- en: GORM has quite a few functionalities; in this section, we learned how to create
    structs and use them to match a schema in a database, as well as add data to a
    specific table. Now, let’s learn how to find users with GORM.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Users with GORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we’ve added users, we would like to retrieve them. Let’s add a few other
    users using what we learned in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Let’s assume that we had already inserted the record for John Smith. So, starting
    from a clean database and clean table, we should have users with IDs of 1, 2,
    and 3, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to retrieve details about the first user we inserted. We can do
    that with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return the first user matching the condition where the user’s ID
    is equal to 1\. The returned record is un-marshaled into the `user` variable,
    which is an instance of the `User` struct. We can search for every other user
    via their ID and substitute the number 1 with 2 or 3\. This, however, is not very
    interesting, as we might not know the user’s ID but only their name or surname.
    Let’s see how to retrieve John Doe from his surname:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we did not use “LastName” but `last_name` as GORM automatically transforms
    every attribute of the struct that’s camel case into snake case; this is the usual
    convention for database column names. The other important thing to notice is that
    we use two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The first one represents the column we want to search in, and we have a question
    mark after the equals sign. The question mark is a placeholder and will be replaced
    by the next parameter, which is *Doe*. As we have two people with the surname
    Smith, the function we just used will retrieve the first person with that surname,
    but this is not necessarily the one we are looking for. We could use the `Last`
    function, which returns the last result that matches the query, but we could have
    more users with the same surname. The solution for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a query that includes more conditions – the first few parameters
    express the condition, while the following parameters fill the values with placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: 'The issue we could face here is that we might get confused with the names of
    the struct’s attributes and the actual column names. If we need to do a simple
    matching query, we can substitute the previous code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, we just pass an instance of the `User` struct with a few attributes set,
    leaving the other ones to the default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'These examples allow us to search for a specific record, but often, we need
    a list of objects. Of course, the `First` and `Last` functions return only one
    item, but GORM also gives us a function to return all the records that match our
    criteria. If the criteria is simply an ID, or if the field we search for is unique,
    we are better off sticking with `First`, but if our criteria are not unique, we
    should use the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `Find` function returns all the matching records, but we cannot just un-marshal
    it into a single user instance. So, we must define a `users` variable, which is
    a slice of `User` instances, rather than using the previously seen `user`, which
    was an instance of a `User` struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us an idea of how to use GORM to insert and retrieve data, but we’ve
    forgotten one important thing: errors. These functions are contacting the database,
    but the queries might somehow error for several reasons, and we need to control
    that. The previously seen function does not return an error but a pointer to the
    database struct, which we can use to get the errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `tx` variable stands for *transaction* and returns a set of values
    with a potential error among them. We can check if there is an error by comparing
    the `tx.Error` value with `nil`. When we use a transaction, whatever we do to
    the database is not definitive; it does not affect the state of the database that’s
    accessed by any other client, so any change is temporary. To make any change effective,
    we need to commit the transaction. In this case, we are just returning results,
    and not modifying the database, so we do not need to commit. We are using the
    transactions because GORM returns a transaction from the `Find` call.
  prefs: []
  type: TYPE_NORMAL
- en: This gives us a starting point to use GORM to model and use data while storing
    it in a database.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter made you efficient in interacting with SQL databases. You learned
    how to create, delete, and manipulate database tables. You also become aware of
    all the different types of databases Go is suited to interact with. As this chapter
    was made with the PostgreSQL engine in mind, you should familiarize yourself with
    its Go module too.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you will now be able to step foot into the realm of database
    programming with the Go language and be self-sufficient in the sense that you
    know where to look for solutions to problems and extra knowledge. The most common
    use case for this knowledge is when you must build automated reporting apps that
    pull data from a database and report it as an email. The other use case is when
    you have an automated app for pushing data to the database server that processes
    a CSV file or an XML file. This depends on the situation you are in.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter also introduced you to the concept of ORM and has given you an
    introduction to the most famous ORM for the Go language: GORM.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to interact with web interfaces via
    HTTP clients, which is one of the most interesting topics in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 5: Building For The Web'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The modern world has been profoundly influenced by the Internet and the World
    Wide Web. Go, born in the internet age, was meticulously crafted to thrive in
    this digital landscape.
  prefs: []
  type: TYPE_NORMAL
- en: This section delves into the realm of web development with Go, empowering you
    to create robust and efficient web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section includes the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B18621_16.xhtml#_idTextAnchor1704), *Web Servers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 17*](B18621_17.xhtml#_idTextAnchor1790), *Using the Go HTTP Client*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
