<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer205">
			<p><a id="_idTextAnchor1703"/></p>
			<h1 id="_idParaDest-402" class="chapter-number"><a id="_idTextAnchor1704"/>16</h1>
			<h1 id="_idParaDest-403">Web Servers<a id="_idTextAnchor1705"/></h1>
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces you to different ways of creating an HTTP server to accept requests from the internet. You will be able to understand how a website can be accessed and how it can respond to a form. You will also learn how to respond to requests from another <span class="No-Break">software program.</span></p>
			<p class="callout">By the end of this chapter, you’ll be able to create an HTTP server that renders a simple message. You will also know how to create an HTTP server that renders complex data structures that serve local static files. Further, you know how to create an HTTP server that renders dynamic pages and works with different ways of routing. Finally, you will know how to create a REST service, accept data through a form, and accept <span class="No-Break">JSON data.</span></p>
			<h1 id="_idParaDest-404"><a id="_idTextAnchor1706"/>Technical requirements</h1>
			<p>To complete and run the examples in this chapter, you will need your favorite IDE and the latest version of the Go compiler. At the time of writing, this is 1.21. All the examples will use the standard Go library. You can refer to this book’s GitHub repository for the code in this <span class="No-Break">chapter: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter16"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter16</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-405"><a id="_idTextAnchor1707"/>Introduction<a id="_idTextAnchor1708"/></h1>
			<p>In this chapter, we will dig into how a remote server is created, so if you already know how to request information, you will see how to reply to <span class="No-Break">these requests.</span></p>
			<p>A web server is a program that uses the HTTP protocol – hence, the HTTP server – to accept requests from any HTTP client (web browser, another program, and so on) and respond to them with an appropriate message. When we browse the internet with our browser, it will be an HTTP server that will send an HTML page to our browser and we will be able to see it. In some other cases, a server will not return an HTML page but a different message that’s appropriate to <span class="No-Break">the client.</span></p>
			<p>Some HTTP servers provide an API that can be consumed by another program. Think of when you want to register with a website, and you are asked if you want to sign up through Facebook or Google. This means that the website you want to register with will consume a Google or Facebook API to get your details. These APIs generally respond with structured text, which is a piece of text representing a complex data structure. The way these servers expect the requests can be different. Some expect the same type of structured messages they return, while some provide what is called a REST API, which is quite strict with the HTTP methods that are used and expects inputs in the form of URL parameters or values, similar to the ones in a <span class="No-Break">web form.</span></p>
			<h1 id="_idParaDest-406"><a id="_idTextAnchor1709"/>How to build a basic <a id="_idTextAnchor1710"/>server</h1>
			<p>The simplest HTTP server that we can create is a Hello World server. This is a server that returns a simple message stating <strong class="source-inline">Hello World</strong> and will not do anything else. It is not very useful, but it is a starting <a id="_idIndexMarker1017"/>point to see what default Go packages give us and is the basis for any other more complex server. The aim is to have a server that runs on a specific port on your machine’s local host and accepts any path under it. Accepting any path means that when you test the server with your browser, it will always return the <strong class="source-inline">Hello World</strong> message and a status code of <strong class="source-inline">200</strong>. Of course, we could return any other message, but, for historical reasons, the simplest project you learn when you study programming is always some sort of software that returns a message stating <strong class="source-inline">Hello World</strong>. In this case, we will see how this can be done and then visualized in a normal browser, before perhaps being put on the internet and shared with billions of users, although users may, in practice, prefer a more useful server. Let’s say this is the most basic HTTP server you <span class="No-Break">can create.</span><a id="_idTextAnchor1711"/></p>
			<h1 id="_idParaDest-407">HTTP<a id="_idTextAnchor1712"/> handler</h1>
			<p>To react to an HTTP request, we need <a id="_idIndexMarker1018"/>to write something that, we usually say, handles the request; hence, we call this something a handler. In Go, we have several ways to do that, and one way is to implement the handler interface of the <strong class="source-inline">http</strong> package. This interface has one pretty self-explanatory method, and this is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
ServeHTTP(w http.ResponseWriter, r *http.Request)</pre>			<p>So, whenever we need to create a handler for HTTP requests, we can create a struct that includes this method <a id="_idIndexMarker1019"/>and we can use it to handle an HTTP request. Here’s <span class="No-Break">an example:</span></p>
			<pre class="source-code">
type MyHandler struct {}
func(h MyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {}</pre>			<p>This is a valid HTTP handler and you can use it <span class="No-Break">like so:</span></p>
			<pre class="source-code">
http.ListenAndServe(":8080", MyHandler{})</pre>			<p>Here, <strong class="source-inline">ListenAndServe()</strong> is a function that will use our handler to serve the requests; any struct that implements the handler interface will be fine. However, we need to let our server <span class="No-Break">do something.</span></p>
			<p>As you can see, the <strong class="source-inline">ServeHTTP</strong> method accepts <strong class="source-inline">ResponseWriter</strong> and a <strong class="source-inline">Request</strong> object. You can use them to capture parameters from the request and write messages to the response. The simplest thing, for example, is to let our server return <span class="No-Break">a message:</span></p>
			<pre class="source-code">
func(h MyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
  _, err := w.Write([]byte("HI"))
  if err != nil {
    log.Printf("an error occurred: %v\n", err)
    w.WriteHeader(http.StatusInternalServerError)
  }
}</pre>			<p>The <strong class="source-inline">ListenAndServe</strong> method might return an error. If this happens, we will want the execution of our program to halt. One common practice is to wrap this function call with a <span class="No-Break">fatal log:</span></p>
			<pre class="source-code">
log.Fatal(http.ListenAndServe(":8080", MyHandler{}))</pre>			<p>This will halt the execution and<a id="_idIndexMarker1020"/> print the error message that’s returned by the <span class="No-Break"><strong class="source-inline">ListenAndServe</strong></span><span class="No-Break"> functi<a id="_idTextAnchor1713"/>on.</span></p>
			<h2 id="_idParaDest-408">Exercise 16.01 – creating a Hello Wo<a id="_idTextAnchor1714"/>rld server</h2>
			<p>Let’s start by building a simple <strong class="source-inline">Hello World</strong> HTTP server based on what you learned in the <span class="No-Break">previous section.</span></p>
			<p>The first thing you need to do is<a id="_idIndexMarker1021"/> create a folder called <strong class="source-inline">hello-world-server</strong>. You can do this via the command line or you can create it with your favorite editor. Inside the folder, create a file called <strong class="source-inline">main.go</strong>. We will not use any external <span class="No-Break">library here:</span></p>
			<ol>
				<li>Add the package’s name, as <span class="No-Break">shown here:</span><pre class="source-code">
package main</pre><p class="list-inset">This tells the compiler that this file is an entry point for a program that can <span class="No-Break">be executed.</span></p></li>				<li>Import the <span class="No-Break">necessary packages:</span><pre class="source-code">
import (
  "log"
  "net/http"
)</pre></li>				<li>Now, create <strong class="source-inline">handler</strong>, the struct that will handle <span class="No-Break">the requests:</span><pre class="source-code">
type hello struct{}
func(h hello) ServeHTTP(w http.ResponseWriter, r *http.Request) {
  msg := "&lt;h1&gt;Hello World&lt;/h1&gt;"
  w.Write([]byte(msg))
}</pre></li>				<li>Now that we have our handler, create the <strong class="source-inline">main()</strong> function. This will start the server and produce a web page<a id="_idIndexMarker1022"/> with <span class="No-Break">our message:</span><pre class="source-code">
func main() {
  log.Fatal(http.ListenAndServe(":8080", hello{}))
}</pre><p class="list-inset">The entire file should look <span class="No-Break">like this:</span></p><pre class="source-code">package main
import (
  "log"
  "net/http"
)
type hello struct{}
func(h hello) ServeHTTP(w http.ResponseWriter, r *http.Request) {
  msg := "&lt;h1&gt;Hello World&lt;/h1&gt;"
  w.Write([]byte(msg))
}
func main() {
  log.Fatal(http.ListenAndServe(":8080", hell<a id="_idTextAnchor1715"/>o{}))
}</pre></li>				<li>Now, go to your Terminal, inside your <strong class="source-inline">hello-world-server</strong> folder, and type in the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker1023"/></span><span class="No-Break">command:</span><pre class="source-code">
go run .</pre><p class="list-inset">You shouldn’t see anything; the program <span class="No-Break">has started.</span></p></li>				<li>Now, open your browser at the <span class="No-Break">following address:</span><pre class="source-code">
http://localhost:8080</pre><p class="list-inset">You should see a page<a id="_idIndexMarker1024"/> with a <span class="No-Break">big mes<a id="_idTextAnchor1716"/>sage:</span></p></li>			</ol>
			<div>
				<div id="_idContainer175" class="IMG---Figure">
					<img src="image/B18621_16_01.jpg" alt="Figure 16.1: Hello World server" width="1361" height="169"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.1: Hello World server</p>
			<p class="list-inset">Now, if you try to change path and go to <strong class="source-inline">/page1</strong>, you will see the <span class="No-Break">following mess<a id="_idTextAnchor1717"/>age:</span></p>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="image/B18621_16_02.jpg" alt="Figure 16.2: Hello World server sub-pages" width="1426" height="166"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.2: Hello World server sub-pages</p>
			<p>Congratulations! This is your first <span class="No-Break">HTTP server.</span></p>
			<p>In this exercise, we created a basic Hello World server that returns a message stating <strong class="source-inline">Hello World</strong> in response to any request on <span class="No-Break">any sub-add<a id="_idTextAnchor1718"/>ress.</span></p>
			<h1 id="_idParaDest-409">S<a id="_idTextAnchor1719"/>imple routing</h1>
			<p>The server we built in the previous exercise doesn’t do much – it just responds with a message; we cannot ask anything else. Before <a id="_idIndexMarker1025"/>we can make our server more dynamic, let’s imagine we want to create an online book and we want to be able to select a chapter just by changing the URL. At the moment, if we browse the following pages, we’ll always see the <span class="No-Break">same message:</span></p>
			<pre class="source-code">
http://localhost:8080
http://localhost:8080/hello
http://localhost:8080/chapter1</pre>			<p>Now, we want to associate different messages with these different paths on our server. We will do this by introducing some simple routing to <span class="No-Break">our server.</span></p>
			<p>A path is what you see after <strong class="source-inline">8080</strong> in the URL, where <strong class="source-inline">8080</strong> is the port number we chose to run the server on. This path can be one number, a word, a set of numbers, or character groups separated by a <strong class="source-inline">/</strong>. To do this, we will use another function of the <span class="No-Break"><strong class="source-inline">net/http</strong></span><span class="No-Break"> package:</span></p>
			<pre class="source-code">
HandleFunc(pattern string, handler func(ResponseWriter, *Request))</pre>			<p>Here, the pattern is the path we want to be served by the <strong class="source-inline">handler</strong> function. Note how the <strong class="source-inline">handler</strong> function signature has the same parameters as the <strong class="source-inline">ServeHTTP</strong> method, which you added to the <strong class="source-inline">hello</strong> struct in the <span class="No-Break">previous exercise.</span></p>
			<p>As an example, the server we built in <em class="italic">Exercise 16.01</em> is not very useful, but we can transform it into something much more useful with the addition of pages other than the <strong class="source-inline">Hello World</strong> one. To do so, we need to do some basic routing. The aim here is to write a book, and the book must have a welcome page that contains a title and a first chapter. The book title is <strong class="source-inline">Hello World</strong>, so we can keep what we did before. The first chapter will have a heading stating <a href="B18621_01.xhtml#_idTextAnchor021"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>. The book is a work in progress, so it doesn’t matter that the content is still poor; what we require is the ability to select the chapter; we will add the <span class="No-Break">content <a id="_idTextAnchor1720"/>later.</span></p>
			<h2 id="_idParaDest-410">Exercise 16.02 – routi<a id="_idTextAnchor1721"/>ng our server</h2>
			<p>We are going to modify the <a id="_idIndexMarker1026"/>code in <em class="italic">Exercise 16.01</em> so that it supports different paths. If you haven’t gone through the previous exercise, do so now so that you have a basic framework for <span class="No-Break">this exercise:</span></p>
			<ol>
				<li>Create a new folder and a <strong class="source-inline">main.go</strong> file, and add the code from the previous exercise to the definition of the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function:</span><pre class="source-code">
package main
import (
  "log"
  "net/http"
)
type hello struct{}
  func(h hello) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    msg := "&lt;h1&gt;Hello World&lt;/h1"
    w.Write([]byte(msg))
}</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">main()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Then, use <strong class="source-inline">handle</strong> to<a id="_idIndexMarker1027"/> route <strong class="source-inline">/chapter1</strong> through a <span class="No-Break"><strong class="source-inline">handlefunc()</strong></span><span class="No-Break"> function:</span><pre class="source-code">
  http.HandleFunc("/chapter1", func(w http.ResponseWriter, r *http.Request) {
    msg := "Chapter 1"
    w.Write([]byte(msg))
})</pre><p class="list-inset">This means that we associate the path, <strong class="source-inline">/chapter1</strong>, with a function that returns a <span class="No-Break">specific message.</span></p></li>				<li>Finally, set the server so that it listens to a port; then, run the <span class="No-Break">following command:</span><pre class="source-code">
    log.Fatal(http.ListenAndServe(":8080", hello{}))
}</pre></li>				<li>Now, save your file and run the server again with the <span class="No-Break">following command:</span><pre class="source-code">
go run .</pre></li>				<li>Then, go to your browser and load the <span class="No-Break">following URLs:</span><ul><li><span class="No-Break"><strong class="source-inline">http://localhost:8080</strong></span></li><li><span class="No-Break"><strong class="source-inline">http://localhost:8080/chapter1</strong></span><ul><li>The output for the <a id="_idIndexMarker1028"/>home page is shown in the <span class="No-Break">following scre<a id="_idTextAnchor1722"/>enshot:</span></li></ul></li></ul></li>
			</ol>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="image/B18621_16_03.jpg" alt="Figure 16.3: Multi-page server – home page" width="1323" height="165"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.3: Multi-page server – home page</p>
			<p>The output for <strong class="source-inline">page 1</strong> is shown in the <span class="No-Break">following scree<a id="_idTextAnchor1723"/>nshot:</span></p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/B18621_16_04.jpg" alt="Figure 16.4: Multi-page server – page 1" width="1383" height="170"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.4: Multi-page server – page 1</p>
			<p>Note that they both still display the same message. This happens because we are setting <strong class="source-inline">hello</strong> as the handler for our server, and this overrides our specific path. We can modify our code so that it looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
func main() {
  http.HandleFunc("/chapter1", func(w http.ResponseWriter, r *http.Request) {
    msg := "&lt;h1&gt;Chapter 1&lt;/h1&gt;"
    w.Write([]byte(msg))
})
    http.Handle("/", hello{})
    log.Fatal(http.ListenAndServe(":8080", nil))
}</pre>			<p>Here, we removed the <strong class="source-inline">hello</strong> handler so that it’s no longer the main handler for our server and we associated this<a id="_idIndexMarker1029"/> handler with the main <strong class="source-inline">/</strong> <span class="No-Break">path:</span></p>
			<pre class="source-code">
http.Handle("/", hello{})</pre>			<p>Then, we associated a <strong class="source-inline">handler</strong> function with the specific <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">chapter1</strong></span><span class="No-Break"> path:</span></p>
			<pre class="source-code">
  http.HandleFunc("/chapter1", func(w http.ResponseWriter, r *http.Request) {
    msg := "Chapter 1"
    w.Write([]byte(msg))
})</pre>			<p>Now, if we stop and then run our server again, we will see that the <strong class="source-inline">/chapter1</strong> path now returns the <span class="No-Break">new me<a id="_idTextAnchor1724"/>ssage:</span></p>
			<div>
				<div id="_idContainer179" class="IMG---Figure">
					<img src="image/B18621_16_05.jpg" alt="Figure 16.5: Multi-page server repeated – chapter 1" width="1374" height="180"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.5: Multi-page server repeated – chapter 1</p>
			<p>In the meantime, all the other paths return the old <strong class="bold">Hello </strong><span class="No-Break"><strong class="bold">World</strong></span><span class="No-Break"> mes<a id="_idTextAnchor1725"/>sage:</span></p>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="image/B18621_16_06.jpg" alt="Figure 16.6: Multi-page server – base page" width="1292" height="162"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.6: Multi-page server – base page</p>
			<p>The default page for the server is <a id="_idIndexMarker1030"/>also displayed for <span class="No-Break">another r<a id="_idTextAnchor1726"/>oute:</span></p>
			<div>
				<div id="_idContainer181" class="IMG---Figure">
					<img src="image/B18621_16_07.jpg" alt="Figure 16.7: The page that is not set returns the default setting" width="1390" height="174"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.7: The page that is not set returns the default setting</p>
			<p>With that, we made a basic Hello World web server with specific routes for different pages. During the process, we used several functions from the go <strong class="source-inline">http</strong> package, some of which are used to achieve the same result. We will see why there are multiple ways to do the same thing and why we need all of <span class="No-Break">them sh<a id="_idTextAnchor1727"/>ortly.</span></p>
			<h1 id="_idParaDest-411">Handler versus h<a id="_idTextAnchor1728"/>andler function</h1>
			<p>As you may have noticed, we used two different functions before, <strong class="source-inline">http.Handle</strong> and <strong class="source-inline">http.HandleFunc</strong>, both of which have <a id="_idIndexMarker1031"/>a path as their first parameter, but which differ in terms of the second parameter. These two functions both ensure that a specific <a id="_idIndexMarker1032"/>path is handled by a function. <strong class="source-inline">http.Handle</strong>, however, expects <strong class="source-inline">http.Handler</strong> to handle the path, while <strong class="source-inline">http.HandleFunc</strong> expects a function to do <span class="No-Break">the same.</span></p>
			<p>As we’ve seen before, <strong class="source-inline">http.Handler</strong> is any struct that has a method with <span class="No-Break">this signature:</span></p>
			<pre class="source-code">
ServeHTTP(w http.ResponseWriter, r *http.Request)</pre>			<p>So, in both cases, there will always be a function with <strong class="source-inline">http.ResponseWriter</strong> and <strong class="source-inline">*http.Request</strong> as parameters that will handle the path. When one or the other might be chosen may just be a matter of personal preference in many cases, but it might be important – when creating a complex project, for example – to choose the right method. Doing so will ensure that the structure of the project is optimal. Different routes may appear better organized if they’re handled by handlers that belong to different packages, or might have to perform very few actions, as in our previous case; and a simple function might prove to<a id="_idIndexMarker1033"/> be the <span class="No-Break">ideal choice.</span></p>
			<p>In general, for simple projects <a id="_idIndexMarker1034"/>where you have a handful of simple pages, you may opt for <strong class="source-inline">HandleFunc</strong>. For example, let’s say you want to have static pages and there is no complex behavior on each page. In this case, it would be overkill to use an empty struct just for returning static text. The handler is more appropriate whenever you need to set some parameters, or if you want to keep track of something. As a general rule, let’s say that if you have a counter, <strong class="source-inline">Handler</strong> is the best choice because you can initialize a struct with a count of 0 and then increment it, but we will see this in <span class="No-Break"><em class="italic">Activity 16.<a id="_idTextAnchor1729"/>01</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-412">Activity 16.01 – adding a page counter <a id="_idTextAnchor1730"/>to an HTML page</h2>
			<p>Imagine that you own a website with, say, three pages, where you are writing your book. You earn money based on how many visits <a id="_idIndexMarker1035"/>your website receives. To understand how popular your website is, and how much money you are earning, you need to keep track of <span class="No-Break">the visits.</span></p>
			<p>In this activity, you will build an HTTP server with three pages that contain some content, and display, on each page, how many visits that page has had so far. You will use the <strong class="source-inline">http.Handler</strong> method, which, in this case, will help you generalize <span class="No-Break">your counter.</span></p>
			<p>To display the dynamic value, you can use the <strong class="source-inline">fmt.Sprintf</strong> function in the <strong class="source-inline">fmt</strong> package, which prints and formats a message to a string. With this function, you can build a string containing characters and numbers. You can find more information about this method online in the <span class="No-Break">Go documentation.</span></p>
			<p>You will use everything you’ve learned so far, including how a struct is instantiated, how to set the attributes of a struct, pointers, how to increase an integer, and, of course, everything you’ve learned about HTTP servers <span class="No-Break">so far.</span></p>
			<p>Observing the following steps will provide an elegant and <span class="No-Break">effective solution:</span></p>
			<ol>
				<li>Create a folder <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">page-counter</strong></span><span class="No-Break">.</span></li>
				<li>Create a file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></li>
				<li>Add the necessary imports to the <strong class="source-inline">http</strong> and <span class="No-Break"><strong class="source-inline">fmt</strong></span><span class="No-Break"> packages.</span></li>
				<li>Define a struct called <strong class="source-inline">PageWithCounter</strong> with <strong class="source-inline">counter</strong> as an integer attribute, <strong class="source-inline">content</strong>, and <strong class="source-inline">heading</strong> as a <span class="No-Break">text attribute.</span></li>
				<li>Add a <strong class="source-inline">ServeHTTP</strong> method to the struct that’s capable of displaying the content, the heading, and <a id="_idIndexMarker1036"/>a message with the total number <span class="No-Break">of views.</span></li>
				<li>Create your <strong class="source-inline">main</strong> function and, inside, implement <span class="No-Break">the following:</span><ul><li>Instantiate three handlers of the <strong class="source-inline">PageWithCounter</strong> type, with <strong class="source-inline">Hello World</strong>, <strong class="source-inline">Chapter 1</strong>, and <strong class="source-inline">Chapter 2</strong> headings and <span class="No-Break">some content.</span></li><li>Add the three handlers to the <strong class="source-inline">/</strong>, <strong class="source-inline">/chapter1</strong>, and <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">chapter2</strong></span><span class="No-Break"> routes.</span></li></ul></li>
				<li>Run the server on <span class="No-Break">port <a id="_idTextAnchor1731"/></span><span class="No-Break"><strong class="source-inline">8080</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>When you run the server, you should see <span class="No-Break">the <a id="_idTextAnchor1732"/>following:</span></p>
			<div>
				<div id="_idContainer182" class="IMG---Figure">
					<img src="image/B18621_16_08.jpg" alt="Figure 16.8: Output in the browser when you run the server for the first time" width="1175" height="261"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.8: Output in the browser when you run the server for the first time</p>
			<p>If you refresh the page, you should see <span class="No-Break">the f<a id="_idTextAnchor1733"/>ollowing:</span></p>
			<div>
				<div id="_idContainer183" class="IMG---Figure">
					<img src="image/B18621_16_09.jpg" alt="Figure 16.9: Output in the browser when you run the server for the second time" width="1445" height="312"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.9: Output in the browser when you run the server for the second time</p>
			<p>Next, navigate to <strong class="source-inline">chapter1</strong> by typing <strong class="source-inline">localhost:8080/chapter1</strong> in the address bar. You should be able to see <a id="_idIndexMarker1037"/>something along the lines of <span class="No-Break">the f<a id="_idTextAnchor1734"/>ollowing:</span></p>
			<div>
				<div id="_idContainer184" class="IMG---Figure">
					<img src="image/B18621_16_10.jpg" alt="Figure 16.10: Output in the browser when you visit the chapter1 page for the first time" width="1375" height="315"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.10: Output in the browser when you visit the chapter1 page for the first time</p>
			<p>Similarly, navigate to <strong class="source-inline">chapter2</strong>; you should be able to see the following increment in terms of the number <span class="No-Break">o<a id="_idTextAnchor1735"/>f views:</span></p>
			<div>
				<div id="_idContainer185" class="IMG---Figure">
					<img src="image/B18621_16_11.jpg" alt="Figure 16.11: Output in the browser when you visit the chapter2 page for the first time" width="1412" height="316"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.11: Output in the browser when you visit the chapter2 page for the first time</p>
			<p>When you revisit <strong class="source-inline">chapter1</strong>, you should see an increase in the number of views, <span class="No-Break">as f<a id="_idTextAnchor1736"/>ollows:</span></p>
			<div>
				<div id="_idContainer186" class="IMG---Figure">
					<img src="image/B18621_16_12.jpg" alt="Figure 16.12: Output in the browser when you visit the chapter1 page for the second time" width="1205" height="255"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.12: Output in the browser when you visit the chapter1 page for the second time</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found in this book’s GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter16/Activity16.01/main.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter16/Activity16.01/main.go</span></a><span class="No-Break">.</span></p>
			<p>In this activity, you learned how to create a server that responds to different requests on different pages with a specific <a id="_idIndexMarker1038"/>static text, along with a counter on each page, with each counter independent from <span class="No-Break">the others.</span></p>
			<h1 id="_idParaDest-413"><a id="_idTextAnchor1737"/>Adding middleware</h1>
			<p>Sometimes, you will need to create a lot of functions to handle HTTP requests, maybe serving different paths in a URL, all performing different actions. You might need to create a function to handle a server<a id="_idIndexMarker1039"/> returning a list of users, one with a list of projects, a route for updating some details, and all the functions doing different things. It might happen, however, that although these functions perform different actions, they will also have something in common. A common example is when these functions have to be performed on a secured environment, which means only for users that have been logged in. Let’s look at a very simple example and consider the following <span class="No-Break">two functions:</span></p>
			<pre class="source-code">
http.HandleFunc(
  "/hello1",
  func(w http.ResponseWriter,
  r *http.Request,
){
  msg := "Hello there, this is function 1"
  w.Write([]byte(msg))
})
http.HandleFunc(
  "/hello2",
  func(w http.ResponseWriter,
  r *http.Request,
){
  msg := "Hello there, and now we are in function 2"
  w.Write([]<a id="_idTextAnchor1738"/>byte(msg))
})</pre>			<p>Both functions will display a sentence that starts with <strong class="source-inline">Hello there,</strong>. Let’s find a way to extract this part of the behavior<a id="_idIndexMarker1040"/> of these functions and create a third function that will be used to perform the act of writing the initial <span class="No-Break">cheering message:</span></p>
			<pre class="source-code">
func Hello(next http.HandlerFunc) http.HandlerFunc {
  return func(w http.ResponseWriter, r *http.Request) {
    msg := "Hello there,"
    w.Write([]byte(msg))
    next.ServeHTTP(w, r)
  }
}</pre>			<p>This function has the <span class="No-Break">following signature:</span></p>
			<pre class="source-code">
func Hello(next http.HandlerFunc) http.HandlerFunc</pre>			<p>This means it is called <strong class="source-inline">Hello</strong>, accepts <strong class="source-inline">http.HandlerFunc</strong> as a parameter, and returns a result against <strong class="source-inline">http.HandlerFunc</strong>. This parameter is called <strong class="source-inline">next</strong> because it is the function that we will want to run next. Let’s look at the body of <span class="No-Break">the function:</span></p>
			<pre class="source-code">
  return func(w http.ResponseWriter, r *http.Request) {
    msg := "Hello there,"
    w.Write([]byte(msg))
    next.ServeHTTP(w, r)
  }</pre>			<p>As you can see, it returns a function that implements the <strong class="source-inline">http.HandlerFunc</strong> type and has the correct arguments and return type. This function will write a message stating <strong class="source-inline">Hello there,</strong> to the<a id="_idIndexMarker1041"/> response writer, <strong class="source-inline">w</strong>, and then call the <strong class="source-inline">next</strong> function with the same response writer and request that the function without a <span class="No-Break">name receives.</span></p>
			<p>Now, let’s refactor our code to make it a bit easier to read. We’ll create two functions for the actions we want <span class="No-Break">to perform:</span></p>
			<pre class="source-code">
func Function1(w http.ResponseWriter,
  r *http.Request,
) {
  msg := " this is function 1"
  w.Write([]byte(msg))
}
func Function2(w http.ResponseWriter,
  r *http.Request,
) {
  msg := " and now we are in function 2"
  w.Write([]byte(msg))
}</pre>			<p>Let’s see what our file<a id="_idIndexMarker1042"/> looks like <span class="No-Break">so far:</span></p>
			<pre class="source-code">
package main
import (
  "log"
  "net/http"
)
func Hello(next http.HandlerFunc) http.HandlerFunc {
  return func(w http.ResponseWriter, r *http.Request) {
    msg := "Hello there,"
    w.Write([]byte(msg))
    next.ServeHTTP(w, r)
  }
}
func Function1(w http.ResponseWriter,
  r *http.Request,
) {
  msg := " this is function 1"
  w.Write([]byte(msg))
}
func Function2(w http.ResponseWriter,
  r *http.Request,
) {
  msg := " and now we are in function 2"
  w.Write([]byte(msg))
}</pre>			<p>As you can see, we have our <strong class="source-inline">Hello</strong> function and two functions returning two different sentences to the response <a id="_idIndexMarker1043"/>writer. The last step is to associate these functions with a path, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
func main() {
  http.HandleFunc(
    "/hello1", Function1)
  http.HandleFunc(
    "/hello2", Function2)
  log.Fatal(http.ListenAndServe(":8085", nil))
}</pre>			<p>As you can see, we pass functions 1 and 2 to each route. If you run the code on your machine and go to <strong class="source-inline">http://localhost:8085/hello1</strong>, you will see a message stating <strong class="source-inline">this is function 1</strong>. What we have not used yet, though, is the <strong class="source-inline">Hello</strong> function. Let’s rewrite the last block of code and make use <span class="No-Break">of it:</span></p>
			<pre class="source-code">
func main() {
  http.HandleFunc(
    "/hello1", Hello(Function1))
  http.HandleFunc(
    "/hello2", Hello(Function2))
  log.Fatal(http.ListenAndServe(":8085", nil))
}</pre>			<p>If you run this program again, you will see that the message has now changed to <strong class="source-inline">Hello there, this is function 1</strong>. The <strong class="source-inline">Hello</strong> function is essentially running before the <strong class="source-inline">Function1</strong> function and after doing its own work, it calls <strong class="source-inline">Function</strong> so that that function can also do its job. We call the <strong class="source-inline">Hello</strong> function <strong class="source-inline">Middleware</strong> as it acts as the man in the middle – it captures<a id="_idIndexMarker1044"/> the request, does some work, and then calls the next function in line. By doing this, it is possible to chain many middleware by doing something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Hello(Middleware2(Middleware3((Function2)))</pre>			<p>You can use this pattern to perform many common actions before or after the actual function that needs to be associated with a p<a id="_idTextAnchor1739"/>ath on <span class="No-Break">t<a id="_idTextAnchor1740"/>he URL.</span></p>
			<h1 id="_idParaDest-414"><a id="_idTextAnchor1741"/>Dynamic content</h1>
			<p>A server that serves only static content is<a id="_idIndexMarker1045"/> useful, but there is much more that can be done. An HTTP server can deliver content based on a more granular request, which is done by passing some parameters to the server. There are many ways to do so, but one simple way is to pass parameters to <strong class="source-inline">querystring</strong>. If the URL of the server is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
http://localhost:8080</pre>			<p>Then, we can add something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
http://localhost:8080?name=john</pre>			<p>Here,<strong class="source-inline">?name=john</strong> is called a <strong class="source-inline">querystring</strong> string as it is a string representing a query. In this case, <strong class="source-inline">querystring</strong> sets a variable called <strong class="source-inline">name</strong> with a value of <strong class="source-inline">john</strong>. This way of passing parameters is generally used with <strong class="source-inline">GET</strong> requests, while a <strong class="source-inline">POST</strong> request will generally make use of the body of the request to send parameters. We will begin by looking at how to accept parameters for a <strong class="source-inline">GET</strong> request since this request is made by simply opening our browser on a specific address. We will see how to handle a <strong class="source-inline">POST</strong> request through a <span class="No-Break">form later.</span></p>
			<p>In the next exercise, you will learn how to return different texts as responses to HTTP requests, where the text depends <a id="_idIndexMarker1046"/>on what values the user puts in the <strong class="source-inline">querystring</strong> string in<a id="_idTextAnchor1742"/> the <span class="No-Break">address bar.</span></p>
			<h2 id="_idParaDest-415">Exercise 16.<a id="_idTextAnchor1743"/>03 – personalized welcome</h2>
			<p>In this exercise, we will create an HTTP server that can cheer us, but instead of a general <strong class="source-inline">hello world</strong> message, we will provide a <a id="_idIndexMarker1047"/>message depending on our name. The idea is that, by opening the browser on the server’s URL and adding a parameter called <strong class="source-inline">name</strong>, the server will welcome us with a message stating <strong class="source-inline">hello</strong>, followed by the value of the <strong class="source-inline">name</strong> parameter. The server is very simple and does not have sub-pages, but contains a dynamic element that constitutes a starting point for more <span class="No-Break">complex situations:</span></p>
			<ol>
				<li>Create a new folder called <strong class="source-inline">personalised-welcome</strong> and, inside the folder, create a file called <strong class="source-inline">main.go</strong>. Inside the file, add the <span class="No-Break">package name:</span><pre class="source-code">
package main</pre></li>				<li>Then, add the <span class="No-Break">required imports:</span><pre class="source-code">
import (
  "fmt"
  "log"
  "net/http"
  "strings"
)</pre></li>				<li>These are the same imports we used in the previous exercises and activities, so there is nothing new. We will not use handlers in this exercise as it is much smaller, but we will make use of the <span class="No-Break"><strong class="source-inline">http.handleFunc</strong></span><span class="No-Break"> function.</span></li>
				<li>Now, add the following code after <span class="No-Break">the imports:</span><pre class="source-code">
func Hello(w http.ResponseWriter, r *http.Request) {</pre></li>				<li>This is the definition of a function that can be used as a handling function for an <span class="No-Break">HTTP path.</span></li>
				<li>Now, save the query to a variable using the <strong class="source-inline">Query</strong> method URL from <span class="No-Break">the request:</span><pre class="source-code">
  vl := r.URL.Query()</pre></li>				<li>The <strong class="source-inline">Query</strong> method on the <strong class="source-inline">URL</strong> object of the request returns a <strong class="source-inline">map[string][]string</strong> string with all the parameters sent through <strong class="source-inline">querystring</strong> in the URL. We<a id="_idIndexMarker1048"/> then assign this map to a <span class="No-Break">variable, </span><span class="No-Break"><strong class="source-inline">vl</strong></span><span class="No-Break">.</span></li>
				<li>At this point, we need to get the value of a specific parameter called <strong class="source-inline">name</strong>, so we get the value from the <span class="No-Break"><strong class="source-inline">name</strong></span><span class="No-Break"> parameter:</span><pre class="source-code">
  name, ok := vl["name"]</pre></li>				<li>As you can see, we have an assignment to two variables, but only one value comes from <strong class="source-inline">vl["name"]</strong>. The second variable, <strong class="source-inline">ok</strong>, is a Boolean that tells us whether the <strong class="source-inline">name</strong> <span class="No-Break">key exists.</span></li>
				<li>If the <strong class="source-inline">name</strong> parameter has not been passed and we want an error message to appear, we must add it if the variable is not found – in other words, if the <strong class="source-inline">ok</strong> variable <span class="No-Break">is false:</span><pre class="source-code">
  if !ok {
    w.WriteHeader(400)
    w.Write([]byte("Missing name"))
    return
  }</pre></li>				<li>The conditional code gets called if the key does not exist in the slice, and it writes a <strong class="source-inline">400</strong> code (bad request) to the header, as well as a message to the response writer stating that the name has not been sent as a parameter. We stop the execution with a <strong class="source-inline">return</strong> statement to prevent <span class="No-Break">further actions.</span></li>
				<li>At this point, write a valid message to the <span class="No-Break">response writer:</span><pre class="source-code">
  w.Write([]byte(fmt.Sprintf("Hello %s", strings.Join(name, ","))))
}</pre></li>				<li>This code formats a string and injects the name into it. The <strong class="source-inline">fmt.Sprintf</strong> function is used to format, while <strong class="source-inline">strings.Join</strong> is used to transform the <strong class="source-inline">name</strong> slice into a string. Notice <a id="_idIndexMarker1049"/>that the <strong class="source-inline">name</strong> variable is set to the value of <strong class="source-inline">vl["name"]</strong>, but <strong class="source-inline">vl</strong> is a <strong class="source-inline">map[string][]string</strong> string, which means that it is a map with string keys whose values are slices of strings; hence, <strong class="source-inline">vl["name"]</strong> is a slice of strings and needs to be transformed into a single string. The <strong class="source-inline">strings.Join</strong> function takes all the elements of the slice and builds a single string using <strong class="source-inline">","</strong> as a separator. Other characters could have also been used <span class="No-Break">as separators.</span></li>
				<li>The last part of the file you have to write is <span class="No-Break">as follows:</span><pre class="source-code">
func main() {
  http.HandleFunc("/", Hello)
  log.Fatal(http.ListenAndServe(":8080", nil))
}</pre></li>				<li>As always, a <strong class="source-inline">main()</strong> function is created, and then the <strong class="source-inline">Hello</strong> function is associated with the <strong class="source-inline">"/"</strong> path and the server is started. Here is the output of three different URLs – two valid ones, and one with a <a id="_idTextAnchor1744"/><span class="No-Break">missing parameter:</span></li>
			</ol>
			<div>
				<div id="_idContainer187" class="IMG---Figure">
					<img src="image/B18621_16_13.jpg" alt="Figure 16.13: The server’s output when requesting the page with the name John" width="1424" height="138"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.13: The server’s output when requesting the page with the name John</p>
			<p class="list-inset">The preceding figure shows the output when we set the query parameter in the URL to the name John. If we<a id="_idIndexMarker1050"/> change the name in the query parameter in the URL, we will <a id="_idTextAnchor1745"/>see the <span class="No-Break">new value:</span></p>
			<div>
				<div id="_idContainer188" class="IMG---Figure">
					<img src="image/B18621_16_14.jpg" alt="Figure 16.14: The server’s output when requesting the page with the name Will" width="1458" height="139"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.14: The server’s output when requesting the page with the name Will</p>
			<p class="list-inset"> If we do not set the query parameter, we will receive an error messag<a id="_idTextAnchor1746"/>e, as <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer189" class="IMG---Figure">
					<img src="image/B18621_16_15.jpg" alt="Figure 16.15: The server outputting an error message when requesting a page without a name" width="1414" height="142"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.15: The server outputting an error message when requesting a page without a name</p>
			<p>Next, we’ll explore the con<a id="_idTextAnchor1747"/>cept <span class="No-Break">of te<a id="_idTextAnchor1748"/>mplates.</span></p>
			<h1 id="_idParaDest-416"><a id="_idTextAnchor1749"/>Templating</h1>
			<p>Although JSON can be the best choice when complex data structures have to be shared across software programs, in general, this is not the case when the HTTP server is supposed to be consumed by humans. In the <a id="_idIndexMarker1051"/>previous exercises and activities, the chosen way to format a piece of text has been the <strong class="source-inline">fmt.Sprintf</strong> function, which is good for formatting texts, but is simply insufficient when more dynamic and complex text is required. As you will have noticed in the previous exercise, the message that was returned in case a name was passed as a parameter to the URL observed a specific pattern, and this is where a new concept comes in – the template. A template is a skeleton from which complex entities can be developed. Essentially, a template is like text with some blanks. A template engine will take some values and fill in the blanks, as shown in the <span class="No-Break">f<a id="_idTextAnchor1750"/>ollowing diagram:</span></p>
			<div>
				<div id="_idContainer190" class="IMG---Figure">
					<img src="image/B18621_16_16.jpg" alt="Figure 16.16: Templating example" width="1157" height="194"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.16: Templating example</p>
			<p>As you can see, <strong class="source-inline">{{name}}</strong> is a placeholder, and, when a value is passed through to the engine, the placeholder is modified with <span class="No-Break">that value.</span></p>
			<p>We see templates everywhere. We have templates for Word documents, where we just fill in what is missing to produce new documents that all differ from one another. A teacher might have some templates<a id="_idIndexMarker1052"/> for their lessons and will develop different lessons from that same template. Go provides two different templating packages – one for text and one for HTML. As we are working with HTTP servers and we want to produce a web page, we will use the HTML templating package, but the interface is the same for the text template library. Although the templating packages are good enough for any real-world application, several other external packages can be used to improve performance. One of these is the <strong class="source-inline">hero</strong> template engine, which is much faster than the standard Go <span class="No-Break">templating package.</span></p>
			<p>The Go templating package provides a placeholder language where we can use things such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
{{name}}</pre>			<p>This is a simple code block that will make the template engine replace the <strong class="source-inline">name</strong> variable with a provided value, but more complex situations can be handled <span class="No-Break">via conditionals:</span></p>
			<pre class="source-code">
{{if age}} Hello {{else}} bye {{end}}</pre>			<p>Here, if an <strong class="source-inline">age</strong> parameter is not null, the template will contain <strong class="source-inline">Hello</strong>; otherwise, it will contain <strong class="source-inline">bye</strong>. Each conditional needs an <strong class="source-inline">{{end}}</strong> placeholder to determine <span class="No-Break">its ending.</span></p>
			<p>Variables in a template, however, do not need to be simple numbers or strings; they can be objects. In this case, if we have a struct with a field called <strong class="source-inline">ID</strong>, we can reference this field in the template <span class="No-Break">like so:</span></p>
			<pre class="source-code">
{{.ID}}</pre>			<p>This is very handy as we can pass a struct to the template instead of many <span class="No-Break">single parameters.</span></p>
			<p>In the next exercise, you will learn<a id="_idIndexMarker1053"/> how to use the basic templating functionalities of Go to create pages with custom messages, as you’ve done before, but just in<a id="_idTextAnchor1751"/> a more <span class="No-Break">elegant way.</span></p>
			<h2 id="_idParaDest-417">Exercise 16<a id="_idTextAnchor1752"/>.04 – templating our pages</h2>
			<p>This exercise aims to have you build a <a id="_idIndexMarker1054"/>more structured web page, use a template, and fill it with parameters from the URL’s <strong class="source-inline">querystring</strong>. In this scenario, we want to display basic information for a customer and hide some information when the data is missing. A customer has <strong class="source-inline">id</strong>, <strong class="source-inline">name</strong>, <strong class="source-inline">surname</strong>, and <strong class="source-inline">age</strong> values, and if any of these values are missing, they will not be displayed. Unless the data is the <strong class="source-inline">id</strong> value, as in this case, an error message will <span class="No-Break">be displayed:</span></p>
			<ol>
				<li>Begin by creating a <strong class="source-inline">server-template</strong> folder that contains a <strong class="source-inline">main.go</strong> file. Then, add the usual package and <span class="No-Break">some imports:</span><pre class="source-code">
package main
import (
  "html/template"
  "log"
  "net/http"
  "strconv"
  "strings"
)</pre></li>				<li>Here, we use two new imports: <strong class="source-inline">html/template</strong> for our templating and <strong class="source-inline">strconv</strong> to convert strings into numbers (this package could also work the other way around, but <a id="_idIndexMarker1055"/>there are better solutions for <span class="No-Break">formatting text).</span></li>
				<li>Now, write <span class="No-Break">the following:</span><pre class="source-code">
var tplStr = `
&lt;html&gt;
  &lt;h1&gt;Customer {{.ID}}&lt;/h1&gt;
  {{if .ID }}
   &lt;p&gt;Details:&lt;/p&gt;
   &lt;ul&gt;
   {{if .Name}}&lt;li&gt;Name: {{.Name}}&lt;/li&gt;{{end}}
   {{if .Surname}}&lt;li&gt;Surname: {{.Surname}}&lt;/li&gt;{{end}}
   {{if .Age}}&lt;li&gt;Age: {{.Age}}&lt;/li&gt;{{end}}
   &lt;/ul&gt;
  {{else}}
  &lt;p&gt;Data not available&lt;/p&gt;
  {{end}}
&lt;/html&gt;
`</pre></li>				<li>This is a raw string that contains some HTML and templating code, which is wrapped by <strong class="source-inline">{{}}</strong>. We will analyze <span class="No-Break">this now.</span></li>
				<li><strong class="source-inline">{{.ID}}</strong> is essentially a placeholder that tells the template engine that wherever this code is found, it will be substituted by a struct’s attribute called <strong class="source-inline">ID</strong>. The Go templating engine works with structs, so essentially, a struct will be passed to the engine and its attributes’ values will be used to fill the placeholders. <strong class="source-inline">{{if .ID}}</strong> is a conditional that tells the template that what happens next will depend on the value of <strong class="source-inline">ID</strong>. In this case, if <strong class="source-inline">ID</strong> is not an empty string, the template will display the customer’s details; otherwise, it will display <strong class="source-inline">&lt;p&gt;Data not available&lt;/p&gt;</strong>, which is wrapped between the <strong class="source-inline">{{else}}</strong> and <strong class="source-inline">{{end}}</strong> placeholders. As you can see, there are many more conditionals nested inside the first one. At each list item, there is a <strong class="source-inline">&lt;li&gt;</strong> tag, which is wrapped, for <a id="_idIndexMarker1056"/>example, by <strong class="source-inline">{{if .Name}}</strong> and terminated <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">{{end}}</strong></span><span class="No-Break">.</span></li>
				<li>Now that we have a string template, let’s create a struct with the correct attributes. To fill in the template, write <span class="No-Break">the following:</span><pre class="source-code">
type Customer struct {
  ID int
  Name string
  Surname string
  Age int
}</pre><p class="list-inset">This struct is self-explanatory. It contains all the attributes needed by <span class="No-Break">the template.</span></p></li>				<li>Define the <strong class="source-inline">handler</strong> function and set a variable to the map of values <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">querystring</strong></span><span class="No-Break">:</span><pre class="source-code">
func Hello(w http.ResponseWriter, r *http.Request) {
  vl := r.URL.Query()</pre></li>				<li>Instantiate a <strong class="source-inline">cust</strong> variable of the <span class="No-Break"><strong class="source-inline">Customer</strong></span><span class="No-Break"> type:</span><pre class="source-code">
  cust := Customer{}</pre></li>				<li>The variable now has all its attributes set to the default values, and we need to grab the passed values from <a id="_idIndexMarker1057"/>the URL. To do so, write <span class="No-Break">the following:</span><pre class="source-code">
  id, ok := vl["id"]
  if ok {
    cust.ID, _ = strconv.Atoi(strings.Join(id, ","))
  }
  name, ok := vl["name"]
  if ok {
    cust.Name = strings.Join(name, ",")
  }
  surname, ok := vl["surname"]
  if ok {
    cust.Surname = strings.Join(surname, ",")
  }
  age, ok := vl["age"]
  if ok {
    cust.Age, _ = strconv.Atoi(strings.Join(age, ""))
  }</pre></li>				<li>As you can see, the parameters are taken as they are from the values map, and if they exist, they are used to set the value of the related <strong class="source-inline">cust</strong> attribute. To check whether these parameters exist, we again used the <strong class="source-inline">ok</strong> variable, which is set to a Boolean with a value of <strong class="source-inline">true</strong> in case the map contains the requested key. The last attribute, <strong class="source-inline">Age</strong>, is handled <span class="No-Break">slightly differently:</span><pre class="source-code">
    cust.Age, _ = strconv.Atoi(strings.Join(age, ""))</pre></li>				<li>This is because <strong class="source-inline">strconv.Atoi</strong> returns an error in case the parameter that’s passed is not a number. In general, we should handle the errors but, in this case, we’ll just ignore it and we won’t display any age-related information if the age provided is not <span class="No-Break">a number.</span></li>
				<li>Next, write <span class="No-Break">the following:</span><pre class="source-code">
  tmpl, _ := template.New("test").Parse(tplStr)</pre></li>				<li>This creates a template object called <strong class="source-inline">test</strong> that contains the content of the string that you created at the outset. Again, ignore the error as we are sure that the template we’ve written is a valid one. In production, however, all the errors should be <span class="No-Break">dealt with.</span></li>
				<li>You can now finish writing <span class="No-Break">the function:</span><pre class="source-code">
  tmpl.Execute(w, cust)
}</pre></li>				<li>Here, the template is executed using the <strong class="source-inline">cust</strong> struct; its content is sent directly to <strong class="source-inline">w ResponseWriter</strong> without <a id="_idIndexMarker1058"/>the need to call the <strong class="source-inline">Write</strong> <span class="No-Break">method manually.</span></li>
				<li>What’s missing now is the <strong class="source-inline">main</strong> method, which is fairly simple. Write <span class="No-Break">the following:</span><pre class="source-code">
func main() {
  http.HandleFunc("/", Hello)
  log.Fatal(http.ListenAndServe(":8080", nil))
}</pre></li>				<li>Here, simply speaking, the main path is associated with the <strong class="source-inline">Hello</strong> function, and the server is <span class="No-Break">then started.</span></li>
				<li>The performance of this code is not very high as we create a template for every request. The template could be created in <strong class="source-inline">main</strong> and then passed to a handler, which could have a <strong class="source-inline">ServeHTTP</strong> method like the <strong class="source-inline">Hello</strong> function you’ve just written. The code has been kept simple here to focus <span class="No-Break">on templating.</span></li>
				<li>Now, if you start the server and visit the following pages, you should see some output si<a id="_idTextAnchor1753"/>milar to <span class="No-Break">the following:</span></li>
			</ol>
			<div>
				<div id="_idContainer191" class="IMG---Figure">
					<img src="image/B18621_16_17.jpg" alt="Figure 16.17: Templated response with blank parameters" width="1145" height="213"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.17: Templated response with blank parameters</p>
			<p>Now, you can add a query parameter <a id="_idIndexMarker1059"/>called <strong class="source-inline">id</strong> and make it equal to <strong class="source-inline">1</strong> in the URL by <span class="No-Break">visitin<a id="_idTextAnchor1754"/>g </span><span class="No-Break"><strong class="source-inline">localhost:8080/?id=1</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="image/B18621_16_18.jpg" alt="Figure 16.18: Templated response with just the ID specified" width="1252" height="218"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.18: Templated response with just the ID specified</p>
			<p>Then, you can add a value for the name parameter by going<a id="_idTextAnchor1755"/> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">localhost<a id="_idTextAnchor1756"/>:8080/?id=1&amp;name=John</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer193" class="IMG---Figure">
					<img src="image/B18621_16_19.jpg" alt="Figure 16.19: Templated response with the ID and name specified" width="1311" height="272"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.19: Templated response with the ID and name specified</p>
			<p>Finally, you also add an age by going <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">localhost:8080/?i<a id="_idTextAnchor1757"/>d=1&amp;name=John&amp;age=40</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer194" class="IMG---Figure">
					<img src="image/B18621_16_20.jpg" alt="Figure 16.20: Templated response with the ID, name, and age specified" width="1236" height="318"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.20: Templated response with the ID, name, and age specified</p>
			<p>Here, each <a id="_idIndexMarker1060"/>parameter in <strong class="source-inline">querystring</strong> is displayed, if valid, <a id="_idTextAnchor1758"/>in the <a id="_idTextAnchor1759"/><span class="No-Break">web application.</span></p>
			<h1 id="_idParaDest-418"><a id="_idTextAnchor1760"/>Static resources</h1>
			<p>Everything you’ve learned so far in this book, up to the previous exercise, is sufficient to build web applications and dynamic websites; you <a id="_idIndexMarker1061"/>just need to put all the <span class="No-Break">pieces together.</span></p>
			<p>What you’ve been doing in this chapter is returning messages that are different but all hardcoded as strings. Even dynamic messages have been based on templates hardcoded in the source file of the exercises and activities. Now, let’s consider something. In the case of the first <strong class="source-inline">hello world</strong> server, the message never changed. If we wanted to modify the message and return a <strong class="source-inline">Hello galaxy</strong> message, we would have to change the text in the code and then recompile and/or run the server again. What if you wanted to sell your simple “hello” server and give the option to everybody to specify a custom message? Of course, you should give the source code to everybody so that they can recompile and run <span class="No-Break">the server.</span></p>
			<p>Although you might want to embrace open source code, this might not be the ideal way to distribute an application, and we need to find a better way to separate the message from the server. A solution to that is to serve static files, which are files that are loaded by your program as external resources. These files do not change, do not get compiled, and are loaded and manipulated by your program. One such example may be templates, as seen previously, because they are just text and you can use template files instead of adding the templates as text to your code. Another simple example of static resources is if you want to include styling files such as CSS in your web page. You will see how to do that in the following exercises and activities. You’ll learn how to serve a specific file or a specific folder, and then you’ll <a id="_idIndexMarker1062"/>learn how to serve dynamic file<a id="_idTextAnchor1761"/>s with a <span class="No-Break">static template.</span></p>
			<h2 id="_idParaDest-419">Exercise 16.05 – creating a Hello Wo<a id="_idTextAnchor1762"/>rld server using a static file</h2>
			<p>In this exercise, you will create your Hello World server but with a static HTML file. What we want is to have a simple server with one<a id="_idIndexMarker1063"/> handler function that looks for a specific file with a specific name, which will be served as the output for<a id="_idIndexMarker1064"/> every path. In this case, you will need to create multiple files in <span class="No-Break">your project:</span></p>
			<ol>
				<li>Create a folder called <strong class="source-inline">static-file</strong> and, inside it, create a file called <strong class="source-inline">index.html</strong>. Then, insert the following code for a pretty simple HTML file with a title and an <strong class="source-inline">h1</strong> tag that states our <span class="No-Break">welcome message:</span><pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Welcome&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Hello World&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></li>				<li>Now, create a file called <strong class="source-inline">main.go</strong> and start writing the <span class="No-Break">necessary imports:</span><pre class="source-code">
package main
import (
  "log"
  "net/http"
)</pre></li>				<li>Now, write the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func main() {</pre></li>				<li>Next, write the <span class="No-Break"><strong class="source-inline">handler</strong></span><span class="No-Break"> function:</span><pre class="source-code">
  http.HandleFunc("/", func (w http.ResponseWriter, r *http.Request) {
    http.ServeFile(w, r, "./index.html")
  })</pre></li>				<li>This is where the magic happens. Here <a id="_idIndexMarker1065"/>a normal <strong class="source-inline">http.HandleFunc</strong> is being called with a <strong class="source-inline">"/"</strong> path as the<a id="_idIndexMarker1066"/> first parameter, after which a handler function is passed, which contains a <span class="No-Break">single instruction:</span><pre class="source-code">
    http.ServeFile(w, r, "./index.html")</pre></li>				<li>This sends the content of the <strong class="source-inline">index.html</strong> file <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">ResponseWriter</strong></span><span class="No-Break">.</span></li>
				<li>Now, write the <span class="No-Break">last part:</span><pre class="source-code">
    log.Fatal(http.ListenAndServe(":8080", nil))
}</pre></li>				<li>As is always the case, this starts the server, logs in case of an error, and exits <span class="No-Break">the program.</span></li>
				<li>Now, save the file and run the program with the <span class="No-Break">following command:</span><pre class="source-code">
go run main.go</pre><p class="list-inset">If you open your browser on the <strong class="source-inline">localhost:8080</strong> page, yo<a id="_idTextAnchor1763"/>u should see <span class="No-Break">the following:</span></p></li>			</ol>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="image/B18621_16_21.jpg" alt="Figure 16.21: Hello World with a static template file" width="874" height="85"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.21: Hello World with a static template file</p>
			<ol>
				<li value="10">Next, without stopping your server, just<a id="_idIndexMarker1067"/> change the HTML file, <strong class="source-inline">index.html</strong>, and modify line <strong class="source-inline">8</strong>, where<a id="_idIndexMarker1068"/> you see <span class="No-Break">the following:</span><pre class="source-code">
    &lt;h1&gt;Hello World&lt;/h1&gt;</pre></li>				<li>Change the text in the <strong class="source-inline">&lt;h1&gt;</strong> tag, <span class="No-Break">like so:</span><pre class="source-code">
    &lt;h1&gt;Hello Galaxy&lt;/h1&gt;</pre></li>				<li>Save the <strong class="source-inline">index.html</strong> file and, without touching the terminal and without restarting your server, just refresh your browser on the same page. You s<a id="_idTextAnchor1764"/>hould now see <span class="No-Break">the following:</span></li>
			</ol>
			<div>
				<div id="_idContainer196" class="IMG---Figure">
					<img src="image/B18621_16_22.jpg" alt="Figure 16.22: Hello World server with the static template file modified" width="828" height="105"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.22: Hello World server with the static template file modified</p>
			<ol>
				<li value="13">So, even if the server is running, it will pick up the new version of <span class="No-Break">the file.</span></li>
			</ol>
			<p>In this exercise, you learned how to use a static HTML file to serve a web page, as well as how detaching the static resources from your application allows you to change your served page without having<a id="_idTextAnchor1765"/> to restart <span class="No-Break">y<a id="_idTextAnchor1766"/>our application.</span></p>
			<h1 id="_idParaDest-420"><a id="_idTextAnchor1767"/>Getting some style</h1>
			<p>So far, you’ve seen how to serve one static page and you might consider serving a few pages with the same method, maybe creating a handler struct with the name of the file to serve as an attribute. This might be impractical for <a id="_idIndexMarker1069"/>large numbers of pages, although, in some cases, it is necessary. A web page, however, does not include just HTML code – it may also include images and styles, as well as some <span class="No-Break">frontend code.</span></p>
			<p>It is not within the scope of this book to teach you how to build HTML pages, and even less how to write JavaScript code or CSS style sheets, but you need to know how to serve these documents as we use a small CSS file to build <span class="No-Break">our example.</span></p>
			<p>Serving static files and putting templates in different files, or generally using external resources, is a good way to separate concerns on our projects and make our projects more manageable and maintainable, so you should try to follow this approach in all <span class="No-Break">your projects.</span></p>
			<p>To add a style sheet to your HTML pages, you need to add a tag <span class="No-Break">like this:</span></p>
			<pre class="source-code">
&lt;link rel="stylesheet" href="file.css"&gt;</pre>			<p>This injects the CSS file into the page as a “stylesheet,” but this is reported here just by way of an example, in case you are interested in learning how to <span class="No-Break">write HTML.</span></p>
			<p>You have also seen that we have served files, reading them from the filesystem one by one, but Go provides us with an easy function to do the job <span class="No-Break">for us:</span></p>
			<pre class="source-code">
http.FileServer(http.Dir("./public"))</pre>			<p>Essentially, <strong class="source-inline">http.FileServer</strong> creates what its name says: a server serving external files. It takes it from the directory defined in <strong class="source-inline">http.Dir</strong>. Whatever file we put inside the <strong class="source-inline">./public</strong> directory will be automatically accessible in the <span class="No-Break">address bar:</span></p>
			<pre class="source-code">
http://localhost:8080/public/myfile.css</pre>			<p>This seems good enough. However, in a real-world scenario, you do not want to expose your folder names and instead specify a different name for your static resources. This can be achieved <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
http.StripPrefix(
  "/statics/",
  http.FileServer(http.Dir("./public")),
)</pre>			<p>You may have noticed that the <strong class="source-inline">http.FileServer</strong> function is wrapped by an <strong class="source-inline">http.StripPrefix</strong> function, which we use to associate the requested path with the correct files on the filesystem. Essentially, we want the path of the <strong class="source-inline">/statics</strong> form to be available and to bind it to the <a id="_idIndexMarker1070"/>content of the <strong class="source-inline">public</strong> folder. The <strong class="source-inline">StripePrefix</strong> function will remove the <strong class="source-inline">"/statics/"</strong> prefix from the request and pass it to the file server, which will just get the name of the file to serve and search for it in the <span class="No-Break"><strong class="source-inline">public</strong></span><span class="No-Break"> folder.</span></p>
			<p>It is not necessary to use these wrappers if you do not want to change the name of the path and folder, but this solution is general and works everywhere, so you can utilize it in other pr<a id="_idTextAnchor1768"/>ojects without having <span class="No-Break">to wo<a id="_idTextAnchor1769"/>rry.</span></p>
			<h2 id="_idParaDest-421"><a id="_idTextAnchor1770"/>Exercise 16.06 – a stylish welcome</h2>
			<p>This exercise aims to help you display a welcome page while making use of some external static resources. We will<a id="_idIndexMarker1071"/> adopt the same approach as in <em class="italic">Exercise 16.05</em>, but we will add some extra files and code. We will place some stylesheets in a <strong class="source-inline">statics</strong> folder, and we will serve them so that they can be used by other pages served by the <span class="No-Break">same server:</span></p>
			<ol>
				<li>By way of a first step, create a folder called <strong class="source-inline">stylish-welcome</strong> and, inside this folder, add a file called <strong class="source-inline">index.html</strong>. Then, incorporate the <span class="No-Break">following content:</span><pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="UTF-8"&gt;
  &lt;title&gt;Welcome&lt;/title&gt;
  &lt;link rel="stylesheet" href="/statics/body.css"&gt;
  &lt;link rel="stylesheet" href="/statics/header.css"&gt;
  &lt;link rel="stylesheet" href="/statics/text.css"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Hello World&lt;/h1&gt;
  &lt;p&gt;May I give you a warm welcome&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></li>				<li>As you can see, there are few differences compared with the previous HTML; we have a paragraph with some <a id="_idIndexMarker1072"/>more text, wrapped by the <strong class="source-inline">&lt;p&gt;</strong> tag, and, inside the <strong class="source-inline">&lt;head&gt;</strong> tag, we include three links to <span class="No-Break">external resources.</span></li>
				<li>Now, create a folder called <strong class="source-inline">public</strong> inside your <strong class="source-inline">stylish-welcome</strong> folder and create three files therein with the following names <span class="No-Break">and content:</span><pre class="source-code">
header.css
h1 {
  color: brown;
}
body.css
body {
  background-color: beige;
}
text.css
p {
  color: coral;
}</pre></li>				<li>Now, go back to your main project folder, <strong class="source-inline">stylish-welcome</strong>, and create the <strong class="source-inline">main.go</strong> file. The content at the start corresponds exactly to that in one of the <span class="No-Break">previous exercises:</span><pre class="source-code">
package main
import (
  "log"
  "net/http"
)
func main() {
  http.HandleFunc("/", func (w http.ResponseWriter, r *http.Request) {
    http.ServeFile(w, r, "./index.html")
  })</pre></li>				<li>Now, add the following code<a id="_idIndexMarker1073"/> to handle the <span class="No-Break">static files:</span><pre class="source-code">
  http.Handle(
    "/statics/",
    http.StripPrefix(
    "/statics/",
    http.FileServer(http.Dir("./public")),
  ),
)</pre></li>				<li>This code adds a handler to the <strong class="source-inline">/statics/</strong> path and does so through an <strong class="source-inline">http.FileServer</strong> function, which returns a static <span class="No-Break">file handler.</span></li>
				<li>This function requires a directory to scrape, and we pass one to it as <span class="No-Break">a parameter:</span><pre class="source-code">
  http.Dir("./statics")</pre></li>				<li>This reads the local <strong class="source-inline">public</strong> folder that you <span class="No-Break">created previously.</span></li>
				<li>Now, add this final part to <span class="No-Break">the file:</span><pre class="source-code">
  log.Fatal(http.ListenAndServe(":8080", nil))
}</pre></li>				<li>Here, again, the server <a id="_idIndexMarker1074"/>gets created and the <strong class="source-inline">main()</strong> function is closed. Now, run the <span class="No-Break">server again:</span><pre class="source-code">
go run main.go</pre></li>				<li>Y<a id="_idTextAnchor1771"/>ou will see the <span class="No-Break">following output:</span></li>
			</ol>
			<div>
				<div id="_idContainer197" class="IMG---Figure">
					<img src="image/B18621_16_23.jpg" alt="Figure 16.23: Styled home page" width="866" height="147"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.23: Styled home page</p>
			<p class="list-inset">Somehow, the HTML file is now getting the style from the style sheets you created at <span class="No-Break">the beginning.</span></p>
			<ol>
				<li value="12">Now, let’s examine how the files are injected. If you look back at the <strong class="source-inline">index.html</strong> file, you will see <span class="No-Break">these lines:</span><pre class="source-code">
&lt;link rel="stylesheet" href="/statics/body.css"&gt;
&lt;link rel="stylesheet" href="/statics/header.css"&gt;
&lt;link rel="stylesheet" href="/statics/text.css"&gt;</pre></li>				<li>So, essentially, we are looking for files under the <strong class="source-inline">"/statics/"</strong> path. The first address will display the content of t<a id="_idTextAnchor1772"/>he CSS for the body of <span class="No-Break">the page:</span></li>
			</ol>
			<div>
				<div id="_idContainer198" class="IMG---Figure">
					<img src="image/B18621_16_24.jpg" alt="Figure 16.24: The body CSS file" width="840" height="95"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.24: The body CSS file</p>
			<p class="list-inset">The second one displays the<a id="_idIndexMarker1075"/><a id="_idTextAnchor1773"/> CSS for the header of <span class="No-Break">the page:</span></p>
			<div>
				<div id="_idContainer199" class="IMG---Figure">
					<img src="image/B18621_16_25.jpg" alt="Figure 16.25: The header CSS file" width="863" height="94"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.25: The header CSS file</p>
			<p class="list-inset">Finally, we have the CSS for the text on the page. So, a<a id="_idTextAnchor1774"/>ll the style sheets <span class="No-Break">are served:</span></p>
			<div>
				<div id="_idContainer200" class="IMG---Figure">
					<img src="image/B18621_16_26.jpg" alt="Figure 16.26: The text CSS file" width="874" height="96"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.26: The text CSS file</p>
			<ol>
				<li value="14">Furt<a id="_idTextAnchor1775"/>hermore, you can even <span class="No-Break">go here:</span></li>
			</ol>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="image/B18621_16_27.jpg" alt="Figure 16.27: Static folder content visible in the browser" width="845" height="100"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.27: Static folder content visible in the browser</p>
			<ol>
				<li value="15">You’ll see that all the files inside the <strong class="source-inline">public</strong> folder are served under the <strong class="source-inline">/statics/</strong> path. If you are looking for a simple static files server, Go allows you, with the help of a few lines of code, to create one, and, with a few more lines, you can make <span class="No-Break">it production-ready.</span></li>
				<li>If you use Chrome, you can inspect with your mouse by right-clicking, though you can do the same with any browser if you have developer tools. You will see someth<a id="_idTextAnchor1776"/>ing similar to <span class="No-Break">the following:</span></li>
			</ol>
			<div>
				<div id="_idContainer202" class="IMG---Figure">
					<img src="image/B18621_16_28.jpg" alt="Figure 16.28: Developer tools showing loaded scripts" width="801" height="317"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.28: Developer tools showing loaded scripts</p>
			<p>As you can see, the files have <a id="_idIndexMarker1076"/>been loaded and the styles are shown as being computed fr<a id="_idTextAnchor1777"/>om the s<a id="_idTextAnchor1778"/>tylesheet on <span class="No-Break">the right.</span></p>
			<h1 id="_idParaDest-422"><a id="_idTextAnchor1779"/>Getting dynamic</h1>
			<p>Static assets are generally served as they are, but when you want to create a dynamic page, you might want to make use of an external template, which you can use on the fly, so that you can change the template without having to restart your server, or that you can load on startup, which means you <a id="_idIndexMarker1077"/>will have to restart your server following any change (this is not strictly true, but we need some concepts of concurrent programming to make it happen). Loading a file at startup is done simply for performance reasons. Filesystem operations are always the slowest, and even if Go is a fairly fast language, you might want to take performance into account when you want to serve your pages, especially if you have many requests from <span class="No-Break">multiple clients.</span></p>
			<p>As you may recall, we used the standard Go templates to make dynamic pages. Now, we can use the template as an external resource, put our template code in an HTML file, and load it. The template engine can parse it and then fill in the blanks with the passed parameters. To do this, we can use the <span class="No-Break"><strong class="source-inline">html/template</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func ParseFiles(filenames ...string) (*Template, error)</pre>			<p>As an example, this can be<a id="_idTextAnchor1780"/> called with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
template.ParseFiles("mytemplate.html")</pre>			<p>In addition, the template is loaded in memory and is ready to <span class="No-Break">be used.</span></p>
			<p>So far, you have been the sole <a id="_idIndexMarker1078"/>user of your HTTP servers, but in an actual scenario, that won’t be the case. In the following examples, we will look at performance and will use a resource that’s loaded <span class="No-Break">at s<a id="_idTextAnchor1781"/>tartup.</span></p>
			<h2 id="_idParaDest-423"><a id="_idTextAnchor1782"/>Activity 16.02 – external template</h2>
			<p>In this activity, you will create a welcome server, similar to the ones you created before, and you will have to use the template package, as <a id="_idIndexMarker1079"/>you’ve done before. In this activity, however, we do not want you to create your template from a hardcoded string but from an HTML file, which will contain all the <span class="No-Break">template placeholders.</span></p>
			<p>You should be able to complete this activity by making use of what you’ve learned so far in this chapter and the <span class="No-Break">previous one.</span></p>
			<p>This activity returns a pointer to <strong class="source-inline">template</strong> and an error from a list of filenames. The error gets returned if any of the files does not exist or if the format of the template is wrong. In any case, do not concern yourself with the possibility of adding multiple files. Stick <span class="No-Break">with one.</span></p>
			<p>Here are the steps to complete <span class="No-Break">this activity:</span></p>
			<ol>
				<li>Create a folder for <span class="No-Break">your project.</span></li>
				<li>Create a template with a name such as <strong class="source-inline">index.html</strong> and fill it with standard HTML code, with a welcome message and a placeholder for the name. Make sure that if the name is empty, the message inserts the word <strong class="source-inline">visitor</strong> where the name is supposed <span class="No-Break">to be.</span></li>
				<li>Create your <strong class="source-inline">main.go</strong> file and add to it the right package <span class="No-Break">and imports.</span></li>
				<li>In the <strong class="source-inline">main.go</strong> file, create a struct holding a name that can be passed to <span class="No-Break">a template.</span></li>
				<li>Create a template from a file using your <span class="No-Break"><strong class="source-inline">index.html</strong></span><span class="No-Break"> file.</span></li>
				<li>Create something that’s able to handle the HTTP requests and use <strong class="source-inline">querystring</strong> to receive parameters and display the data through the template you <span class="No-Break">created previously.</span></li>
				<li>Set all the paths to the server so that you can use the function or handler you created in the previous step; then, create<a id="_idIndexMarker1080"/> <span class="No-Break">the server.</span></li>
				<li>Run the server and check the re<a id="_idTextAnchor1783"/>sul<a id="_idTextAnchor1784"/>t. The output will be <span class="No-Break">as follows:</span></li>
			</ol>
			<div>
				<div id="_idContainer203" class="IMG---Figure">
					<img src="image/B18621_16_29.jpg" alt="Figure 16.29: Anonymous visitor page" width="904" height="141"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.29: Anonymous visitor page</p>
			<p>The visitor page, including the name that’s displayed<a id="_idTextAnchor1785"/>, will look something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer204" class="IMG---Figure">
					<img src="image/B18621_16_30.jpg" alt="Figure 16.30: Visitor page with the name “Will”" width="865" height="133"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 16.30: Visitor page with the name “Will”</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found in this book’s GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter16/Activity16.02"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter16/Activity16.02</span></a><span class="No-Break">.</span></p>
			<p>In this activity, you learned how to create a templated HTTP handler as a struct that can be initialized with any external <a id="_idIndexMarker1081"/>template. You can now create multiple pages, instantiating the same struct with different templates of <span class="No-Break">your choice.</span></p>
			<h1 id="_idParaDest-424"><a id="_idTextAnchor1786"/>Embedding external files</h1>
			<p>In the previous sections, you learned about a very interesting technique, but having external files to read can be problematic when deploying something to production, especially with Go, where one of its <a id="_idIndexMarker1082"/>strong features is building a single executable. Fortunately, there is a package in Go called <strong class="source-inline">embed</strong> that allows us to add external files to our final binary so that we need the original file when we develop, but we do not need to share this file with anybody else as it will be compiled and added to our final binary. Let’s see how <span class="No-Break">this works.</span></p>
			<p>Let’s imagine that you have a simple template file and want to use it on your <span class="No-Break">web server:</span></p>
			<pre class="source-code">
mytemplate.html
&lt;h1&gt;{{.Text}}&lt;/h1&gt;</pre>			<p>Let’s look at a small program that does exactly that, using what you’ve learned in the <span class="No-Break">previous chapter:</span></p>
			<pre class="source-code">
package main
import (
  "html/template"
  "log"
  "net/http"
)
func main() {
  t, _ := template.ParseFiles("mytemplate.html")
  http.HandleFunc(
    "/hello1", func(w http.ResponseWriter,
      r *http.Request,
    ) {
      data := struct {
        text string
      }{
        text: "Hello there",
      }
      t.Execute(w, data)
    })
  log.Fatal(http.ListenAndServe(":8085", nil))
}</pre>			<p>If you run this code, the program will parse the file from your folder and use it as a template to display <strong class="source-inline">Hello there</strong> on the <strong class="source-inline">/hello1</strong> path. If you build your application and you move your executable to a different folder, however, you will receive an error. Let’s modify this software <a id="_idIndexMarker1083"/>so that it uses the <span class="No-Break"><strong class="source-inline">embed</strong></span><span class="No-Break"> package:</span></p>
			<pre class="source-code">
package main
import (
  _ "embed"
  "html/template"
  "log"
  "net/http"
)
//go:embed mytemplate.html
var s string
func main() {
  t, _ := template.New("mytemplate").Parse(s)
  http.HandleFunc(
    "/hello1", func(w http.ResponseWriter,
      r *http.Request,
    ) {
      data := struct {
        text string
      }{
        text: "Hello there",
      }
      t.Execute(w, data)
    })
  log.Fatal(http.ListenAndServe(":8085", nil))
}</pre>			<p>The difference Is that we’ve just created a global variable, <strong class="source-inline">s</strong>, that holds the content of the <strong class="source-inline">mytemplate.html</strong> files and <a id="_idIndexMarker1084"/>stores it in the binary when you compile your code using the <strong class="source-inline">//go:embed</strong> build <span class="No-Break">tag directive:</span></p>
			<pre class="source-code">
_ "embed"
//go:embed mytemplate.html
var s string
t, _ := template.New("mytemplate").Parse(s)</pre>			<p>Finally, we create a template with the <strong class="source-inline">New</strong> method and then parse the string. If you compile the code and run your application from a differe<a id="_idTextAnchor1787"/>nt fold<a id="_idTextAnchor1788"/>er, you won’t have <span class="No-Break">any errors.</span></p>
			<h1 id="_idParaDest-425"><a id="_idTextAnchor1789"/>Summary</h1>
			<p>In this chapter, you were introduced to the server side of web programming. You learned how to accept requests from HTTP clients and respond appropriately. You also learned how to separate the possible requests into different areas of an HTTP server via paths and sub-paths. For this, you used a simple routing mechanism with the standard <strong class="source-inline">Go </strong><span class="No-Break"><strong class="source-inline">HTTP</strong></span><span class="No-Break"> package.</span></p>
			<p>Then, you learned how to return your response to suit different consumers: JSON responses for synthetic clients, and HTML pages for <span class="No-Break">human access.</span></p>
			<p>Next, you learned how to use templates to format your plain text and HTML messages, using the standard templating package. You learned how to serve and use static resources, serving them directly through a default file server or a <span class="No-Break">template object.</span></p>
			<p>After that, you learned how to create a middleware and how to embed external files inside your binary for better portability. At this stage, you know all the basics for building production-grade HTTP servers, although you might want to use some external libraries to facilitate your Hello World example, facilitating better routing by using something such as gorilla mux or, generally, the entire <strong class="source-inline">gorilla</strong> package, which is a low-level abstraction on top of the <strong class="source-inline">http</strong> package. You could use <strong class="source-inline">hero</strong> as a template engine to make your page <span class="No-Break">rendering faster.</span></p>
			<p>One thing to mention is that you can make pretty much stateless services with what you’ve learned in this chapter, but you cannot create a production-grade stateful server at the moment as you do not know how to handle concurrent requests. This means that <strong class="source-inline">views counter</strong> is not suitable for a production server yet, but this will be the subject of <span class="No-Break">another chapter.</span></p>
			<p>In the next chapter, you will shift gears and learned how to use the Go HTTP client to talk to other systems over <span class="No-Break">the internet.</span></p>
		</div>
	</div></div></body></html>