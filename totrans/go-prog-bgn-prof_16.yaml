- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Web Servers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络服务器
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to different ways of creating an HTTP server to
    accept requests from the internet. You will be able to understand how a website
    can be accessed and how it can respond to a form. You will also learn how to respond
    to requests from another software program.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了创建HTTP服务器以接受来自互联网的请求的不同方法。你将能够理解一个网站是如何被访问的，以及它如何响应一个表单。你还将学习如何响应来自另一个软件程序的需求。
- en: By the end of this chapter, you’ll be able to create an HTTP server that renders
    a simple message. You will also know how to create an HTTP server that renders
    complex data structures that serve local static files. Further, you know how to
    create an HTTP server that renders dynamic pages and works with different ways
    of routing. Finally, you will know how to create a REST service, accept data through
    a form, and accept JSON data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建一个渲染简单信息的HTTP服务器。你还将知道如何创建一个渲染复杂数据结构并服务于本地静态文件的HTTP服务器。此外，你将了解如何创建一个渲染动态页面并使用不同路由方式的HTTP服务器。最后，你将知道如何创建一个REST服务，通过表单接收数据，以及接收JSON数据。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete and run the examples in this chapter, you will need your favorite
    IDE and the latest version of the Go compiler. At the time of writing, this is
    1.21\. All the examples will use the standard Go library. You can refer to this
    book’s GitHub repository for the code in this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter16](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter16).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成并运行本章中的示例，你需要你的首选集成开发环境（IDE）和Go编译器的最新版本。在撰写本文时，这是1.21版本。所有示例都将使用标准Go库。你可以参考本书的GitHub仓库以获取本章的代码：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter16](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter16)。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will dig into how a remote server is created, so if you
    already know how to request information, you will see how to reply to these requests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨如何创建一个远程服务器，因此如果你已经知道如何请求信息，你将看到如何对这些请求进行响应。
- en: A web server is a program that uses the HTTP protocol – hence, the HTTP server
    – to accept requests from any HTTP client (web browser, another program, and so
    on) and respond to them with an appropriate message. When we browse the internet
    with our browser, it will be an HTTP server that will send an HTML page to our
    browser and we will be able to see it. In some other cases, a server will not
    return an HTML page but a different message that’s appropriate to the client.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网络服务器是一个使用HTTP协议的程序——因此称为HTTP服务器——用于接受来自任何HTTP客户端（网页浏览器、另一个程序等）的请求，并以适当的消息响应它们。当我们用浏览器浏览互联网时，它将是一个HTTP服务器，将发送一个HTML页面到我们的浏览器，我们就能看到它。在某些其他情况下，服务器不会返回一个HTML页面，而是返回一个适合客户端的不同消息。
- en: Some HTTP servers provide an API that can be consumed by another program. Think
    of when you want to register with a website, and you are asked if you want to
    sign up through Facebook or Google. This means that the website you want to register
    with will consume a Google or Facebook API to get your details. These APIs generally
    respond with structured text, which is a piece of text representing a complex
    data structure. The way these servers expect the requests can be different. Some
    expect the same type of structured messages they return, while some provide what
    is called a REST API, which is quite strict with the HTTP methods that are used
    and expects inputs in the form of URL parameters or values, similar to the ones
    in a web form.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一些HTTP服务器提供了一个可以被另一个程序消费的API。想想当你想要注册到一个网站时，你被问及是否想要通过Facebook或Google注册。这意味着你想要注册的网站将消费一个Google或Facebook
    API来获取你的详细信息。这些API通常以结构化文本的形式响应，这是一段代表复杂数据结构的文本。这些服务器期望请求的方式可能不同。一些期望返回相同类型的结构化消息，而一些提供所谓的REST
    API，它对使用的HTTP方法非常严格，并期望以URL参数或值的形式输入，类似于网页表单。
- en: How to build a basic server
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何构建一个基本服务器
- en: The simplest HTTP server that we can create is a Hello World server. This is
    a server that returns a simple message stating `Hello World` and will not do anything
    else. It is not very useful, but it is a starting point to see what default Go
    packages give us and is the basis for any other more complex server. The aim is
    to have a server that runs on a specific port on your machine’s local host and
    accepts any path under it. Accepting any path means that when you test the server
    with your browser, it will always return the `Hello World` message and a status
    code of `200`. Of course, we could return any other message, but, for historical
    reasons, the simplest project you learn when you study programming is always some
    sort of software that returns a message stating `Hello World`. In this case, we
    will see how this can be done and then visualized in a normal browser, before
    perhaps being put on the internet and shared with billions of users, although
    users may, in practice, prefer a more useful server. Let’s say this is the most
    basic HTTP server you can create.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能创建的最简单的HTTP服务器是一个“Hello World”服务器。这是一个返回简单消息，声明“Hello World”并且不会做其他任何事情的服务器。它并不非常实用，但它是观察默认Go包能给我们什么的一个起点，也是任何其他更复杂服务器的基石。目标是有一个在机器的本地主机上特定端口运行的服务器，并接受其下的任何路径。接受任何路径意味着当你用浏览器测试服务器时，它总是会返回“Hello
    World”消息和状态码`200`。当然，我们可以返回任何其他消息，但出于历史原因，当你学习编程时学习的最简单的项目总是某种返回声明“Hello World”的消息的软件。在这种情况下，我们将看到如何做到这一点，并在正常浏览器中可视化，然后可能将其放在互联网上并与数十亿用户分享，尽管在实践中，用户可能更喜欢一个更有用的服务器。让我们说这是你可以创建的最基本的HTTP服务器。
- en: HTTP handler
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP处理器
- en: 'To react to an HTTP request, we need to write something that, we usually say,
    handles the request; hence, we call this something a handler. In Go, we have several
    ways to do that, and one way is to implement the handler interface of the `http`
    package. This interface has one pretty self-explanatory method, and this is as
    follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应HTTP请求，我们需要编写一些通常所说的处理请求的内容；因此，我们称这个内容为处理器。在Go中，我们有几种方法可以做到这一点，其中一种方法是实现`http`包的处理器接口。此接口有一个相当直观的方法，如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So, whenever we need to create a handler for HTTP requests, we can create a
    struct that includes this method and we can use it to handle an HTTP request.
    Here’s an example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当我们需要为HTTP请求创建一个处理器时，我们可以创建一个包含此方法的struct，并可以使用它来处理HTTP请求。以下是一个示例：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is a valid HTTP handler and you can use it like so:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的HTTP处理器，您可以使用它如下：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `ListenAndServe()` is a function that will use our handler to serve the
    requests; any struct that implements the handler interface will be fine. However,
    we need to let our server do something.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ListenAndServe()`是一个将使用我们的处理器来处理请求的函数；任何实现了处理器接口的struct都是可以的。然而，我们需要让我们的服务器做些事情。
- en: 'As you can see, the `ServeHTTP` method accepts `ResponseWriter` and a `Request`
    object. You can use them to capture parameters from the request and write messages
    to the response. The simplest thing, for example, is to let our server return
    a message:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`ServeHTTP`方法接受`ResponseWriter`和一个`Request`对象。您可以使用它们来捕获请求中的参数并将消息写入响应。例如，最简单的事情就是让我们的服务器返回一个消息：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `ListenAndServe` method might return an error. If this happens, we will
    want the execution of our program to halt. One common practice is to wrap this
    function call with a fatal log:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListenAndServe`方法可能会返回一个错误。如果发生这种情况，我们希望程序执行停止。一种常见的做法是将此函数调用用致命日志包装起来：'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will halt the execution and print the error message that’s returned by
    the `ListenAndServe` function.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将停止执行并打印出`ListenAndServe`函数返回的错误信息。
- en: Exercise 16.01 – creating a Hello World server
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16.01 – 创建一个Hello World服务器
- en: Let’s start by building a simple `Hello World` HTTP server based on what you
    learned in the previous section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从根据上一节学到的内容构建一个简单的“Hello World”HTTP服务器开始。
- en: 'The first thing you need to do is create a folder called `hello-world-server`.
    You can do this via the command line or you can create it with your favorite editor.
    Inside the folder, create a file called `main.go`. We will not use any external
    library here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是创建一个名为`hello-world-server`的文件夹。您可以通过命令行或使用您最喜欢的编辑器来完成此操作。在文件夹内，创建一个名为`main.go`的文件。在这里，我们不会使用任何外部库：
- en: 'Add the package’s name, as shown here:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加包名，如下所示：
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This tells the compiler that this file is an entry point for a program that
    can be executed.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这告诉编译器，此文件是程序入口点，该程序可以被执行。
- en: 'Import the necessary packages:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的包：
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, create `handler`, the struct that will handle the requests:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建`handler`，这个结构体将用于处理请求：
- en: '[PRE7]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have our handler, create the `main()` function. This will start
    the server and produce a web page with our message:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了我们的处理器，创建`main()`函数。这将启动服务器并生成一个包含我们消息的网页：
- en: '[PRE8]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The entire file should look like this:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 整个文件应该看起来像这样：
- en: '[PRE9]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, go to your Terminal, inside your `hello-world-server` folder, and type
    in the following command:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开你的终端，进入你的`hello-world-server`文件夹，并输入以下命令：
- en: '[PRE10]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You shouldn’t see anything; the program has started.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你不应该看到任何东西；程序已经启动。
- en: 'Now, open your browser at the following address:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开你的浏览器到以下地址：
- en: '[PRE11]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see a page with a big message:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到一个带有大消息的页面：
- en: '![Figure 16.1: Hello World server](img/B18621_16_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图16.1：Hello World服务器](img/B18621_16_01.jpg)'
- en: 'Figure 16.1: Hello World server'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1：Hello World服务器
- en: 'Now, if you try to change path and go to `/page1`, you will see the following
    message:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你尝试更改路径并访问`/page1`，你会看到以下消息：
- en: '![Figure 16.2: Hello World server sub-pages](img/B18621_16_02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图16.2：Hello World服务器子页面](img/B18621_16_02.jpg)'
- en: 'Figure 16.2: Hello World server sub-pages'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2：Hello World服务器子页面
- en: Congratulations! This is your first HTTP server.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！这是你的第一个HTTP服务器。
- en: In this exercise, we created a basic Hello World server that returns a message
    stating `Hello World` in response to any request on any sub-address.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建了一个基本的Hello World服务器，它对任何子地址上的任何请求都返回一条消息，声明`Hello World`。
- en: Simple routing
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单路由
- en: 'The server we built in the previous exercise doesn’t do much – it just responds
    with a message; we cannot ask anything else. Before we can make our server more
    dynamic, let’s imagine we want to create an online book and we want to be able
    to select a chapter just by changing the URL. At the moment, if we browse the
    following pages, we’ll always see the same message:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中我们构建的服务器并没有做什么——它只是响应一条消息；我们无法询问其他内容。在我们使服务器更加动态之前，让我们想象我们想要创建一个在线书籍，并且我们想要能够通过更改URL来选择章节。目前，如果我们浏览以下页面，我们总是会看到相同的信息：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we want to associate different messages with these different paths on our
    server. We will do this by introducing some simple routing to our server.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要将不同的消息与服务器上的不同路径关联起来。我们将通过向服务器引入一些简单的路由来实现这一点。
- en: 'A path is what you see after `8080` in the URL, where `8080` is the port number
    we chose to run the server on. This path can be one number, a word, a set of numbers,
    or character groups separated by a `/`. To do this, we will use another function
    of the `net/http` package:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 路径是在URL中`8080`之后看到的，其中`8080`是我们选择在服务器上运行的端口号。这个路径可以是一个数字，一个单词，一组数字，或者由`/`分隔的字符组。为此，我们将使用`net/http`包的另一个函数：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the pattern is the path we want to be served by the `handler` function.
    Note how the `handler` function signature has the same parameters as the `ServeHTTP`
    method, which you added to the `hello` struct in the previous exercise.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，模式是我们想要由`handler`函数服务的路径。注意`handler`函数签名与你在上一个练习中添加到`hello`结构体的`ServeHTTP`方法具有相同的参数。
- en: As an example, the server we built in *Exercise 16.01* is not very useful, but
    we can transform it into something much more useful with the addition of pages
    other than the `Hello World` one. To do so, we need to do some basic routing.
    The aim here is to write a book, and the book must have a welcome page that contains
    a title and a first chapter. The book title is `Hello World`, so we can keep what
    we did before. The first chapter will have a heading stating [*Chapter 1*](B18621_01.xhtml#_idTextAnchor021).
    The book is a work in progress, so it doesn’t matter that the content is still
    poor; what we require is the ability to select the chapter; we will add the content
    later.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我们在*练习16.01*中构建的服务器并不非常实用，但我们可以通过添加除`Hello World`之外的页面来将其转变为更有用的东西。为此，我们需要做一些基本的路由。这里的目的是写一本书，这本书必须有一个包含标题和第一章的欢迎页面。书名是`Hello
    World`，所以我们可以保留之前所做的工作。第一章将有一个标题，声明[*第一章*](B18621_01.xhtml#_idTextAnchor021)。这本书还在进行中，所以内容仍然很糟糕并不重要；我们需要的是能够选择章节；我们将在稍后添加内容。
- en: Exercise 16.02 – routing our server
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16.02 – 路由我们的服务器
- en: 'We are going to modify the code in *Exercise 16.01* so that it supports different
    paths. If you haven’t gone through the previous exercise, do so now so that you
    have a basic framework for this exercise:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改*练习16.01*中的代码，使其支持不同的路径。如果你还没有完成前面的练习，请现在完成，以便你有一个这个练习的基本框架：
- en: 'Create a new folder and a `main.go` file, and add the code from the previous
    exercise to the definition of the `main` function:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹和一个 `main.go` 文件，并将之前练习中的代码添加到 `main` 函数的定义中：
- en: '[PRE14]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create the `main()` function:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main()` 函数：
- en: '[PRE15]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, use `handle` to route `/chapter1` through a `handlefunc()` function:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `handle` 将 `/chapter1` 路由通过 `handlefunc()` 函数：
- en: '[PRE16]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This means that we associate the path, `/chapter1`, with a function that returns
    a specific message.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着我们将路径 `/chapter1` 与一个返回特定信息的函数关联起来。
- en: 'Finally, set the server so that it listens to a port; then, run the following
    command:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，设置服务器以便它监听一个端口；然后，运行以下命令：
- en: '[PRE17]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, save your file and run the server again with the following command:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，保存你的文件，并使用以下命令再次运行服务器：
- en: '[PRE18]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, go to your browser and load the following URLs:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，打开你的浏览器并加载以下URL：
- en: '`http://localhost:8080`'
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080`'
- en: '`http://localhost:8080/chapter1`'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/chapter1`'
- en: 'The output for the home page is shown in the following screenshot:'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主页的输出显示在下图中：
- en: '![Figure 16.3: Multi-page server – home page](img/B18621_16_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图16.3：多页服务器 – 主页](img/B18621_16_03.jpg)'
- en: 'Figure 16.3: Multi-page server – home page'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3：多页服务器 – 主页
- en: 'The output for `page 1` is shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: “第1页”的输出显示在下图中：
- en: '![Figure 16.4: Multi-page server – page 1](img/B18621_16_04.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图16.4：多页服务器 – 第1页](img/B18621_16_04.jpg)'
- en: 'Figure 16.4: Multi-page server – page 1'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4：多页服务器 – 第1页
- en: 'Note that they both still display the same message. This happens because we
    are setting `hello` as the handler for our server, and this overrides our specific
    path. We can modify our code so that it looks like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它们仍然显示相同的信息。这是因为我们将 `hello` 设置为我们的服务器的处理器，这覆盖了我们的特定路径。我们可以修改我们的代码，使其看起来像这样：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we removed the `hello` handler so that it’s no longer the main handler
    for our server and we associated this handler with the main `/` path:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们移除了 `hello` 处理器，使其不再是我们的服务器的主处理器，并将此处理器与主要的 `/` 路径关联起来：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we associated a `handler` function with the specific `/``chapter1` path:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将一个 `handler` 函数与特定的 `/chapter1` 路径关联起来：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, if we stop and then run our server again, we will see that the `/chapter1`
    path now returns the new message:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们停止并再次运行我们的服务器，我们会看到 `/chapter1` 路径现在返回了新的信息：
- en: '![Figure 16.5: Multi-page server repeated – chapter 1](img/B18621_16_05.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图16.5：多页服务器重复 – 第1章](img/B18621_16_05.jpg)'
- en: 'Figure 16.5: Multi-page server repeated – chapter 1'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5：多页服务器重复 – 第1章
- en: 'In the meantime, all the other paths return the old **Hello** **World** message:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，所有其他路径都返回旧的 **Hello** **World** 信息：
- en: '![Figure 16.6: Multi-page server – base page](img/B18621_16_06.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图16.6：多页服务器 – 基础页面](img/B18621_16_06.jpg)'
- en: 'Figure 16.6: Multi-page server – base page'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：多页服务器 – 基础页面
- en: 'The default page for the server is also displayed for another route:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的默认页面也显示在另一个路由上：
- en: '![Figure 16.7: The page that is not set returns the default setting](img/B18621_16_07.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图16.7：未设置的页面返回默认设置](img/B18621_16_07.jpg)'
- en: 'Figure 16.7: The page that is not set returns the default setting'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7：未设置的页面返回默认设置
- en: With that, we made a basic Hello World web server with specific routes for different
    pages. During the process, we used several functions from the go `http` package,
    some of which are used to achieve the same result. We will see why there are multiple
    ways to do the same thing and why we need all of them shortly.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们创建了一个基本的Hello World网络服务器，为不同的页面设置了特定的路由。在这个过程中，我们使用了go `http` 包中的几个函数，其中一些用于实现相同的结果。我们将很快看到为什么有多个方法可以完成同一件事，以及为什么我们需要所有这些方法。
- en: Handler versus handler function
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器与处理器函数
- en: As you may have noticed, we used two different functions before, `http.Handle`
    and `http.HandleFunc`, both of which have a path as their first parameter, but
    which differ in terms of the second parameter. These two functions both ensure
    that a specific path is handled by a function. `http.Handle`, however, expects
    `http.Handler` to handle the path, while `http.HandleFunc` expects a function
    to do the same.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们之前使用了两个不同的函数，`http.Handle` 和 `http.HandleFunc`，它们都以路径作为第一个参数，但在第二个参数方面有所不同。这两个函数都确保特定的路径由一个函数处理。然而，`http.Handle`
    期望 `http.Handler` 来处理路径，而 `http.HandleFunc` 期望一个函数来做同样的事情。
- en: 'As we’ve seen before, `http.Handler` is any struct that has a method with this
    signature:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，`http.Handler` 是任何具有此签名的结构体：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So, in both cases, there will always be a function with `http.ResponseWriter`
    and `*http.Request` as parameters that will handle the path. When one or the other
    might be chosen may just be a matter of personal preference in many cases, but
    it might be important – when creating a complex project, for example – to choose
    the right method. Doing so will ensure that the structure of the project is optimal.
    Different routes may appear better organized if they’re handled by handlers that
    belong to different packages, or might have to perform very few actions, as in
    our previous case; and a simple function might prove to be the ideal choice.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这两种情况下，都存在一个带有 `http.ResponseWriter` 和 `*http.Request` 作为参数的函数来处理路径。在许多情况下，选择哪一个可能只是个人偏好的问题，但在创建复杂项目时，例如，选择正确的方法可能很重要。这样做将确保项目的结构是最优的。不同的路由如果由属于不同包的处理器处理，或者可能需要执行非常少的操作，就像我们之前的例子一样，可能会组织得更好；而一个简单的函数可能证明是理想的选择。
- en: In general, for simple projects where you have a handful of simple pages, you
    may opt for `HandleFunc`. For example, let’s say you want to have static pages
    and there is no complex behavior on each page. In this case, it would be overkill
    to use an empty struct just for returning static text. The handler is more appropriate
    whenever you need to set some parameters, or if you want to keep track of something.
    As a general rule, let’s say that if you have a counter, `Handler` is the best
    choice because you can initialize a struct with a count of 0 and then increment
    it, but we will see this in *Activity 16.01*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于只有几个简单页面的简单项目，你可以选择使用 `HandleFunc`。例如，假设你想要有静态页面，并且每个页面上没有复杂的行为。在这种情况下，仅为了返回静态文本而使用一个空的
    struct 就显得过于冗余。当需要设置一些参数或想要跟踪某些内容时，处理器更为合适。作为一个一般规则，如果我们有一个计数器，`Handler` 是最佳选择，因为你可以用一个计数为
    0 的结构体初始化，然后增加它，但我们将这在 *活动 16.01* 中看到。
- en: Activity 16.01 – adding a page counter to an HTML page
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 16.01 – 向 HTML 页面添加页面计数器
- en: Imagine that you own a website with, say, three pages, where you are writing
    your book. You earn money based on how many visits your website receives. To understand
    how popular your website is, and how much money you are earning, you need to keep
    track of the visits.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你拥有一个网站，比如有三个页面，你在那里写你的书。你通过网站收到的访问量来赚钱。为了了解你的网站有多受欢迎，以及你赚了多少钱，你需要跟踪访问量。
- en: In this activity, you will build an HTTP server with three pages that contain
    some content, and display, on each page, how many visits that page has had so
    far. You will use the `http.Handler` method, which, in this case, will help you
    generalize your counter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将构建一个包含三个页面且每个页面都有一些内容的 HTTP 服务器，并在每个页面上显示该页面迄今为止的访问次数。你将使用 `http.Handler`
    方法，在这种情况下，这将帮助你泛化计数器。
- en: To display the dynamic value, you can use the `fmt.Sprintf` function in the
    `fmt` package, which prints and formats a message to a string. With this function,
    you can build a string containing characters and numbers. You can find more information
    about this method online in the Go documentation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示动态值，你可以使用 `fmt` 包中的 `fmt.Sprintf` 函数，该函数将打印并格式化一条消息到字符串中。使用此函数，你可以构建包含字符和数字的字符串。你可以在
    Go 文档中在线找到有关此方法的更多信息。
- en: You will use everything you’ve learned so far, including how a struct is instantiated,
    how to set the attributes of a struct, pointers, how to increase an integer, and,
    of course, everything you’ve learned about HTTP servers so far.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用迄今为止所学的一切，包括如何实例化结构体，如何设置结构体的属性，指针，如何增加一个整数，以及当然，迄今为止你所学的关于 HTTP 服务器的所有内容。
- en: 'Observing the following steps will provide an elegant and effective solution:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下步骤将提供一个优雅且有效的解决方案：
- en: Create a folder called `page-counter`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `page-counter` 的文件夹。
- en: Create a file called `main.go`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件。
- en: Add the necessary imports to the `http` and `fmt` packages.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `http` 和 `fmt` 包添加必要的导入。
- en: Define a struct called `PageWithCounter` with `counter` as an integer attribute,
    `content`, and `heading` as a text attribute.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `PageWithCounter` 的结构体，其中包含一个整型属性 `counter`，一个文本属性 `content` 和一个文本属性
    `heading`。
- en: Add a `ServeHTTP` method to the struct that’s capable of displaying the content,
    the heading, and a message with the total number of views.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向结构体添加一个能够显示内容、标题和总浏览次数的消息的 `ServeHTTP` 方法。
- en: 'Create your `main` function and, inside, implement the following:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建你的 `main` 函数，并在其中实现以下内容：
- en: Instantiate three handlers of the `PageWithCounter` type, with `Hello World`,
    `Chapter 1`, and `Chapter 2` headings and some content.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例化三个`PageWithCounter`类型的处理器，具有`Hello World`、`Chapter 1`和`Chapter 2`标题和一些内容。
- en: Add the three handlers to the `/`, `/chapter1`, and `/``chapter2` routes.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将三个处理器添加到`/`、`/chapter1`和`/chapter2`路由。
- en: Run the server on port `8080`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在端口`8080`上运行服务器。
- en: 'When you run the server, you should see the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行服务器时，你应该看到以下内容：
- en: '![Figure 16.8: Output in the browser when you run the server for the first
    time](img/B18621_16_08.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图16.8：首次运行服务器时浏览器中的输出](img/B18621_16_08.jpg)'
- en: 'Figure 16.8: Output in the browser when you run the server for the first time'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8：首次运行服务器时浏览器中的输出
- en: 'If you refresh the page, you should see the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刷新页面，你应该看到以下内容：
- en: '![Figure 16.9: Output in the browser when you run the server for the second
    time](img/B18621_16_09.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图16.9：第二次运行服务器时浏览器中的输出](img/B18621_16_09.jpg)'
- en: 'Figure 16.9: Output in the browser when you run the server for the second time'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9：第二次运行服务器时浏览器中的输出
- en: 'Next, navigate to `chapter1` by typing `localhost:8080/chapter1` in the address
    bar. You should be able to see something along the lines of the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过在地址栏中输入`localhost:8080/chapter1`来导航到`chapter1`。你应该能够看到以下类似的内容：
- en: '![Figure 16.10: Output in the browser when you visit the chapter1 page for
    the first time](img/B18621_16_10.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图16.10：首次访问chapter1页面时浏览器中的输出](img/B18621_16_10.jpg)'
- en: 'Figure 16.10: Output in the browser when you visit the chapter1 page for the
    first time'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10：首次访问chapter1页面时浏览器中的输出
- en: 'Similarly, navigate to `chapter2`; you should be able to see the following
    increment in terms of the number of views:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，导航到`chapter2`；你应该能够看到以下关于查看次数的增加：
- en: '![Figure 16.11: Output in the browser when you visit the chapter2 page for
    the first time](img/B18621_16_11.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图16.11：首次访问chapter2页面时浏览器中的输出](img/B18621_16_11.jpg)'
- en: 'Figure 16.11: Output in the browser when you visit the chapter2 page for the
    first time'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11：首次访问chapter2页面时浏览器中的输出
- en: 'When you revisit `chapter1`, you should see an increase in the number of views,
    as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次访问`chapter1`时，你应该看到查看次数的增加，如下所示：
- en: '![Figure 16.12: Output in the browser when you visit the chapter1 page for
    the second time](img/B18621_16_12.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图16.12：第二次访问chapter1页面时浏览器中的输出](img/B18621_16_12.jpg)'
- en: 'Figure 16.12: Output in the browser when you visit the chapter1 page for the
    second time'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.12：第二次访问chapter1页面时浏览器中的输出
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter16/Activity16.01/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter16/Activity16.01/main.go).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在本书的GitHub仓库中找到，网址为[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter16/Activity16.01/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter16/Activity16.01/main.go)。
- en: In this activity, you learned how to create a server that responds to different
    requests on different pages with a specific static text, along with a counter
    on each page, with each counter independent from the others.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你学习了如何创建一个服务器，该服务器可以针对不同页面上的不同请求返回特定的静态文本，并在每个页面上都有一个计数器，每个计数器与其他计数器独立。
- en: Adding middleware
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加中间件
- en: 'Sometimes, you will need to create a lot of functions to handle HTTP requests,
    maybe serving different paths in a URL, all performing different actions. You
    might need to create a function to handle a server returning a list of users,
    one with a list of projects, a route for updating some details, and all the functions
    doing different things. It might happen, however, that although these functions
    perform different actions, they will also have something in common. A common example
    is when these functions have to be performed on a secured environment, which means
    only for users that have been logged in. Let’s look at a very simple example and
    consider the following two functions:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要创建很多函数来处理HTTP请求，可能是在URL的不同路径上提供不同的服务，所有这些都在执行不同的操作。你可能需要创建一个函数来处理返回用户列表的服务器，一个用于项目列表，一个用于更新某些细节的路由，所有这些函数都在做不同的事情。然而，尽管这些函数执行不同的操作，它们也可能有一些共同点。一个常见的例子是，当这些函数需要在安全环境中执行时，这意味着只有登录的用户才能执行。让我们看一个非常简单的例子，并考虑以下两个函数：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Both functions will display a sentence that starts with `Hello there,`. Let’s
    find a way to extract this part of the behavior of these functions and create
    a third function that will be used to perform the act of writing the initial cheering
    message:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 两个函数都将显示以“你好，”开头的句子。让我们找到一种方法来提取这些函数行为的一部分，并创建一个第三函数，该函数将用于执行写入初始欢呼信息的操作：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This function has the following signature:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数具有以下签名：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This means it is called `Hello`, accepts `http.HandlerFunc` as a parameter,
    and returns a result against `http.HandlerFunc`. This parameter is called `next`
    because it is the function that we will want to run next. Let’s look at the body
    of the function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它被命名为`Hello`，接受`http.HandlerFunc`作为参数，并返回对`http.HandlerFunc`的结果。此参数被称为`next`，因为它是我们想要运行的下一个函数。让我们看看函数的主体：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, it returns a function that implements the `http.HandlerFunc`
    type and has the correct arguments and return type. This function will write a
    message stating `Hello there,` to the response writer, `w`, and then call the
    `next` function with the same response writer and request that the function without
    a name receives.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它返回一个实现`http.HandlerFunc`类型并具有正确参数和返回类型的函数。这个函数将向响应写入器`w`写入一条消息，指出“你好，”，然后调用`next`函数，使用相同的响应写入器和请求调用没有名称的函数。
- en: 'Now, let’s refactor our code to make it a bit easier to read. We’ll create
    two functions for the actions we want to perform:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重构我们的代码，使其更容易阅读。我们将为要执行的操作创建两个函数：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s see what our file looks like so far:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看到目前为止我们的文件看起来像什么：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, we have our `Hello` function and two functions returning two
    different sentences to the response writer. The last step is to associate these
    functions with a path, like so:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们有`Hello`函数和两个函数，它们向响应写入器返回两个不同的句子。最后一步是将这些函数与一个路径关联起来，如下所示：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, we pass functions 1 and 2 to each route. If you run the code
    on your machine and go to `http://localhost:8085/hello1`, you will see a message
    stating `this is function 1`. What we have not used yet, though, is the `Hello`
    function. Let’s rewrite the last block of code and make use of it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们将函数1和函数2传递给每个路由。如果您在自己的机器上运行此代码并访问`http://localhost:8085/hello1`，您将看到一个显示“这是函数1”的消息。尽管如此，我们还没有使用`Hello`函数。让我们重写最后一块代码并使用它：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you run this program again, you will see that the message has now changed
    to `Hello there, this is function 1`. The `Hello` function is essentially running
    before the `Function1` function and after doing its own work, it calls `Function`
    so that that function can also do its job. We call the `Hello` function `Middleware`
    as it acts as the man in the middle – it captures the request, does some work,
    and then calls the next function in line. By doing this, it is possible to chain
    many middleware by doing something like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再次运行此程序，您将看到消息已更改为“你好，这是函数1”。`Hello`函数实际上在`Function1`函数之前运行，并在完成自己的工作后，调用`Function`，以便该函数也可以完成其工作。我们将`Hello`函数称为`Middleware`，因为它充当中间人——它捕获请求，做一些工作，然后调用下一个函数。通过这样做，我们可以通过执行如下操作来链式连接许多中间件：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can use this pattern to perform many common actions before or after the
    actual function that needs to be associated with a path on the URL.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这种模式在需要与URL路径关联的实际函数之前或之后执行许多常见操作。
- en: Dynamic content
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态内容
- en: 'A server that serves only static content is useful, but there is much more
    that can be done. An HTTP server can deliver content based on a more granular
    request, which is done by passing some parameters to the server. There are many
    ways to do so, but one simple way is to pass parameters to `querystring`. If the
    URL of the server is as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 仅提供静态内容的服务器很有用，但还有更多的事情可以做。HTTP服务器可以根据更细粒度的请求交付内容，这是通过向服务器传递一些参数来完成的。有多种方法可以做到这一点，但一种简单的方法是将参数传递给`querystring`。如果服务器的URL如下所示：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we can add something like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加如下内容：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here,`?name=john` is called a `querystring` string as it is a string representing
    a query. In this case, `querystring` sets a variable called `name` with a value
    of `john`. This way of passing parameters is generally used with `GET` requests,
    while a `POST` request will generally make use of the body of the request to send
    parameters. We will begin by looking at how to accept parameters for a `GET` request
    since this request is made by simply opening our browser on a specific address.
    We will see how to handle a `POST` request through a form later.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`?name=john` 被称为 `querystring` 字符串，因为它是一个表示查询的字符串。在这种情况下，`querystring` 设置了一个名为
    `name` 的变量，其值为 `john`。这种方式通常用于 `GET` 请求，而 `POST` 请求通常使用请求体来发送参数。我们将首先看看如何接受 `GET`
    请求的参数，因为这种请求是通过简单地在我们的浏览器上打开一个特定地址来进行的。我们将在稍后通过表单查看如何处理 `POST` 请求。
- en: In the next exercise, you will learn how to return different texts as responses
    to HTTP requests, where the text depends on what values the user puts in the `querystring`
    string in the address bar.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将学习如何根据用户在地址栏中 `querystring` 字符串中输入的值返回不同的文本作为 HTTP 请求的响应。
- en: Exercise 16.03 – personalized welcome
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 16.03 – 个性化欢迎
- en: 'In this exercise, we will create an HTTP server that can cheer us, but instead
    of a general `hello world` message, we will provide a message depending on our
    name. The idea is that, by opening the browser on the server’s URL and adding
    a parameter called `name`, the server will welcome us with a message stating `hello`,
    followed by the value of the `name` parameter. The server is very simple and does
    not have sub-pages, but contains a dynamic element that constitutes a starting
    point for more complex situations:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个可以为我们欢呼的 HTTP 服务器，但与一般的 `hello world` 消息不同，我们将提供一个基于我们名字的消息。想法是，通过在服务器的
    URL 上打开浏览器并添加一个名为 `name` 的参数，服务器将用一条消息欢迎我们，该消息以 `hello` 开头，后跟 `name` 参数的值。服务器非常简单，没有子页面，但它包含一个动态元素，这构成了更复杂情况的一个起点：
- en: 'Create a new folder called `personalised-welcome` and, inside the folder, create
    a file called `main.go`. Inside the file, add the package name:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `personalised-welcome` 的新文件夹，并在文件夹内创建一个名为 `main.go` 的文件。在文件内添加包名：
- en: '[PRE34]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, add the required imports:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加所需的导入：
- en: '[PRE35]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: These are the same imports we used in the previous exercises and activities,
    so there is nothing new. We will not use handlers in this exercise as it is much
    smaller, but we will make use of the `http.handleFunc` function.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是我们之前练习和活动中使用的相同导入，所以没有新的内容。在这个练习中，我们不会使用处理器，因为它很小，但我们将利用 `http.handleFunc`
    函数。
- en: 'Now, add the following code after the imports:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在导入之后添加以下代码：
- en: '[PRE36]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is the definition of a function that can be used as a handling function
    for an HTTP path.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是定义一个可以作为 HTTP 路径处理函数使用的函数的定义。
- en: 'Now, save the query to a variable using the `Query` method URL from the request:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用请求的 `URL` 对象上的 `Query` 方法将查询保存到变量中：
- en: '[PRE37]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `Query` method on the `URL` object of the request returns a `map[string][]string`
    string with all the parameters sent through `querystring` in the URL. We then
    assign this map to a variable, `vl`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求的 `URL` 对象上的 `Query` 方法返回一个 `map[string][]string` 字符串，其中包含通过 URL 中的 `querystring`
    发送的所有参数。然后我们将这个映射分配给一个变量，`vl`。
- en: 'At this point, we need to get the value of a specific parameter called `name`,
    so we get the value from the `name` parameter:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们需要获取一个名为 `name` 的特定参数的值，所以我们从 `name` 参数获取值：
- en: '[PRE38]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, we have an assignment to two variables, but only one value comes
    from `vl["name"]`. The second variable, `ok`, is a Boolean that tells us whether
    the `name` key exists.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们有两个变量的赋值，但只有一个值来自 `vl["name"]`。第二个变量 `ok` 是一个布尔值，它告诉我们 `name` 键是否存在。
- en: 'If the `name` parameter has not been passed and we want an error message to
    appear, we must add it if the variable is not found – in other words, if the `ok`
    variable is false:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有传递 `name` 参数并且我们想要显示错误消息，我们必须在变量未找到时添加它——换句话说，如果 `ok` 变量为假：
- en: '[PRE39]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The conditional code gets called if the key does not exist in the slice, and
    it writes a `400` code (bad request) to the header, as well as a message to the
    response writer stating that the name has not been sent as a parameter. We stop
    the execution with a `return` statement to prevent further actions.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果切片中不存在键，则调用条件代码，并将 `400` 状态码（错误请求）写入标题，以及一条消息到响应写入器，说明没有发送 `name` 参数。我们使用
    `return` 语句停止执行，以防止进一步的操作。
- en: 'At this point, write a valid message to the response writer:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，向响应写入器写入一个有效的消息：
- en: '[PRE40]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This code formats a string and injects the name into it. The `fmt.Sprintf` function
    is used to format, while `strings.Join` is used to transform the `name` slice
    into a string. Notice that the `name` variable is set to the value of `vl["name"]`,
    but `vl` is a `map[string][]string` string, which means that it is a map with
    string keys whose values are slices of strings; hence, `vl["name"]` is a slice
    of strings and needs to be transformed into a single string. The `strings.Join`
    function takes all the elements of the slice and builds a single string using
    `","` as a separator. Other characters could have also been used as separators.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码格式化一个字符串并将名称注入其中。使用`fmt.Sprintf`函数进行格式化，而使用`strings.Join`将`name`切片转换为字符串。请注意，`name`变量被设置为`vl["name"]`的值，但`vl`是一个`map[string][]string`字符串，这意味着它是一个具有字符串键的映射，其值是字符串切片；因此，`vl["name"]`是一个字符串切片，需要将其转换为单个字符串。`strings.Join`函数接受切片的所有元素，并使用`","`作为分隔符构建一个单独的字符串。也可以使用其他字符作为分隔符。
- en: 'The last part of the file you have to write is as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要编写的文件的最后一部分如下：
- en: '[PRE41]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As always, a `main()` function is created, and then the `Hello` function is
    associated with the `"/"` path and the server is started. Here is the output of
    three different URLs – two valid ones, and one with a missing parameter:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如往常一样，创建了一个`main()`函数，然后将`Hello`函数与`"/"`路径关联，并启动了服务器。以下是三个不同URL的输出——两个有效的和一个缺少参数的：
- en: '![Figure 16.13: The server’s output when requesting the page with the name
    John](img/B18621_16_13.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图16.13：请求名为John的页面时服务器的输出](img/B18621_16_13.jpg)'
- en: 'Figure 16.13: The server’s output when requesting the page with the name John'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.13：请求名为John的页面时服务器的输出
- en: 'The preceding figure shows the output when we set the query parameter in the
    URL to the name John. If we change the name in the query parameter in the URL,
    we will see the new value:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了我们将URL中的查询参数设置为John时的输出。如果我们更改URL中查询参数的名称，我们将看到新的值：
- en: '![Figure 16.14: The server’s output when requesting the page with the name
    Will](img/B18621_16_14.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图16.14：请求名为Will的页面时服务器的输出](img/B18621_16_14.jpg)'
- en: 'Figure 16.14: The server’s output when requesting the page with the name Will'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.14：请求名为Will的页面时服务器的输出
- en: 'If we do not set the query parameter, we will receive an error message, as
    shown here:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不设置查询参数，我们将收到一个错误消息，如下所示：
- en: '![Figure 16.15: The server outputting an error message when requesting a page
    without a name](img/B18621_16_15.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图16.15：请求不带名称的页面时服务器输出的错误信息](img/B18621_16_15.jpg)'
- en: 'Figure 16.15: The server outputting an error message when requesting a page
    without a name'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.15：请求不带名称的页面时服务器输出的错误信息
- en: Next, we’ll explore the concept of templates.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨模板的概念。
- en: Templating
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板化
- en: 'Although JSON can be the best choice when complex data structures have to be
    shared across software programs, in general, this is not the case when the HTTP
    server is supposed to be consumed by humans. In the previous exercises and activities,
    the chosen way to format a piece of text has been the `fmt.Sprintf` function,
    which is good for formatting texts, but is simply insufficient when more dynamic
    and complex text is required. As you will have noticed in the previous exercise,
    the message that was returned in case a name was passed as a parameter to the
    URL observed a specific pattern, and this is where a new concept comes in – the
    template. A template is a skeleton from which complex entities can be developed.
    Essentially, a template is like text with some blanks. A template engine will
    take some values and fill in the blanks, as shown in the following diagram:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在需要跨软件程序共享复杂数据结构时，JSON可能是最佳选择，但在一般情况下，当HTTP服务器预期由人类使用时，情况并非如此。在之前的练习和活动中，选择格式化文本的方式是使用`fmt.Sprintf`函数，这对于格式化文本是好的，但当需要更多动态和复杂的文本时，它就远远不够了。正如你在之前的练习中注意到的，当将名称作为参数传递给观察到的URL时，返回的消息遵循一个特定的模式，这就是新概念出现的地方——模板。模板是一个复杂的实体可以从中发展出来的骨架。本质上，模板就像带有一些空白的文本。模板引擎将取一些值并填充这些空白，如下面的图所示：
- en: '![Figure 16.16: Templating example](img/B18621_16_16.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图16.16：模板示例](img/B18621_16_16.jpg)'
- en: 'Figure 16.16: Templating example'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.16：模板示例
- en: As you can see, `{{name}}` is a placeholder, and, when a value is passed through
    to the engine, the placeholder is modified with that value.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`{{name}}`是一个占位符，当通过引擎传递值时，占位符会使用该值进行修改。
- en: We see templates everywhere. We have templates for Word documents, where we
    just fill in what is missing to produce new documents that all differ from one
    another. A teacher might have some templates for their lessons and will develop
    different lessons from that same template. Go provides two different templating
    packages – one for text and one for HTML. As we are working with HTTP servers
    and we want to produce a web page, we will use the HTML templating package, but
    the interface is the same for the text template library. Although the templating
    packages are good enough for any real-world application, several other external
    packages can be used to improve performance. One of these is the `hero` template
    engine, which is much faster than the standard Go templating package.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到处都能看到模板。我们有Word文档的模板，我们只需填写缺失的部分，就可以生成新的文档，这些文档彼此都不同。一位老师可能有一些用于他们课程的模板，并从相同的模板中开发不同的课程。Go提供了两个不同的模板包——一个用于文本，一个用于HTML。由于我们正在处理HTTP服务器，并且我们想要生成一个网页，我们将使用HTML模板包，但文本模板库的接口是相同的。尽管模板包对于任何实际应用都足够好，但还可以使用几个其他外部包来提高性能。其中之一是`hero`模板引擎，它比标准的Go模板包快得多。
- en: 'The Go templating package provides a placeholder language where we can use
    things such as the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Go模板包提供了一个占位符语言，我们可以使用以下内容：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is a simple code block that will make the template engine replace the
    `name` variable with a provided value, but more complex situations can be handled
    via conditionals:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的代码块，它将使模板引擎将`name`变量替换为提供的值，但更复杂的情况可以通过条件语句来处理：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, if an `age` parameter is not null, the template will contain `Hello`;
    otherwise, it will contain `bye`. Each conditional needs an `{{end}}` placeholder
    to determine its ending.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果`age`参数不为空，模板将包含`Hello`；否则，它将包含`bye`。每个条件都需要一个`{{end}}`占位符来确定其结束。
- en: 'Variables in a template, however, do not need to be simple numbers or strings;
    they can be objects. In this case, if we have a struct with a field called `ID`,
    we can reference this field in the template like so:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中的变量不需要是简单的数字或字符串；它们可以是对象。在这种情况下，如果我们有一个名为`ID`的字段的结构体，我们可以在模板中这样引用这个字段：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is very handy as we can pass a struct to the template instead of many single
    parameters.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便，因为我们可以将一个结构体传递给模板，而不是许多单个参数。
- en: In the next exercise, you will learn how to use the basic templating functionalities
    of Go to create pages with custom messages, as you’ve done before, but just in
    a more elegant way.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将学习如何使用Go的基本模板功能来创建带有自定义消息的页面，就像你之前做的那样，但方式更加优雅。
- en: Exercise 16.04 – templating our pages
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16.04 – 模板化我们的页面
- en: 'This exercise aims to have you build a more structured web page, use a template,
    and fill it with parameters from the URL’s `querystring`. In this scenario, we
    want to display basic information for a customer and hide some information when
    the data is missing. A customer has `id`, `name`, `surname`, and `age` values,
    and if any of these values are missing, they will not be displayed. Unless the
    data is the `id` value, as in this case, an error message will be displayed:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习旨在帮助你构建一个结构更清晰的网页，使用模板，并用URL的`querystring`中的参数填充它。在这种情况下，我们希望显示客户的基本信息，并在数据缺失时隐藏一些信息。客户有`id`、`name`、`surname`和`age`值，如果这些值中的任何一个缺失，则不会显示。除非数据是`id`值，就像在这个例子中，将会显示错误信息：
- en: 'Begin by creating a `server-template` folder that contains a `main.go` file.
    Then, add the usual package and some imports:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个包含`main.go`文件的`server-template`文件夹。然后，添加通常的包和一些导入：
- en: '[PRE45]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here, we use two new imports: `html/template` for our templating and `strconv`
    to convert strings into numbers (this package could also work the other way around,
    but there are better solutions for formatting text).'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用了两个新的导入：`html/template`用于模板，`strconv`用于将字符串转换为数字（这个包也可以反过来工作，但还有更好的文本格式化解决方案）。
- en: 'Now, write the following:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，写下以下内容：
- en: '[PRE46]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is a raw string that contains some HTML and templating code, which is wrapped
    by `{{}}`. We will analyze this now.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个包含一些HTML和模板代码的原始字符串，这些代码被`{{}}`包裹。我们现在将分析这个字符串。
- en: '`{{.ID}}` is essentially a placeholder that tells the template engine that
    wherever this code is found, it will be substituted by a struct’s attribute called
    `ID`. The Go templating engine works with structs, so essentially, a struct will
    be passed to the engine and its attributes’ values will be used to fill the placeholders.
    `{{if .ID}}` is a conditional that tells the template that what happens next will
    depend on the value of `ID`. In this case, if `ID` is not an empty string, the
    template will display the customer’s details; otherwise, it will display `<p>Data
    not available</p>`, which is wrapped between the `{{else}}` and `{{end}}` placeholders.
    As you can see, there are many more conditionals nested inside the first one.
    At each list item, there is a `<li>` tag, which is wrapped, for example, by `{{if
    .Name}}` and terminated with `{{end}}`.'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{{.ID}}`基本上是一个占位符，告诉模板引擎，无论此代码出现在何处，它将被一个名为`ID`的struct属性所替代。Go模板引擎与struct一起工作，所以基本上，一个struct将被传递到引擎，其属性值将用于填充占位符。`{{if
    .ID}}`是一个条件，告诉模板接下来发生的事情将取决于`ID`的值。在这种情况下，如果`ID`不是空字符串，模板将显示客户的详细信息；否则，它将显示`<p>Data
    not available</p>`，这是在`{{else}}`和`{{end}}`占位符之间包装的。如您所见，第一个条件内部嵌套了更多的条件。在每个列表项中，都有一个`<li>`标签，例如，被`{{if
    .Name}}`包装，并以`{{end}}`结束。'
- en: 'Now that we have a string template, let’s create a struct with the correct
    attributes. To fill in the template, write the following:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们已经有了字符串模板，让我们创建一个具有正确属性的struct。为了填充模板，写下以下内容：
- en: '[PRE47]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This struct is self-explanatory. It contains all the attributes needed by the
    template.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个struct是自我解释的。它包含模板所需的所有属性。
- en: 'Define the `handler` function and set a variable to the map of values in `querystring`:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`handler`函数并将一个变量设置为`querystring`中的值映射：
- en: '[PRE48]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Instantiate a `cust` variable of the `Customer` type:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化一个`cust`变量，类型为`Customer`：
- en: '[PRE49]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The variable now has all its attributes set to the default values, and we need
    to grab the passed values from the URL. To do so, write the following:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量现在所有属性都已设置为默认值，我们需要从URL中获取传递的值。为此，写下以下内容：
- en: '[PRE50]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you can see, the parameters are taken as they are from the values map, and
    if they exist, they are used to set the value of the related `cust` attribute.
    To check whether these parameters exist, we again used the `ok` variable, which
    is set to a Boolean with a value of `true` in case the map contains the requested
    key. The last attribute, `Age`, is handled slightly differently:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，参数直接从值映射中获取，如果存在，则用于设置相关`cust`属性的值。为了检查这些参数是否存在，我们再次使用了`ok`变量，该变量在映射包含请求的键时设置为具有值`true`的布尔值。最后一个属性`Age`的处理略有不同：
- en: '[PRE51]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is because `strconv.Atoi` returns an error in case the parameter that’s
    passed is not a number. In general, we should handle the errors but, in this case,
    we’ll just ignore it and we won’t display any age-related information if the age
    provided is not a number.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是因为`strconv.Atoi`在传递的参数不是数字时返回错误。通常，我们应该处理错误，但在这个例子中，我们将忽略它，并且如果提供的年龄不是数字，则不会显示任何与年龄相关的信息。
- en: 'Next, write the following:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，写下以下内容：
- en: '[PRE52]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This creates a template object called `test` that contains the content of the
    string that you created at the outset. Again, ignore the error as we are sure
    that the template we’ve written is a valid one. In production, however, all the
    errors should be dealt with.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这创建了一个名为`test`的模板对象，其中包含您最初创建的字符串内容。再次忽略错误，因为我们确信我们编写的模板是有效的。然而，在生产环境中，应该处理所有错误。
- en: 'You can now finish writing the function:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以完成函数的编写：
- en: '[PRE53]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, the template is executed using the `cust` struct; its content is sent
    directly to `w ResponseWriter` without the need to call the `Write` method manually.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，模板使用`cust` struct执行；其内容直接发送到`w ResponseWriter`，无需手动调用`Write`方法。
- en: 'What’s missing now is the `main` method, which is fairly simple. Write the
    following:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在缺少的是`main`方法，这相当简单。写下以下内容：
- en: '[PRE54]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Here, simply speaking, the main path is associated with the `Hello` function,
    and the server is then started.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单来说，主路径与`Hello`函数相关联，然后服务器启动。
- en: The performance of this code is not very high as we create a template for every
    request. The template could be created in `main` and then passed to a handler,
    which could have a `ServeHTTP` method like the `Hello` function you’ve just written.
    The code has been kept simple here to focus on templating.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码的性能并不很高，因为我们为每个请求创建了一个模板。这个模板可以在`main`中创建，然后传递给一个处理程序，这个处理程序可以有一个类似于你刚刚编写的`Hello`函数的`ServeHTTP`方法。这里的代码被保持简单，以便专注于模板化。
- en: 'Now, if you start the server and visit the following pages, you should see
    some output similar to the following:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你启动服务器并访问以下页面，你应该会看到一些类似于以下内容的输出：
- en: '![Figure 16.17: Templated response with blank parameters](img/B18621_16_17.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图16.17：带有空白参数的模板响应](img/B18621_16_17.jpg)'
- en: 'Figure 16.17: Templated response with blank parameters'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.17：带有空白参数的模板响应
- en: 'Now, you can add a query parameter called `id` and make it equal to `1` in
    the URL by visiting `localhost:8080/?id=1`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在URL中添加一个名为`id`的查询参数，并通过访问`localhost:8080/?id=1`使其等于`1`：
- en: '![Figure 16.18: Templated response with just the ID specified](img/B18621_16_18.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图16.18：仅指定ID的模板响应](img/B18621_16_18.jpg)'
- en: 'Figure 16.18: Templated response with just the ID specified'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.18：仅指定ID的模板响应
- en: 'Then, you can add a value for the name parameter by going to `localhost:8080/?id=1&name=John`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过访问`localhost:8080/?id=1&name=John`为名称参数添加一个值：
- en: '![Figure 16.19: Templated response with the ID and name specified](img/B18621_16_19.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图16.19：指定ID和名称的模板响应](img/B18621_16_19.jpg)'
- en: 'Figure 16.19: Templated response with the ID and name specified'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.19：指定ID和名称的模板响应
- en: 'Finally, you also add an age by going to `localhost:8080/?id=1&name=John&age=40`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你也可以通过访问`localhost:8080/?id=1&name=John&age=40`添加年龄：
- en: '![Figure 16.20: Templated response with the ID, name, and age specified](img/B18621_16_20.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图16.20：指定ID、名称和年龄的模板响应](img/B18621_16_20.jpg)'
- en: 'Figure 16.20: Templated response with the ID, name, and age specified'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.20：指定ID、名称和年龄的模板响应
- en: Here, each parameter in `querystring` is displayed, if valid, in the web application.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果`querystring`中的每个参数有效，它都会在Web应用程序中显示出来。
- en: Static resources
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态资源
- en: Everything you’ve learned so far in this book, up to the previous exercise,
    is sufficient to build web applications and dynamic websites; you just need to
    put all the pieces together.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，直到之前的练习为止，你所学到的知识已经足够构建Web应用程序和动态网站；你只需要把所有这些部件组合起来。
- en: What you’ve been doing in this chapter is returning messages that are different
    but all hardcoded as strings. Even dynamic messages have been based on templates
    hardcoded in the source file of the exercises and activities. Now, let’s consider
    something. In the case of the first `hello world` server, the message never changed.
    If we wanted to modify the message and return a `Hello galaxy` message, we would
    have to change the text in the code and then recompile and/or run the server again.
    What if you wanted to sell your simple “hello” server and give the option to everybody
    to specify a custom message? Of course, you should give the source code to everybody
    so that they can recompile and run the server.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中你所做的是返回不同的消息，但这些消息都是作为字符串硬编码的。即使是动态消息，也基于在练习和活动源文件中硬编码的模板。现在，让我们考虑一下。对于第一个“hello
    world”服务器，消息从未改变。如果我们想修改消息并返回一个“Hello galaxy”的消息，我们就必须更改代码中的文本，然后重新编译和/或再次运行服务器。如果你想要出售你的简单“hello”服务器并给每个人指定自定义消息的选项呢？当然，你应该把源代码给每个人，这样他们就可以重新编译和运行服务器。
- en: Although you might want to embrace open source code, this might not be the ideal
    way to distribute an application, and we need to find a better way to separate
    the message from the server. A solution to that is to serve static files, which
    are files that are loaded by your program as external resources. These files do
    not change, do not get compiled, and are loaded and manipulated by your program.
    One such example may be templates, as seen previously, because they are just text
    and you can use template files instead of adding the templates as text to your
    code. Another simple example of static resources is if you want to include styling
    files such as CSS in your web page. You will see how to do that in the following
    exercises and activities. You’ll learn how to serve a specific file or a specific
    folder, and then you’ll learn how to serve dynamic files with a static template.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能想拥抱开源代码，但这可能不是分发应用程序的理想方式，我们需要找到一种更好的方法来将消息与服务器分离。一个解决方案是提供静态文件，这些文件是由你的程序作为外部资源加载的。这些文件不会改变，不会编译，并且由你的程序加载和处理。一个这样的例子可能是模板，如之前所见，因为它们只是文本，你可以使用模板文件而不是将模板作为文本添加到你的代码中。另一个静态资源的简单例子是，如果你想在你的网页中包含样式文件，如
    CSS。你将在接下来的练习和活动中看到如何做到这一点。你将学习如何提供特定的文件或特定的文件夹，然后你将学习如何使用静态模板提供动态文件。
- en: Exercise 16.05 – creating a Hello World server using a static file
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 16.05 – 使用静态文件创建 Hello World 服务器
- en: 'In this exercise, you will create your Hello World server but with a static
    HTML file. What we want is to have a simple server with one handler function that
    looks for a specific file with a specific name, which will be served as the output
    for every path. In this case, you will need to create multiple files in your project:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建你的 Hello World 服务器，但使用静态 HTML 文件。我们想要的是一个简单的服务器，它有一个查找特定文件（具有特定名称）的处理函数，该文件将作为每个路径的输出。在这种情况下，你需要在你的项目中创建多个文件：
- en: 'Create a folder called `static-file` and, inside it, create a file called `index.html`.
    Then, insert the following code for a pretty simple HTML file with a title and
    an `h1` tag that states our welcome message:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `static-file` 的文件夹，并在其中创建一个名为 `index.html` 的文件。然后，插入以下代码，创建一个相当简单的 HTML
    文件，其中包含标题和声明欢迎信息的 `h1` 标签：
- en: '[PRE55]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, create a file called `main.go` and start writing the necessary imports:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `main.go` 的文件，并开始编写必要的导入：
- en: '[PRE56]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, write the `main` function:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写 `main` 函数：
- en: '[PRE57]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, write the `handler` function:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编写 `handler` 函数：
- en: '[PRE58]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This is where the magic happens. Here a normal `http.HandleFunc` is being called
    with a `"/"` path as the first parameter, after which a handler function is passed,
    which contains a single instruction:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是魔法发生的地方。这里一个正常的 `http.HandleFunc` 被调用，其第一个参数是 `"/"` 路径，之后传递一个处理函数，该函数包含一条指令：
- en: '[PRE59]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This sends the content of the `index.html` file to `ResponseWriter`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会将 `index.html` 文件的内容发送到 `ResponseWriter`。
- en: 'Now, write the last part:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写最后一部分：
- en: '[PRE60]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As is always the case, this starts the server, logs in case of an error, and
    exits the program.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常一样，这会启动服务器，在出错时记录，并退出程序。
- en: 'Now, save the file and run the program with the following command:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，保存文件，并使用以下命令运行程序：
- en: '[PRE61]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If you open your browser on the `localhost:8080` page, you should see the following:'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你打开浏览器访问 `localhost:8080` 页面，你应该看到以下内容：
- en: '![Figure 16.21: Hello World with a static template file](img/B18621_16_21.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.21：带有静态模板文件的 Hello World](img/B18621_16_21.jpg)'
- en: 'Figure 16.21: Hello World with a static template file'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.21：带有静态模板文件的 Hello World
- en: 'Next, without stopping your server, just change the HTML file, `index.html`,
    and modify line `8`, where you see the following:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在不停止服务器的情况下，只需更改 HTML 文件，即 `index.html`，并修改第 `8` 行，在那里你会看到以下内容：
- en: '[PRE62]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Change the text in the `<h1>` tag, like so:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改 `<h1>` 标签中的文本，如下所示：
- en: '[PRE63]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Save the `index.html` file and, without touching the terminal and without restarting
    your server, just refresh your browser on the same page. You should now see the
    following:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `index.html` 文件，并且不要触摸终端，也不要重新启动服务器，只需在同一页面上刷新浏览器。你现在应该看到以下内容：
- en: '![Figure 16.22: Hello World server with the static template file modified](img/B18621_16_22.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.22：带有静态模板文件的 Hello World 服务器](img/B18621_16_22.jpg)'
- en: 'Figure 16.22: Hello World server with the static template file modified'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.22：修改后的静态模板文件的 Hello World 服务器
- en: So, even if the server is running, it will pick up the new version of the file.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，即使服务器正在运行，它也会获取文件的新版本。
- en: In this exercise, you learned how to use a static HTML file to serve a web page,
    as well as how detaching the static resources from your application allows you
    to change your served page without having to restart your application.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你学习了如何使用静态HTML文件来服务一个网页，以及如何将静态资源从你的应用程序中分离出来，这样你就可以在不重新启动应用程序的情况下更改你提供的服务页面。
- en: Getting some style
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取一些样式
- en: So far, you’ve seen how to serve one static page and you might consider serving
    a few pages with the same method, maybe creating a handler struct with the name
    of the file to serve as an attribute. This might be impractical for large numbers
    of pages, although, in some cases, it is necessary. A web page, however, does
    not include just HTML code – it may also include images and styles, as well as
    some frontend code.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何服务一个静态页面，你可能考虑使用相同的方法来服务几个页面，也许创建一个具有要服务的文件名称作为属性的处理器结构。对于大量页面来说，这可能不太实用，尽管在某些情况下这是必要的。然而，一个网页不仅仅包含HTML代码——它还可能包含图片和样式，以及一些前端代码。
- en: It is not within the scope of this book to teach you how to build HTML pages,
    and even less how to write JavaScript code or CSS style sheets, but you need to
    know how to serve these documents as we use a small CSS file to build our example.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的范围并不包括教你如何构建HTML页面，甚至更少教你如何编写JavaScript代码或CSS样式表，但你需要知道如何作为我们使用一个小CSS文件构建示例来服务这些文档。
- en: Serving static files and putting templates in different files, or generally
    using external resources, is a good way to separate concerns on our projects and
    make our projects more manageable and maintainable, so you should try to follow
    this approach in all your projects.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 服务静态文件并将模板放在不同的文件中，或者通常使用外部资源，是在我们的项目中分离关注点的好方法，可以使我们的项目更易于管理和维护，因此你应该尝试在所有项目中遵循这种方法。
- en: 'To add a style sheet to your HTML pages, you need to add a tag like this:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要将样式表添加到你的HTML页面中，你需要添加一个像这样的标签：
- en: '[PRE64]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This injects the CSS file into the page as a “stylesheet,” but this is reported
    here just by way of an example, in case you are interested in learning how to
    write HTML.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这将CSS文件注入页面作为“样式表”，但这在这里只是作为一个例子，以防你对学习如何编写HTML感兴趣。
- en: 'You have also seen that we have served files, reading them from the filesystem
    one by one, but Go provides us with an easy function to do the job for us:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你还看到我们服务了文件，逐个从文件系统中读取它们，但Go为我们提供了一个简单的函数来完成这项工作：
- en: '[PRE65]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Essentially, `http.FileServer` creates what its name says: a server serving
    external files. It takes it from the directory defined in `http.Dir`. Whatever
    file we put inside the `./public` directory will be automatically accessible in
    the address bar:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`http.FileServer`创建了一个它名字所描述的服务外部文件的服务器。它从`http.Dir`中定义的目录中获取。无论我们在`./public`目录中放置什么文件，都会在地址栏中自动可访问：
- en: '[PRE66]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This seems good enough. However, in a real-world scenario, you do not want
    to expose your folder names and instead specify a different name for your static
    resources. This can be achieved as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来足够好了。然而，在现实世界的场景中，你不想暴露你的文件夹名称，而是为你的静态资源指定一个不同的名称。这可以通过以下方式实现：
- en: '[PRE67]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: You may have noticed that the `http.FileServer` function is wrapped by an `http.StripPrefix`
    function, which we use to associate the requested path with the correct files
    on the filesystem. Essentially, we want the path of the `/statics` form to be
    available and to bind it to the content of the `public` folder. The `StripePrefix`
    function will remove the `"/statics/"` prefix from the request and pass it to
    the file server, which will just get the name of the file to serve and search
    for it in the `public` folder.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到`http.FileServer`函数被`http.StripPrefix`函数包装，我们使用它来将请求的路径与文件系统上的正确文件关联。本质上，我们希望`/statics`路径可用，并将其绑定到`public`文件夹的内容。`StripPrefix`函数将移除请求中的`"/statics/"`前缀，并将其传递给文件服务器，文件服务器将只获取要服务的文件名，并在`public`文件夹中搜索它。
- en: It is not necessary to use these wrappers if you do not want to change the name
    of the path and folder, but this solution is general and works everywhere, so
    you can utilize it in other projects without having to worry.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想更改路径和文件夹的名称，则不需要使用这些包装器，但这个解决方案是通用的，并且可以在任何地方使用，因此你可以在其他项目中使用它而不用担心。
- en: Exercise 16.06 – a stylish welcome
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16.06 – 一个时尚的欢迎
- en: 'This exercise aims to help you display a welcome page while making use of some
    external static resources. We will adopt the same approach as in *Exercise 16.05*,
    but we will add some extra files and code. We will place some stylesheets in a
    `statics` folder, and we will serve them so that they can be used by other pages
    served by the same server:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习旨在帮助你显示一个欢迎页面，同时使用一些外部静态资源。我们将采用与*练习16.05*相同的方法，但我们将添加一些额外的文件和代码。我们将把一些样式表放在一个`statics`文件夹中，并且我们将提供它们，以便它们可以被同一服务器提供的其他页面使用：
- en: 'By way of a first step, create a folder called `stylish-welcome` and, inside
    this folder, add a file called `index.html`. Then, incorporate the following content:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，创建一个名为`stylish-welcome`的文件夹，并在该文件夹内添加一个名为`index.html`的文件。然后，加入以下内容：
- en: '[PRE68]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As you can see, there are few differences compared with the previous HTML; we
    have a paragraph with some more text, wrapped by the `<p>` tag, and, inside the
    `<head>` tag, we include three links to external resources.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，与之前的HTML相比，差异很少；我们有一个包含更多文本的段落，由`<p>`标签包裹，并且在`<head>`标签内，我们包含了指向外部资源的三个链接。
- en: 'Now, create a folder called `public` inside your `stylish-welcome` folder and
    create three files therein with the following names and content:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你的`stylish-welcome`文件夹内创建一个名为`public`的文件夹，并在其中创建三个文件，名称和内容如下：
- en: '[PRE69]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, go back to your main project folder, `stylish-welcome`, and create the
    `main.go` file. The content at the start corresponds exactly to that in one of
    the previous exercises:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到你的主项目文件夹`stylish-welcome`，并创建一个名为`main.go`的文件。文件开头的内容与之前的某个练习中的内容完全一致：
- en: '[PRE70]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, add the following code to handle the static files:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加以下代码来处理静态文件：
- en: '[PRE71]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This code adds a handler to the `/statics/` path and does so through an `http.FileServer`
    function, which returns a static file handler.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码为`/statics/`路径添加了一个处理器，通过`http.FileServer`函数实现，该函数返回一个静态文件处理器。
- en: 'This function requires a directory to scrape, and we pass one to it as a parameter:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此功能需要一个用于抓取的目录，我们将一个参数传递给它：
- en: '[PRE72]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This reads the local `public` folder that you created previously.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将读取你之前创建的本地`public`文件夹。
- en: 'Now, add this final part to the file:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下最后部分添加到文件中：
- en: '[PRE73]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Here, again, the server gets created and the `main()` function is closed. Now,
    run the server again:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，服务器再次创建，`main()`函数关闭。现在，再次运行服务器：
- en: '[PRE74]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You will see the following output:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '![Figure 16.23: Styled home page](img/B18621_16_23.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图16.23：样式化的主页](img/B18621_16_23.jpg)'
- en: 'Figure 16.23: Styled home page'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.23：样式化的主页
- en: Somehow, the HTML file is now getting the style from the style sheets you created
    at the beginning.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 某种程度上，HTML文件现在正在使用你最初创建的样式表中的样式。
- en: 'Now, let’s examine how the files are injected. If you look back at the `index.html`
    file, you will see these lines:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看文件是如何注入的。如果你回顾`index.html`文件，你会看到这些行：
- en: '[PRE75]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'So, essentially, we are looking for files under the `"/statics/"` path. The
    first address will display the content of the CSS for the body of the page:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，本质上，我们正在寻找`"/statics/"`路径下的文件。第一个地址将显示页面主体的CSS内容：
- en: '![Figure 16.24: The body CSS file](img/B18621_16_24.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![图16.24：主体CSS文件](img/B18621_16_24.jpg)'
- en: 'Figure 16.24: The body CSS file'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.24：主体CSS文件
- en: 'The second one displays the CSS for the header of the page:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个显示了页面标题的CSS：
- en: '![Figure 16.25: The header CSS file](img/B18621_16_25.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图16.25：标题CSS文件](img/B18621_16_25.jpg)'
- en: 'Figure 16.25: The header CSS file'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.25：标题CSS文件
- en: 'Finally, we have the CSS for the text on the page. So, all the style sheets
    are served:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有页面上的文本CSS。因此，所有的样式表都已提供：
- en: '![Figure 16.26: The text CSS file](img/B18621_16_26.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![图16.26：文本CSS文件](img/B18621_16_26.jpg)'
- en: 'Figure 16.26: The text CSS file'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.26：文本CSS文件
- en: 'Furthermore, you can even go here:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，你甚至可以访问这里：
- en: '![Figure 16.27: Static folder content visible in the browser](img/B18621_16_27.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![图16.27：在浏览器中可见的静态文件夹内容](img/B18621_16_27.jpg)'
- en: 'Figure 16.27: Static folder content visible in the browser'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.27：在浏览器中可见的静态文件夹内容
- en: You’ll see that all the files inside the `public` folder are served under the
    `/statics/` path. If you are looking for a simple static files server, Go allows
    you, with the help of a few lines of code, to create one, and, with a few more
    lines, you can make it production-ready.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到`public`文件夹内的所有文件都在`/statics/`路径下提供。如果你在寻找一个简单的静态文件服务器，Go通过几行代码允许你创建一个，并且通过更多的代码，你可以使其适用于生产环境。
- en: 'If you use Chrome, you can inspect with your mouse by right-clicking, though
    you can do the same with any browser if you have developer tools. You will see
    something similar to the following:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用Chrome，可以通过右键单击使用鼠标进行检查，尽管如果您有开发者工具，任何浏览器都可以做到这一点。您将看到以下类似的内容：
- en: '![Figure 16.28: Developer tools showing loaded scripts](img/B18621_16_28.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![图16.28：开发者工具显示加载的脚本](img/B18621_16_28.jpg)'
- en: 'Figure 16.28: Developer tools showing loaded scripts'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.28：开发者工具显示加载的脚本
- en: As you can see, the files have been loaded and the styles are shown as being
    computed from the stylesheet on the right.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，文件已加载，样式显示为从右侧的样式表中计算得出。
- en: Getting dynamic
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变得动态
- en: Static assets are generally served as they are, but when you want to create
    a dynamic page, you might want to make use of an external template, which you
    can use on the fly, so that you can change the template without having to restart
    your server, or that you can load on startup, which means you will have to restart
    your server following any change (this is not strictly true, but we need some
    concepts of concurrent programming to make it happen). Loading a file at startup
    is done simply for performance reasons. Filesystem operations are always the slowest,
    and even if Go is a fairly fast language, you might want to take performance into
    account when you want to serve your pages, especially if you have many requests
    from multiple clients.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 静态资源通常按原样提供服务，但当你想创建一个动态页面时，你可能想使用外部模板，这样你就可以即时使用它，这样你就可以在不重新启动服务器的情况下更改模板，或者你可以在启动时加载，这意味着您在更改后必须重新启动服务器（这并不完全正确，但我们需要一些并发编程的概念来实现这一点）。在启动时加载文件只是为了性能原因。文件系统操作总是最慢的，即使Go是一种相当快的语言，当您想要提供页面时，您可能仍然需要考虑性能，尤其是如果您有来自多个客户端的大量请求。
- en: 'As you may recall, we used the standard Go templates to make dynamic pages.
    Now, we can use the template as an external resource, put our template code in
    an HTML file, and load it. The template engine can parse it and then fill in the
    blanks with the passed parameters. To do this, we can use the `html/template`
    function:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所回忆的，我们使用了标准的Go模板来创建动态页面。现在，我们可以将模板作为外部资源使用，将模板代码放入HTML文件中，并加载它。模板引擎可以解析它，然后使用传递的参数填充空白。为此，我们可以使用`html/template`函数：
- en: '[PRE76]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'As an example, this can be called with the following code:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以使用以下代码调用：
- en: '[PRE77]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In addition, the template is loaded in memory and is ready to be used.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，模板被加载到内存中，并准备好使用。
- en: So far, you have been the sole user of your HTTP servers, but in an actual scenario,
    that won’t be the case. In the following examples, we will look at performance
    and will use a resource that’s loaded at startup.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您一直是您HTTP服务器的唯一用户，但在实际场景中，情况不会是这样。在接下来的示例中，我们将查看性能，并使用启动时加载的资源。
- en: Activity 16.02 – external template
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十六.02 – 外部模板
- en: In this activity, you will create a welcome server, similar to the ones you
    created before, and you will have to use the template package, as you’ve done
    before. In this activity, however, we do not want you to create your template
    from a hardcoded string but from an HTML file, which will contain all the template
    placeholders.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在此活动中，您将创建一个欢迎服务器，类似于您之前创建的，您将不得不使用模板包，就像您之前做的那样。然而，在此活动中，我们不想让您从硬编码的字符串创建模板，而是从HTML文件创建，该文件将包含所有模板占位符。
- en: You should be able to complete this activity by making use of what you’ve learned
    so far in this chapter and the previous one.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够利用本章和上一章所学的内容完成此活动。
- en: This activity returns a pointer to `template` and an error from a list of filenames.
    The error gets returned if any of the files does not exist or if the format of
    the template is wrong. In any case, do not concern yourself with the possibility
    of adding multiple files. Stick with one.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动从文件名列表返回`template`指针和一个错误。如果任何文件不存在或模板格式错误，则返回错误。在任何情况下，都不要担心添加多个文件的可能性。坚持使用一个。
- en: 'Here are the steps to complete this activity:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动的步骤如下：
- en: Create a folder for your project.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的项目创建一个文件夹。
- en: Create a template with a name such as `index.html` and fill it with standard
    HTML code, with a welcome message and a placeholder for the name. Make sure that
    if the name is empty, the message inserts the word `visitor` where the name is
    supposed to be.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`index.html`的模板，并用标准的HTML代码填充，包括欢迎信息和名称的占位符。确保如果名称为空，消息在名称应出现的位置插入单词`visitor`。
- en: Create your `main.go` file and add to it the right package and imports.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建你的 `main.go` 文件，并向其中添加正确的包和导入。
- en: In the `main.go` file, create a struct holding a name that can be passed to
    a template.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 文件中，创建一个包含可以传递给模板的名称的结构体。
- en: Create a template from a file using your `index.html` file.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的 `index.html` 文件从文件创建一个模板。
- en: Create something that’s able to handle the HTTP requests and use `querystring`
    to receive parameters and display the data through the template you created previously.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建能够处理 HTTP 请求的东西，并使用 `querystring` 接收参数，通过你之前创建的模板显示数据。
- en: Set all the paths to the server so that you can use the function or handler
    you created in the previous step; then, create the server.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有路径设置到服务器上，以便你可以使用你在上一步中创建的函数或处理器；然后，创建服务器。
- en: 'Run the server and check the result. The output will be as follows:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行服务器并检查结果。输出将如下所示：
- en: '![Figure 16.29: Anonymous visitor page](img/B18621_16_29.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.29：匿名访客页面](img/B18621_16_29.jpg)'
- en: 'Figure 16.29: Anonymous visitor page'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.29：匿名访客页面
- en: 'The visitor page, including the name that’s displayed, will look something
    like this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 访客页面，包括显示的名称，看起来可能如下所示：
- en: '![Figure 16.30: Visitor page with the name “Will”](img/B18621_16_30.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.30：名为“Will”的访客页面](img/B18621_16_30.jpg)'
- en: 'Figure 16.30: Visitor page with the name “Will”'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.30：名为“Will”的访客页面
- en: Note
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter16/Activity16.02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter16/Activity16.02).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter16/Activity16.02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter16/Activity16.02)。
- en: In this activity, you learned how to create a templated HTTP handler as a struct
    that can be initialized with any external template. You can now create multiple
    pages, instantiating the same struct with different templates of your choice.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你学习了如何创建一个模板化的 HTTP 处理器作为结构体，它可以初始化为任何外部模板。你现在可以创建多个页面，使用不同的模板实例化相同的结构体。
- en: Embedding external files
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部文件嵌入
- en: In the previous sections, you learned about a very interesting technique, but
    having external files to read can be problematic when deploying something to production,
    especially with Go, where one of its strong features is building a single executable.
    Fortunately, there is a package in Go called `embed` that allows us to add external
    files to our final binary so that we need the original file when we develop, but
    we do not need to share this file with anybody else as it will be compiled and
    added to our final binary. Let’s see how this works.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你了解了一种非常有趣的技术，但读取外部文件在部署到生产环境时可能会出现问题，尤其是在使用 Go 语言时，Go 语言的一个强大特性是构建单个可执行文件。幸运的是，Go
    语言中有一个名为 `embed` 的包，它允许我们将外部文件添加到我们的最终二进制文件中，这样我们在开发时不需要原始文件，但也不需要与他人共享此文件，因为它将被编译并添加到我们的最终二进制文件中。让我们看看它是如何工作的。
- en: 'Let’s imagine that you have a simple template file and want to use it on your
    web server:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你有一个简单的模板文件，并想在你的 web 服务器上使用它：
- en: '[PRE78]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Let’s look at a small program that does exactly that, using what you’ve learned
    in the previous chapter:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个小程序，它正好做了这件事，使用了你在上一章中学到的知识：
- en: '[PRE79]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If you run this code, the program will parse the file from your folder and
    use it as a template to display `Hello there` on the `/hello1` path. If you build
    your application and you move your executable to a different folder, however,
    you will receive an error. Let’s modify this software so that it uses the `embed`
    package:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此代码，程序将解析你的文件夹中的文件，并将其用作模板在 `/hello1` 路径上显示 `Hello there`。然而，如果你构建你的应用程序并将可执行文件移动到不同的文件夹，你将收到一个错误。让我们修改这个软件，使其使用
    `embed` 包：
- en: '[PRE80]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The difference Is that we’ve just created a global variable, `s`, that holds
    the content of the `mytemplate.html` files and stores it in the binary when you
    compile your code using the `//go:embed` build tag directive:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 差异在于我们刚刚创建了一个全局变量 `s`，它包含 `mytemplate.html` 文件的内容，并在你使用 `//go:embed` 构建标签指令编译代码时将其存储在二进制文件中：
- en: '[PRE81]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Finally, we create a template with the `New` method and then parse the string.
    If you compile the code and run your application from a different folder, you
    won’t have any errors.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `New` 方法创建一个模板，然后解析字符串。如果你编译代码并从不同的文件夹运行你的应用程序，你将不会遇到任何错误。
- en: Summary
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you were introduced to the server side of web programming.
    You learned how to accept requests from HTTP clients and respond appropriately.
    You also learned how to separate the possible requests into different areas of
    an HTTP server via paths and sub-paths. For this, you used a simple routing mechanism
    with the standard `Go` `HTTP` package.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你被引入了Web编程的服务器端。你学习了如何接受来自HTTP客户端的请求并做出相应的响应。你还学习了如何通过路径和子路径将可能的请求分离到HTTP服务器的不同区域。为此，你使用了一个简单的路由机制，即标准的`Go`
    `HTTP`包。
- en: 'Then, you learned how to return your response to suit different consumers:
    JSON responses for synthetic clients, and HTML pages for human access.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学习了如何根据不同的消费者返回响应：为合成客户端返回JSON响应，为人类访问返回HTML页面。
- en: Next, you learned how to use templates to format your plain text and HTML messages,
    using the standard templating package. You learned how to serve and use static
    resources, serving them directly through a default file server or a template object.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你学习了如何使用模板来格式化你的纯文本和HTML消息，使用的是标准的模板包。你学习了如何提供和使用静态资源，可以直接通过默认文件服务器或模板对象来提供服务。
- en: After that, you learned how to create a middleware and how to embed external
    files inside your binary for better portability. At this stage, you know all the
    basics for building production-grade HTTP servers, although you might want to
    use some external libraries to facilitate your Hello World example, facilitating
    better routing by using something such as gorilla mux or, generally, the entire
    `gorilla` package, which is a low-level abstraction on top of the `http` package.
    You could use `hero` as a template engine to make your page rendering faster.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你学习了如何创建中间件以及如何将外部文件嵌入到你的二进制文件中以实现更好的可移植性。在这个阶段，你已经掌握了构建生产级别HTTP服务器的基础知识，尽管你可能希望使用一些外部库来简化你的Hello
    World示例，例如使用gorilla mux或通常的`gorilla`包，这是一个在`http`包之上的低级抽象。你可以使用`hero`作为模板引擎来加快页面渲染速度。
- en: One thing to mention is that you can make pretty much stateless services with
    what you’ve learned in this chapter, but you cannot create a production-grade
    stateful server at the moment as you do not know how to handle concurrent requests.
    This means that `views counter` is not suitable for a production server yet, but
    this will be the subject of another chapter.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 有一点需要提及的是，你可以利用本章所学的内容创建几乎无状态的服务，但目前你还不能创建一个生产级别的有状态服务器，因为你不知道如何处理并发请求。这意味着`视图计数器`还不适合用于生产服务器，但这将是下一章的主题。
- en: In the next chapter, you will shift gears and learned how to use the Go HTTP
    client to talk to other systems over the internet.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将转换方向，学习如何使用Go HTTP客户端通过互联网与其他系统通信。
