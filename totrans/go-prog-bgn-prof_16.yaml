- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web Servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces you to different ways of creating an HTTP server to
    accept requests from the internet. You will be able to understand how a website
    can be accessed and how it can respond to a form. You will also learn how to respond
    to requests from another software program.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to create an HTTP server that renders
    a simple message. You will also know how to create an HTTP server that renders
    complex data structures that serve local static files. Further, you know how to
    create an HTTP server that renders dynamic pages and works with different ways
    of routing. Finally, you will know how to create a REST service, accept data through
    a form, and accept JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete and run the examples in this chapter, you will need your favorite
    IDE and the latest version of the Go compiler. At the time of writing, this is
    1.21\. All the examples will use the standard Go library. You can refer to this
    book’s GitHub repository for the code in this chapter: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter16](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter16).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will dig into how a remote server is created, so if you
    already know how to request information, you will see how to reply to these requests.
  prefs: []
  type: TYPE_NORMAL
- en: A web server is a program that uses the HTTP protocol – hence, the HTTP server
    – to accept requests from any HTTP client (web browser, another program, and so
    on) and respond to them with an appropriate message. When we browse the internet
    with our browser, it will be an HTTP server that will send an HTML page to our
    browser and we will be able to see it. In some other cases, a server will not
    return an HTML page but a different message that’s appropriate to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Some HTTP servers provide an API that can be consumed by another program. Think
    of when you want to register with a website, and you are asked if you want to
    sign up through Facebook or Google. This means that the website you want to register
    with will consume a Google or Facebook API to get your details. These APIs generally
    respond with structured text, which is a piece of text representing a complex
    data structure. The way these servers expect the requests can be different. Some
    expect the same type of structured messages they return, while some provide what
    is called a REST API, which is quite strict with the HTTP methods that are used
    and expects inputs in the form of URL parameters or values, similar to the ones
    in a web form.
  prefs: []
  type: TYPE_NORMAL
- en: How to build a basic server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest HTTP server that we can create is a Hello World server. This is
    a server that returns a simple message stating `Hello World` and will not do anything
    else. It is not very useful, but it is a starting point to see what default Go
    packages give us and is the basis for any other more complex server. The aim is
    to have a server that runs on a specific port on your machine’s local host and
    accepts any path under it. Accepting any path means that when you test the server
    with your browser, it will always return the `Hello World` message and a status
    code of `200`. Of course, we could return any other message, but, for historical
    reasons, the simplest project you learn when you study programming is always some
    sort of software that returns a message stating `Hello World`. In this case, we
    will see how this can be done and then visualized in a normal browser, before
    perhaps being put on the internet and shared with billions of users, although
    users may, in practice, prefer a more useful server. Let’s say this is the most
    basic HTTP server you can create.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To react to an HTTP request, we need to write something that, we usually say,
    handles the request; hence, we call this something a handler. In Go, we have several
    ways to do that, and one way is to implement the handler interface of the `http`
    package. This interface has one pretty self-explanatory method, and this is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So, whenever we need to create a handler for HTTP requests, we can create a
    struct that includes this method and we can use it to handle an HTTP request.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a valid HTTP handler and you can use it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ListenAndServe()` is a function that will use our handler to serve the
    requests; any struct that implements the handler interface will be fine. However,
    we need to let our server do something.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the `ServeHTTP` method accepts `ResponseWriter` and a `Request`
    object. You can use them to capture parameters from the request and write messages
    to the response. The simplest thing, for example, is to let our server return
    a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ListenAndServe` method might return an error. If this happens, we will
    want the execution of our program to halt. One common practice is to wrap this
    function call with a fatal log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will halt the execution and print the error message that’s returned by
    the `ListenAndServe` function.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 16.01 – creating a Hello World server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by building a simple `Hello World` HTTP server based on what you
    learned in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is create a folder called `hello-world-server`.
    You can do this via the command line or you can create it with your favorite editor.
    Inside the folder, create a file called `main.go`. We will not use any external
    library here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the package’s name, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This tells the compiler that this file is an entry point for a program that
    can be executed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the necessary packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create `handler`, the struct that will handle the requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have our handler, create the `main()` function. This will start
    the server and produce a web page with our message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire file should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, go to your Terminal, inside your `hello-world-server` folder, and type
    in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You shouldn’t see anything; the program has started.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, open your browser at the following address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see a page with a big message:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.1: Hello World server](img/B18621_16_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: Hello World server'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you try to change path and go to `/page1`, you will see the following
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2: Hello World server sub-pages](img/B18621_16_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: Hello World server sub-pages'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! This is your first HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we created a basic Hello World server that returns a message
    stating `Hello World` in response to any request on any sub-address.
  prefs: []
  type: TYPE_NORMAL
- en: Simple routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The server we built in the previous exercise doesn’t do much – it just responds
    with a message; we cannot ask anything else. Before we can make our server more
    dynamic, let’s imagine we want to create an online book and we want to be able
    to select a chapter just by changing the URL. At the moment, if we browse the
    following pages, we’ll always see the same message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, we want to associate different messages with these different paths on our
    server. We will do this by introducing some simple routing to our server.
  prefs: []
  type: TYPE_NORMAL
- en: 'A path is what you see after `8080` in the URL, where `8080` is the port number
    we chose to run the server on. This path can be one number, a word, a set of numbers,
    or character groups separated by a `/`. To do this, we will use another function
    of the `net/http` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, the pattern is the path we want to be served by the `handler` function.
    Note how the `handler` function signature has the same parameters as the `ServeHTTP`
    method, which you added to the `hello` struct in the previous exercise.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, the server we built in *Exercise 16.01* is not very useful, but
    we can transform it into something much more useful with the addition of pages
    other than the `Hello World` one. To do so, we need to do some basic routing.
    The aim here is to write a book, and the book must have a welcome page that contains
    a title and a first chapter. The book title is `Hello World`, so we can keep what
    we did before. The first chapter will have a heading stating [*Chapter 1*](B18621_01.xhtml#_idTextAnchor021).
    The book is a work in progress, so it doesn’t matter that the content is still
    poor; what we require is the ability to select the chapter; we will add the content
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 16.02 – routing our server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to modify the code in *Exercise 16.01* so that it supports different
    paths. If you haven’t gone through the previous exercise, do so now so that you
    have a basic framework for this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder and a `main.go` file, and add the code from the previous
    exercise to the definition of the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, use `handle` to route `/chapter1` through a `handlefunc()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This means that we associate the path, `/chapter1`, with a function that returns
    a specific message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, set the server so that it listens to a port; then, run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, save your file and run the server again with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, go to your browser and load the following URLs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8080`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/chapter1`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output for the home page is shown in the following screenshot:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 16.3: Multi-page server – home page](img/B18621_16_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.3: Multi-page server – home page'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for `page 1` is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.4: Multi-page server – page 1](img/B18621_16_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.4: Multi-page server – page 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that they both still display the same message. This happens because we
    are setting `hello` as the handler for our server, and this overrides our specific
    path. We can modify our code so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we removed the `hello` handler so that it’s no longer the main handler
    for our server and we associated this handler with the main `/` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we associated a `handler` function with the specific `/``chapter1` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we stop and then run our server again, we will see that the `/chapter1`
    path now returns the new message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.5: Multi-page server repeated – chapter 1](img/B18621_16_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.5: Multi-page server repeated – chapter 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the meantime, all the other paths return the old **Hello** **World** message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.6: Multi-page server – base page](img/B18621_16_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.6: Multi-page server – base page'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default page for the server is also displayed for another route:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.7: The page that is not set returns the default setting](img/B18621_16_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.7: The page that is not set returns the default setting'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we made a basic Hello World web server with specific routes for different
    pages. During the process, we used several functions from the go `http` package,
    some of which are used to achieve the same result. We will see why there are multiple
    ways to do the same thing and why we need all of them shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Handler versus handler function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may have noticed, we used two different functions before, `http.Handle`
    and `http.HandleFunc`, both of which have a path as their first parameter, but
    which differ in terms of the second parameter. These two functions both ensure
    that a specific path is handled by a function. `http.Handle`, however, expects
    `http.Handler` to handle the path, while `http.HandleFunc` expects a function
    to do the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve seen before, `http.Handler` is any struct that has a method with this
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So, in both cases, there will always be a function with `http.ResponseWriter`
    and `*http.Request` as parameters that will handle the path. When one or the other
    might be chosen may just be a matter of personal preference in many cases, but
    it might be important – when creating a complex project, for example – to choose
    the right method. Doing so will ensure that the structure of the project is optimal.
    Different routes may appear better organized if they’re handled by handlers that
    belong to different packages, or might have to perform very few actions, as in
    our previous case; and a simple function might prove to be the ideal choice.
  prefs: []
  type: TYPE_NORMAL
- en: In general, for simple projects where you have a handful of simple pages, you
    may opt for `HandleFunc`. For example, let’s say you want to have static pages
    and there is no complex behavior on each page. In this case, it would be overkill
    to use an empty struct just for returning static text. The handler is more appropriate
    whenever you need to set some parameters, or if you want to keep track of something.
    As a general rule, let’s say that if you have a counter, `Handler` is the best
    choice because you can initialize a struct with a count of 0 and then increment
    it, but we will see this in *Activity 16.01*.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 16.01 – adding a page counter to an HTML page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that you own a website with, say, three pages, where you are writing
    your book. You earn money based on how many visits your website receives. To understand
    how popular your website is, and how much money you are earning, you need to keep
    track of the visits.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you will build an HTTP server with three pages that contain
    some content, and display, on each page, how many visits that page has had so
    far. You will use the `http.Handler` method, which, in this case, will help you
    generalize your counter.
  prefs: []
  type: TYPE_NORMAL
- en: To display the dynamic value, you can use the `fmt.Sprintf` function in the
    `fmt` package, which prints and formats a message to a string. With this function,
    you can build a string containing characters and numbers. You can find more information
    about this method online in the Go documentation.
  prefs: []
  type: TYPE_NORMAL
- en: You will use everything you’ve learned so far, including how a struct is instantiated,
    how to set the attributes of a struct, pointers, how to increase an integer, and,
    of course, everything you’ve learned about HTTP servers so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observing the following steps will provide an elegant and effective solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `page-counter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the necessary imports to the `http` and `fmt` packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a struct called `PageWithCounter` with `counter` as an integer attribute,
    `content`, and `heading` as a text attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `ServeHTTP` method to the struct that’s capable of displaying the content,
    the heading, and a message with the total number of views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create your `main` function and, inside, implement the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiate three handlers of the `PageWithCounter` type, with `Hello World`,
    `Chapter 1`, and `Chapter 2` headings and some content.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the three handlers to the `/`, `/chapter1`, and `/``chapter2` routes.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the server on port `8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you run the server, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.8: Output in the browser when you run the server for the first
    time](img/B18621_16_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.8: Output in the browser when you run the server for the first time'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you refresh the page, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.9: Output in the browser when you run the server for the second
    time](img/B18621_16_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.9: Output in the browser when you run the server for the second time'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, navigate to `chapter1` by typing `localhost:8080/chapter1` in the address
    bar. You should be able to see something along the lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.10: Output in the browser when you visit the chapter1 page for
    the first time](img/B18621_16_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.10: Output in the browser when you visit the chapter1 page for the
    first time'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, navigate to `chapter2`; you should be able to see the following
    increment in terms of the number of views:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.11: Output in the browser when you visit the chapter2 page for
    the first time](img/B18621_16_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.11: Output in the browser when you visit the chapter2 page for the
    first time'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you revisit `chapter1`, you should see an increase in the number of views,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.12: Output in the browser when you visit the chapter1 page for
    the second time](img/B18621_16_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.12: Output in the browser when you visit the chapter1 page for the
    second time'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter16/Activity16.01/main.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter16/Activity16.01/main.go).
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you learned how to create a server that responds to different
    requests on different pages with a specific static text, along with a counter
    on each page, with each counter independent from the others.
  prefs: []
  type: TYPE_NORMAL
- en: Adding middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you will need to create a lot of functions to handle HTTP requests,
    maybe serving different paths in a URL, all performing different actions. You
    might need to create a function to handle a server returning a list of users,
    one with a list of projects, a route for updating some details, and all the functions
    doing different things. It might happen, however, that although these functions
    perform different actions, they will also have something in common. A common example
    is when these functions have to be performed on a secured environment, which means
    only for users that have been logged in. Let’s look at a very simple example and
    consider the following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Both functions will display a sentence that starts with `Hello there,`. Let’s
    find a way to extract this part of the behavior of these functions and create
    a third function that will be used to perform the act of writing the initial cheering
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This function has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This means it is called `Hello`, accepts `http.HandlerFunc` as a parameter,
    and returns a result against `http.HandlerFunc`. This parameter is called `next`
    because it is the function that we will want to run next. Let’s look at the body
    of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it returns a function that implements the `http.HandlerFunc`
    type and has the correct arguments and return type. This function will write a
    message stating `Hello there,` to the response writer, `w`, and then call the
    `next` function with the same response writer and request that the function without
    a name receives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s refactor our code to make it a bit easier to read. We’ll create
    two functions for the actions we want to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see what our file looks like so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have our `Hello` function and two functions returning two
    different sentences to the response writer. The last step is to associate these
    functions with a path, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we pass functions 1 and 2 to each route. If you run the code
    on your machine and go to `http://localhost:8085/hello1`, you will see a message
    stating `this is function 1`. What we have not used yet, though, is the `Hello`
    function. Let’s rewrite the last block of code and make use of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this program again, you will see that the message has now changed
    to `Hello there, this is function 1`. The `Hello` function is essentially running
    before the `Function1` function and after doing its own work, it calls `Function`
    so that that function can also do its job. We call the `Hello` function `Middleware`
    as it acts as the man in the middle – it captures the request, does some work,
    and then calls the next function in line. By doing this, it is possible to chain
    many middleware by doing something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can use this pattern to perform many common actions before or after the
    actual function that needs to be associated with a path on the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A server that serves only static content is useful, but there is much more
    that can be done. An HTTP server can deliver content based on a more granular
    request, which is done by passing some parameters to the server. There are many
    ways to do so, but one simple way is to pass parameters to `querystring`. If the
    URL of the server is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can add something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here,`?name=john` is called a `querystring` string as it is a string representing
    a query. In this case, `querystring` sets a variable called `name` with a value
    of `john`. This way of passing parameters is generally used with `GET` requests,
    while a `POST` request will generally make use of the body of the request to send
    parameters. We will begin by looking at how to accept parameters for a `GET` request
    since this request is made by simply opening our browser on a specific address.
    We will see how to handle a `POST` request through a form later.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will learn how to return different texts as responses
    to HTTP requests, where the text depends on what values the user puts in the `querystring`
    string in the address bar.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 16.03 – personalized welcome
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create an HTTP server that can cheer us, but instead
    of a general `hello world` message, we will provide a message depending on our
    name. The idea is that, by opening the browser on the server’s URL and adding
    a parameter called `name`, the server will welcome us with a message stating `hello`,
    followed by the value of the `name` parameter. The server is very simple and does
    not have sub-pages, but contains a dynamic element that constitutes a starting
    point for more complex situations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder called `personalised-welcome` and, inside the folder, create
    a file called `main.go`. Inside the file, add the package name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the required imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are the same imports we used in the previous exercises and activities,
    so there is nothing new. We will not use handlers in this exercise as it is much
    smaller, but we will make use of the `http.handleFunc` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the following code after the imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the definition of a function that can be used as a handling function
    for an HTTP path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, save the query to a variable using the `Query` method URL from the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Query` method on the `URL` object of the request returns a `map[string][]string`
    string with all the parameters sent through `querystring` in the URL. We then
    assign this map to a variable, `vl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, we need to get the value of a specific parameter called `name`,
    so we get the value from the `name` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we have an assignment to two variables, but only one value comes
    from `vl["name"]`. The second variable, `ok`, is a Boolean that tells us whether
    the `name` key exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the `name` parameter has not been passed and we want an error message to
    appear, we must add it if the variable is not found – in other words, if the `ok`
    variable is false:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The conditional code gets called if the key does not exist in the slice, and
    it writes a `400` code (bad request) to the header, as well as a message to the
    response writer stating that the name has not been sent as a parameter. We stop
    the execution with a `return` statement to prevent further actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, write a valid message to the response writer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code formats a string and injects the name into it. The `fmt.Sprintf` function
    is used to format, while `strings.Join` is used to transform the `name` slice
    into a string. Notice that the `name` variable is set to the value of `vl["name"]`,
    but `vl` is a `map[string][]string` string, which means that it is a map with
    string keys whose values are slices of strings; hence, `vl["name"]` is a slice
    of strings and needs to be transformed into a single string. The `strings.Join`
    function takes all the elements of the slice and builds a single string using
    `","` as a separator. Other characters could have also been used as separators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last part of the file you have to write is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As always, a `main()` function is created, and then the `Hello` function is
    associated with the `"/"` path and the server is started. Here is the output of
    three different URLs – two valid ones, and one with a missing parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.13: The server’s output when requesting the page with the name
    John](img/B18621_16_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.13: The server’s output when requesting the page with the name John'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure shows the output when we set the query parameter in the
    URL to the name John. If we change the name in the query parameter in the URL,
    we will see the new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.14: The server’s output when requesting the page with the name
    Will](img/B18621_16_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.14: The server’s output when requesting the page with the name Will'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do not set the query parameter, we will receive an error message, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.15: The server outputting an error message when requesting a page
    without a name](img/B18621_16_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.15: The server outputting an error message when requesting a page
    without a name'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll explore the concept of templates.
  prefs: []
  type: TYPE_NORMAL
- en: Templating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although JSON can be the best choice when complex data structures have to be
    shared across software programs, in general, this is not the case when the HTTP
    server is supposed to be consumed by humans. In the previous exercises and activities,
    the chosen way to format a piece of text has been the `fmt.Sprintf` function,
    which is good for formatting texts, but is simply insufficient when more dynamic
    and complex text is required. As you will have noticed in the previous exercise,
    the message that was returned in case a name was passed as a parameter to the
    URL observed a specific pattern, and this is where a new concept comes in – the
    template. A template is a skeleton from which complex entities can be developed.
    Essentially, a template is like text with some blanks. A template engine will
    take some values and fill in the blanks, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.16: Templating example](img/B18621_16_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.16: Templating example'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `{{name}}` is a placeholder, and, when a value is passed through
    to the engine, the placeholder is modified with that value.
  prefs: []
  type: TYPE_NORMAL
- en: We see templates everywhere. We have templates for Word documents, where we
    just fill in what is missing to produce new documents that all differ from one
    another. A teacher might have some templates for their lessons and will develop
    different lessons from that same template. Go provides two different templating
    packages – one for text and one for HTML. As we are working with HTTP servers
    and we want to produce a web page, we will use the HTML templating package, but
    the interface is the same for the text template library. Although the templating
    packages are good enough for any real-world application, several other external
    packages can be used to improve performance. One of these is the `hero` template
    engine, which is much faster than the standard Go templating package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go templating package provides a placeholder language where we can use
    things such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple code block that will make the template engine replace the
    `name` variable with a provided value, but more complex situations can be handled
    via conditionals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, if an `age` parameter is not null, the template will contain `Hello`;
    otherwise, it will contain `bye`. Each conditional needs an `{{end}}` placeholder
    to determine its ending.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables in a template, however, do not need to be simple numbers or strings;
    they can be objects. In this case, if we have a struct with a field called `ID`,
    we can reference this field in the template like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This is very handy as we can pass a struct to the template instead of many single
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will learn how to use the basic templating functionalities
    of Go to create pages with custom messages, as you’ve done before, but just in
    a more elegant way.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 16.04 – templating our pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise aims to have you build a more structured web page, use a template,
    and fill it with parameters from the URL’s `querystring`. In this scenario, we
    want to display basic information for a customer and hide some information when
    the data is missing. A customer has `id`, `name`, `surname`, and `age` values,
    and if any of these values are missing, they will not be displayed. Unless the
    data is the `id` value, as in this case, an error message will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating a `server-template` folder that contains a `main.go` file.
    Then, add the usual package and some imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we use two new imports: `html/template` for our templating and `strconv`
    to convert strings into numbers (this package could also work the other way around,
    but there are better solutions for formatting text).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a raw string that contains some HTML and templating code, which is wrapped
    by `{{}}`. We will analyze this now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{{.ID}}` is essentially a placeholder that tells the template engine that
    wherever this code is found, it will be substituted by a struct’s attribute called
    `ID`. The Go templating engine works with structs, so essentially, a struct will
    be passed to the engine and its attributes’ values will be used to fill the placeholders.
    `{{if .ID}}` is a conditional that tells the template that what happens next will
    depend on the value of `ID`. In this case, if `ID` is not an empty string, the
    template will display the customer’s details; otherwise, it will display `<p>Data
    not available</p>`, which is wrapped between the `{{else}}` and `{{end}}` placeholders.
    As you can see, there are many more conditionals nested inside the first one.
    At each list item, there is a `<li>` tag, which is wrapped, for example, by `{{if
    .Name}}` and terminated with `{{end}}`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have a string template, let’s create a struct with the correct
    attributes. To fill in the template, write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This struct is self-explanatory. It contains all the attributes needed by the
    template.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the `handler` function and set a variable to the map of values in `querystring`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instantiate a `cust` variable of the `Customer` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The variable now has all its attributes set to the default values, and we need
    to grab the passed values from the URL. To do so, write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, the parameters are taken as they are from the values map, and
    if they exist, they are used to set the value of the related `cust` attribute.
    To check whether these parameters exist, we again used the `ok` variable, which
    is set to a Boolean with a value of `true` in case the map contains the requested
    key. The last attribute, `Age`, is handled slightly differently:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is because `strconv.Atoi` returns an error in case the parameter that’s
    passed is not a number. In general, we should handle the errors but, in this case,
    we’ll just ignore it and we won’t display any age-related information if the age
    provided is not a number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates a template object called `test` that contains the content of the
    string that you created at the outset. Again, ignore the error as we are sure
    that the template we’ve written is a valid one. In production, however, all the
    errors should be dealt with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now finish writing the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the template is executed using the `cust` struct; its content is sent
    directly to `w ResponseWriter` without the need to call the `Write` method manually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What’s missing now is the `main` method, which is fairly simple. Write the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, simply speaking, the main path is associated with the `Hello` function,
    and the server is then started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The performance of this code is not very high as we create a template for every
    request. The template could be created in `main` and then passed to a handler,
    which could have a `ServeHTTP` method like the `Hello` function you’ve just written.
    The code has been kept simple here to focus on templating.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, if you start the server and visit the following pages, you should see
    some output similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.17: Templated response with blank parameters](img/B18621_16_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.17: Templated response with blank parameters'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can add a query parameter called `id` and make it equal to `1` in
    the URL by visiting `localhost:8080/?id=1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.18: Templated response with just the ID specified](img/B18621_16_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.18: Templated response with just the ID specified'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can add a value for the name parameter by going to `localhost:8080/?id=1&name=John`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.19: Templated response with the ID and name specified](img/B18621_16_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.19: Templated response with the ID and name specified'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you also add an age by going to `localhost:8080/?id=1&name=John&age=40`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.20: Templated response with the ID, name, and age specified](img/B18621_16_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.20: Templated response with the ID, name, and age specified'
  prefs: []
  type: TYPE_NORMAL
- en: Here, each parameter in `querystring` is displayed, if valid, in the web application.
  prefs: []
  type: TYPE_NORMAL
- en: Static resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything you’ve learned so far in this book, up to the previous exercise,
    is sufficient to build web applications and dynamic websites; you just need to
    put all the pieces together.
  prefs: []
  type: TYPE_NORMAL
- en: What you’ve been doing in this chapter is returning messages that are different
    but all hardcoded as strings. Even dynamic messages have been based on templates
    hardcoded in the source file of the exercises and activities. Now, let’s consider
    something. In the case of the first `hello world` server, the message never changed.
    If we wanted to modify the message and return a `Hello galaxy` message, we would
    have to change the text in the code and then recompile and/or run the server again.
    What if you wanted to sell your simple “hello” server and give the option to everybody
    to specify a custom message? Of course, you should give the source code to everybody
    so that they can recompile and run the server.
  prefs: []
  type: TYPE_NORMAL
- en: Although you might want to embrace open source code, this might not be the ideal
    way to distribute an application, and we need to find a better way to separate
    the message from the server. A solution to that is to serve static files, which
    are files that are loaded by your program as external resources. These files do
    not change, do not get compiled, and are loaded and manipulated by your program.
    One such example may be templates, as seen previously, because they are just text
    and you can use template files instead of adding the templates as text to your
    code. Another simple example of static resources is if you want to include styling
    files such as CSS in your web page. You will see how to do that in the following
    exercises and activities. You’ll learn how to serve a specific file or a specific
    folder, and then you’ll learn how to serve dynamic files with a static template.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 16.05 – creating a Hello World server using a static file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create your Hello World server but with a static
    HTML file. What we want is to have a simple server with one handler function that
    looks for a specific file with a specific name, which will be served as the output
    for every path. In this case, you will need to create multiple files in your project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called `static-file` and, inside it, create a file called `index.html`.
    Then, insert the following code for a pretty simple HTML file with a title and
    an `h1` tag that states our welcome message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a file called `main.go` and start writing the necessary imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, write the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, write the `handler` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is where the magic happens. Here a normal `http.HandleFunc` is being called
    with a `"/"` path as the first parameter, after which a handler function is passed,
    which contains a single instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sends the content of the `index.html` file to `ResponseWriter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, write the last part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As is always the case, this starts the server, logs in case of an error, and
    exits the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, save the file and run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you open your browser on the `localhost:8080` page, you should see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.21: Hello World with a static template file](img/B18621_16_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.21: Hello World with a static template file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, without stopping your server, just change the HTML file, `index.html`,
    and modify line `8`, where you see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the text in the `<h1>` tag, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the `index.html` file and, without touching the terminal and without restarting
    your server, just refresh your browser on the same page. You should now see the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.22: Hello World server with the static template file modified](img/B18621_16_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.22: Hello World server with the static template file modified'
  prefs: []
  type: TYPE_NORMAL
- en: So, even if the server is running, it will pick up the new version of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, you learned how to use a static HTML file to serve a web page,
    as well as how detaching the static resources from your application allows you
    to change your served page without having to restart your application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting some style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you’ve seen how to serve one static page and you might consider serving
    a few pages with the same method, maybe creating a handler struct with the name
    of the file to serve as an attribute. This might be impractical for large numbers
    of pages, although, in some cases, it is necessary. A web page, however, does
    not include just HTML code – it may also include images and styles, as well as
    some frontend code.
  prefs: []
  type: TYPE_NORMAL
- en: It is not within the scope of this book to teach you how to build HTML pages,
    and even less how to write JavaScript code or CSS style sheets, but you need to
    know how to serve these documents as we use a small CSS file to build our example.
  prefs: []
  type: TYPE_NORMAL
- en: Serving static files and putting templates in different files, or generally
    using external resources, is a good way to separate concerns on our projects and
    make our projects more manageable and maintainable, so you should try to follow
    this approach in all your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a style sheet to your HTML pages, you need to add a tag like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This injects the CSS file into the page as a “stylesheet,” but this is reported
    here just by way of an example, in case you are interested in learning how to
    write HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have also seen that we have served files, reading them from the filesystem
    one by one, but Go provides us with an easy function to do the job for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Essentially, `http.FileServer` creates what its name says: a server serving
    external files. It takes it from the directory defined in `http.Dir`. Whatever
    file we put inside the `./public` directory will be automatically accessible in
    the address bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems good enough. However, in a real-world scenario, you do not want
    to expose your folder names and instead specify a different name for your static
    resources. This can be achieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that the `http.FileServer` function is wrapped by an `http.StripPrefix`
    function, which we use to associate the requested path with the correct files
    on the filesystem. Essentially, we want the path of the `/statics` form to be
    available and to bind it to the content of the `public` folder. The `StripePrefix`
    function will remove the `"/statics/"` prefix from the request and pass it to
    the file server, which will just get the name of the file to serve and search
    for it in the `public` folder.
  prefs: []
  type: TYPE_NORMAL
- en: It is not necessary to use these wrappers if you do not want to change the name
    of the path and folder, but this solution is general and works everywhere, so
    you can utilize it in other projects without having to worry.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 16.06 – a stylish welcome
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise aims to help you display a welcome page while making use of some
    external static resources. We will adopt the same approach as in *Exercise 16.05*,
    but we will add some extra files and code. We will place some stylesheets in a
    `statics` folder, and we will serve them so that they can be used by other pages
    served by the same server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By way of a first step, create a folder called `stylish-welcome` and, inside
    this folder, add a file called `index.html`. Then, incorporate the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, there are few differences compared with the previous HTML; we
    have a paragraph with some more text, wrapped by the `<p>` tag, and, inside the
    `<head>` tag, we include three links to external resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create a folder called `public` inside your `stylish-welcome` folder and
    create three files therein with the following names and content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, go back to your main project folder, `stylish-welcome`, and create the
    `main.go` file. The content at the start corresponds exactly to that in one of
    the previous exercises:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the following code to handle the static files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code adds a handler to the `/statics/` path and does so through an `http.FileServer`
    function, which returns a static file handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This function requires a directory to scrape, and we pass one to it as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This reads the local `public` folder that you created previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add this final part to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, again, the server gets created and the `main()` function is closed. Now,
    run the server again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.23: Styled home page](img/B18621_16_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.23: Styled home page'
  prefs: []
  type: TYPE_NORMAL
- en: Somehow, the HTML file is now getting the style from the style sheets you created
    at the beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s examine how the files are injected. If you look back at the `index.html`
    file, you will see these lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So, essentially, we are looking for files under the `"/statics/"` path. The
    first address will display the content of the CSS for the body of the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.24: The body CSS file](img/B18621_16_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.24: The body CSS file'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second one displays the CSS for the header of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.25: The header CSS file](img/B18621_16_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.25: The header CSS file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the CSS for the text on the page. So, all the style sheets
    are served:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.26: The text CSS file](img/B18621_16_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.26: The text CSS file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, you can even go here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.27: Static folder content visible in the browser](img/B18621_16_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.27: Static folder content visible in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see that all the files inside the `public` folder are served under the
    `/statics/` path. If you are looking for a simple static files server, Go allows
    you, with the help of a few lines of code, to create one, and, with a few more
    lines, you can make it production-ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you use Chrome, you can inspect with your mouse by right-clicking, though
    you can do the same with any browser if you have developer tools. You will see
    something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.28: Developer tools showing loaded scripts](img/B18621_16_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.28: Developer tools showing loaded scripts'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the files have been loaded and the styles are shown as being
    computed from the stylesheet on the right.
  prefs: []
  type: TYPE_NORMAL
- en: Getting dynamic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static assets are generally served as they are, but when you want to create
    a dynamic page, you might want to make use of an external template, which you
    can use on the fly, so that you can change the template without having to restart
    your server, or that you can load on startup, which means you will have to restart
    your server following any change (this is not strictly true, but we need some
    concepts of concurrent programming to make it happen). Loading a file at startup
    is done simply for performance reasons. Filesystem operations are always the slowest,
    and even if Go is a fairly fast language, you might want to take performance into
    account when you want to serve your pages, especially if you have many requests
    from multiple clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may recall, we used the standard Go templates to make dynamic pages.
    Now, we can use the template as an external resource, put our template code in
    an HTML file, and load it. The template engine can parse it and then fill in the
    blanks with the passed parameters. To do this, we can use the `html/template`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, this can be called with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In addition, the template is loaded in memory and is ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have been the sole user of your HTTP servers, but in an actual scenario,
    that won’t be the case. In the following examples, we will look at performance
    and will use a resource that’s loaded at startup.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 16.02 – external template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will create a welcome server, similar to the ones you
    created before, and you will have to use the template package, as you’ve done
    before. In this activity, however, we do not want you to create your template
    from a hardcoded string but from an HTML file, which will contain all the template
    placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to complete this activity by making use of what you’ve learned
    so far in this chapter and the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: This activity returns a pointer to `template` and an error from a list of filenames.
    The error gets returned if any of the files does not exist or if the format of
    the template is wrong. In any case, do not concern yourself with the possibility
    of adding multiple files. Stick with one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder for your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a template with a name such as `index.html` and fill it with standard
    HTML code, with a welcome message and a placeholder for the name. Make sure that
    if the name is empty, the message inserts the word `visitor` where the name is
    supposed to be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create your `main.go` file and add to it the right package and imports.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main.go` file, create a struct holding a name that can be passed to
    a template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a template from a file using your `index.html` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create something that’s able to handle the HTTP requests and use `querystring`
    to receive parameters and display the data through the template you created previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set all the paths to the server so that you can use the function or handler
    you created in the previous step; then, create the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the server and check the result. The output will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.29: Anonymous visitor page](img/B18621_16_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.29: Anonymous visitor page'
  prefs: []
  type: TYPE_NORMAL
- en: 'The visitor page, including the name that’s displayed, will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.30: Visitor page with the name “Will”](img/B18621_16_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.30: Visitor page with the name “Will”'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter16/Activity16.02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter16/Activity16.02).
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you learned how to create a templated HTTP handler as a struct
    that can be initialized with any external template. You can now create multiple
    pages, instantiating the same struct with different templates of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding external files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, you learned about a very interesting technique, but
    having external files to read can be problematic when deploying something to production,
    especially with Go, where one of its strong features is building a single executable.
    Fortunately, there is a package in Go called `embed` that allows us to add external
    files to our final binary so that we need the original file when we develop, but
    we do not need to share this file with anybody else as it will be compiled and
    added to our final binary. Let’s see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s imagine that you have a simple template file and want to use it on your
    web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at a small program that does exactly that, using what you’ve learned
    in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code, the program will parse the file from your folder and
    use it as a template to display `Hello there` on the `/hello1` path. If you build
    your application and you move your executable to a different folder, however,
    you will receive an error. Let’s modify this software so that it uses the `embed`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference Is that we’ve just created a global variable, `s`, that holds
    the content of the `mytemplate.html` files and stores it in the binary when you
    compile your code using the `//go:embed` build tag directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we create a template with the `New` method and then parse the string.
    If you compile the code and run your application from a different folder, you
    won’t have any errors.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to the server side of web programming.
    You learned how to accept requests from HTTP clients and respond appropriately.
    You also learned how to separate the possible requests into different areas of
    an HTTP server via paths and sub-paths. For this, you used a simple routing mechanism
    with the standard `Go` `HTTP` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you learned how to return your response to suit different consumers:
    JSON responses for synthetic clients, and HTML pages for human access.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you learned how to use templates to format your plain text and HTML messages,
    using the standard templating package. You learned how to serve and use static
    resources, serving them directly through a default file server or a template object.
  prefs: []
  type: TYPE_NORMAL
- en: After that, you learned how to create a middleware and how to embed external
    files inside your binary for better portability. At this stage, you know all the
    basics for building production-grade HTTP servers, although you might want to
    use some external libraries to facilitate your Hello World example, facilitating
    better routing by using something such as gorilla mux or, generally, the entire
    `gorilla` package, which is a low-level abstraction on top of the `http` package.
    You could use `hero` as a template engine to make your page rendering faster.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to mention is that you can make pretty much stateless services with
    what you’ve learned in this chapter, but you cannot create a production-grade
    stateful server at the moment as you do not know how to handle concurrent requests.
    This means that `views counter` is not suitable for a production server yet, but
    this will be the subject of another chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will shift gears and learned how to use the Go HTTP
    client to talk to other systems over the internet.
  prefs: []
  type: TYPE_NORMAL
