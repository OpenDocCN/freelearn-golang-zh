<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer215">
			<h1 id="_idParaDest-426" class="chapter-number"><a id="_idTextAnchor1790"/>17</h1>
			<h1 id="_idParaDest-427">Using the Go HTTP Client<a id="_idTextAnchor1791"/><a id="_idTextAnchor1792"/></h1>
			<p class="callout-heading"><a id="_idTextAnchor1793"/><a id="_idTextAnchor1794"/>Overview</p>
			<p class="callout">This chapter will equip you to use the Go HTTP Client to talk to other systems over <span class="No-Break">the Internet.</span></p>
			<p class="callout">You will start by learning to use the HTTP client to get data from a web server and to send data to a web server. By the end of the chapter, you will be able to upload a file to a web server and experiment with a custom Go HTTP Client to interact with <span class="No-Break">web servers.</span></p>
			<h1 id="_idParaDest-428"><a id="_idTextAnchor1795"/>Technical requirements</h1>
			<p>For this chapter, you’ll require Go version 1.21 or higher. The code for this chapter can be found at: <a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter17"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter17</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-429"><a id="_idTextAnchor1796"/><a id="_idTextAnchor1797"/>Introduction</h1>
			<p>In the previous chapter, you looked<a id="_idIndexMarker1085"/> at web APIs with REST. You learned what REST is, how to think about API design, resources, and errors in REST, as well as the problems with REST and some of <span class="No-Break">its alternatives.</span></p>
			<p>In this chapter, you will learn about the Go HTTP Client and how to use it. An HTTP client is something that is used to get data from or send data to a web server. Probably the most well-known example of an HTTP client is a web browser (such as Firefox, Chrome, and Microsoft Edge). When you enter a web address into a web browser, it will have an HTTP client built in that sends a request to the server for data. The server will gather the data and send it back to the HTTP client, which will then display the web page in the browser. Similarly, when you fill out a form in a web browser, for example, when you log in to a website, the browser will use its HTTP client to send that form data to the server and then take appropriate action, depending on <span class="No-Break">the response.</span></p>
			<p>This chapter looks at how you can use the Go HTTP Client to request data from a web server and send data to a server. You will examine the different ways you can use the HTTP client to interact with a web server and the various use cases for those interactions. The web browser example will be useful in explaining the different interactions. As part of this<a id="_idIndexMarker1086"/> chapter, you will create your own Go programs that make use of the Go HTTP Client to send and receive data from a <span class="No-Break">web server<a id="_idTextAnchor1798"/><a id="_idTextAnchor1799"/>.</span></p>
			<h1 id="_idParaDest-430"><a id="_idTextAnchor1800"/>The Go HTTP Client and its uses</h1>
			<p>The Go HTTP Client is part of the Go<a id="_idIndexMarker1087"/> standard library, specifically the <strong class="source-inline">net/http</strong> package. There are two main ways<a id="_idIndexMarker1088"/> to use it. The first is to use the default HTTP client that is included in the <strong class="source-inline">net/http</strong> package. It’s simple to use and allows you to get up and running quickly. The second way is to create your own HTTP client based on the default HTTP client. This allows you to customize the requests and various other things. It takes longer to configure, but it gives you much more freedom and control over the requests <span class="No-Break">you send.</span></p>
			<p>When using an HTTP client, you can send different types of requests. While there are many types of requests, we will discuss the two main ones: the GET request and the POST request. For instance, if you wanted to retrieve data from a server, you would send a GET request. When you enter a web address in your web browser, it will send a GET request to the server at that address and then display the data it returns. If you wanted to send data to the server, you would send a POST request. If you wanted to log into a website, you would POST your login details to <span class="No-Break">the server.</span></p>
			<p>In this chapter, there are a few exercises to teach you about the Go HTTP Client. They will teach you how to request data from a server in various formats using GET requests. They will also teach you how to POST form data to a web server, similar to how a web browser would send a POST request when you log in to a website. These exercises will also show you how to upload a file to a web server and how to use a customized HTTP client to have more control over the requests <span class="No-Break">you se<a id="_idTextAnchor1801"/><a id="_idTextAnchor1802"/>nd.</span></p>
			<h1 id="_idParaDest-431"><a id="_idTextAnchor1803"/>Sending a request to a server</h1>
			<p>When you want<a id="_idIndexMarker1089"/> to retrieve data<a id="_idIndexMarker1090"/> from a web server, you send a GET request to the server. When sending a request, the URL will contain information on the resource from which you want data. The URL can be broken down into a few key parts. These include the protocol, the hostname, the URI, and the query parameters. The format of it looks <span class="No-Break">like t<a id="_idTextAnchor1804"/>his:</span></p>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="image/B18621_17_01.jpg" alt="Figure 17.1: URL format breakdown" width="764" height="201"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.1: URL format breakdown</p>
			<p>We can see the following in <span class="No-Break">this example:</span></p>
			<ul>
				<li><strong class="source-inline">Protocol</strong> tells the client how to connect to the server. The two most common protocols are HTTP and HTTPS. In this example, we have <span class="No-Break">used </span><span class="No-Break"><strong class="source-inline">https</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">Hostname</strong> is the address of the server we want to connect to. In this example, it <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">example.com</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">URI</strong> is the <strong class="bold">uniform resource identifier</strong> (<strong class="bold">URI</strong>), and this tells the server the path to the resource<a id="_idIndexMarker1091"/> we want. In this example, it <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">/downloads</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">Query Parameters</strong> tells the server about any additional information it needs. In this example, we have two query parameters. These are <strong class="source-inline">filter=latest</strong> and <strong class="source-inline">os=windows</strong>. You will notice they are separated from the URI by <strong class="source-inline">?</strong>. This is so the server can parse them from the request. We join any additional parameters to the end of the URI with the <strong class="source-inline">&amp;</strong> symbol, as seen with the <span class="No-Break"><strong class="source-inline">os</strong></span><span class="No-Break"> param<a id="_idTextAnchor1805"/>e<a id="_idTextAnchor1806"/>ter.</span></li>
			</ul>
			<h2 id="_idParaDest-432"><a id="_idTextAnchor1807"/>Exercise 17.01 – sending a GET request to a web server using the Go HTTP Client</h2>
			<p>In this exercise, you will be getting data<a id="_idIndexMarker1092"/> from a web server<a id="_idIndexMarker1093"/> and printing out that data. You will send a GET request to <a href="https://www.google.com">https://www.google.com</a> and display the data the web <span class="No-Break">server returns:</span></p>
			<ol>
				<li>Create a new directory, <strong class="source-inline">Exercise17.01</strong>. Within that directory, create a new Go file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">main.go</strong></span><span class="No-Break">.</span></li>
				<li>As this is a new program, you will want to set the package of the file to the <strong class="source-inline">main()</strong> function. Import the <strong class="source-inline">net/http</strong> package, the <strong class="source-inline">log</strong> package, and the <strong class="source-inline">io</strong> package. Type the <span class="No-Break">following code:</span><pre class="source-code">
package main
import (
  "io"
  "log"
  "net<a id="_idTextAnchor1808"/>/http"
)</pre><p class="list-inset">Now that you have the package set up and the imports you need, you can start creating a function to get data from a web server. The function you are going to create will request data from a <span class="No-Break">web server.</span></p></li>				<li>Create a function that returns <span class="No-Break">a string:</span><pre class="source-code">
func getDataAndReturnResponse() st<a id="_idTextAnchor1809"/>ring {</pre></li>				<li>Within that function, you can then use the default Go HTTP Client to request data from a server. In this exercise, you will request data from <a href="https://www.google.com">https://www.google.com</a>. To request data from the web server, you use the <strong class="source-inline">Get</strong> function in the <strong class="source-inline">http</strong> package, which looks <span class="No-Break">as follows:</span><pre class="source-code">
  r, err := http.Get("https://www.google.com")
  if err != nil {
    log.Fatal(err)
  }</pre></li>				<li>The data the server sends<a id="_idIndexMarker1094"/> back is contained<a id="_idIndexMarker1095"/> within <strong class="source-inline">r.Body</strong>, so you just need to read that data. To read the data within <strong class="source-inline">r.Body</strong>, you can use the <strong class="source-inline">ReadAll</strong> function within the <strong class="source-inline">io</strong> package. The two together would look <span class="No-Break">like this:</span><pre class="source-code">
  defer r.Body.Close()
  data, err := io.ReadAll(r.Body)
  if err != nil {
    log.Fatal(err)
  }</pre></li>				<li>After you have received the response from the server and read the data, you just need to return that data as a string, which looks <span class="No-Break">like this:</span><pre class="source-code">
  return string<a id="_idTextAnchor1810"/>(data)
}</pre><p class="list-inset">The function you have now created will now look <span class="No-Break">like this:</span></p><pre class="source-code">func getDataAndReturnResponse() string {
  // send the GET request
  r, err := http.Get("https://www.google.com")
  if err != nil {
    log.Fatal(err)
  }
  // get data from the response body
  defer r.Body.Close()
  data, err := io.ReadAll(r.Body)
  if err != nil {
    log.Fatal(err)
  }
  // return the response data
  return string(data)
}</pre></li>				<li>Create a <strong class="source-inline">main</strong> function. Within the <strong class="source-inline">main</strong> function, call the <strong class="source-inline">getDataAndReturnResponse</strong> function and log the string <span class="No-Break">it returns:</span><pre class="source-code">
func main() {
  data := getDataAndReturnResponse()
  log.Println(data)
}</pre></li>				<li>To run the program, open your terminal and navigate to the directory that you created the <strong class="source-inline">main.go</strong> <span class="No-Break">file in.</span></li>
				<li>Run <strong class="source-inline">go run main.go</strong> to compile and execute <span class="No-Break">the file:</span><pre class="source-code">
go run main.go</pre><p class="list-inset">The program will issue a GET request to <a href="https://www.google.com">https://www.google.com</a> and log the response in <span class="No-Break">your terminal.</span></p><p class="list-inset">While it may look<a id="_idIndexMarker1096"/> like gibberish, if you were to save<a id="_idIndexMarker1097"/> that data to a file called <strong class="source-inline">response.html</strong> and open it in your web browser, it would resemble the Google home page. This is what your web browser will do under the hood when you open a web page. It will send a GET request to the server and then display the data it returns. If we do this manually, it will look <span class="No-Break">a<a id="_idTextAnchor1811"/>s follows:</span></p></li>			</ol>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="image/B18621_17_02.jpg" alt="Figure 17.2: Request HTML response when viewed in Chrome" width="1650" height="592"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.2: Request HTML response when viewed in Chrome</p>
			<p>In this exercise, we saw how to send<a id="_idIndexMarker1098"/> a GET request to a web server<a id="_idIndexMarker1099"/> and get data back. You created a Go program that sent a request to <a href="https://www.google.com">https://www.google.com</a> and got back the HTML data for the Googl<a id="_idTextAnchor1812"/><a id="_idTextAnchor1813"/>e <span class="No-Break">home page.</span></p>
			<h1 id="_idParaDest-433"><a id="_idTextAnchor1814"/>Structured data</h1>
			<p>Once you have requested<a id="_idIndexMarker1100"/> data from a server, the data returned can come in various formats. For example, if you send a request to <strong class="source-inline">packtpub.com</strong>, it will return HTML data for the Packt website. While HTML data is useful for displaying websites, it isn’t ideal for sending machine-readable data. A common data type used in web APIs is JSON. JSON provides a good structure for data that is both machine-readable and human-readable. Later, you will learn how to parse JSON and make use of<a id="_idTextAnchor1815"/><a id="_idTextAnchor1816"/> it <span class="No-Break">using Go.</span></p>
			<h2 id="_idParaDest-434"><a id="_idTextAnchor1817"/>Exercise 17.02 – using the HTTP Client with structured data</h2>
			<p>In this exercise, you will parse<a id="_idIndexMarker1101"/> structured JSON data<a id="_idIndexMarker1102"/> in Go. The server will return JSON data, and you will use the <strong class="source-inline">json.Unmarshal</strong> function to parse the data and put them i<a id="_idTextAnchor1818"/>nto <span class="No-Break">a struct:</span></p>
			<ol>
				<li>Create a new directory, <strong class="source-inline">Exercise17.02</strong>. Within that directory, create two more directories, <strong class="source-inline">server</strong> and <strong class="source-inline">client</strong>. Then, within the <strong class="source-inline">server</strong> directory, create a file called <strong class="source-inline">server.go</strong> and write the <span class="No-Break">following code:</span><pre class="source-code">
package main
import (
  "log"
  "net/http"
)
type server struct{}
func (srv server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
  msg := "{\"message\": \"hello world\"}"
  w.Write([]byte(msg))
}
func main() {
  log.Fatal(http.ListenAndServe(":8080", server{}))
}</pre><p class="list-inset">This creates a very basic web server<a id="_idIndexMarker1103"/> that sends back JSON<a id="_idIndexMarker1104"/> data. For now, we will just use it as <span class="No-Break">an example.</span></p></li>				<li>Once you have created the server, navigate to the client directory and create a file called <strong class="source-inline">client.go</strong>. Add <strong class="source-inline">package main</strong>, and import the packages needed for <span class="No-Break">the file:</span><pre class="source-code">
package main
import (
  "encoding/json"
  "fmt"
  "io"
  "log"
  "net/http"
)</pre></li>				<li>Then, create a struct with a string<a id="_idIndexMarker1105"/> parameter that can accept<a id="_idIndexMarker1106"/> the response from the server. You must use the exported field to encode or decode JSON. Fields must start with capital letters to be exported. Then, add a struct tag to customize the encoded JSON key name. If the name of the JSON field is different from the field name in the Go struct, it allows us to link that JSON field to the field in the struct. In our case, the names are the same. We can omit the struct tag, but it is the best practice to use JSON tags explicitly to make it <span class="No-Break">more clear:</span><pre class="source-code">
type messageData struct {
  Message string `json:"message"`
}</pre></li>				<li>Next, create a function that you can call to get and parse the data from the server. Use the struct you just created as the <span class="No-Break">return value:</span><pre class="source-code">
func getDataAndReturnRespons<a id="_idTextAnchor1819"/>e() messageData {</pre><p class="list-inset">When you run the web server, it will listen on <strong class="source-inline">http://localhost:8080</strong>. So, you need to send a GET request to that URL and then read the <span class="No-Break">response body:</span></p><pre class="source-code">  r, err := http.Get("http://localhost:8080")
  if err != nil {
    log.Fatal(err)
  }
  defer r.Body.Close()
  data, err := io.ReadAll(r.Body)
  if err != nil {
    log.Fatal(err)
  }</pre></li>				<li>This time, however, you will parse<a id="_idIndexMarker1107"/> the response instead of simply returning<a id="_idIndexMarker1108"/> it. To do that, you create an instance of the struct you created and then pass it along with the response data <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">json.Unmarshal</strong></span><span class="No-Break">:</span><pre class="source-code">
  message := messageData{}
  err = json.Unmarshal(data, &amp;message)
  if err != nil {
    log.Fatal(err)
  }</pre><p class="list-inset">This will populate the <strong class="source-inline">message</strong> variable with the data returned from <span class="No-Break">the server.</span></p></li>				<li>You then need to return the struct to complete <span class="No-Break">the function:</span><a id="_idTextAnchor1820"/><pre class="source-code">
  return message
}</pre></li>				<li>Finally, call the function you just created from the <strong class="source-inline">main()</strong> function and log the message from <span class="No-Break">the server:</span><pre class="source-code">
func main() {
  data := getDataAndReturnResponse()
  fmt.Println(data.Message)
}</pre></li>				<li>To run this, you need to do two steps. The first is to navigate to the <strong class="source-inline">server</strong> directory in your terminal and run the following command. This will start the <span class="No-Break">web server:</span><pre class="source-code">
go run server.go</pre></li>				<li>In a second terminal window, navigate to the <strong class="source-inline">client</strong> directory and run <strong class="source-inline">go run main.go</strong>. This will start the client and connect to the server. It should output the following mess<a id="_idTextAnchor1821"/>age from <span class="No-Break">the server:</span></li>
			</ol>
			<div>
				<div id="_idContainer208" class="IMG---Figure">
					<img src="image/B18621_17_03.jpg" alt="Figure 17.3: Expected output" width="826" height="94"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.3: Expected output</p>
			<p>In this exercise, you sent<a id="_idIndexMarker1109"/> a GET request<a id="_idIndexMarker1110"/> to the server and received structured data in the JSON format. You then parsed that JSON data to ge<a id="_idTextAnchor1822"/>t t<a id="_idTextAnchor1823"/>he message <span class="No-Break">from it.</span></p>
			<h2 id="_idParaDest-435"><a id="_idTextAnchor1824"/>Activity 17.01 – requesting data from a web server and processing the response</h2>
			<p>Imagine you are interacting<a id="_idIndexMarker1111"/> with a web API. You send a GET request for data and get<a id="_idIndexMarker1112"/> back an array of names. You need to count those names to find out how many of each you have. In this activity, you will do just that. You will send a GET request to the server, get back structured JSON data, parse the data, and count how many of each name you got back in <span class="No-Break">the response:</span></p>
			<ol>
				<li>Create a directory <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">Activity17.01</strong></span><span class="No-Break">.</span></li>
				<li>Create two subdirectories, one called <strong class="source-inline">client</strong> and another <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">server</strong></span><span class="No-Break">.</span></li>
				<li>In the <strong class="source-inline">server</strong> directory, create a file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">server.go</strong></span><span class="No-Break">.</span></li>
				<li>Add the server code <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">server.go</strong></span><span class="No-Break">.</span></li>
				<li>Start the server by calling <strong class="source-inline">go run server.go</strong> in the <span class="No-Break">server directory.</span></li>
				<li>In the <strong class="source-inline">client</strong> directory, create a file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">client.go</strong></span><span class="No-Break">.</span></li>
				<li>In <strong class="source-inline">client.go</strong>, add the <span class="No-Break">necessary imports.</span></li>
				<li>Create structs to parse the <span class="No-Break">response data.</span></li>
				<li>Create a function called <strong class="source-inline">getDataAndParseResponse</strong> that returns <span class="No-Break">two integers.</span></li>
				<li>Send a <strong class="source-inline">GET</strong> request to <span class="No-Break">the server.</span></li>
				<li>Parse the response into a struct. Here is an example of what the data will <span class="No-Break">look like:</span><pre class="source-code">
{"names":["Electric","Electric","Electric","Boogaloo","Boogaloo","Boogaloo","Boogaloo"]}</pre></li>				<li>Loop through the struct and count the occurrences of the names <strong class="source-inline">Electric</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Boogaloo</strong></span><span class="No-Break">.</span></li>
				<li>Return <span class="No-Break">the counts.</span></li>
				<li>Print <span class="No-Break">the counts.</span></li>
			</ol>
			<p>The expecte<a id="_idTextAnchor1825"/>d<a id="_idIndexMarker1113"/> output is<a id="_idIndexMarker1114"/> <span class="No-Break">as follows:</span></p>
			<div>
				<div id="_idContainer209" class="IMG---Figure">
					<img src="image/B18621_17_04.jpg" alt="Figure 17.4: Possible output" width="494" height="84"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.4: Possible output</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The solution for this activity can be found in the GitHub repository <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter17/Activity17.01"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter17/Activity17.01</span></a><span class="No-Break">.</span></p>
			<p>In this activity, we requested data from a web server and processed the data it returned <a id="_idTextAnchor1826"/><a id="_idTextAnchor1827"/>using the Go <span class="No-Break">HTTP Client.</span></p>
			<h1 id="_idParaDest-436"><a id="_idTextAnchor1828"/>Sending data to a server</h1>
			<p>In addition to requesting data<a id="_idIndexMarker1115"/> from a server, you<a id="_idIndexMarker1116"/> will also want to send data to a server. The most common way of doing this is via a POST request. A POST request comes in two main parts: the URL and the body. The body of a POST request is where you put the data you want to send to the server. A common example of this is a login form. When we send a login request, we POST the body to the URL. The web server then checks that the login details within the body are correct and updates our login status. It responds to the request by telling the client whether it succeeded or not. In this section, you will learn how to send data to a s<a id="_idTextAnchor1829"/><a id="_idTextAnchor1830"/>erver using a <span class="No-Break">POST request.</span></p>
			<h2 id="_idParaDest-437"><a id="_idTextAnchor1831"/>Exercise 17.03 – sending a POST request to a web server using the Go HTTP Client</h2>
			<p>In this exercise, you will send a POST request<a id="_idIndexMarker1117"/> to a web server containing<a id="_idIndexMarker1118"/> a message. The web server will then respond with the same message so you can confirm that it <span class="No-Break">received it:</span></p>
			<ol>
				<li>Create a new directory, <strong class="source-inline">Exercise17.03</strong>. Within that directory, create two more directories, <strong class="source-inline">server</strong> and <strong class="source-inline">client</strong>. Then, within the <strong class="source-inline">server</strong> directory, create a file called <strong class="source-inline">server.go</strong> and write the following code. We will ignore error handling to keep in mind brevity for the exercise code, but in real-world applications, be sure to <span class="No-Break">handle errors:</span><pre class="source-code">
package main
import (
  "encoding/json"
  "log"
  "net/http"
)
type server struct{}
type messageData struct {
  Message string `json:"message"`
}
func (srv server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
  jsonDecoder := json.NewDecoder(r.Body)
  messageData := messageData{}
  err := jsonDecoder.Decode(&amp;messageData)
  if err != nil {
    log.Fatal(err)
  }
  jsonBytes, _ := json.Marshal(messageData)
  log.Println(string(jsonBytes))
  w.Write(jsonBytes)
}
func main() {
  log.Fatal(http.ListenAndServe(":8080", server{}))
}</pre><p class="list-inset">This creates a very basic web server<a id="_idIndexMarker1119"/> that receives a JSON POST request<a id="_idIndexMarker1120"/> and returs the message sent to it back to <span class="No-Break">the client.</span></p></li>				<li>Once you have the server created. Navigate to the client directory and create a file called <strong class="source-inline">client.go</strong>. Add <strong class="source-inline">package main</strong> and the imports needed for <span class="No-Break">the file:</span><pre class="source-code">
package main
import (
  "bytes"
  "encoding/json"
  "fmt"
  "io"
  "log"
  "net/http"
)</pre></li>				<li>Next, you need to create<a id="_idIndexMarker1121"/> a struct for the data<a id="_idIndexMarker1122"/> we want to send and receive. This will be the same as the struct used by the server to parse <span class="No-Break">the request:</span><pre class="source-code">
type messageData struct {
  Message string `json:"message"`
}</pre></li>				<li>You then need to create the function to POST the data to the server. It should accept a <strong class="source-inline">messageData</strong> struct parameter as well as return a <span class="No-Break"><strong class="source-inline">messageData</strong></span><span class="No-Break"> struct:</span><pre class="source-code">
func postDataAndReturnResponse(msg messageData) messageData {</pre></li>				<li>To post the data to the server, you need to marshal the struct into bytes that the client can send to the server. To do this, you can use the <strong class="source-inline">json.Marshal</strong> function. Note, we are intentionally ommitting error handling here, but normally you will <span class="No-Break">handle errors:</span><pre class="source-code">
  json<a id="_idTextAnchor1832"/>Bytes, _ := json.Marshal(msg)</pre></li>				<li>Now that you have the bytes, you can use the <strong class="source-inline">http.Post</strong> function to send the POST request. Within the request, you just need to tell the function what URL to post to, what kind of data you are sending, and the data you want to send. In this case, the URL is <strong class="source-inline">http://localhost:8080</strong>. The content you are sending is <strong class="source-inline">application/json</strong>, and the data are the <strong class="source-inline">jsonBytes</strong> variable you just created. Together, it looks <span class="No-Break">like this:</span><pre class="source-code">
  r, err := http.Post("http://localhost:8080", "application/json", bytes.NewBuffer(jsonBytes))
  if err != nil {
    log.Fatal(err)
  }</pre></li>				<li>After that, the rest of the function<a id="_idIndexMarker1123"/> is the same as in the previous<a id="_idIndexMarker1124"/> exercise. You read the response, parse out the data, and then return the data, which looks <span class="No-Break">like this:</span><pre class="source-code">
  defer r.Body.Close()
  data, err := io.ReadAll(r.Body)
  if err != nil {
    log.Fatal(err)
  }
  message := messageData{}
  err = json.Unmarshal(data, &amp;message)
  if err != nil {
    log.Fatal(err)
  }
  return message
}</pre></li>				<li>Then, you need to call the <strong class="source-inline">postDataAndReturnResponse</strong> function from your <strong class="source-inline">main</strong> function. This time, however, you need to pass the message you want to send to the function. You just need to create an instance of the <strong class="source-inline">messageData</strong> struct and pass that to the function when you call it, which looks <span class="No-Break">like this:</span><pre class="source-code">
func main() {
  msg := messageData{Message: "Hi Server!"}
  data := postDataAndReturnResponse(msg<a id="_idTextAnchor1833"/>)
  fmt.Println(data.Message)
}</pre></li>				<li>To run this exercise, you need<a id="_idIndexMarker1125"/> to carry out two steps. The first<a id="_idIndexMarker1126"/> is to navigate to the <strong class="source-inline">server</strong> directory in your terminal and run <strong class="source-inline">go run server.go</strong>. This will start the web server. In a second terminal window, navigate to the <strong class="source-inline">client</strong> directory and run <strong class="source-inline">go run main.go</strong>. This will start the client and connect to the server. It should output th<a id="_idTextAnchor1834"/>e following message from <span class="No-Break">the server:</span></li>
			</ol>
			<div>
				<div id="_idContainer210" class="IMG---Figure">
					<img src="image/B18621_17_05.jpg" alt="Figure 17.5: Expected output" width="882" height="95"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.5: Expected output</p>
			<p>In this exercise, you sent a POST request to the server. The server parsed the request and sent the same message back to you. If you change the message sent to the server, you should see the response from the <a id="_idTextAnchor1835"/>serve<a id="_idTextAnchor1836"/>r sending back the <span class="No-Break">new message.</span></p>
			<h2 id="_idParaDest-438"><a id="_idTextAnchor1837"/>Uploading files in a POST request</h2>
			<p>Another common example<a id="_idIndexMarker1127"/> of data you might<a id="_idIndexMarker1128"/> want to post to a web server is a file from your local computer. This is how websites allow users to upload their photos and so on. As you can imagine, this is more complex than sending simple form data. To achieve this, the file needs to be read first and then wrapped in a format that the server can understand. It can then be sent in a POST request to the server in what’s called a multipart form. You will learn how to read a fi<a id="_idTextAnchor1838"/><a id="_idTextAnchor1839"/>le and upload it to a server <span class="No-Break">using Go.</span></p>
			<h2 id="_idParaDest-439"><a id="_idTextAnchor1840"/>Exercise 17.04 – uploading a file to a web server via a POST request</h2>
			<p>In this exercise, you will read in a local file<a id="_idIndexMarker1129"/> and then upload it to a web<a id="_idIndexMarker1130"/> server. You can then check that the web server saved the file <span class="No-Break">you uploaded:</span></p>
			<p>Create a new directory, <strong class="source-inline">Exercise17.04</strong>. Within that directory, create two more directories, <strong class="source-inline">server</strong> and <strong class="source-inline">client</strong>. Then, within the <strong class="source-inline">server</strong> directory, create a file called <strong class="source-inline">server.go</strong> and write the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
func (srv server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
  uploadedFile, uploadedFileHeader, err := r.FormFile("myFile")
  if err != nil {
    log.Fatal(err)
  }
  defer uploadedFile.Close()
  fileContent, err := io.ReadAll(uploadedFile)
  if err != nil {
    log.Fatal(err)
  }</pre>			<ol>
				<li>The full code for this step is available <span class="No-Break">at:</span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter17"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter17</span></a><span class="No-Break"> </span><span class="No-Break">.</span><p class="list-inset">This creates a very basic web server that receives a multipart form POST request and saves the file within the form. A multipart form is a content type used for encoding files or binary data along with textual key-value pairs in HTTP requests. We are using this encoding to include files as part of the form data, as this is the standard way to handle file uploads in <span class="No-Break">HTML forms.</span></p></li>
				<li>Once you have created the server, navigate to the client directory and create a file called <strong class="source-inline">client.go</strong>. Add <strong class="source-inline">package main</strong> and the imports needed for <span class="No-Break">the file:</span><pre class="source-code">
package main
import (
  "bytes"
  "fmt"
  "io"
  "io"
  "log"
  "mime/multipart"
  "net/http"
  "os"
)</pre></li>				<li>You then need to create a function<a id="_idIndexMarker1131"/> to call that you will give a filename<a id="_idIndexMarker1132"/> to. The function will read in the file, upload it to the server, and return the <span class="No-Break">server’s response:</span><pre class="source-code">
func postFileAndRet<a id="_idTextAnchor1841"/>urnResponse(filename string) string {</pre></li>				<li>You need to create a buffer that you can write the file bytes to and then create a writer to allow bytes to write <span class="No-Break">into it:</span><pre class="source-code">
  fileDataBuffer := bytes.Buffer{}
  multipartWriter := multipart.NewWriter(&amp;fileDataBuffer)</pre></li>				<li>Open the file from your local computer using the <span class="No-Break">following command:</span><pre class="source-code">
  file, err := os.Open(filename)
  if err != nil {
    log.Fatal(err)
  }</pre></li>				<li>Once you have opened the local file, you need to create <strong class="source-inline">formFile</strong>. This wraps the file data in the right format to upload it to <span class="No-Break">the server:</span><pre class="source-code">
  formFile, err := multipartWriter.CreateFormFile("myFile", file.Name())
  if err != nil {
    log.Fatal(err)
  }</pre></li>				<li>Copy the bytes from the local file into the form file and then close the form file writer so that it knows no more data will <span class="No-Break">be added:</span><pre class="source-code">
  _, err = io.Copy(formFile, file)
  if err != nil {
    log.Fatal(err)
  }
  multipartWriter.Close()</pre></li>				<li>Next, you need to create the POST request<a id="_idIndexMarker1133"/> that you want to send<a id="_idIndexMarker1134"/> to the server. In the previous exercises, we used shortcut functions such as <strong class="source-inline">http.Post</strong>. However, in this exercise, we need more control over the data being sent. That means we’ll need to create <strong class="source-inline">http.Request</strong>. In this case, you’re creating a POST request that you will send to <strong class="source-inline">http://localhost:8080</strong>. As we are uploading a file, the bytes buffer also needs to be included in the request; this looks like <span class="No-Break">the following:</span><pre class="source-code">
  req, err := http.NewRequest("POST", "http://localhost:8080", &amp;fileDataBuffer)
  if err != nil {
    log.Fatal(err)
  }</pre></li>				<li>You then need to set the <strong class="source-inline">Content-Type</strong> request<a id="_idIndexMarker1135"/> header. This tells the server about the content<a id="_idIndexMarker1136"/> of the file so it knows how to handle <span class="No-Break">the upload:</span><pre class="source-code">
  req.Header.Set("Content-Type", multipartWriter.FormDataContentType())</pre></li>				<li>Send the request <span class="No-Break">as follows:</span><pre class="source-code">
  response, err := http.DefaultClient.Do(req)
  if err != nil {
    log.Fatal(err)
  }</pre></li>				<li>After you have sent the request, we can read in the response and return the data <span class="No-Break">within it:</span><pre class="source-code">
  defer response.Body.Close()
  data, err := io.ReadAll(response.Body)
  if err != nil {
    log.Fatal(err)
  }
  return string(data)
}</pre></li>				<li>Finally, you just need to call the <strong class="source-inline">postFileAndReturnResponse</strong> function and tell it what file <span class="No-Break">to upload:</span><pre class="source-code">
func main() {
  data := postFileAndReturnRes<a id="_idTextAnchor1842"/>ponse("./test.txt")
  fmt.Println(data)
}</pre></li>				<li>To run this, you need to carry out two steps. The first is to navigate to the <strong class="source-inline">server</strong> directory in your terminal and run <strong class="source-inline">go run server.go</strong>. This will start the <span class="No-Break">web server:</span><pre class="source-code">
go run server.go</pre></li>				<li>Next, in the <strong class="source-inline">client</strong> directory, create a file named <strong class="source-inline">test.txt</strong> and put a few lines of text <span class="No-Break">in it.</span></li>
				<li>In a second terminal<a id="_idIndexMarker1137"/> window, navigate to the <strong class="source-inline">client</strong> directory<a id="_idIndexMarker1138"/> and run <strong class="source-inline">go run client.go</strong>. This will start the client and connect to <span class="No-Break">the server:</span><pre class="source-code">
go run client.go</pre></li>				<li>The client will then read in <strong class="source-inline">test.txt</strong> and upload it to the server. The client should give the <span class="No-Break">following output:</span></li>
			</ol>
			<div>
				<div id="_idContainer211" class="IMG---Figure">
					<img src="image/B18621_17_06.jpg" alt="Figure 17.6: Expected client output" width="533" height="71"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.6: Expected client output</p>
			<p>Then, if you navigate to the <strong class="source-inline">server</strong> directory, you should see that the <strong class="source-inline">test.txt</strong> file has <span class="No-Break">now appeared:</span></p>
			<div>
				<div id="_idContainer212" class="IMG---Figure">
					<img src="image/B18621_17_07.jpg" alt="Figure 17.7: Expected text file present" width="915" height="70"/>
				</div>
			</div>
			<p class="IMG---Figure"><a id="_idTextAnchor1843"/></p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.7: Expected text file present</p>
			<p>In this exercise, you sent a file to a web server using the Go HTTP Client. This approach works well with small files but can lead to memory overflow in the case of big files. Therefore, you may have to adapt the code if using large files to use alternative methods, such as <strong class="source-inline">os.Pipe()</strong>. In this example, with a small file, you had the file read in from the disk, formatted it into a POST request, and sent the data to the server. You saw the use of multipart form file uploading. We also saw the use of Go <strong class="source-inline">http.DefaultClient</strong>. <strong class="source-inline">DefaultClient</strong> works great; however, it should never be used in a production environment as it does not set a default timeout for HTTP requests. When making HTTP<a id="_idIndexMarker1139"/> requests, it is crucial to set timeouts<a id="_idIndexMarker1140"/> to ensure that your application does not hang indefinitely in the<a id="_idTextAnchor1844"/> case o<a id="_idTextAnchor1845"/>f network issues or <span class="No-Break">unresponsive servers.</span></p>
			<h2 id="_idParaDest-440"><a id="_idTextAnchor1846"/>Custom request headers</h2>
			<p>Sometimes there is more to a request<a id="_idIndexMarker1141"/> than simply requesting or sending data. This information is stored within the request headers. A very common example of this is authorization headers. When you log into a server, it will respond with an authorization token. In all future requests sent to the server, you would include this token in the request’s headers so the server knows you are the one making the requests. You will learn how<a id="_idTextAnchor1847"/><a id="_idTextAnchor1848"/> to add an authorization token to <span class="No-Break">requests later.</span></p>
			<h2 id="_idParaDest-441"><a id="_idTextAnchor1849"/>Exercise 17.05 – using custom headers and options with the Go HTTP Client</h2>
			<p>In this exercise, you will create<a id="_idIndexMarker1142"/> your own HTTP client<a id="_idIndexMarker1143"/> and set custom options on it. You will also set an authorization token in the request headers so the<a id="_idTextAnchor1850"/> server knows it is you requesting <span class="No-Break">the data:</span></p>
			<ol>
				<li>Create a new directory, <strong class="source-inline">Exercise17.05</strong>. Within that directory, create two more directories, <strong class="source-inline">server</strong> and <strong class="source-inline">client</strong>. Then, within the <strong class="source-inline">server</strong> directory, create a file called <strong class="source-inline">server.go</strong> and write the <span class="No-Break">following code:</span><pre class="source-code">
package main
import (
  "log"
  "net/http"
  "time"
)
type server struct{}
func (srv server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
  auth := r.Header.Get("Authorization")
  if auth != "superSecretToken" {
    w.WriteHeader(http.StatusUnauthorized)
    w.Write([]byte("Authorization token not recognized"))
    return
  }
  time.Sleep(10 * time.Second)
  msg := "hello client!"
  w.Write([]byte(msg))
}
func main() {
  log.Fatal(http.ListenAndServe(":8080", server{}))
}</pre><p class="list-inset">This creates a very basic web server<a id="_idIndexMarker1144"/> that receives<a id="_idIndexMarker1145"/> a request, checks the authorization header is correct, waits 10 seconds, and then sends <span class="No-Break">back data.</span></p></li>				<li>Once you have created the server, navigate to the client directory and create a file called <strong class="source-inline">client.go</strong>. Add <strong class="source-inline">package main</strong> and the imports needed for <span class="No-Break">the file:</span><pre class="source-code">
package main
import (
  "fmt"
  "io"
  "log"
  "net/http"
  "time"
)</pre></li>				<li>Then, you need to create<a id="_idIndexMarker1146"/> a function that will create<a id="_idIndexMarker1147"/> an HTTP client, set the timeout limitations, and set the <span class="No-Break">authorization header:</span><pre class="source-code">
func getD<a id="_idTextAnchor1851"/>ataWithCustomOptionsAndReturnResponse() string {</pre></li>				<li>You need to create your own HTTP client and set the timeout to <span class="No-Break">11 seconds:</span><pre class="source-code">
  client := http.Client{Timeout: 11 * time.Second}</pre></li>				<li>You also need to create a request to send it to the server. You should create a GET request with the URL <strong class="source-inline">http://localhost:8080</strong>. No data will be sent in this request, so the data can be set to nil. You can use the <strong class="source-inline">http.NewRequest</strong> function to <span class="No-Break">do this:</span><pre class="source-code">
  req, err := http.NewRequest("POST", "http://localhost:8080", nil)
  if err != nil {
    log.Fatal(err)
  }</pre></li>				<li>If you look at the server code again, you will notice that it checks for the <strong class="source-inline">Authorization</strong> request header, and it expects its value to be <strong class="source-inline">superSecretToken</strong>. So, you need to set the <strong class="source-inline">Authorization</strong> header in your request <span class="No-Break">as well:</span><pre class="source-code">
  re<a id="_idTextAnchor1852"/>q.Header.Set("Authorization", "superSecretToken")</pre></li>				<li>You then get the client you created to enact <span class="No-Break">the request:</span><pre class="source-code">
  resp, err := client.Do(req)
  if err != nil {
    log.Fatal(err)
  }</pre></li>				<li>Then, you need to read<a id="_idIndexMarker1148"/> in the response from the server<a id="_idIndexMarker1149"/> and return <span class="No-Break">the data:</span><pre class="source-code">
  defer resp.Body.Close()
  data, err := io.ReadAll(resp.Body)
  if err != nil {
    log.Fatal(err)
  }
  return string(data)
}</pre></li>				<li>Finally, you need to call the function you just created from the <strong class="source-inline">main</strong> function and log the data <span class="No-Break">it returns:</span><pre class="source-code">
func main() {
  data := getDataWithCustomOptionsAndReturnResponse()
  fmt.Println(data)
}</pre></li>				<li>To run this exercise, you need to carry out two steps. The first is to navigate to the <strong class="source-inline">server</strong> directory in your terminal and run <strong class="source-inline">go run server.go</strong>. This will start the <span class="No-Break">web server.</span></li>
				<li>In a second terminal window, navigate to the directory you created <span class="No-Break"><strong class="source-inline">client</strong></span><span class="No-Break"> in.</span></li>
				<li>To execute the client, run the <span class="No-Break">following command:</span><pre class="source-code">
go run client.go</pre></li>			</ol>
			<p>This will start the client and connect to the server. The client will send the request to the server, and after 10 seconds, it should output <span class="No-Break">the following:</span></p>
			<div>
				<div id="_idContainer213" class="IMG---Figure">
					<img src="image/B18621_17_08.jpg" alt="Figure 17.8: Expected output" width="670" height="67"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.8: Expected output</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Change the timeout settings in the client to under 10 seconds and see what happens. You can also change or remove the authorization header on the request and see <span class="No-Break">what happens.</span></p>
			<p>In this exercise, you learned<a id="_idIndexMarker1150"/> how to add custom headers<a id="_idIndexMarker1151"/> to a request. You learned about the common example of adding an authorization header, which is <a id="_idTextAnchor1853"/><a id="_idTextAnchor1854"/>required by many APIs when you want to interact <span class="No-Break">with them.</span></p>
			<h2 id="_idParaDest-442"><a id="_idTextAnchor1855"/>Activity 17.02 – sending data to a web server and checking whether the data was received using POST and GET</h2>
			<p>Imagine you are interacting<a id="_idIndexMarker1152"/> with a web API, and you wish to send data to a web<a id="_idIndexMarker1153"/> server. You<a id="_idIndexMarker1154"/> then want to check whether the data<a id="_idIndexMarker1155"/> was added. In this<a id="_idIndexMarker1156"/> activity, you will do just that. You will send a POST request to the server and then request the data back using a GET request, parse the data, and print <span class="No-Break">it out.</span></p>
			<p>Follow these steps<a id="_idIndexMarker1157"/> to get<a id="_idIndexMarker1158"/> the <span class="No-Break">desired</span><span class="No-Break"><a id="_idIndexMarker1159"/></span><span class="No-Break"> outcome:</span></p>
			<ol>
				<li>Create a directory <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">Activity17.02</strong></span><span class="No-Break">.</span></li>
				<li>Create two subdirectories, one called <strong class="source-inline">client</strong> and one <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">server</strong></span><span class="No-Break">.</span></li>
				<li>In the <strong class="source-inline">server</strong> directory, create a file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">server.go</strong></span><span class="No-Break">.</span></li>
				<li>Add the server code to the <span class="No-Break"><strong class="source-inline">server.go</strong></span><span class="No-Break"> file.</span></li>
				<li>Start the server by calling <strong class="source-inline">go run server.go</strong> in the <span class="No-Break">server directory.</span></li>
				<li>In the <strong class="source-inline">client</strong> directory, create a file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">client.go</strong></span><span class="No-Break">.</span></li>
				<li>In <strong class="source-inline">client.go</strong>, add the <span class="No-Break">necessary imports.</span></li>
				<li>Create structs to host the request data, which looks like the <span class="No-Break">following: </span><span class="No-Break"><strong class="source-inline">{"name":"Electric"}</strong></span><span class="No-Break">.</span></li>
				<li>Create structs to parse the response data, which looks like the <span class="No-Break">following: </span><span class="No-Break"><strong class="source-inline">{"ok":true}.</strong></span></li>
				<li>Create an <strong class="source-inline">addNameAndParseResponse</strong> function that posts a name to <span class="No-Break">the server.</span></li>
				<li>Create a <strong class="source-inline">getDataAndParseResponse</strong> function that parses the <span class="No-Break">server response.</span></li>
				<li>Send a POST request to the server to <span class="No-Break">add names.</span></li>
				<li>Send a GET request to <span class="No-Break">the server.</span></li>
				<li>Parse the response into <span class="No-Break">a struct.</span></li>
				<li>Loop through the struct and print <span class="No-Break">the names.</span></li>
			</ol>
			<p>This is the <span class="No-Break">expected output:</span></p>
			<div>
				<div id="_idContainer214" class="IMG---Figure">
					<img src="image/B18621_17_09.jpg" alt="Figure 17.9: Possible output" width="669" height="103"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.9: Possible output</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The solution for this activity can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter17/Activity17.02"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter17/Activity17.02</span></a><span class="No-Break">.</span></p>
			<p>In this activity, you saw<a id="_idIndexMarker1160"/> how to send data to a web<a id="_idIndexMarker1161"/> server using a POST request<a id="_idIndexMarker1162"/> and then how to request data<a id="_idIndexMarker1163"/> from the server to<a id="_idIndexMarker1164"/> ensure it was updated using a GET request. Interacting wit<a id="_idTextAnchor1856"/><a id="_idTextAnchor1857"/>h a serv<a id="_idTextAnchor1858"/><a id="_idTextAnchor1859"/>er in this way is very common when <span class="No-Break">programming professionally.</span></p>
			<h1 id="_idParaDest-443"><a id="_idTextAnchor1860"/>Summary</h1>
			<p>HTTP clients are used to interact with web servers. They are used to send different types of requests to a server (for example, GET or POST requests) and then react to the response returned by the server. A web browser is a type of HTTP client that will send a GET request to a web server and display the HTML data it returns. In Go, you created your own HTTP client and did the same thing, sending a GET request to <a href="https://www.google.com">https://www.google.com</a> and then logging the response returned by the server. You also learned about the components of a URL and that you can control what you request from a server by changing <span class="No-Break">the URL.</span></p>
			<p>There is also more to web servers than simply requesting HTML data. You learned that they can return structured data in the form of JSON, which can be parsed and used in your code. Data can also be sent to a server using POST requests, allowing you to send form data to a server. However, the data sent to a server isn’t limited to just form data: you can also upload files to a server using a <span class="No-Break">POST request.</span></p>
			<p>There are also ways to customize the requests you send. You learned about the common example of authorization, where you add a token to the header of HTTP requests so that a server can tell who is making <span class="No-Break">that request.</span></p>
		</div>
	</div></div>
<div id="book-content"><div id="sbo-rt-content"><div id="_idContainer216" class="Content">
			<h1 id="_idParaDest-444" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor1861"/>Part 6: Professional</h1>
			<p>Having gained proficiency in utilizing Go for real-world tasks, it’s time to equip you with the tools and techniques essential for professional programming <span class="No-Break">in Go.</span></p>
			<p>This section encompasses advanced topics and best practices aimed at elevating your programming skills to a <span class="No-Break">professional level.</span></p>
			<p>This section includes the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18621_18.xhtml#_idTextAnchor1862"><em class="italic">Chapter 18</em></a>, <em class="italic">Concurrent Work</em></li>
				<li><a href="B18621_19.xhtml#_idTextAnchor2002"><em class="italic">Chapter 19</em></a>, <em class="italic">Testing</em></li>
				<li><a href="B18621_20.xhtml#_idTextAnchor2072"><em class="italic">Chapter 20</em></a>, <em class="italic">Using Go Tools</em></li>
				<li><a href="B18621_21.xhtml#_idTextAnchor2172"><em class="italic">Chapter 21</em></a>, <em class="italic">Go in the Cloud</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer217">
			</div>
		</div>
	</div></div></body></html>