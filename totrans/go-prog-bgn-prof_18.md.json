["```go\nfunc hello() {\n  fmt.Println(\"hello world\")\n}\n```", "```go\ngo hello()\n```", "```go\nfunc main() {\n  fmt.Println(\"Start\")\n  go hello()\n  fmt.Println(\"End\")\n```", "```go\n    package main\n    import \"fmt\"\n    ```", "```go\n    func sum(from, to int) int {\n      res := 0\n      for i := from; i<=to; i++ {\n        res += i\n      }\n      return res\n    }\n    ```", "```go\n    func main() {\n      s1 := sum(1, 100)\n      fmt.Println(s1)\n    }\n    ```", "```go\n    go run main.go\n    ```", "```go\n    5050\n    ```", "```go\n    func main() {\n      var s1 int\n      go func() {\n        s1 = sum(1, 100)\n      }()\n      fmt.Println(s1)\n    }\n    ```", "```go\n    func main() {\n      var s1, s2 int\n      go func() {\n        s1 = sum(1, 100)\n      }()\n      s2 = sum(1, 10)\n      fmt.Println(s1, s2)\n    }\n    ```", "```go\n    time.Sleep(time.Second)\n    ```", "```go\n    import (\n      \"log\"\n      \"time\"\n    )\n    ```", "```go\n    log.Println(s1, s2)\n    ```", "```go\n    2024/01/25 19:23:00 5050 55\n    ```", "```go\nwg := sync.WaitGroup{}\n```", "```go\npackage main\nimport \"sync\"\nfunc main() {\n  wg := &sync.WaitGroup{}\n  wg.Add(1)\n  …………………..\n  wg.Wait()\n  ………….\n  ………….\n}\n```", "```go\nwg.Done()\n```", "```go\n    package main\n    import (\n      \"log\"\n      \"sync\"\n    )\n    ```", "```go\n    func sum(from,to int, wg *sync.WaitGroup, res *int) {\n    ```", "```go\n      *res = 0\n      for i := from; i <=to ; i++ {\n        *res += i\n      }\n    ```", "```go\n      wg.Done()}\n    ```", "```go\n    func main() {\n      s1 := 0\n      wg := &sync.WaitGroup{}\n    ```", "```go\n      wg.Add(1)\n      go sum(1,100, wg, &s1)\n    ```", "```go\n      wg.Wait()\n      log.Println(s1)\n    }\n    ```", "```go\n    go run main.go\n    ```", "```go\n2024/01/25 19:24:51 5050\n```", "```go\nfunc next(v *int) {\n  c := *v\n  *v = c + 1\n}\n```", "```go\na := 0\nnext(&a)\nnext(&a)\nnext(&a)\n```", "```go\na := 0\ngo next(&a)\ngo next(&a)\ngo next(&a)\n```", "```go\nc := *v\n```", "```go\ns = 0\ns = 1\ns = 3 // (1 + 2)\ns = 6\ns = 10\n```", "```go\ns = 0\ns = 1\ns = 4 // 3 + 1, the previous value of 1\ns = 6 // 2 + 4 the previous value of 4\ns = 10\n```", "```go\nfunc AddInt32(addr *int32, delta int32) (new int32)\n```", "```go\n    package main\n    import (\n      \"log\"\n      \"sync\"\n      \"sync/atomic\"\n    )\n    ```", "```go\n    func sum(from, to int, wg *sync.WaitGroup, res *int32) {\n    ```", "```go\n      for i := from; i <= to; i++ {\n        atomic.AddInt32(res, int32(i))\n      }\n      wg.Done()\n      return\n    }\n    ```", "```go\n    func main() {\n      s1 := int32(0)\n      wg := &sync.WaitGroup{}\n    ```", "```go\n      wg.Add(4)\n    ```", "```go\n      go sum(1, 25, wg, &s1)\n      go sum(26, 50, wg, &s1)\n      go sum(51, 75, wg, &s1)\n      go sum(76, 100, wg, &s1)\n    ```", "```go\n      wg.Wait()\n      log.Println(s1)\n    }\n    ```", "```go\n    go run main.go\n    2024/01/25 19:26:04 5050\n    ```", "```go\n    package main\n    import (\n      \"bytes\"\n      \"log\"\n      \"testing\"\n    )\n    func Test_Main(t *testing.T) {\n      for i:=0; i < 10000; i++ {\n        var s bytes.Buffer\n        log.SetOutput(&s)\n        log.SetFlags(0)\n        main()\n        if s.String() != \"5050\\n\" {\n          t.Error(s.String())\n        }\n      }\n    }\n    ```", "```go\n    go test\n    ```", "```go\n    PASS\n    ok parallelwork 0.048s\n    ```", "```go\n    go test -race\n    ```", "```go\n    PASS\n    ok parallelwork 3.417s\n    ```", "```go\n    atomic.AddInt32(res, int32(i))\n    ```", "```go\n    *res = *res + int32(i)\n    ```", "```go\n    go run main.go\n    ```", "```go\n    2024/01/25 19:30:47 5050\n    ```", "```go\n    go test -race\n    ```", "```go\nmtx := sync.Mutex{}\n```", "```go\nmtx := &sync.Mutex{}\n```", "```go\nmtx.Lock()\ns = s + 5\n```", "```go\nmtx.Unlock()\n```", "```go\nvar ch chan int\nch = make(chan int)\n```", "```go\nch := make(chan int)\n```", "```go\nch := make(chan int, 10)\n```", "```go\nch <- 2\n```", "```go\n<- ch\n```", "```go\ni := <- ch\n```", "```go\npackage main\nimport \"log\"\nfunc main() {\n  ch := make(chan int, 1)\n  ch <- 1\n  i := <- ch\n  log.Println(i)\n}\n```", "```go\nch := make(chan int)\n```", "```go\nfatal error: all goroutines are asleep - deadlock!\ngoroutine 1 [chan send]:\nmain.main()\n    /Users/ samcoyle/go/src/github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter19/Exercise19.04/main.go:8 +0x59Process finished with exit code 2\n```", "```go\nclose(ch)\n```", "```go\n...\ndefer close(ch)\nfor i := 0; i < 100; i++ {\n  ch <- i\n}\nreturn\n```", "```go\n    package main\n    import (\n      \"log\"\n    )\n    ```", "```go\n    func greet(ch chan string) {\n      ch <- \"Hello\"\n    }\n    ```", "```go\n    func main() {\n      ch := make(chan string)\n      go greet(ch)\n    ```", "```go\n      log.Println(<-ch)\n    }\n    ```", "```go\n    <- ch\n    ```", "```go\n    go run main.go\n    ```", "```go\n2024/01/25 19:44:11 Hello\n```", "```go\n    package main\n    import (\n      \"fmt\"\n      \"log\"\n    )\n    ```", "```go\n    func greet(ch chan string) {\n      msg := <- ch\n      ch <- fmt.Sprintf(\"Thanks for %s\", msg)\n      ch <- \"Hello David\"\n    }\n    ```", "```go\n    func main() {\n      ch := make(chan string)\n      go greet(ch)\n    ```", "```go\n      ch <- \"Hello John\"\n    ```", "```go\n      log.Println(<-ch)\n      log.Println(<-ch)\n    }\n    ```", "```go\n2024/01/25 19:44:49 Thanks for Hello John\n2024/01/25 19:44:49 Hello David\n```", "```go\n    package main\n    import (\n      \"log\"\n      \"time\"\n    )\n    ```", "```go\n    func push(from, to int, out chan int) {\n      for i := from; i <= to; i++ {\n        out <- i\n        time.Sleep(time.Microsecond)\n      }\n    }\n    ```", "```go\n    func main() {\n      s1 := 0\n      ch := make(chan int, 100)\n    ```", "```go\n      go push(1, 25, ch)\n      go push(26, 50, ch)\n      go push(51, 75, ch)\n      go push(76, 100, ch)\n    ```", "```go\n      for c := 0; c < 100; c++ {\n    ```", "```go\n        i := <- ch\n    ```", "```go\n        log.Println(i)\n    ```", "```go\n        s1 += i\n      }\n      log.Println(s1)\n    }\n    ```", "```go\n2024/01/25 21:42:09 76\n2024/01/25 21:42:09 26\n2024/01/25 21:42:09 51\n2024/01/25 21:42:09 77\n2024/01/25 21:42:09 52\n……………………………………………………………\n2024/01/25 21:42:09 48\n2024/01/25 21:42:09 75\n2024/01/25 21:42:09 100\n2024/01/25 21:42:09 23\n2024/01/25 21:42:09 49\n2024/01/25 21:42:09 24\n2024/01/25 21:42:09 50\n2024/01/25 21:42:09 25\n2024/01/25 21:42:09 5050\n```", "```go\n    package main\n    import (\n      \"log\"\n    )\n    ```", "```go\n    func push(from, to int, in chan bool, out chan int) {\n    ```", "```go\n      for i := from; i <= to; i++ {\n        <- in\n        out <- i\n      }\n    }\n    ```", "```go\n    func main() {\n      s1 := 0\n      out := make(chan int, 100)\n      in := make(chan bool, 100)\n      go push(1, 25, in, out)\n      go push(26, 50, in, out)\n      go push(51, 75, in, out)\n      go push(76, 100, in, out)\n    ```", "```go\n      for c := 0; c < 100; c++ {\n        in <- true\n        i := <- out\n        log.Println(i)\n        s1 += i\n      }\n      log.Println(s1)\n    }\n    ```", "```go\n2024/01/25 22:18:00 76\n2024/01/25 22:18:00 1\n2024/01/25 22:18:00 77\n2024/01/25 22:18:00 26\n2024/01/25 22:18:00 51\n2024/01/25 22:18:00 2\n2024/01/25 22:18:00 78\n…………………………………………………………\n2024/01/25 22:18:00 74\n2024/01/25 22:18:00 25\n2024/01/25 22:18:00 50\n2024/01/25 22:18:00 75\n2024/01/25 22:18:00 5050\n```", "```go\n    package main\n    import (\n      \"log\"\n    )\n    ```", "```go\n    func worker(in chan int, out chan int) {\n      sum := 0\n      for i := range in {\n        sum += i\n      }\n      out <- sum\n    }\n    ```", "```go\n    <- in\n    ```", "```go\n    func sum(workers, from, to int) int {\n    ```", "```go\n      out := make(chan int, workers)\n      in := make(chan int, 4)\n      for i := 0; i <  workers; i++ {\n        go worker(in, out)\n      }\n    ```", "```go\n      for i := from; i <= to; i++ {\n        in <- i\n      }\n    ```", "```go\n      close(in)\n    ```", "```go\n      sum := 0\n      for i := 0; i < workers; i++ {\n        sum += <-out\n      }\n    ```", "```go\n      close(out)\n      return sum\n    }\n    ```", "```go\n    func main() {\n      res := sum(100, 1, 100)\n      log.Println(res)\n    }\n    ```", "```go\n2024/01/25 19:49:13 5050\n```", "```go\nch1 := make(chan int)\nch2 := make(chan int, 10)\n```", "```go\ni := <- ch\n```", "```go\nch := make(chan int, 2)\nch <- 1\nch <- 2\nfmt.Println(<-ch)\nfmt.Println(<-ch)\n```", "```go\n1\n2\n```", "```go\nch := make(chan int, 2)\nch <- 1\nch <- 2\nch <- 3\nfmt.Println(<-ch)\nfmt.Println(<-ch)\n```", "```go\nfatal error: all goroutines are asleep - deadlock!\ngoroutine 1 [chan send]:\nmain.main()\n    /tmp/sandbox223984687/prog.go:9 +0xa0\n```", "```go\nch := make(chan int, 3)\n```", "```go\nch := make(chan int, 0)\n```", "```go\npackage main\nimport \"fmt\"\nfunc readThem(ch chan int) {\n  for {\n    fmt.Println(<- ch)\n  }\n}\nfunc main() {\n  ch := make(chan int)\n  go readThem(ch)\n  ch <- 1\n  ch <- 2\n  ch <- 3\n}\n```", "```go\n1\n2\n3\n```", "```go\nch <- 4\nch <- 5\n```", "```go\npackage main\nimport \"fmt\"\nimport \"sync\"\nfunc readThem(ch chan int, wg *sync.WaitGroup) {\n  for i := range ch {\n    fmt.Println(i)\n  }\n  wg.Done()\n}\nfunc main() {\n  wg := &sync.WaitGroup{}\n  wg.Add(1)\n  ch := make(chan int)\n  go readThem(ch, wg)\n  ch <- 1\n  ch <- 2\n  ch <- 3\n  ch <- 4\n  ch <- 5\n  close(ch)\n  wg.Wait()\n}\n```", "```go\n    package main\n    import \"log\"\n    ```", "```go\n    func readThem(in, out chan string) {\n    ```", "```go\n      for i := range in {\n        log.Println(i)\n      }\n    ```", "```go\n      out <- \"done\"\n    }\n    ```", "```go\n    func main() {\n      log.SetFlags(0)\n    ```", "```go\n      in, out := make(chan string), make(chan string)\n      go readThem(in, out)\n    ```", "```go\n      strs := []string{\"a\",\"b\", \"c\", \"d\", \"e\", \"f\"}\n      for _, s := range strs {\n        in <- s\n      }\n    ```", "```go\n      close(in)\n      <-out\n    }\n    ```", "```go\na\nb\nc\nd\ne\nf\n```", "```go\nfunc doSomething() chan int {\n  ch := make(chan int)\n  go func() {\n    for i := range ch {\n      log.Println(i)\n    }\n  }()\n  return ch\n}\n```", "```go\nch := doSomething()\nch <- 1\nch <- 4\n```", "```go\n<- chan int\n```", "```go\nchan <- int\n```", "```go\ntype MyStruct struct {}\nfunc (m MyStruct) doIt()\n. . . . . .\nms := MyStruct{}\ngo ms.doIt()\n```", "```go\n    package main\n    import (\n      \"fmt\"\n      \"sync\"\n    )\n    type Worker struct {\n      in, out chan int\n      sbw int // sbw: subworker\n      mtx *sync.Mutex\n    }\n    ```", "```go\n    func (w *Worker) readThem() {\n      w.sbw++\n      go func() {\n    ```", "```go\n        partial := 0\n        for i := range w.in {\n          partial += i\n        }\n        w.out <- partial\n    ```", "```go\n        w.mtx.Lock()\n        w.sbw--\n        if w.sbw == 0 {\n          close(w.out)\n        }\n        w.mtx.Unlock()\n      }()\n    }\n    ```", "```go\n    func (w *Worker) gatherResult() int {\n      total := 0\n      wg := &sync.WaitGroup{}\n      wg.Add(1)\n      go func() {\n    ```", "```go\n        for i:= range w.out{\n          total += i\n        }\n        wg.Done()\n      }()\n    ```", "```go\n      wg.Wait()\n      return total\n    }\n    ```", "```go\n    func main() {\n      mtx := &sync.Mutex{}\n      in := make(chan int, 100)\n      wrNum := 10\n      out := make(chan int)\n      wrk := Worker{in: in, out: out, mtx: mtx}\n    ```", "```go\n      for i := 1; i <= wrNum; i++ {\n        wrk.readThem()\n      }\n    ```", "```go\n      for i := 1;i <= 100; i++ {\n        in <- i\n      }\n    ```", "```go\n      close(in)\n    ```", "```go\n      res := wrk.gatherResult()\n      fmt.Println(res)\n    }\n    ```", "```go\n    5050\n    ```", "```go\nfunc doIt(ctx context.Context, a int, b string) {\n  fmt.Println(b)\n  doThat(ctx, a*2)\n}\nfunc doThat(ctx context.Context, a int) {\n  fmt.Println(a)\n  doMore(ctx)\n}\n```", "```go\n    package main\n    import (\n      \"context\"\n      \"log\"\n      \"time\"\n    )\n    ```", "```go\n    func countNumbers(ctx context.Context, r chan int) {\n      v := 0\n      for {\n    ```", "```go\n        select {\n          case <-ctx.Done():\n          r <- v\n          return\n    ```", "```go\n          default:\n          time.Sleep(time.Millisecond * 100)\n          v++\n        }\n      }\n    }\n    ```", "```go\n    func main() {\n      r := make(chan int)\n      ctx := context.TODO()\n    ```", "```go\n    cl, stop := context.WithCancel(ctx)\n    go countNumbers(cl, r)\n    ```", "```go\n      go func() {\n        time.Sleep(time.Millisecond*100*3)\n        stop()\n      }()\n    ```", "```go\n      v := <- r\n      log.Println(v)\n    }\n    ```", "```go\n2024/01/25 20:00:58 3\n```", "```go\n    package main\n    import (\n      \"fmt\"\n      \"sync\"\n      \"time\"\n    )\n    ```", "```go\n    type WorkQueue struct {\n      cond *sync.Cond\n      maxSize int\n      workItems []string\n    }\n    func NewWorkQueue(maxSize int) *WorkQueue {\n      return &WorkQueue{\n        cond: sync.NewCond(&sync.Mutex{}),\n        maxSize: maxSize,\n        workItems: make([]string, 0),\n      }\n    }\n    ```", "```go\n    func (wq *WorkQueue) enqueue(item string) {\n      wq.cond.L.Lock()\n      defer wq.cond.L.Unlock()\n      for len(wq.workItems) == wq.maxSize {\n        wq.cond.Wait()\n      }\n      wq.workItems = append(wq.workItems, item)\n      wq.cond.Signal()\n    }\n    ```", "```go\n    func (wq *WorkQueue) dequeue() string {\n      wq.cond.L.Lock()\n      defer wq.cond.L.Unlock()\n      for len(wq.workItems) == 0 {\n        wq.cond.Wait()\n      }\n      item := wq.workItems[0]\n      wq.workItems = wq.workItems[1:]\n      wq.cond.Signal()\n      return item\n    }\n    ```", "```go\n    func main() {\n      var wg sync.WaitGroup\n      workQueue := NewWorkQueue(3)\n    ```", "```go\n      wg.Add(1)\n      go func() {\n        defer wg.Done()\n        for i := 1; i <= 5; i++ {\n          workItem := fmt.Sprintf(\"WorkItem %d\", i)\n          workQueue.enqueue(workItem)\n          fmt.Printf(\"Enqueued: %s\\n\", workItem)\n          time.Sleep(time.Second)\n        }\n      }()\n    ```", "```go\n      wg.Add(1)\n      go func() {\n        defer wg.Done()\n        for i := 1; i <= 5; i++ {\n          workItem := workQueue.dequeue()\n          fmt.Printf(\"Dequeued: %s\\n\", workItem)\n          time.Sleep(2 * time.Second)\n        }\n      }()\n    ```", "```go\n      wg.Wait()\n    }\n    ```", "```go\n    go run main.go\n    ```", "```go\nEnqueued: WorkItem 1\nDequeued: WorkItem 1\nEnqueued: WorkItem 2\nDequeued: WorkItem 2\nEnqueued: WorkItem 3\nEnqueued: WorkItem 4\nEnqueued: WorkItem 5\nDequeued: WorkItem 3\nDequeued: WorkItem 4\nDequeued: WorkItem 5\n```", "```go\n    package main\n    import (\n      \"crypto/rand\"\n      \"fmt\"\n      \"math/big\"\n      \"sync\"\n    )\n    ```", "```go\n    func generateRandomNumber(max int) (int, error) {\n      n, err := rand.Int(rand.Reader, big.NewInt(int64(max)))\n      if err != nil {\n        return 0, err\n      }\n      return int(n.Int64()), nil\n    }\n    ```", "```go\n    func updateCount(countMap *sync.Map, key int) {\n      count, _ := countMap.LoadOrStore(key, 0)\n      countMap.Store(key, count.(int)+1)\n    }\n    ```", "```go\n    func printCounts(countMap *sync.Map) {\n      countMap.Range(func(key, value interface{}) bool {\n        fmt.Printf(\"Number %d: Count %d\\n\", key, value)\n        return true\n      })\n    }\n    ```", "```go\n    func main() {\n      var countMap sync.Map\n      numGoroutines := 5\n      var wg sync.WaitGroup\n      generateAndCount := func() {\n        defer wg.Done()\n        // Generate 1000 random numbers per Goroutine\n        for i := 0; i < 1000; i++ {\n          // Generate random number between 0 and 9\n          randomNumber, err := generateRandomNumber(10)\n          if err != nil {\n            fmt.Println(\"Error generating random number:\", err)\n            return\n          }\n          updateCount(&countMap, randomNumber)\n        }\n      }\n    ```", "```go\n      for i := 0; i < numGoroutines; i++ {\n        wg.Add(1)\n        go generateAndCount()\n      }\n      wg.Wait()\n      printCounts(&countMap)\n    }\n    ```", "```go\n    go run main.go\n    ```", "```go\nNumber 7: Count 480\nNumber 0: Count 488\nNumber 5: Count 506\nNumber 4: Count 489\nNumber 1: Count 472\nNumber 9: Count 499\nNumber 2: Count 499\nNumber 6: Count 515\nNumber 3: Count 481\nNumber 8: Count 533\n```"]