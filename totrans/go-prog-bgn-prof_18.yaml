- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Concurrent Work
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发工作
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to Go features that will allow you to perform concurrent
    work, or, in other words, achieve concurrency. The first feature you will learn
    is called a Goroutine. You’ll learn what a Goroutine is and how you can use it
    to achieve concurrency. Then, you’ll learn how to utilize `WaitGroup`s to synchronize
    the execution of several Goroutines. You will also learn how to implement synchronized
    and thread-safe changes to variables shared across different Goroutines using
    atomic changes. To synchronize more complex changes, you will work with mutexes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Go 的功能，这些功能将允许你执行并发工作，换句话说，实现并发。你将学习的第一个功能被称为 Goroutine。你将了解 Goroutine
    是什么，以及如何使用它来实现并发。然后，你将学习如何利用 `WaitGroup` 来同步多个 Goroutine 的执行。你还将学习如何使用原子操作来实现跨不同
    Goroutine 共享变量的同步和线程安全更改。为了同步更复杂的变化，你将使用互斥锁。
- en: Later in the chapter, you will experiment with the functionalities of channels
    and use message tracking to track the completion of a task. We will also cover
    the importance of concurrency, concurrency patterns, and more.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，你将实验通道的功能，并使用消息跟踪来跟踪任务的完成情况。我们还将讨论并发的重要性、并发模式等内容。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you''ll require Go version 1.21 or higher. The code for this
    chapter can be found at: [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter18](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter18).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要 Go 版本 1.21 或更高版本。本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter18](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter18)。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: There is software that’s meant to be used by a single user, and most of what
    you’ve learned so far in this book allows you to develop such applications. There
    is other software, however, that is meant to be used by several users at the same
    time. An example of this is a web server. You created web servers in [*Chapter
    16*](B18621_16.xhtml#_idTextAnchor1704), *Web Servers*. They are designed to serve
    websites or web applications that are generally used by thousands of users at
    the same time.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有些软件是为单个用户使用的，而本书中你学到的大部分内容都允许你开发这样的应用程序。然而，还有其他软件是为同时供多个用户使用的。一个例子是网络服务器。你在[*第16章*](B18621_16.xhtml#_idTextAnchor1704)“网络服务器”中创建了网络服务器。它们被设计用来服务网站或网络应用程序，这些网站或应用程序通常由成千上万的用户同时使用。
- en: When multiple users are accessing a web server, it sometimes needs to perform
    a series of actions that are totally independent and whose result is the only
    thing that matters to the final output. All these situations call for a type of
    programming in which different tasks can be executed at the same time, independently
    from each other. Some languages allow parallel computation, where tasks are computed
    simultaneously.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个用户访问网络服务器时，有时它需要执行一系列完全独立且结果对最终输出唯一重要的操作。所有这些情况都需要一种类型的编程，其中不同的任务可以同时独立执行。一些语言允许并行计算，其中任务是同时计算的。
- en: In concurrent programming, when a task starts, all other tasks start as well,
    but instead of completing them one by one, the machine performs a bit of each
    task at the same time. While Go allows concurrent programming, tasks can also
    be performed in parallel when the machine has multiple cores. From the perspective
    of the programmer, however, this distinction is not that important, as tasks are
    created with the idea that they will be performed in parallel and in whatever
    way the machine will perform them. Let’s find out more in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发编程中，当一项任务开始时，所有其他任务也会同时开始，但机器不是依次完成它们，而是同时执行每个任务的一部分。虽然 Go 允许并发编程，但当机器有多个核心时，任务也可以并行执行。然而，从程序员的视角来看，这种区别并不那么重要，因为创建任务时，我们假设它们将以并行的方式执行，并且机器将以任何方式执行它们。让我们在本章中了解更多信息。
- en: Goroutines
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Goroutines
- en: Imagine several people have some nails to hammer into a wall. Each person has
    a different number of nails and a different area of the wall, but there is only
    one hammer. Each person uses the hammer for one nail, then passes the hammer to
    the next person, and so on. The person with the fewest nails will finish earlier,
    but they will all share the same hammer; this is how Goroutines work.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象有几个人有一些钉子要钉到墙上。每个人都有不同数量的钉子和不同的墙面区域，但只有一个锤子。每个人用锤子钉一个钉子，然后传给下一个人，以此类推。钉子最少的人会先完成，但他们都会使用同一个锤子；这就是Goroutines的工作方式。
- en: Using Goroutines, Go allows multiple tasks to run at the same time (they are
    also called coroutines). These are routines (read tasks) that can co-run inside
    the same process but are totally concurrent. Goroutines do not share memory, which
    is why they are different from threads. However, we will see how easy it is to
    pass variables across them in your code and how this might lead to some unexpected
    behavior.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Goroutines，Go允许多个任务同时运行（它们也被称为协程）。这些是可以在同一进程中并发运行的例程（即任务），但它们是完全并发的。Goroutines不共享内存，这就是它们与线程不同的原因。然而，我们将看到如何在代码中轻松地在它们之间传递变量，以及这可能会引起一些意外的行为。
- en: Writing a Goroutine is nothing special; they are just normal functions. Each
    function can easily become a Goroutine; all we must do is write the word `go`
    before calling the function.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 编写Goroutine并没有什么特别之处；它们只是普通的函数。每个函数都可以轻松地成为一个Goroutine；我们只需要在调用函数之前写上单词`go`。
- en: 'Let us consider a function called `hello()`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个名为`hello()`的函数：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To call our function as a Goroutine, we do the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的函数作为Goroutine调用，我们执行以下操作：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The function will run as a Goroutine. What this means can be understood better
    through the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将以Goroutine的形式运行。这意味着什么可以通过以下代码更好地理解：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code starts by printing `Start`, then it calls the `hello()` function. Then,
    the execution goes straight to printing `End` without waiting for the `hello()`
    function to complete. No matter how long it takes to run the `hello()` function,
    the `main()` function will not care about the `hello()` function as these functions
    will run independently. To better understand how this works, let’s do some exercises.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先打印`Start`，然后调用`hello()`函数。然后，执行直接跳转到打印`End`，而不等待`hello()`函数完成。无论`hello()`函数运行多长时间，`main()`函数都不会关心`hello()`函数，因为这些函数将独立运行。为了更好地理解这是如何工作的，让我们做一些练习。
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The important thing to remember is that Go is not a parallel language but concurrent,
    which means that Goroutines do not work in an independent manner, but each Goroutine
    is split into smaller parts and each Goroutine runs one of its subparts at a time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的重要一点是，Go不是一种并行语言，而是一种并发语言，这意味着Goroutines不是以独立的方式工作，而是每个Goroutine被分割成更小的部分，每个Goroutine一次运行其一个子部分。
- en: Exercise 18.01 – using concurrent Goroutines
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习18.01 – 使用并发Goroutines
- en: 'Let’s imagine we want to make two calculations. First, we sum all numbers from
    `1` to `10`, then numbers from `1` to `100`. To save time, we want to make both
    calculations happen independently and see both results at the same time:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们想要进行两个计算。首先，我们将从`1`到`10`的所有数字相加，然后从`1`到`100`的数字相加。为了节省时间，我们希望这两个计算独立进行，并且同时看到两个结果：
- en: 'Create a new folder in your filesystem, and, inside it, create a `main.go`
    file and write the following:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的文件系统中创建一个新的文件夹，并在其中创建一个`main.go`文件，然后编写以下内容：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a function to sum two numbers:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于求和两个数字的函数：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This accepts two integers as extremes (the minimum and maximum of an interval)
    and returns the sum of all numbers in the range between these two extremes.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数接受两个整数作为极值（区间的最小值和最大值），并返回这两个极值之间所有数字的总和。
- en: 'Create a `main()` function, which sums numbers `1` and `100`, then print the
    result:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main()`函数，它将数字`1`和`100`相加，然后打印结果：
- en: '[PRE5]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Run the program:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序：
- en: '[PRE6]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You will see the following output:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE7]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let’s introduce some concurrency. Modify the `main()` function to look
    like this:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们引入一些并发性。修改`main()`函数，使其看起来像这样：
- en: '[PRE8]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we are running an anonymous function that assigns the value `s1` to the
    sum as before, but if we run the code, the result will be `0`. If you try to remove
    the term `go` before the `func()` part, you will see that the result is `5050`.
    In this case, the anonymous function will run and start summing the numbers, but
    then there is a call to `fmt.Println`, which prints the value of `s1`. Here, the
    program waits for the `sum()` function to end before printing the value of `s1`,
    hence returning the correct result.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，我们正在运行一个匿名函数，它将值 `s1` 赋给总和，就像之前一样，但如果我们运行代码，结果将是 `0`。如果你尝试在 `func()` 部分之前移除
    `go` 项，你会看到结果是 `5050`。在这种情况下，匿名函数将运行并开始求和数字，但随后有一个调用 `fmt.Println`，它打印 `s1` 的值。在这里，程序在打印
    `s1` 的值之前等待 `sum()` 函数结束，因此返回正确的结果。
- en: If we call the function and prepend the `go` word, the program prints the current
    value of `s1` while the function is still computing the sum, which is still `0`,
    and terminates.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们调用函数并在前面加上 `go` 这个词，程序会在函数仍在计算总和时（总和仍然是 `0`）打印 `s1` 的当前值，然后终止。
- en: 'Let’s call the `sum()` function twice with two different ranges. Modify the
    `main()` function:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们两次调用 `sum()` 函数，使用两个不同的范围。修改 `main()` 函数：
- en: '[PRE9]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you run this program, it will print numbers `0` and `55`. This is because
    the concurrent function, `go func()`, does not have the time to return the result.
    The `main()` function is faster as it must count to `55` and not `5050`, so the
    program terminates before the concurrent function is finished.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，它将打印数字 `0` 和 `55`。这是因为并发函数 `go func()` 没有时间返回结果。`main()` 函数更快，因为它必须数到
    `55` 而不是 `5050`，所以程序在并发函数完成之前就终止了。
- en: 'To solve this problem, we want to find a way to wait for the *concurrent* function
    to finish. There are some correct ways to do this, but for now, let’s do something
    quite crude but effective, which is to wait for a fixed amount of time. To do
    so, just add this line before the `fmt.Println` command:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们想要找到一个等待并发函数完成的方法。有一些正确的方法可以做到这一点，但现在，让我们做一件相当粗糙但有效的事情，那就是等待固定的时间。要做到这一点，只需在
    `fmt.Println` 命令之前添加这一行：
- en: '[PRE10]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Modify the `import` section, just below the `package main` instruction, to
    look as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `import` 部分，位于 `package main` 指令下方，使其看起来如下：
- en: '[PRE11]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you run your program now, you should see `5050 55` printed on the screen.
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你现在运行你的程序，你应该在屏幕上看到打印出 `5050 55`。
- en: 'In the `main()` function, write code for the log to be printed:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，编写代码以打印日志：
- en: '[PRE12]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you run your program now, you will see the same output again, `5050 55`,
    but prepended by a timestamp representing when you ran the code:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在运行你的程序，你将再次看到相同的输出，`5050 55`，但前面会加上表示你运行代码时的时间戳：
- en: '[PRE13]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the calculations have happened concurrently, and we have received
    both outputs at the same time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，计算是并发发生的，我们同时收到了两个输出。
- en: Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The full code for this exercise is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter18](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter18).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的完整代码可以在 [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter18](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter18)
    找到。
- en: WaitGroup
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WaitGroup
- en: 'In the previous exercise, we used a not-so-elegant method to ensure that the
    Goroutine ended by making the main Goroutine wait for a second. The important
    thing to understand is that even if a program does not explicitly use Goroutines
    via the `go` call, it still uses one Goroutine, which is the main routine. When
    we run our program and create a new Goroutine, we are running two Goroutines:
    the main one and the one we just created. In order to synchronize these two Goroutines,
    Go gives us a function called `WaitGroup`. You can define a `WaitGroup` using
    the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，我们使用了一种不太优雅的方法来确保通过让主 Goroutine 等待一秒钟来结束 Goroutine。重要的是要理解，即使程序没有通过
    `go` 调用显式使用 Goroutines，它仍然使用了一个 Goroutine，那就是主程序。当我们运行程序并创建一个新的 Goroutine 时，我们正在运行两个
    Goroutines：一个是主程序，另一个是我们刚刚创建的。为了同步这两个 Goroutines，Go 给我们提供了一个名为 `WaitGroup` 的函数。你可以使用以下代码定义一个
    `WaitGroup`：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`WaitGroup` needs the `sync` package to be imported. Typical code using the
    `WaitGroup` will be something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitGroup` 需要导入 `sync` 包。典型的使用 `WaitGroup` 的代码可能如下所示：'
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we create a pointer to a new `WaitGroup`, then we mention that we are
    adding an asynchronous operation that adds `1` to the group using `wg.Add(1)`.
    This is essentially a counter holding the number of all concurrent Goroutines
    that are running. Later, we add the code that will run the concurrent call. At
    the end, we tell the `WaitGroup` to wait for the Goroutines to end using `wg.Wait()`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个指向新 `WaitGroup` 的指针，然后提到我们正在添加一个异步操作，该操作使用 `wg.Add(1)` 将 `1` 添加到组中。这本质上是一个计数器，持有所有正在运行并发
    Goroutine 的数量。稍后，我们将添加将运行并发调用的代码。最后，我们告诉 `WaitGroup` 使用 `wg.Wait()` 等待 Goroutine
    完成。
- en: 'How does the `WaitGroup` know that the routines are complete? Well, we need
    to explicitly tell the `WaitGroup` about it inside the Goroutine with the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitGroup` 如何知道这些例程已经完成？嗯，我们需要在 Goroutine 中显式地告诉 `WaitGroup` 如下：'
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This must reside at the end of the called Goroutine. We will see this in the
    next exercise.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这必须位于被调用 Goroutine 的末尾。我们将在下一个练习中看到这一点。
- en: Exercise 18.02 – experimenting with WaitGroup
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 18.02 – 使用 WaitGroup 进行实验
- en: 'Let’s say we calculate the addition in *Exercise 18.01*, *Using concurrent
    Goroutines*, again using a Goroutine that runs concurrently with the main process.
    However, this time, we want to use a `WaitGroup` to synchronize the results. We
    have a few changes to make. Essentially, the `sum()` function needs to accept
    a new parameter for the `WaitGroup`, and there is no need to use the `time` package.
    Many people new to concurrency add `time.Sleep` to wait for Goroutines to finish.
    This intentional delay is self-defeating and makes no practical sense outside
    of testing, as the purpose of Goroutines is to speed up the overall execution
    of things:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们再次在 *练习 18.01*，*使用并发 Goroutine* 中计算加法，这次使用与主进程并发运行的 Goroutine。然而，这次我们想要使用
    `WaitGroup` 来同步结果。我们需要做一些更改。本质上，`sum()` 函数需要接受一个新的 `WaitGroup` 参数，并且不需要使用 `time`
    包。许多刚开始学习并发的人会在 Goroutine 完成之前添加 `time.Sleep` 来等待。这种故意的延迟是自相矛盾的，并且在实际应用中没有意义，因为
    Goroutine 的目的是加快整体执行速度：
- en: 'Create a new folder and a `main.go` file inside it. The package and import
    parts of your file will be as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹内创建一个 `main.go` 文件。你的文件包和导入部分如下：
- en: '[PRE17]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we define the package as the `main` package and then import the `log`
    and `sync` packages. `log` will be used again to print out messages, and `sync`
    will be used for the `WaitGroup`.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将包定义为 `main` 包，然后导入 `log` 和 `sync` 包。`log` 将再次用于打印消息，而 `sync` 将用于 `WaitGroup`。
- en: 'Next, write a `sum()` function:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编写一个 `sum()` 函数：
- en: '[PRE18]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, we add a parameter called `wg` with a pointer to `sync.WaitGroup` along
    with the result parameter. In the previous exercise, we wrapped the `sum()` function
    with an anonymous function that ran as a Goroutine. Here, we want to avoid that,
    but we need to somehow get the result of the `sum()` function. Hence, we pass
    an extra parameter as a pointer that will return the correct value.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们添加一个名为 `wg` 的参数，它是一个指向 `sync.WaitGroup` 的指针，以及结果参数。在前一个练习中，我们用匿名函数包装了 `sum()`
    函数，该函数作为一个 Goroutine 运行。这里，我们想要避免这样做，但我们需要以某种方式获取 `sum()` 函数的结果。因此，我们传递一个额外的参数作为指针，它将返回正确的值。
- en: 'Create a loop to increment the `sum()` function:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环来增加 `sum()` 函数：
- en: '[PRE19]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we set the value of what is held by the `res` pointer to `0`, and then
    we use the same loop that we saw earlier, but again associating the `sum()` function
    with the value pointed by the `res` parameter.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将 `res` 指针所持有的值设置为 `0`，然后我们使用之前看到的相同循环，但再次将 `sum()` 函数与 `res` 参数所指向的值关联起来。
- en: 'We can now complete this function:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以完成这个函数：
- en: '[PRE20]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we tell the `WaitGroup` that this Goroutine is completed, and then we
    return.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们告诉 `WaitGroup` 这个 Goroutine 已经完成，然后返回。
- en: 'Now, let’s write a `main()` function, which will set up the variables and then
    run the Goroutine that calculates the sum. We will then wait for the Goroutine
    to finish and display the result:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个 `main()` 函数，它将设置变量并运行计算总和的 Goroutine。然后我们将等待 Goroutine 完成，并显示结果：
- en: '[PRE21]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, the `main()` function is defined, and then a variable called `s1` is set
    to `0`. Also, a pointer to the `WaitGroup` is created.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，定义了 `main()` 函数，并设置了一个名为 `s1` 的变量为 `0`。同时，创建了一个指向 `WaitGroup` 的指针。
- en: 'Add one to the count of the `WaitGroup` and then run the Goroutine:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `WaitGroup` 的计数加一，然后运行 Goroutine：
- en: '[PRE22]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This code notifies the `WaitGroup` that there is one Goroutine running and then
    creates a new Goroutine calculating the sum. The `sum()` function will call the
    `wg.Done()` method to notify the `WaitGroup` of its completion.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码通知 `WaitGroup` 有一个 Goroutine 正在运行，然后创建一个新的 Goroutine 来计算总和。`sum()` 函数将调用
    `wg.Done()` 方法通知 `WaitGroup` 其完成。
- en: 'We need to wait for the Goroutine to finish. To do so, write the following:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要等待 Goroutine 完成。为此，编写以下代码：
- en: '[PRE23]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This also logs the result to the standard output.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这也将结果记录到标准输出。
- en: 'Run the program:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序：
- en: '[PRE24]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You will see the log output for the function using `WaitGroup`s, as follows,
    with the timestamp:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到使用 `WaitGroup` 的函数的日志输出，如下所示，带有时间戳：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With this exercise, we have explored the functionality of `WaitGroup` by synchronizing
    Goroutines in our code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，我们已经通过在我们的代码中同步 Goroutines 探索了 `WaitGroup` 的功能。
- en: Race conditions
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 竞态条件
- en: 'One important thing to consider is that whenever we run multiple functions
    concurrently, we have no guarantee in what order each instruction in each function
    will be performed. In many architectures, this is not a problem. Some functions
    are not connected in any way with other functions, and whatever a function does
    in its Goroutine does not affect the actions performed in other Goroutines. This
    is, however, not always true. The first situation we can think of is when some
    functions need to share the same parameter. Some functions will read from this
    parameter, while others will write to this parameter. As we do not know which
    operation will run first, there is a high likelihood that one function will override
    the value updated by another function. Let’s see an example that explains this
    situation:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一个重要问题是，无论何时我们并发运行多个函数，我们都没有保证每个函数中的每个指令将按什么顺序执行。在许多架构中，这并不是一个问题。一些函数根本不与其他函数连接，并且一个函数在其
    Goroutine 中所做的操作不会影响其他 Goroutines 中执行的操作。然而，这并不总是正确的。我们可以想到的第一种情况是，当一些函数需要共享相同的参数时。一些函数会从这个参数中读取，而其他函数会写入这个参数。由于我们不知道哪个操作会先运行，所以一个函数可能会覆盖另一个函数更新的值。让我们看看一个解释这种情况的例子：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This function takes a pointer to an integer as a parameter. It is a pointer
    because we want to run several Goroutines with the `next()` function and update
    `v`. If we run the following code, we would expect that `a` will hold the value
    3:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受一个指向整数的指针作为参数。它是一个指针，因为我们想使用 `next()` 函数运行多个 Goroutines 并更新 `v`。如果我们运行以下代码，我们期望
    `a` 将持有值 3：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is perfectly fine. However, what if we run the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全没问题。然而，如果我们运行以下代码：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In this case, we might see that `a` holds 3, or 2, or 1\. Why would this happen?
    Because when a function executes the following statement, the value of `v` might
    be 0 for all functions running in independent Goroutines:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能会看到 `a` 持有 3、2 或 1。为什么会这样呢？因为当一个函数执行以下语句时，`v` 的值可能对所有在独立 Goroutines
    中运行的函数都是 0：
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If this happens, then each function will set `v` to `c + 1`, which means none
    of the Goroutines are aware of what the other Goroutines are doing and override
    any changes made by another Goroutine. This problem is called a **race condition**
    and happens every time we work with shared resources without taking precautions.
    Fortunately, we have several ways to prevent this situation and to make sure that
    the same change is made only once. We will look at these solutions in the next
    sections, and we will explore the situation we just described in more detail,
    with a proper solution and race detection.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生这种情况，那么每个函数都会将 `v` 设置为 `c + 1`，这意味着没有任何 Goroutine 意识到其他 Goroutine 在做什么，并覆盖了另一个
    Goroutine 所做的任何更改。这个问题被称为 **竞态条件**，并且每次我们在没有采取预防措施的情况下处理共享资源时都会发生。幸运的是，我们有几种方法可以防止这种情况，并确保相同的更改只进行一次。我们将在下一节中查看这些解决方案，并更详细地探讨我们刚才描述的情况，包括适当的解决方案和竞态检测。
- en: Atomic operations
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原子操作
- en: Let’s imagine we want to run independent functions again. However, in this case,
    we want to modify the value held by a variable. We still want to sum the numbers
    from 1 to 100, but we want to split the work into two concurrent Goroutines. We
    can sum the numbers from 1 to 50 in one routine and the numbers from 51 to 100
    in another routine. At the end, we will still need to receive the value of 5050,
    but two different routines can add a number at the same time to the same variable.
    Let’s see an example with only four numbers where we want to sum 1, 2, 3, and
    4, and the result is 10.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象我们再次想要运行独立的函数。然而，在这种情况下，我们想要修改变量的值。我们仍然想要从1到100求和，但我们将工作分成两个并发Goroutines。我们可以在一个进程中求和1到50的数字，在另一个进程中求和51到100的数字。最后，我们仍然需要收到5050的值，但两个不同的进程可以同时向同一个变量添加一个数字。让我们看看一个只有四个数字的例子，我们想要求和1、2、3和4，结果是10。
- en: 'Think of it like having a variable called `s := 0` and then making a loop where
    the value of `s` becomes the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 想象有一个名为`s := 0`的变量，然后进行一个循环，其中`s`的值变为以下：
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, we could also have the following loop. In this case, the order in
    which the numbers are summed is different:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以有以下的循环。在这种情况下，求和的数字顺序是不同的：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Essentially, this is just the commutative property of the sum, but this gives
    us a hint that we can split the sum into two or more concurrent calls. The problem
    that arises here is that all the functions need to manipulate the same variable,
    `s`, which can lead to race conditions and incorrect final values. A race condition
    happens when two processes change the same variable, and one process overrides
    the changes made by another process without considering the previous change. Thankfully,
    we have a package called `atomic` that allows us to safely modify variables across
    Goroutines.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，这只是求和的交换律，但这给我们一个提示，我们可以将求和分成两个或更多的并发调用。这里出现的问题是，所有函数都需要操作同一个变量`s`，这可能导致竞态条件和最终值不正确。竞态条件发生在两个进程更改同一个变量时，一个进程在不考虑先前更改的情况下覆盖另一个进程所做的更改。幸运的是，我们有一个名为`atomic`的包，允许我们在Goroutines之间安全地修改变量。
- en: 'We will look at how this package works soon, but, for now, all you need to
    know is that this package has some functions for executing simple concurrent safe
    operations on variables. Let’s look at an example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快查看这个包是如何工作的，但现在，你需要知道的是，这个包有一些函数可以用于在变量上执行简单的并发安全操作。让我们看看一个例子：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code takes a pointer to `int32` and modifies it by adding the value it
    points at to the value of `delta`. If `addr` holds a value of 2 and `delta` is
    4, after calling this function, `addr` will hold 6.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码接受一个指向`int32`的指针，并通过将其指向的值加到`delta`的值上来修改它。如果`addr`持有值为2且`delta`为4，在调用此函数后，`addr`将持有6。
- en: Exercise 18.03 – an atomic change
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习18.03 – 原子变更
- en: 'In this exercise, we want to calculate the sum of all numbers between 1 and
    100 but with more concurrent Goroutines – let’s say 4\. So, we have one function
    summing in the range of 1-25, one in the range of 26-50, then 51-75, and finally
    76-100\. We will use what we’ve learned about atomic operations and `WaitGroups`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们想要计算1到100之间所有数字的总和，但使用更多的并发Goroutines——比如说4个。所以，我们有一个函数在1-25的范围内求和，一个在26-50的范围内，然后是51-75，最后是76-100。我们将使用我们关于原子操作和`WaitGroups`的知识：
- en: 'Create a new folder and a `main.go` file. Inside it, write the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹和一个`main.go`文件。在里面，写下以下代码：
- en: '[PRE33]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will import the same packages used for the previous exercises, in addition
    to the `sync/atomic` package.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将导入之前练习中使用的相同包，以及`sync/atomic`包。
- en: 'The next step is to refactor the `sum()` function from *Exercise 19.02*, *Experimenting
    with WaitGroup*, to use the `atomic` package:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将*练习19.02*，*使用WaitGroup进行实验*中的`sum()`函数重构，以使用`atomic`包：
- en: '[PRE34]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we just changed `res` from `int` to `*int32`. The reason for this is that
    the atomic operations available specifically for arithmetic operations only work
    on `int32/64` and relative `uint32/64`.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们只是将`res`从`int`改为`*int32`。这样做的原因是，专门针对算术操作可用的原子操作仅适用于`int32/64`和相关的`uint32/64`。
- en: 'At this point, write a loop to add each number to the total:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，写一个循环将每个数字加到总数中：
- en: '[PRE35]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, instead of assigning the value of `res` as `0`, we are now adding
    `i` to the total value held by `res`. The rest of the code is unchanged.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，我们不是将`res`的值赋为`0`，而是现在将`i`添加到`res`持有的总值中。其余的代码保持不变。
- en: 'The next step is to write a `main()` function to calculate the sum in four
    different Goroutines:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是编写一个`main()`函数，以四个不同的Goroutines计算总和：
- en: '[PRE36]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we set `s1` to an `int32` type rather than `int` so that we can send it
    as a parameter to the `sum()` function. Then, we create a pointer to `WaitGroup`.
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们将`s1`设置为`int32`类型而不是`int`，这样我们就可以将其作为参数发送给`sum()`函数。然后，我们创建一个指向`WaitGroup`的指针。
- en: 'Now, tell the `WaitGroup` that we will have four Goroutines running:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，告诉`WaitGroup`我们将有四个Goroutines正在运行：
- en: '[PRE37]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, run four Goroutines performing the sum over four ranges: 1-25, 26-50,
    51-75, and 76-100:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行四个Goroutines，分别对四个范围进行求和：1-25，26-50，51-75，和76-100：
- en: '[PRE38]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, add the code that waits for the routines to complete and print the result:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加等待例程完成并打印结果的代码：
- en: '[PRE39]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, run the code with the following:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下内容运行代码：
- en: '[PRE40]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The actual date will be different because it depends on when you run this code.
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际日期将不同，因为它取决于你何时运行此代码。
- en: 'Now, let’s test the code. We will use it to show you what it means to have
    a race condition, why we use this `atomic` package, and what concurrency safety
    is. Here is the test code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们测试代码。我们将使用它来向您展示什么是竞态条件，为什么我们使用这个`atomic`包，以及什么是并发安全性。以下是测试代码：
- en: '[PRE41]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We will run the same test 10,000 times.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将运行相同的测试10,000次。
- en: 'Run your test:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的测试：
- en: '[PRE42]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The result of the test on atomic changes is as follows:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 原子更改测试的结果如下：
- en: '[PRE43]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And now, add the `-``race` flag:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加`-race`标志：
- en: '[PRE44]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output when running these tests with the `-race` flag is as follows:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`-race`标志运行这些测试的输出如下：
- en: '[PRE45]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Again, everything is fine so far.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，到目前为止一切正常。
- en: 'Let’s now remove the `sync/atomic` import and modify the `sum()` function where
    you see this line:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们移除`sync/atomic`导入，并修改包含此行的`sum()`函数：
- en: '[PRE46]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Change it to this:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改成这样：
- en: '[PRE47]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, run your program:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行你的程序：
- en: '[PRE48]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The log output for a non-atomic change stays the same when using pointers:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用指针时，非原子更改的日志输出保持不变：
- en: '[PRE49]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'But if you try running the test multiple times, you may see some different
    results, even though, in this case, that is quite unlikely. At this point, however,
    try running the tests with the `-``race` flag:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但如果你尝试多次运行测试，你可能会看到一些不同的结果，尽管在这种情况下，这种情况相当不可能。然而，此时尝试使用`-race`标志运行测试：
- en: '[PRE50]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You will see the following output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '![Figure 18.1: Race conditions arise when using the pointer here](img/B18621_18_1.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图18.1：在此处使用指针时会出现竞态条件](img/B18621_18_1.jpg)'
- en: 'Figure 18.1: Race conditions arise when using the pointer here'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1：在此处使用指针时会出现竞态条件
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: GCC must be installed to run this code. Information on installation instructions
    can be found at [https://go.dev/doc/install/gccgo](https://go.dev/doc/install/gccgo).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 必须安装GCC才能运行此代码。有关安装说明的信息，请参阅[https://go.dev/doc/install/gccgo](https://go.dev/doc/install/gccgo)。
- en: 'Now, let’s run the code without the `-``race` flag:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们不带`-race`标志运行代码：
- en: '![Figure 18.2: Stack trace with racing conditions](img/B18621_18_2.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图18.2：带有竞态条件的堆栈跟踪](img/B18621_18_2.jpg)'
- en: 'Figure 18.2: Stack trace with racing conditions'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.2：带有竞态条件的堆栈跟踪
- en: Note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '*...* in *Figure 18**.2* denotes some lines of output that I removed to make
    the visual more digestible.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*...* 在 *图18.2* 中表示我删除的一些输出行，以使视觉更易于理解。'
- en: By running the code several times, you can see different results because each
    routine can change the value of `s1` at any time and in any order, which we cannot
    know in advance.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过多次运行代码，你可以看到不同的结果，因为每个例程可以在任何时间以任何顺序更改`s1`的值，这是我们无法提前知道的。
- en: In this exercise, you’ve learned how to use the `atomic` package to safely modify
    variables shared by multiple Goroutines. You’ve learned how direct access to the
    same variable from different Goroutines can be dangerous and how to use the `atomic`
    package to avoid this situation. We also saw how to work with tests in Go. This
    topic will be covered more thoroughly in the next chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你学习了如何使用`atomic`包安全地修改多个Goroutines共享的变量。你学习了从不同的Goroutines直接访问相同的变量可能是危险的，以及如何使用`atomic`包来避免这种情况。我们还看到了如何在Go中处理测试。这个主题将在下一章中更详细地介绍。
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The full code for this exercise is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter18/Exercise18.03](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter18/Exercise18.03).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的完整代码可在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter18/Exercise18.03](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter18/Exercise18.03)找到。
- en: Invisible concurrency
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可见的并发
- en: We’ve seen in the previous exercise the effects of concurrency through race
    conditions, but we want to see them in practice. It is easy to understand that
    concurrency problems are difficult to visualize as they do not manifest in the
    same way every time we run a program. That’s why we are focusing on finding ways
    to synchronize concurrent work. One easy way to visualize it, however, but that
    is difficult to use in tests, is to print out each concurrent routine and see
    the order in which these routines are called. In the previous exercise, for example,
    we could have sent another parameter with a name and printed the name of the function
    at each iteration in the `for` loop.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，我们已经看到了通过竞态条件产生的并发效果，但我们想在实际中看到这些效果。很容易理解，并发问题很难可视化，因为它们在每次运行程序时并不总是以相同的方式表现出来。这就是为什么我们专注于寻找同步并发工作的方法。然而，有一个简单的方法可以可视化它，但在测试中使用却很困难，那就是打印出每个并发例程，并查看这些例程被调用的顺序。例如，在之前的练习中，我们可以在`for`循环的每次迭代中发送另一个带有名称的参数，并打印出函数的名称。
- en: 'If we want to see the effects of concurrency and still be able to test it,
    we could use the `atomic` package again, this time with strings so that we can
    build a string containing a message from each Goroutine. For this scenario, we
    will use the `sync` package again, but we will not make use of atomic operations.
    Instead, we will use a new struct called `Mutex`. A mutex, short for *mutual exclusion*,
    serves as a synchronization primitive in Go, allowing multiple Goroutines to coordinate
    access to shared resources. When a Goroutine acquires a mutex, it locks it, ensuring
    exclusive access to the critical section of code. This prevents other Goroutines
    from accessing the same resource until the mutex is unlocked. Once the critical
    section execution is complete, the mutex is unlocked, allowing other Goroutines
    to acquire it and proceed with their execution concurrently. Let’s see how we
    can use it. First, it needs the `sync` package to be imported. Then, we create
    a mutex like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想看到并发效果并仍然能够测试它，我们可以再次使用`atomic`包，这次使用字符串，这样我们就可以构建一个包含每个Goroutine消息的字符串。对于这种情况，我们再次使用`sync`包，但我们将不使用原子操作。相反，我们将使用一个新的结构体`Mutex`。互斥锁，简称为*互斥排他*，在Go中作为同步原语，允许多个Goroutine协调对共享资源的访问。当一个Goroutine获取互斥锁时，它会锁定它，确保对代码关键部分的独占访问。这阻止了其他Goroutine在互斥锁解锁之前访问相同的资源。一旦关键部分执行完成，互斥锁被解锁，允许其他Goroutine获取它并继续并发执行。让我们看看我们如何使用它。首先，需要导入`sync`包。然后，我们可以创建一个互斥锁，如下所示：
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'But most of the time, we want to pass a mutex across several functions, so
    we’d better create a pointer to a mutex:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 但大多数时候，我们希望将互斥锁传递给几个函数，所以我们最好创建一个指向互斥锁的指针：
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This ensures we use the same mutex everywhere. It is important to use the same
    mutex, but the reason why the mutex must be only one will be clear after analyzing
    the methods in the `Mutex` struct. If all Goroutines have `mtx.Lock()` before
    modifying a value in a critical section of code such as in the following case,
    then only one Goroutine at a time can modify the variable due to the lock:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保我们在任何地方都使用相同的互斥锁。使用相同的互斥锁很重要，但为什么互斥锁必须是唯一的，在分析`Mutex`结构体中的方法之后将会变得清楚。如果所有Goroutine在修改代码关键部分（如以下情况）中的值之前都执行了`mtx.Lock()`，那么由于锁定，每次只能有一个Goroutine修改变量：
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The preceding code snippet will lock the execution of all the routines, except
    the one that will change the variable. At this point, we will add 5 to the current
    value of `s`. After this, we release the lock using the following command so that
    any other Goroutine can modify the value of `s`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将锁定所有例程的执行，除了将改变变量的那个例程。在这个时候，我们将向`s`的当前值添加5。之后，我们使用以下命令释放锁，以便任何其他Goroutine都可以修改`s`的值：
- en: '[PRE54]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: From now on, any following code will run concurrently. We will see later some
    better ways to ensure safety when we modify a variable, but, for now, do not worry
    about adding much code between the lock/unlock part. The more code there is between
    these constructs, the less concurrent your code will be. So, you should lock the
    execution of the program, add only the logic required to ensure safety, unlock,
    and then carry on with the execution of the rest of the code, which does not touch
    the shared variables.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to notice is that the order of asynchronously performed
    code can change. This is because Goroutines run independently and you cannot know
    which one runs first. Furthermore, mutex-protected code can only be run by one
    Goroutine at a time, and you should then not rely on Goroutines to order things
    correctly; you might need to order your results afterward if you need a specific
    order.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Channels
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve seen how to create concurrent code via Goroutines, how to synchronize
    it with `WaitGroup`, how to perform atomic operations, and how to temporarily
    stop concurrency to synchronize access to shared variables. We will now introduce
    a different concept – the channel, which is typical of Go. A channel is what the
    name essentially suggests – it’s something where messages can be piped, and any
    Goroutine can send or receive messages through a channel. Similar to that of a
    slice, a channel is created the following way:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Of course, it is possible to instantiate the channel directly with the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Just like with slices, we can also do the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, a channel is created with a buffer of 10 items.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: A channel can be of any type, such as integer, Boolean, float, and any struct
    that can be defined, and even slices and pointers, though the last two are generally
    used less frequently.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Channels can be passed as parameters to functions, and that’s how different
    Goroutines can share content. Let’s see how to send a message to a channel:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this case, we send the value of 2 to the preceding `ch` channel, which is
    a channel of integers. Of course, trying to send something other than an integer
    to an integer channel will cause an error.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'After sending a message, we need to be able to receive a message from a channel.
    To do that, we can just do the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Doing this ensures that the message is received; however, the message is not
    stored. It might seem useless to lose the message, but we will see that it might
    make sense. Nevertheless, we might want to keep the value received from the channel,
    and we can do so by storing the value in a new variable:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let’s see a simple program that shows us how to use what we’ve learned so far:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This program creates a new channel, pipes the integer 1 in, then reads it,
    and finally prints out the value of `i`, which should be 1\. This code is not
    that useful in practice, but with a small change, we can see something interesting.
    Let’s make the channel unbuffered by changing the channel definition to the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If you run the code, you will get the following output:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The message may be different depending on the version of Go you are using.
    Also, some errors such as these have been introduced in newer versions. In older
    versions, though, the compiler was more permissive. In this specific case, the
    problem is simple: if we do not know how big the channel is, the Goroutines wait
    indefinitely, and this is called a deadlock. You can think of an unbuffered channel
    as having a capacity of zero. If we try to put anything into it, it won’t hold
    the item – instead, it will block until we can pass the item through the channel
    to a variable, for example. We will see later how to handle them, as they require
    more than one routine running. With only one Goroutine, after we send the message,
    we block the execution, and there is no other Goroutine able to receive the message;
    hence, we have a deadlock.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go further, let’s see one more characteristic of channels, which
    is that they can be closed. Channels need to be closed when the task they have
    been created for is finished. To close a channel, type in the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Alternatively, you can defer the closing, as shown in the following code snippet:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this case, after the `return` statement, the channel is closed as the closing
    is deferred to run after the `return` statement.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 18.04 – exchanging greeting messages via channels
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will use a Goroutine to send a greeting message, and then
    we will receive the greeting in the main process. The exercise is very simple
    and does not need concurrency, but it is a starting point to understand how message
    passing works:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder. In it, create a `main.go` file with the `main` package:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then, create a `greeter()` function:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This function just sends a `Hello` message to a channel and ends.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create a `main()` function where you instantiate a channel and pass it
    to the `greeter()` function:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, only a channel of strings is created and passed as a parameter to the
    call to a new routine called `greet`.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, print the result and complete the function:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here, we are printing whatever comes from the channel. The following part of
    the code returns a value, which is passed straight to the `Println` function:'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Run the program with the following:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You will see the following output:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now, we can see that the message has been delivered to the `main()` function
    through the channel.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have seen how to use channels to make different Goroutines
    communicate with each other and synchronize their computations.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 18.05 – two-way message exchange with channels
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we want now is to send messages from the main Goroutine to the second
    Goroutine and then get a message back as a response. We will base our code on
    the previous one and expand it. The main Goroutine will send a `"Hello John"`
    message, while the second Goroutine will return `"Thanks"` for the message received,
    stating it in full, and will then add a `"Hello` `David"` message:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder. In it, create a `main.go` file with the `main` package:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: With the necessary imports, we will use the `fmt` package to manipulate the
    strings.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a `greet()` function to return the expected messages:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `greet()` function signature has not changed. However, now, before sending
    a message, it will first wait for a message and then reply. After receiving the
    message, this function sends a message back thanking for the greeting and then
    sends its own greeting.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create a `main()` function and call the `greet()` function as a Goroutine:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here, the `main()` function is created, and a string channel is instantiated.
    Then, the second Goroutine is started. Next, we need to send the first message
    from the main Goroutine to the second, which is currently waiting.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, to send a `"Hello John"` message to the channel, write the following code:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'And finally, add the code that waits for the messages to come back before printing
    them:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You can see that you need to log twice as you expect two messages to come back.
    In many cases, you will use a loop to retrieve all the messages, which we will
    see in the next exercise. For now, try to run your code, and you will see something
    as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: From the output, you can see that both messages have been received through the
    channel.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have learned how a Goroutine can both send and receive
    messages through the same channel and that two Goroutines can exchange messages
    through the same channel in both directions.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 18.06 – summing numbers from everywhere
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine you want to add a few numbers, but the numbers come from several sources.
    They might come from a feed or from a database; we just do not know which numbers
    we are going to add and where they come from. However, we need to add them all
    in one place. In this exercise, we will have four Goroutines sending numbers in
    particular ranges, and the main Goroutine, which will calculate their sum:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a new folder and the main file. After you’ve done that,
    write the package and imports:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here, we also include the `time` package, which we will use to do a small trick
    that will help us to better visualize the effects of concurrency.
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, write a `push()` function:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This sends all the numbers in the `from, to` range to the channel. After each
    message is sent, the Goroutine sleeps for a microsecond so that another Goroutine
    will pick up the work.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, write a `main()` function:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This code creates a variable for the final sum, `s1`, and one for the channel,
    `ch`, which has a buffer of 100.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create four `go` routines:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'At this point, we need to gather all the numbers to add, so we create a loop
    of 100 cycles:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Then, read the number from the channel:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We also want to see which number came from which Goroutine:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Finally, we calculate the sum and show the result:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Here, we have the truncated output once you run the program:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Based on the results, we can easily guess which number comes from which routine.
    The last line displays the sum of all numbers. If you run the program multiple
    times, you will see that the order of the numbers changes as well.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw how we can split some computational work across several
    concurrent Goroutines and then gather all the computation in a single Goroutine.
    Each Goroutine performs a task. In this case, one sends numbers, while another
    receives the numbers and performs a sum.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 18.07 – request to Goroutines
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will solve the same problem mentioned in *Exercise 19.06*,
    *Summing numbers from everywhere*, but in a different way. Instead of receiving
    numbers as the Goroutines send them, we will make the main Goroutine ask for numbers
    from the other Goroutines. We will play with channel operations and experiment
    with their blocking nature:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder and a `main.go` file with the `main` package. Then, add the
    following import:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Then, write the signature of the `push()` function:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Here, there are two channels – a Boolean one called `in`, which represents the
    incoming requests, and `out`, which will be used to send back messages.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, write a loop for sending numbers when a request comes in:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: As you can see, the loop is still for a fixed number of items. Before sending
    anything, it waits for a request from the `in` channel. When it receives a request,
    it sends a number.
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create a `main()` function, where you call the `push()` function in four
    different Goroutines, each one sending a subset of the numbers 1 to 100:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This is pretty similar to the previous exercise, but it creates an extra channel,
    `in`.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create a loop to request a number, print it, and add it to the total:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'In this case, the loop first requests a number and then waits to receive another
    number. Here, we do not need to sleep for a microsecond because after we receive
    a number, the next request will go to any active Goroutine. If you run the program,
    you will again see something similar to what you saw in the previous exercise.
    Here, we have the truncated output:'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: You can see that each number is printed in the order it is received. Then, the
    sum of all numbers is printed on the screen.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you’ve learned how you can use channels to request other Goroutines
    to perform some actions. A channel can be used to send some trigger messages and
    not only to exchange content and values.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The importance of concurrency
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve seen how to use concurrency to split work over several Goroutines,
    but in all of these exercises, concurrency was not really needed. In fact, you
    do not save much time doing what we did, nor do you have any other advantage.
    Concurrency is important when you need to perform several tasks that are logically
    independent of each other, and the easiest case to understand is a web server.
    You saw in [*Chapter 16*](B18621_16.xhtml#_idTextAnchor1704), *Web Servers*, that
    several clients will most likely connect to the same server and all these connections
    will result in the server performing some actions. Also, these actions are all
    independent; that’s where concurrency is important, as you do not want one of
    your users to have to wait for all other HTTP requests to be completed before
    their request gets handled. Another case for concurrency is when you have different
    data sources to gather data and you can gather that data in different Goroutines
    and combine the result at the end. We will see now more complex applications for
    concurrency and learn how to use it for HTTP servers.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 18.08 – equally splitting work between Goroutines
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will see how we can perform our sum of numbers in a predefined
    number of Goroutines for them to gather the result at the end. Essentially, we
    want to create a function that adds numbers and receives the numbers from a channel.
    When no more numbers are received by the function, we will send the sum to the
    `main()` function through the channel.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to note here is that the function performing the sum does not know
    in advance how many numbers it will receive, which means we cannot have a fixed
    `from, to` range. So, we have to find another solution. We need to be able to
    split the work in any number of Goroutines and not be bound by a `from, to` range.
    Also, we do not want to do the addition in the `main()` function. Instead, we
    want to create a function that will split the work over several Goroutines:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder and a `main.go` file with the `main` package and write the
    following:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, let’s write a function to do a partial addition. We will call it `worker()`
    as we will have a fixed set of Goroutines running this same function, waiting
    for numbers to arrive:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: As you can see, we have an `in` channel and an `out` channel of integers. Then,
    we instantiate the `sum` variable, which will store the sum of all numbers sent
    to this worker.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we have a loop that ranges over the channel. This is interesting
    because we do not use `in` directly, as follows:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We, instead, rely only on the range to get the numbers in. In the loop, we just
    add `i` to the total and, at the end, we send the partial sum back. Even if we
    do not know how many items are going to be sent to the channel, we can still loop
    over the range without a problem. We rely on the fact that when no more items
    are sent, the `in` channel will be closed.
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `sum()` function:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This is the actual `sum()` function that has the number of workers and the usual
    range for the numbers to add.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, write a loop to run the requested number of workers:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This creates the two `in`/`out` channels and runs the number of workers set
    by the `workers` parameter.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, create a loop to send all numbers to the `in` channel:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This sends all numbers to be summed to the channel, which will distribute the
    numbers across all Goroutines. If you were to print out the numbers received across
    with the index of the worker, you could see how the numbers are distributed uniformly
    across the Goroutines, which does not mean an exact split, but at least it’s a
    fair one.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As we sent all the numbers, we now need to receive the partial sums back, but
    before that, we need to notify the function that the numbers to sum are finished,
    so add the following line of code. Closing a channel means nothing else can be
    sent, but data can still be received from the channel:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'And then, perform a sum of the partials:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Then, finally, close the `out` channel and return the result:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'At this point, we need to somehow execute this function. So, let’s write a
    simple `main()` function to do that:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This simply outputs a sum from a function that makes use of concurrency and
    then prints out the result.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you run your program, you should see the log output of the sum of numbers
    split into different routines as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: As you can see, after splitting the computation across multiple Goroutines,
    the result is synchronized into one single result.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you’ve learned how to make use of concurrency to split your
    computation across several concurrent Goroutines and then combine all these computations
    into one single result.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency patterns
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way we organize our concurrent work is pretty much the same in every application.
    We will look at one common pattern that is called a *pipeline*, where we have
    a source, and then messages are sent from one Goroutine to another until the end
    of the line, until all Goroutines in the pipeline have been utilized. Another
    pattern is the *fan out/* *fan in* pattern where, as in the previous exercise,
    work is sent to several Goroutines reading from the same channel. All these patterns,
    however, are generally made of a *source* stage, which is the first stage of the
    pipeline and the one that gathers, or sources, the data, then some internal steps,
    and at the end, a *sink*, which is the final stage where the results of the process
    from all the other routines get merged. It is known as a sink because all the
    data sinks into it.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Buffers
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ve seen in the previous exercises that there are channels with a defined
    length and channels with an undetermined length:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Let’s see how we can make use of this.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'A buffer is like a container that needs to be filled with some content, so
    you prepare it when you expect to receive that content. We said that operations
    on channels are blocking operations, which means the execution of the Goroutine
    will stop and wait whenever you try to read a message from the channel. Let’s
    try to understand what this means in practice with an example. Let’s say we have
    the following code in a Goroutine:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: We know that before we can carry on with the execution of the code, we need
    to receive a message. However, there is something more about this blocking behavior.
    If the channel does not have a buffer, the Goroutine is blocked as well. It is
    not possible to write to a channel or to receive a channel. We’ll get a better
    idea of this with an example, and we will show how to use unbuffered channels
    to achieve the same result so that you will get a better understanding of what
    you’ve seen in the previous exercises.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at this code:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'If you put this code inside a function, you will see that it works perfectly
    and will display something as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'But what if you add an extra read? Let’s take a look:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In this case, you will see an error:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This happens because the routine running this code is blocked after the buffer
    of size 2 is filled with a data size of 2 coming from the read operations (commonly
    referred to as reads), which results in the buffer being filled with data, which,
    in this case, has 2 data, and the buffer has a size of 2\. We can increase the
    buffer:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: And it will work again; we are just not displaying the third number.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s see what happens if we remove the buffer. Try, and again you will
    see the previous error. This happens because the buffer is always full and the
    routine is blocked. An unbuffered channel is equivalent to the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We’ve used unbuffered channels without any issues. Let’s see an example of
    how to use them:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'If you run this program, you should see something as follows:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'But there is a chance you could see fewer numbers. If you run this on the Go
    Playground, you should see this result, but if you run it on your machine, you
    might see fewer numbers. Try sending more numbers:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'At each addition, run your program; you might not see all the numbers. Basically,
    there are two Goroutines: one is reading messages from an unbuffered channel,
    and the main Goroutine is sending these messages through the same channel. Due
    to this, there is no deadlock. This shows that we can make use of unbuffered channels
    for read and write operations flawlessly by using two Goroutines. We still have,
    however, an issue with not all numbers showing up, which we can fix in the following
    way:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Here, we iterate over the channel inside the Goroutine, and we stop as soon
    as the channel gets closed. This is because when the channel gets closed, the
    range stops iterating. The channel gets closed in the main Goroutine after everything
    is sent. We make use of a `WaitGroup` here to know that everything is completed.
    If we were not closing the channel in the `main()` function, we would be in the
    main Goroutine, which would terminate before the second Goroutine would print
    all the numbers. There is another way, however, to wait for the execution of the
    second Goroutine to be completed, and this is with explicit notification, which
    we will see in the next exercise. One thing to notice is that even though we close
    the channel, the messages all still arrive at the receiving routine. This is because
    you can receive messages from a closed channel; you just can’t send more.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 18.09 – notifying when the computation has finished
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we want to have one Goroutine to send messages and another
    one to print them. Moreover, we want to know when the sender has finished sending
    messages. The code will be like the previous example, with some modifications:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file and import the necessary packages:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Then, define a function that will first receive the strings and print them
    later:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Then, create a loop over the channel until the channel is closed:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Finally, send a notification saying that the processing has finished:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Now, let’s build the `main()` function:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Here, we’ve also set the `log` flags to `0` so that we do not see anything other
    than the strings we send.
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create the necessary channels and use them to spin up the Goroutine:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Next, create a set of strings and loop over them, sending each string to the
    channel:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'After that, close the channel you used to send the messages and wait for the
    `done` signal:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'If you run your program, you will see the log output of code using a `done`
    channel:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: We see that the `main()` function has received all the messages from the Goroutine
    and has printed them. The `main()` function terminates only when it has been notified
    that all incoming messages have been sent.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you’ve learned how you can make a Goroutine notify another
    Goroutine that the work has finished by passing a message through a channel without
    needing `WaitGroup`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Some more common practices
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In all these examples, we’ve created channels and passed them through, but
    functions can also return channels and spin up new Goroutines. Here is an example:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'In this case, we can actually have the following in our `main()` function:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: We do not need to call the `doSomething` function as a Goroutine because it
    will spin up a new one by itself.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: 'Some functions can also return or accept, such as this one:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Here’s another example:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: This makes clear what the function does with the channels. In fact, you could
    try to specify the direction in all the exercises we’ve done so far and see what
    happens if you specify an incorrect one.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: HTTP servers
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve seen how to build HTTP servers in [*Chapter 16*](B18621_16.xhtml#_idTextAnchor1704),
    *Web Servers*, but you might remember that there was something difficult to handle
    with HTTP servers, and this was the application’s state. Essentially, an HTTP
    server runs as a single program and listens to requests in the main Goroutine.
    However, when a new HTTP request is made by one of the clients, a new Goroutine
    is created that handles that specific request. You have not done it manually,
    nor have you managed the server’s channels, but this is how it works internally.
    You do not actually need to send anything across the different Goroutines because
    each Goroutine and each request is independent since they have been made by different
    people.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: However, what you must think of is how to not create race conditions when you
    want to keep a state. Most HTTP servers are stateless, especially if you’re building
    a microservice environment. However, you might want to keep track of things with
    a counter, or you might actually work with TCP servers, a gaming server, or a
    chat app where you need to keep the state and gather information from all the
    peers. The techniques you’ve learned in this chapter allow you to do so. You can
    use a mutex to make sure a counter is thread-safe or, better, routine-safe across
    all requests. I’d suggest you go back to your code for the HTTP server and ensure
    safety with mutexes.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Methods as Goroutines
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you’ve only seen functions used as Goroutines, but methods are simple
    functions with a receiver; hence, they can be used asynchronously too. This can
    be useful if you want to share some properties of your struct, such as for your
    counter in an HTTP server.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: With this technique, you can encapsulate the channels you use across several
    Goroutines belonging to the same instance of a struct without having to pass these
    channels everywhere.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example of how to do that:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: But let’s see how to apply this in an exercise.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 18.10 – a structured work
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will calculate a sum using several workers. A worker is
    essentially a function, and we will be organizing these workers into a single
    struct:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'Create your folder and `main` file. In it, add the required imports and define
    a `Worker` struct with two channels – `in` and `out`. Ensure that you add a mutex
    as well:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'To create its methods, write the following:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Here, we create a method and increment the number of `subworker` instances.
    Sub-workers are basically identical Goroutines that split the work that needs
    to be done. Note that the function is meant to be used directly and not as a Goroutine,
    as it itself creates a new Goroutine.
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, build the content of the spawned Goroutine:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'This is pretty similar to what you’ve done before; now comes the tricky part:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Here, we’ve locked the routine, reduced the counter on the sub-workers safely,
    and then, in case all the workers have terminated, we’ve closed the output channel.
    Then, we’ve unlocked the execution to allow the program to carry on.
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we need to make a function that’s able to return the sum:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Here, we create a total, then a `WaitGroup`, and we add 1 to it as we will
    spawn only one Goroutine whose content is as follows:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: As you can see, we have looped until the `out` channel is closed by one of the
    sub-workers.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we can wait for the Goroutine to finish and return the result:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The main code just sets up variables for the worker and its sub-workers:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Now, create a loop where you call the `readThem()` method `wrNum` times. This
    will create some sub-workers:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Now, send the numbers to be summed to the channel:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Close the channel to notify that all numbers have been sent:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Then, wait for the result and print it out:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'If you run the program, you will see the log output of a sum made using structs
    to organize our work:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: In this exercise, you’ve learned how to use a method of a struct to create a
    new Goroutine. The method can be called like any function, but the result will
    be a new anonymous Goroutine being created.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Go context package
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve seen how to run concurrent code and run it until it has finished, waiting
    for the completion of some processing through `WaitGroup` or channel reads. You
    might have seen in some Go code, especially code related to HTTP calls, some parameters
    from the `context` package, and you might have wondered what it is and why it
    is used.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code we’ve written here is running on our machines and does not pass
    through the internet, so we hardly have any delay due to latency; however, in
    situations involving HTTP calls, we might encounter servers that do not respond
    and get stuck. In such cases, how do we stop our call if the server does not respond
    after a while? How do we stop the execution of a routine that runs independently
    when an event occurs? Well, we have several ways, but a standard one is to use
    contexts, and we will see now how they work. A context is a variable that is passed
    through a series of calls and might hold some values or may be empty. It is a
    container, but it is not used to send values across functions; you can use normal
    integers, strings, and so on for this purpose. A context is passed through to
    get back control of what is happening:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: As you can see, there are several calls, and `ctx` is passed through, but we
    do not do anything with it. However, it can contain data, and it contains functions
    that we can use to stop the execution of the current Goroutine. We will see how
    it works in the next exercise.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 18.11 – managing Goroutines with a context
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will start a Goroutine with an infinite loop counting
    from zero until we decide to stop it. We will make use of the context to notify
    the routine to stop and a sleeping function to make sure we know how many iterations
    we do:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: 'Create your folder and a `main.go` file, then write the following:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: For the usual imports, we have `logs` and `time`, which we’ve already seen,
    plus the `context` package.
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s write a function that counts every 100 milliseconds from 0:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Here, `v` is the value we count from zero. The `ctx` variable is the context,
    while the `r` variable is the channel returning the result. Then, we start defining
    a loop.
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we start an infinite loop, but inside it, we will have `select`:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: In this `select` group, we have a case where we check whether the context is
    `done`, and if it is, we just break the loop and return the value we have counted
    so far.
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the context is not `done`, we need to keep counting:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Here, we sleep for 100 milliseconds, and then we increment the value by 1.
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to write a `main()` function that makes use of this counter:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: We create an integer channel to pass to the counter and a context.
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to be able to cancel the context, so we extend this simple context.
    For clarity, `cl` is the variable name for the cancelable context, and `stop`
    is the function name we have chosen to cancel it:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Here, we also finally call the counting Goroutine.
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we need a way to break the loop, so we will use the `stop()`
    function returned by `context.WithCancel`, but we will do that inside another
    Goroutine. This will stop the context after 300 milliseconds:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Now, we just need to wait for the message with the count to be received and
    log it:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'After 300 milliseconds have passed, the counter will return 3 since, due to
    context manipulation, the routine stopped at the third iteration:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Here, we can see that even though the loop is infinite, the execution stops
    after three iterations.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you’ve learned how you can use a context to stop the execution
    of a Goroutine. This is useful in many cases, such as when performing long tasks
    that you want to stop after a maximum amount of time or after a certain event
    has occurred.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: One thing to mention is that, in this exercise, we did something that in some
    situations could lead to problems. What we did was create a channel in one Goroutine,
    but close it in another one. This is not wrong; in some cases, it might be useful,
    but try to avoid it as it could lead to problems when somebody looks at the code
    or when you look at the code after several months because it is difficult to track
    where a channel is closed across several functions.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent work with sync.Cond
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Efficient coordination between different Goroutines is crucial to ensure smooth
    execution and resource management. Another powerful synchronization primitive
    provided by the Go standard library is `sync.Cond` (condition). The `Cond` type
    is associated with `sync.Mutex` and provides a way for Goroutines to wait for
    or signal the occurrence of a particular condition or changes in shared data.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore how to use `sync.Cond` by creating a simple example of a **work-in-progress**
    (**WIP**) limited queue.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 18.12 – creating a WIP limited queue
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose you have a scenario where multiple Goroutines produce and consume items,
    but you want to limit the number of items in progress currently. `sync.Cond` can
    help achieve this synchronization. Here’s how to use it:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'Create your folder and a `main.go` file, then write the following:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: We import `fmt`, `sync`, and `time`, which we’ve already seen.
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s define a `WorkInProgressQueue` and function to create a new `WorkInProgressQueue`
    object:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Now, we define an `enqueue()` function to add work items while respecting a
    maximum size constraint on the work queue:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Then, define a `dequeue()` function where we consume work items:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Now we define a `main()` function and a maximum capacity for our work queue
    at three items:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Next, we define the first Goroutine. This one is responsible for producing
    work items:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'We then define the second Goroutine. This one is responsible for consuming
    work items:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Lastly, we wait for all Goroutines to complete and close our `main()` function:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Run the program:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'You will see the following output, where the items may be in different orders
    of being enqueued and then dequeued:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: This exercise demonstrates a simple work queue where the Goroutine enqueues
    items up to the queue’s maximum size. If the queue is full, then the Goroutine
    will wait until there is room for more items in the queue. Once an item is enqueued,
    then it signals other Goroutines that might be waiting on the condition variable.
    There is also the second Goroutine, or the consumer Goroutine dequeuing items.
    The consumer waits if the queue is empty up to the five items. After dequeuing
    an item, it signals to other Goroutines that might be waiting on the condition
    variable. As you can see, the `sync.Cond` variable is used for signaling and waiting
    for Goroutines.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: The thread-safe map
  id: totrans-497
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In concurrent programming, safely managing access to shared data structures
    is crucial to avoid race conditions and ensure consistency. Go’s standard library
    provides a powerful tool for concurrent map access – the `sync.Map` type. Unlike
    the regular `Map` type, `sync.Map` is specifically designed to be used concurrently
    without the need for external synchronization.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: The `sync.Map` type is part of the `sync` package and provides fine-grained
    locking internally to allow multiple readers and a single writer to access a map
    concurrently without blocking operations. This makes it suitable for scenarios
    where you have multiple Goroutines that need to read or modify a map concurrently.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an exercise showcasing the utility of `sync.Map`.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 18.13 – counting how many times random numbers are between 0 and 9
    using sync.Map
  id: totrans-501
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we want to count how many times random numbers fall between the values
    of zero and nine in a concurrent setting. The `sync.Map` type will help us do
    this safely:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 'Create your folder and a `main.go` file, then write the following:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Let’s write a function to generate a random number in the range of `[``0, max)`:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Let’s write a helper function to update the count using load and store methods
    to safely access and update the count map:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Now, write a function to print the counts from the `sync.Map` contents:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Lastly, we can define a `main()` function that will define our `sync.Map` type
    and a Goroutine to generate random numbers and update the counts in the `sync.Map`
    type:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'We will then end our `main()` function by spawning all our Goroutines and waiting
    for their completion before printing the counts from our concurrent safe map:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Run the program:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'You will see the following output, where the items may be in different orders
    and with different counts:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: In this exercise, we used the `sync.Map` type to safely maintain accurate counts
    for each random number generated by multiple Goroutines. We had the `updateCount`
    function responsible for updating the count in a thread-safe manner using the
    `LoadOrStore` and `Store` methods. We just saw how we can use this thread-safe
    map without additional synchronization mechanisms. Using `sync.Map` simplifies
    concurrent map access and eliminates the need for explicit locks, making the code
    cleaner and more efficient in scenarios where concurrent access to a map is required.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-520
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you’ve learned how to create production-ready concurrent code,
    how to handle race conditions, and how to make sure that your code is concurrent-safe.
    You’ve learned how to use channels to make your Goroutines communicate with each
    other and how to stop their executions using a context.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: You’ve worked on several techniques to handle concurrent computation and learned
    about `sync.Cond` and `sync.Map` as powerful tools in your toolbelt for concurrent
    programming In many real-life scenarios, you might just use functions and methods
    that handle concurrency for you, especially if you’re doing web programming, but
    there are cases where you must handle work coming from some different sources
    by yourself. You need to match requests with your response through different channels.
    You might need to gather different data into one single Goroutine from different
    ones. With what you’ve learned here, you’ll be able to do all that. You’ll be
    able to ensure you do not lose data by waiting for all Goroutines to finish. You’ll
    be able to modify the same variable from different Goroutines, making sure you
    do not override a value if it is not what you want. You’ve also learned how to
    avoid deadlocks and how to use channels to share information. One of the Go mottos
    is *Share by communicating, do not communicate by sharing.* This means that the
    preferred way to share values is to send them via a channel and not rely on mutexes
    if not strictly necessary. You now know how to do all that.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn to make your code more professional. Essentially,
    you will learn what you are expected to do as a professional in a real working
    environment, which is testing and checking your code – making sure, essentially,
    that your code works and is valid.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
