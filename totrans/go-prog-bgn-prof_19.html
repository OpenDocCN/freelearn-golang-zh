<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer221">
			<h1 id="_idParaDest-478" class="chapter-number"><a id="_idTextAnchor2002"/>19</h1>
			<h1 id="_idParaDest-479"><a id="_idTextAnchor2003"/>Testing</h1>
			<p class="callout-heading">Overview</p>
			<p class="callout">Testing is a crucial aspect of software development that ensures the reliability and correctness of your code. In Go, a comprehensive testing approach covers various types of tests, each serving a unique purpose. This chapter explores different testing techniques and tools available in Go to empower developers in building robust and <span class="No-Break">maintainable applications.</span></p>
			<p class="callout">By the end of this chapter, you will understand the various types of tests Go developers implement. We will discuss the big three types of tests: unit, integration, and <strong class="bold">end-to-end</strong> (<strong class="bold">E2E</strong>) tests. We will then cover a few other types of tests, such as HTTP testing and fuzz testing. We will cover test suites, benchmarks, and code coverage, and even create a final test report for project stakeholders or just to share how well-tested your code truly is. You will also see the benefits of automated tests testing your code regularly while continuously iterating on your code base as it evolves. These skills are imperative to developing production-ready and industry-grade applications. Testing is also an important part of the <strong class="bold">software development life cycle</strong> (<strong class="bold">SDLC</strong>) that we, as developers, go through for <span class="No-Break">our projects.</span></p>
			<h1 id="_idParaDest-480"><a id="_idTextAnchor2004"/>Technical requirements</h1>
			<p>For this chapter, you’ll require Go version 1.21 or higher. The code for this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter19"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter19</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-481"><a id="_idTextAnchor2005"/>Introduction</h1>
			<p>Testing is a fundamental aspect of software development that ensures the reliability, correctness, and stability of applications. In Go, testing plays a crucial role in maintaining the robustness of <span class="No-Break">software systems.</span></p>
			<p>As I mentioned previously, testing is a crucial part of the SDLC that encompasses various phases, from requirements gathering to deployment. Quality assurance begins with the implementation of effective testing strategies. Robust testing not only identifies and rectifies bugs and errors in code but also promotes maintainability and scalability. Consider a scenario where a critical financial application lacks comprehensive testing. An innocuous code change might inadvertently introduce a bug that goes unnoticed until the application fails catastrophically. Testing, therefore, acts as a safety net, catching potential issues early in the development life cycle. If a team is impacted by a bug rolling out into their different environments, developers should proactively create tests that cover that scenario for the future – no matter what language they <span class="No-Break">code in.</span></p>
			<p>Go provides a built-in testing framework that is both simple and powerful. Leveraging the testing package, developers can create unit tests, benchmark tests, and even example-based documentation tests. The testing package is designed to be expressive, making it easy to write, read, and maintain tests. Through conventions such as test file suffixes (<strong class="source-inline">_test.go</strong>) and clear test function signatures prefixed with <strong class="source-inline">Test</strong>, Go encourages a standardized approach to testing that promotes consistency across all projects. It is also important to note that there is no <strong class="source-inline">main()</strong> function when it comes to testing in Go to control the program flow. Each test function is executed independently, <span class="No-Break">and consecutively.</span></p>
			<p>In this chapter, we will dive into the specifics of testing in Go, covering topics such as writing effective unit tests, benchmarking, table-driven tests, and more. Armed with a solid understanding of testing principles in Go, developers will be well-equipped to build reliable and maintainable <span class="No-Break">software applications.</span></p>
			<h1 id="_idParaDest-482"><a id="_idTextAnchor2006"/>Unit tests</h1>
			<p>One of the<a id="_idIndexMarker1252"/> fundamental aspects of testing your application starts with unit tests. Unit tests focus on individual components, verifying that each function or method works as intended. In Go, unit tests are written using the built-in testing package, making it easy to define test functions <span class="No-Break">and assertions.</span></p>
			<p>You will typically define positive and negative unit tests. For example, if you have a function to concatenate several strings together, then you would have some positive test cases, such as <strong class="source-inline">"hi " + "sam" = "hi sam", and "bye," + " sam" = "bye, sam"</strong>. You would also add a few negative test cases that verify that an error occurred for input, such as <strong class="source-inline">"hi" + "there" expecting the result of "hi sam"</strong>. This is not equivalent, nor what we would expect as output, so our negative test case would expect an error <span class="No-Break">to arise.</span></p>
			<p>You can also consider edge cases, such as concatenating strings that include punctuation marks and ensuring that they are included in the concatenation and that proper grammatical syntax and capitalization are enforced. This provides coverage on test cases you expect to work, test cases<a id="_idIndexMarker1253"/> you expect will produce errors, and test coverage on edge or corner cases for your function <span class="No-Break">or method.</span></p>
			<p>Idiomatic and readable code should come first nature to Go programmers due to its idiomatic nature. Therefore, it should be of no surprise that Go adopts a table-driven test structure for all tests, including unit tests. Table-driven tests keep code readable, flexible, and adaptable to future changes. They include the definition of an anonymous <strong class="source-inline">using</strong> struct defined as <em class="italic">Tests</em> or <em class="italic">TestCases</em>, where you include the test case’s name, inputs or arguments, and expected outputs. Let’s see an example of this <span class="No-Break">in action.</span></p>
			<h2 id="_idParaDest-483"><a id="_idTextAnchor2007"/>Exercise 19.01 – table-driven tests</h2>
			<p>Let’s look at an example of creating idiomatic<a id="_idIndexMarker1254"/> table-driven <span class="No-Break">unit tests:</span></p>
			<ol>
				<li>Create a new folder in<a id="_idIndexMarker1255"/> your filesystem, and, inside it, create a <strong class="source-inline">main_test.go</strong> file and write the following code. We are including the <strong class="source-inline">assert</strong> package from the <strong class="source-inline">gotest.tools</strong> module as it provides utilities and enhancements for testing in Go. Specifically, the <strong class="source-inline">assert</strong> package offers assertions in an expressive and readable way, so it is a nice package <span class="No-Break">to u<a id="_idTextAnchor2008"/><a id="_idTextAnchor2009"/>se:</span><pre class="source-code">
package main
import (
  "testing"
  "gotest.tools/assert"
)</pre></li>				<li>Create a function that sums <span class="No-Break">two numbe<a id="_idTextAnchor2010"/>rs:</span><pre class="source-code">
func add(x, y int) in<a id="_idTextAnchor2011"/><a id="_idTextAnchor2012"/>t {
  return x + y
}</pre></li>				<li>Define the table-driven <a id="_idIndexMarker1256"/>test function to check that the numeric<a id="_idIndexMarker1257"/> addition is correct and add a few test cases to check. We will add a test case that expects an incorrect value to see what this <span class="No-Break">looks <a id="_idTextAnchor2013"/><a id="_idTextAnchor2014"/>like:</span><pre class="source-code">
func TestAdd(t *testing.T) {
  tests := []struct {
    name string
    inputs []int
    want int
  }{
    {
      name: "Test Case 1",
      inputs: []int{5, 6},
      want: 11,
    },
    {
      name: "Test Case 2",
      inputs: []int{11, 7},
      want: 18,
    },
    {
      name: "Test Case 3",
      inputs: []int{1, 8},
      wan<a id="_idTextAnchor2015"/><a id="_idTextAnchor2016"/>t: 9,
    },
    {
      name: "Test Case 4 (intentional failure)",
      inputs: []int{2, 3},
      want: 0, // This should be 5, intentionally incorrect to demonstrate failure
    },
  }</pre></li>				<li>Loop over each test case, assert that <a id="_idIndexMarker1258"/>the received value is what is expected, and close the function. We could just <a id="_idIndexMarker1259"/>as easily use an <strong class="source-inline">if</strong> conditional instead of the <strong class="source-inline">assert</strong> package; however, it condenses and cleans up the code a bit, so you will typically see this package being used to assert that test values <span class="No-Break">are corre<a id="_idTextAnchor2017"/><a id="_idTextAnchor2018"/>ct:</span><pre class="source-code">
    for _, test := range tests {
        got := add(test.inputs[0], test.inputs[1])
        assert.Equal(t, test.want, got)
    }
  }</pre></li>				<li>Run <span class="No-Break">the program:</span><pre class="source-code">
go test main_test.go</pre><p class="list-inset">You will see the <span class="No-Break">following output:</span></p><pre class="source-code">    main_test.go:45: assertion failed: 8 (test.want int) != 5 (got int)
FAIL
FAIL    command-line-arguments  0.168s
FAIL</pre><p class="list-inset">As you can see, the <strong class="source-inline">assert</strong> package<a id="_idIndexMarker1260"/> makes it easy to see what is failing in the test function. However, this<a id="_idIndexMarker1261"/> output makes it somewhat difficult to know which test case in particular <span class="No-Break">is failing.</span></p></li>				<li>Now, if we fix the intentionally incorrect test case, we will see the <span class="No-Break">following output:</span><pre class="source-code">
ok      command-line-arguments  0.153s</pre><p class="list-inset">You’ve now seen what table-driven tests look like for unit testing in Go. However, there are improvements we can make to this code to make it even more readable – for example, we can adjust the code so that it utilizes subtests. Subtests in Go provide <span class="No-Break">several benefits:</span></p><ul><li>Isolation of setup and teardown logic <span class="No-Break">if applicable</span></li><li>Clear <span class="No-Break">test output</span></li><li>Ability to add <span class="No-Break">parallel execution</span></li><li>Structured <span class="No-Break">test organization</span></li><li>Conditional <span class="No-Break">test execution</span></li><li>Improved <span class="No-Break">test readability</span></li></ul><p class="list-inset">Now that we’ve seen some of the benefits of subtests, let’s see what this looks like when it’s been added to our unit test function from before. For this, we can simply update the for <span class="No-Break">lo<a id="_idTextAnchor2019"/><a id="_idTextAnchor2020"/>op logic:</span></p><pre class="source-code">for _, test := range tests {
  test := test
  t.Run(test.name, func(t *testing.T) {
    got := add(test.inputs[0], test.inputs[1])
    assert.Equal(t, test.want, got)
  })
}</pre></li>				<li>Run the program again<a id="_idIndexMarker1262"/> after <span class="No-Break">the update:</span><pre class="source-code">
go test main_test.go</pre></li>			</ol>
			<p>You will see the <span class="No-Break">following </span><span class="No-Break"><a id="_idIndexMarker1263"/></span><span class="No-Break">output:</span></p>
			<pre class="console">
--- FAIL: TestAdd (0.00s)
Running tool: /usr/local/go/bin/go test -timeout 30s -run ^TestAdd$ github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter19/Exercise19.01
--- FAIL: TestAdd (0.00s)
--- FAIL: TestAdd/Test_Case_4_(intentional_failure) (0.00s)
/Users/samcoyle/go/src/github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter19/Exercise19.01/main_test.go:45: assertion failed: 0 (test.want int) != 5 (got int)
FAIL
FAIL github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter19/Exercise19.01 0.164s
FAIL</pre>			<p>From this, you can see how the failing test output helps determine which test case is failing thanks to the <strong class="source-inline">name</strong> field in our test cases. In addition, the test function’s for loop now includes <strong class="source-inline">test := test</strong>. This is due to using the variable on the range scope in the function literal. If you do not include this line, then the linter will complain due to there being an issue with the usage of the <strong class="source-inline">test</strong> loop variable inside a function literal (closure) passed to <strong class="source-inline">t.Run</strong> or another function within <span class="No-Break">the loop.</span></p>
			<p>When you use a loop variable inside a function literal, it captures the loop variable by reference. This can lead to unexpected<a id="_idIndexMarker1264"/> behavior because the loop variable is shared among all the iterations of <a id="_idIndexMarker1265"/>the for loop. To correct this problem, you can create a local copy of the loop variable within the loop to avoid capturing it by reference using the line we <span class="No-Break">have added.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The full code for this exercise is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter19/Example01/main_test.go"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter19/Example01/main_test.go</span></a><span class="No-Break">.</span></p>
			<p>We’ve now seen how to write unit tests to ensure the correctness of individual components and use table-driven tests in Go. You’ve also seen that all test functions in Go are prefixed with <strong class="source-inline">Test</strong> and involve passing the <strong class="source-inline">testing.T</strong> parameter. You now know the benefits of naming test cases, defining positive and negative test cases that cover corner cases, and being mindful of good practices and test coverage when it comes to unit tests. Unit tests are among the easiest of tests to add, so they should be plentiful and easy to adapt as your <span class="No-Break">code grows.</span></p>
			<h1 id="_idParaDest-484"><a id="_idTextAnchor2021"/>Integration tests</h1>
			<p>Integration tests verify the interactions between different components or services in your application. This can include tests for <a id="_idIndexMarker1266"/>one service interacting with another service, or one service interacting with many services. Overall, these tests ensure that the integrated system functions correctly as a whole. They also typically require more setup than your unit tests and take a bit more time to implement. These tests intend to validate the collaboration and communication between various parts of <span class="No-Break">your application.</span></p>
			<p>Integration tests play a crucial role in ensuring that the different components of your system work together seamlessly. They help uncover issues related to data flow, <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) integrations, database interactions, and other collaborative aspects that may not be<a id="_idIndexMarker1267"/> apparent during unit testing. These kinds of tests are important for detecting problems in real-world scenarios where components interact with <span class="No-Break">each other.</span></p>
			<p>When setting up integration tests, there are a<a id="_idIndexMarker1268"/> few things you need <span class="No-Break">to consider:</span></p>
			<ul>
				<li><strong class="bold">Test environment</strong>: Integration tests often require a test environment that closely resembles a production environment or may require a dedicated test database and/or <span class="No-Break">mocked services.</span></li>
				<li><strong class="bold">Data setup</strong>: Preparing test data that simulates real-world scenarios can be common for integration tests. This may involve populating a database with specific data or configuring external services with test <span class="No-Break">case data.</span></li>
				<li><strong class="bold">Service communication</strong>: When testing interactions between services, you can consider mocking or stubbing to simulate the behavior of external services. Tools such as <strong class="source-inline">gomock</strong> and <strong class="source-inline">testify/mock</strong> can help in creating mocks for <span class="No-Break">testing purposes.</span></li>
			</ul>
			<h2 id="_idParaDest-485"><a id="_idTextAnchor2022"/>Exercise 19.02 – integration test with a database</h2>
			<p>Using an in-memory database can be a good choice for integration tests as they do not affect a live database. Let’s look at an exercise<a id="_idIndexMarker1269"/> where we mock <a id="_idIndexMarker1270"/>a database, expect certain events to occur on the database, and check our values using the <span class="No-Break"><strong class="source-inline">assert</strong></span><span class="No-Break"> package:</span></p>
			<ol>
				<li>Create a new folder in your filesystem, and, inside it, create a <strong class="source-inline">main_test.go</strong> file and write <span class="No-Break">the following:</span><pre class="source-code">
package main
import (
  "context"
  "database/sql"
  "testing"
  "github.com/DATA-DOG/go-sqlmock"
  "github.com/stretchr<a id="_idTextAnchor2023"/>/testify/assert"
  "github.com/stretchr/testify/require"
)</pre></li>				<li>Define a <strong class="source-inline">Record</strong> data object that you can use to check the <span class="No-Break">da<a id="_idTextAnchor2024"/><a id="_idTextAnchor2025"/>tabase operations:</span><pre class="source-code">
type Record<a id="_idTextAnchor2026"/><a id="_idTextAnchor2027"/> struct {
  ID int
  Name string
  Value string
}</pre></li>				<li>Create the database <a id="_idIndexMarker1271"/>structure and function for creat<a id="_idTextAnchor2028"/><a id="_idTextAnchor2029"/>ing a <span class="No-Break">new database:</span><pre class="source-code">
type Database struct {
  conn *sql.DB
}
func NewDatabase(conn *sql.DB) *Database {
  return &amp;Database{conn: conn}
}</pre></li>				<li>Create the insertion <a id="_idIndexMarker1272"/>functi<a id="_idTextAnchor2030"/><a id="_idTextAnchor2031"/>on for <span class="No-Break">the database:</span><pre class="source-code">
func (d *Database) InsertRecord(ctx context.Context, record Record) error {
  _, err := d.conn.ExecContext(ctx, "INSERT INTO records (id, name, value) VALUES ($1, $2, $3)", record.ID, record.Name, record.Value)
  return err
}</pre></li>				<li>Create a function to retrieve inserted object<a id="_idTextAnchor2032"/><a id="_idTextAnchor2033"/>s from <span class="No-Break">the database:</span><pre class="source-code">
func (d *Database) GetRecordByID(ctx context.Context, id int) (Record, error) {
  var record Record
  row := d.conn.QueryRowContext(ctx, "SELECT id, name, value FROM records WHERE id = $1", id)
  err := row.Scan(&amp;record.ID, &amp;record.Name, &amp;record.Value)
  return record, err
}</pre></li>				<li>Create a test function to<a id="_idIndexMarker1273"/> check integrations with an in-memory database and perform setup by creating<a id="_idIndexMarker1274"/> the in-memory SQL mock, as well as a test record for interacting with <span class="No-Break">the database:</span><pre class="source-code">
func TestDatabaseIntegration(t *testing.T) {
  db, mock, err := sqlmock.New()
  require.NoError(t, err)
  defer db.Close()
  testRecord := Record{
    ID: 1,
    Name: "TestRecord",
    Value: "TestValue",
  }</pre></li>				<li>Set up the expectations for <a id="_idTextAnchor2034"/><a id="_idTextAnchor2035"/>the SQL <span class="No-Break">mock database:</span><pre class="source-code">
  mock.ExpectExec("INSERT INTO records").WithArgs(testRecord.ID, testRecord.Name, testRecord.Value).WillReturnResult(sqlmock.NewResult(1, 1))
  rows := sqlmock.NewRows([]string{"id", "name", "value"}).AddRow(testRecord.ID, testRecord.Name, testRecord.Value)
  mock.ExpectQuery("SELECT id, name, value FROM records").WillReturnRows(rows)
Create the database and insert a record into it:
  dbInstance := NewDatabase(db)
  err = dbInstance.InsertRecord(context.Bac<a id="_idTextAnchor2036"/>kground(), testRecord)
  assert.NoError(t, err, "Error inserting record into the database")</pre></li>				<li>Verify that you can retrieve<a id="_idIndexMarker1275"/> the inserted record from the<a id="_idIndexMarker1276"/> database, ensure all mocked expectations were met on the database, and <a id="_idTextAnchor2037"/><a id="_idTextAnchor2038"/>close the <span class="No-Break">test function:</span><pre class="source-code">
  retrievedRecord, err := dbInstance.GetRecordByID(context.Background(), 1)
  assert.NoError(t, err, "Error retrieving record from the database")
  assert.Equal(t, testRecord, retrievedRecord, "Retrieved record does not match the inserted record")
  assert.NoError(t, mock.ExpectationsWereMet())
}</pre></li>				<li>Run <span class="No-Break">the program:</span><pre class="source-code">
go test main_test.go</pre></li>			</ol>
			<p>You will see the <span class="No-Break">following output:</span></p>
			<pre class="console">
  ok      command-line-arguments  0.252s</pre>			<p>We’ve now seen what it looks like to use a mocked resource for our integration tests and performing database interactions. This test checked the insertion and retrieval of a record in the in-memory<a id="_idIndexMarker1277"/> database. You can easily expand this code to check different databases that your project<a id="_idIndexMarker1278"/> may interact with or use it for inspiration to check additional <span class="No-Break">project interactions.</span></p>
			<h1 id="_idParaDest-486"><a id="_idTextAnchor2039"/>E2E tests</h1>
			<p>In Go, E2E tests are vital for assessing the system as a whole. Unlike unit tests, which focus on isolated units of code, or integration tests, which might check that certain components cooperate as expected, E2E tests exercise<a id="_idIndexMarker1279"/> the entire system, simulating real user scenarios. These tests are good for catching issues that may arise from the integration of various components, ensuring the overall functionality of <span class="No-Break">your application.</span></p>
			<p>The purpose of E2E tests is to validate that the entire application, including its user interface, APIs, and underlying services, behaves as intended. These tests mimic the actions of a user interacting with the system, covering multiple layers and components. By testing the complete flow of an application, E2E tests help identify integration issues across the system, configuration problems, or unexpected behaviors that may arise in a <span class="No-Break">real-world environment.</span></p>
			<p>E2E tests have several <span class="No-Break">distinctive characteristics:</span></p>
			<ul>
				<li><strong class="bold">Realistic scenarios</strong>: E2E tests simulate user flows or business processes, ensuring that the application behaves as<a id="_idIndexMarker1280"/> expected from an end user’s perspective. This realism helps catch issues that might not be apparent in more <span class="No-Break">isolated testing.</span></li>
				<li><strong class="bold">Multiple component interactions</strong>: In a typical application, various components, such as databases, APIs, and user interfaces, work together to deliver functionality. E2E tests exercise these components simultaneously, verifying their interactions <span class="No-Break">and compatibility.</span></li>
				<li><strong class="bold">An environment that’s similar to production</strong>: E2E tests are usually run in an environment that closely resembles the production setup. This ensures that the tests accurately reflect <a id="_idIndexMarker1281"/>how the application will behave in <span class="No-Break">real-world conditions.</span></li>
			</ul>
			<p>When implementing E2E tests in Go, tools <a id="_idIndexMarker1282"/>such as <strong class="bold">Selenium</strong>, <strong class="bold">Cypress</strong>, or custom HTTP clients can be used to interact with the<a id="_idIndexMarker1283"/> application. Go provides the <strong class="source-inline">testing</strong> and <strong class="source-inline">testing/httptest</strong> packages, which help structure and execute E2E tests effectively. These tests often involve <a id="_idIndexMarker1284"/>setting up the application, interacting with it programmatically, and asserting that the expected outcomes match the <span class="No-Break">actual results.</span></p>
			<p>Here are some best practices for <span class="No-Break">E2E testing:</span></p>
			<ul>
				<li><strong class="bold">Isolation</strong>: E2E tests should run in an isolated environment to prevent interference with other tests or<a id="_idIndexMarker1285"/> the production-level system. This ensures the reliability and consistency of the <span class="No-Break">test results.</span></li>
				<li><strong class="bold">Automation</strong>: Due to the complexity of these tests, automation<a id="_idIndexMarker1286"/> is critical. Automated E2E tests can be integrated into the <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) pipeline, allowing for regular validation of the<a id="_idIndexMarker1287"/> application’s <span class="No-Break">E2E functionality.</span></li>
				<li><strong class="bold">Clear test scenarios</strong>: Define clear and representative test scenarios that cover critical user journeys. These scenarios should encompass the most common paths users take through <span class="No-Break">the application.</span></li>
				<li><strong class="bold">Data management</strong>: Set up and manage test data effectively. This includes creating data fixtures or using database migrations to ensure a consistent state for each test run where one test does not interfere <span class="No-Break">with another.</span></li>
			</ul>
			<p>E2E tests are some of the most involved tests to set up for a project and take the most time to complete. However, they help provide confidence in the overall functionality of the system and can catch integration issues early in the <span class="No-Break">development process.</span></p>
			<h1 id="_idParaDest-487"><a id="_idTextAnchor2040"/>HTTP testing</h1>
			<p>In Go, HTTP testing helps validate the behavior and functionality of web services and applications. These tests ensure that the<a id="_idIndexMarker1288"/> HTTP endpoints respond correctly to various requests, handle errors appropriately, and interact seamlessly with the underlying logic. Testing the HTTP layer is essential to building robust and reliable applications as it allows developers to verify the correctness of their API implementations and catch issues early in the <span class="No-Break">development process.</span></p>
			<p>The importance of HTTP testing can be summed up by the <span class="No-Break">following aspects:</span></p>
			<ul>
				<li><strong class="bold">Functional validation</strong>: HTTP tests validate the functional aspects of your API endpoints, ensuring that they produce the <a id="_idIndexMarker1289"/>expected responses for different scenarios. This includes checking status codes, response bodies, <span class="No-Break">and headers.</span></li>
				<li><strong class="bold">Integration verification</strong>: HTTP tests facilitate the verification of integrations between different components of your application. They help confirm that various services communicate correctly over HTTP while respecting the <span class="No-Break">defined contract.</span></li>
				<li><strong class="bold">Error handling</strong>: Testing<a id="_idIndexMarker1290"/> HTTP error scenarios is crucial to ensure that your API responds appropriately to erroneous requests. This includes testing for proper error codes, error messages, and error <span class="No-Break">handling behavior.</span></li>
				<li><strong class="bold">Security assurance</strong>: HTTP testing is an integral part of security testing. It allows developers to validate that the authentication and authorization mechanisms work as intended and that sensitive information is <span class="No-Break">handled securely.</span></li>
			</ul>
			<p>Go provides a powerful testing framework that makes it straightforward to write HTTP tests. The <strong class="source-inline">net/http/httptest</strong> package offers a testing server that enables the creation of isolated HTTP environments for testing. This is particularly useful for testing how your application interacts with external services <span class="No-Break">or APIs.</span></p>
			<h2 id="_idParaDest-488"><a id="_idTextAnchor2041"/>Exercise 19.03 – authentication integration with a test server</h2>
			<p>Consider a scenario where we have<a id="_idIndexMarker1291"/> an application that communicates via HTTP with an authentication service. We want a test server for the authentication service that simulates some authentication logic and then tests the main applications’ user authentication function. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>Create a new folder in your filesystem, and, inside it, create a <strong class="source-inline">main_test.go</strong> file and write <span class="No-Break">the following:</span><pre class="source-code">
package main
import (
  "net/http"
  "net/http/httptest
  "testing"
  "github.com/stretchr/testify/assert"
)</pre></li>				<li>Define a <strong class="source-inline">User</strong> struct <a id="_idIndexMarker1292"/>and an <strong class="source-inline">Application</strong> struct, along <a id="_idTextAnchor2042"/><a id="_idTextAnchor2043"/>with a new function for <span class="No-Break">the application:</span><pre class="source-code">
type User stru<a id="_idTextAnchor2044"/><a id="_idTextAnchor2045"/>ct {
  UserID string
  Username string
}
type Application struct {
  AuthServiceURL string
}
func NewApplication(authServiceURL string) *Application {
  return &amp;Application{
    AuthServiceURL: authServiceURL,
  }
}</pre></li>				<li>Create a function to s<a id="_idTextAnchor2046"/><a id="_idTextAnchor2047"/>imulate the user <span class="No-Break">authentication process:</span><pre class="source-code">
func (app *Application) AuthenticateUser(token string) (*User, error) {
  return &amp;User{
    UserID: "123",
    Username: "testuser",
  }, nil
}</pre></li>				<li>Define the test function and <a id="_idIndexMarker1293"/>set up a te<a id="_idTextAnchor2048"/><a id="_idTextAnchor2049"/>st server for the <span class="No-Break">authentication service:</span><pre class="source-code">
func TestAuthenticationIntegration(t *testing.T) {
  authService := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    if r.Header.Get("Authorization") == "Bearer valid_to<a id="_idTextAnchor2050"/><a id="_idTextAnchor2051"/>ken" {
      w.WriteHeader(http.StatusOK)
      w.Write([]byte(`{"user_id": "123", "username": "testuser"}`))
    } else {
      w.WriteHeader(http.StatusUnauthorized)
    }
  }))
  defer authService.Close()</pre></li>				<li>Create the application, test the authentication p<a id="_idTextAnchor2052"/><a id="_idTextAnchor2053"/>rocess, and then close the <span class="No-Break">test function:</span><pre class="source-code">
  app := NewApplication(authService.URL)
  token := "valid_token"
  gotUser, err := app.AuthenticateUser(token)
  assert.NoError(t, err)
  assert.Equal(t, "123", gotUser.UserID)
  assert.Equal(t, "testuser", gotUser.Username)
}</pre></li>				<li>Run <span class="No-Break">the program:</span><pre class="source-code">
go test main_test.go</pre></li>			</ol>
			<p>You will see the <span class="No-Break">following output:</span></p>
			<pre class="console">
  ok      command-line-arguments  0.298s</pre>			<p>In this exercise, we used the <strong class="source-inline">httptest.NewServer</strong> function to create a test server for the authentication service, allowing us to control its behavior during the test. The test then set up the main <a id="_idIndexMarker1294"/>application, triggered the authentication process, and asserted the expected outcomes. This helped highlight how to incorporate HTTP testing to build reliable <span class="No-Break">web applications.</span></p>
			<h1 id="_idParaDest-489"><a id="_idTextAnchor2054"/>Fuzz testing</h1>
			<p>Fuzz testing, or fuzzing, involves <a id="_idIndexMarker1295"/>providing random or malformed inputs to functions to discover vulnerabilities. In other words, it is a testing technique that involves providing invalid, unexpected, or random data as input to a program with the intent of discovering vulnerabilities and bugs. The testing package in Go’s standard library includes support for fuzzing, enabling developers to uncover unexpected behaviors with <span class="No-Break">their code.</span></p>
			<p>Unlike traditional testing, which relies on predetermined test cases, fuzz testing explores the input space extensively. You can see this as fuzz testing often subjects programs to large amounts of random or malformed input data to see what happens. Because fuzz tests are so different from traditional test cases, they can help identify edge cases and unexpected input scenarios that might light up bugs or vulnerabilities. They can also provide ongoing security and stability verification if they’re established in an <span class="No-Break">automated fashion.</span></p>
			<p>A simple example fuzz test for our <strong class="source-inline">add</strong> function from earlier looks <span class="No-Break">as follows<a id="_idTextAnchor2055"/><a id="_idTextAnchor2056"/>:</span></p>
			<pre class="source-code">
func add(x, y int) int {
  return x + y
}
func FuzzAdd(f *testing.F) {
  f.Fuzz(func(t *testing.T, i int, j int) {
    got := add(i, j)
    assert.Equal(t, i + j, got)
  })
}</pre>			<p>You can see a few differences in this function versus the previous test functions we’ve been seeing. For example, fuzz testing functions start with <em class="italic">Fuzz</em> and pass in <strong class="source-inline">f *testing.F</strong> instead of <strong class="source-inline">t *testing.T</strong>. You can also see that since we don’t have to worry about generating our<a id="_idIndexMarker1296"/> own inputs, the function is very simple and clean in comparison to all of our test cases from earlier in this chapter. In addition, instead of a <strong class="source-inline">t.Run</strong> execution, we have <strong class="source-inline">f.Fuzz</strong>, which takes a fuzz target function with our usual <strong class="source-inline">t *testing.T</strong> and the input types <span class="No-Break">to fuzz.</span></p>
			<p>Lastly, it is important to note that to see the fuzz testing results, you must run the <span class="No-Break">following command:</span></p>
			<pre class="console">
go test –fuzz .</pre>			<p>This will run the fuzz tests that are present in the test file. It is important to note that your fuzz tests can live alongside other tests in the test file. You will also see an output similar to <span class="No-Break">the following:</span></p>
			<pre class="console">
fuzz: elapsed: 0s, gathering baseline coverage: 0/1 completed
fuzz: elapsed: 0s, gathering baseline coverage: 1/1 completed, now fuzzing with 10 workers
fuzz: elapsed: 3s, execs: 331780 (110538/sec), new interesting: 0 (total: 1)
fuzz: elapsed: 6s, execs: 709743 (126040/sec), new interesting: 0 (total: 1)
fuzz: elapsed: 9s, execs: 1123414 (137875/sec), new interesting: 0 (total: 1)
fuzz: elapsed: 12s, execs: 1417293 (97927/sec), new interesting: 0 (total: 1)
fuzz: elapsed: 15s, execs: 1713062 (98627/sec), new interesting: 0 (total: 1)
fuzz: elapsed: 18s, execs: 2076324 (121080/sec), new interesting: 0 (total: 1)
^Cfuzz: elapsed: 20s, execs: 2237555 (107504/sec), new interesting: 0 (total: 1)
PASS
ok      github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter19/Example    19.697s</pre>			<p>The new interesting thing in the preceding output is the number of inputs that were added to the corpus that provide unique results. <em class="italic">Execs</em> is the number of individual tests that were run. As you can see, this is far larger than the amount we were manually testing in our unit test case from <a id="_idIndexMarker1297"/>earlier. Fuzz testing can help provide lots of input. If you have a fuzz test that fails, then the failing seed corpus entry will be written to a file and placed in the package directory. You can then use that information to rectify <span class="No-Break">the failure.</span></p>
			<h1 id="_idParaDest-490"><a id="_idTextAnchor2057"/>Benchmarks</h1>
			<p>Benchmarks assess the performance of your code by measuring the execution time of specific functions. The <strong class="source-inline">testing</strong> package<a id="_idIndexMarker1298"/> provides support for benchmarks, allowing developers to identify performance bottlenecks, identify if developers are achieving their project’s <strong class="bold">service-level indicators</strong> (<strong class="bold">SLIs</strong>) or <strong class="bold">service-level objectives</strong> (<strong class="bold">SLOs</strong>), and gain<a id="_idIndexMarker1299"/> insights into <span class="No-Break">their application.</span></p>
			<p>Similar to how<a id="_idIndexMarker1300"/> fuzz testing had a slightly different syntax, but followed our usual Go test setup expectations, benchmark tests also look different, but very similar to what we’re used to. For example, benchmark tests start with the word <em class="italic">Benchmark</em> and accept <strong class="source-inline">b *testing.B</strong>. The testing runner executes each benchmark function several times, increasing the value of <strong class="source-inline">b.N</strong> on <span class="No-Break">each run.</span></p>
			<p>Here’s a simple example benchmark function for our <span class="No-Break">addition function:</span></p>
			<pre class="source-code">
func BenchmarkAdd(b *testing.B) {
  for i := 0; i &lt; b.N; i++ {
    add(1, 2)
  }
}</pre>			<p>To run the benchmark test, you <a id="_idIndexMarker1301"/>must add the benchmark flag for the Go <span class="No-Break">test framework:</span></p>
			<pre class="console">
go test –bench .</pre>			<p>This will give you an output similar to <span class="No-Break">the following:</span></p>
			<pre class="console">
goos: darwin
goarch: arm64
pkg: github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter19/Example
BenchmarkAdd-10      1000000000      0.3444 ns/op
PASS
ok      github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter19/Example  0.538s</pre>			<p>The numerical value of <strong class="source-inline">1000000000</strong> indicates the number of iterations or operations the benchmark performed; in this case, it’s 1 billion operations. <strong class="source-inline">0.3444 ns/op</strong> is the average time taken per operation in nanoseconds. This indicates that, on average, each call to the <strong class="source-inline">add</strong> function took approximately <span class="No-Break"><strong class="source-inline">0.3444</strong></span><span class="No-Break"> nanoseconds.</span></p>
			<p>You can write even more complex benchmark functions to derive more meaning out of your code’s performance so that you can include heap allocations per operation and byte allocations <span class="No-Break">per operation.</span></p>
			<p>With benchmark tests, it is important to use real-world input to retrieve the most accurate performance metrics on your code. You should also break down benchmarks into multiple functions to attain better granularity as this will help you assess the performance of <span class="No-Break">your code.</span></p>
			<h1 id="_idParaDest-491"><a id="_idTextAnchor2058"/>Test suites</h1>
			<p>Test suites organize multiple related tests into a cohesive unit. The <strong class="source-inline">testing</strong> package in Go supports test suites that use the <strong class="source-inline">TestMain</strong> function and the <strong class="source-inline">testing.M</strong> type. <strong class="source-inline">TestMain</strong> is a special function<a id="_idIndexMarker1302"/> that can be used to perform setup and teardown logic for the entire test suite. This is particularly useful when you need to set up resources or configurations that are shared across multiple <span class="No-Break">test suites.</span></p>
			<h2 id="_idParaDest-492"><a id="_idTextAnchor2059"/>Exercise 19.04 – using TestMain to execute several test functions</h2>
			<p>Consider a scenario where you have multiple <a id="_idIndexMarker1303"/>test functions that you want to be grouped into a test suite. Let’s see how that can be done using the native Go <span class="No-Break">test framework:</span></p>
			<ol>
				<li>Create a new folder in your filesystem, and, inside it, create a <strong class="source-inline">main_test.go</strong> file and write <span class="No-Break">the following:</span><pre class="source-code">
package main
import (
  "log"
<a id="_idTextAnchor2060"/><a id="_idTextAnchor2061"/>  "testing"
)</pre></li>				<li>Define a setup and <span class="No-Break">teardown function:</span><pre class="source-code">
func setup() {
  log.Println("setup() running")
}
func teardown() {
  log.Println("t<a id="_idTextAnchor2062"/><a id="_idTextAnchor2063"/>eardown() running")
}</pre></li>				<li>Create the <span class="No-Break"><strong class="source-inline">TestMain</strong></span><span class="No-Break"> function:</span><pre class="source-code">
func TestMain(m *testing.M) {
  setup()
  defer teardown()
  m.R<a id="_idTextAnchor2064"/><a id="_idTextAnchor2065"/>un()
}</pre></li>				<li>Define a few test cases for <strong class="source-inline">TestMain</strong> <span class="No-Break">to run:</span><pre class="source-code">
func TestA(t *testing.T) {
  log.Println("TestA running")
}
func TestB(t *testing.T) {
  log.Println("TestB running")
}
func TestC(t *testing.T) {
  log.Println("TestC running")
}</pre></li>				<li>Run the program in verbose<a id="_idTextAnchor2066"/><a id="_idIndexMarker1304"/> mode to see <strong class="source-inline">TestMain</strong> executing our <span class="No-Break">test functions:</span><pre class="source-code">
go test –v main_test.go</pre></li>			</ol>
			<p>You will see the <span class="No-Break">following output:</span></p>
			<pre class="console">
2024/02/05 23:34:29 setup() running
=== RUN   TestA
2024/02/05 23:34:29 TestA running
--- PASS: TestA (0.00s)
=== RUN   TestB
2024/02/05 23:34:29 TestB running
--- PASS: TestB (0.00s)
=== RUN   TestC
2024/02/05 23:34:29 TestC running
--- PASS: TestC (0.00s)
PASS
2024/02/05 23:34:29 teardown() running
ok      github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter19/Exercise20.04    0.395s</pre>			<p>Here, you can see how <strong class="source-inline">TestMain</strong> executes the setup, then the test functions we’ve defined in the package, and then the teardown at the end thanks to the <strong class="source-inline">defer</strong> function. This allows you to write several test functions that might be related and group them into a suite to be run together. By using <strong class="source-inline">TestMain</strong>, you have more control over the global setup and teardown <a id="_idIndexMarker1305"/>processes, allowing you to handle shared resources and configurations efficiently for your <span class="No-Break">test suite.</span></p>
			<h1 id="_idParaDest-493"><a id="_idTextAnchor2067"/>Test report</h1>
			<p>Writing tests is crucial for maintaining <a id="_idIndexMarker1306"/>the correctness of your application; however, knowing the results of your tests is equally as important. Generating a test report provides a clear overview of test results. This helps identify issues and track improvements to the code base over time. The Go <strong class="source-inline">test</strong> command supports various flags for customizing <span class="No-Break">test output.</span></p>
			<p>Go provides the <strong class="source-inline">json</strong> flag, which can be used to generate machine-readable JSON output. This output can then be processed or analyzed by various tools. To generate a <a id="_idTextAnchor2068"/>test report in JSON format, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
go test . -v -json &gt; test-report.json</pre>			<p>This command runs the tests and redirects the JSON-formatted output to a file named <strong class="source-inline">test-report.json</strong> using the available test files denoted by the period, though you can specify certain test files instead of using a period. The resulting file contains information about each test, including its name, status, duration, and any <span class="No-Break">failure messages.</span></p>
			<p>You can then use this report with various tools to analyze and better visualize the test results. However, you have to be mindful that some packages might alter the output of your test results in unintended ways – or useful ways. For example, the <strong class="source-inline">stretchr/testify</strong> package can be used with the assertion functions that we’ve seen in a few of the exercises to provide more useful output in the test reports. Our simple assertion on the addition of values from previous exercises could be modified to provide clear output in the event of <span class="No-Break">a failure.</span></p>
			<p>So, let’s say we have the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
assert.Equal(t, i+j, got)</pre>			<p>This could be updated to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
assert.Equal(t, i+j, got, "the values i and j should be summed together properly")</pre>			<p>Additionally, you could update<a id="_idIndexMarker1307"/> it further to provide even more insights into what values<a id="_idTextAnchor2069"/> of <strong class="source-inline">i</strong> and <strong class="source-inline">j</strong> failed the test, and <span class="No-Break">so forth.</span></p>
			<h1 id="_idParaDest-494"><a id="_idTextAnchor2070"/>Code coverage</h1>
			<p>Understanding the extent of<a id="_idIndexMarker1308"/> code coverage ensures that your tests adequately exercise your code base. Go provides a built-in tool called <strong class="source-inline">cover</strong> that generates test coverage reports based on the test cases you have implemented and that it can identify. This is something you can easily add for unit tests and is a new feature that was added in Go 1.20 for integration test <span class="No-Break">code coverage.</span></p>
			<p>Industry standards for application development sit at an 80% code coverage average for projects to strive for. You will typically see the coverage tool used in CI tools that run pull requests against main/master branches to check that there are no large drops in code coverage that have <span class="No-Break">been tested.</span></p>
			<p>You can add the <strong class="source-inline">cover</strong> flag to calculate test coverage on your test functions. There is also a flag that you can include to specify an output file to generate from the code coverage tool running and gathering its results. This is a useful report to include when your project requires artifacts for stakeholders and leadership that want verification that proper test code coverage is included in the development of <span class="No-Break">the project.</span></p>
			<p>Let’s look at an example of what that might look like for a package we’ve been using throughout this chapter in an <strong class="source-inline">add.go</strong> file. If you have an <strong class="source-inline">add_test.go</strong> file with the corresponding <strong class="source-inline">TestAdd()</strong> function, you can check the code coverage amount using the <span class="No-Break">following command:</span></p>
			<pre class="console">
go test . -cover</pre>			<p>You can also update the period so that it points to a specific package or directory that you want code coverage on. You should see the typical test output, followed by the <span class="No-Break">coverage amount:</span></p>
			<pre class="console">
ok      github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter19/Example02        0.357s  coverage: 100.0% of statements</pre>			<p>As you can see, since there is a test function for our <strong class="source-inline">add</strong> function, we have 100% coverage. If, by chance, we add<a id="_idIndexMarker1309"/> an addition function for a different type of input, such as float64 values, then our coverage amount would drop to 50% until we add the test function that corresponds to our <span class="No-Break">new function.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The full code for this exercise is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter19/Example02"><span class="No-Break">https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter19/Example02</span></a><span class="No-Break">.</span></p>
			<p>A development team can use the results from the code coverage tool to determine if they need to increase the amount of test cases for their projects, or in certain areas of the project, as the output file can demonstrate the areas lacking in code coverage. This is one of the many powerful ways Go enables developers to write properly <span class="No-Break">tested code.</span></p>
			<h1 id="_idParaDest-495"><a id="_idTextAnchor2071"/>Summary</h1>
			<p>In this chapter, we explored the diverse landscape of testing in Go, from unit tests to integration and E2E tests, and a few other types of tests, including HTTP tests and fuzz tests. We also learned about test suites and industry best practices when it comes to code coverage for our projects. We wrapped this chapter up with what we can do with our tests, which includes creating a test report to share for our test coverage, as well as benchmarks that highlight the performance of our <span class="No-Break">code base.</span></p>
			<p>Armed with these tools and techniques, developers can ensure the reliability and stability of the Go code that they write. We covered a lot of ground when it comes to testing with Go, and barely scratched the surface of the capabilities that the Go toolchain offers us developers. In the next chapter, we’ll take a closer look at the Go tools and the capabilities they <span class="No-Break">offer us.</span></p>
		</div>
	</div></div></body></html>