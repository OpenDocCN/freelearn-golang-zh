["```go\n    package main\n    import (\n      \"testing\"\n      \"gotest.tools/assert\"\n    )\n    ```", "```go\n    func add(x, y int) int {\n      return x + y\n    }\n    ```", "```go\n    func TestAdd(t *testing.T) {\n      tests := []struct {\n        name string\n        inputs []int\n        want int\n      }{\n        {\n          name: \"Test Case 1\",\n          inputs: []int{5, 6},\n          want: 11,\n        },\n        {\n          name: \"Test Case 2\",\n          inputs: []int{11, 7},\n          want: 18,\n        },\n        {\n          name: \"Test Case 3\",\n          inputs: []int{1, 8},\n          want: 9,\n        },\n        {\n          name: \"Test Case 4 (intentional failure)\",\n          inputs: []int{2, 3},\n          want: 0, // This should be 5, intentionally incorrect to demonstrate failure\n        },\n      }\n    ```", "```go\n        for _, test := range tests {\n            got := add(test.inputs[0], test.inputs[1])\n            assert.Equal(t, test.want, got)\n        }\n      }\n    ```", "```go\n    go test main_test.go\n    ```", "```go\n        main_test.go:45: assertion failed: 8 (test.want int) != 5 (got int)\n    FAIL\n    FAIL    command-line-arguments  0.168s\n    FAIL\n    ```", "```go\n    ok      command-line-arguments  0.153s\n    ```", "```go\n    for _, test := range tests {\n      test := test\n      t.Run(test.name, func(t *testing.T) {\n        got := add(test.inputs[0], test.inputs[1])\n        assert.Equal(t, test.want, got)\n      })\n    }\n    ```", "```go\n    go test main_test.go\n    ```", "```go\n--- FAIL: TestAdd (0.00s)\nRunning tool: /usr/local/go/bin/go test -timeout 30s -run ^TestAdd$ github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter19/Exercise19.01\n--- FAIL: TestAdd (0.00s)\n--- FAIL: TestAdd/Test_Case_4_(intentional_failure) (0.00s)\n/Users/samcoyle/go/src/github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter19/Exercise19.01/main_test.go:45: assertion failed: 0 (test.want int) != 5 (got int)\nFAIL\nFAIL github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter19/Exercise19.01 0.164s\nFAIL\n```", "```go\n    package main\n    import (\n      \"context\"\n      \"database/sql\"\n      \"testing\"\n      \"github.com/DATA-DOG/go-sqlmock\"\n      \"github.com/stretchr/testify/assert\"\n      \"github.com/stretchr/testify/require\"\n    )\n    ```", "```go\n    type Record struct {\n      ID int\n      Name string\n      Value string\n    }\n    ```", "```go\n    type Database struct {\n      conn *sql.DB\n    }\n    func NewDatabase(conn *sql.DB) *Database {\n      return &Database{conn: conn}\n    }\n    ```", "```go\n    func (d *Database) InsertRecord(ctx context.Context, record Record) error {\n      _, err := d.conn.ExecContext(ctx, \"INSERT INTO records (id, name, value) VALUES ($1, $2, $3)\", record.ID, record.Name, record.Value)\n      return err\n    }\n    ```", "```go\n    func (d *Database) GetRecordByID(ctx context.Context, id int) (Record, error) {\n      var record Record\n      row := d.conn.QueryRowContext(ctx, \"SELECT id, name, value FROM records WHERE id = $1\", id)\n      err := row.Scan(&record.ID, &record.Name, &record.Value)\n      return record, err\n    }\n    ```", "```go\n    func TestDatabaseIntegration(t *testing.T) {\n      db, mock, err := sqlmock.New()\n      require.NoError(t, err)\n      defer db.Close()\n      testRecord := Record{\n        ID: 1,\n        Name: \"TestRecord\",\n        Value: \"TestValue\",\n      }\n    ```", "```go\n      mock.ExpectExec(\"INSERT INTO records\").WithArgs(testRecord.ID, testRecord.Name, testRecord.Value).WillReturnResult(sqlmock.NewResult(1, 1))\n      rows := sqlmock.NewRows([]string{\"id\", \"name\", \"value\"}).AddRow(testRecord.ID, testRecord.Name, testRecord.Value)\n      mock.ExpectQuery(\"SELECT id, name, value FROM records\").WillReturnRows(rows)\n    Create the database and insert a record into it:\n      dbInstance := NewDatabase(db)\n      err = dbInstance.InsertRecord(context.Background(), testRecord)\n      assert.NoError(t, err, \"Error inserting record into the database\")\n    ```", "```go\n      retrievedRecord, err := dbInstance.GetRecordByID(context.Background(), 1)\n      assert.NoError(t, err, \"Error retrieving record from the database\")\n      assert.Equal(t, testRecord, retrievedRecord, \"Retrieved record does not match the inserted record\")\n      assert.NoError(t, mock.ExpectationsWereMet())\n    }\n    ```", "```go\n    go test main_test.go\n    ```", "```go\n  ok      command-line-arguments  0.252s\n```", "```go\n    package main\n    import (\n      \"net/http\"\n      \"net/http/httptest\n      \"testing\"\n      \"github.com/stretchr/testify/assert\"\n    )\n    ```", "```go\n    type User struct {\n      UserID string\n      Username string\n    }\n    type Application struct {\n      AuthServiceURL string\n    }\n    func NewApplication(authServiceURL string) *Application {\n      return &Application{\n        AuthServiceURL: authServiceURL,\n      }\n    }\n    ```", "```go\n    func (app *Application) AuthenticateUser(token string) (*User, error) {\n      return &User{\n        UserID: \"123\",\n        Username: \"testuser\",\n      }, nil\n    }\n    ```", "```go\n    func TestAuthenticationIntegration(t *testing.T) {\n      authService := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        if r.Header.Get(\"Authorization\") == \"Bearer valid_token\" {\n          w.WriteHeader(http.StatusOK)\n          w.Write([]byte(`{\"user_id\": \"123\", \"username\": \"testuser\"}`))\n        } else {\n          w.WriteHeader(http.StatusUnauthorized)\n        }\n      }))\n      defer authService.Close()\n    ```", "```go\n      app := NewApplication(authService.URL)\n      token := \"valid_token\"\n      gotUser, err := app.AuthenticateUser(token)\n      assert.NoError(t, err)\n      assert.Equal(t, \"123\", gotUser.UserID)\n      assert.Equal(t, \"testuser\", gotUser.Username)\n    }\n    ```", "```go\n    go test main_test.go\n    ```", "```go\n  ok      command-line-arguments  0.298s\n```", "```go\nfunc add(x, y int) int {\n  return x + y\n}\nfunc FuzzAdd(f *testing.F) {\n  f.Fuzz(func(t *testing.T, i int, j int) {\n    got := add(i, j)\n    assert.Equal(t, i + j, got)\n  })\n}\n```", "```go\ngo test –fuzz .\n```", "```go\nfuzz: elapsed: 0s, gathering baseline coverage: 0/1 completed\nfuzz: elapsed: 0s, gathering baseline coverage: 1/1 completed, now fuzzing with 10 workers\nfuzz: elapsed: 3s, execs: 331780 (110538/sec), new interesting: 0 (total: 1)\nfuzz: elapsed: 6s, execs: 709743 (126040/sec), new interesting: 0 (total: 1)\nfuzz: elapsed: 9s, execs: 1123414 (137875/sec), new interesting: 0 (total: 1)\nfuzz: elapsed: 12s, execs: 1417293 (97927/sec), new interesting: 0 (total: 1)\nfuzz: elapsed: 15s, execs: 1713062 (98627/sec), new interesting: 0 (total: 1)\nfuzz: elapsed: 18s, execs: 2076324 (121080/sec), new interesting: 0 (total: 1)\n^Cfuzz: elapsed: 20s, execs: 2237555 (107504/sec), new interesting: 0 (total: 1)\nPASS\nok      github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter19/Example    19.697s\n```", "```go\nfunc BenchmarkAdd(b *testing.B) {\n  for i := 0; i < b.N; i++ {\n    add(1, 2)\n  }\n}\n```", "```go\ngo test –bench .\n```", "```go\ngoos: darwin\ngoarch: arm64\npkg: github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter19/Example\nBenchmarkAdd-10      1000000000      0.3444 ns/op\nPASS\nok      github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter19/Example  0.538s\n```", "```go\n    package main\n    import (\n      \"log\"\n      \"testing\"\n    )\n    ```", "```go\n    func setup() {\n      log.Println(\"setup() running\")\n    }\n    func teardown() {\n      log.Println(\"teardown() running\")\n    }\n    ```", "```go\n    func TestMain(m *testing.M) {\n      setup()\n      defer teardown()\n      m.Run()\n    }\n    ```", "```go\n    func TestA(t *testing.T) {\n      log.Println(\"TestA running\")\n    }\n    func TestB(t *testing.T) {\n      log.Println(\"TestB running\")\n    }\n    func TestC(t *testing.T) {\n      log.Println(\"TestC running\")\n    }\n    ```", "```go\n    go test –v main_test.go\n    ```", "```go\n2024/02/05 23:34:29 setup() running\n=== RUN   TestA\n2024/02/05 23:34:29 TestA running\n--- PASS: TestA (0.00s)\n=== RUN   TestB\n2024/02/05 23:34:29 TestB running\n--- PASS: TestB (0.00s)\n=== RUN   TestC\n2024/02/05 23:34:29 TestC running\n--- PASS: TestC (0.00s)\nPASS\n2024/02/05 23:34:29 teardown() running\nok      github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter19/Exercise20.04    0.395s\n```", "```go\ngo test . -v -json > test-report.json\n```", "```go\nassert.Equal(t, i+j, got)\n```", "```go\nassert.Equal(t, i+j, got, \"the values i and j should be summed together properly\")\n```", "```go\ngo test . -cover\n```", "```go\nok      github.com/packt-book/Go-Programming---From-Beginner-to-Professional-Second-Edition-/Chapter19/Example02        0.357s  coverage: 100.0% of statements\n```"]