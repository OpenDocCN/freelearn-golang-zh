- en: '19'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '19'
- en: Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Overview
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: Testing is a crucial aspect of software development that ensures the reliability
    and correctness of your code. In Go, a comprehensive testing approach covers various
    types of tests, each serving a unique purpose. This chapter explores different
    testing techniques and tools available in Go to empower developers in building
    robust and maintainable applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是软件开发的一个关键方面，它确保了代码的可靠性和正确性。在Go中，全面的测试方法涵盖了各种类型的测试，每种测试都服务于独特的目的。本章探讨了Go中可用的不同测试技术和工具，以赋予开发者构建健壮和可维护应用程序的能力。
- en: 'By the end of this chapter, you will understand the various types of tests
    Go developers implement. We will discuss the big three types of tests: unit, integration,
    and **end-to-end** (**E2E**) tests. We will then cover a few other types of tests,
    such as HTTP testing and fuzz testing. We will cover test suites, benchmarks,
    and code coverage, and even create a final test report for project stakeholders
    or just to share how well-tested your code truly is. You will also see the benefits
    of automated tests testing your code regularly while continuously iterating on
    your code base as it evolves. These skills are imperative to developing production-ready
    and industry-grade applications. Testing is also an important part of the **software
    development life cycle** (**SDLC**) that we, as developers, go through for our
    projects.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将了解Go开发者所实施的各类测试。我们将讨论三大测试类型：单元测试、集成测试和**端到端测试**（**E2E**）。然后，我们将介绍其他几种测试类型，例如HTTP测试和模糊测试。我们将涵盖测试套件、基准测试和代码覆盖率，甚至为项目利益相关者创建最终的测试报告，或者只是为了分享你的代码真正测试得有多好。你还将看到定期自动测试你的代码的好处，同时持续迭代你的代码库。这些技能对于开发生产就绪和行业级应用程序至关重要。测试也是软件开发生命周期（**SDLC**）的重要组成部分，我们作为开发者，在项目过程中会经历这一部分。
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you’ll require Go version 1.21 or higher. The code for this
    chapter can be found at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter19](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter19).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要Go版本1.21或更高版本。本章的代码可以在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter19](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter19)找到。
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Testing is a fundamental aspect of software development that ensures the reliability,
    correctness, and stability of applications. In Go, testing plays a crucial role
    in maintaining the robustness of software systems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是软件开发的一个基本方面，它确保了应用程序的可靠性、正确性和稳定性。在Go中，测试在维护软件系统的健壮性方面发挥着关键作用。
- en: As I mentioned previously, testing is a crucial part of the SDLC that encompasses
    various phases, from requirements gathering to deployment. Quality assurance begins
    with the implementation of effective testing strategies. Robust testing not only
    identifies and rectifies bugs and errors in code but also promotes maintainability
    and scalability. Consider a scenario where a critical financial application lacks
    comprehensive testing. An innocuous code change might inadvertently introduce
    a bug that goes unnoticed until the application fails catastrophically. Testing,
    therefore, acts as a safety net, catching potential issues early in the development
    life cycle. If a team is impacted by a bug rolling out into their different environments,
    developers should proactively create tests that cover that scenario for the future
    – no matter what language they code in.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，测试是软件开发生命周期（**SDLC**）的一个关键部分，它涵盖了从需求收集到部署的各个阶段。质量保证从实施有效的测试策略开始。健壮的测试不仅能够识别和纠正代码中的错误和缺陷，还能促进可维护性和可扩展性。考虑一个场景，一个关键的金融应用程序缺乏全面的测试。一个无害的代码更改可能会无意中引入一个未被注意到的错误，直到应用程序在灾难性失败时才被发现。因此，测试充当了一个安全网，在开发生命周期的早期阶段捕捉潜在的问题。如果一个团队受到一个在他们的不同环境中推出的错误的冲击，开发者应该积极创建测试来覆盖该场景，以便未来使用——无论他们使用什么语言编码。
- en: Go provides a built-in testing framework that is both simple and powerful. Leveraging
    the testing package, developers can create unit tests, benchmark tests, and even
    example-based documentation tests. The testing package is designed to be expressive,
    making it easy to write, read, and maintain tests. Through conventions such as
    test file suffixes (`_test.go`) and clear test function signatures prefixed with
    `Test`, Go encourages a standardized approach to testing that promotes consistency
    across all projects. It is also important to note that there is no `main()` function
    when it comes to testing in Go to control the program flow. Each test function
    is executed independently, and consecutively.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一个简单而强大的内置测试框架。利用测试包，开发者可以创建单元测试、基准测试，甚至是基于示例的文档测试。测试包旨在具有表现力，这使得编写、阅读和维护测试变得容易。通过测试文件后缀（`_test.go`）和以`Test`开头的前缀清晰的测试函数签名等约定，Go鼓励一种标准化的测试方法，这有助于在所有项目中保持一致性。值得注意的是，在Go中进行测试时没有`main()`函数来控制程序流程。每个测试函数都是独立且连续执行的。
- en: In this chapter, we will dive into the specifics of testing in Go, covering
    topics such as writing effective unit tests, benchmarking, table-driven tests,
    and more. Armed with a solid understanding of testing principles in Go, developers
    will be well-equipped to build reliable and maintainable software applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨Go测试的细节，包括编写有效的单元测试、基准测试、表驱动测试等内容。有了对Go测试原则的扎实理解，开发者将能够构建可靠且可维护的软件应用程序。
- en: Unit tests
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: One of the fundamental aspects of testing your application starts with unit
    tests. Unit tests focus on individual components, verifying that each function
    or method works as intended. In Go, unit tests are written using the built-in
    testing package, making it easy to define test functions and assertions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 测试你的应用程序的一个基本方面是从单元测试开始的。单元测试专注于单个组件，验证每个函数或方法是否按预期工作。在Go中，单元测试使用内置的测试包编写，这使得定义测试函数和断言变得容易。
- en: You will typically define positive and negative unit tests. For example, if
    you have a function to concatenate several strings together, then you would have
    some positive test cases, such as `"hi " + "sam" = "hi sam", and "bye," + " sam"
    = "bye, sam"`. You would also add a few negative test cases that verify that an
    error occurred for input, such as `"hi" + "there" expecting the result of "hi
    sam"`. This is not equivalent, nor what we would expect as output, so our negative
    test case would expect an error to arise.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会定义正例和反例单元测试。例如，如果你有一个连接几个字符串的函数，那么你会有一些正例测试用例，例如`"hi " + "sam" = "hi sam"`和`"bye,"
    + " sam" = "bye, sam"`。你还会添加一些反例测试用例，以验证输入是否发生了错误，例如`"hi" + "there" expecting
    the result of "hi sam"`。这并不等价，也不是我们期望的输出，因此我们的反例测试用例期望出现错误。
- en: You can also consider edge cases, such as concatenating strings that include
    punctuation marks and ensuring that they are included in the concatenation and
    that proper grammatical syntax and capitalization are enforced. This provides
    coverage on test cases you expect to work, test cases you expect will produce
    errors, and test coverage on edge or corner cases for your function or method.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以考虑边缘情况，例如连接包含标点符号的字符串，并确保它们包含在连接中，并且强制执行正确的语法语法和大小写。这为测试用例提供了覆盖，你期望它们能正常工作，测试用例你期望会产生错误，以及测试覆盖你函数或方法的边缘或角落情况。
- en: Idiomatic and readable code should come first nature to Go programmers due to
    its idiomatic nature. Therefore, it should be of no surprise that Go adopts a
    table-driven test structure for all tests, including unit tests. Table-driven
    tests keep code readable, flexible, and adaptable to future changes. They include
    the definition of an anonymous `using` struct defined as *Tests* or *TestCases*,
    where you include the test case’s name, inputs or arguments, and expected outputs.
    Let’s see an example of this in action.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其惯用性，对于Go程序员来说，编写符合习惯和易于阅读的代码应该是自然而然的。因此，Go采用表驱动测试结构进行所有测试，包括单元测试，这并不令人惊讶。表驱动测试保持代码可读性、灵活性和适应未来变化的能力。它们包括定义一个匿名`using`结构体，定义为*Tests*或*TestCases*，其中你包括测试用例的名称、输入或参数和预期输出。让我们看看这个例子是如何实施的。
- en: Exercise 19.01 – table-driven tests
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习19.01 – 表驱动测试
- en: 'Let’s look at an example of creating idiomatic table-driven unit tests:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建惯用表驱动单元测试的例子：
- en: 'Create a new folder in your filesystem, and, inside it, create a `main_test.go`
    file and write the following code. We are including the `assert` package from
    the `gotest.tools` module as it provides utilities and enhancements for testing
    in Go. Specifically, the `assert` package offers assertions in an expressive and
    readable way, so it is a nice package to use:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的文件系统中创建一个新的文件夹，并在其中创建一个`main_test.go`文件，并编写以下代码。我们包括`gotest.tools`模块中的`assert`包，因为它为Go中的测试提供了实用工具和增强。具体来说，`assert`包以表达性和可读性的方式提供断言，所以它是一个很好的包：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a function that sums two numbers:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，用于计算两个数字的和：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define the table-driven test function to check that the numeric addition is
    correct and add a few test cases to check. We will add a test case that expects
    an incorrect value to see what this looks like:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个表格驱动的测试函数来检查数值加法是否正确，并添加一些测试用例进行检查。我们将添加一个预期值错误的测试用例来查看其表现：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Loop over each test case, assert that the received value is what is expected,
    and close the function. We could just as easily use an `if` conditional instead
    of the `assert` package; however, it condenses and cleans up the code a bit, so
    you will typically see this package being used to assert that test values are
    correct:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历每个测试用例，断言接收到的值是预期的，然后关闭函数。我们同样可以使用`if`条件语句而不是`assert`包；然而，它可以使代码更加紧凑和整洁，所以你通常会看到这个包被用来断言测试值是否正确：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the program:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will see the following output:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE5]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the `assert` package makes it easy to see what is failing in
    the test function. However, this output makes it somewhat difficult to know which
    test case in particular is failing.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，`assert`包使得在测试函数中看到失败变得容易。然而，这个输出使得知道特定的哪个测试用例失败变得有些困难。
- en: 'Now, if we fix the intentionally incorrect test case, we will see the following
    output:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们修复故意错误的测试用例，我们将看到以下输出：
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You’ve now seen what table-driven tests look like for unit testing in Go. However,
    there are improvements we can make to this code to make it even more readable
    – for example, we can adjust the code so that it utilizes subtests. Subtests in
    Go provide several benefits:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你现在已经看到了Go中单元测试的表格驱动测试的样子。然而，我们可以对这个代码进行一些改进，使其更加易读——例如，我们可以调整代码，使其利用子测试。Go中的子测试提供了几个好处：
- en: Isolation of setup and teardown logic if applicable
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果适用，隔离设置和清理逻辑
- en: Clear test output
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰的测试输出
- en: Ability to add parallel execution
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够添加并行执行
- en: Structured test organization
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化测试组织
- en: Conditional test execution
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件测试执行
- en: Improved test readability
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进测试可读性
- en: 'Now that we’ve seen some of the benefits of subtests, let’s see what this looks
    like when it’s been added to our unit test function from before. For this, we
    can simply update the for loop logic:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经看到了子测试的一些好处，让我们看看当它被添加到之前的单元测试函数中时的样子。为此，我们可以简单地更新for循环逻辑：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the program again after the update:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新后再次运行程序：
- en: '[PRE8]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You will see the following output:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: From this, you can see how the failing test output helps determine which test
    case is failing thanks to the `name` field in our test cases. In addition, the
    test function’s for loop now includes `test := test`. This is due to using the
    variable on the range scope in the function literal. If you do not include this
    line, then the linter will complain due to there being an issue with the usage
    of the `test` loop variable inside a function literal (closure) passed to `t.Run`
    or another function within the loop.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，你可以看到失败的测试输出如何通过测试用例中的`name`字段帮助我们确定哪个测试用例失败。此外，测试函数的for循环现在包括`test := test`。这是由于在函数字面量中使用变量在范围作用域内。如果你不包含这一行，那么lint器会因为函数字面量（闭包）中`test`循环变量的使用问题而抱怨。
- en: When you use a loop variable inside a function literal, it captures the loop
    variable by reference. This can lead to unexpected behavior because the loop variable
    is shared among all the iterations of the for loop. To correct this problem, you
    can create a local copy of the loop variable within the loop to avoid capturing
    it by reference using the line we have added.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在函数字面量中使用循环变量时，它会通过引用捕获循环变量。这可能导致意外的行为，因为循环变量在for循环的所有迭代中是共享的。为了纠正这个问题，你可以在循环内创建循环变量的局部副本，以避免通过引用捕获它，使用我们添加的行。
- en: Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The full code for this exercise is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter19/Example01/main_test.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter19/Example01/main_test.go).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的完整代码可在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter19/Example01/main_test.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter19/Example01/main_test.go)找到。
- en: We’ve now seen how to write unit tests to ensure the correctness of individual
    components and use table-driven tests in Go. You’ve also seen that all test functions
    in Go are prefixed with `Test` and involve passing the `testing.T` parameter.
    You now know the benefits of naming test cases, defining positive and negative
    test cases that cover corner cases, and being mindful of good practices and test
    coverage when it comes to unit tests. Unit tests are among the easiest of tests
    to add, so they should be plentiful and easy to adapt as your code grows.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何编写单元测试以确保单个组件的正确性，并在Go中使用表格驱动测试。你也看到了Go中所有测试函数都以`Test`开头，并涉及传递`testing.T`参数。你现在知道了命名测试用例、定义正负测试用例以覆盖边缘情况，以及在单元测试中注意良好实践和测试覆盖率的好处。单元测试是添加起来最容易的测试之一，因此它们应该很多，并且随着代码的增长而容易适应。
- en: Integration tests
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration tests verify the interactions between different components or services
    in your application. This can include tests for one service interacting with another
    service, or one service interacting with many services. Overall, these tests ensure
    that the integrated system functions correctly as a whole. They also typically
    require more setup than your unit tests and take a bit more time to implement.
    These tests intend to validate the collaboration and communication between various
    parts of your application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试验证了应用程序中不同组件或服务之间的交互。这可能包括一个服务与另一个服务交互的测试，或者一个服务与多个服务交互的测试。总的来说，这些测试确保集成系统作为一个整体正确运行。它们通常比单元测试需要更多的设置，并且实现起来需要更多的时间。这些测试旨在验证应用程序各个部分之间的协作和通信。
- en: Integration tests play a crucial role in ensuring that the different components
    of your system work together seamlessly. They help uncover issues related to data
    flow, **application programming interface** (**API**) integrations, database interactions,
    and other collaborative aspects that may not be apparent during unit testing.
    These kinds of tests are important for detecting problems in real-world scenarios
    where components interact with each other.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试在确保系统的不同组件无缝协作中起着至关重要的作用。它们有助于揭示与数据流、**应用程序编程接口**（**API**）集成、数据库交互和其他协作方面相关的问题，这些问题在单元测试期间可能不明显。这类测试对于检测组件在现实场景中交互时可能出现的问题非常重要。
- en: 'When setting up integration tests, there are a few things you need to consider:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置集成测试时，你需要考虑以下几点：
- en: '**Test environment**: Integration tests often require a test environment that
    closely resembles a production environment or may require a dedicated test database
    and/or mocked services.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试环境**：集成测试通常需要一个与生产环境相似或可能需要专用测试数据库和/或模拟服务的测试环境。'
- en: '**Data setup**: Preparing test data that simulates real-world scenarios can
    be common for integration tests. This may involve populating a database with specific
    data or configuring external services with test case data.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据设置**：为集成测试准备模拟真实场景的数据是常见的。这可能涉及用特定数据填充数据库或配置外部服务以使用测试用例数据。'
- en: '`gomock` and `testify/mock` can help in creating mocks for testing purposes.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gomock`和`testify/mock`可以帮助创建用于测试的模拟。'
- en: Exercise 19.02 – integration test with a database
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习19.02 – 带数据库的集成测试
- en: 'Using an in-memory database can be a good choice for integration tests as they
    do not affect a live database. Let’s look at an exercise where we mock a database,
    expect certain events to occur on the database, and check our values using the
    `assert` package:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内存数据库对于集成测试来说是一个不错的选择，因为它们不会影响实时数据库。让我们看看一个模拟数据库、期望数据库发生某些事件并使用`assert`包检查我们值的练习：
- en: 'Create a new folder in your filesystem, and, inside it, create a `main_test.go`
    file and write the following:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的文件系统中创建一个新的文件夹，并在其中创建一个`main_test.go`文件，并编写以下内容：
- en: '[PRE10]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define a `Record` data object that you can use to check the database operations:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`Record`数据对象，你可以用它来检查数据库操作：
- en: '[PRE11]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create the database structure and function for creating a new database:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据库结构和创建新数据库的函数：
- en: '[PRE12]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create the insertion function for the database:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建数据库的插入函数：
- en: '[PRE13]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a function to retrieve inserted objects from the database:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从数据库检索插入对象的函数：
- en: '[PRE14]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a test function to check integrations with an in-memory database and
    perform setup by creating the in-memory SQL mock, as well as a test record for
    interacting with the database:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试函数来检查与内存数据库的集成，并通过创建内存SQL模拟以及与数据库交互的测试记录来执行设置：
- en: '[PRE15]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Set up the expectations for the SQL mock database:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置SQL模拟数据库的期望：
- en: '[PRE16]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Verify that you can retrieve the inserted record from the database, ensure
    all mocked expectations were met on the database, and close the test function:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您可以从数据库中检索插入的记录，确保数据库上所有模拟的期望都得到满足，并关闭测试函数：
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the program:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序：
- en: '[PRE18]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You will see the following output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We’ve now seen what it looks like to use a mocked resource for our integration
    tests and performing database interactions. This test checked the insertion and
    retrieval of a record in the in-memory database. You can easily expand this code
    to check different databases that your project may interact with or use it for
    inspiration to check additional project interactions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何使用模拟资源进行集成测试以及执行数据库交互的样子。这个测试检查了在内存数据库中记录的插入和检索。您可以轻松扩展此代码以检查项目可能交互的不同数据库，或者用它作为灵感来检查额外的项目交互。
- en: E2E tests
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端测试
- en: In Go, E2E tests are vital for assessing the system as a whole. Unlike unit
    tests, which focus on isolated units of code, or integration tests, which might
    check that certain components cooperate as expected, E2E tests exercise the entire
    system, simulating real user scenarios. These tests are good for catching issues
    that may arise from the integration of various components, ensuring the overall
    functionality of your application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，端到端测试对于评估整个系统至关重要。与关注独立代码单元的单元测试不同，或者与可能检查某些组件是否按预期合作的集成测试不同，端到端测试对整个系统进行测试，模拟真实用户场景。这些测试有助于捕捉可能由各种组件集成引起的问题，确保应用程序的整体功能。
- en: The purpose of E2E tests is to validate that the entire application, including
    its user interface, APIs, and underlying services, behaves as intended. These
    tests mimic the actions of a user interacting with the system, covering multiple
    layers and components. By testing the complete flow of an application, E2E tests
    help identify integration issues across the system, configuration problems, or
    unexpected behaviors that may arise in a real-world environment.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试的目的是验证整个应用程序，包括其用户界面、API和底层服务，是否按预期运行。这些测试模拟用户与系统交互的动作，覆盖多个层次和组件。通过测试应用程序的完整流程，端到端测试有助于识别系统中的集成问题、配置问题或可能在现实世界环境中出现的意外行为。
- en: 'E2E tests have several distinctive characteristics:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试有几个显著特点：
- en: '**Realistic scenarios**: E2E tests simulate user flows or business processes,
    ensuring that the application behaves as expected from an end user’s perspective.
    This realism helps catch issues that might not be apparent in more isolated testing.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**现实场景**：端到端测试模拟用户流程或业务流程，确保应用程序从最终用户的角度来看表现如预期。这种现实感有助于捕捉在更隔离的测试中可能不明显的问题。'
- en: '**Multiple component interactions**: In a typical application, various components,
    such as databases, APIs, and user interfaces, work together to deliver functionality.
    E2E tests exercise these components simultaneously, verifying their interactions
    and compatibility.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多组件交互**：在典型应用中，各种组件，如数据库、API和用户界面，共同工作以提供功能。端到端测试同时对这些组件进行测试，验证它们的交互和兼容性。'
- en: '**An environment that’s similar to production**: E2E tests are usually run
    in an environment that closely resembles the production setup. This ensures that
    the tests accurately reflect how the application will behave in real-world conditions.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与生产环境相似的环境**：端到端测试通常在接近生产设置的环境中运行。这确保了测试能够准确地反映应用程序在实际条件下的行为。'
- en: When implementing E2E tests in Go, tools such as `testing` and `testing/httptest`
    packages, which help structure and execute E2E tests effectively. These tests
    often involve setting up the application, interacting with it programmatically,
    and asserting that the expected outcomes match the actual results.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中实现 E2E 测试时，可以使用 `testing` 和 `testing/httptest` 等工具包，这些工具包有助于有效地构建和执行 E2E
    测试。这些测试通常涉及设置应用程序，以编程方式与之交互，并断言预期的结果与实际结果相匹配。
- en: 'Here are some best practices for E2E testing:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些 E2E 测试的最佳实践：
- en: '**Isolation**: E2E tests should run in an isolated environment to prevent interference
    with other tests or the production-level system. This ensures the reliability
    and consistency of the test results.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：E2E 测试应在隔离环境中运行，以防止与其他测试或生产级系统发生干扰。这确保了测试结果的可靠性和一致性。'
- en: '**Automation**: Due to the complexity of these tests, automation is critical.
    Automated E2E tests can be integrated into the **continuous integration** (**CI**)
    pipeline, allowing for regular validation of the application’s E2E functionality.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：由于这些测试的复杂性，自动化至关重要。自动化的 E2E 测试可以集成到 **持续集成**（**CI**）管道中，允许定期验证应用程序的
    E2E 功能。'
- en: '**Clear test scenarios**: Define clear and representative test scenarios that
    cover critical user journeys. These scenarios should encompass the most common
    paths users take through the application.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰的测试场景**：定义清晰且具有代表性的测试场景，涵盖关键的用户旅程。这些场景应包括用户在应用程序中采取的最常见路径。'
- en: '**Data management**: Set up and manage test data effectively. This includes
    creating data fixtures or using database migrations to ensure a consistent state
    for each test run where one test does not interfere with another.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据管理**：有效地设置和管理测试数据。这包括创建数据固定或使用数据库迁移，以确保每次测试运行的一致状态，确保一个测试不会干扰另一个测试。'
- en: E2E tests are some of the most involved tests to set up for a project and take
    the most time to complete. However, they help provide confidence in the overall
    functionality of the system and can catch integration issues early in the development
    process.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: E2E 测试是设置项目时最复杂的测试之一，并且完成它们需要花费最多的时间。然而，它们有助于增强对系统整体功能的信心，并且可以在开发早期阶段捕捉到集成问题。
- en: HTTP testing
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 测试
- en: In Go, HTTP testing helps validate the behavior and functionality of web services
    and applications. These tests ensure that the HTTP endpoints respond correctly
    to various requests, handle errors appropriately, and interact seamlessly with
    the underlying logic. Testing the HTTP layer is essential to building robust and
    reliable applications as it allows developers to verify the correctness of their
    API implementations and catch issues early in the development process.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，HTTP 测试有助于验证网络服务和应用程序的行为和功能。这些测试确保 HTTP 端点对各种请求做出正确的响应，适当地处理错误，并与底层逻辑无缝交互。测试
    HTTP 层对于构建健壮和可靠的应用程序至关重要，因为它允许开发者验证其 API 实现的正确性，并在开发早期阶段捕捉到问题。
- en: 'The importance of HTTP testing can be summed up by the following aspects:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 测试的重要性可以通过以下方面总结：
- en: '**Functional validation**: HTTP tests validate the functional aspects of your
    API endpoints, ensuring that they produce the expected responses for different
    scenarios. This includes checking status codes, response bodies, and headers.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能验证**：HTTP 测试验证了 API 端点的功能方面，确保它们在不同场景下产生预期的响应。这包括检查状态码、响应体和头信息。'
- en: '**Integration verification**: HTTP tests facilitate the verification of integrations
    between different components of your application. They help confirm that various
    services communicate correctly over HTTP while respecting the defined contract.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成验证**：HTTP 测试有助于验证应用程序不同组件之间的集成。它们有助于确认各种服务是否通过 HTTP 正确通信，同时遵守定义的契约。'
- en: '**Error handling**: Testing HTTP error scenarios is crucial to ensure that
    your API responds appropriately to erroneous requests. This includes testing for
    proper error codes, error messages, and error handling behavior.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：测试 HTTP 错误场景对于确保您的 API 对错误请求做出适当的响应至关重要。这包括测试适当的错误代码、错误消息和错误处理行为。'
- en: '**Security assurance**: HTTP testing is an integral part of security testing.
    It allows developers to validate that the authentication and authorization mechanisms
    work as intended and that sensitive information is handled securely.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全保证**：HTTP 测试是安全测试的一个组成部分。它允许开发者验证认证和授权机制是否按预期工作，以及敏感信息是否得到安全处理。'
- en: Go provides a powerful testing framework that makes it straightforward to write
    HTTP tests. The `net/http/httptest` package offers a testing server that enables
    the creation of isolated HTTP environments for testing. This is particularly useful
    for testing how your application interacts with external services or APIs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了一个强大的测试框架，使得编写HTTP测试变得简单直接。`net/http/httptest`包提供了一个测试服务器，它允许创建用于测试的隔离HTTP环境。这对于测试你的应用程序如何与外部服务或API交互特别有用。
- en: Exercise 19.03 – authentication integration with a test server
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习19.03 – 与测试服务器的认证集成
- en: 'Consider a scenario where we have an application that communicates via HTTP
    with an authentication service. We want a test server for the authentication service
    that simulates some authentication logic and then tests the main applications’
    user authentication function. Let’s get started:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个场景，我们有一个通过HTTP与认证服务通信的应用程序。我们希望有一个模拟一些认证逻辑并测试主应用程序用户认证功能的认证服务测试服务器。让我们开始吧：
- en: 'Create a new folder in your filesystem, and, inside it, create a `main_test.go`
    file and write the following:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的文件系统中创建一个新的文件夹，并在其中创建一个`main_test.go`文件，并编写以下内容：
- en: '[PRE20]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Define a `User` struct and an `Application` struct, along with a new function
    for the application:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`User`结构体和一个`Application`结构体，以及一个新的应用程序函数：
- en: '[PRE21]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a function to simulate the user authentication process:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模拟用户认证过程的函数：
- en: '[PRE22]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Define the test function and set up a test server for the authentication service:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义测试函数并设置用于认证服务的测试服务器：
- en: '[PRE23]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create the application, test the authentication process, and then close the
    test function:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建应用程序，测试认证过程，然后关闭测试功能：
- en: '[PRE24]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the program:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序：
- en: '[PRE25]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You will see the following output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this exercise, we used the `httptest.NewServer` function to create a test
    server for the authentication service, allowing us to control its behavior during
    the test. The test then set up the main application, triggered the authentication
    process, and asserted the expected outcomes. This helped highlight how to incorporate
    HTTP testing to build reliable web applications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了`httptest.NewServer`函数来创建认证服务的测试服务器，使我们能够在测试期间控制其行为。然后测试设置了主应用程序，触发了认证过程，并断言了预期的结果。这有助于突出如何将HTTP测试集成到构建可靠的Web应用程序中。
- en: Fuzz testing
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊测试
- en: Fuzz testing, or fuzzing, involves providing random or malformed inputs to functions
    to discover vulnerabilities. In other words, it is a testing technique that involves
    providing invalid, unexpected, or random data as input to a program with the intent
    of discovering vulnerabilities and bugs. The testing package in Go’s standard
    library includes support for fuzzing, enabling developers to uncover unexpected
    behaviors with their code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试，或称模糊化，涉及向函数提供随机或格式不正确的输入以发现漏洞。换句话说，它是一种测试技术，涉及向程序提供无效、意外或随机数据作为输入，目的是发现漏洞和错误。Go标准库中的测试包包括对模糊测试的支持，使开发者能够发现代码中的意外行为。
- en: Unlike traditional testing, which relies on predetermined test cases, fuzz testing
    explores the input space extensively. You can see this as fuzz testing often subjects
    programs to large amounts of random or malformed input data to see what happens.
    Because fuzz tests are so different from traditional test cases, they can help
    identify edge cases and unexpected input scenarios that might light up bugs or
    vulnerabilities. They can also provide ongoing security and stability verification
    if they’re established in an automated fashion.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的测试不同，传统的测试依赖于预定义的测试用例，模糊测试则广泛地探索输入空间。你可以将其视为模糊测试经常使程序承受大量随机或格式不正确的输入数据，以观察会发生什么。由于模糊测试与传统测试用例有很大不同，它们可以帮助识别边缘情况和可能触发错误或漏洞的意外输入场景。如果以自动化的方式建立，它们还可以提供持续的安全性和稳定性验证。
- en: 'A simple example fuzz test for our `add` function from earlier looks as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们之前提到的`add`函数的一个简单模糊测试示例如下：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can see a few differences in this function versus the previous test functions
    we’ve been seeing. For example, fuzz testing functions start with *Fuzz* and pass
    in `f *testing.F` instead of `t *testing.T`. You can also see that since we don’t
    have to worry about generating our own inputs, the function is very simple and
    clean in comparison to all of our test cases from earlier in this chapter. In
    addition, instead of a `t.Run` execution, we have `f.Fuzz`, which takes a fuzz
    target function with our usual `t *testing.T` and the input types to fuzz.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前看到的测试函数相比，这个函数有一些不同之处。例如，模糊测试函数以 *Fuzz* 开头，并传递 `f *testing.F` 而不是 `t *testing.T`。您还可以看到，由于我们不必担心生成自己的输入，与本章早期所有测试用例相比，该函数非常简单且干净。此外，我们不再使用
    `t.Run` 执行，而是使用 `f.Fuzz`，它接受一个模糊目标函数以及我们常用的 `t *testing.T` 和模糊输入类型。
- en: 'Lastly, it is important to note that to see the fuzz testing results, you must
    run the following command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要注意的是，要查看模糊测试结果，必须运行以下命令：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will run the fuzz tests that are present in the test file. It is important
    to note that your fuzz tests can live alongside other tests in the test file.
    You will also see an output similar to the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行测试文件中存在的模糊测试。需要注意的是，您的模糊测试可以与测试文件中的其他测试共存。您还将看到类似于以下的结果：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The new interesting thing in the preceding output is the number of inputs that
    were added to the corpus that provide unique results. *Execs* is the number of
    individual tests that were run. As you can see, this is far larger than the amount
    we were manually testing in our unit test case from earlier. Fuzz testing can
    help provide lots of input. If you have a fuzz test that fails, then the failing
    seed corpus entry will be written to a file and placed in the package directory.
    You can then use that information to rectify the failure.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出中新的有趣之处在于添加到语料库中的输入数量，这些输入提供了独特的结果。*Execs* 是运行的单个测试的数量。如您所见，这比我们之前在单元测试用例中手动测试的数量大得多。模糊测试可以帮助提供大量的输入。如果您有一个失败的模糊测试，那么失败的种子语料库条目将被写入文件并放置在包目录中。然后您可以使用该信息来纠正失败。
- en: Benchmarks
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试
- en: Benchmarks assess the performance of your code by measuring the execution time
    of specific functions. The `testing` package provides support for benchmarks,
    allowing developers to identify performance bottlenecks, identify if developers
    are achieving their project’s **service-level indicators** (**SLIs**) or **service-level
    objectives** (**SLOs**), and gain insights into their application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试通过测量特定函数的执行时间来评估代码的性能。`testing` 包提供了对基准测试的支持，允许开发者识别性能瓶颈，确定开发者是否实现了项目的**服务级别指标**（**SLIs**）或**服务级别目标**（**SLOs**），并深入了解他们的应用程序。
- en: Similar to how fuzz testing had a slightly different syntax, but followed our
    usual Go test setup expectations, benchmark tests also look different, but very
    similar to what we’re used to. For example, benchmark tests start with the word
    *Benchmark* and accept `b *testing.B`. The testing runner executes each benchmark
    function several times, increasing the value of `b.N` on each run.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与模糊测试有略微不同的语法，但遵循我们通常的 Go 测试设置期望一样，基准测试看起来也不同，但与我们习惯的非常相似。例如，基准测试以单词 *Benchmark*
    开头，并接受 `b *testing.B`。测试运行器会执行每个基准函数多次，每次运行都会增加 `b.N` 的值。
- en: 'Here’s a simple example benchmark function for our addition function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个针对我们的加法函数的简单基准函数示例：
- en: '[PRE30]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To run the benchmark test, you must add the benchmark flag for the Go test
    framework:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行基准测试，您必须为 Go 测试框架添加基准标志：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will give you an output similar to the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出类似于以下的结果：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The numerical value of `1000000000` indicates the number of iterations or operations
    the benchmark performed; in this case, it’s 1 billion operations. `0.3444 ns/op`
    is the average time taken per operation in nanoseconds. This indicates that, on
    average, each call to the `add` function took approximately `0.3444` nanoseconds.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`1000000000` 的数值表示基准测试执行的迭代次数或操作数；在这种情况下，是 10 亿次操作。`0.3444 ns/op` 是每次操作的平均时间，以纳秒为单位。这表明，平均而言，每次调用
    `add` 函数大约花费了 `0.3444` 纳秒。'
- en: You can write even more complex benchmark functions to derive more meaning out
    of your code’s performance so that you can include heap allocations per operation
    and byte allocations per operation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以编写更复杂的基准函数，以便从代码的性能中获得更多意义，从而包括每个操作的堆分配和每个操作的字节分配。
- en: With benchmark tests, it is important to use real-world input to retrieve the
    most accurate performance metrics on your code. You should also break down benchmarks
    into multiple functions to attain better granularity as this will help you assess
    the performance of your code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在基准测试中，使用真实世界的输入来获取代码的最准确性能指标非常重要。你还应该将基准测试分解成多个函数，以获得更好的粒度，这将有助于你评估代码的性能。
- en: Test suites
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试套件
- en: Test suites organize multiple related tests into a cohesive unit. The `testing`
    package in Go supports test suites that use the `TestMain` function and the `testing.M`
    type. `TestMain` is a special function that can be used to perform setup and teardown
    logic for the entire test suite. This is particularly useful when you need to
    set up resources or configurations that are shared across multiple test suites.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 测试套件将多个相关的测试组织成一个统一的单元。Go中的`testing`包支持使用`TestMain`函数和`testing.M`类型的测试套件。`TestMain`是一个特殊函数，可以用于执行整个测试套件的设置和清理逻辑。当你需要设置跨多个测试套件的资源或配置时，这特别有用。
- en: Exercise 19.04 – using TestMain to execute several test functions
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习19.04 – 使用TestMain执行多个测试函数
- en: 'Consider a scenario where you have multiple test functions that you want to
    be grouped into a test suite. Let’s see how that can be done using the native
    Go test framework:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个场景，你有多个测试函数想要分组到一个测试套件中。让我们看看如何使用本机Go测试框架来实现这一点：
- en: 'Create a new folder in your filesystem, and, inside it, create a `main_test.go`
    file and write the following:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的文件系统中创建一个新的文件夹，并在其中创建一个`main_test.go`文件，并编写以下内容：
- en: '[PRE33]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Define a setup and teardown function:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义设置和清理函数：
- en: '[PRE34]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create the `TestMain` function:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`TestMain`函数：
- en: '[PRE35]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define a few test cases for `TestMain` to run:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一些测试用例以运行`TestMain`：
- en: '[PRE36]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Run the program in verbose mode to see `TestMain` executing our test functions:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以详细模式运行程序以查看`TestMain`执行我们的测试函数：
- en: '[PRE37]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You will see the following output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, you can see how `TestMain` executes the setup, then the test functions
    we’ve defined in the package, and then the teardown at the end thanks to the `defer`
    function. This allows you to write several test functions that might be related
    and group them into a suite to be run together. By using `TestMain`, you have
    more control over the global setup and teardown processes, allowing you to handle
    shared resources and configurations efficiently for your test suite.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到`TestMain`如何执行设置，然后执行我们在包中定义的测试函数，最后通过`defer`函数执行清理。这允许你编写可能相关的多个测试函数，并将它们分组为套件一起运行。通过使用`TestMain`，你可以更好地控制整个测试套件的设置和清理过程，从而有效地处理测试套件的共享资源和配置。
- en: Test report
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试报告
- en: Writing tests is crucial for maintaining the correctness of your application;
    however, knowing the results of your tests is equally as important. Generating
    a test report provides a clear overview of test results. This helps identify issues
    and track improvements to the code base over time. The Go `test` command supports
    various flags for customizing test output.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试对于维护应用程序的正确性至关重要；然而，了解测试结果同样重要。生成测试报告可以清晰地概述测试结果。这有助于识别问题并随着时间的推移跟踪代码库的改进。Go的`test`命令支持各种标志来定制测试输出。
- en: 'Go provides the `json` flag, which can be used to generate machine-readable
    JSON output. This output can then be processed or analyzed by various tools. To
    generate a test report in JSON format, run the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了`json`标志，可用于生成可机器读取的JSON输出。然后，可以使用各种工具处理或分析此输出。要生成JSON格式的测试报告，请运行以下命令：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This command runs the tests and redirects the JSON-formatted output to a file
    named `test-report.json` using the available test files denoted by the period,
    though you can specify certain test files instead of using a period. The resulting
    file contains information about each test, including its name, status, duration,
    and any failure messages.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令运行测试，并将JSON格式的输出重定向到名为`test-report.json`的文件，使用点号表示可用的测试文件，尽管你可以指定某些测试文件而不是使用点号。生成的文件包含有关每个测试的信息，包括其名称、状态、持续时间以及任何失败消息。
- en: You can then use this report with various tools to analyze and better visualize
    the test results. However, you have to be mindful that some packages might alter
    the output of your test results in unintended ways – or useful ways. For example,
    the `stretchr/testify` package can be used with the assertion functions that we’ve
    seen in a few of the exercises to provide more useful output in the test reports.
    Our simple assertion on the addition of values from previous exercises could be
    modified to provide clear output in the event of a failure.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用各种工具使用此报告来分析和更好地可视化测试结果。然而，您必须注意，某些包可能会以未预料到的方式（或有用的方式）更改您的测试结果输出。例如，`stretchr/testify`包可以与我们在一些练习中看到的断言函数一起使用，以在测试报告中提供更有用的输出。我们关于从前一章节的练习中添加值的简单断言可以修改为在失败事件中提供清晰的输出。
- en: 'So, let’s say we have the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下代码：
- en: '[PRE40]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This could be updated to the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以更新为以下内容：
- en: '[PRE41]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Additionally, you could update it further to provide even more insights into
    what values of `i` and `j` failed the test, and so forth.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以进一步更新它，以提供更多关于`i`和`j`的哪些值未能通过测试等信息的洞察。
- en: Code coverage
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Understanding the extent of code coverage ensures that your tests adequately
    exercise your code base. Go provides a built-in tool called `cover` that generates
    test coverage reports based on the test cases you have implemented and that it
    can identify. This is something you can easily add for unit tests and is a new
    feature that was added in Go 1.20 for integration test code coverage.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 理解代码覆盖范围确保您的测试充分测试了代码库。Go提供了一个名为`cover`的内置工具，它根据您已实施的测试用例生成测试覆盖率报告，并且可以识别。这对于单元测试来说很容易添加，这是Go
    1.20为集成测试代码覆盖率添加的新功能。
- en: Industry standards for application development sit at an 80% code coverage average
    for projects to strive for. You will typically see the coverage tool used in CI
    tools that run pull requests against main/master branches to check that there
    are no large drops in code coverage that have been tested.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发的行业标准是项目力争达到80%的代码覆盖率平均。您通常会在CI工具中看到覆盖率工具的使用，这些工具针对main/master分支运行拉取请求，以检查是否存在已测试的代码覆盖率的大幅下降。
- en: You can add the `cover` flag to calculate test coverage on your test functions.
    There is also a flag that you can include to specify an output file to generate
    from the code coverage tool running and gathering its results. This is a useful
    report to include when your project requires artifacts for stakeholders and leadership
    that want verification that proper test code coverage is included in the development
    of the project.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`cover`标志添加到测试函数中，以计算测试覆盖率。还有一个标志，您可以在其中指定一个输出文件，以便从运行并收集其结果的代码覆盖率工具生成。当您的项目需要利益相关者和领导层验证项目开发中包含适当的测试代码覆盖率时，这是一个有用的报告。
- en: 'Let’s look at an example of what that might look like for a package we’ve been
    using throughout this chapter in an `add.go` file. If you have an `add_test.go`
    file with the corresponding `TestAdd()` function, you can check the code coverage
    amount using the following command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，看看这对于我们在本章中使用的`add.go`文件中的包可能是什么样子。如果您有一个包含相应`TestAdd()`函数的`add_test.go`文件，您可以使用以下命令检查代码覆盖率：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can also update the period so that it points to a specific package or directory
    that you want code coverage on. You should see the typical test output, followed
    by the coverage amount:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以更新周期，使其指向您想要代码覆盖的具体包或目录。您应该看到典型的测试输出，然后是覆盖率数量：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see, since there is a test function for our `add` function, we have
    100% coverage. If, by chance, we add an addition function for a different type
    of input, such as float64 values, then our coverage amount would drop to 50% until
    we add the test function that corresponds to our new function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，由于我们的`add`函数有一个测试函数，所以我们有100%的覆盖率。如果我们意外地添加了一个针对不同类型输入的加法函数，例如float64值，那么我们的覆盖率将下降到50%，直到我们添加与我们的新函数相对应的测试函数。
- en: Note
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The full code for this exercise is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter19/Example02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter19/Example02).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的完整代码可在[https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter19/Example02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter19/Example02)找到。
- en: A development team can use the results from the code coverage tool to determine
    if they need to increase the amount of test cases for their projects, or in certain
    areas of the project, as the output file can demonstrate the areas lacking in
    code coverage. This is one of the many powerful ways Go enables developers to
    write properly tested code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一个开发团队可以使用代码覆盖率工具的结果来确定他们是否需要增加他们项目的测试用例数量，或者在项目的某些区域，因为输出文件可以展示代码覆盖率不足的区域。这是Go语言为开发者提供编写经过适当测试的代码的许多强大方式之一。
- en: Summary
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the diverse landscape of testing in Go, from unit
    tests to integration and E2E tests, and a few other types of tests, including
    HTTP tests and fuzz tests. We also learned about test suites and industry best
    practices when it comes to code coverage for our projects. We wrapped this chapter
    up with what we can do with our tests, which includes creating a test report to
    share for our test coverage, as well as benchmarks that highlight the performance
    of our code base.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Go语言测试的多样化领域，从单元测试到集成和端到端测试，以及一些其他类型的测试，包括HTTP测试和模糊测试。我们还了解了在项目代码覆盖率方面的一些测试套件和行业最佳实践。我们以我们可以对测试做的事情结束本章，包括创建测试报告以共享测试覆盖率，以及突出显示代码库性能的基准测试。
- en: Armed with these tools and techniques, developers can ensure the reliability
    and stability of the Go code that they write. We covered a lot of ground when
    it comes to testing with Go, and barely scratched the surface of the capabilities
    that the Go toolchain offers us developers. In the next chapter, we’ll take a
    closer look at the Go tools and the capabilities they offer us.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些工具和技术，开发者可以确保他们编写的Go代码的可靠性和稳定性。在Go语言测试方面，我们覆盖了很多内容，但仅仅触及了Go工具链为我们开发者提供的功能的一角。在下一章中，我们将更深入地探讨Go工具及其为我们提供的功能。
