- en: '19'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: Testing is a crucial aspect of software development that ensures the reliability
    and correctness of your code. In Go, a comprehensive testing approach covers various
    types of tests, each serving a unique purpose. This chapter explores different
    testing techniques and tools available in Go to empower developers in building
    robust and maintainable applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will understand the various types of tests
    Go developers implement. We will discuss the big three types of tests: unit, integration,
    and **end-to-end** (**E2E**) tests. We will then cover a few other types of tests,
    such as HTTP testing and fuzz testing. We will cover test suites, benchmarks,
    and code coverage, and even create a final test report for project stakeholders
    or just to share how well-tested your code truly is. You will also see the benefits
    of automated tests testing your code regularly while continuously iterating on
    your code base as it evolves. These skills are imperative to developing production-ready
    and industry-grade applications. Testing is also an important part of the **software
    development life cycle** (**SDLC**) that we, as developers, go through for our
    projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you’ll require Go version 1.21 or higher. The code for this
    chapter can be found at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter19](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter19).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a fundamental aspect of software development that ensures the reliability,
    correctness, and stability of applications. In Go, testing plays a crucial role
    in maintaining the robustness of software systems.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned previously, testing is a crucial part of the SDLC that encompasses
    various phases, from requirements gathering to deployment. Quality assurance begins
    with the implementation of effective testing strategies. Robust testing not only
    identifies and rectifies bugs and errors in code but also promotes maintainability
    and scalability. Consider a scenario where a critical financial application lacks
    comprehensive testing. An innocuous code change might inadvertently introduce
    a bug that goes unnoticed until the application fails catastrophically. Testing,
    therefore, acts as a safety net, catching potential issues early in the development
    life cycle. If a team is impacted by a bug rolling out into their different environments,
    developers should proactively create tests that cover that scenario for the future
    – no matter what language they code in.
  prefs: []
  type: TYPE_NORMAL
- en: Go provides a built-in testing framework that is both simple and powerful. Leveraging
    the testing package, developers can create unit tests, benchmark tests, and even
    example-based documentation tests. The testing package is designed to be expressive,
    making it easy to write, read, and maintain tests. Through conventions such as
    test file suffixes (`_test.go`) and clear test function signatures prefixed with
    `Test`, Go encourages a standardized approach to testing that promotes consistency
    across all projects. It is also important to note that there is no `main()` function
    when it comes to testing in Go to control the program flow. Each test function
    is executed independently, and consecutively.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will dive into the specifics of testing in Go, covering
    topics such as writing effective unit tests, benchmarking, table-driven tests,
    and more. Armed with a solid understanding of testing principles in Go, developers
    will be well-equipped to build reliable and maintainable software applications.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the fundamental aspects of testing your application starts with unit
    tests. Unit tests focus on individual components, verifying that each function
    or method works as intended. In Go, unit tests are written using the built-in
    testing package, making it easy to define test functions and assertions.
  prefs: []
  type: TYPE_NORMAL
- en: You will typically define positive and negative unit tests. For example, if
    you have a function to concatenate several strings together, then you would have
    some positive test cases, such as `"hi " + "sam" = "hi sam", and "bye," + " sam"
    = "bye, sam"`. You would also add a few negative test cases that verify that an
    error occurred for input, such as `"hi" + "there" expecting the result of "hi
    sam"`. This is not equivalent, nor what we would expect as output, so our negative
    test case would expect an error to arise.
  prefs: []
  type: TYPE_NORMAL
- en: You can also consider edge cases, such as concatenating strings that include
    punctuation marks and ensuring that they are included in the concatenation and
    that proper grammatical syntax and capitalization are enforced. This provides
    coverage on test cases you expect to work, test cases you expect will produce
    errors, and test coverage on edge or corner cases for your function or method.
  prefs: []
  type: TYPE_NORMAL
- en: Idiomatic and readable code should come first nature to Go programmers due to
    its idiomatic nature. Therefore, it should be of no surprise that Go adopts a
    table-driven test structure for all tests, including unit tests. Table-driven
    tests keep code readable, flexible, and adaptable to future changes. They include
    the definition of an anonymous `using` struct defined as *Tests* or *TestCases*,
    where you include the test case’s name, inputs or arguments, and expected outputs.
    Let’s see an example of this in action.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 19.01 – table-driven tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at an example of creating idiomatic table-driven unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder in your filesystem, and, inside it, create a `main_test.go`
    file and write the following code. We are including the `assert` package from
    the `gotest.tools` module as it provides utilities and enhancements for testing
    in Go. Specifically, the `assert` package offers assertions in an expressive and
    readable way, so it is a nice package to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that sums two numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the table-driven test function to check that the numeric addition is
    correct and add a few test cases to check. We will add a test case that expects
    an incorrect value to see what this looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop over each test case, assert that the received value is what is expected,
    and close the function. We could just as easily use an `if` conditional instead
    of the `assert` package; however, it condenses and cleans up the code a bit, so
    you will typically see this package being used to assert that test values are
    correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the `assert` package makes it easy to see what is failing in
    the test function. However, this output makes it somewhat difficult to know which
    test case in particular is failing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, if we fix the intentionally incorrect test case, we will see the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ve now seen what table-driven tests look like for unit testing in Go. However,
    there are improvements we can make to this code to make it even more readable
    – for example, we can adjust the code so that it utilizes subtests. Subtests in
    Go provide several benefits:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Isolation of setup and teardown logic if applicable
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear test output
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to add parallel execution
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured test organization
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional test execution
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved test readability
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we’ve seen some of the benefits of subtests, let’s see what this looks
    like when it’s been added to our unit test function from before. For this, we
    can simply update the for loop logic:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program again after the update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: From this, you can see how the failing test output helps determine which test
    case is failing thanks to the `name` field in our test cases. In addition, the
    test function’s for loop now includes `test := test`. This is due to using the
    variable on the range scope in the function literal. If you do not include this
    line, then the linter will complain due to there being an issue with the usage
    of the `test` loop variable inside a function literal (closure) passed to `t.Run`
    or another function within the loop.
  prefs: []
  type: TYPE_NORMAL
- en: When you use a loop variable inside a function literal, it captures the loop
    variable by reference. This can lead to unexpected behavior because the loop variable
    is shared among all the iterations of the for loop. To correct this problem, you
    can create a local copy of the loop variable within the loop to avoid capturing
    it by reference using the line we have added.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The full code for this exercise is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter19/Example01/main_test.go](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/blob/main/Chapter19/Example01/main_test.go).
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how to write unit tests to ensure the correctness of individual
    components and use table-driven tests in Go. You’ve also seen that all test functions
    in Go are prefixed with `Test` and involve passing the `testing.T` parameter.
    You now know the benefits of naming test cases, defining positive and negative
    test cases that cover corner cases, and being mindful of good practices and test
    coverage when it comes to unit tests. Unit tests are among the easiest of tests
    to add, so they should be plentiful and easy to adapt as your code grows.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integration tests verify the interactions between different components or services
    in your application. This can include tests for one service interacting with another
    service, or one service interacting with many services. Overall, these tests ensure
    that the integrated system functions correctly as a whole. They also typically
    require more setup than your unit tests and take a bit more time to implement.
    These tests intend to validate the collaboration and communication between various
    parts of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests play a crucial role in ensuring that the different components
    of your system work together seamlessly. They help uncover issues related to data
    flow, **application programming interface** (**API**) integrations, database interactions,
    and other collaborative aspects that may not be apparent during unit testing.
    These kinds of tests are important for detecting problems in real-world scenarios
    where components interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'When setting up integration tests, there are a few things you need to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test environment**: Integration tests often require a test environment that
    closely resembles a production environment or may require a dedicated test database
    and/or mocked services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data setup**: Preparing test data that simulates real-world scenarios can
    be common for integration tests. This may involve populating a database with specific
    data or configuring external services with test case data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gomock` and `testify/mock` can help in creating mocks for testing purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise 19.02 – integration test with a database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using an in-memory database can be a good choice for integration tests as they
    do not affect a live database. Let’s look at an exercise where we mock a database,
    expect certain events to occur on the database, and check our values using the
    `assert` package:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder in your filesystem, and, inside it, create a `main_test.go`
    file and write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `Record` data object that you can use to check the database operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the database structure and function for creating a new database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the insertion function for the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to retrieve inserted objects from the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a test function to check integrations with an in-memory database and
    perform setup by creating the in-memory SQL mock, as well as a test record for
    interacting with the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set up the expectations for the SQL mock database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify that you can retrieve the inserted record from the database, ensure
    all mocked expectations were met on the database, and close the test function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now seen what it looks like to use a mocked resource for our integration
    tests and performing database interactions. This test checked the insertion and
    retrieval of a record in the in-memory database. You can easily expand this code
    to check different databases that your project may interact with or use it for
    inspiration to check additional project interactions.
  prefs: []
  type: TYPE_NORMAL
- en: E2E tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Go, E2E tests are vital for assessing the system as a whole. Unlike unit
    tests, which focus on isolated units of code, or integration tests, which might
    check that certain components cooperate as expected, E2E tests exercise the entire
    system, simulating real user scenarios. These tests are good for catching issues
    that may arise from the integration of various components, ensuring the overall
    functionality of your application.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of E2E tests is to validate that the entire application, including
    its user interface, APIs, and underlying services, behaves as intended. These
    tests mimic the actions of a user interacting with the system, covering multiple
    layers and components. By testing the complete flow of an application, E2E tests
    help identify integration issues across the system, configuration problems, or
    unexpected behaviors that may arise in a real-world environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'E2E tests have several distinctive characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Realistic scenarios**: E2E tests simulate user flows or business processes,
    ensuring that the application behaves as expected from an end user’s perspective.
    This realism helps catch issues that might not be apparent in more isolated testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple component interactions**: In a typical application, various components,
    such as databases, APIs, and user interfaces, work together to deliver functionality.
    E2E tests exercise these components simultaneously, verifying their interactions
    and compatibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An environment that’s similar to production**: E2E tests are usually run
    in an environment that closely resembles the production setup. This ensures that
    the tests accurately reflect how the application will behave in real-world conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When implementing E2E tests in Go, tools such as `testing` and `testing/httptest`
    packages, which help structure and execute E2E tests effectively. These tests
    often involve setting up the application, interacting with it programmatically,
    and asserting that the expected outcomes match the actual results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some best practices for E2E testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Isolation**: E2E tests should run in an isolated environment to prevent interference
    with other tests or the production-level system. This ensures the reliability
    and consistency of the test results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automation**: Due to the complexity of these tests, automation is critical.
    Automated E2E tests can be integrated into the **continuous integration** (**CI**)
    pipeline, allowing for regular validation of the application’s E2E functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clear test scenarios**: Define clear and representative test scenarios that
    cover critical user journeys. These scenarios should encompass the most common
    paths users take through the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data management**: Set up and manage test data effectively. This includes
    creating data fixtures or using database migrations to ensure a consistent state
    for each test run where one test does not interfere with another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E2E tests are some of the most involved tests to set up for a project and take
    the most time to complete. However, they help provide confidence in the overall
    functionality of the system and can catch integration issues early in the development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Go, HTTP testing helps validate the behavior and functionality of web services
    and applications. These tests ensure that the HTTP endpoints respond correctly
    to various requests, handle errors appropriately, and interact seamlessly with
    the underlying logic. Testing the HTTP layer is essential to building robust and
    reliable applications as it allows developers to verify the correctness of their
    API implementations and catch issues early in the development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The importance of HTTP testing can be summed up by the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional validation**: HTTP tests validate the functional aspects of your
    API endpoints, ensuring that they produce the expected responses for different
    scenarios. This includes checking status codes, response bodies, and headers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration verification**: HTTP tests facilitate the verification of integrations
    between different components of your application. They help confirm that various
    services communicate correctly over HTTP while respecting the defined contract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling**: Testing HTTP error scenarios is crucial to ensure that
    your API responds appropriately to erroneous requests. This includes testing for
    proper error codes, error messages, and error handling behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security assurance**: HTTP testing is an integral part of security testing.
    It allows developers to validate that the authentication and authorization mechanisms
    work as intended and that sensitive information is handled securely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go provides a powerful testing framework that makes it straightforward to write
    HTTP tests. The `net/http/httptest` package offers a testing server that enables
    the creation of isolated HTTP environments for testing. This is particularly useful
    for testing how your application interacts with external services or APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 19.03 – authentication integration with a test server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider a scenario where we have an application that communicates via HTTP
    with an authentication service. We want a test server for the authentication service
    that simulates some authentication logic and then tests the main applications’
    user authentication function. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder in your filesystem, and, inside it, create a `main_test.go`
    file and write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `User` struct and an `Application` struct, along with a new function
    for the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to simulate the user authentication process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the test function and set up a test server for the authentication service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the application, test the authentication process, and then close the
    test function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we used the `httptest.NewServer` function to create a test
    server for the authentication service, allowing us to control its behavior during
    the test. The test then set up the main application, triggered the authentication
    process, and asserted the expected outcomes. This helped highlight how to incorporate
    HTTP testing to build reliable web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzz testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fuzz testing, or fuzzing, involves providing random or malformed inputs to functions
    to discover vulnerabilities. In other words, it is a testing technique that involves
    providing invalid, unexpected, or random data as input to a program with the intent
    of discovering vulnerabilities and bugs. The testing package in Go’s standard
    library includes support for fuzzing, enabling developers to uncover unexpected
    behaviors with their code.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike traditional testing, which relies on predetermined test cases, fuzz testing
    explores the input space extensively. You can see this as fuzz testing often subjects
    programs to large amounts of random or malformed input data to see what happens.
    Because fuzz tests are so different from traditional test cases, they can help
    identify edge cases and unexpected input scenarios that might light up bugs or
    vulnerabilities. They can also provide ongoing security and stability verification
    if they’re established in an automated fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example fuzz test for our `add` function from earlier looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can see a few differences in this function versus the previous test functions
    we’ve been seeing. For example, fuzz testing functions start with *Fuzz* and pass
    in `f *testing.F` instead of `t *testing.T`. You can also see that since we don’t
    have to worry about generating our own inputs, the function is very simple and
    clean in comparison to all of our test cases from earlier in this chapter. In
    addition, instead of a `t.Run` execution, we have `f.Fuzz`, which takes a fuzz
    target function with our usual `t *testing.T` and the input types to fuzz.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, it is important to note that to see the fuzz testing results, you must
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will run the fuzz tests that are present in the test file. It is important
    to note that your fuzz tests can live alongside other tests in the test file.
    You will also see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The new interesting thing in the preceding output is the number of inputs that
    were added to the corpus that provide unique results. *Execs* is the number of
    individual tests that were run. As you can see, this is far larger than the amount
    we were manually testing in our unit test case from earlier. Fuzz testing can
    help provide lots of input. If you have a fuzz test that fails, then the failing
    seed corpus entry will be written to a file and placed in the package directory.
    You can then use that information to rectify the failure.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Benchmarks assess the performance of your code by measuring the execution time
    of specific functions. The `testing` package provides support for benchmarks,
    allowing developers to identify performance bottlenecks, identify if developers
    are achieving their project’s **service-level indicators** (**SLIs**) or **service-level
    objectives** (**SLOs**), and gain insights into their application.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to how fuzz testing had a slightly different syntax, but followed our
    usual Go test setup expectations, benchmark tests also look different, but very
    similar to what we’re used to. For example, benchmark tests start with the word
    *Benchmark* and accept `b *testing.B`. The testing runner executes each benchmark
    function several times, increasing the value of `b.N` on each run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple example benchmark function for our addition function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the benchmark test, you must add the benchmark flag for the Go test
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give you an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The numerical value of `1000000000` indicates the number of iterations or operations
    the benchmark performed; in this case, it’s 1 billion operations. `0.3444 ns/op`
    is the average time taken per operation in nanoseconds. This indicates that, on
    average, each call to the `add` function took approximately `0.3444` nanoseconds.
  prefs: []
  type: TYPE_NORMAL
- en: You can write even more complex benchmark functions to derive more meaning out
    of your code’s performance so that you can include heap allocations per operation
    and byte allocations per operation.
  prefs: []
  type: TYPE_NORMAL
- en: With benchmark tests, it is important to use real-world input to retrieve the
    most accurate performance metrics on your code. You should also break down benchmarks
    into multiple functions to attain better granularity as this will help you assess
    the performance of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Test suites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test suites organize multiple related tests into a cohesive unit. The `testing`
    package in Go supports test suites that use the `TestMain` function and the `testing.M`
    type. `TestMain` is a special function that can be used to perform setup and teardown
    logic for the entire test suite. This is particularly useful when you need to
    set up resources or configurations that are shared across multiple test suites.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 19.04 – using TestMain to execute several test functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider a scenario where you have multiple test functions that you want to
    be grouped into a test suite. Let’s see how that can be done using the native
    Go test framework:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder in your filesystem, and, inside it, create a `main_test.go`
    file and write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a setup and teardown function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `TestMain` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a few test cases for `TestMain` to run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program in verbose mode to see `TestMain` executing our test functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see how `TestMain` executes the setup, then the test functions
    we’ve defined in the package, and then the teardown at the end thanks to the `defer`
    function. This allows you to write several test functions that might be related
    and group them into a suite to be run together. By using `TestMain`, you have
    more control over the global setup and teardown processes, allowing you to handle
    shared resources and configurations efficiently for your test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Test report
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing tests is crucial for maintaining the correctness of your application;
    however, knowing the results of your tests is equally as important. Generating
    a test report provides a clear overview of test results. This helps identify issues
    and track improvements to the code base over time. The Go `test` command supports
    various flags for customizing test output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go provides the `json` flag, which can be used to generate machine-readable
    JSON output. This output can then be processed or analyzed by various tools. To
    generate a test report in JSON format, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This command runs the tests and redirects the JSON-formatted output to a file
    named `test-report.json` using the available test files denoted by the period,
    though you can specify certain test files instead of using a period. The resulting
    file contains information about each test, including its name, status, duration,
    and any failure messages.
  prefs: []
  type: TYPE_NORMAL
- en: You can then use this report with various tools to analyze and better visualize
    the test results. However, you have to be mindful that some packages might alter
    the output of your test results in unintended ways – or useful ways. For example,
    the `stretchr/testify` package can be used with the assertion functions that we’ve
    seen in a few of the exercises to provide more useful output in the test reports.
    Our simple assertion on the addition of values from previous exercises could be
    modified to provide clear output in the event of a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s say we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This could be updated to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, you could update it further to provide even more insights into
    what values of `i` and `j` failed the test, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the extent of code coverage ensures that your tests adequately
    exercise your code base. Go provides a built-in tool called `cover` that generates
    test coverage reports based on the test cases you have implemented and that it
    can identify. This is something you can easily add for unit tests and is a new
    feature that was added in Go 1.20 for integration test code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Industry standards for application development sit at an 80% code coverage average
    for projects to strive for. You will typically see the coverage tool used in CI
    tools that run pull requests against main/master branches to check that there
    are no large drops in code coverage that have been tested.
  prefs: []
  type: TYPE_NORMAL
- en: You can add the `cover` flag to calculate test coverage on your test functions.
    There is also a flag that you can include to specify an output file to generate
    from the code coverage tool running and gathering its results. This is a useful
    report to include when your project requires artifacts for stakeholders and leadership
    that want verification that proper test code coverage is included in the development
    of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of what that might look like for a package we’ve been
    using throughout this chapter in an `add.go` file. If you have an `add_test.go`
    file with the corresponding `TestAdd()` function, you can check the code coverage
    amount using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also update the period so that it points to a specific package or directory
    that you want code coverage on. You should see the typical test output, followed
    by the coverage amount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, since there is a test function for our `add` function, we have
    100% coverage. If, by chance, we add an addition function for a different type
    of input, such as float64 values, then our coverage amount would drop to 50% until
    we add the test function that corresponds to our new function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The full code for this exercise is available at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter19/Example02](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter19/Example02).
  prefs: []
  type: TYPE_NORMAL
- en: A development team can use the results from the code coverage tool to determine
    if they need to increase the amount of test cases for their projects, or in certain
    areas of the project, as the output file can demonstrate the areas lacking in
    code coverage. This is one of the many powerful ways Go enables developers to
    write properly tested code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the diverse landscape of testing in Go, from unit
    tests to integration and E2E tests, and a few other types of tests, including
    HTTP tests and fuzz tests. We also learned about test suites and industry best
    practices when it comes to code coverage for our projects. We wrapped this chapter
    up with what we can do with our tests, which includes creating a test report to
    share for our test coverage, as well as benchmarks that highlight the performance
    of our code base.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with these tools and techniques, developers can ensure the reliability
    and stability of the Go code that they write. We covered a lot of ground when
    it comes to testing with Go, and barely scratched the surface of the capabilities
    that the Go toolchain offers us developers. In the next chapter, we’ll take a
    closer look at the Go tools and the capabilities they offer us.
  prefs: []
  type: TYPE_NORMAL
