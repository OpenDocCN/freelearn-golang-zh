- en: '20'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Go Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will teach you how to make use of the Go toolkit so that you can
    improve and build your code. It will also help you build and improve your code
    using Go tools and create binaries using `go build`. Furthermore, you’ll learn
    how to clean up library imports using `goimports`, detect suspicious constructs
    with `go vet`, and identify race conditions in your code using the Go race detector.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to run code with `go run`, format
    code with `gofmt`, automatically generate documentation using `go doc`, and download
    third-party packages using `go get`.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you’ll require Go version 1.21 or higher. The code for this
    chapter can be found at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter20](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter20).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you learned how to produce concurrent and well-tested
    code. Although Go makes the task of creating concurrent and tested code much easier
    compared to other languages, these tasks can be intrinsically complex. This is
    when learning to use tools to write better code that will simplify the complexity
    comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about Go tools. Go comes with several tools
    to help you write better code. For example, in the previous chapters, you came
    across `go build`, which you used to build your code into an executable. You also
    came across `go test`, which you used to test your code. There are also a few
    more tools that help in different ways. For example, the `goimports` tool will
    check if you have all the import statements required for your code to work and
    if not, it will add them. It can also check if any of your import statements are
    no longer needed and remove them. While this seems like a very simple thing, it
    means you no longer need to worry about the imports and can instead focus on the
    code you are writing. Alternatively, you can use the Go race detector to find
    race conditions hidden in your code. This is an extremely valuable tool when you
    start writing concurrent code.
  prefs: []
  type: TYPE_NORMAL
- en: The tools provided with the Go language are one of the reasons for its popularity.
    They provide a standard way to check code for formatting issues, mistakes, and
    race conditions, which is very useful when you are developing software in a professional
    setting. The exercises in this chapter provide practical examples of how to use
    these tools to improve your code.
  prefs: []
  type: TYPE_NORMAL
- en: The go build tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `go build` tool takes Go source code and compiles it so that it can be executed.
    When creating software, you write code in a human-readable programming language.
    Then, the code needs to be translated into a machine-readable format so that it
    can be executed. This is done by a compiler that compiles the machine instructions
    from the source code. To do this with Go code, you can use `go build`.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 20.01 – using the go build tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn about the `go build` tool. This will take
    your Go source code and compile it into a binary. To use it, run the `go build`
    tool on the command line while using the `–o` flag to specify the output file
    or executable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If the `–o` flag is omitted, the output file will be named by the package or
    folder that contains the source file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `Exercise20.01`. Within that directory, create
    a new file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following two commands to create the Go module for the exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the file to create a simple `Hello` `World` program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the program, you need to open your Terminal and navigate to the directory
    that you created the `main.go` file in. Then, run the `go build` tool by writing
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will create an executable called `hello_world` that you can execute the
    binary in by running it on the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, you used the `go build` tool to compile your code into a binary
    and execute it.
  prefs: []
  type: TYPE_NORMAL
- en: The go run tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `go run` tool is similar to `go build` in that it compiles your Go code.
    However, the subtle difference is that `go build` will output a binary file that
    you can execute, whereas the `go run` tool doesn’t create a binary file that you
    need to execute. It compiles the code and runs it in a single step, with no binary
    file output in the end. This can be useful if you want to quickly check that your
    code does what you expect it to do, without the need to create and run a binary
    file. This would be commonly used when you’re testing your code so that you can
    run it quickly without needing to create a binary to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 20.02 – using the go run tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn about the `go run` tool. This is used as a
    shortcut to compile and run your code in a single step, which is useful if you
    want to quickly check that your code works. To use it, run the `go run` tool on
    the command line in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `Exercise20.02`. Within that directory, create
    a new file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following two commands to create the Go module for this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the file to create a simple `Hello` `Packt` program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can run the program using the `go` `run` tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will execute the code and run it all in one step, giving you the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, you used the `go run` tool to compile and run a simple Go
    program in a single step. This is useful to quickly check whether your code does
    what you expect.
  prefs: []
  type: TYPE_NORMAL
- en: The gofmt tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `gofmt` tool is used to keep your code neat and consistently styled. When
    working on a large software project, an important but often overlooked factor
    is code style. Having a consistent code style throughout your project is important
    for readability. When you must read someone else’s code, or even your own code
    months after writing it, having it in a consistent style makes you focus on the
    logic without much effort. Having to parse differing styles when reading code
    is just one more thing to worry about and leads to mistakes. To overcome this
    issue, Go comes with a tool to automatically format your code in a consistent
    way called `gofmt`. This means that, across your project, and even across other
    Go projects that use the `gofmt` tool, the code will be consistent. So, it will
    fix the formatting of the code by correcting the spacing and indentation, as well
    as trying to align the sections of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 20.03 – using the gofmt tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you’ll learn how to use the `gofmt` tool to format your code.
    When you run the `gofmt` tool, it will display how it thinks the file should look
    with the correct formatting, but it won’t change the file. If you would like `gofmt`
    to automatically change the file to the correct format, you can run `gofmt` with
    the `-w` option, which will update the file and save the changes. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `Exercise20.03`. Within that directory, create
    a new Go file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following two commands to create the Go module for this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the file to create a badly formatted `Hello` `Packt`
    program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in your Terminal, run `gofmt` to see what the file will look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display how the file should be formatted to make it correct. Here
    is the expected output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 20.1: Expected output from gofmt](img/B18621_20_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.1: Expected output from gofmt'
  prefs: []
  type: TYPE_NORMAL
- en: However, this only shows the changes it would make; it doesn’t change the file.
    This is so that you can confirm you are happy with the changes it will make.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the file and save those changes, you need to add the `-``w` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will update the file and save the changes. Then, when you look at the
    file, it should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You may observe that the badly formatted code has been realigned after using
    the `gofmt` tool. The spacing and indentation have been fixed, and the new line
    between `func` and `main()` has been removed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Many `gofmt` on your code when you save. It is worth researching how to do this
    with your chosen IDE so that the `gofmt` tool will run automatically and fix any
    spacing or indentation mistakes in your code.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you used the `gofmt` tool to reformat a badly formatted file
    into a neat state. This can seem pointless and annoying when you first start coding.
    However, as your skills improve and you start working on larger projects, you
    will start to appreciate the importance of a neat and consistent code style.
  prefs: []
  type: TYPE_NORMAL
- en: The goimports tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another useful tool that comes with Go is `goimports`, which automatically adds
    the imports that are needed in your file. A key part of software engineering is
    not reinventing the wheel and reusing other people’s code. In Go, you do this
    by importing the libraries at the start of your file, in the `import` section.
    It can, however, be tedious to add these imports each time you need to use them.
    You can also accidentally leave in unused imports, which can pose a security risk.
    A better way to do this is to use `goimports` to automatically add the imports
    for you. It will also remove unused imports and reorder the remaining imports
    into alphabetical order for better readability.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 20.04 – using the goimports tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn how to use `goimports` to manage the imports
    in a simple Go program. When you run the `goimports` tool, it will output how
    it thinks the file should look with the imports fixed. Alternatively, you can
    run `goimports` with the `-w` option, which automatically updates the imports
    in the file and saves the changes. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `Exercise20.04`. Within that directory, create
    a new file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following two commands to create the Go module for this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the file to create a simple `Hello Packt` program
    with incorrect imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will notice that the `log` library has not been imported and that the `net/http`
    import is unused.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In your Terminal, run the `goimports` tool against your file to see how the
    imports change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display the changes it would make to the file to correct it. Here
    is the expected output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 20.2: Expected output for goimports](img/B18621_20_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.2: Expected output for goimports'
  prefs: []
  type: TYPE_NORMAL
- en: This won’t have changed the file but shows what the file will be changed to.
    As you can see, the `net/http` import has been removed and the `log` import has
    been added.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write these changes to the file, add the `-``w` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will update the file and make it look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, you learned how to use the `goimports` tool. You can use this
    tool to detect incorrect and unused import statements and automatically correct
    them. Many IDEs come with a built-in way to turn on `goimports` so that when you
    save your file, it will automatically correct the imports for you.
  prefs: []
  type: TYPE_NORMAL
- en: The go vet tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `go vet` tool is used for static analysis of your Go code. While the Go
    compiler can find and inform you of mistakes you may have made, there are certain
    things it will miss. For this reason, the `go vet` tool was created. This might
    sound trivial, but some of these issues could go unnoticed for a long time after
    the code has been deployed, the most common of which is passing the wrong number
    of arguments when using the `Printf` function. It will also check for useless
    assignments, for example, if you set a variable and then never use that variable.
    Another particularly useful thing it detects is when a non-pointer interface is
    passed to an `unmarshal` function. The compiler won’t notice this as it is valid;
    however, the `unmarshal` function will be unable to write the data to the interface.
    This can be troublesome to debug but using the `go vet` tool allows you to catch
    it early and remediate the issue before it becomes a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 20.05 – using the go vet tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use the `go vet` tool to find a common mistake that’s
    made when using the `Printf` function. You will use it to detect when the wrong
    number of arguments are being passed to a `Printf` function. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory called `Exercise20.05`. Within that directory, create
    a new go file called `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following two commands to create the Go module for this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the file to create a simple `Hello` `Packt` program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the `jointString` variable makes use of `fmt.Sprintf` to join
    two strings into one. However, the `%s` format string is incorrect and only formats
    one of the input strings. When you build this code, it will compile into a binary
    without any errors. However, when you run the program, the output will not be
    as expected. Luckily, the `go vet` tool was created for this exact reason.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the `go vet` tool against the file you created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display any issues it finds in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.3: Expected output from go vet](img/B18621_20_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.3: Expected output from go vet'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `go vet` has identified an issue on line 9 of the file. The
    `Sprintf` call needs `1` argument, but we have given it `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Sprintf` call so that it can handle both arguments we want to send:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can run `go vet` again and check that there are no more issues:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It should return nothing, letting you know the file has no more issues.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here’s the output after making the corrections in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, you learned how to use the `go vet` tool to detect issues
    that the compiler might miss. While this is a very basic example, `go vet` can
    detect mistakes such as passing a non-pointer to `unmarshal` functions or detecting
    unreachable code. You are encouraged to run `go vet` as part of your build process
    so that you can catch these issues before they make it into your program.
  prefs: []
  type: TYPE_NORMAL
- en: The Go race detector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go race detector was added to Go so that developers can detect race conditions.
    As we mentioned in [*Chapter 18*](B18621_18.xhtml#_idTextAnchor1862), *Concurrent
    Work*, you can use goroutines to run parts of your code concurrently. However,
    even experienced programmers might make a mistake that allows different goroutines
    to access the same resource at the same time. This is called a race condition.
    A race condition is problematic because one goroutine can edit the resource in
    the middle of another reading it, meaning the resource could be corrupted. While
    Go has made concurrency a first-class citizen in the language, the mechanisms
    for concurrent code do not prevent race conditions. Also, due to the inherent
    nature of concurrency, a race condition might stay hidden until long after your
    code has been deployed. This also means they tend to be transient, making them
    devilishly difficult to debug and fix. This is why the Go race detector was created.
  prefs: []
  type: TYPE_NORMAL
- en: This tool works by using an algorithm that detects asynchronous memory access,
    but a drawback of this is that it can only do so when the code executes. So, you
    need to run the code to be able to detect race conditions. Luckily, it has been
    integrated into the Go toolchain, so we can use it to do this for us.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 20.06 – using the Go race detector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a basic program that contains a race condition.
    You will use the Go race detector on the program to find the race condition. You
    will learn how to identify where the problem lies and then learn ways to mitigate
    the race condition. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `Exercise20.06`. Within that directory, create
    a new file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following two commands to create the Go module for this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the file to create a simple program with race conditions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, there is an array called `names` with one item in it. A goroutine
    then starts appending more names to it. At the same time, the main goroutine is
    attempting to print out all the items in the array. So, both goroutines are accessing
    the same resource at the same time, which is a race condition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the preceding code with the `race` flag activated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output, you can see a warning, informing you about the race condition.
    It tells you that the same resource was read and written in the code on lines
    `main.go:10` and `main.go:15`, which look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in both cases, it is the `names` array that is being accessed,
    so that is where the problem lies. The reason this happens is that the program
    starts to print `names` before it waits for the `finished` channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'A solution could be to wait for the `finished` channel before printing the
    items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This means that the items will have all been added to the array before you
    start to print them out. You can confirm this solution by running the program
    again with the `--race` flag activated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should run the program as normal and show no race condition warnings.
    The expected output after the corrections have been made is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final program with the race condition now fixed would look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While the program in this exercise was quite simple, as was the solution, you
    are encouraged to return to [*Chapter 18*](B18621_18.xhtml#_idTextAnchor1862),
    *Concurrent Work*, and use the `--race` flag in the activities there. This will
    provide a better working example of how the Go race detector can help you.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Go race detector is often used by professional software developers to confirm
    that their solution doesn’t contain any hidden race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: The go doc tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `go doc` tool is used to generate documentation for packages and functions
    in Go. An often neglected part of many software projects is their documentation.
    This is because it can be tedious to write and even more tedious to keep up to
    date. So, Go comes with a tool to automatically generate documentation for package
    declarations and functions in your code. You simply need to add comments to the
    start of functions and packages. Then, these will be picked up and combined with
    the function header.
  prefs: []
  type: TYPE_NORMAL
- en: This can then be shared with others to help them understand how to use your
    code. To generate the documentation for a package and its function, you can use
    the `go doc` tool. Documentation like this helps when you are working on a large
    project and other people need to make use of your code. Often, in a professional
    setting, different teams will be working on different parts of a program; each
    team will need to communicate to the other teams about what functions are available
    in a package and how to call them. To do this, they could use `go doc` to generate
    the documentation for the code they’ve written and share it with other teams.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 20.07 – implementing the go doc tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn about the `go doc` tool and how it can be
    used to generate documentation for your code. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `Exercise20.07`. Within that directory, create
    a new file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following two commands to create the Go module for this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the `main.go` file you created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This creates a simple program that contains two functions: one called `Add`,
    which adds two numbers, and one called `Multiply`, which multiplies two numbers.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following command to compile and execute the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will notice that both functions have comments above them that begin with
    the name of the function. This is a Go convention to let you know that these comments
    can be used as documentation. What this means is that you can use the `go doc`
    tool to create documentation for the code. In the same directory as your `main.go`
    file, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will generate documentation for the code and output it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.4: Expected output from go doc](img/B18621_20_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.4: Expected output from go doc'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you learned how to use the `go doc` tool to generate documentation
    on the Go package you created, as well as its functions. You can use this for
    other packages you have created and share the documentation with others if they
    would like to make use of your code. If you would like to capture this documentation,
    you can use `godoc package/path >` `output.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: The go get tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `go get` tool allows you to download and use different libraries. While
    Go comes with a wide range of packages by default, it is dwarfed by the number
    of third-party packages that are available. These provide extra functionality
    that you can use in your code to enhance it. However, for your code to make use
    of these packages, you need to have them on your computer so that the compiler
    can include them when compiling your code. To download these packages, you can
    use the `go` `get` tool.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 20.08 – implementing the go get tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn how to download a third-party package using
    `go get`. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `Exercise20.08`. Within that directory, create
    a new file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following two commands to create the go module for this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the `main.go` file you created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is a simple web server that you can start by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, the web server uses a third-party package called `mux`. In the import
    section, you will see that it has been imported from `github.com/gorilla/mux`.
    However, since we don’t have this package stored locally, an error will occur
    when we try to run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the third-party package, you can use `go get`. This will download it
    locally so that our Go code can make use of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that you have downloaded the package, you can run the web server again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, it should run without any errors:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 20.5: Expected output when running the web server](img/B18621_20_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.5: Expected output when running the web server'
  prefs: []
  type: TYPE_NORMAL
- en: 'While the web server is running, you can open `http://localhost:8888` in your
    web browser and check that it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.6: Web server output when viewed in Firefox](img/B18621_20_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.6: Web server output when viewed in Firefox'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you learned how to download third-party packages using the
    `go get` tool. This allows the use of tools and packages beyond what comes as
    a standard package in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 20.01 – using gofmt, goimport, go vet, and go get to correct a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that you are working on a project with poorly written code. The file
    contains a badly formatted file, missing imports, and a log message in the wrong
    place. You want to use the Go tools you’ve learned about in this chapter to correct
    the file and find any issues with it. In this activity, you will use `gofmt`,
    `goimport`, `go vet`, and `go get` to fix the file and find any issues within
    it. The steps for this activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `Activity20.01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Go module for your activity code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the code from the `Activity20.01/example` directory to `main.go` so that
    you can correct and properly format it and install its dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix any formatting issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix any missing imports from `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for any issues the compiler may miss by using `go vet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the third-party `gorilla/mux` package has been downloaded to your local
    computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the expected output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 20.7: Expected output when running the code](img/B18621_20_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.7: Expected output when running the code'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check that this worked by going to `http://localhost:8888` in your
    web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.8: Expected output when accessing the web server through Firefox](img/B18621_20_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 20.8: Expected output when accessing the web server through Firefox'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter20/Activity20.01](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter20/Activity20.01).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the example code to correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You’ve now seen several of the Go tools in action in one coding exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go tools are invaluable to a programmers when they’re writing code. In this
    chapter, you learned about `go build` and how to compile your code into executables.
    Then, you learned how consistent neat code is important when working on a project
    and how you can use `gofmt` to automatically neaten the code for you. This can
    be further improved with `goimports`, which can remove unnecessary imports for
    better security and automatically add imports you may have forgotten to add yourself.
  prefs: []
  type: TYPE_NORMAL
- en: After, you looked at `go vet` and how it can be used to help you find any mistakes
    that the compiler may have missed. You also learnt how to use the Go race detector
    to find race conditions hidden in your code. Then, you learned how to generate
    documentation for your code, which makes for easier collaboration when working
    on larger projects. Finally, you looked at downloading third-party packages using
    the `go get` tool, which allows you to make use of numerous Go packages that are
    available online to enhance your code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about running your Go code in the cloud,
    and considerations developers make when this occurs.
  prefs: []
  type: TYPE_NORMAL
