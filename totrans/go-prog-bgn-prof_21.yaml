- en: '21'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go in the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will show you how to take your Go application to the next level
    of readiness for deployment. It will cover the considerations you have to make
    your Go application run reliably once deployed to your server or cloud infrastructure
    by demonstrating how to add monitoring capabilities to the system through an open
    source monitoring and alerting toolkit known as **Prometheus**. The chapter will
    also discuss how to run your application using an orchestrator and all of the
    benefits you get out of the box. Lastly, the chapter will cover insights that
    **OpenTelemetry** allows, as well as best practices for containerizing your Go
    application code.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be empowered to deploy your Go application
    reliably, and with valuable insights into the system to ensure its success.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you'll require Go version 1.21 or higher. The code for this
    chapter can be found at [https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter21](https://github.com/PacktPublishing/Go-Programming-From-Beginner-to-Professional-Second-Edition-/tree/main/Chapter21).
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about the various Go tools that enable
    developers to write better code and be more productive. We covered the Go tools
    to compile and run your Go code using the `go build` and `go run` commands. We
    then looked at how to format Go code using `gofmt`. We also saw the power of working
    with the Go ecosystem through its dependencies with the `goimports` and `go get`
    command-line tools. After having functional dependencies in our code, we can see
    issues that might be present using the `Go vet` tool and the `Go race` detector.
    Lastly, with any good code comes a well-rounded project through proper documentation
    using the `Go doc` tool. The previous chapter empowered you with the tools right
    at your fingertips in the Go ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we focus on the fact that at some point in a project, your
    application development journey will lead you to the final frontier: deploying
    the application. But, before you hit the deploy button or run the final command,
    there are essential considerations to ensure your application runs reliably and
    efficiently in its destination environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Where your Go application will be deployed depends on numerous factors. This
    can be a stakeholder and leadership-led decision, based on existing infrastructure,
    or even based on the specifications of your project or customer base. No matter
    the destination, your Go code will be able to be packaged up and shipped to it.
    However, it is on you to ensure your project is ready for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will teach you about running your application in the cloud successfully
    and some of the considerations you might make before deploying it into the cloud,
    or wherever you choose to deploy it to really. We will cover topics such as monitoring,
    orchestration, tracing, and containerization, equipping you with the knowledge
    and tools to navigate the complexities of cloud infrastructure effectively.
  prefs: []
  type: TYPE_NORMAL
- en: First and foremost, we’ll discuss the importance of monitoring your application’s
    performance and health in a cloud-native environment. We’ll explore how to integrate
    monitoring systems such as Prometheus into your Go application, enabling you to
    gather vital metrics and gain insights into its ongoing behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll delve into the realm of distributed tracing and logs with OpenTracing.
    By implementing tracing and logging into your Go application, you’ll gain visibility
    into the flow of requests and responses across microservices. This will provide
    you with additional insights to make debugging issues a breeze – hopefully – and
    provide you with insights to potentially make performance optimizations in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll cover essential containerization practices for Go applications,
    including image optimization, dependency management, and security considerations.
    You’ll learn how to build robust container images for your Go application, ready
    for deployment in any environment. That will allow for a seamless transition to
    where we’ll tackle the challenge of orchestrating your application using platforms
    such as Kubernetes. Orchestrators allow for scalability, resiliency, and ease
    of management for your application at a greater scale.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be well equipped to deploy your Go application
    confidently to the cloud, armed with the knowledge and tools to ensure its reliability,
    scalability, performance, and visibility into production environments. Let’s dive
    in!
  prefs: []
  type: TYPE_NORMAL
- en: Making your app monitorable by systems such as Prometheus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monitoring is a critical aspect of maintaining the health and performance of
    any application, no matter the language. Monitoring is especially important in
    a cloud-native environment where resources are dynamic and distributed. There
    are certain nuances as to the differences between monitoring and observability
    in software engineering.
  prefs: []
  type: TYPE_NORMAL
- en: The monitoring aspects abide more by collecting data through predefined metrics
    and thresholds to detect and alert upon issues to define the overall health of
    the system, whereas observability is much more investigative and goes into a more
    comprehensive understanding of system behavior and performance to enable effective
    debugging and troubleshooting in complex environments. To focus on enabling monitoring
    capabilities and insights into the health of our application, we will focus on
    monitoring instead of observability in this book chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus is a powerful tool when it comes to enabling monitoring capabilities
    on an application. It operates on a pull-based model, where it scrapes metrics
    from instrumented applications at regular intervals. These metrics are then stored
    in a time-series database, allowing developers to query, visualize, and alert
    them in real time. As a Go developer, integrating Prometheus into an application
    enables you to gain valuable insights into its performance and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: To make your Go application monitorable with Prometheus, you need to instrument
    it with metrics that capture relevant information about its internal state and
    performance. This involves adding instrumentation code to your application’s code
    base to expose metrics endpoints that Prometheus can then scrape.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Prometheus Go client library provides a convenient way to instrument your
    Go application with metrics. It offers a range of metric types that allow you
    to capture different aspects of your application’s behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Counters**: Monotonically increasing values used to track the number of occurrences
    of an event over time. They reset to zero when the application restarts and are
    useful for measuring event frequencies, such as the number of requests or errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gauges**: Instantaneous measurements of a particular value at a specific
    point in time. They can increase or decrease and represent the current state of
    a system, such as CPU usage, memory consumption, or the number of active connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Histograms**: A means to track the distribution of values over time, allowing
    you to understand the variability and spread of data. They collect observations
    into configurable buckets and provide metrics such as percentiles, median, and
    average, which are useful for understanding response times, latencies, and request
    durations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Summaries**: Similar to histograms, summaries provide a more accurate representation
    of the data distribution, especially for high-cardinality datasets. They calculate
    quantiles and percentiles dynamically, allowing you to analyze data distribution
    with precision and granularity, making them suitable for measuring latency, duration,
    and response-time distributions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you’ve instrumented your application using the aforementioned metric types
    that are appropriate to the metrics you desire and use case, you then need to
    expose metrics endpoints for Prometheus to scrape. These endpoints typically serve
    metrics in a format compatible with the Prometheus exposition format, such as
    `/metrics`.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus uses configuration files called scrape configs to define targets
    it should scrape for metrics. You’ll need to configure Prometheus to scrape your
    application’s metrics endpoint(s) and specify the scrape interval to collect data
    at regular intervals.
  prefs: []
  type: TYPE_NORMAL
- en: With Prometheus collecting metrics from your Go application, you can now visualize
    them using tools such as Grafana and set up alerts based on predefined thresholds
    or conditions. This allows you to proactively monitor your application’s health
    and performance and take corrective action when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 21.01 – Creating an app with a /healthz endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve just walked through an overview of how monitoring works, a powerful tool
    you can utilize to capture metrics, and how you can then visualize those metrics
    and use them for the betterment of your project. We will now take a look at what
    this looks like in code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `Exercise21.01`. Within that directory, create
    a new file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the following two commands to create a `go` module for the exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the file to create a simple application we can monitor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a counter metric we will use to monitor the count of calls to the endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register the metric with Prometheus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a handler for the `/``healthz` endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a handler for viewing the metrics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define and start the server, and then close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the program, you need to open your terminal and navigate to the directory
    that you created the `main.go` file in. Then, run the `go build` tool by writing
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will create an executable called `monitored_app` that you can execute
    the binary in by running it on the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The server is now listening for requests. You can now navigate to the `/healthz`
    endpoint in your web browser, or through a `curl` command to perform the HTTP
    request. Navigate to the web browser at the endpoint, and reload the page a few
    times: `http://localhost:8080/healthz`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you return to your terminal, you will see that the counter was incremented
    with each request or, in other words, each time you refreshed the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You will see the same number of lines of that output as the number of times
    you made a request to the web server for that endpoint. Now that we’ve made a
    few requests to the server, we’ve generated some data on our monitored application.
    We can view the available Prometheus metrics at `http://localhost:8080/metrics`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go to the web browser at the `/metrics` endpoint, you will see the metric
    we created, among a bunch of other metrics that have been abbreviated with three
    dots, as there are too many to list nicely on a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see our custom metric:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We invoked our endpoint three times; therefore, we see a counter value of `3`.
  prefs: []
  type: TYPE_NORMAL
- en: The additional metrics you are seeing are provided by the Prometheus client
    library itself and are related to Go runtime metrics, including memory allocation,
    garbage collection, goroutines, and other runtime statistics. These metrics are
    automatically exposed by the Prometheus client library when you import and use
    it in your Go application.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you defined a counter metric for an endpoint on an HTTP server
    using Prometheus. By instrumenting your Go application with Prometheus and following
    best practices for monitoring, you can gain valuable insights into its behavior
    and performance in a cloud-native environment. With Prometheus, we saw how you
    can use it to be well equipped to define the monitoring capabilities of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the example by adding additional custom metrics allows teams to detect
    issues early on, effectively troubleshoot their applications, and ensure the reliability
    and scalability of Go applications in production-level environments. Prometheus
    also enables alerting upon metrics upon certain criteria, proving it to be quite
    a powerful tool when gaining insights into your application.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling deep insights through OpenTelemetry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today’s complex distributed systems landscape, understanding how our applications
    behave and perform is crucial for maintaining reliability and performance. We
    will now take a look at another useful monitoring tool readily available. **OpenTelemetry**
    is a pivotal tool for gaining profound insights into the functionality and performance
    of distributed systems. OpenTelemetry, often referred to as OTel, provides a standardized
    approach to collect and correlate data across various components of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'By incorporating OpenTelemetry into your Go applications, you can seamlessly
    capture telemetry data, including traces, metrics, and logs, to gain a holistic
    understanding of your system’s operation. Let’s take a look at the three main
    pillars OpenTelemetry encompasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tracing** allows us to track the flow of requests as they travel through
    different services and components, providing invaluable insights into latency,
    dependencies, and error propagation. For tracing, we create and propagate trace
    contexts across service boundaries in order to achieve end-to-end visibility into
    request flows. This enables us to visualize requests as they flow through the
    system, identify performance bottlenecks, diagnose errors, and optimize resource
    utilization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metrics** offer a quantitative view of our system’s health and performance,
    enabling us to monitor key indicators and identify potential bottlenecks or anomalies.
    OpenTelemetry provides a means of collecting metrics similar to providing insights
    into the health and performance of our applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logs** provide a narrative of events and actions within our applications,
    aiding in troubleshooting and debugging efforts. This also allows us to trace
    the flow of information across our distributed systems and capture logs as events
    occur internal to the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To harness the power of OpenTelemetry in your application, you must first instrument
    the application with the necessary instrumentation libraries and **software development
    kits**, or **SDKs**. This is similar to how we saw you must instrument the application
    for Prometheus in the previous section of this chapter. For OpenTelemetry, it
    is a similar process of integrating the OpenTelemetry SDKs into the code base
    and configuring instrumentation for tracing, metrics, and logging.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what some of this looks like in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 21.02 – Using OpenTelemetry for queryable logs and tracing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now understand the monitoring capabilities that OpenTelemetry allows developers.
    We will now see how it helps to make structured logs that enable developers to
    more easily query their logs later on, as well as see what tracing is like with
    OpenTelemetry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory called `Exercise21.02`. Within that directory, create
    a new Go file called `main.go`, then do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following two commands to create a `go` module for the exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to the file, including all of the imports necessary
    for our OpenTelemetry monitoring:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to initialize a trace exporter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to initialize a log exporter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to initialize a structured logger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to initialize the tracing provider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, define an HTTP handler that will handle the incoming monitored request
    and capture log information, as well as start the span for the incoming request:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Last, define a `main()` function where you will call all of the initialization
    helper functions we just defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wrap the HTTP handler with OpenTelemetry instrumentation, start the HTTP server,
    and close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the program, you need to open your terminal and navigate to the directory
    that you created the `main.go` file in. Then, run the `go build` tool by writing
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will create an executable called `monitored_app` that you can execute
    the binary in by running it on the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The server is now listening for requests. You can now navigate to the `/healthz`
    endpoint in your web browser, or through a `curl` command to perform the HTTP
    request. Navigate to the web browser at the endpoint, and reload the page a few
    times: `http://localhost:8080/healthz`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The web page will now show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you return to your terminal, you will see the structured log we defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also see the results of the tracing information exported to standard
    output, so we can see the trace in the terminal. Here, you can see part of the
    output, shortened to allow ease of visibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 21.1: OpenTelemetry tracing output – this image is meant to show the
    output and text; readability is not essential](img/B18621_21_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.1: OpenTelemetry tracing output – this image is meant to show the
    output and text; readability is not essential'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you worked with OpenTelemetry to gain valuable monitoring
    insights into the application, including structured logging and tracing information
    on requests. The logs help to provide information on what occurred, and we saw
    how you can structure the logs to include information relevant to your use case
    and project. From there, you can use different aspects of the logs to query. For
    example, our logs included the service name, HTTP method used, and endpoint invoked.
    We could easily create queries based on all service requests or all requests to
    a specific endpoint. This could provide valuable insights to enable teams to practice
    on their projects. We also saw tracing information using OpenTelemetry. This information
    is useful for timing insights and execution flow if there are sub-requests made.
    We can also visualize these results with different exporters or UI tools to more
    easily see what is going on in our request flows in more complex use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for putting your Go application in a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent years, containerization has revolutionized the way software engineers
    deploy and manage software applications. By encapsulating an application along
    with its dependencies into a lightweight, portable container, containerization
    provides numerous benefits, including consistency, scalability, and portability
    for our applications. This approach has gained widespread adoption across industries
    and is considered a standard practice for modern software development and deployment
    workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Containerization is essential to software nowadays as it ensures consistency
    by packaging the application and its dependencies into a single unit, eliminating
    the infamous and dreaded “it works on my machine” problem This consistency extends
    to different environments, including production, reducing the risk of configuration
    drift. It also allows scalability on demand, as it is efficient to add or remove
    instances of the application when it is lightweight and fast to spin up in a container.
    Lastly, containers can be run on-premises, in **cloud service providers** (**CSPs**),
    or even in hybrid environments. Therefore, it is essential to understand how to
    package up your Go application dependencies into a container to run your Go code
    to be consistent, scalable, and portable.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is a big player in the containerization ecosystem, serving as one of
    the most widely used containerization platforms. Docker provides a containerization
    engine, image management, container orchestration, and a widely integrated ecosystem.
    It provides tools, workflows, and infrastructure for creating, deploying, and
    managing containers effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few best practices to keep in mind when containerizing your Go
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Leverage Go modules for dependency management**: Go modules provide a convenient
    way to manage dependencies for your Go applications. When containerizing your
    Go application, ensure that you are using Go modules to manage dependencies effectively.
    Go modules were covered early on in the book in [*Chapter 9*](B18621_09.xhtml#_idTextAnchor1367),
    *Using Go Modules to Define* *a Project*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keep containers lightweight**: One of the fundamental principles of containerization
    is to keep containers lightweight. This means minimizing the size of your container
    images to reduce deployment times and resource usage. When building container
    images for Go applications, use multi-stage builds to compile your application
    binary and copy only the necessary files into the final image. Additionally, leverage
    Alpine-based or scratch images as base images to further reduce image size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimize Dockerfile instructions**: When writing Dockerfiles for your Go
    applications, optimize Dockerfile instructions to improve build performance and
    reduce image size. Use multi-stage builds to separate the build environment from
    the final production image, minimizing the size of the final image. Additionally,
    leverage Docker’s layer-caching mechanism by ordering your Dockerfile instructions
    from least frequently changing to most frequently changing, ensuring that only
    necessary steps are executed when rebuilding the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure your container environment**: Security should be a top priority when
    containerizing your Go applications. Follow security best practices such as using
    minimal and trusted base images, scanning container images for vulnerabilities
    using tools such as **Trivy**, and applying least privilege principles by running
    containers with non-root users whenever possible. Additionally, ensure that sensitive
    information such as credentials or API keys are not hardcoded into your container
    images but instead provided as environment variables or mounted as secrets at
    runtime. Lastly, consider leveraging Chainguard images for your Dockerfiles to
    enhance the security of container images by relying upon their enhanced security
    measures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement health checks and logging**: Implement health checks and logging
    in your Go applications to improve observability and reliability in a containerized
    environment. Define health check endpoints to allow container orchestration platforms
    such as Kubernetes to monitor the health of your application and automatically
    restart unhealthy containers. Additionally, use structured logging to provide
    valuable insights into the behavior of your application, making it easier to troubleshoot
    issues and debug problems in production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use container orchestration platforms**: We will discuss why this is important
    in the next section of this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand why it is crucial to know how to containerize our Go
    applications, let’s see what this looks like in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 21.03 – Creating a Dockerfile for a Go application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To containerize your Go application, you’ll need to create a Dockerfile, which
    is a text document that contains instructions for Docker on how to build your
    application’s image. Let’s walk through the process of creating a Dockerfile for
    a simple Go application and then see how to build and run the container. We will
    use the code from earlier on in the chapter, in the `Exercise21.01` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `Exercise21.03`. Within that directory, create
    a new file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the contents of `Exercise21.03/main.go`, `Exercise21.03/go.mod`, and `Exercise21.03/go.sum`
    into the new directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file called `Dockerfile` that contains instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start with the official Go image as the base image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure the Go compiler builds a statically linked binary, including all necessary
    libraries within the binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the working directory inside of the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy over the Go modules files and our code for the monitored application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build our Go binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start a new stage to create a minimal final image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy over the binary to our final stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expose the port we will use to interact with our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run our monitored application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have filled the contents of our `Dockerfile` file, we can build
    our Docker image by running the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can then run our Docker container using the following command, which will
    start a container based on our monitored application image and map port `8080`
    on our host machine to port 8080 of the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now access our application at the same URL we’ve been hitting: `http://localhost:8080/healthz`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We still see the same output as we did before with the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now seen how to take our Go application into a lightweight, ephemeral
    container and run it using Docker commands. Docker is a platform that enables
    us to build, ship, and run our application in a Docker container by packaging
    up our Go application dependencies into a portable container that can be deployed
    across different environments.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now expand on this idea of portability and container orchestration.
  prefs: []
  type: TYPE_NORMAL
- en: Making your app ready to work with orchestrators such as Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Kubernetes**, often abbreviated as **K8s**, has emerged as the de facto standard
    for container orchestration and management. It provides the capabilities to automate
    the deployment, scaling, and management of containerized applications. At its
    core, Kubernetes abstracts away the complexities of managing individual containers
    and offers a unified API and control plane for orchestrating containerized workloads
    across a cluster of machines. Orchestrators such as Kubernetes are what you turn
    to when you want to streamline the deployment and management of modern, cloud-native
    applications.'
  prefs: []
  type: TYPE_NORMAL
- en: In today’s dynamic and rapidly evolving software landscape, where microservices
    architectures and containerization have become mainstream, Kubernetes offers a
    scalable and resilient platform for deploying and operating these distributed
    applications. However, it is not without its complexities and learning curve.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few things to do in order for your application to work with orchestrators
    such as Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Containerize your application**: Package your Go application and its dependencies
    into a Docker container, as we saw in the previous section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deploy your containerized application**: Once you’ve built your container
    image, you need to deploy it into your Kubernetes cluster. This typically involves
    pushing your container image to a container registry (such as Docker Hub, **Google
    Container Registry** (**GCR**), or **Amazon Elastic Container Registry** (**Amazon
    ECR**), and then deploying it into your Kubernetes cluster using Kubernetes deployment
    manifests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Define Kubernetes resources**: In Kubernetes, you define the desired state
    of your application using Kubernetes resources such as Deployments, Services,
    ConfigMaps, and Secrets. You will need to create Kubernetes manifests (YAML files)
    that describe these resources and specify how Kubernetes should manage your Go
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handle application life cycle**: Kubernetes manages the life cycle of your
    application, including scaling, rolling updates, and monitoring. Ensure that your
    application is designed to work well with Kubernetes by implementing features
    such as health checks, readiness probes, graceful shutdowns, and logging/metrics
    instrumentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service discovery and load balancing**: Use Kubernetes services to expose
    your application internally within the cluster and to external clients. This allows
    other parts of your application to discover and communicate with your Go application
    and enables Kubernetes to load-balance traffic to multiple instances of your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring and logging**: Instrument your Go application for monitoring and
    logging using tools such as Prometheus, Grafana, Fluentd, OpenTelemetry, and so
    on. Emit metrics, logs, and trace information in a structured format so that Kubernetes
    can collect and analyze them. This allows you to gain visibility into the health
    and performance of your application running in Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By following these steps, you can successfully deploy and run your Go application
    using an orchestrator, such as a Kubernetes environment. It’s important to familiarize
    yourself with Kubernetes concepts and best practices to ensure that your application
    runs smoothly and efficiently in production. You should also acknowledge a much
    more complex environment and learning curve to bring yourself up to speed on working
    with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was an exciting one that expanded our understanding of where we
    are running the Go applications that we write. We learned how to run our Go code
    in the cloud, all packaged up nicely and providing us with the monitoring insights
    that we need to ensure success for our services.
  prefs: []
  type: TYPE_NORMAL
- en: We started with understanding why and how to make our Go application code instrumented
    with monitoring using Prometheus. That was a nice segue into gaining even richer
    insights into our application using OpenTelemetry. We then demonstrated how to
    containerize our application using Docker, and then looked at how to run that
    containerized application in an orchestrated environment, such as in Kubernetes.
    We’ve covered a lot of ground in this chapter and in this book in its entirety.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of the book, we have covered the basics of Go with variables
    and various type declarations. We moved into control flow and data rules with
    Go, to include some of the newest features of working with complex types such
    as using generics and interfaces. We covered good software engineering practices
    as they apply to Go through code reuse, error handling, and how to work with large-scale
    projects through Go modules and packages. We even touched on time and files and
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: The book transformed our skills to a professional level demonstrating debugging
    best practices with Go, crafting state-of-the-art CLI applications, and how to
    perform application development by connecting to databases, and working with web
    servers and clients. We tied everything up with a nice bow ending with covering
    the concurrency Go primitives, strong testing practices, and even highlighting
    the best of the Go ecosystem with the tools it offers. Lastly, we saw how to run
    our Go code in the cloud and gain insights into how our application is performing.
    This book should provide you with the tools and knowledge to transform your Go
    knowledge into a professional Go developer!
  prefs: []
  type: TYPE_NORMAL
