<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer006">
			<h1 id="_idParaDest-18" class="chapter-number"><a id="_idTextAnchor017"/>1</h1>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Project Organization</h1>
			<p>This chapter is about how you can start a new project, organize a source tree, and manage the packages you need to develop your programs. A well designed project structure is important because when other developers work on your project or try to use components from it, they can quickly and easily find what they are looking for. This chapter will first answer some of the questions you may have when you are starting a new project. Then, we will look at how you can use the Go package system, work with standard library and third-party packages, and make it easy for other developers to use <span class="No-Break">your packages.</span></p>
			<p>This chapter includes the <span class="No-Break">following recipes:</span></p>
			<ul>
				<li>Creating <span class="No-Break">a module</span></li>
				<li>Creating a <span class="No-Break">source tree</span></li>
				<li>Building and <span class="No-Break">running programs</span></li>
				<li>Importing <span class="No-Break">third-party packages</span></li>
				<li>Importing specific versions <span class="No-Break">of packages</span></li>
				<li>Using internal packages to reduce <span class="No-Break">API surface</span></li>
				<li>Using a local copy of <span class="No-Break">a module</span></li>
				<li><span class="No-Break">Workspaces</span></li>
				<li>Managing the versions of <span class="No-Break">your module</span></li>
			</ul>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Modules and packages</h1>
			<p>First, a few words<a id="_idIndexMarker000"/> about modules and packages would be helpful. A <strong class="bold">package</strong> is a cohesive unit of data types, constants, variables, and functions. You build and test packages, not individual files or modules. When you build a package, the build system collects and also builds all dependent packages. If the package name is <strong class="source-inline">main</strong>, building it will result in an executable. You can run the <strong class="source-inline">main</strong> package without producing a binary (more specifically, the Go build system first builds the package, produces the binary in a temporary location, and runs it). To use another package, you import it. Modules help with organizing multiple packages and the resolution of package references within a project. A <strong class="bold">module</strong> is <a id="_idIndexMarker001"/>simply a collection of packages. If you import a package into your program, the module containing that package will be added to <strong class="source-inline">go.mod</strong>, and a checksum of the contents of that module will be added to <strong class="source-inline">go.sum</strong>. Modules also help you to manage versions of <span class="No-Break">your programs.</span></p>
			<p>All files of a package are stored under a single directory on the filesystem. Every package has a name declared using the <strong class="source-inline">package</strong> directive, shared by all source files in it. The package name usually matches the directory name containing the files, but this is not necessarily so. For example, the <strong class="source-inline">main</strong> package is not usually under a directory named <strong class="source-inline">main/</strong>. The directory of the package determines the package’s “import path.” You import another package into your current package using the <strong class="source-inline">import &lt;importPath&gt;</strong> statement. Once you import a package, you use the names declared in that package using its package name (which is not necessarily the <span class="No-Break">directory name).</span></p>
			<p>A module name points to the location where the module contents are stored in a version control system on the Internet. At the time of writing, this is not a hard-and-fast requirement, so you can actually create module names that do not follow this convention. This should be avoided to prevent potential future incompatibilities with the build system. Your module names should be part of the import paths for the packages of those modules. In particular, module names whose first component (the part before the first <strong class="source-inline">/</strong>) does not have <strong class="source-inline">.</strong> are reserved for the <span class="No-Break">standard library.</span></p>
			<p>These concepts are illustrated in <span class="No-Break"><em class="italic">Figure 1</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer005" class="IMG---Figure">
					<img src="image/B21961_01_1.jpg" alt="Figure 1.1 – Modules and packages" width="1604" height="659"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Modules and packages</p>
			<ol>
				<li>The module<a id="_idIndexMarker002"/> name declared in <strong class="source-inline">go.mod</strong> is the repository path where the module can <span class="No-Break">be found.</span></li>
				<li>The import path in <strong class="source-inline">main.go</strong> defines where the imported package can be found. The Go build system will locate the package using this import path, and then it will locate the module containing the <a id="_idIndexMarker003"/>package by scanning the parent directories of the package path. Once the module is found, it will be downloaded to the <span class="No-Break">module cache.</span></li>
				<li>The package name defined in the imported module is the package name you use to access the symbols of that package. This can be different from the last component of the import path. In our example, the package name is <strong class="source-inline">example</strong>, but the import path for this package <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">github.com/bserdar/go-recipes-module</strong></span><span class="No-Break">.</span></li>
				<li>The <strong class="source-inline">Example</strong> function is located in the <span class="No-Break"><strong class="source-inline">example</strong></span><span class="No-Break"> package.</span></li>
				<li>The <strong class="source-inline">example</strong> package also imports another package contained in the same module. The build system will identify this package to be part of the same module and resolve the references, using the downloaded version of <span class="No-Break">the module.</span></li>
			</ol>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Technical requirements</h1>
			<p>You will need a recent version of Go on your computer to build and run the examples in this chapter. The examples in this book were tested using <strong class="bold">Go version 1.22</strong>. The code from this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Go-Recipes-for-Developers/tree/main/src/chp1"><span class="No-Break">https://github.com/PacktPublishing/Go-Recipes-for-Developers/tree/main/src/chp1</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>Creating a module</h1>
			<p>When you start<a id="_idIndexMarker004"/> working on a new project, the first thing to do is to create a module for it. A module is how Go <span class="No-Break">manages dependencies.</span></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>How to do it...</h2>
			<ol>
				<li>Create a directory to store a <span class="No-Break">new module.</span></li>
				<li>Under that directory, use <strong class="source-inline">go mod init &lt;moduleName&gt;</strong> to create the new module. The <strong class="source-inline">go.mod</strong> file marks the root directory of a module. Any package under this directory will be a part of this module unless that directory also has a <strong class="source-inline">go.mod</strong> file. Although such nested modules are supported by the build system, there is not much to be gained <span class="No-Break">from them.</span></li>
				<li>To import a package in the same module, use <strong class="source-inline">moduleName/packagePath</strong>. When <strong class="source-inline">moduleName</strong> is the same as the location of the module on the internet, there are no ambiguities about what you are <span class="No-Break">referring to.</span></li>
				<li>For the packages under a module, the root of the module is the closest parent directory containing a <strong class="source-inline">go.mod</strong> file. All references to other packages within a module will be looked up in the directory tree under the <span class="No-Break">module root.</span></li>
				<li>Start by creating a directory to store the project files. Your current directory can be anywhere on the filesystem. I have seen people use a common directory to store their work, such as <strong class="source-inline">$HOME/projects</strong> (or <strong class="source-inline">\user\myUser\projects</strong> in Windows). You may choose to use a directory structure that looks like the module name, such as <strong class="source-inline">$HOME/github.com/mycompany/mymodule</strong> (or <strong class="source-inline">\user\myUser\github.com\mycompany\mymodule</strong> in Windows). Depending on your operating system, you may find a more <span class="No-Break">suitable location.</span></li>
			</ol>
			<p class="callout-heading">Warning</p>
			<p class="callout">Do not work under the <strong class="source-inline">src/</strong> directory of your Go installation. That is the source code for the Go <span class="No-Break">standard library.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You should not have an environment variable, <strong class="source-inline">GOPATH</strong>; if you have to keep it, do not work under it. This variable was used by an older mode of operation (Go version &lt;1.13) that is now deprecated in favor of the Go <span class="No-Break">module system.</span></p>
			<p>Throughout <a id="_idIndexMarker005"/>this chapter, we will be using a simple program that displays a form in a web browser and stores the entered information in <span class="No-Break">a database.</span></p>
			<p>After creating the module directory, use <strong class="source-inline">go mod init</strong>. The following commands will create a <strong class="source-inline">webform</strong> directory under <strong class="source-inline">projects</strong> and initialize a Go <span class="No-Break">module there:</span></p>
			<pre class="source-code">
$ cd projects
$ mkdir webform
$ go mod init github.com/examplecompany/webform</pre>			<p>This will create a <strong class="source-inline">go.mod</strong> file in this directory that looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
module github.com/PacktPublishing/Go-Recipes-for-Developers/chapter1/webform
go 1.21.0</pre>			<p>Use a name that describes where your module can be found. Always use a URL structure such as the <strong class="source-inline">&lt;host&gt;.&lt;domain&gt;/location/to/module</strong> format (e.g., <strong class="source-inline">github.com/bserdar/jsonom</strong>). In particular, the first component of the module name should have a dot (<strong class="source-inline">.</strong>) (the Go build system <span class="No-Break">checks this).</span></p>
			<p>So, even though you can name the module something such as <strong class="source-inline">webform</strong> or <strong class="source-inline">mywork/webform</strong>, do <a id="_idIndexMarker006"/>not do so. However, you can use something such as <strong class="source-inline">workspace.local/webform</strong>. When in doubt, use the code <span class="No-Break">repository name.</span></p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Creating a source tree</h1>
			<p>Once<a id="_idIndexMarker007"/> you have a new module, it is time to decide how you are going to organize the <span class="No-Break">source files.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>How to do it...</h2>
			<p>There are several established conventions, depending on <span class="No-Break">the project:</span></p>
			<ul>
				<li>Use a standard layout, such <span class="No-Break">as </span><a href="https://github.com/golang-standards/project-layout"><span class="No-Break">https://github.com/golang-standards/project-layout</span></a><span class="No-Break">.</span></li>
				<li>A library with a narrow focus can put all the exported names at the module root, with implementation details optionally stored under internal packages. A module that produces a single executable with relatively few or no reusable components can also use the flat <span class="No-Break">directory structure.</span></li>
			</ul>
			<p>For a project like ours that produces an executable, the structure laid out in <a href="https://github.com/golang-standards/project-layout">https://github.com/golang-standards/project-layout</a> fits. So, let’s follow <span class="No-Break">that template:</span></p>
			<pre class="source-code">
webform/
  go.mod
  cmd/
    webform/
      main.go
  web/
    static/
  pkg/
    ...
  internal/
    ...
  build/
    ci/
    package/
  configs/</pre>			<p>Here, the <strong class="source-inline">cmd/webform</strong> directory will contain the <strong class="source-inline">main</strong> package. As you can see, this is one<a id="_idIndexMarker008"/> instance where the package name does not match the directory it is in. The Go build system will create executables using the directory name, so when you build the <strong class="source-inline">main</strong> package under <strong class="source-inline">cmd/webform</strong>, you get an executable named <strong class="source-inline">webform</strong>. If you have multiple executables built within a single module, you can accommodate them by creating a separate <strong class="source-inline">main</strong> package under a directory matching the program name, under the <span class="No-Break"><strong class="source-inline">cmd/</strong></span><span class="No-Break"> directory.</span></p>
			<p>The <strong class="source-inline">pkg/</strong> directory will contain the exported packages of the program. These are packages that can be imported and reused in <span class="No-Break">other projects.</span></p>
			<p>If you have packages that are not usable outside this project, you should put them under the <strong class="source-inline">internal/</strong> directory. The Go build system recognizes this directory and does not allow you to import packages under <strong class="source-inline">internal/</strong> from other packages that are outside the directory containing the <strong class="source-inline">internal/</strong> directory. With this setup, all the packages of our <strong class="source-inline">webform</strong> program will have access to the packages under <strong class="source-inline">internal/</strong>, but it will be inaccessible to packages importing <span class="No-Break">this module.</span></p>
			<p>The <strong class="source-inline">web/</strong> directory will contain any web-related assets. In this example, we will have a <strong class="source-inline">web/static</strong> directory containing static web pages. You can also add <strong class="source-inline">web/templates</strong> to store server-side templates if you <span class="No-Break">have any.</span></p>
			<p>The <strong class="source-inline">build/package</strong> directory should have packaging scripts and configuration for cloud, container, packaging systems (<strong class="source-inline">dep</strong>, <strong class="source-inline">rpm</strong>, <span class="No-Break"><strong class="source-inline">pkg</strong></span><span class="No-Break">, etc.).</span></p>
			<p>The <strong class="source-inline">build/ci</strong> directory should have continuous integration tool scripts and configurations. If the continuous integration tool you are using requires its files to be in a certain directory other than this, you can create symbolic links, or simply put those files where the tool needs them instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">/build/ci</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">configs/</strong> directory should contain the configuration file templates and <span class="No-Break">default configurations.</span></p>
			<p>You can also<a id="_idIndexMarker009"/> see projects that have the <strong class="source-inline">main</strong> package under the module root, eliminating the <strong class="source-inline">cmd/</strong> directory. This is a common layout when the module has only <span class="No-Break">one executable:</span></p>
			<pre class="source-code">
webform/
  go.mod
  go.sum
  main.go
  internal/
    ...
  pkg/
    ...</pre>			<p>Then there are modules without any <strong class="source-inline">main</strong> package. These are usually libraries that you can import into your projects. For example, <a href="https://github.com/google/uuid">https://github.com/google/uuid</a> contains the popular UUID implementation using a flat <span class="No-Break">directory structure.</span></p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Building and running programs</h1>
			<p>Now that <a id="_idIndexMarker010"/>you have a module and a source tree with some Go files, you can build or run <span class="No-Break">your program.</span></p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>How to do it...</h2>
			<ul>
				<li>Use <strong class="source-inline">go build</strong> to build the <span class="No-Break">current package</span></li>
				<li>Use <strong class="source-inline">go build ./path/to/package</strong> to build the package in the <span class="No-Break">given directory</span></li>
				<li>Use <strong class="source-inline">go build &lt;moduleName&gt;</strong> to build <span class="No-Break">a module</span></li>
				<li>Use <strong class="source-inline">go run</strong> to run the current <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> package</span></li>
				<li>Use <strong class="source-inline">go run ./path/to/main/package</strong> to build and run the <strong class="source-inline">main</strong> package in the <span class="No-Break">given directory</span></li>
				<li>Use <strong class="source-inline">go run &lt;moduleName/mainpkg&gt;</strong> to build and run the module’s main under the <span class="No-Break">given directory</span></li>
			</ul>
			<p>Let’s<a id="_idIndexMarker011"/> write the <strong class="source-inline">main</strong> function<a id="_idIndexMarker012"/> that starts an HTTP server. The following snippet <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">cmd/webform/main.go</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
package main
import (
    "net/http"
)
func main() {
    server := http.Server{
        Addr:    ":8181",
        Handler: http.FileServer(http.Dir("web/static")),
    }
    server.ListenAndServe()
}</pre>			<p>Currently, <strong class="source-inline">main</strong> only imports the standard library’s <strong class="source-inline">net/http</strong> package. It starts a server that serves the files under the <strong class="source-inline">web/static</strong> directory. Note that for this to work, you have to run the program from the <span class="No-Break">module root:</span></p>
			<pre class="source-code">
$ go run ./cmd/webform</pre>			<p>Always run the <strong class="source-inline">main</strong> package; avoid <strong class="source-inline">go run main.go</strong>. This will run <strong class="source-inline">main.go</strong>, excluding any other files in the main package. It will fail if you have other <strong class="source-inline">.go</strong> files that contain helper functions in the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> package.</span></p>
			<p>If you run this program from another directory, it will fail to find the <strong class="source-inline">web/static</strong> directory; because it <a id="_idIndexMarker013"/>is a <strong class="bold">relative path</strong>, it is resolved relative to the <span class="No-Break">current directory.</span></p>
			<p>When you <a id="_idIndexMarker014"/>run a program via <strong class="source-inline">go run</strong>, the program executable is placed in a temporary directory. To build the executable, use <span class="No-Break">the following:</span></p>
			<pre class="source-code">
$ go build ./cmd/webform</pre>			<p>This will create a binary in the current directory. The name of the binary will be determined by the last segment of the main package – in this case, <strong class="source-inline">webform</strong>. To build a binary with a different name, use <span class="No-Break">the following:</span></p>
			<pre class="source-code">
$ go build -o wform ./cmd/webform</pre>			<p>This will build a binary <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">wform</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Importing third-party packages</h1>
			<p>Most projects will <a id="_idIndexMarker015"/>depend on third-party libraries that must be imported into them. The Go module system manages <span class="No-Break">these dependencies.</span></p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>How to do it...</h2>
			<ol>
				<li>Find the import path of the package you need to use in <span class="No-Break">your project.</span></li>
				<li>Add the necessary imports to the source files you use in the <span class="No-Break">external package.</span></li>
				<li>Use the <strong class="source-inline">go get</strong> or <strong class="source-inline">go mod tidy</strong> command to add the module to <strong class="source-inline">go.mod</strong> and <strong class="source-inline">go.sum</strong>. If the module was not downloaded before, this step will also download <span class="No-Break">the module.</span></li>
			</ol>
			<p class="callout-heading">Tip</p>
			<p class="callout">You can use <a href="https://pkg.go.dev">https://pkg.go.dev</a> to discover packages. It is also the place to publish documentation for the Go projects <span class="No-Break">you publish.</span></p>
			<p>Let’s add a database to our program from the previous section so that we can store the data submitted by the web form. For this exercise, we will use the <span class="No-Break"><strong class="source-inline">SQLite</strong></span><span class="No-Break"> database.</span></p>
			<p>Change <a id="_idIndexMarker016"/>the <strong class="source-inline">cmd/webform/main.go</strong> file to import the database package and add the necessary database <span class="No-Break">initialization code:</span></p>
			<pre class="source-code">
package main
import (
    "net/http"
    "database/sql"
    _ "modernc.org/sqlite"
    "github.com/PacktPublishing/Go-Recipes-for-Developers/src/chp1/
    webform/pkg/commentdb"
)
func main() {
    db, err := sql.Open("sqlite", "webform.db")
    if err != nil {
        panic(err)
    }
    commentdb.InitDB(db)
    server := http.Server{
        Addr:    ":8181",
        Handler: http.FileServer(http.Dir("web/static")),
    }
    server.ListenAndServe()
}</pre>			<p>The <strong class="source-inline">_ "modernc.org/sqlite"</strong> line imports the <strong class="source-inline">SQLite</strong> driver into the project. The underscore is the <strong class="bold">blank</strong> identifier, meaning that the <strong class="source-inline">sqlite</strong> package is not directly used by this file and is only included for its side effects. Without the blank identifier, the compiler would complain that the import was not used. In this case, the <strong class="source-inline">modernc.org/sqlite</strong> package is a database driver, and when you import it, its <strong class="source-inline">init()</strong> functions will register the required driver with the <span class="No-Break">standard library.</span></p>
			<p>The next <a id="_idIndexMarker017"/>declaration imports the <strong class="source-inline">commentdb</strong> package from our module. Note that the complete module name is used to import the package. The build system will recognize the prefix of this import declaration as the current module name, and it will translate it to a local filesystem reference, which, in this case, <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">webform/pkg/commentdb</strong></span><span class="No-Break">.</span></p>
			<p>On the <strong class="source-inline">db, err := sql.Open("sqlite", "webform.db")</strong> line, we use the <strong class="source-inline">database/sql</strong> package function, <strong class="source-inline">Open</strong>, to start a <strong class="source-inline">SQLite</strong> database instance. <strong class="source-inline">sqlite</strong> names the database driver, which was registered by the imported  <span class="No-Break"><strong class="source-inline">_ "modernc.org/sqlite"</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">commentdb.InitDB(db)</strong> statement will call a function from the <strong class="source-inline">commentdb</strong> <span class="No-Break">package .</span></p>
			<p>Now, let’s see what <strong class="source-inline">commentdb.InitDB</strong> looks like. This is the <span class="No-Break"><strong class="source-inline">webform/pkg/commentdb/initdb.go</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
package commentdb
import (
    "context"
    "database/sql"
)
const createStmt=`create table if not exists comments (
email TEXT,
comment TEXT)`
func InitDB(conn *sql.DB) {
    _, err := conn.ExecContext(context.Background(), createStmt)
    if err != nil {
        panic(err)
    }
}</pre>			<p>As you can see, this function creates the database tables if they have not been <span class="No-Break">created yet.</span></p>
			<p>Note the<a id="_idIndexMarker018"/> capitalization of <strong class="source-inline">InitDB</strong>. If the first letter of a symbol name declared in a package is a capital letter, that symbol is accessible from other packages (i.e., it is <em class="italic">exported</em>). If not, the symbol can only be used within the package it is declared (i.e., it is <em class="italic">not exported</em>). The <strong class="source-inline">createStmt</strong> constant  is not exported and will be invisible to <span class="No-Break">other packages.</span></p>
			<p>Let’s build <span class="No-Break">the program:</span></p>
			<pre class="source-code">
$ go build ./cmd/webform
  cmd/webform/main.go:7:2: no required module provides package modernc.org/sqlite; to add it:
      go get modernc.org/sqlite</pre>			<p>You can run <strong class="source-inline">go get modernc.org/sqlite</strong> to add a module to your project. Alternatively, you can run <span class="No-Break">the following:</span></p>
			<pre class="source-code">
$ go get</pre>			<p>That will get all the missing modules. Alternatively, you can run <span class="No-Break">the following:</span></p>
			<pre class="source-code">
$ go mod tidy</pre>			<p><strong class="source-inline">go mod tidy</strong> will download all missing packages, update <strong class="source-inline">go.mod</strong> and <strong class="source-inline">go.sum</strong> with updated dependencies, and remove references to any unused modules. <strong class="source-inline">go get</strong> will only download <span class="No-Break">missing modules.</span></p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Importing specific versions of packages</h1>
			<p>Sometimes, you<a id="_idIndexMarker019"/> need a specific version of a third-party package because of API incompatibilities or a particular behavior you <span class="No-Break">depend on.</span></p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>How to do it...</h2>
			<ul>
				<li>To get a specific version of a package, specify the <span class="No-Break">version label:</span><pre class="source-code">
$ go get modernc.org/sqlite@v1.26.0</pre></li>				<li>To get the latest release of a specific major version of a package, <span class="No-Break">use this:</span><pre class="source-code">
$ go get gopkg.in/yaml.v3</pre><p class="list-inset">Alternatively, <span class="No-Break">use this:</span></p><pre class="source-code">$ go get github.com/ory/dockertest/v3</pre></li>				<li>To import the latest available version, <span class="No-Break">use this:</span><pre class="source-code">
$ go get modernc.org/sqlite</pre></li>				<li>You can also specify a different branch. The following will get a module from the <strong class="source-inline">devel</strong> branch, if there <span class="No-Break">is one:</span><pre class="source-code">
$ go get modernc.org/sqlite@devel</pre></li>				<li>Alternatively, you can get a <span class="No-Break">specific commit:</span><pre class="source-code">
$ go get modernc.org/sqlite@a8c3eea199bc8fdc39391d5d261eaa3577566050</pre></li>			</ul>
			<p>As you can see, you can get a specific revision of a module using the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">revision</strong></span><span class="No-Break"> convention:</span></p>
			<pre class="source-code">
$ go get modernc.org/sqlite@v1.26.0</pre>			<p>The revision part of the URL is evaluated by the version control system, which, in this case, is <strong class="source-inline">git</strong>, so any valid <strong class="source-inline">git</strong> revision syntax can <span class="No-Break">be used.</span></p>
			<p class="callout-heading">Tip:</p>
			<p class="callout">You can find which revision control systems are supported by checking out the <strong class="source-inline">src/cmd/go/alldocs.go</strong> file under your <span class="No-Break">Go installation.</span></p>
			<p>That also <a id="_idIndexMarker020"/>means you can <span class="No-Break">use branches:</span></p>
			<pre class="source-code">
$ go get modernc.org/sqlite@master</pre>			<p class="callout-heading">Tip</p>
			<p class="callout">The <a href="https://gopkg.in">https://gopkg.in</a> service translates version numbers to URLs compatible with the Go build system. Refer to the instructions on that website on how to <span class="No-Break">use it.</span></p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Working with the module cache</h1>
			<p>The <a id="_idIndexMarker021"/>module cache is a directory where the Go build system stores downloaded module files. This section describes how to work with the <span class="No-Break">module cache.</span></p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>How to do it...</h2>
			<p>The module cache is, by default, under <strong class="source-inline">$GOPATH/pkg/mod</strong>, which is <strong class="source-inline">$HOME/go/pkg/mod</strong> when <strong class="source-inline">GOPATH</strong> is <span class="No-Break">not set:</span></p>
			<ul>
				<li>By default, the Go build system creates read-only files under the module cache to prevent <span class="No-Break">accidental modifications.</span></li>
				<li>To verify that the module cache is not modified and reflects the original versions of modules, <span class="No-Break">use this:</span><pre class="source-code">
go mod verify</pre></li>				<li>To clean up the module cache, <span class="No-Break">use this:</span><pre class="source-code">
go clean -modcache</pre></li>			</ul>
			<p>The authoritative source for information about the module cache is the Go Modules <span class="No-Break">Reference (</span><a href="https://go.dev/ref/mod"><span class="No-Break">https://go.dev/ref/mod</span></a><span class="No-Break">)</span></p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Using internal packages to reduce an API surface</h1>
			<p>Not <a id="_idIndexMarker022"/>every piece of code is reusable. Having a smaller API surface makes it easier for others to adapt and use your code. So, you should not export APIs that are specific to <span class="No-Break">your program.</span></p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>How to do it...</h2>
			<p>Create <strong class="source-inline">internal</strong> packages to hide implementation details from other packages. Anything under an <strong class="source-inline">internal</strong> package can only be imported from the packages under the package containing that <strong class="source-inline">internal</strong> package – that is, anything under <strong class="source-inline">myproject/internal</strong> can only be imported from the packages <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">myproject</strong></span><span class="No-Break">.</span></p>
			<p>In our example, we placed the database access code into a package where it can be accessed by other programs. However, it does not make sense to expose the HTTP routes to others, as they are specific to this program. So, we will put them under the <span class="No-Break"><strong class="source-inline">webform/internal</strong></span><span class="No-Break"> package.</span></p>
			<p>This is the <span class="No-Break"><strong class="source-inline">internal/routes/routes.go</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
package routes
import (
    "database/sql"
    "github.com/gorilla/mux"
    "net/http"
)
func Build(router *mux.Router, conn *sql.DB) {
    router.Path("/form").
        Methods("GET").HandlerFunc(func(w http.ResponseWriter, r 
        *http.Request) {
        http.ServeFile(w, r, "web/static/form.html")
    })
    router.Path("/form").
        Methods("POST").HandlerFunc(func(w http.ResponseWriter, r 
        *http.Request) {
        handlePost(conn, w, r)
    })
}
func handlePost(conn *sql.DB, w http.ResponseWriter, r *http.Request) {
    email := r.PostFormValue("email")
    comment := r.PostFormValue("comment")
    _, err := conn.ExecContext(r.Context(), "insert into comments 
    (email,comment) values (?,?)",
    email, comment)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    http.Redirect(w, r, "/form", http.StatusFound)
}</pre>			<p>Then, we<a id="_idIndexMarker023"/> change the <strong class="source-inline">main.go</strong> file to use the <span class="No-Break">internal package:</span></p>
			<pre class="source-code">
package main
import (
    "database/sql"
    "net/http"
    "github.com/gorilla/mux"
    _ "modernc.org/sqlite"
    "github.com/PacktPublishing/Go-Recipes-for-Developers/src/chp1/
    webform/internal/routes"
    "github.com/PacktPublishing/Go-Recipes-for-Developers/src/chp1/
    webform/pkg/commentdb"
)
func main() {
    db, err := sql.Open("sqlite", "webform.db")
    if err != nil {
        panic(err)
    }
    commentdb.InitDB(db)
    r := mux.NewRouter()
    routes.Build(r, db)
    server := http.Server{
        Addr:    ":8181",
        Handler: r,
    }
    server.ListenAndServe()
}</pre>			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Using a local copy of a module</h1>
			<p>Sometimes, you <a id="_idIndexMarker024"/>will work on multiple modules, or you download a module from a repository, make some changes to it, and then want to use the changed version instead of the version available on <span class="No-Break">the repository.</span></p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>How to do it...</h2>
			<p>Use the <strong class="source-inline">replace</strong> directive in <strong class="source-inline">go.mod</strong> to point to the local directory containing <span class="No-Break">a module.</span></p>
			<p>Let’s return to our example – suppose you want to make some changes to the <span class="No-Break"><strong class="source-inline">sqlite</strong></span><span class="No-Break"> package:</span></p>
			<ol>
				<li><span class="No-Break">Clone it:</span><pre class="source-code">
$ ls
  webform
$ git clone git@gitlab.com:cznic/sqlite.git
$ ls
  sqlite
  webform</pre></li>				<li>Modify the <strong class="source-inline">go.mod</strong> file under your project to point to the local copy of the module. <strong class="source-inline">go.mod</strong> becomes <span class="No-Break">the following:</span><pre class="source-code">
module github.com/PacktPublishing/Go-Recipes-for-Developers/chapter1/webform
go 1.22.1
replace modernc.org/sqlite =&gt; ../sqlite
require (
    github.com/gorilla/mux v1.8.1
    modernc.org/sqlite v1.27.0
)
...</pre></li>				<li>You <a id="_idIndexMarker025"/>can now make changes in the <strong class="source-inline">sqlite</strong> module on your system, and those changes will be built into <span class="No-Break">your application.</span></li>
			</ol>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Working on multiple modules – workspaces</h1>
			<p>Sometimes you need to work with multiple interdependent modules. A convenient way to do this is by defining a workspace. A<a id="_idIndexMarker026"/> workspace is simply a set of modules. If one of the modules within a workspace refers to a package in another module in the same workspace, it is resolved locally instead of that module being downloaded over <span class="No-Break">the network.</span></p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>How to do it...</h2>
			<ol>
				<li>To <a id="_idIndexMarker027"/>create a workspace, you have to have a parent directory containing all your <span class="No-Break">work modules:</span><pre class="source-code">
$ cd ~/projects
$ mkdir ws
$ cd ws</pre></li>				<li>Then, start a workspace <span class="No-Break">using this:</span><pre class="source-code">
$ go work init</pre><p class="list-inset">This will create a <strong class="source-inline">go.work</strong> file in <span class="No-Break">this directory.</span></p></li>				<li>Place the module you are working on into <span class="No-Break">this directory.</span><p class="list-inset">Let’s <a id="_idIndexMarker028"/>demonstrate this using our example. Let’s say we have the following <span class="No-Break">directory structure:</span></p><pre class="source-code">
$HOME/
  projects/
    ws/
       go.work
       webform
       sqlite</pre><p class="list-inset">Now, we want to add the two modules, <strong class="source-inline">webform</strong> and <strong class="source-inline">sqlite</strong>, to the workspace. To do that, <span class="No-Break">use this:</span></p><pre class="source-code">$ go work use ./webform
$ go work use ./sqlite</pre><p class="list-inset">These commands will add the two modules to your workspace. Any <strong class="source-inline">sqlite</strong> reference from the <strong class="source-inline">webform</strong> module will now be resolved to use the local copy of <span class="No-Break">the module.</span></p></li>			</ol>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Managing the versions of your module</h1>
			<p>Go <a id="_idIndexMarker029"/>tooling uses the semantic versioning system. This means that the version numbers are of the <strong class="source-inline">X.Y.z</strong> form, broken down <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">X</strong> is incremented for major releases that are not necessarily <span class="No-Break">backward compatible.</span></li>
				<li><strong class="source-inline">Y</strong> is incremented for minor releases that are incremental <span class="No-Break">but backward-compatible</span></li>
				<li><strong class="source-inline">z</strong> is incremented for <span class="No-Break">backward-compatible patches</span></li>
			</ul>
			<p>You can learn more<a id="_idIndexMarker030"/> about semantic versioning <span class="No-Break">at </span><a href="https://semver.org"><span class="No-Break">https://semver.org</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>How to do it...</h2>
			<ul>
				<li>To publish a patch or minor version, tag the branch containing your changes with the new <span class="No-Break">version number:</span><pre class="source-code">
$ git tag v1.0.0
$ git push origin v1.0.0</pre></li>				<li>If you want<a id="_idIndexMarker031"/> to publish a new release that has an incompatible API with the previous releases, you should increment the major versions of that module. To release a new major version of your module, use a <span class="No-Break">new branch:</span><pre class="source-code">
$ git checkout -b v2</pre><p class="list-inset">Then, change your module name in <strong class="source-inline">go.mod</strong> to end with <strong class="source-inline">/v2</strong>, and update all references in the source tree to use the <strong class="source-inline">/v2</strong> version of <span class="No-Break">the module.</span></p></li>			</ul>
			<p>For example, let’s say you released the first version of the <strong class="source-inline">webform</strong> module, <strong class="source-inline">v1.0.0</strong>. Then, you decided you would like to add new API endpoints. This would not be a breaking change, so you simply increment the minor version number – <strong class="source-inline">v1.1.0</strong>. But then it turns out some of the APIs you added were causing problems, so you removed them. Now, that is a breaking change, so you should publish <strong class="source-inline">v2.0.0</strong> with it. How can you <span class="No-Break">do that?</span></p>
			<p>The answer is, you use a new branch in the version control system. Create the <span class="No-Break"><strong class="source-inline">v2</strong></span><span class="No-Break"> branch:</span></p>
			<pre class="source-code">
$ git checkout -b v2</pre>			<p>Then, change <strong class="source-inline">go.mod</strong> to reflect the <span class="No-Break">new version:</span></p>
			<pre class="source-code">
module github.com/PacktPublishing/Go-Recipes-for-Developers/chapter1/webform/v2
go 1.22.1
require (
  ...
)</pre>			<p>If there are multiple packages in the module, you have to update the source tree so that any references<a id="_idIndexMarker032"/> to packages within that module also use the <span class="No-Break"><strong class="source-inline">v2</strong></span><span class="No-Break"> version.</span></p>
			<p>Commit and push the <span class="No-Break">new branch:</span></p>
			<pre class="source-code">
$ git add go.mod
$ git commit -m "New version"
$ git push origin v2</pre>			<p>To use the new version, you now have to import the <strong class="source-inline">v2</strong> version of <span class="No-Break">the packages:</span></p>
			<pre class="source-code">
import "github.com/PacktPublishing/Go-Recipes-for-Developers/chapter1/webform/v2/pkg/commentdb"</pre>			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>Summary and further reading</h1>
			<p>This chapter focused on the concepts and mechanics of setting up and managing Go projects. It is by no means an exhaustive reference, but the recipes presented here should give you the basics of using the Go build <span class="No-Break">system effectively.</span></p>
			<p>The definitive guide for Go modules is the Go Modules <span class="No-Break">Reference (</span><a href="https://go.dev/ref/mod"><span class="No-Break">https://go.dev/ref/mod</span></a><span class="No-Break">).</span></p>
			<p>Check out the <em class="italic">Managing dependencies</em> link (<a href="https://go.dev/doc/modules/managing-dependencies">https://go.dev/doc/modules/managing-dependencies</a>) for a detailed discussion on <span class="No-Break">dependency management.</span></p>
			<p>In the next chapter, we will start working with <span class="No-Break">textual data.</span></p>
		</div>
	</div></div></body></html>