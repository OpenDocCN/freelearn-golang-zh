<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer008">
			<h1 id="_idParaDest-43" class="chapter-number"><a id="_idTextAnchor042"/>2</h1>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Working with Strings</h1>
			<p>String is one of the fundamental data types <span class="No-Break">in Go.</span></p>
			<p>Go uses immutable UTF-8-encoded strings. This might be confusing for a new developer; after all, <span class="No-Break">this works:</span></p>
			<pre class="source-code">
x:="Hello"
x+=" World"
fmt.Println(x)
// Prints Hello World</pre>			<p>Didn’t we just change <strong class="source-inline">x</strong>? Yes, we did. What is immutable here are the <strong class="source-inline">"Hello" </strong>and <strong class="source-inline">" World"</strong> strings. So, the string itself is immutable, but the string variable, <strong class="source-inline">x</strong>, is mutable. To modify string variables, you create slices of bytes or runes (which are mutable), work with them, and then convert them back to <span class="No-Break">a string.</span></p>
			<p>UTF-8 is the most common encoding used for web and internet technologies. This means that any time you deal with text in a Go program, you deal with UTF-8 strings. If you have to process data in a different encoding, you first translate it to UTF-8, process it, and encode it back to its <span class="No-Break">original encoding.</span></p>
			<p>UTF-8 is a variable-length encoding that uses one to four bytes for each codepoint. Most codepoints represent a character, but there are some that represent other information, such as formatting. This may cause some surprises. For instance, the length of a string (i.e., the number of bytes it occupies) is different from the number of characters. To find the number of characters in a string requires you to count them sequentially. When you slice a string, you have to be careful about <span class="No-Break">codepoint boundaries.</span></p>
			<p>Go uses the <strong class="source-inline">rune</strong> type to denote codepoints. So, a string can be seen as a sequence of bytes as well as a sequence of runes. This is illustrated in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.1</em>. Here, <strong class="source-inline">x</strong> is a string variable that has a pointer to the immutable string, which is a sequence of bytes and can also be seen as a sequence of runes. Even though UTF-8 is a variable-length encoding, <strong class="source-inline">rune</strong> is a fixed-length 32-bit type (<strong class="source-inline">uint32</strong>). Smaller codepoints, like the following character, <strong class="source-inline">H</strong>, is a 32-bit decimal, 72, whereas the byte, <strong class="source-inline">H</strong>, is an <span class="No-Break">8-bit value.</span></p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B21961_02_1.jpg" alt="Figure 2.1 – A string, byte, and rune" width="1641" height="361"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – A string, byte, and rune</p>
			<p>In this chapter, we will look at some common operations involving strings and text. The recipes included in this chapter are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break">Creating strings</span></li>
				<li><span class="No-Break">Formatting strings</span></li>
				<li><span class="No-Break">Combining strings</span></li>
				<li>Uppercase, lowercase, and title <span class="No-Break">case comparisons</span></li>
				<li>Dealing with <span class="No-Break">internationalized strings</span></li>
				<li>Working <span class="No-Break">with encodings</span></li>
				<li>Iterating bytes and runes <span class="No-Break">of strings</span></li>
				<li><span class="No-Break">Splitting</span></li>
				<li><span class="No-Break">Regular expressions</span></li>
				<li>Reading strings line by line or word <span class="No-Break">by word</span></li>
				<li><span class="No-Break">Trimming</span></li>
				<li><span class="No-Break">Templates</span></li>
			</ul>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor044"/>Creating strings</h1>
			<p>In this <a id="_idIndexMarker033"/>recipe, we will look at how to create strings in <span class="No-Break">a program.</span></p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>How to do it...</h2>
			<ul>
				<li>Use a string literal. There are two types of string literals <span class="No-Break">in Go:</span><ul><li>Use interpreted string literals, between the <span class="No-Break">double quotations:</span><pre class="source-code">
x := "Hello world"</pre></li><li> With interpreted string literals, you must escape <span class="No-Break">certain characters:</span><pre class="source-code">x:="This is how you can include a \" in your string literal"
y:="You can also use a newline \n, tab \t"</pre></li><li>You can include Unicode codepoints or hexadecimal bytes, escaped <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">'\'</strong></span><span class="No-Break">:</span><pre class="source-code">w:="\u65e5本\U00008a9e"
x:="\xff"</pre></li></ul></li>			</ul>
			<p>You cannot have newlines or an unescaped double-quote in an <span class="No-Break">interpreted string:</span></p>
			<ul>
				<li>Use raw string literals, using backticks. A raw string literal can include any characters (including newlines) except a backtick. There is no way to escape backticks in a <span class="No-Break">raw literal.</span><pre class="source-code">
x:=`This is a
multiline raw string literal.
Backslash will print as backslash \`</pre></li>			</ul>
			<p>If you need to include a backtick in your raw string literal, <span class="No-Break">do this:</span></p>
			<pre class="source-code">
x:=`This is a raw string literal with `+"`"+` in it`</pre>			<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Formatting strings</h1>
			<p>The Go <a id="_idIndexMarker034"/>standard library offers multiple ways to substitute values in a text template. Here, we will discuss the text formatting utilities in the <strong class="source-inline">fmt</strong> package. They offer a simple and convenient way to substitute values in a <span class="No-Break">text template.</span></p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>How to do it...</h2>
			<ul>
				<li>Use the <strong class="source-inline">fmt.Print</strong> family of functions to <span class="No-Break">format values</span></li>
				<li><strong class="source-inline">fmt.Print</strong> will print a value using its <span class="No-Break">default formatting</span></li>
				<li>A string value will be printed <span class="No-Break">as is</span></li>
				<li>A numeric value will be first converted to a string as an integer, a decimal number, or by using scientific notation for <span class="No-Break">large exponents</span></li>
				<li>A Boolean value will be printed as <strong class="source-inline">true</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">false</strong></span></li>
				<li>Structured values will be printed as a list <span class="No-Break">of fields</span></li>
			</ul>
			<p>If a <strong class="source-inline">Print</strong> function ends with <strong class="source-inline">ln</strong> (such as <strong class="source-inline">fmt.Println</strong>), a new line will be output after <span class="No-Break">the string.</span></p>
			<p>If a <strong class="source-inline">Print</strong> function ends with <strong class="source-inline">f</strong>, the function will accept a format argument, which will be used as the template into which it will <span class="No-Break">substitute values.</span></p>
			<p><strong class="source-inline">fmt.Sprintf</strong> will format a string and <span class="No-Break">return it.</span></p>
			<p><strong class="source-inline">fmt.Fprintf</strong> will format a string and write it to <strong class="source-inline">io.Writer</strong>, which can be a file, network connection, and <span class="No-Break">so on.</span></p>
			<p><strong class="source-inline">fmt.Printf</strong> will format a string and write it to <span class="No-Break">standard output.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>How it works...</h2>
			<p>All these functions use the <strong class="source-inline">%[options]&lt;verb&gt;</strong> format to consume an argument from the argument list. To produce a <strong class="source-inline">%</strong> character in the output, <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">%%</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func main() {
     fmt.Printf("Print integers using %%d: %d|\n", 10)
    // Print integers using %d: 10|
     fmt.Printf("You can set the width of the printed number, left 
     aligned: %5d|\n", 10)
    // You can set the width of the printed number, left 
    // aligned:    10|
     fmt.Printf("You can make numbers right-aligned with a given 
     width: %-5d|\n", 10)
    // You can make numbers right-aligned with a given width: 10   |
     fmt.Printf("The width can be filled with 0s: %05d|\n", 10)
    // The width can be filled with 0s: 00010|
     fmt.Printf("You can use multiple arguments: %d %s %v\n", 10, 
     "yes", true)
    // You can use multiple arguments: 10 yes true
     fmt.Printf("You can refer to the same argument multiple times : 
     %d %s %[2]s  %v\n", 10, "yes", true)
    // You can refer to the same argument multiple times : 10 yes 
    // yes  true
     fmt.Printf("But if you use an index n, the next argument will be 
     selected from n+1 : %d %s %[2]s %[1]v  %v\n", 10, "yes", true)
    // But if you use an index n, the next argument will be selected 
    // from n+1 : 10 yes yes 10  yes
     fmt.Printf("Use %%v to use the default format for the type: %v %v 
     %v\n", 10, "yes", true)
    // Use %v to use the default format for the type: 10 yes true
     fmt.Printf("For floating point, you can specify precision: 
     %5.2f\n", 12.345657)
    // For floating point, you can specify precision: 12.35
     fmt.Printf("For floating point, you can specify precision: 
     %5.2f\n", 12.0)
    // For floating point, you can specify precision: 12.00
    type S struct {
         IntValue    int
         StringValue string
    }
    s := S{
         IntValue:    1,
         StringValue: `foo "bar"`,
    }
    // Print the field values of a structure, in the order they are 
    // declared
    fmt.Printf("%v\n", s)
    // {1 foo "bar"}
    // Print the field names and values of a structure
    fmt.Printf("%+v\n", s)
    //{IntValue:1 StringValue:foo "bar"}
}</pre>			<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/>Combining strings</h1>
			<p>The Go standard <a id="_idIndexMarker035"/>library offers multiple ways to build strings from components. The best way depends on what type of strings you are dealing with, and how long they are. This section shows several ways that strings can <span class="No-Break">be built.</span></p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>How to do it...</h2>
			<ul>
				<li>To combine a few fixed numbers of strings, or to add runes to another string, use the <strong class="source-inline">+</strong> or <strong class="source-inline">+=</strong> operators <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">string.Builder</strong></span></li>
				<li>To build a string algorithmically, <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">strings.Builder</strong></span></li>
				<li>To combine a slice of strings, <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">strings.Join</strong></span></li>
				<li>To combine parts of URL paths, <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">path.Join</strong></span></li>
				<li>To build filesystem paths from path segments, <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">filepath.Join</strong></span></li>
			</ul>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>How it works...</h2>
			<p>To build constant values, or for simple concatenations, use the <strong class="source-inline">+</strong> or <strong class="source-inline">+=</strong> <span class="No-Break">operators:</span></p>
			<pre class="source-code">
var TwoLines = "This is the first line \n"+
"This is the second line"
func ThreeLines(newLine string) string {
   return TwoLines+"\n"+newLine
}</pre>			<p>You can <a id="_idIndexMarker036"/>add runes to a string the <span class="No-Break">same way:</span></p>
			<pre class="source-code">
func AddNewLine(line string) string {
  return line+string('\n')
}</pre>			<p class="callout-heading">Tip</p>
			<p class="callout">Using the <strong class="source-inline">+</strong> operator for strings can be controversial among performance-conscious teams. It is correct that the <strong class="source-inline">+</strong> operator may become inefficient because multiple additions may create unnecessary temporary strings to store intermediate results. It is also correct that, for some use cases, the compiler can generate better code than you can write manually. However, unless you use the <strong class="source-inline">+</strong> operator to create strings in <strong class="source-inline">for</strong>-loops, they are rarely the cause of your performance problems. For example, <strong class="source-inline">x+y</strong> will almost always outperform <strong class="source-inline">fmt.Sprintf("%s%s",x,y)</strong>. When in doubt, write a benchmark and measure. Here’s how it appears on <span class="No-Break">my laptop:</span></p>
			<p class="callout"><strong class="source-inline">BenchmarkXPlusY-12          98628536             </strong><span class="No-Break"><strong class="source-inline">11.31 ns/op</strong></span></p>
			<p class="callout"><strong class="source-inline">BenchmarkSprintf-12         12120278</strong><strong class="source-inline">             </strong><span class="No-Break"><strong class="source-inline">97.70 ns/op</strong></span></p>
			<p class="callout"><strong class="source-inline">BenchmarkBuilder-12         33077902             </strong><span class="No-Break"><strong class="source-inline">34.89 ns/op</strong></span></p>
			<p>For non-trivial cases where you have to add many short strings to build a longer one, use <strong class="source-inline">strings.Builder</strong>. Even though <strong class="source-inline">strings.Builder</strong> looks like a convenient frontend to a byte slice, it does more than that. It creates strings from the underlying byte slice without copying, so it almost always outperforms using a byte slice and then creating a string <span class="No-Break">from it.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">This is an example showing why you should prefer standard library functions to third-party libraries or manual optimizations. These functions are aggressively optimized and rely on Go internals without creating <span class="No-Break">portability issues:</span></p>
			<pre class="source-code">
builder := strings.Builder{} // Zero-value is ready to use
for i:=0; i&lt; 10000; i++ {
   builder.WriteString(getShortString(i))
}
fmt.Println(builder.String())</pre>			<p>Use <strong class="source-inline">strings.Join</strong> to combine a slice of strings. If you are dealing with filenames and you need to combine multiple levels of directories, use <strong class="source-inline">filepath.Join</strong> to avoid platform-specific <a id="_idIndexMarker037"/>separator characters. <strong class="source-inline">filepath.Join</strong> will use <strong class="source-inline">\</strong> on Windows platform and <strong class="source-inline">/</strong> on Linux-based platforms. If you are dealing with URLs and need to combine multiple segments, use <strong class="source-inline">path.Join</strong>, which will always use <strong class="source-inline">/</strong> to <span class="No-Break">combine parts:</span></p>
			<pre class="source-code">
package main
import (
     "fmt"
     "path"
     "path/filepath"
     "strings"
)
func main() {
     words := []string{"foo", "bar", "baz"}
     fmt.Println(strings.Join(words, " "))
    // foo bar baz
     fmt.Println(strings.Join(words, ""))
    // foobarbaz
     fmt.Println(path.Join(words...))
    // foo/bar/baz
     fmt.Println(filepath.Join(words...))
    // foo/bar/baz or foo\bar\baz, depending on the host system
     paths := []string{"/foo", "//bar", "baz"}
     fmt.Println(strings.Join(paths, " "))
    // /foo //bar baz
     fmt.Println(path.Join(paths...))
    // /foo/bar/baz
     fmt.Println(filepath.Join(paths...))
    // /foo/bar/baz or \foo\bar\baz depending on the host system
}</pre>			<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Working with string cases</h1>
			<p>When working with textual data, problems related to string cases arise often. Should a text search <a id="_idIndexMarker038"/>be case-sensitive or case-insensitive? How do we convert a string to lowercase or uppercase? In this section, we will look at some recipes to deal with these common problems in a <span class="No-Break">portable way.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>How to do it...</h2>
			<ul>
				<li>Convert strings to uppercase and lowercase using the <strong class="source-inline">strings.ToUpper</strong> and <strong class="source-inline">strings.ToLower</strong> <span class="No-Break">functions, respectively.</span></li>
				<li>When dealing with text in languages with special uppercase/lowercase mappings (such as Turkish, where “İ” is the uppercase version of “I”), use <strong class="source-inline">strings.ToUpperSpecial</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">strings.ToLowerSpecial</strong></span></li>
				<li>To convert text to uppercase for use in titles, <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">strings.ToTitle</strong></span></li>
				<li>To compare strings lexicographically, use <span class="No-Break">comparison operators</span></li>
				<li>To test the equivalence of strings ignoring case, <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">strings.EqualFold</strong></span></li>
			</ul>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>How it works...</h2>
			<p>Converting a string to uppercase or lowercase <span class="No-Break">is easy:</span></p>
			<pre class="source-code">
greet := "Hello World!"
fmt.Println(strings.ToUpper(greet))
fmt.Println(strings.ToLower(greet))</pre>			<p>This program outputs <span class="No-Break">the following:</span></p>
			<pre class="source-code">
HELLO WORLD!
hello world!</pre>			<p>But the uppercase/lowercase may differ from language to language. For example, there are special cases for some of the <span class="No-Break">Turkic languages:</span></p>
			<pre class="source-code">
word := "ilk"
fmt.Println(strings.ToUpper(word))</pre>			<p>This will print <span class="No-Break">the following:</span></p>
			<pre class="source-code">
ILK</pre>			<p>However, that is not <a id="_idIndexMarker039"/>the correct uppercase use for Turkish. Let’s try <span class="No-Break">the following:</span></p>
			<pre class="source-code">
import (
    "fmt"
    "strings"
    "unicode"
)
func main() {
  word := "ilk"
  fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase,word))
}</pre>			<p>The preceding program will print <span class="No-Break">the following:</span></p>
			<pre class="source-code">
İLK</pre>			<p>The title case differs from uppercase or lowercase mainly when dealing with ligatures and digraphs – that is, more than one character represented as a single character, such as <span class="No-Break"><strong class="source-inline">Ǉ</strong></span><span class="No-Break"><strong class="source-inline"> (U+01C7)</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
package main
import (
    "fmt"
    "strings"
)
func main() {
    fmt.Println(strings.ToTitle("Ǉ")) // U+01C7
    fmt.Println(strings.ToUpper("Ǉ"))
    fmt.Println(strings.ToLower("Ǉ"))
}</pre>			<p>This program prints <span class="No-Break">the following:</span></p>
			<pre class="source-code">
ǈ
Ǉ
ǉ</pre>			<p>Uppercase, lowercase, and title <a id="_idIndexMarker040"/>case define how to print a string <a id="_idIndexMarker041"/>using a particular case mapping. These are <strong class="bold">case mappings</strong>. <strong class="bold">Case folding</strong> is the <a id="_idIndexMarker042"/>process of transforming text into the same case for <span class="No-Break">comparison purposes.</span></p>
			<p>For lexicographical case-sensitive comparisons, use the <span class="No-Break">relational operators:</span></p>
			<pre class="source-code">
fmt.Prinln("a" &lt; "b") // true</pre>			<p>To compare two Unicode strings in a case-insensitive way, <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">strings.EqualFold</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
fmt.Println(strings.EqualFold("here", "Here")) // true
fmt.Println(strings.EqualFold("here", "Here")) // true
fmt.Println(strings.EqualFold("GÖ", "gö")) // true</pre>			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>There’s more...</h2>
			<p>While the standard library <strong class="source-inline">strings</strong> package includes most of the string comparison functions you need, they may not be sufficient when dealing with internationalized strings. For example, in many cases, you would want to have <strong class="source-inline">Montréal</strong> and <strong class="source-inline">montreal</strong> be considered equal. <strong class="source-inline">strings.EqualFold</strong> will not do that. Many of the supporting functions to deal with internalized text processing are in the packages <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">golang.org/x/text</strong></span><span class="No-Break">.</span></p>
			<p>Unicode offers multiple ways to represent a given string. The <strong class="source-inline">é</strong> in <strong class="source-inline">Montréal</strong> can be represented as a single rune, <strong class="source-inline">\u00e9</strong> or <strong class="source-inline">e</strong>, followed by an acute accent, <strong class="source-inline">e\u0301</strong>. <strong class="source-inline">\u0301</strong> is the “combining acute accent,” <strong class="source-inline">◌́</strong><strong class="source-inline">,</strong> and it modifies the codepoint that comes before it. According to the Unicode standard, <strong class="source-inline">é</strong> and <strong class="source-inline">e</strong> + <strong class="source-inline">◌́</strong> are “canonically equivalent.” There is also a compatibility equivalence, such as <strong class="source-inline">\ufb00</strong>, representing <strong class="source-inline">ff</strong> as a single codepoint, and the <strong class="source-inline">ff</strong> sequence. Canonically equivalent sequences are also compatible, but not all compatible sequences are <span class="No-Break">canonically equivalent.</span></p>
			<p>So, if you need <a id="_idIndexMarker043"/>to remove diacritics (i.e., nonspacing marks) from text, you can decompose it, remove the diacritics, and then compose it <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// Based on the blog post https://go.dev/blog/normalization
package main
import (
     "fmt"
     "io"
     "strings"
     "unicode"
     "golang.org/x/text/transform"
     "golang.org/x/text/unicode/norm"
)
func main() {
     isMn := func(r rune) bool {
          return unicode.Is(unicode.Mn, r) // Mn: nonspacing marks
     }
     t := transform.Chain(norm.NFD, transform.RemoveFunc(isMn), norm.
     NFC)
     rd := transform.NewReader(strings.NewReader("Montréal"), t)
     str, _ := io.ReadAll(rd)
     fmt.Println(string(str))
}</pre>			<p>The above <a id="_idIndexMarker044"/>program will print <span class="No-Break">the following:</span></p>
			<pre class="source-code">
Montreal</pre>			<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/>Working with encodings</h1>
			<p>If there is <a id="_idIndexMarker045"/>a chance that your program will have to work with data produced by disparate systems, you should be aware of different text encodings. This is a huge topic, but this section should provide some pointers to scratch <span class="No-Break">the surface.</span></p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>How to do it...</h2>
			<ul>
				<li>Use the <strong class="source-inline">golang.org/x/text/encoding</strong> package to deal with <span class="No-Break">different encodings.</span></li>
				<li>To find an encoding by name, use one of <span class="No-Break">the following:</span><ul><li><span class="No-Break"><strong class="source-inline">golang.org/x/text/encoding/ianaindex</strong></span></li><li><span class="No-Break"><strong class="source-inline">golang.org/x/text/encoding/htmlindex</strong></span></li></ul></li>
				<li>Once you have an encoding, use it to translate text to and <span class="No-Break">from UTF-8.</span></li>
			</ul>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>How it works...</h2>
			<p>Use one of <a id="_idIndexMarker046"/>the indexes to find an encoding. Then, use that encoding to <span class="No-Break">read/write data:</span></p>
			<pre class="source-code">
package main
import (
     "fmt"
     "os"
     "golang.org/x/text/encoding/ianaindex"
)
func main() {
     enc, err := ianaindex.MIME.Encoding("US-ASCII")
     if err != nil {
            panic(err)
     }
     b, err := os.ReadFile("ascii.txt")
     if err != nil {
            panic(err)
     }
     decoder := enc.NewDecoder()
     encoded, err := decoder.Bytes(b)
     if err != nil {
            panic(err)
     }
     fmt.Println(string(encoded))
}</pre>			<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Iterating bytes and runes of strings</h1>
			<p>Go strings <a id="_idIndexMarker047"/>can be seen as a sequence of bytes, or as a sequence of runes. This section shows how you can iterate a string <span class="No-Break">either way.</span></p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>How to do it...</h2>
			<p>To iterate the bytes of a string, <span class="No-Break">use indexes:</span></p>
			<pre class="source-code">
for i:=0;i&lt;len(str);i++ {
  fmt.Print(str[i]," ")
}</pre>			<p>To iterate the runes of a string, <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">range</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
for index, c:=range str {
  fmt.Print(c," ")
}</pre>			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>How it works...</h2>
			<p>A Go string is a slice of bytes, so you would expect to be able to write a for-loop to iterate the bytes and runes of a string. You might think that you can do <span class="No-Break">the following:</span></p>
			<pre class="source-code">
strBytes := []byte(str)
strRunes := []rune(str)</pre>			<p>However, converting a string to a slice of bytes or a slice of runes is an expensive operation. The first one creates a writeable copy of the bytes of the <strong class="source-inline">str</strong> string, and the second one creates a writeable copy of the runes of <strong class="source-inline">str</strong>. Remember that <strong class="source-inline">rune</strong> is  <span class="No-Break"><strong class="source-inline">uint32</strong></span><span class="No-Break">.</span></p>
			<p>There are two forms of for-loop to iterate the elements of a string. The following for-loop will iterate the bytes of <span class="No-Break">a string:</span></p>
			<pre class="source-code">
str:="Hello 世界"
for i:=0;i&lt;len(str);i++ {
  fmt.Print(str[i]," ")
}</pre>			<p>The output is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
72 101 108 108 111 32 228 184 150 231 149 140</pre>			<p>Also, note that <strong class="source-inline">str[i]</strong> will give you the i’th byte, not the <span class="No-Break">i’th rune.</span></p>
			<p>The following form iterates the runes of <span class="No-Break">a string:</span></p>
			<pre class="source-code">
for i,r:=range str {
  fmt.Printf("( %d %d %s)", i, r, string(r))
}</pre>			<p>The output <a id="_idIndexMarker048"/>is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
(0 72 H)(1 101 e)(2 108 l)(3 108 l)(4 111 o)(5 32  )(6 19990 世)(9 30028 界)</pre>			<p>Note the indexes – they go in a sequence of 0, 1, 2, 3, 4, 5, 6, 9. This is because <strong class="source-inline">str[6]</strong> contains a rune of 3 bytes, and so <span class="No-Break">does </span><span class="No-Break"><strong class="source-inline">str[9]</strong></span><span class="No-Break">.</span></p>
			<p>When you are dealing with <strong class="source-inline">[]byte</strong> instead of a string, you can emulate the rune iteration, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import (
  "unicode/utf8"
  "fmt"
)
str:=[]byte("Hello 世界")
for i:=0;i&lt;len(str); {
  r, n:=utf8.DecodeRune(str[i:])
  fmt.Print("(",i,r, " ",string(r),")")
  i+=n
}</pre>			<p>The <strong class="source-inline">utf8.DecodeRune</strong> function decodes the next rune from the byte slice and returns that <a id="_idIndexMarker049"/>rune and the number of bytes consumed. This way, you can decode the runes of a byte slice without first converting it to <span class="No-Break">a string.</span></p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Splitting</h1>
			<p>The <strong class="source-inline">strings</strong> package offers <a id="_idIndexMarker050"/>convenient functions to split a string to get a slice <span class="No-Break">of strings.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>How to do it...</h2>
			<ul>
				<li>To split a string into components using a delimiter, <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">strings.Split</strong></span><span class="No-Break">.</span></li>
				<li>To split the space-separated components of a string, <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">strings.Fields</strong></span><span class="No-Break">.</span></li>
			</ul>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>How it works...</h2>
			<p>If you need to parse a string delimited with a fixed delimiter, use <strong class="source-inline">strings.Split</strong>. If you need to parse the space-separated sections of a string, <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">strings.Fields</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
package main
import (
     "fmt"
     "strings"
)
func main() {
     fmt.Println(strings.Split("a,b,c,d", ","))
    // ["a", "b", "c", "d"]
     fmt.Println(strings.Split("a, b, c, d", ","))
    // ["a", " b", " c", " d"]
     fmt.Println(strings.Fields("a    b   c  d  "))
    // ["a", "b", "c", "d"]
     fmt.Println(strings.Split("a---b---c--d--", "-"))
    // ["a", "", "", "b", "", "", "c", "", "d", "", ""]
}</pre>			<p>Note that <strong class="source-inline">strings.Split</strong> may cause some surprises when the delimiter is repeated. For instance, with <strong class="source-inline">"-"</strong> as the delimiter, <strong class="source-inline">"a---b"</strong> splits into <strong class="source-inline">"a"</strong>, <strong class="source-inline">""</strong>, <strong class="source-inline">""</strong>, and <strong class="source-inline">"b"</strong>. The two empty <a id="_idIndexMarker051"/>strings are those between the first and second <strong class="source-inline">"-"</strong>, and the second and <span class="No-Break">third </span><span class="No-Break"><strong class="source-inline">"-"</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor065"/>Reading strings line by line, or word by word</h1>
			<p>There are many <a id="_idIndexMarker052"/>use cases for processing strings in a stream, such as when dealing with large text or user input. This recipe shows the use of <strong class="source-inline">bufio.Scanner</strong> for <span class="No-Break">this purpose.</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>How to do it...</h2>
			<ul>
				<li>Use <strong class="source-inline">bufio.Scanner</strong> for reading lines, words, or <span class="No-Break">custom blocks.</span></li>
				<li>Create a <span class="No-Break"><strong class="source-inline">bufio.Scanner</strong></span><span class="No-Break"> instance</span></li>
				<li>Set the <span class="No-Break">split method</span></li>
				<li>Read scanned tokens in <span class="No-Break">a for-loop</span></li>
			</ul>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>How it works...</h2>
			<p>The <strong class="source-inline">Scanner</strong> works like an iterator – every call to <strong class="source-inline">Scan()</strong> method will return <strong class="source-inline">true</strong> if it parsed <a id="_idIndexMarker053"/>the next token, or <strong class="source-inline">false</strong> if there are no more tokens. The token can be obtained by the <span class="No-Break"><strong class="source-inline">Text()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
package main
import (
     "bufio"
     "fmt"
     "strings"
)
const input = `This is a string
that has 3
lines.`
func main() {
     lineScanner := bufio.NewScanner(strings.NewReader(input))
     line := 0
     for lineScanner.Scan() {
          text := lineScanner.Text()
          line++
          fmt.Printf("Line %d: %s\n", line, text)
     }
     if err := lineScanner.Err(); err != nil {
          panic(err)
     }
     wordScanner := bufio.NewScanner(strings.NewReader(input))
     wordScanner.Split(bufio.ScanWords)
     word := 0
     for wordScanner.Scan() {
          text := wordScanner.Text()
          word++
          fmt.Printf("word %d: %s\n", word, text)
     }
     if err := wordScanner.Err(); err != nil {
          panic(err)
     }
}</pre>			<p>The output <a id="_idIndexMarker054"/>is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Line 1: This is a string
Line 2: that has 3
Line 3: lines.
word 1: This
word 2: is
word 3: a
word 4: string
word 5: that
word 6: has
word 7: 3
word 8: lines.</pre>			<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Trimming the ends of a string</h1>
			<p>User input is <a id="_idIndexMarker055"/>usually messy, including additional spaces before or after the text that matters. This recipe shows how to use the string trimming functions for <span class="No-Break">this purpose.</span></p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>How to do it...</h2>
			<p>Use the <strong class="source-inline">strings.Trim</strong> family of functions, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
package main
import (
     "fmt"
     "strings"
)
func main() {
     fmt.Println(strings.TrimRight("Break-------", "-"))
    // Break
     fmt.Println(strings.TrimRight("Break with spaces-- -- --", "- "))
    // Break with spaces
     fmt.Println(strings.TrimSuffix("file.txt", ".txt"))
    // file
     fmt.Println(strings.TrimLeft(" \t   Indented text", " \t"))
    // Indented text
     fmt.Println(strings.TrimSpace(" \t \n  Indented text  \n\t"))
    // Indented text
}</pre>			<h1 id="_idParaDest-71"><a id="_idTextAnchor070"/>Regular expressions</h1>
			<p>A regular expression <a id="_idIndexMarker056"/>offers efficient methods to ensure that textual data matches a given pattern, searches for patterns, extracts, and replaces parts of text. Usually, you compile a regular expression once and then use that compiled regular expression many times to efficiently validate, search, extract, or replace parts <span class="No-Break">of strings.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Validating input</h2>
			<p>Format validation <a id="_idIndexMarker057"/>is the process of ensuring that data <a id="_idIndexMarker058"/>coming from user input or other sources is in a recognized format. Regular expressions can be an effective tool for <span class="No-Break">such validation.</span></p>
			<h3>How to do it...</h3>
			<p>Use precompiled regular expressions to validate input values that should fit <span class="No-Break">a pattern.</span></p>
			<pre class="source-code">
package main
import (
     "fmt"
     "regexp"
)
var integerRegexp = regexp.MustCompile("^[0-9]+$")
func main() {
     fmt.Println(integerRegexp.MatchString("123"))   // true
     fmt.Println(integerRegexp.MatchString(" 123 ")) // false
}</pre>			<p>To ensure an <a id="_idIndexMarker059"/>exact match, make sure you include the beginning (<strong class="source-inline">^</strong>) and end-of-text markers (<strong class="source-inline">$</strong>); otherwise, you will end up accepting input <strong class="bold">containing</strong> strings that match the <span class="No-Break">regular expression.</span></p>
			<p>Not all types <a id="_idIndexMarker060"/>of input are suitable for regular expression validation. Some inputs have complicated regular expressions (such as the one for emails or password policies), so custom validations may work better <span class="No-Break">for those.</span></p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/>Searching patterns</h2>
			<p>You can <a id="_idIndexMarker061"/>use a regular expression to search through <a id="_idIndexMarker062"/>textual data to locate strings matching <span class="No-Break">a pattern.</span></p>
			<h3>How to do it...</h3>
			<p>Use the <strong class="source-inline">regexp.Find</strong> family of methods to search for substrings matching <span class="No-Break">a pattern.</span></p>
			<pre class="source-code">
package main
import (
     "fmt"
     "regexp"
)
func main() {
     re := regexp.MustCompile(`[0-9]+`)
     fmt.Println(re.FindAllString("This regular expression find 
     numbers, like 1, 100, 500, etc.", -1))
}</pre>			<p>Here <a id="_idIndexMarker063"/>is <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker064"/></span><span class="No-Break">output:</span></p>
			<pre class="source-code">
[1 100 500]</pre>			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Extracting data from strings</h1>
			<p>You can <a id="_idIndexMarker065"/>use a regular expression to locate and extract <a id="_idIndexMarker066"/>text that occurs within <span class="No-Break">a pattern.</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>How to do it...</h2>
			<p>Use capture groups to extract substrings that match <span class="No-Break">a pattern.</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>How it works...</h2>
			<pre class="source-code">
package main
import (
     "fmt"
     "regexp"
)
func main() {
     re := regexp.MustCompile(`^(\w+)=(\w+)$`)
     result := re.FindStringSubmatch(`property=12`)
     fmt.Printf("Key: %s value: %s\n", result[1], result[2])
     result = re.FindStringSubmatch(`x=y`)
     fmt.Printf("Key: %s value: %s\n", result[1], result[2])
}</pre>			<p>Here <a id="_idIndexMarker067"/>is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
Key: property value: 12
Key: x value: y</pre>			<p>Let’s <a id="_idIndexMarker068"/>look at this <span class="No-Break">regular expression:</span></p>
			<ul>
				<li><strong class="source-inline">^(\w+)</strong>: A string composed of one or more word characters at the beginning of the line (capture <span class="No-Break">group 1)</span></li>
				<li><strong class="source-inline">=</strong>: An “<strong class="source-inline">=</strong>” <span class="No-Break">sign</span></li>
				<li><strong class="source-inline">(\w+)$</strong>: A string composed of one or more word characters (capture group 2), and then the end <span class="No-Break">of line</span></li>
			</ul>
			<p>Note that the capture groups are <span class="No-Break">in parentheses.</span></p>
			<p>The <strong class="source-inline">FindStringSubmatch</strong> method returns the matching string as the 0th element of the slice, and then each capture group. Using the capture groups, you can extract data <span class="No-Break">as above.</span></p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Replacing parts of a string</h1>
			<p>You can <a id="_idIndexMarker069"/>use a regular expression to search through text, replacing parts that match a pattern with <span class="No-Break">other strings.</span></p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>How to do it...</h2>
			<p>Use the <strong class="source-inline">Replace</strong> family <a id="_idIndexMarker070"/>of functions to replace the patterns in a string with <span class="No-Break">something else:</span></p>
			<pre class="source-code">
package main
import (
     "fmt"
     "regexp"
)
func main() {
     // Find numbers, capture the first digit
     re := regexp.MustCompile(`([0-9])[0-9]*`)
     fmt.Println(re.ReplaceAllString("This example replaces 
     numbers  with 'x': 1, 100, 500.", "x"))
    // This example replaces numbers  with 'x': x, x, x.
     fmt.Println(re.ReplaceAllString("This example replaces all 
     numbers with their first digits: 1, 100, 500.", "${1}"))
    // This example replaces all numbers with their first digits: 1, 
    // 1, 5.
}</pre>			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Templates</h1>
			<p>Templates <a id="_idIndexMarker071"/>are useful for generating data-driven textual output. The <strong class="source-inline">text/template</strong> package can be used in the <span class="No-Break">following contexts:</span></p>
			<ul>
				<li><strong class="bold">Configuration files</strong>: You can accept templates in configuration files, such as the following <a id="_idIndexMarker072"/>example that uses an <strong class="source-inline">env</strong> map variable to create <span class="No-Break">environment-sensitive configurations</span><pre class="source-code">
logfile: {{.env.logDir}}/log.json</pre></li>				<li><strong class="bold">Reporting</strong>: Use <a id="_idIndexMarker073"/>templates to generate output for command-line applications <span class="No-Break">and reports</span></li>
				<li><strong class="bold">Web applications</strong>: The <strong class="source-inline">html/template</strong> package provides HTML-safe templating <a id="_idIndexMarker074"/>functionality for template-based HTML generation to build <span class="No-Break">web applications</span></li>
			</ul>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Value substitution</h2>
			<p>The main <a id="_idIndexMarker075"/>use of templates is inserting data elements into structured text. This section describes how you can insert values computed in a program into <span class="No-Break">a template.</span></p>
			<h3>How to do it...</h3>
			<p>Use the <strong class="source-inline">{{.name}}</strong> syntax to substitute a value in <span class="No-Break">a template.</span></p>
			<p>The following code segment executes a template using <span class="No-Break">different inputs:</span></p>
			<pre class="source-code">
package main
import (
     "os"
     "text/template"
)
type Book struct {
     Title   string
     Author  string
     PubYear int
}
const tp = `The book "{{.Title}}" by {{.Author}} was published in {{.PubYear}}.
`
func main() {
     book1 := Book{
          Title:   "Pride and Prejudice",
          Author:  "Jane Austen",
          PubYear: 1813,
     }
     book2 := Book{
          Title:   "The Lord of the Rings",
          Author:  "J.R.R. Tolkien",
          PubYear: 1954,
     }
     tmpl, err := template.New("book").Parse(tp)
     if err != nil {
          panic(err)
     }
     tmpl.Execute(os.Stdout, book1)
     tmpl.Execute(os.Stdout, book2)
}</pre>			<p>The preceding program outputs <span class="No-Break">the following:</span></p>
			<pre class="source-code">
The book "Pride and Prejudice" by Jane Austen was published in 1813.
The book "The Lord of the Rings" by J.R.R. Tolkien was published in 1954.</pre>			<p>The <strong class="source-inline">template.New(name)</strong> call creates an empty template with the given name (there’ll be more on this later). The returned template object represents a template body (which is empty after the <strong class="source-inline">New()</strong> call). The Go template engine uses a template representing <a id="_idIndexMarker076"/>the body, as well as zero or more named templates that are associated with that body. The <strong class="source-inline">tmpl.Parse(tp)</strong> call parses the <strong class="source-inline">tp</strong> template as the body for the given <strong class="source-inline">named </strong>template. If there are other template definitions in <strong class="source-inline">tp</strong> that are defined using the <strong class="source-inline">{{define}}</strong> construct, those are kept within <strong class="source-inline">tmpl</strong> <span class="No-Break">as well.</span></p>
			<p><strong class="source-inline">tmpl.Execute(os.Stdout,book1)</strong> executes the template, writing the output to <strong class="source-inline">os.Stdout</strong>. The second argument, <strong class="source-inline">book1</strong>, is the data used to evaluate the template. You access it by "<strong class="source-inline">.</strong>". So, for instance, when <strong class="source-inline">{{.Author}}</strong> is evaluated, the template engine reads <strong class="source-inline">book1.Author</strong>, using reflection, and outputs its value. In other words, <strong class="source-inline">.</strong> is <strong class="source-inline">book1</strong> for the first <strong class="source-inline">tmpl.Execute</strong> call, and <strong class="source-inline">.</strong> is <strong class="source-inline">book2</strong> for the second <strong class="source-inline">tmpl.Execute</strong> call in the <span class="No-Break">preceding example.</span></p>
			<p>Since this is done using reflection, the following produces the <span class="No-Break">same output:</span></p>
			<pre class="source-code">
tmpl.Execute(os.Stdout,map[string]any {
   "Title":"Pride and Prejudice",
   "Author":  "Jane Austen",
   "PubYear": 1813,
   })</pre>			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Iteration</h2>
			<p>A template <a id="_idIndexMarker077"/>can include tabular data or lists that are populated using <a id="_idIndexMarker078"/>slices or maps computed in a program. Templates provide an iteration mechanism to render <span class="No-Break">such content.</span></p>
			<h3>How to do it...</h3>
			<ul>
				<li>For slices/arrays, do <span class="No-Break">the following:</span><pre class="source-code">
{{ range &lt;slice&gt; }}
  // Here, {{.}} refers the subsequent elements of the slice/array
{{end}}</pre></li>				<li>For maps, do <a id="_idIndexMarker079"/><span class="No-Break">the following:</span><pre class="source-code">
{{ range &lt;map&gt; }}
  // Here, {{.}} refers to the subsequent values (not keys) of the map
  // The iteration order of the map is not guaranteed
{{end}}</pre><p class="list-inset">Alternatively, do <span class="No-Break">the following:</span></p><pre class="source-code">{{ range $key, $value := &lt;map&gt; }}
  // Here, {{$key}} and {{$value}} are variables that are set to
  // subsequent key-value pairs of the map
{{end}}</pre></li>			</ul>
			<h3>How it works...</h3>
			<p>Use <strong class="source-inline">range</strong> to loop through slices <span class="No-Break">and maps.</span></p>
			<p>Modify the preceding example with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const tpIter = `{{range .}}
The book "{{.Title}}" by {{.Author}} was published in {{.PubYear}}.
{{end}}`</pre>			<p>Then, modify it with the <span class="No-Break">following too:</span></p>
			<pre class="source-code">
...
tmpl, err = template.New("bookIter").Parse(tpIter)
if err != nil {
    panic(err)
}
tmpl.Execute(os.Stdout, []Book{book1, book2})</pre>			<p>Here is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
The book "Pride and Prejudice" by Jane Austen was published in 1813.
The book "The Lord of the Rings" by J.R.R. Tolkien was published in 1954.</pre>			<p>Now, note that <strong class="source-inline">.</strong> is a slice of books, so we can range through the elements of it. When evaluating the <a id="_idIndexMarker080"/>section within <strong class="source-inline">{{range .}}</strong>, <strong class="source-inline">.</strong> is set to successive elements of the slice – during the first iteration, <strong class="source-inline">.</strong> is <strong class="source-inline">book1</strong>, and during the second iteration, <strong class="source-inline">.</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">book2</strong></span><span class="No-Break">.</span></p>
			<p>We will deal with the empty <span class="No-Break">lines shortly.</span></p>
			<p>The same thing happens <span class="No-Break">for maps:</span></p>
			<pre class="source-code">
tmpl.Execute(os.Stdout, map[int]Book{
  1: book1,
  2: book2,
  })</pre>			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Variables and scope</h2>
			<p>It is often <a id="_idIndexMarker081"/>necessary to <a id="_idIndexMarker082"/>define local variables within <a id="_idIndexMarker083"/>templates to <a id="_idIndexMarker084"/>keep computed values. The variables defined in templates follow similar scoping rules as variables defined in functions – the <strong class="source-inline">{{range}}</strong>, <strong class="source-inline">{{if}}</strong>, <strong class="source-inline">{{with}}</strong> and <strong class="source-inline">{{define}}</strong> blocks create a <span class="No-Break">new scope.</span></p>
			<p>A variable <a id="_idIndexMarker085"/>defined in a scope is accessible in all the scopes contained within that scope, but it is not accessible outside <span class="No-Break">of it.</span></p>
			<h3>How to do it...</h3>
			<p><strong class="source-inline">.</strong> (<strong class="bold">dot</strong>) refers to the “current object,” <span class="No-Break">as follows:</span></p>
			<ul>
				<li>At the top-level scope, <strong class="source-inline">.</strong> refers to the object passed as the <strong class="source-inline">data</strong> argument of the <span class="No-Break"><strong class="source-inline">Execute</strong></span><span class="No-Break"> method</span></li>
				<li>Inside a <strong class="source-inline">{{range}}</strong>, <strong class="source-inline">.</strong> refers to the current <span class="No-Break">slice/array/map element</span></li>
				<li>Inside a <strong class="source-inline">{{with &lt;expr&gt;}}</strong>, <strong class="source-inline">.</strong> refers to the value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">&lt;expr&gt;</strong></span></li>
				<li>Inside a <strong class="source-inline">{{define}}</strong> block, <strong class="source-inline">.</strong> refers to the value of the object passed into <strong class="source-inline">{{template "</strong><span class="No-Break"><strong class="source-inline">name" &lt;object&gt;}}</strong></span></li>
				<li><strong class="source-inline">.X</strong> refers to the member named <strong class="source-inline">X</strong> in the <span class="No-Break">current object:</span><ul><li>If <strong class="source-inline">.</strong> is a map, then <strong class="source-inline">.X</strong> evaluates to the element with the <span class="No-Break"><strong class="source-inline">X</strong></span><span class="No-Break"> key</span></li><li>If <strong class="source-inline">.</strong> is a struct, then <strong class="source-inline">.X</strong> evaluates to the <strong class="bold">exported</strong> <strong class="source-inline">X</strong> <span class="No-Break">member variable</span></li></ul></li>
			</ul>
			<p class="callout-heading">Tip</p>
			<p class="callout">Note the emphasis on <strong class="bold">exported</strong>. The template engine uses reflection to find the value of <strong class="source-inline">X</strong> in the current object. If the current object is a struct, reflection can only access the exported fields, so you cannot access unexported variables. However, if the current object is a map, this becomes a key lookup, and there is no such restriction. In other words, <strong class="source-inline">{{.name}}</strong> will only work if <strong class="source-inline">.</strong> is a map, but <strong class="source-inline">{{.Name}}</strong> will work for a <strong class="source-inline">.</strong> struct and a <strong class="source-inline">.</strong> <span class="No-Break">map.</span></p>
			<p>Define a new local variable that is visible in the current scope using <span class="No-Break">the following:</span></p>
			<pre class="source-code">
$name := value</pre>			<h3>How it works...</h3>
			<p>Use the <strong class="source-inline">$name</strong> notation to <a id="_idIndexMarker086"/>assign a computed value to a variable instead of recomputing it <span class="No-Break">every time:</span></p>
			<pre class="source-code">
{{ $disabled := false }}
{{ if eq .Selection "1"}}
 {{ $disabled = true }}
{{ end }}
&lt;input type="text" value="{{.Value1}}" {{if $disabled}}disabled{{end}}&gt;
&lt;input type="text" value="{{.Value2}}" {{if $disabled}}disabled{{end}}&gt;</pre>			<p>The first section of this template is equivalent to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
disabled := false
if data.Selection == "1" {
  disabled=true
}</pre>			<p><strong class="source-inline">$</strong> is necessary as the first character of the variable name. Without that, the template engine will think <strong class="source-inline">name</strong> is <span class="No-Break">a function.</span></p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>There’s more – nested loops and conditionals</h2>
			<p>When you are <a id="_idIndexMarker087"/>dealing with nested loops or conditions, scoping can become <a id="_idIndexMarker088"/>a challenge. Every <strong class="source-inline">{{range}}</strong>, <strong class="source-inline">{{if}}</strong>, and <strong class="source-inline">{{with}}</strong> create a new scope. Variables defined within a scope are only accessible in that scope and all scopes enclosed in it. You can use this to create nested loops and still access variables defined in the <span class="No-Break">enclosing scope:</span></p>
			<pre class="source-code">
type Book struct {
     Title    string
     Author   string
     Editions []Edition
}
type Edition struct {
     Edition int
     PubYear int
}
const tp = `{{range $bookIndex, $book := .}}
{{$book.Author}}
{{range $book.Editions}}
  {{$book.Title}} Edition: {{.Edition}} {{.PubYear}}
{{end}}
{{end}}`</pre>			<p>In this <a id="_idIndexMarker089"/>template, the first <strong class="source-inline">range</strong> defines the loop index, <strong class="source-inline">$bookIndex</strong>, and the loop variable, <strong class="source-inline">$book</strong>, that can be used in the nested scopes. At <a id="_idIndexMarker090"/>this stage, <strong class="source-inline">.</strong> points to the slice of <strong class="source-inline">Book</strong> fields. The next <strong class="source-inline">range</strong> iterates the current <strong class="source-inline">$book.Editions</strong> – that is, <strong class="source-inline">.</strong> now points to the successive elements of the <strong class="source-inline">Book.Editions</strong> slice. The nested template accesses both the <strong class="source-inline">Edition</strong> fields and the <strong class="source-inline">Book</strong> fields from the <span class="No-Break">enclosing scope.</span></p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Dealing with empty lines</h1>
			<p>Template <a id="_idIndexMarker091"/>actions (i.e., the code elements placed in a template) may result in unwanted empty spaces and lines. The Go template system offers some mechanisms to deal with these <span class="No-Break">unwanted spaces.</span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>How to do it...</h2>
			<p>Use <strong class="source-inline">-</strong> next to the <span class="No-Break">template delimiter:</span></p>
			<ul>
				<li><strong class="source-inline">{{-  </strong>will remove all spaces/tabs/newlines that were output before this <span class="No-Break">template element</span></li>
				<li><strong class="source-inline">-}}</strong> will remove all spaces/tabs/newlines that come after this <span class="No-Break">template element</span></li>
			</ul>
			<p>If a template <a id="_idIndexMarker092"/>directive produces output, such as the value of a variable, it will be written to the output stream. But if a template directive does not generate any output, such as a <strong class="source-inline">{{range}}</strong> or <strong class="source-inline">{{if}}</strong> statement, then it will be replaced with empty strings. And if those statements are on a line by themselves, those lines will be written to the output as well, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
{{range .}}
  {{if gt . 1}}
    {{.}}
  {{end}}
{{end}}</pre>			<p>This template will produce an output every four lines. When there is nothing to output, it will print three <span class="No-Break">empty lines.</span></p>
			<p>Fix this by using “<strong class="source-inline">-</strong>” inside the <strong class="source-inline">{{ }}</strong> constructs. <strong class="source-inline">{{ -}}</strong> will remove all empty space (including lines) coming after, and <strong class="source-inline">{{- }}</strong> will remove all empty spaces before, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
{{range . -}}
  {{ if gt . 1 }}
    {{- . }}
  {{end -}}
{{end -}}</pre>			<p>Here is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
2
  3
  4
  5</pre>			<p>How can we get rid of the spaces at the beginning of each line? First, we have to find out why they are there, which is <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
    {{- . }}
__{{end -}}</pre>			<p>The first “-” will remove <a id="_idIndexMarker093"/>all spaces before the value. We cannot put <strong class="source-inline">-}}</strong> in this line, or <strong class="source-inline">{{- end}}</strong>, as these solutions would remove line feeds as well. But we can <span class="No-Break">do this:</span></p>
			<pre class="source-code">
{{range . -}}
{{ if gt . 1 }}
  {{- . }}
{{end -}}
{{end -}}</pre>			<p>This will produce <span class="No-Break">the following:</span></p>
			<pre class="source-code">
2
3
4
5</pre>			<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Template composition</h1>
			<p>As templates grow, they may become repetitive. To reduce such repetition, the Go template <a id="_idIndexMarker094"/>system offers named blocks (components) that can be reused within a template, just like functions in a program. Then, the final template can be composed of <span class="No-Break">these components.</span></p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>How to do it...</h2>
			<p>You can create template “components” that you can reuse in multiple contexts. To define a named template, use the <strong class="source-inline">{{define "</strong><span class="No-Break"><strong class="source-inline">name"}}</strong></span><span class="No-Break"> construct:</span></p>
			<pre class="source-code">
{{define "template1"}}
  ...
{{end}}
{{define "template2"}}
 ...
{{end}}</pre>			<p>Then, call that <a id="_idIndexMarker095"/>template using the <strong class="source-inline">{{template "name" .}}</strong> construct as if it is a function with a <span class="No-Break">single argument:</span></p>
			<pre class="source-code">
{{template "template1" .}}
{{range .List}}
  {{template "template2" .}}
{{end}}</pre>			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>How it works...</h2>
			<p>The following example prints a book list using a <span class="No-Break">named template:</span></p>
			<pre class="source-code">
package main
import (
     "os"
     "text/template"
)
const tp = `{{define "line"}}
{{.Title}} {{.Author}} {{.PubYear}}
{{end}}
Book list:
{{range . -}}
  {{template "line" .}}
{{end -}}
`
type Book struct {
     Title   string
     Author  string
     PubYear int
}
var books = []Book{
     {
          Title:   "Pride and Prejudice",
          Author:  "Jane Austen",
          PubYear: 1813,
     },
     {
          Title:   "To Kill a Mockingbird",
          Author:  "Harper Lee",
          PubYear: 1960,
     },
     {
          Title:   "The Great Gatsby",
          Author:  "F. Scott Fitzgerald",
          PubYear: 1925,
     },
     {
          Title:   "The Lord of the Rings",
          Author:  "J.R.R. Tolkien",
          PubYear: 1954,
     },
}
func main() {
     tmpl, err := template.New("body").Parse(tp)
     if err != nil {
          panic(err)
     }
     tmpl.Execute(os.Stdout, books)
}</pre>			<p>The <strong class="source-inline">tmpl</strong> template contains <a id="_idIndexMarker096"/>two templates in this example – the template named <strong class="source-inline">"body"</strong> (because it is created with <strong class="source-inline">template.New("body")</strong>), and the template named <strong class="source-inline">"line"</strong> (because the template contains <strong class="source-inline">{{define "line"}}</strong>.) For each element of the slice, the <strong class="source-inline">"body"</strong> template instantiates <strong class="source-inline">"line"</strong> with successive elements of the <span class="No-Break"><strong class="source-inline">books</strong></span><span class="No-Break"> slice.</span></p>
			<p>This is equivalent to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const lineTemplate = `{{.Title}} {{.Author}} {{.PubYear}}`
const bodyTemplate = `Book list:
{{range . -}}
  {{template "line" .}}
{{end -}}`
func main() {
     tmpl, err := template.New("body").Parse(bodyTemplate)
     if err != nil {
          panic(err)
     }
     _, err = tmpl.New("line").Parse(lineTemplate)
     if err != nil {
          panic(err)
     }
     tmpl.Execute(os.Stdout, books)
}</pre>			<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Template composition – layout templates</h1>
			<p>When developing <a id="_idIndexMarker097"/>web applications, it is usually desirable to have a few templates specifying page layouts. Complete web pages are constructed by combining page components, developed as independent templates using this layout. Unfortunately, the Go template engine forces you to think of alternative solutions because Go template references are static. This means you would need a separate layout template for <span class="No-Break">each page.</span></p>
			<p>But there <span class="No-Break">are alternatives.</span></p>
			<p>I’ll show you a basic idea that demonstrates how template composition can be used so that you can extend it, based on your use case, or how to use an available third-party library that does this. The crucial idea in composition using layout templates is that if you define a new template using an already-defined template name, the new definition overrides the <span class="No-Break">older one.</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/>How to do it...</h2>
			<ul>
				<li>Create a layout template. Use empty templates or templates with default content for the sections you will redefine for <span class="No-Break">each occasion.</span></li>
				<li>Create a configuration system where you define every possible composition. Each composition <a id="_idIndexMarker098"/>includes the layout template, as well as the templates defining the sections in the <span class="No-Break">layout template.</span></li>
				<li>Compile each composition as a <span class="No-Break">separate template.</span></li>
			</ul>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>How it works...</h2>
			<p>Create a <span class="No-Break">layout template:</span></p>
			<pre class="source-code">
const layout=`
&lt;!doctype html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
  &lt;title&gt;{{template "pageTitle" .}}&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  {{template "pageHeader" .}}
  {{template "pageBody" .}}
  {{template "pageFooter" .}}
  &lt;/body&gt;
&lt;/html&gt;
{{define "pageTitle"}}{{end}}
{{define "pageHeader"}}{{end}}
{{define "pageBody"}}{{end}}
{{define "pageFooter"}}{{end}}`</pre>			<p>This layout <a id="_idIndexMarker099"/>template defines four named templates with no content. For each new page, we can recreate <span class="No-Break">these components:</span></p>
			<pre class="source-code">
const mainPage=`
{{define "pageTitle"}}Main Page{{end}}
{{define "pageHeader"}}
&lt;h1&gt;Main page&lt;/h1&gt;
{{end}}
{{define "pageBody"}}
This is the page body.
{{end}}
{{define "pageFooter"}}
This is the page footer.
{{end}}`</pre>			<p>We can define a second page, similar to the <span class="No-Break">first one:</span></p>
			<pre class="source-code">
const secondPage=`
{{define "pageTitle"}}Second page{{end}}
{{define "pageHeader"}}
&lt;h1&gt;Second page&lt;/h1&gt;
{{end}}
{{define "pageBody"}}
This is the page body for the second page.
{{end}}`</pre>			<p>Now, we <a id="_idIndexMarker100"/>compose <strong class="source-inline">layout</strong> with <strong class="source-inline">mainPage</strong> to get the template for the main page, and then <strong class="source-inline">layout</strong> with <strong class="source-inline">secondPage</strong> to get the template for the <span class="No-Break">second page:</span></p>
			<pre class="source-code">
import (
  "html/template"
)
func main() {
     mainPageTmpl := template.Must(template.New("body").Parse(layout))
     template.Must(mainPageTmpl.Parse(mainPage))
     secondPageTmpl := template.Must(template.New("body").
     Parse(layout))
     template.Must(secondPageTmpl.Parse(secondPage))
     mainPageTmpl.Execute(os.Stdout, nil)
     secondPageTmpl.Execute(os.Stdout, nil)
}</pre>			<p>You can extend this pattern to build a sophisticated web application using layout templates, as well as a configuration file defining all the valid compositions of templates for each page. Such a YAML file looks like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
mainPage:
  - layouts/main.html
  - mainPage.html
  - fragments/status.html
detailPage:
  - layouts/2col.html
  - detailPage.html
  - fragments/status.html
...</pre>			<p>When the <a id="_idIndexMarker101"/>application starts, you build each template for <strong class="source-inline">mainPage</strong> and <strong class="source-inline">detailPage</strong> by parsing its constituent templates in the given order, putting each template in a map. Then, you can look up the template name you want to generate and use the <span class="No-Break">parsed template.</span></p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor091"/>There’s more...</h1>
			<p>The Go <a id="_idIndexMarker102"/>standard library documentation is always your best source for up-to-date information and great examples, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><a href="https://pkg.go.dev/strings"><span class="No-Break">https://pkg.go.dev/strings</span></a></li>
				<li><a href="https://pkg.go.dev/text/template"><span class="No-Break">https://pkg.go.dev/text/template</span></a></li>
				<li><a href="https://pkg.go.dev/html/template"><span class="No-Break">https://pkg.go.dev/html/template</span></a></li>
				<li><a href="https://pkg.go.dev/fmt"><span class="No-Break">https://pkg.go.dev/fmt</span></a></li>
				<li><a href="https://pkg.go.dev/bufio"><span class="No-Break">https://pkg.go.dev/bufio</span></a></li>
			</ul>
			<p>The following links are <span class="No-Break">also useful:</span></p>
			<ul>
				<li><em class="italic">Character Model for the World Wide Web: String </em><span class="No-Break"><em class="italic">Matching</em></span><span class="No-Break">: </span><a href="https://www.w3.org/TR/charmod-norm/"><span class="No-Break">https://www.w3.org/TR/charmod-norm/</span></a></li>
				<li><em class="italic">Character Properties, Case Mappings &amp; Names </em><span class="No-Break"><em class="italic">FAQ</em></span><span class="No-Break">: </span><a href="https://unicode.org/faq/casemap_charprop.html"><span class="No-Break">https://unicode.org/faq/casemap_charprop.html</span></a></li>
				<li>RFC7564: <span class="No-Break">PRECIS </span><a href="https://www.rfc-editor.org/rfc/rfc7564"><span class="No-Break">https://www.rfc-editor.org/rfc/rfc7564</span></a></li>
				<li>This is a <a id="_idIndexMarker103"/>great blog post about the Unicode normalization <span class="No-Break">process: </span><a href="https://go.dev/blog/normalization"><span class="No-Break">https://go.dev/blog/normalization</span></a></li>
				<li>For all encoding, internationalization, and Unicode-related problems that are not handled by the standard library, take a look at the packages here before searching for anything <span class="No-Break">else: </span><a href="https://pkg.go.dev/golang.org/x/text"><span class="No-Break">https://pkg.go.dev/golang.org/x/text</span></a></li>
			</ul>
		</div>
	</div></div></body></html>