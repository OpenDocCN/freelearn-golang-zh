["```go\nx:=\"Hello\"\nx+=\" World\"\nfmt.Println(x)\n// Prints Hello World\n```", "```go\n        x := \"Hello world\"\n        ```", "```go\n        x:=\"This is how you can include a \\\" in your string literal\"\n        y:=\"You can also use a newline \\n, tab \\t\"\n        ```", "```go\n        w:=\"\\u65e5本\\U00008a9e\"\n        x:=\"\\xff\"\n        ```", "```go\n    x:=`This is a\n    multiline raw string literal.\n    Backslash will print as backslash \\`\n    ```", "```go\nx:=`This is a raw string literal with `+\"`\"+` in it`\n```", "```go\nfunc main() {\n     fmt.Printf(\"Print integers using %%d: %d|\\n\", 10)\n    // Print integers using %d: 10|\n     fmt.Printf(\"You can set the width of the printed number, left \n     aligned: %5d|\\n\", 10)\n    // You can set the width of the printed number, left \n    // aligned:    10|\n     fmt.Printf(\"You can make numbers right-aligned with a given \n     width: %-5d|\\n\", 10)\n    // You can make numbers right-aligned with a given width: 10   |\n     fmt.Printf(\"The width can be filled with 0s: %05d|\\n\", 10)\n    // The width can be filled with 0s: 00010|\n     fmt.Printf(\"You can use multiple arguments: %d %s %v\\n\", 10, \n     \"yes\", true)\n    // You can use multiple arguments: 10 yes true\n     fmt.Printf(\"You can refer to the same argument multiple times : \n     %d %s %[2]s  %v\\n\", 10, \"yes\", true)\n    // You can refer to the same argument multiple times : 10 yes \n    // yes  true\n     fmt.Printf(\"But if you use an index n, the next argument will be \n     selected from n+1 : %d %s %[2]s %[1]v  %v\\n\", 10, \"yes\", true)\n    // But if you use an index n, the next argument will be selected \n    // from n+1 : 10 yes yes 10  yes\n     fmt.Printf(\"Use %%v to use the default format for the type: %v %v \n     %v\\n\", 10, \"yes\", true)\n    // Use %v to use the default format for the type: 10 yes true\n     fmt.Printf(\"For floating point, you can specify precision: \n     %5.2f\\n\", 12.345657)\n    // For floating point, you can specify precision: 12.35\n     fmt.Printf(\"For floating point, you can specify precision: \n     %5.2f\\n\", 12.0)\n    // For floating point, you can specify precision: 12.00\n    type S struct {\n         IntValue    int\n         StringValue string\n    }\n    s := S{\n         IntValue:    1,\n         StringValue: `foo \"bar\"`,\n    }\n    // Print the field values of a structure, in the order they are \n    // declared\n    fmt.Printf(\"%v\\n\", s)\n    // {1 foo \"bar\"}\n    // Print the field names and values of a structure\n    fmt.Printf(\"%+v\\n\", s)\n    //{IntValue:1 StringValue:foo \"bar\"}\n}\n```", "```go\nvar TwoLines = \"This is the first line \\n\"+\n\"This is the second line\"\nfunc ThreeLines(newLine string) string {\n   return TwoLines+\"\\n\"+newLine\n}\n```", "```go\nfunc AddNewLine(line string) string {\n  return line+string('\\n')\n}\n```", "```go\nbuilder := strings.Builder{} // Zero-value is ready to use\nfor i:=0; i< 10000; i++ {\n   builder.WriteString(getShortString(i))\n}\nfmt.Println(builder.String())\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"path\"\n     \"path/filepath\"\n     \"strings\"\n)\nfunc main() {\n     words := []string{\"foo\", \"bar\", \"baz\"}\n     fmt.Println(strings.Join(words, \" \"))\n    // foo bar baz\n     fmt.Println(strings.Join(words, \"\"))\n    // foobarbaz\n     fmt.Println(path.Join(words...))\n    // foo/bar/baz\n     fmt.Println(filepath.Join(words...))\n    // foo/bar/baz or foo\\bar\\baz, depending on the host system\n     paths := []string{\"/foo\", \"//bar\", \"baz\"}\n     fmt.Println(strings.Join(paths, \" \"))\n    // /foo //bar baz\n     fmt.Println(path.Join(paths...))\n    // /foo/bar/baz\n     fmt.Println(filepath.Join(paths...))\n    // /foo/bar/baz or \\foo\\bar\\baz depending on the host system\n}\n```", "```go\ngreet := \"Hello World!\"\nfmt.Println(strings.ToUpper(greet))\nfmt.Println(strings.ToLower(greet))\n```", "```go\nHELLO WORLD!\nhello world!\n```", "```go\nword := \"ilk\"\nfmt.Println(strings.ToUpper(word))\n```", "```go\nILK\n```", "```go\nimport (\n    \"fmt\"\n    \"strings\"\n    \"unicode\"\n)\nfunc main() {\n  word := \"ilk\"\n  fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase,word))\n}\n```", "```go\nİLK\n```", "```go\npackage main\nimport (\n    \"fmt\"\n    \"strings\"\n)\nfunc main() {\n    fmt.Println(strings.ToTitle(\"Ǉ\")) // U+01C7\n    fmt.Println(strings.ToUpper(\"Ǉ\"))\n    fmt.Println(strings.ToLower(\"Ǉ\"))\n}\n```", "```go\nǈ\nǇ\nǉ\n```", "```go\nfmt.Prinln(\"a\" < \"b\") // true\n```", "```go\nfmt.Println(strings.EqualFold(\"here\", \"Here\")) // true\nfmt.Println(strings.EqualFold(\"here\", \"Here\")) // true\nfmt.Println(strings.EqualFold(\"GÖ\", \"gö\")) // true\n```", "```go\n// Based on the blog post https://go.dev/blog/normalization\npackage main\nimport (\n     \"fmt\"\n     \"io\"\n     \"strings\"\n     \"unicode\"\n     \"golang.org/x/text/transform\"\n     \"golang.org/x/text/unicode/norm\"\n)\nfunc main() {\n     isMn := func(r rune) bool {\n          return unicode.Is(unicode.Mn, r) // Mn: nonspacing marks\n     }\n     t := transform.Chain(norm.NFD, transform.RemoveFunc(isMn), norm.\n     NFC)\n     rd := transform.NewReader(strings.NewReader(\"Montréal\"), t)\n     str, _ := io.ReadAll(rd)\n     fmt.Println(string(str))\n}\n```", "```go\nMontreal\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"os\"\n     \"golang.org/x/text/encoding/ianaindex\"\n)\nfunc main() {\n     enc, err := ianaindex.MIME.Encoding(\"US-ASCII\")\n     if err != nil {\n            panic(err)\n     }\n     b, err := os.ReadFile(\"ascii.txt\")\n     if err != nil {\n            panic(err)\n     }\n     decoder := enc.NewDecoder()\n     encoded, err := decoder.Bytes(b)\n     if err != nil {\n            panic(err)\n     }\n     fmt.Println(string(encoded))\n}\n```", "```go\nfor i:=0;i<len(str);i++ {\n  fmt.Print(str[i],\" \")\n}\n```", "```go\nfor index, c:=range str {\n  fmt.Print(c,\" \")\n}\n```", "```go\nstrBytes := []byte(str)\nstrRunes := []rune(str)\n```", "```go\nstr:=\"Hello 世界\"\nfor i:=0;i<len(str);i++ {\n  fmt.Print(str[i],\" \")\n}\n```", "```go\n72 101 108 108 111 32 228 184 150 231 149 140\n```", "```go\nfor i,r:=range str {\n  fmt.Printf(\"( %d %d %s)\", i, r, string(r))\n}\n```", "```go\n(0 72 H)(1 101 e)(2 108 l)(3 108 l)(4 111 o)(5 32  )(6 19990 世)(9 30028 界)\n```", "```go\nimport (\n  \"unicode/utf8\"\n  \"fmt\"\n)\nstr:=[]byte(\"Hello 世界\")\nfor i:=0;i<len(str); {\n  r, n:=utf8.DecodeRune(str[i:])\n  fmt.Print(\"(\",i,r, \" \",string(r),\")\")\n  i+=n\n}\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"strings\"\n)\nfunc main() {\n     fmt.Println(strings.Split(\"a,b,c,d\", \",\"))\n    // [\"a\", \"b\", \"c\", \"d\"]\n     fmt.Println(strings.Split(\"a, b, c, d\", \",\"))\n    // [\"a\", \" b\", \" c\", \" d\"]\n     fmt.Println(strings.Fields(\"a    b   c  d  \"))\n    // [\"a\", \"b\", \"c\", \"d\"]\n     fmt.Println(strings.Split(\"a---b---c--d--\", \"-\"))\n    // [\"a\", \"\", \"\", \"b\", \"\", \"\", \"c\", \"\", \"d\", \"\", \"\"]\n}\n```", "```go\npackage main\nimport (\n     \"bufio\"\n     \"fmt\"\n     \"strings\"\n)\nconst input = `This is a string\nthat has 3\nlines.`\nfunc main() {\n     lineScanner := bufio.NewScanner(strings.NewReader(input))\n     line := 0\n     for lineScanner.Scan() {\n          text := lineScanner.Text()\n          line++\n          fmt.Printf(\"Line %d: %s\\n\", line, text)\n     }\n     if err := lineScanner.Err(); err != nil {\n          panic(err)\n     }\n     wordScanner := bufio.NewScanner(strings.NewReader(input))\n     wordScanner.Split(bufio.ScanWords)\n     word := 0\n     for wordScanner.Scan() {\n          text := wordScanner.Text()\n          word++\n          fmt.Printf(\"word %d: %s\\n\", word, text)\n     }\n     if err := wordScanner.Err(); err != nil {\n          panic(err)\n     }\n}\n```", "```go\nLine 1: This is a string\nLine 2: that has 3\nLine 3: lines.\nword 1: This\nword 2: is\nword 3: a\nword 4: string\nword 5: that\nword 6: has\nword 7: 3\nword 8: lines.\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"strings\"\n)\nfunc main() {\n     fmt.Println(strings.TrimRight(\"Break-------\", \"-\"))\n    // Break\n     fmt.Println(strings.TrimRight(\"Break with spaces-- -- --\", \"- \"))\n    // Break with spaces\n     fmt.Println(strings.TrimSuffix(\"file.txt\", \".txt\"))\n    // file\n     fmt.Println(strings.TrimLeft(\" \\t   Indented text\", \" \\t\"))\n    // Indented text\n     fmt.Println(strings.TrimSpace(\" \\t \\n  Indented text  \\n\\t\"))\n    // Indented text\n}\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"regexp\"\n)\nvar integerRegexp = regexp.MustCompile(\"^[0-9]+$\")\nfunc main() {\n     fmt.Println(integerRegexp.MatchString(\"123\"))   // true\n     fmt.Println(integerRegexp.MatchString(\" 123 \")) // false\n}\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"regexp\"\n)\nfunc main() {\n     re := regexp.MustCompile(`[0-9]+`)\n     fmt.Println(re.FindAllString(\"This regular expression find \n     numbers, like 1, 100, 500, etc.\", -1))\n}\n```", "```go\n[1 100 500]\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"regexp\"\n)\nfunc main() {\n     re := regexp.MustCompile(`^(\\w+)=(\\w+)$`)\n     result := re.FindStringSubmatch(`property=12`)\n     fmt.Printf(\"Key: %s value: %s\\n\", result[1], result[2])\n     result = re.FindStringSubmatch(`x=y`)\n     fmt.Printf(\"Key: %s value: %s\\n\", result[1], result[2])\n}\n```", "```go\nKey: property value: 12\nKey: x value: y\n```", "```go\npackage main\nimport (\n     \"fmt\"\n     \"regexp\"\n)\nfunc main() {\n     // Find numbers, capture the first digit\n     re := regexp.MustCompile(`([0-9])[0-9]*`)\n     fmt.Println(re.ReplaceAllString(\"This example replaces \n     numbers  with 'x': 1, 100, 500.\", \"x\"))\n    // This example replaces numbers  with 'x': x, x, x.\n     fmt.Println(re.ReplaceAllString(\"This example replaces all \n     numbers with their first digits: 1, 100, 500.\", \"${1}\"))\n    // This example replaces all numbers with their first digits: 1, \n    // 1, 5.\n}\n```", "```go\n    logfile: {{.env.logDir}}/log.json\n    ```", "```go\npackage main\nimport (\n     \"os\"\n     \"text/template\"\n)\ntype Book struct {\n     Title   string\n     Author  string\n     PubYear int\n}\nconst tp = `The book \"{{.Title}}\" by {{.Author}} was published in {{.PubYear}}.\n`\nfunc main() {\n     book1 := Book{\n          Title:   \"Pride and Prejudice\",\n          Author:  \"Jane Austen\",\n          PubYear: 1813,\n     }\n     book2 := Book{\n          Title:   \"The Lord of the Rings\",\n          Author:  \"J.R.R. Tolkien\",\n          PubYear: 1954,\n     }\n     tmpl, err := template.New(\"book\").Parse(tp)\n     if err != nil {\n          panic(err)\n     }\n     tmpl.Execute(os.Stdout, book1)\n     tmpl.Execute(os.Stdout, book2)\n}\n```", "```go\nThe book \"Pride and Prejudice\" by Jane Austen was published in 1813.\nThe book \"The Lord of the Rings\" by J.R.R. Tolkien was published in 1954.\n```", "```go\ntmpl.Execute(os.Stdout,map[string]any {\n   \"Title\":\"Pride and Prejudice\",\n   \"Author\":  \"Jane Austen\",\n   \"PubYear\": 1813,\n   })\n```", "```go\n    {{ range <slice> }}\n      // Here, {{.}} refers the subsequent elements of the slice/array\n    {{end}}\n    ```", "```go\n    {{ range <map> }}\n      // Here, {{.}} refers to the subsequent values (not keys) of the map\n      // The iteration order of the map is not guaranteed\n    {{end}}\n    ```", "```go\n    {{ range $key, $value := <map> }}\n      // Here, {{$key}} and {{$value}} are variables that are set to\n      // subsequent key-value pairs of the map\n    {{end}}\n    ```", "```go\nconst tpIter = `{{range .}}\nThe book \"{{.Title}}\" by {{.Author}} was published in {{.PubYear}}.\n{{end}}`\n```", "```go\n...\ntmpl, err = template.New(\"bookIter\").Parse(tpIter)\nif err != nil {\n    panic(err)\n}\ntmpl.Execute(os.Stdout, []Book{book1, book2})\n```", "```go\nThe book \"Pride and Prejudice\" by Jane Austen was published in 1813.\nThe book \"The Lord of the Rings\" by J.R.R. Tolkien was published in 1954.\n```", "```go\ntmpl.Execute(os.Stdout, map[int]Book{\n  1: book1,\n  2: book2,\n  })\n```", "```go\n$name := value\n```", "```go\n{{ $disabled := false }}\n{{ if eq .Selection \"1\"}}\n {{ $disabled = true }}\n{{ end }}\n<input type=\"text\" value=\"{{.Value1}}\" {{if $disabled}}disabled{{end}}>\n<input type=\"text\" value=\"{{.Value2}}\" {{if $disabled}}disabled{{end}}>\n```", "```go\ndisabled := false\nif data.Selection == \"1\" {\n  disabled=true\n}\n```", "```go\ntype Book struct {\n     Title    string\n     Author   string\n     Editions []Edition\n}\ntype Edition struct {\n     Edition int\n     PubYear int\n}\nconst tp = `{{range $bookIndex, $book := .}}\n{{$book.Author}}\n{{range $book.Editions}}\n  {{$book.Title}} Edition: {{.Edition}} {{.PubYear}}\n{{end}}\n{{end}}`\n```", "```go\n{{range .}}\n  {{if gt . 1}}\n    {{.}}\n  {{end}}\n{{end}}\n```", "```go\n{{range . -}}\n  {{ if gt . 1 }}\n    {{- . }}\n  {{end -}}\n{{end -}}\n```", "```go\n2\n  3\n  4\n  5\n```", "```go\n    {{- . }}\n__{{end -}}\n```", "```go\n{{range . -}}\n{{ if gt . 1 }}\n  {{- . }}\n{{end -}}\n{{end -}}\n```", "```go\n2\n3\n4\n5\n```", "```go\n{{define \"template1\"}}\n  ...\n{{end}}\n{{define \"template2\"}}\n ...\n{{end}}\n```", "```go\n{{template \"template1\" .}}\n{{range .List}}\n  {{template \"template2\" .}}\n{{end}}\n```", "```go\npackage main\nimport (\n     \"os\"\n     \"text/template\"\n)\nconst tp = `{{define \"line\"}}\n{{.Title}} {{.Author}} {{.PubYear}}\n{{end}}\nBook list:\n{{range . -}}\n  {{template \"line\" .}}\n{{end -}}\n`\ntype Book struct {\n     Title   string\n     Author  string\n     PubYear int\n}\nvar books = []Book{\n     {\n          Title:   \"Pride and Prejudice\",\n          Author:  \"Jane Austen\",\n          PubYear: 1813,\n     },\n     {\n          Title:   \"To Kill a Mockingbird\",\n          Author:  \"Harper Lee\",\n          PubYear: 1960,\n     },\n     {\n          Title:   \"The Great Gatsby\",\n          Author:  \"F. Scott Fitzgerald\",\n          PubYear: 1925,\n     },\n     {\n          Title:   \"The Lord of the Rings\",\n          Author:  \"J.R.R. Tolkien\",\n          PubYear: 1954,\n     },\n}\nfunc main() {\n     tmpl, err := template.New(\"body\").Parse(tp)\n     if err != nil {\n          panic(err)\n     }\n     tmpl.Execute(os.Stdout, books)\n}\n```", "```go\nconst lineTemplate = `{{.Title}} {{.Author}} {{.PubYear}}`\nconst bodyTemplate = `Book list:\n{{range . -}}\n  {{template \"line\" .}}\n{{end -}}`\nfunc main() {\n     tmpl, err := template.New(\"body\").Parse(bodyTemplate)\n     if err != nil {\n          panic(err)\n     }\n     _, err = tmpl.New(\"line\").Parse(lineTemplate)\n     if err != nil {\n          panic(err)\n     }\n     tmpl.Execute(os.Stdout, books)\n}\n```", "```go\nconst layout=`\n<!doctype html>\n<html lang=\"en\">\n  <head>\n  <title>{{template \"pageTitle\" .}}</title>\n  </head>\n  <body>\n  {{template \"pageHeader\" .}}\n  {{template \"pageBody\" .}}\n  {{template \"pageFooter\" .}}\n  </body>\n</html>\n{{define \"pageTitle\"}}{{end}}\n{{define \"pageHeader\"}}{{end}}\n{{define \"pageBody\"}}{{end}}\n{{define \"pageFooter\"}}{{end}}`\n```", "```go\nconst mainPage=`\n{{define \"pageTitle\"}}Main Page{{end}}\n{{define \"pageHeader\"}}\n<h1>Main page</h1>\n{{end}}\n{{define \"pageBody\"}}\nThis is the page body.\n{{end}}\n{{define \"pageFooter\"}}\nThis is the page footer.\n{{end}}`\n```", "```go\nconst secondPage=`\n{{define \"pageTitle\"}}Second page{{end}}\n{{define \"pageHeader\"}}\n<h1>Second page</h1>\n{{end}}\n{{define \"pageBody\"}}\nThis is the page body for the second page.\n{{end}}`\n```", "```go\nimport (\n  \"html/template\"\n)\nfunc main() {\n     mainPageTmpl := template.Must(template.New(\"body\").Parse(layout))\n     template.Must(mainPageTmpl.Parse(mainPage))\n     secondPageTmpl := template.Must(template.New(\"body\").\n     Parse(layout))\n     template.Must(secondPageTmpl.Parse(secondPage))\n     mainPageTmpl.Execute(os.Stdout, nil)\n     secondPageTmpl.Execute(os.Stdout, nil)\n}\n```", "```go\nmainPage:\n  - layouts/main.html\n  - mainPage.html\n  - fragments/status.html\ndetailPage:\n  - layouts/2col.html\n  - detailPage.html\n  - fragments/status.html\n...\n```"]