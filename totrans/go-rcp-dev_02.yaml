- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Working with Strings
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串操作
- en: String is one of the fundamental data types in Go.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是Go中的基本数据类型之一。
- en: 'Go uses immutable UTF-8-encoded strings. This might be confusing for a new
    developer; after all, this works:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用不可变的UTF-8编码字符串。对于新开发者来说，这可能会令人困惑；毕竟，这可以工作：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Didn’t we just change `x`? Yes, we did. What is immutable here are the `"Hello"`
    and `" World"` strings. So, the string itself is immutable, but the string variable,
    `x`, is mutable. To modify string variables, you create slices of bytes or runes
    (which are mutable), work with them, and then convert them back to a string.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是刚刚修改了`x`吗？是的，我们确实修改了。在这里不可变的是`"Hello"`和`" World"`字符串。所以，字符串本身是不可变的，但字符串变量`x`是可变的。要修改字符串变量，你需要创建字节数组或runes（它们是可变的）的切片，然后与它们一起工作，最后将它们转换回字符串。
- en: UTF-8 is the most common encoding used for web and internet technologies. This
    means that any time you deal with text in a Go program, you deal with UTF-8 strings.
    If you have to process data in a different encoding, you first translate it to
    UTF-8, process it, and encode it back to its original encoding.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8是用于Web和互联网技术的最常见编码。这意味着每次你在Go程序中处理文本时，你都在处理UTF-8字符串。如果你必须以不同的编码处理数据，你首先将其转换为UTF-8，处理它，然后再将其编码回原始编码。
- en: UTF-8 is a variable-length encoding that uses one to four bytes for each codepoint.
    Most codepoints represent a character, but there are some that represent other
    information, such as formatting. This may cause some surprises. For instance,
    the length of a string (i.e., the number of bytes it occupies) is different from
    the number of characters. To find the number of characters in a string requires
    you to count them sequentially. When you slice a string, you have to be careful
    about codepoint boundaries.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: UTF-8是一种变长编码，每个码点使用一个到四个字节。大多数码点代表一个字符，但也有一些代表其他信息，如格式化。这可能会引起一些意外。例如，字符串的长度（即它占用的字节数）与字符数不同。要找到字符串中的字符数，你需要逐个计数。当你切片字符串时，你必须注意码点边界。
- en: Go uses the `rune` type to denote codepoints. So, a string can be seen as a
    sequence of bytes as well as a sequence of runes. This is illustrated in *Figure
    2**.1*. Here, `x` is a string variable that has a pointer to the immutable string,
    which is a sequence of bytes and can also be seen as a sequence of runes. Even
    though UTF-8 is a variable-length encoding, `rune` is a fixed-length 32-bit type
    (`uint32`). Smaller codepoints, like the following character, `H`, is a 32-bit
    decimal, 72, whereas the byte, `H`, is an 8-bit value.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用`rune`类型来表示码点。因此，字符串可以被视为字节序列，也可以被视为rune序列。这如图*图2.1*所示。在这里，`x`是一个字符串变量，它指向不可变的字符串，这是一个字节序列，也可以被视为rune序列。尽管UTF-8是一种变长编码，但`rune`是一个固定长度的32位类型（`uint32`）。较小的码点，如以下字符`H`，是一个32位的十进制数，72，而字节`H`是一个8位值。
- en: '![Figure 2.1 – A string, byte, and rune](img/B21961_02_1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 字符串、字节和rune](img/B21961_02_1.jpg)'
- en: Figure 2.1 – A string, byte, and rune
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 字符串、字节和rune
- en: 'In this chapter, we will look at some common operations involving strings and
    text. The recipes included in this chapter are as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一些涉及字符串和文本的常见操作。本章包含的食谱如下：
- en: Creating strings
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建字符串
- en: Formatting strings
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化字符串
- en: Combining strings
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并字符串
- en: Uppercase, lowercase, and title case comparisons
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大写、小写和标题大小写比较
- en: Dealing with internationalized strings
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理国际化字符串
- en: Working with encodings
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理编码
- en: Iterating bytes and runes of strings
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代字符串的字节和rune
- en: Splitting
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分割
- en: Regular expressions
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Reading strings line by line or word by word
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐行或逐字读取字符串
- en: Trimming
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去除空白
- en: Templates
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板
- en: Creating strings
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建字符串
- en: In this recipe, we will look at how to create strings in a program.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将探讨如何在程序中创建字符串。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Use a string literal. There are two types of string literals in Go:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字符串字面量。Go中有两种字符串字面量：
- en: 'Use interpreted string literals, between the double quotations:'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用解释字符串字面量，用双引号括起来：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With interpreted string literals, you must escape certain characters:'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在解释字符串字面量中，你必须转义某些字符：
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can include Unicode codepoints or hexadecimal bytes, escaped with `''\''`:'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以包括Unicode码点或十六进制字节，使用`\'`转义：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You cannot have newlines or an unescaped double-quote in an interpreted string:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释字符串中，你不能有换行符或未转义的引号：
- en: Use raw string literals, using backticks. A raw string literal can include any
    characters (including newlines) except a backtick. There is no way to escape backticks
    in a raw literal.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用反引号创建原始字符串字面量。原始字符串字面量可以包含任何字符（包括换行符），但不能包含反引号。在原始字面量中无法转义反引号。
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you need to include a backtick in your raw string literal, do this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在原始字符串字面量中包含反引号，请这样做：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Formatting strings
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串格式化
- en: The Go standard library offers multiple ways to substitute values in a text
    template. Here, we will discuss the text formatting utilities in the `fmt` package.
    They offer a simple and convenient way to substitute values in a text template.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Go 标准库提供了多种在文本模板中替换值的方法。在这里，我们将讨论 `fmt` 包中的文本格式化工具。它们提供了一种简单方便的方法来在文本模板中替换值。
- en: How to do it...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Use the `fmt.Print` family of functions to format values
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `fmt.Print` 系列函数来格式化值
- en: '`fmt.Print` will print a value using its default formatting'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmt.Print` 将使用其默认格式打印一个值'
- en: A string value will be printed as is
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串值将按原样打印
- en: A numeric value will be first converted to a string as an integer, a decimal
    number, or by using scientific notation for large exponents
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字值将首先被转换为字符串，作为整数、十进制数，或者使用科学记数法表示大指数
- en: A Boolean value will be printed as `true` or `false`
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值将打印为 `true` 或 `false`
- en: Structured values will be printed as a list of fields
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化值将按字段列表打印
- en: If a `Print` function ends with `ln` (such as `fmt.Println`), a new line will
    be output after the string.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 `Print` 函数以 `ln` 结尾（例如 `fmt.Println`），将在字符串后输出一个新行。
- en: If a `Print` function ends with `f`, the function will accept a format argument,
    which will be used as the template into which it will substitute values.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 `Print` 函数以 `f` 结尾（例如 `fmt.Println`），则该函数将接受一个格式参数，该参数将用作模板，并将值替换到其中。
- en: '`fmt.Sprintf` will format a string and return it.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Sprintf` 将格式化一个字符串并返回它。'
- en: '`fmt.Fprintf` will format a string and write it to `io.Writer`, which can be
    a file, network connection, and so on.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Fprintf` 将格式化一个字符串并将其写入 `io.Writer`，这可以是文件、网络连接等。'
- en: '`fmt.Printf` will format a string and write it to standard output.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Printf` 将格式化一个字符串并将其写入标准输出。'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'All these functions use the `%[options]<verb>` format to consume an argument
    from the argument list. To produce a `%` character in the output, use `%%`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都使用 `%[选项]动词>` 格式从参数列表中消耗一个参数。要在输出中产生一个 `%` 字符，请使用 `%%`：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Combining strings
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串组合
- en: The Go standard library offers multiple ways to build strings from components.
    The best way depends on what type of strings you are dealing with, and how long
    they are. This section shows several ways that strings can be built.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Go 标准库提供了多种从组件构建字符串的方法。最佳方法取决于你处理的是哪种类型的字符串，以及它们的长度。本节展示了构建字符串的几种方法。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To combine a few fixed numbers of strings, or to add runes to another string,
    use the `+` or `+=` operators or `string.Builder`
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要组合少量固定数量的字符串，或向另一个字符串添加 runes，请使用 `+` 或 `+=` 运算符或 `string.Builder`
- en: To build a string algorithmically, use `strings.Builder`
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要算法性地构建一个字符串，请使用 `strings.Builder`
- en: To combine a slice of strings, use `strings.Join`
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要组合字符串切片，请使用 `strings.Join`
- en: To combine parts of URL paths, use `path.Join`
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要组合 URL 路径的一部分，请使用 `path.Join`
- en: To build filesystem paths from path segments, use `filepath.Join`
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从路径段构建文件系统路径，请使用 `filepath.Join`
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To build constant values, or for simple concatenations, use the `+` or `+=`
    operators:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建常量值或进行简单的连接，请使用 `+` 或 `+=` 运算符：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can add runes to a string the same way:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用相同的方式向字符串添加 runes：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Using the `+` operator for strings can be controversial among performance-conscious
    teams. It is correct that the `+` operator may become inefficient because multiple
    additions may create unnecessary temporary strings to store intermediate results.
    It is also correct that, for some use cases, the compiler can generate better
    code than you can write manually. However, unless you use the `+` operator to
    create strings in `for`-loops, they are rarely the cause of your performance problems.
    For example, `x+y` will almost always outperform `fmt.Sprintf("%s%s",x,y)`. When
    in doubt, write a benchmark and measure. Here’s how it appears on my laptop:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在性能意识强烈的团队中，使用 `+` 运算符进行字符串连接可能会引起争议。确实，`+` 运算符可能会变得低效，因为多次添加可能会创建不必要的临时字符串来存储中间结果。同样正确的是，对于某些用例，编译器可以生成比手动编写的更好的代码。然而，除非你在
    `for` 循环中使用 `+` 运算符创建字符串，否则它们很少是性能问题的原因。例如，`x+y` 几乎总是优于 `fmt.Sprintf("%s%s",x,y)`。如果有疑问，请编写基准测试并测量。以下是我笔记本电脑上的结果：
- en: '`BenchmarkXPlusY-12          98628536             ``11.31 ns/op`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '`BenchmarkSprintf-12         12120278``97.70 ns/op`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`BenchmarkBuilder-12         33077902             ``34.89 ns/op`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: For non-trivial cases where you have to add many short strings to build a longer
    one, use `strings.Builder`. Even though `strings.Builder` looks like a convenient
    frontend to a byte slice, it does more than that. It creates strings from the
    underlying byte slice without copying, so it almost always outperforms using a
    byte slice and then creating a string from it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example showing why you should prefer standard library functions
    to third-party libraries or manual optimizations. These functions are aggressively
    optimized and rely on Go internals without creating portability issues:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use `strings.Join` to combine a slice of strings. If you are dealing with filenames
    and you need to combine multiple levels of directories, use `filepath.Join` to
    avoid platform-specific separator characters. `filepath.Join` will use `\` on
    Windows platform and `/` on Linux-based platforms. If you are dealing with URLs
    and need to combine multiple segments, use `path.Join`, which will always use
    `/` to combine parts:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Working with string cases
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with textual data, problems related to string cases arise often.
    Should a text search be case-sensitive or case-insensitive? How do we convert
    a string to lowercase or uppercase? In this section, we will look at some recipes
    to deal with these common problems in a portable way.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Convert strings to uppercase and lowercase using the `strings.ToUpper` and `strings.ToLower`
    functions, respectively.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When dealing with text in languages with special uppercase/lowercase mappings
    (such as Turkish, where “İ” is the uppercase version of “I”), use `strings.ToUpperSpecial`
    and `strings.ToLowerSpecial`
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To convert text to uppercase for use in titles, use `strings.ToTitle`
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To compare strings lexicographically, use comparison operators
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To test the equivalence of strings ignoring case, use `strings.EqualFold`
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Converting a string to uppercase or lowercase is easy:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This program outputs the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But the uppercase/lowercase may differ from language to language. For example,
    there are special cases for some of the Turkic languages:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will print the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, that is not the correct uppercase use for Turkish. Let’s try the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding program will print the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The title case differs from uppercase or lowercase mainly when dealing with
    ligatures and digraphs – that is, more than one character represented as a single
    character, such as `Ǉ` `(U+01C7)`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This program prints the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Uppercase, lowercase, and title case define how to print a string using a particular
    case mapping. These are **case mappings**. **Case folding** is the process of
    transforming text into the same case for comparison purposes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'For lexicographical case-sensitive comparisons, use the relational operators:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To compare two Unicode strings in a case-insensitive way, use `strings.EqualFold`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要以不区分大小写的方式比较两个 Unicode 字符串，请使用 `strings.EqualFold`：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There’s more...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While the standard library `strings` package includes most of the string comparison
    functions you need, they may not be sufficient when dealing with internationalized
    strings. For example, in many cases, you would want to have `Montréal` and `montreal`
    be considered equal. `strings.EqualFold` will not do that. Many of the supporting
    functions to deal with internalized text processing are in the packages under
    `golang.org/x/text`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然标准库 `strings` 包包括了您需要的几乎所有字符串比较函数，但在处理国际化字符串时，它们可能不足以满足需求。例如，在许多情况下，您可能希望将
    `Montréal` 和 `montreal` 视为相等。`strings.EqualFold` 无法做到这一点。许多用于处理内部文本处理的辅助函数都在 `golang.org/x/text`
    下的包中。
- en: Unicode offers multiple ways to represent a given string. The `é` in `Montréal`
    can be represented as a single rune, `\u00e9` or `e`, followed by an acute accent,
    `e\u0301`. `\u0301` is the “combining acute accent,” `◌́``,` and it modifies the
    codepoint that comes before it. According to the Unicode standard, `é` and `e`
    + `◌́` are “canonically equivalent.” There is also a compatibility equivalence,
    such as `\ufb00`, representing `ff` as a single codepoint, and the `ff` sequence.
    Canonically equivalent sequences are also compatible, but not all compatible sequences
    are canonically equivalent.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode 提供了多种表示给定字符串的方法。例如，`Montréal` 中的 `é` 可以表示为一个单独的字符，`\u00e9` 或 `e`，后面跟着一个重音符号，`e\u0301`。`\u0301`
    是“组合重音符号”，“◌́”或“`”和它修改了它前面的代码点。根据 Unicode 标准，`é` 和 `e` + `◌́` 是“规范等价”的。也存在兼容等价，例如
    `\ufb00`，表示 `ff` 为单个代码点，以及 `ff` 序列。规范等价序列也是兼容的，但并非所有兼容序列都是规范等价的。
- en: 'So, if you need to remove diacritics (i.e., nonspacing marks) from text, you
    can decompose it, remove the diacritics, and then compose it as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您需要从文本中移除变音符号（即非间隔符号），您可以将其分解，移除变音符号，然后按以下方式重新组合：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The above program will print the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序将打印以下内容：
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Working with encodings
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理编码
- en: If there is a chance that your program will have to work with data produced
    by disparate systems, you should be aware of different text encodings. This is
    a huge topic, but this section should provide some pointers to scratch the surface.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的程序有可能需要处理由不同系统产生的数据，您应该了解不同的文本编码。这是一个很大的话题，但本节应该提供一些线索来触及表面。
- en: How to do it...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Use the `golang.org/x/text/encoding` package to deal with different encodings.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `golang.org/x/text/encoding` 包来处理不同的编码。
- en: 'To find an encoding by name, use one of the following:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要按名称查找编码，请使用以下之一：
- en: '`golang.org/x/text/encoding/ianaindex`'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`golang.org/x/text/encoding/ianaindex`'
- en: '`golang.org/x/text/encoding/htmlindex`'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`golang.org/x/text/encoding/htmlindex`'
- en: Once you have an encoding, use it to translate text to and from UTF-8.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦您有了编码，就可以使用它将文本转换为 UTF-8 或从 UTF-8 转换文本。
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Use one of the indexes to find an encoding. Then, use that encoding to read/write
    data:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其中一个索引来查找编码。然后，使用该编码来读取/写入数据：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Iterating bytes and runes of strings
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代字符串的字节和字符
- en: Go strings can be seen as a sequence of bytes, or as a sequence of runes. This
    section shows how you can iterate a string either way.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言的字符串可以看作是字节序列，或者看作是字符序列。本节展示了如何以这两种方式迭代字符串。
- en: How to do it...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To iterate the bytes of a string, use indexes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要迭代字符串的字节，使用索引：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To iterate the runes of a string, use `range`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要迭代字符串的字符，使用 `range`：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A Go string is a slice of bytes, so you would expect to be able to write a
    for-loop to iterate the bytes and runes of a string. You might think that you
    can do the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言的字符串是字节切片，因此您可能会认为可以编写一个 for 循环来迭代字符串的字节和字符。您可能会认为可以这样做：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: However, converting a string to a slice of bytes or a slice of runes is an expensive
    operation. The first one creates a writeable copy of the bytes of the `str` string,
    and the second one creates a writeable copy of the runes of `str`. Remember that
    `rune` is `uint32`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将字符串转换为字节数组或字符数组是一个昂贵的操作。第一个操作创建了 `str` 字符串字节的可写副本，第二个操作创建了 `str` 字符串字符的可写副本。请记住，`rune`
    是 `uint32`。
- en: 'There are two forms of for-loop to iterate the elements of a string. The following
    for-loop will iterate the bytes of a string:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种形式的 for 循环可以迭代字符串的元素。以下 for 循环将迭代字符串的字节：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Also, note that `str[i]` will give you the i’th byte, not the i’th rune.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，`str[i]` 将为您提供第 i 个字节，而不是第 i 个字符。
- en: 'The following form iterates the runes of a string:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下形式迭代字符串的rune：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note the indexes – they go in a sequence of 0, 1, 2, 3, 4, 5, 6, 9\. This is
    because `str[6]` contains a rune of 3 bytes, and so does `str[9]`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意索引 - 它们按照0、1、2、3、4、5、6、9的顺序排列。这是因为`str[6]`包含一个3字节的rune，同样`str[9]`也是。
- en: 'When you are dealing with `[]byte` instead of a string, you can emulate the
    rune iteration, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理的是`[]byte`而不是字符串时，你可以模拟rune迭代，如下所示：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `utf8.DecodeRune` function decodes the next rune from the byte slice and
    returns that rune and the number of bytes consumed. This way, you can decode the
    runes of a byte slice without first converting it to a string.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`utf8.DecodeRune`函数从字节切片中解码下一个rune，并返回该rune以及消耗的字节数。这样，你可以在不首先将其转换为字符串的情况下解码字节切片中的rune。'
- en: Splitting
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分割
- en: The `strings` package offers convenient functions to split a string to get a
    slice of strings.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings`包提供了方便的函数来分割字符串以获取字符串切片。'
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: To split a string into components using a delimiter, use `strings.Split`.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用分隔符将字符串分割成组件，请使用`strings.Split`。
- en: To split the space-separated components of a string, use `strings.Fields`.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要分割字符串中由空格分隔的组件，请使用`strings.Fields`。
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If you need to parse a string delimited with a fixed delimiter, use `strings.Split`.
    If you need to parse the space-separated sections of a string, use `strings.Fields`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要解析由固定分隔符分隔的字符串，请使用`strings.Split`。如果你需要解析字符串中的空格分隔部分，请使用`strings.Fields`：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that `strings.Split` may cause some surprises when the delimiter is repeated.
    For instance, with `"-"` as the delimiter, `"a---b"` splits into `"a"`, `""`,
    `""`, and `"b"`. The two empty strings are those between the first and second
    `"-"`, and the second and third `"-"`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当分隔符重复时，`strings.Split`可能会导致一些意外。例如，使用`"-"`作为分隔符时，`"a---b"`会分割成`"a"`、`""`、`""`和`"b"`。这两个空字符串是第一个和第二个`"-"`之间以及第二个和第三个`"-"`之间的。
- en: Reading strings line by line, or word by word
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐行或逐字读取字符串
- en: There are many use cases for processing strings in a stream, such as when dealing
    with large text or user input. This recipe shows the use of `bufio.Scanner` for
    this purpose.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大量文本或用户输入时，有许多使用字符串流处理的使用场景。这个配方展示了如何使用`bufio.Scanner`来完成这个目的。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Use `bufio.Scanner` for reading lines, words, or custom blocks.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`bufio.Scanner`读取行、单词或自定义块。
- en: Create a `bufio.Scanner` instance
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`bufio.Scanner`实例
- en: Set the split method
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置分割方法
- en: Read scanned tokens in a for-loop
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在for循环中读取扫描的标记
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `Scanner` works like an iterator – every call to `Scan()` method will return
    `true` if it parsed the next token, or `false` if there are no more tokens. The
    token can be obtained by the `Text()` method:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scanner`的工作方式类似于迭代器 - 每次调用`Scan()`方法都会返回`true`，如果它解析了下一个标记，或者返回`false`，如果没有更多的标记。可以通过`Text()`方法获取标记：'
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE34]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Trimming the ends of a string
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修剪字符串的末尾
- en: User input is usually messy, including additional spaces before or after the
    text that matters. This recipe shows how to use the string trimming functions
    for this purpose.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入通常很杂乱，包括在重要文本前后添加额外的空格。这个配方展示了如何使用字符串修剪函数来完成这个目的。
- en: How to do it...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Use the `strings.Trim` family of functions, as shown here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如这里所示的`strings.Trim`函数族：
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Regular expressions
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: A regular expression offers efficient methods to ensure that textual data matches
    a given pattern, searches for patterns, extracts, and replaces parts of text.
    Usually, you compile a regular expression once and then use that compiled regular
    expression many times to efficiently validate, search, extract, or replace parts
    of strings.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式提供了确保文本数据与给定模式匹配、搜索模式、提取和替换文本部分的高效方法。通常，你编译一个正则表达式一次，然后多次使用该编译后的正则表达式来有效地验证、搜索、提取或替换字符串的部分。
- en: Validating input
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证输入
- en: Format validation is the process of ensuring that data coming from user input
    or other sources is in a recognized format. Regular expressions can be an effective
    tool for such validation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 格式验证是确保来自用户输入或其他来源的数据处于可识别格式的过程。正则表达式可以成为此类验证的有效工具。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Use precompiled regular expressions to validate input values that should fit
    a pattern.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预编译的正则表达式来验证应该符合模式的输入值。
- en: '[PRE36]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To ensure an exact match, make sure you include the beginning (`^`) and end-of-text
    markers (`$`); otherwise, you will end up accepting input **containing** strings
    that match the regular expression.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保精确匹配，请确保包含开始（`^`）和文本结束标记（`$`）；否则，您将接受匹配正则表达式的字符串**包含**的输入。
- en: Not all types of input are suitable for regular expression validation. Some
    inputs have complicated regular expressions (such as the one for emails or password
    policies), so custom validations may work better for those.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有类型的输入都适合正则表达式验证。一些输入具有复杂的正则表达式（例如电子邮件或密码策略的正则表达式），因此对于这些输入，自定义验证可能更有效。
- en: Searching patterns
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索模式
- en: You can use a regular expression to search through textual data to locate strings
    matching a pattern.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用正则表达式遍历文本数据以定位匹配模式的字符串。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Use the `regexp.Find` family of methods to search for substrings matching a
    pattern.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `regexp.Find` 函数族来搜索匹配模式的子字符串。
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here is the output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Extracting data from strings
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从字符串中提取数据
- en: You can use a regular expression to locate and extract text that occurs within
    a pattern.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用正则表达式定位和提取在模式中出现的文本。
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Use capture groups to extract substrings that match a pattern.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用捕获组提取匹配模式的子字符串。
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '[PRE39]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here is the output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let’s look at this regular expression:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个正则表达式：
- en: '`^(\w+)`: A string composed of one or more word characters at the beginning
    of the line (capture group 1)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`^(\w+)`：行首由一个或多个单词字符组成的字符串（捕获组 1）'
- en: '`=`: An “`=`” sign'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=`：一个“`=`”符号'
- en: '`(\w+)$`: A string composed of one or more word characters (capture group 2),
    and then the end of line'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(\w+)$`：由一个或多个单词字符（捕获组 2）组成的字符串，然后是行尾'
- en: Note that the capture groups are in parentheses.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，捕获组位于括号中。
- en: The `FindStringSubmatch` method returns the matching string as the 0th element
    of the slice, and then each capture group. Using the capture groups, you can extract
    data as above.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindStringSubmatch` 方法返回匹配的字符串作为切片的0th元素，然后是每个捕获组。使用捕获组，您可以像上面那样提取数据。'
- en: Replacing parts of a string
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换字符串的部分
- en: You can use a regular expression to search through text, replacing parts that
    match a pattern with other strings.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用正则表达式遍历文本，用其他字符串替换匹配模式的部分。
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the `Replace` family of functions to replace the patterns in a string with
    something else:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Replace` 函数族将字符串中的模式替换为其他内容：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Templates
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: 'Templates are useful for generating data-driven textual output. The `text/template`
    package can be used in the following contexts:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 模板对于生成数据驱动的文本输出非常有用。`text/template` 包可以在以下环境中使用：
- en: '`env` map variable to create environment-sensitive configurations'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `env` 映射变量创建环境敏感的配置
- en: '[PRE42]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '**Reporting**: Use templates to generate output for command-line applications
    and reports'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**报告**：使用模板为命令行应用程序和报告生成输出'
- en: '`html/template` package provides HTML-safe templating functionality for template-based
    HTML generation to build web applications'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`html/template` 包提供了基于模板的HTML生成功能，用于构建Web应用程序'
- en: Value substitution
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值替换
- en: The main use of templates is inserting data elements into structured text. This
    section describes how you can insert values computed in a program into a template.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的主要用途是将数据元素插入到结构化文本中。本节描述了如何将程序中计算出的值插入到模板中。
- en: How to do it...
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Use the `{{.name}}` syntax to substitute a value in a template.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `{{.name}}` 语法在模板中替换一个值。
- en: 'The following code segment executes a template using different inputs:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码段使用不同的输入执行模板：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding program outputs the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序输出以下内容：
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `template.New(name)` call creates an empty template with the given name
    (there’ll be more on this later). The returned template object represents a template
    body (which is empty after the `New()` call). The Go template engine uses a template
    representing the body, as well as zero or more named templates that are associated
    with that body. The `tmpl.Parse(tp)` call parses the `tp` template as the body
    for the given `named` template. If there are other template definitions in `tp`
    that are defined using the `{{define}}` construct, those are kept within `tmpl`
    as well.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`template.New(name)` 调用创建了一个具有给定名称的空模板（稍后会有更多关于这个的介绍）。返回的模板对象代表一个模板体（在 `New()`
    调用后是空的）。Go 模板引擎使用代表体的模板，以及零个或多个与该体关联的命名模板。`tmpl.Parse(tp)` 调用将 `tp` 模板解析为给定 `named`
    模板的体。如果 `tp` 中有其他使用 `{{define}}` 构造定义的模板定义，那些也会保留在 `tmpl` 中。'
- en: '`tmpl.Execute(os.Stdout,book1)` executes the template, writing the output to
    `os.Stdout`. The second argument, `book1`, is the data used to evaluate the template.
    You access it by "`.`". So, for instance, when `{{.Author}}` is evaluated, the
    template engine reads `book1.Author`, using reflection, and outputs its value.
    In other words, `.` is `book1` for the first `tmpl.Execute` call, and `.` is `book2`
    for the second `tmpl.Execute` call in the preceding example.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmpl.Execute(os.Stdout,book1)` 执行模板，将输出写入 `os.Stdout`。第二个参数 `book1` 是用于评估模板的数据。您可以通过
    "`.`" 访问它。因此，例如，当 `{{.Author}}` 被评估时，模板引擎读取 `book1.Author`，使用反射，并输出其值。换句话说，`.`
    对于第一个 `tmpl.Execute` 调用是 `book1`，而对于前面示例中的第二个 `tmpl.Execute` 调用，`.` 是 `book2`。'
- en: 'Since this is done using reflection, the following produces the same output:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是使用反射完成的，以下产生相同的输出：
- en: '[PRE45]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Iteration
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代
- en: A template can include tabular data or lists that are populated using slices
    or maps computed in a program. Templates provide an iteration mechanism to render
    such content.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可以包含使用程序中计算的切片或映射填充的表格数据或列表。模板提供了一种迭代机制来渲染此类内容。
- en: How to do it...
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'For slices/arrays, do the following:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于切片/数组，执行以下操作：
- en: '[PRE46]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'For maps, do the following:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于映射，执行以下操作：
- en: '[PRE47]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Alternatively, do the following:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，执行以下操作：
- en: '[PRE48]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works...
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Use `range` to loop through slices and maps.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `range` 遍历切片和映射。
- en: 'Modify the preceding example with the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方式修改前面的示例：
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, modify it with the following too:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下方式修改它：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here is the output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE51]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, note that `.` is a slice of books, so we can range through the elements
    of it. When evaluating the section within `{{range .}}`, `.` is set to successive
    elements of the slice – during the first iteration, `.` is `book1`, and during
    the second iteration, `.` is `book2`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请注意，`.` 是书籍的切片，因此我们可以遍历其元素。在评估 `{{range .}}` 内部的部分时，`.` 被设置为切片的连续元素 - 在第一次迭代期间，`.`
    是 `book1`，在第二次迭代期间，`.` 是 `book2`。
- en: We will deal with the empty lines shortly.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将很快处理空行。
- en: 'The same thing happens for maps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 对于映射，发生相同的事情：
- en: '[PRE52]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Variables and scope
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量和作用域
- en: It is often necessary to define local variables within templates to keep computed
    values. The variables defined in templates follow similar scoping rules as variables
    defined in functions – the `{{range}}`, `{{if}}`, `{{with}}` and `{{define}}`
    blocks create a new scope.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要在模板中定义局部变量以保留计算值。在模板中定义的变量遵循与在函数中定义的变量类似的范围规则 - `{{range}}`、`{{if}}`、`{{with}}`
    和 `{{define}}` 块创建一个新的作用域。
- en: A variable defined in a scope is accessible in all the scopes contained within
    that scope, but it is not accessible outside of it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在作用域中定义的变量可以在该作用域包含的所有作用域中访问，但不能在作用域外部访问。
- en: How to do it...
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: '`.` (**dot**) refers to the “current object,” as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`.`（点）代表“当前对象”，如下所示：'
- en: At the top-level scope, `.` refers to the object passed as the `data` argument
    of the `Execute` method
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在顶级作用域中，`.` 指的是作为 `Execute` 方法 `data` 参数传递的对象
- en: Inside a `{{range}}`, `.` refers to the current slice/array/map element
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `{{range}}` 内部，`.` 指的是当前的切片/数组/映射元素
- en: Inside a `{{with <expr>}}`, `.` refers to the value of `<expr>`
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `{{with <expr>}}` 内部，`.` 指的是 `<expr>` 的值
- en: Inside a `{{define}}` block, `.` refers to the value of the object passed into
    `{{template "``name" <object>}}`
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `{{define}}` 块内部，`.` 指的是传递给 `{{template "``name" <object>}}` 的对象的值
- en: '`.X` refers to the member named `X` in the current object:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.X` 指的是当前对象中名为 `X` 的成员：'
- en: If `.` is a map, then `.X` evaluates to the element with the `X` key
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `.` 是映射，那么 `.X` 评估为具有 `X` 键的元素
- en: If `.` is a struct, then `.X` evaluates to the `X` member variable
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `.` 是一个结构体，那么 `.X` 评估为 `X` 成员变量
- en: Tip
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note the emphasis on `X` in the current object. If the current object is a struct,
    reflection can only access the exported fields, so you cannot access unexported
    variables. However, if the current object is a map, this becomes a key lookup,
    and there is no such restriction. In other words, `{{.name}}` will only work if
    `.` is a map, but `{{.Name}}` will work for a `.` struct and a `.` map.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当前对象中 `X` 的强调。如果当前对象是一个结构体，反射只能访问导出的字段，因此你不能访问未导出的变量。然而，如果当前对象是一个映射，这变成了一次键查找，并且没有这样的限制。换句话说，`{{.name}}`
    只在 `.` 是映射时才有效，但 `{{.Name}}` 对 `.` 结构体和 `.` 映射都有效。
- en: 'Define a new local variable that is visible in the current scope using the
    following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方式定义一个在当前作用域中可见的新局部变量：
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Use the `$name` notation to assign a computed value to a variable instead of
    recomputing it every time:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `$name` 语法将计算值赋给变量，而不是每次都重新计算它：
- en: '[PRE54]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The first section of this template is equivalent to the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板的第一个部分等同于以下内容：
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`$` is necessary as the first character of the variable name. Without that,
    the template engine will think `name` is a function.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`$` 是变量名的第一个字符所必需的。如果没有它，模板引擎会认为 `name` 是一个函数。'
- en: There’s more – nested loops and conditionals
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多的是 – 嵌套循环和条件
- en: 'When you are dealing with nested loops or conditions, scoping can become a
    challenge. Every `{{range}}`, `{{if}}`, and `{{with}}` create a new scope. Variables
    defined within a scope are only accessible in that scope and all scopes enclosed
    in it. You can use this to create nested loops and still access variables defined
    in the enclosing scope:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理嵌套循环或条件时，作用域可能会成为一个挑战。每个 `{{range}}`、`{{if}}` 和 `{{with}}` 都创建一个新的作用域。在作用域内定义的变量只在该作用域及其所有封装的作用域中可访问。你可以使用这个特性来创建嵌套循环并仍然访问封装作用域中定义的变量：
- en: '[PRE56]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this template, the first `range` defines the loop index, `$bookIndex`, and
    the loop variable, `$book`, that can be used in the nested scopes. At this stage,
    `.` points to the slice of `Book` fields. The next `range` iterates the current
    `$book.Editions` – that is, `.` now points to the successive elements of the `Book.Editions`
    slice. The nested template accesses both the `Edition` fields and the `Book` fields
    from the enclosing scope.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模板中，第一个 `range` 定义了循环索引 `$bookIndex` 和循环变量 `$book`，它们可以在嵌套作用域中使用。在这个阶段，`.`
    指向 `Book` 字段的切片。下一个 `range` 遍历当前的 `$book.Editions` – 即，`.` 现在指向 `Book.Editions`
    切片的连续元素。嵌套模板从封装作用域中访问 `Edition` 字段和 `Book` 字段。
- en: Dealing with empty lines
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理空行
- en: Template actions (i.e., the code elements placed in a template) may result in
    unwanted empty spaces and lines. The Go template system offers some mechanisms
    to deal with these unwanted spaces.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 模板操作（即放置在模板中的代码元素）可能会导致不想要的空格和行。Go 模板系统提供了一些机制来处理这些不想要的空格。
- en: How to do it...
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Use `-` next to the template delimiter:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板分隔符旁边使用 `-`：
- en: '`{{-` will remove all spaces/tabs/newlines that were output before this template
    element'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{{-` 将会移除在此模板元素之前输出的所有空格、制表符和换行符'
- en: '`-}}` will remove all spaces/tabs/newlines that come after this template element'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-}}` 将会移除在此模板元素之后的所有空格、制表符和换行符'
- en: 'If a template directive produces output, such as the value of a variable, it
    will be written to the output stream. But if a template directive does not generate
    any output, such as a `{{range}}` or `{{if}}` statement, then it will be replaced
    with empty strings. And if those statements are on a line by themselves, those
    lines will be written to the output as well, like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模板指令产生了输出，例如变量的值，它将被写入输出流。但如果模板指令没有生成任何输出，例如一个 `{{range}}` 或 `{{if}}` 语句，那么它将被替换为空字符串。如果这些语句单独占一行，那么这些行也将被写入输出，如下所示：
- en: '[PRE57]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This template will produce an output every four lines. When there is nothing
    to output, it will print three empty lines.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板每四行产生一次输出。如果没有内容输出，它将打印出三行空行。
- en: 'Fix this by using “`-`” inside the `{{ }}` constructs. `{{ -}}` will remove
    all empty space (including lines) coming after, and `{{- }}` will remove all empty
    spaces before, as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `{{ }}` 构造中使用 “`-`” 来修复这个问题。`{{ -}}` 将移除之后的所有空格（包括行），而 `{{- }}` 将移除之前的所有空格，如下所示：
- en: '[PRE58]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here is the output:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '[PRE59]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'How can we get rid of the spaces at the beginning of each line? First, we have
    to find out why they are there, which is shown here:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何去除每行的开头空格？首先，我们必须找出它们为什么在那里，如下所示：
- en: '[PRE60]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The first “-” will remove all spaces before the value. We cannot put `-}}`
    in this line, or `{{- end}}`, as these solutions would remove line feeds as well.
    But we can do this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This will produce the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Template composition
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As templates grow, they may become repetitive. To reduce such repetition, the
    Go template system offers named blocks (components) that can be reused within
    a template, just like functions in a program. Then, the final template can be
    composed of these components.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create template “components” that you can reuse in multiple contexts.
    To define a named template, use the `{{define "``name"}}` construct:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, call that template using the `{{template "name" .}}` construct as if
    it is a function with a single argument:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: How it works...
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example prints a book list using a named template:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `tmpl` template contains two templates in this example – the template named
    `"body"` (because it is created with `template.New("body")`), and the template
    named `"line"` (because the template contains `{{define "line"}}`.) For each element
    of the slice, the `"body"` template instantiates `"line"` with successive elements
    of the `books` slice.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'This is equivalent to the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Template composition – layout templates
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing web applications, it is usually desirable to have a few templates
    specifying page layouts. Complete web pages are constructed by combining page
    components, developed as independent templates using this layout. Unfortunately,
    the Go template engine forces you to think of alternative solutions because Go
    template references are static. This means you would need a separate layout template
    for each page.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: But there are alternatives.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: I’ll show you a basic idea that demonstrates how template composition can be
    used so that you can extend it, based on your use case, or how to use an available
    third-party library that does this. The crucial idea in composition using layout
    templates is that if you define a new template using an already-defined template
    name, the new definition overrides the older one.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a layout template. Use empty templates or templates with default content
    for the sections you will redefine for each occasion.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a configuration system where you define every possible composition. Each
    composition includes the layout template, as well as the templates defining the
    sections in the layout template.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile each composition as a separate template.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a layout template:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This layout template defines four named templates with no content. For each
    new page, we can recreate these components:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can define a second page, similar to the first one:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we compose `layout` with `mainPage` to get the template for the main page,
    and then `layout` with `secondPage` to get the template for the second page:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You can extend this pattern to build a sophisticated web application using
    layout templates, as well as a configuration file defining all the valid compositions
    of templates for each page. Such a YAML file looks like the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: When the application starts, you build each template for `mainPage` and `detailPage`
    by parsing its constituent templates in the given order, putting each template
    in a map. Then, you can look up the template name you want to generate and use
    the parsed template.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Go standard library documentation is always your best source for up-to-date
    information and great examples, such as the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[https://pkg.go.dev/strings](https://pkg.go.dev/strings)'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pkg.go.dev/text/template](https://pkg.go.dev/text/template)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pkg.go.dev/html/template](https://pkg.go.dev/html/template)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pkg.go.dev/fmt](https://pkg.go.dev/fmt)'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pkg.go.dev/bufio](https://pkg.go.dev/bufio)'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following links are also useful:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '*Character Model for the World Wide Web: String* *Matching*: [https://www.w3.org/TR/charmod-norm/](https://www.w3.org/TR/charmod-norm/)'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Character Properties, Case Mappings & Names* *FAQ*: [https://unicode.org/faq/casemap_charprop.html](https://unicode.org/faq/casemap_charprop.html)'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RFC7564: PRECIS [https://www.rfc-editor.org/rfc/rfc7564](https://www.rfc-editor.org/rfc/rfc7564)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a great blog post about the Unicode normalization process: [https://go.dev/blog/normalization](https://go.dev/blog/normalization)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For all encoding, internationalization, and Unicode-related problems that are
    not handled by the standard library, take a look at the packages here before searching
    for anything else: [https://pkg.go.dev/golang.org/x/text](https://pkg.go.dev/golang.org/x/text)'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
