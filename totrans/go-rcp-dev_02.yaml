- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: String is one of the fundamental data types in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go uses immutable UTF-8-encoded strings. This might be confusing for a new
    developer; after all, this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Didn’t we just change `x`? Yes, we did. What is immutable here are the `"Hello"`
    and `" World"` strings. So, the string itself is immutable, but the string variable,
    `x`, is mutable. To modify string variables, you create slices of bytes or runes
    (which are mutable), work with them, and then convert them back to a string.
  prefs: []
  type: TYPE_NORMAL
- en: UTF-8 is the most common encoding used for web and internet technologies. This
    means that any time you deal with text in a Go program, you deal with UTF-8 strings.
    If you have to process data in a different encoding, you first translate it to
    UTF-8, process it, and encode it back to its original encoding.
  prefs: []
  type: TYPE_NORMAL
- en: UTF-8 is a variable-length encoding that uses one to four bytes for each codepoint.
    Most codepoints represent a character, but there are some that represent other
    information, such as formatting. This may cause some surprises. For instance,
    the length of a string (i.e., the number of bytes it occupies) is different from
    the number of characters. To find the number of characters in a string requires
    you to count them sequentially. When you slice a string, you have to be careful
    about codepoint boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: Go uses the `rune` type to denote codepoints. So, a string can be seen as a
    sequence of bytes as well as a sequence of runes. This is illustrated in *Figure
    2**.1*. Here, `x` is a string variable that has a pointer to the immutable string,
    which is a sequence of bytes and can also be seen as a sequence of runes. Even
    though UTF-8 is a variable-length encoding, `rune` is a fixed-length 32-bit type
    (`uint32`). Smaller codepoints, like the following character, `H`, is a 32-bit
    decimal, 72, whereas the byte, `H`, is an 8-bit value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – A string, byte, and rune](img/B21961_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – A string, byte, and rune
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at some common operations involving strings and
    text. The recipes included in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uppercase, lowercase, and title case comparisons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with internationalized strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with encodings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating bytes and runes of strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading strings line by line or word by word
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trimming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at how to create strings in a program.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use a string literal. There are two types of string literals in Go:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use interpreted string literals, between the double quotations:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'With interpreted string literals, you must escape certain characters:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'You can include Unicode codepoints or hexadecimal bytes, escaped with `''\''`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'You cannot have newlines or an unescaped double-quote in an interpreted string:'
  prefs: []
  type: TYPE_NORMAL
- en: Use raw string literals, using backticks. A raw string literal can include any
    characters (including newlines) except a backtick. There is no way to escape backticks
    in a raw literal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you need to include a backtick in your raw string literal, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Formatting strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go standard library offers multiple ways to substitute values in a text
    template. Here, we will discuss the text formatting utilities in the `fmt` package.
    They offer a simple and convenient way to substitute values in a text template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `fmt.Print` family of functions to format values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fmt.Print` will print a value using its default formatting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string value will be printed as is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A numeric value will be first converted to a string as an integer, a decimal
    number, or by using scientific notation for large exponents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Boolean value will be printed as `true` or `false`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured values will be printed as a list of fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a `Print` function ends with `ln` (such as `fmt.Println`), a new line will
    be output after the string.
  prefs: []
  type: TYPE_NORMAL
- en: If a `Print` function ends with `f`, the function will accept a format argument,
    which will be used as the template into which it will substitute values.
  prefs: []
  type: TYPE_NORMAL
- en: '`fmt.Sprintf` will format a string and return it.'
  prefs: []
  type: TYPE_NORMAL
- en: '`fmt.Fprintf` will format a string and write it to `io.Writer`, which can be
    a file, network connection, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: '`fmt.Printf` will format a string and write it to standard output.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All these functions use the `%[options]<verb>` format to consume an argument
    from the argument list. To produce a `%` character in the output, use `%%`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Combining strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go standard library offers multiple ways to build strings from components.
    The best way depends on what type of strings you are dealing with, and how long
    they are. This section shows several ways that strings can be built.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To combine a few fixed numbers of strings, or to add runes to another string,
    use the `+` or `+=` operators or `string.Builder`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To build a string algorithmically, use `strings.Builder`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To combine a slice of strings, use `strings.Join`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To combine parts of URL paths, use `path.Join`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To build filesystem paths from path segments, use `filepath.Join`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build constant values, or for simple concatenations, use the `+` or `+=`
    operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add runes to a string the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `+` operator for strings can be controversial among performance-conscious
    teams. It is correct that the `+` operator may become inefficient because multiple
    additions may create unnecessary temporary strings to store intermediate results.
    It is also correct that, for some use cases, the compiler can generate better
    code than you can write manually. However, unless you use the `+` operator to
    create strings in `for`-loops, they are rarely the cause of your performance problems.
    For example, `x+y` will almost always outperform `fmt.Sprintf("%s%s",x,y)`. When
    in doubt, write a benchmark and measure. Here’s how it appears on my laptop:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BenchmarkXPlusY-12          98628536             ``11.31 ns/op`'
  prefs: []
  type: TYPE_NORMAL
- en: '`BenchmarkSprintf-12         12120278``97.70 ns/op`'
  prefs: []
  type: TYPE_NORMAL
- en: '`BenchmarkBuilder-12         33077902             ``34.89 ns/op`'
  prefs: []
  type: TYPE_NORMAL
- en: For non-trivial cases where you have to add many short strings to build a longer
    one, use `strings.Builder`. Even though `strings.Builder` looks like a convenient
    frontend to a byte slice, it does more than that. It creates strings from the
    underlying byte slice without copying, so it almost always outperforms using a
    byte slice and then creating a string from it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example showing why you should prefer standard library functions
    to third-party libraries or manual optimizations. These functions are aggressively
    optimized and rely on Go internals without creating portability issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `strings.Join` to combine a slice of strings. If you are dealing with filenames
    and you need to combine multiple levels of directories, use `filepath.Join` to
    avoid platform-specific separator characters. `filepath.Join` will use `\` on
    Windows platform and `/` on Linux-based platforms. If you are dealing with URLs
    and need to combine multiple segments, use `path.Join`, which will always use
    `/` to combine parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Working with string cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with textual data, problems related to string cases arise often.
    Should a text search be case-sensitive or case-insensitive? How do we convert
    a string to lowercase or uppercase? In this section, we will look at some recipes
    to deal with these common problems in a portable way.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Convert strings to uppercase and lowercase using the `strings.ToUpper` and `strings.ToLower`
    functions, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When dealing with text in languages with special uppercase/lowercase mappings
    (such as Turkish, where “İ” is the uppercase version of “I”), use `strings.ToUpperSpecial`
    and `strings.ToLowerSpecial`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To convert text to uppercase for use in titles, use `strings.ToTitle`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To compare strings lexicographically, use comparison operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To test the equivalence of strings ignoring case, use `strings.EqualFold`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Converting a string to uppercase or lowercase is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This program outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'But the uppercase/lowercase may differ from language to language. For example,
    there are special cases for some of the Turkic languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, that is not the correct uppercase use for Turkish. Let’s try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding program will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The title case differs from uppercase or lowercase mainly when dealing with
    ligatures and digraphs – that is, more than one character represented as a single
    character, such as `Ǉ` `(U+01C7)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This program prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Uppercase, lowercase, and title case define how to print a string using a particular
    case mapping. These are **case mappings**. **Case folding** is the process of
    transforming text into the same case for comparison purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For lexicographical case-sensitive comparisons, use the relational operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To compare two Unicode strings in a case-insensitive way, use `strings.EqualFold`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the standard library `strings` package includes most of the string comparison
    functions you need, they may not be sufficient when dealing with internationalized
    strings. For example, in many cases, you would want to have `Montréal` and `montreal`
    be considered equal. `strings.EqualFold` will not do that. Many of the supporting
    functions to deal with internalized text processing are in the packages under
    `golang.org/x/text`.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode offers multiple ways to represent a given string. The `é` in `Montréal`
    can be represented as a single rune, `\u00e9` or `e`, followed by an acute accent,
    `e\u0301`. `\u0301` is the “combining acute accent,” `◌́``,` and it modifies the
    codepoint that comes before it. According to the Unicode standard, `é` and `e`
    + `◌́` are “canonically equivalent.” There is also a compatibility equivalence,
    such as `\ufb00`, representing `ff` as a single codepoint, and the `ff` sequence.
    Canonically equivalent sequences are also compatible, but not all compatible sequences
    are canonically equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you need to remove diacritics (i.e., nonspacing marks) from text, you
    can decompose it, remove the diacritics, and then compose it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The above program will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Working with encodings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If there is a chance that your program will have to work with data produced
    by disparate systems, you should be aware of different text encodings. This is
    a huge topic, but this section should provide some pointers to scratch the surface.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `golang.org/x/text/encoding` package to deal with different encodings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To find an encoding by name, use one of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`golang.org/x/text/encoding/ianaindex`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`golang.org/x/text/encoding/htmlindex`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have an encoding, use it to translate text to and from UTF-8.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use one of the indexes to find an encoding. Then, use that encoding to read/write
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Iterating bytes and runes of strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go strings can be seen as a sequence of bytes, or as a sequence of runes. This
    section shows how you can iterate a string either way.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To iterate the bytes of a string, use indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To iterate the runes of a string, use `range`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Go string is a slice of bytes, so you would expect to be able to write a
    for-loop to iterate the bytes and runes of a string. You might think that you
    can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: However, converting a string to a slice of bytes or a slice of runes is an expensive
    operation. The first one creates a writeable copy of the bytes of the `str` string,
    and the second one creates a writeable copy of the runes of `str`. Remember that
    `rune` is `uint32`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two forms of for-loop to iterate the elements of a string. The following
    for-loop will iterate the bytes of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Also, note that `str[i]` will give you the i’th byte, not the i’th rune.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following form iterates the runes of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note the indexes – they go in a sequence of 0, 1, 2, 3, 4, 5, 6, 9\. This is
    because `str[6]` contains a rune of 3 bytes, and so does `str[9]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are dealing with `[]byte` instead of a string, you can emulate the
    rune iteration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `utf8.DecodeRune` function decodes the next rune from the byte slice and
    returns that rune and the number of bytes consumed. This way, you can decode the
    runes of a byte slice without first converting it to a string.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `strings` package offers convenient functions to split a string to get a
    slice of strings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To split a string into components using a delimiter, use `strings.Split`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To split the space-separated components of a string, use `strings.Fields`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to parse a string delimited with a fixed delimiter, use `strings.Split`.
    If you need to parse the space-separated sections of a string, use `strings.Fields`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that `strings.Split` may cause some surprises when the delimiter is repeated.
    For instance, with `"-"` as the delimiter, `"a---b"` splits into `"a"`, `""`,
    `""`, and `"b"`. The two empty strings are those between the first and second
    `"-"`, and the second and third `"-"`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading strings line by line, or word by word
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many use cases for processing strings in a stream, such as when dealing
    with large text or user input. This recipe shows the use of `bufio.Scanner` for
    this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `bufio.Scanner` for reading lines, words, or custom blocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `bufio.Scanner` instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the split method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read scanned tokens in a for-loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Scanner` works like an iterator – every call to `Scan()` method will return
    `true` if it parsed the next token, or `false` if there are no more tokens. The
    token can be obtained by the `Text()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Trimming the ends of a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: User input is usually messy, including additional spaces before or after the
    text that matters. This recipe shows how to use the string trimming functions
    for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `strings.Trim` family of functions, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A regular expression offers efficient methods to ensure that textual data matches
    a given pattern, searches for patterns, extracts, and replaces parts of text.
    Usually, you compile a regular expression once and then use that compiled regular
    expression many times to efficiently validate, search, extract, or replace parts
    of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Validating input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Format validation is the process of ensuring that data coming from user input
    or other sources is in a recognized format. Regular expressions can be an effective
    tool for such validation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use precompiled regular expressions to validate input values that should fit
    a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: To ensure an exact match, make sure you include the beginning (`^`) and end-of-text
    markers (`$`); otherwise, you will end up accepting input **containing** strings
    that match the regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: Not all types of input are suitable for regular expression validation. Some
    inputs have complicated regular expressions (such as the one for emails or password
    policies), so custom validations may work better for those.
  prefs: []
  type: TYPE_NORMAL
- en: Searching patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use a regular expression to search through textual data to locate strings
    matching a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the `regexp.Find` family of methods to search for substrings matching a
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Extracting data from strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use a regular expression to locate and extract text that occurs within
    a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use capture groups to extract substrings that match a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at this regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '`^(\w+)`: A string composed of one or more word characters at the beginning
    of the line (capture group 1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=`: An “`=`” sign'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(\w+)$`: A string composed of one or more word characters (capture group 2),
    and then the end of line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the capture groups are in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: The `FindStringSubmatch` method returns the matching string as the 0th element
    of the slice, and then each capture group. Using the capture groups, you can extract
    data as above.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing parts of a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use a regular expression to search through text, replacing parts that
    match a pattern with other strings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `Replace` family of functions to replace the patterns in a string with
    something else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Templates are useful for generating data-driven textual output. The `text/template`
    package can be used in the following contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`env` map variable to create environment-sensitive configurations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Reporting**: Use templates to generate output for command-line applications
    and reports'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`html/template` package provides HTML-safe templating functionality for template-based
    HTML generation to build web applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value substitution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main use of templates is inserting data elements into structured text. This
    section describes how you can insert values computed in a program into a template.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the `{{.name}}` syntax to substitute a value in a template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code segment executes a template using different inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding program outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `template.New(name)` call creates an empty template with the given name
    (there’ll be more on this later). The returned template object represents a template
    body (which is empty after the `New()` call). The Go template engine uses a template
    representing the body, as well as zero or more named templates that are associated
    with that body. The `tmpl.Parse(tp)` call parses the `tp` template as the body
    for the given `named` template. If there are other template definitions in `tp`
    that are defined using the `{{define}}` construct, those are kept within `tmpl`
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`tmpl.Execute(os.Stdout,book1)` executes the template, writing the output to
    `os.Stdout`. The second argument, `book1`, is the data used to evaluate the template.
    You access it by "`.`". So, for instance, when `{{.Author}}` is evaluated, the
    template engine reads `book1.Author`, using reflection, and outputs its value.
    In other words, `.` is `book1` for the first `tmpl.Execute` call, and `.` is `book2`
    for the second `tmpl.Execute` call in the preceding example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is done using reflection, the following produces the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Iteration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A template can include tabular data or lists that are populated using slices
    or maps computed in a program. Templates provide an iteration mechanism to render
    such content.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For slices/arrays, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For maps, do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use `range` to loop through slices and maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the preceding example with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify it with the following too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now, note that `.` is a slice of books, so we can range through the elements
    of it. When evaluating the section within `{{range .}}`, `.` is set to successive
    elements of the slice – during the first iteration, `.` is `book1`, and during
    the second iteration, `.` is `book2`.
  prefs: []
  type: TYPE_NORMAL
- en: We will deal with the empty lines shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same thing happens for maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Variables and scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is often necessary to define local variables within templates to keep computed
    values. The variables defined in templates follow similar scoping rules as variables
    defined in functions – the `{{range}}`, `{{if}}`, `{{with}}` and `{{define}}`
    blocks create a new scope.
  prefs: []
  type: TYPE_NORMAL
- en: A variable defined in a scope is accessible in all the scopes contained within
    that scope, but it is not accessible outside of it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`.` (**dot**) refers to the “current object,” as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: At the top-level scope, `.` refers to the object passed as the `data` argument
    of the `Execute` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside a `{{range}}`, `.` refers to the current slice/array/map element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside a `{{with <expr>}}`, `.` refers to the value of `<expr>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside a `{{define}}` block, `.` refers to the value of the object passed into
    `{{template "``name" <object>}}`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.X` refers to the member named `X` in the current object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `.` is a map, then `.X` evaluates to the element with the `X` key
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If `.` is a struct, then `.X` evaluates to the `X` member variable
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Note the emphasis on `X` in the current object. If the current object is a struct,
    reflection can only access the exported fields, so you cannot access unexported
    variables. However, if the current object is a map, this becomes a key lookup,
    and there is no such restriction. In other words, `{{.name}}` will only work if
    `.` is a map, but `{{.Name}}` will work for a `.` struct and a `.` map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a new local variable that is visible in the current scope using the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the `$name` notation to assign a computed value to a variable instead of
    recomputing it every time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The first section of this template is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`$` is necessary as the first character of the variable name. Without that,
    the template engine will think `name` is a function.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more – nested loops and conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you are dealing with nested loops or conditions, scoping can become a
    challenge. Every `{{range}}`, `{{if}}`, and `{{with}}` create a new scope. Variables
    defined within a scope are only accessible in that scope and all scopes enclosed
    in it. You can use this to create nested loops and still access variables defined
    in the enclosing scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In this template, the first `range` defines the loop index, `$bookIndex`, and
    the loop variable, `$book`, that can be used in the nested scopes. At this stage,
    `.` points to the slice of `Book` fields. The next `range` iterates the current
    `$book.Editions` – that is, `.` now points to the successive elements of the `Book.Editions`
    slice. The nested template accesses both the `Edition` fields and the `Book` fields
    from the enclosing scope.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with empty lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Template actions (i.e., the code elements placed in a template) may result in
    unwanted empty spaces and lines. The Go template system offers some mechanisms
    to deal with these unwanted spaces.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `-` next to the template delimiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{{-` will remove all spaces/tabs/newlines that were output before this template
    element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-}}` will remove all spaces/tabs/newlines that come after this template element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a template directive produces output, such as the value of a variable, it
    will be written to the output stream. But if a template directive does not generate
    any output, such as a `{{range}}` or `{{if}}` statement, then it will be replaced
    with empty strings. And if those statements are on a line by themselves, those
    lines will be written to the output as well, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This template will produce an output every four lines. When there is nothing
    to output, it will print three empty lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fix this by using “`-`” inside the `{{ }}` constructs. `{{ -}}` will remove
    all empty space (including lines) coming after, and `{{- }}` will remove all empty
    spaces before, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'How can we get rid of the spaces at the beginning of each line? First, we have
    to find out why they are there, which is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The first “-” will remove all spaces before the value. We cannot put `-}}`
    in this line, or `{{- end}}`, as these solutions would remove line feeds as well.
    But we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Template composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As templates grow, they may become repetitive. To reduce such repetition, the
    Go template system offers named blocks (components) that can be reused within
    a template, just like functions in a program. Then, the final template can be
    composed of these components.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create template “components” that you can reuse in multiple contexts.
    To define a named template, use the `{{define "``name"}}` construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, call that template using the `{{template "name" .}}` construct as if
    it is a function with a single argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following example prints a book list using a named template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `tmpl` template contains two templates in this example – the template named
    `"body"` (because it is created with `template.New("body")`), and the template
    named `"line"` (because the template contains `{{define "line"}}`.) For each element
    of the slice, the `"body"` template instantiates `"line"` with successive elements
    of the `books` slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Template composition – layout templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing web applications, it is usually desirable to have a few templates
    specifying page layouts. Complete web pages are constructed by combining page
    components, developed as independent templates using this layout. Unfortunately,
    the Go template engine forces you to think of alternative solutions because Go
    template references are static. This means you would need a separate layout template
    for each page.
  prefs: []
  type: TYPE_NORMAL
- en: But there are alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll show you a basic idea that demonstrates how template composition can be
    used so that you can extend it, based on your use case, or how to use an available
    third-party library that does this. The crucial idea in composition using layout
    templates is that if you define a new template using an already-defined template
    name, the new definition overrides the older one.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a layout template. Use empty templates or templates with default content
    for the sections you will redefine for each occasion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a configuration system where you define every possible composition. Each
    composition includes the layout template, as well as the templates defining the
    sections in the layout template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile each composition as a separate template.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a layout template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This layout template defines four named templates with no content. For each
    new page, we can recreate these components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define a second page, similar to the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we compose `layout` with `mainPage` to get the template for the main page,
    and then `layout` with `secondPage` to get the template for the second page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'You can extend this pattern to build a sophisticated web application using
    layout templates, as well as a configuration file defining all the valid compositions
    of templates for each page. Such a YAML file looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: When the application starts, you build each template for `mainPage` and `detailPage`
    by parsing its constituent templates in the given order, putting each template
    in a map. Then, you can look up the template name you want to generate and use
    the parsed template.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Go standard library documentation is always your best source for up-to-date
    information and great examples, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://pkg.go.dev/strings](https://pkg.go.dev/strings)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pkg.go.dev/text/template](https://pkg.go.dev/text/template)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pkg.go.dev/html/template](https://pkg.go.dev/html/template)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pkg.go.dev/fmt](https://pkg.go.dev/fmt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pkg.go.dev/bufio](https://pkg.go.dev/bufio)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following links are also useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Character Model for the World Wide Web: String* *Matching*: [https://www.w3.org/TR/charmod-norm/](https://www.w3.org/TR/charmod-norm/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Character Properties, Case Mappings & Names* *FAQ*: [https://unicode.org/faq/casemap_charprop.html](https://unicode.org/faq/casemap_charprop.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RFC7564: PRECIS [https://www.rfc-editor.org/rfc/rfc7564](https://www.rfc-editor.org/rfc/rfc7564)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a great blog post about the Unicode normalization process: [https://go.dev/blog/normalization](https://go.dev/blog/normalization)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For all encoding, internationalization, and Unicode-related problems that are
    not handled by the standard library, take a look at the packages here before searching
    for anything else: [https://pkg.go.dev/golang.org/x/text](https://pkg.go.dev/golang.org/x/text)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
