<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer009">
			<h1 id="_idParaDest-93" class="chapter-number"><a id="_idTextAnchor092"/>3</h1>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/>Working with Date and Time</h1>
			<p>Working with date and time can be difficult in any programming language. Go’s standard library offers easy-to-use tools to work with date and time constructs. These may be somewhat different from what many people are used to. For example, there are libraries in different languages that make a distinction between a <strong class="source-inline">time</strong> type and a <strong class="source-inline">date</strong> type. Go’s standard library only includes a <strong class="source-inline">time.Time</strong> type. That might make you feel disoriented when you’re working with <span class="No-Break">Go’s time.</span></p>
			<p>I’d like to think that Go’s treatment of date/time reduces the chances of creating subtle bugs. You see, you have to be really careful and clear about what you mean when you talk about time: are you talking about a point in time or an interval? A date is actually an interval (for instance, 08/01/2024 starts at 08/01/2024T00:00:00 and continues until 08/01/2024T23:59:59) even though usually that is not the intent. A specific date/time value also depends on where you are measuring time. 2023-11-05T08:00 in Denver, Colorado is different from 2023-11-05T08:00 in Berlin, Germany. Time always moves forward, but date/time may skip or go backward: after 2023-11-05T02:59 in Denver, Colorado, time goes back to 2023-11-05T02:00 because that is when daylight savings time ends in Colorado. So there are actually two time instances for 2023-11-05T02:10:10, one in Mountain Daylight Time, and one in Mountain <span class="No-Break">Standard Time.</span></p>
			<p>There are many software bugs in production today that handle time incorrectly. For example, if you are computing when the subscription of a customer ends, you have to take into account the location of that customer and the time of day that subscription ends, otherwise, their subscriptions may terminate early (or late) on their <span class="No-Break">last day.</span></p>
			<p>This chapter contains the following recipes for working with <span class="No-Break">date/time correctly:</span></p>
			<ul>
				<li>Working with <span class="No-Break">Unix time</span></li>
				<li><span class="No-Break">Date/time components</span></li>
				<li><span class="No-Break">Date/time arithmetic</span></li>
				<li>Formatting and <span class="No-Break">parsing date/time</span></li>
				<li>Working with <span class="No-Break">time zones</span></li>
				<li><span class="No-Break">Timers</span></li>
				<li><span class="No-Break">Tickers</span></li>
				<li>Storing <span class="No-Break">time information</span></li>
			</ul>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor094"/>Working with Unix time</h1>
			<p>Unix time is <a id="_idIndexMarker104"/>the number of seconds (or milliseconds, microseconds, or nanoseconds) passed since January 1, 1970 UTC (the epoch.) Go uses <strong class="source-inline">int64</strong> to represent these values, so Unix time as seconds can represent billions of years into the past or the future. Unix time as nanoseconds can represent date values between 1678 and 2262. Unix time is an absolute measure of an instance as the duration since (or until) the epoch. It is independent of the location, so with two Unix times, <strong class="source-inline">s</strong> and <strong class="source-inline">t</strong>, if <strong class="source-inline">s&lt;t</strong>, then <strong class="source-inline">s</strong> happened before <strong class="source-inline">t</strong>, no matter the location. Because of these properties, Unix time is usually used as a timestamp that marks when an event happened (when a log is written, when a record is <span class="No-Break">inserted, etc.).</span></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>How to do it...</h2>
			<ul>
				<li>To get the current Unix time, use <span class="No-Break">the following:</span><ul><li><strong class="source-inline">time.Now().Unix() int64</strong>: Unix time <span class="No-Break">in seconds</span></li><li><strong class="source-inline">time.Now().UnixMilli() int64</strong>: Unix time <span class="No-Break">in milliseconds</span></li><li><strong class="source-inline">time.Now().UnixMicro() int64</strong>: Unix time <span class="No-Break">in microseconds</span></li><li><strong class="source-inline">time.Now().UnixNano() int64</strong>: Unix time <span class="No-Break">in nanoseconds</span></li></ul></li>
				<li>Given a Unix time, convert it to a <strong class="source-inline">time.Time</strong> type using <span class="No-Break">the following:</span><ul><li><strong class="source-inline">time.Unix(sec, nanosec int64) time.Time</strong>: Translate Unix time in seconds and/or nanoseconds <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">time.Time</strong></span></li><li><strong class="source-inline">time.UnixMilli(int64) time.Time</strong>: Translate Unix time in milliseconds <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">time.Time</strong></span></li><li><strong class="source-inline">time.UnixMicro(int64) time.Time</strong>: Translate Unix time in microseconds <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">time.Time</strong></span></li></ul></li>
				<li>To translate a Unix time to local time, use <strong class="source-inline">localTime := time.Unix(unixTimeSeconds,0).In(location)</strong>, where <strong class="source-inline">location</strong> is a <strong class="source-inline">*time.Location</strong> for the location<a id="_idIndexMarker105"/> in which to interpret the <span class="No-Break">Unix time</span></li>
			</ul>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Date/time components</h1>
			<p>When working with<a id="_idIndexMarker106"/> date values, you often have to compose a date/time from its components or need to access the components of a date/time value. This recipe shows how it can <span class="No-Break">be done.</span></p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>How to do it...</h2>
			<ul>
				<li>To build a date/time value from parts, use the <span class="No-Break"><strong class="source-inline">time.Date</strong></span><span class="No-Break"> function</span></li>
				<li>To get the parts of a date/time value, use the <span class="No-Break"><strong class="source-inline">time.Time</strong></span><span class="No-Break"> methods:</span><ul><li><span class="No-Break"><strong class="source-inline">time.Day() int</strong></span></li><li><span class="No-Break"><strong class="source-inline">time.Month() time.Month</strong></span></li><li><span class="No-Break"><strong class="source-inline">time.Year() int</strong></span></li><li><strong class="source-inline">time.Date() (year, month, </strong><span class="No-Break"><strong class="source-inline">day int)</strong></span></li><li><span class="No-Break"><strong class="source-inline">time.Hour() int</strong></span></li><li><span class="No-Break"><strong class="source-inline">time.Minute() int</strong></span></li><li><span class="No-Break"><strong class="source-inline">time.Second() int</strong></span></li><li><span class="No-Break"><strong class="source-inline">time.Nanosecond() int</strong></span></li><li><strong class="source-inline">time.Zone() (name </strong><span class="No-Break"><strong class="source-inline">string,offset int)</strong></span></li><li><span class="No-Break"><strong class="source-inline">time.Location() *time.Location</strong></span></li></ul></li>
			</ul>
			<p><strong class="source-inline">time.Date</strong> will create a time value from <span class="No-Break">its components:</span></p>
			<pre class="source-code">
d := time.Date(2020, 3, 31, 15, 30, 0, 0, time.UTC)
fmt.Println(d)
// 2020-03-31 15:30:00 +0000 UTC</pre>			<p>The output will be normalized, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
d := time.Date(2020, 3, 0, 15, 30, 0, 0, time.UTC)
fmt.Println(d)
// 2020-02-29 15:30:00 +0000 UTC</pre>			<p>Since the day of the month starts from 1, creating a date with a <strong class="source-inline">0</strong> day will result in the last day of the <span class="No-Break">previous month.</span></p>
			<p>Once you have a <strong class="source-inline">time.Time</strong> value, you can get <span class="No-Break">its components:</span></p>
			<pre class="source-code">
d := time.Date(2020, 3, 0, 15, 30, 0, 0, time.UTC)
fmt.Println(d.Day())
// 29</pre>			<p>Again, <strong class="source-inline">time.Date</strong> normalizes<a id="_idIndexMarker107"/> the date value, so <strong class="source-inline">d.Day()</strong> will <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">29</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor098"/>Date/time arithmetic</h1>
			<p>Date/time arithmetic is <a id="_idIndexMarker108"/>necessary to answer questions such as <span class="No-Break">the following:</span></p>
			<ul>
				<li>How long did it take to complete <span class="No-Break">an operation?</span></li>
				<li>What time will it be after <span class="No-Break">5 minutes?</span></li>
				<li>How many days are there until <span class="No-Break">next month?</span></li>
			</ul>
			<p>This recipe shows how you can answer these questions using the <span class="No-Break"><strong class="source-inline">time</strong></span><span class="No-Break"> package.</span></p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>How to do it...</h2>
			<ul>
				<li>To find out how much time has passed between two instances in time, use the <strong class="source-inline">Time.Sub</strong> method to <span class="No-Break">subtract them.</span></li>
				<li>To find the duration from now to a later time, <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">time.Until(laterTime)</strong></span><span class="No-Break">.</span></li>
				<li>To find how much time has passed since a given time, <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">time.Since(beforeTime)</strong></span><span class="No-Break">.</span></li>
				<li>To find out what time it will be after a certain duration, use the <strong class="source-inline">Time.Add</strong> method. Use negative duration to find the time before a <span class="No-Break">certain duration.</span></li>
				<li>To add/subtract years, months, or days to/from a time, use the <span class="No-Break"><strong class="source-inline">Time.AddDate</strong></span><span class="No-Break"> method.</span></li>
				<li>To compare two <strong class="source-inline">time.Time</strong> values, use <span class="No-Break">the following:</span><ul><li><strong class="source-inline">Time.Equal</strong> to check whether two time values represent the <span class="No-Break">same instance</span></li><li><strong class="source-inline">Time.Before</strong> or <strong class="source-inline">Time.After</strong> to check whether a time value is before or after a given <span class="No-Break">time value</span></li></ul></li>
			</ul>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>How it works...</h2>
			<p>A <strong class="source-inline">time.Duration</strong> type<a id="_idIndexMarker109"/> represents the time elapsed between two instances in nanoseconds as an <strong class="source-inline">int64</strong> value. In other words, if you subtract a <strong class="source-inline">time.Time</strong> value from another, you get <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">time.Duration</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
dur := tm1.Sub(tm2)</pre>			<p>Since <strong class="source-inline">Duration</strong> is an <strong class="source-inline">int64</strong> representing nanoseconds, you can do <span class="No-Break">duration arithmetic:</span></p>
			<pre class="source-code">
// Add 1 day to duration
dur+=time.Hour*24</pre>			<p>Note that the last operation in the preceding also involves multiplication since <strong class="source-inline">time.Hour</strong> is of the <strong class="source-inline">time.Duration</strong> <span class="No-Break">type itself.</span></p>
			<p>You can add a duration value to a <span class="No-Break"><strong class="source-inline">time.Time</strong></span><span class="No-Break"> value:</span></p>
			<pre class="source-code">
now := time.Now()
then := now.Add(dur)</pre>			<p class="callout-heading">Tip</p>
			<p class="callout">Duration being an <strong class="source-inline">int64</strong> means that a <strong class="source-inline">time.Duration</strong> value is limited to around 290 years. This should be sufficient for most practical cases. However, if this is not the case for you, you need to build a solution for yourself or find a <span class="No-Break">third-party library.</span></p>
			<p>You can subtract the duration from a <strong class="source-inline">time.Time</strong> value by adding a negative <span class="No-Break">duration value:</span></p>
			<pre class="source-code">
fmt.Println( then.Add(-dur).Equal(now) )</pre>			<p>Note the use of the <strong class="source-inline">Time.Equal</strong> method. This compares two time instances taking into account their time zones, which can be different. For instance, <strong class="source-inline">Time.Equal</strong> will return <strong class="source-inline">true</strong> for <strong class="source-inline">2024-01-09 09:00 MST</strong> and <strong class="source-inline">2024-01-09 </strong><span class="No-Break"><strong class="source-inline">08:00 PST</strong></span><span class="No-Break">.</span></p>
			<p>Use <strong class="source-inline">Time.Before</strong> and <strong class="source-inline">Time.After</strong> to compare time values. For instance, you can check whether an object with an expiration date has expired by using <span class="No-Break">the following:</span></p>
			<pre class="source-code">
if object.Expiration.After(time.Now()) {
   // Object expired
}</pre>			<p>You can also add <a id="_idIndexMarker110"/>years/months/days to a <span class="No-Break">given date:</span></p>
			<pre class="source-code">
t:=time.Now()
// Subtract 1 year from now to get this moment in last year
lastYear := t.AddDate(-1,0,0)
// Add 1 day to get same time tomorrow
tomorrow := t.AddDate(0,0,1)
// Add 1 day to get the next month
nextMonth := t.AddDate(0,1,0)</pre>			<p>The result of these operations will be normalized. For instance, if you subtract a year from <strong class="source-inline">2020-02-29</strong>, you will get <strong class="source-inline">2019-03-01</strong>. This causes problems when you are working with a date at the end of a month and you have to add/subtract month values. Adding a month to <strong class="source-inline">2020-03-31</strong> twice <a id="_idIndexMarker111"/>will yield <strong class="source-inline">2020-06-01</strong>, but adding two months will <span class="No-Break">yield </span><span class="No-Break"><strong class="source-inline">2020-05-31</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
d := time.Date(2020, 3, 31, 0, 0, 0, 0, time.UTC)
fmt.Println(d.AddDate(0, 1, 0).AddDate(0, 1, 0))
// 2020-06-01 00:00:00 +0000 UTC
fmt.Println(d.AddDate(0, 2, 0))
// 2020-05-31 00:00:00 +0000 UTC</pre>			<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/>Formatting and parsing date/time</h1>
			<p>Go uses an<a id="_idIndexMarker112"/> interesting <a id="_idIndexMarker113"/>and somewhat controversial date/time formatting scheme. The date/time format is expressed using a specific point in time, adjusted such that every component of the date/time is a <span class="No-Break">unique number:</span></p>
			<ul>
				<li>1 is the month: “Jan” “January” “<span class="No-Break">01” “1”</span></li>
				<li>2 is the day of the month: “2” “<span class="No-Break">_2” “02”</span></li>
				<li>3 is the hour of the day in a 12-hour format: “15” “<span class="No-Break">3” “03”</span></li>
				<li>15 is the hour of the day in a <span class="No-Break">24-hour format,</span></li>
				<li>4 is the minute: “<span class="No-Break">4” “04”</span></li>
				<li>5 is the second: “<span class="No-Break">5” “05”</span></li>
				<li>6 is the year: “<span class="No-Break">2006” “06”</span></li>
				<li>MST is the timezone: “-0700” “-07:00” “-07” “-070000” “-<span class="No-Break">07:00:00” “MST”</span></li>
				<li>0 is the millisecond padded with 0s: “<span class="No-Break">0” “000”</span></li>
				<li>9 is the millisecond that is not padded: “<span class="No-Break">9” “999”</span></li>
			</ul>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>How to do it...</h2>
			<ul>
				<li>Use <strong class="source-inline">time.Parse</strong> with an appropriate format to parse date/time. Any parts of the date/time that are not specified in the format will be initialized to its zero value, which is January for months, 1 for the year, 1 for the day of the month, and 0 for everything else. If the time zone information is missing, the parsed date/time will be <span class="No-Break">in UTC.</span></li>
				<li>Use <strong class="source-inline">time.ParseInLocation</strong> to parse date/time in a given location. The time zone will be determined based on the date value and <span class="No-Break">the location.</span></li>
				<li>Use the <strong class="source-inline">Format()</strong> method to format a <span class="No-Break">date/time value.</span></li>
			</ul>
			<pre class="source-code">
func main() {
  t := time.Date(2024, 3, 8, 18, 2, 13, 500, time.UTC)
  fmt.Println("Date in yyyy/mm/dd format", t.Format("2006/01/02"))
  // Date in yyyy/mm/dd format 2024/03/08
  fmt.Println("Date in yyyy/m/d format", t.Format("2006/1/2"))
  // Date in yyyy/m/d format 2024/3/8
  fmt.Println("Date in yy/m/d format", t.Format("06/1/2"))
  // Date in yy/m/d format 24/3/8
  fmt.Println("Time in hh:mm format (12 hr)", t.Format("03:04"))
  // Time in hh:mm format (12 hr) 06:02
  fmt.Println("Time in hh:m format (24 hr)", t.Format("15:4"))
  // Time in hh:m format (24 hr) 18:2
  fmt.Println("Date-time with time zone", t.Format("2006-01-02 
  13:04:05 -07:00"))
  // Date-time with time zone 2024-03-08 36:02:13 +00:00
}</pre>			<p><a id="_idTextAnchor103"/>Time zones change by location and by date. In the following example, even though the same location is used to parse the date, the time zone changes because July 9 is Mountain Daylight <a id="_idIndexMarker114"/>Time, but <a id="_idIndexMarker115"/>January 9 is Mountain <span class="No-Break">Standard Time:</span></p>
			<pre class="source-code">
loc, _ := time.LoadLocation("America/Denver")
const format = "Jan 2, 2006 at 3:04pm"
str, _ := time.ParseInLocation(format, "Jul 9, 2012 at 5:02am", loc)
fmt.Println(str)
// 2012-07-09 05:02:00 -0600 MDT
str, _ = time.ParseInLocation(format, "Jan 9, 2012 at 5:02am", loc)
fmt.Println(str)
// 2012-01-09 05:02:00 -0700 MST</pre>			<h1 id="_idParaDest-104"><a id="_idTextAnchor104"/>Working with time zones</h1>
			<p>The Go <strong class="source-inline">time.Time</strong> value<a id="_idIndexMarker116"/> includes <strong class="source-inline">time.Location</strong>, which can be one of <span class="No-Break">two things:</span></p>
			<ul>
				<li>A real location, such as <strong class="source-inline">America/Denver</strong>. If this is the case, the actual time zone depends on the time value. For <strong class="source-inline">Denver</strong>, the time zone will be either <strong class="source-inline">MDT</strong> (Mountain Daylight Time) or <strong class="source-inline">MST</strong> (Mountain Standard Time) depending on the actual <span class="No-Break">time value</span></li>
				<li>A fixed time zone that gives <span class="No-Break">the offset.</span></li>
			</ul>
			<p>Some applications work <a id="_idIndexMarker117"/>with <strong class="bold">local time</strong>. This is the date/time value captured at a particular location, and interpreted as the same value everywhere, as opposed to being interpreted as the same point in time. Birthdays (and thus, ages) are usually interpreted using local time. That is, if you are born on 2005-07-14, you will be considered 2 years old in New York (Eastern time zone) on 2007-07-14 at 00:00, but still be 1 year old at the same moment in time in Los Angeles, which is 2007-07-13 at 21:00 (Pacific <span class="No-Break">time zone).</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor105"/>How to do it...</h2>
			<p>If you are working with moments in time, always capture date/time values with the associated location. Such date/time values can be translated into other time <span class="No-Break">zones easily.</span></p>
			<p>If you are working with local time in multiple time zones, recreate <strong class="source-inline">time.Time</strong> in a new location or time zone <span class="No-Break">to translate.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor106"/>How it works...</h2>
			<p>When you <a id="_idIndexMarker118"/>create a <strong class="source-inline">time.Time</strong>, it is always associated with <span class="No-Break">a location:</span></p>
			<pre class="source-code">
// Create a new time using the local time zone
t := time.Date(2021,12,31,15,0,0,0, time.Local)
// 2021-12-31 15:00:00 -0700 MST</pre>			<p>Once you have a <strong class="source-inline">time.Time</strong>, you can get the same moment in time in different <span class="No-Break">time zones:</span></p>
			<pre class="source-code">
utcTime := t.In(time.UTC)
fmt.Println(utcTime)
// 2021-12-31 22:00:00 +0000 UTC
ny,err:=time.LoadLocation("America/New_York")
if err!=nil {
  panic(err)
}
nyTime := t.In(ny)
fmt.Println(nyTime)
// 2021-12-31 17:00:00 -0500 EST</pre>			<p>These are different representations of the same moment in time in different <span class="No-Break">time zones.</span></p>
			<p>You can also create a custom <span class="No-Break">time zone:</span></p>
			<pre class="source-code">
zone30 := time.FixedZone("30min", 30)
fmt.Println(t.In(zone30))
// 2021-12-31 22:00:30 +0000 30min</pre>			<p>When you are dealing with local time, you discard the location and time <span class="No-Break">zone information:</span></p>
			<pre class="source-code">
// Create a local time, UTC zone
t := time.Date(2021,12,31,15,0,0,0, time.UTC)
// 2021-12-31 15:00:00 +0000 UTC</pre>			<p>To get the same<a id="_idIndexMarker119"/> time value in New York, use <span class="No-Break">the following:</span></p>
			<pre class="source-code">
ny,err:=time.LoadLocation("America/New_York")
if err!=nil {
  panic(err)
}
nyTime := time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second(), t.Nanosecond(), ny)
fmt.Println(nyTime)
// 2021-12-31 15:00:00 -0500 EST</pre>			<h1 id="_idParaDest-107"><a id="_idTextAnchor107"/>Storing time information</h1>
			<p>A common problem is <a id="_idIndexMarker120"/>storing date/time information in databases, files, and so on in a portable manner, so that it can be <span class="No-Break">interpreted correctly.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor108"/>How to do it...</h2>
			<p>You should first identify the exact needs: do you need to store an instant of time or time <span class="No-Break">of day?</span></p>
			<ul>
				<li>To store an instant of time, do one of <span class="No-Break">the following:</span><ul><li>Store Unix time at the needed granularity (that is, <strong class="source-inline">time.Unix</strong> for seconds, <strong class="source-inline">time.UnixMilli</strong> for <span class="No-Break">milliseconds, etc.)</span></li><li>Store UTC <span class="No-Break">time (</span><span class="No-Break"><strong class="source-inline">time.UTC()</strong></span><span class="No-Break">)</span></li></ul></li>
				<li>To store the time of day, store the <strong class="source-inline">time.Duration</strong> value that gives the instant in the day. The following function computes the instant within that day <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">time.Duration</strong></span><span class="No-Break">:</span><pre class="source-code">
func GetTimeOfDay(t time.Time) time.Duration {
  beginningOfDay:=time.Date(t.Year(),t.Month(),t.
  Day(),0,0,0,0,t.Location())
  return t.Sub(beginningOfDay)
}</pre></li>				<li>To store a date value, you can clear the time portions <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">time.Time</strong></span><span class="No-Break">:</span><pre class="source-code">
date:=time.Date(t.Year(), t.Month(), t.Day(), 0,0,0,0,t.Location())</pre><p class="list-inset">Note that comparing dates stored in this manner can be problematic as each day will be interpreted<a id="_idIndexMarker121"/> to be a different instant in different <span class="No-Break">time zones.</span></p></li>			</ul>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor109"/>Timers</h1>
			<p>Use <strong class="source-inline">time.Timer</strong> to schedule<a id="_idIndexMarker122"/> some work to be done in the future. When the timer expires, you will receive a signal from a channel. You can use a timer to run a function later or to cancel a process that ran <span class="No-Break">too long.</span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor110"/>How to do it...</h2>
			<p>You can create a timer in one of <span class="No-Break">two ways:</span></p>
			<ul>
				<li>Use <strong class="source-inline">time.NewTimer</strong> or <strong class="source-inline">time.After</strong>. The timer will send a signal through a channel when it expires. Use a <strong class="source-inline">select</strong> statement, or read from the channel to receive the timer <span class="No-Break">expiration signal.</span></li>
				<li>Use <strong class="source-inline">time.AfterFunc</strong> to call a function when the <span class="No-Break">timer expires.</span></li>
			</ul>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor111"/>How it works...</h2>
			<p>A <strong class="source-inline">time.Timer</strong> timer is created <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">time.Duration</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// Create a 10-second timer
timer := time.NewTimer(time.Second*10)</pre>			<p>The timer contains a channel that will receive the current timestamp after 10 seconds pass. A timer is created with a channel capacity of <strong class="source-inline">1</strong>, so the timer runtime will always be able to write to that channel and stop the timer. In other words, if you fail to read from a timer, it will not leak; it will eventually be <span class="No-Break">garbage collected.</span></p>
			<p>The timer can be used to stop a <span class="No-Break">long-running process:</span></p>
			<pre class="source-code">
func longProcess() {
  timer := time.NewTimer(time.Second*10)
  for {
     processData()
     select {
       case &lt;-timer.C:
          // 2 seconds passed
          return
       default:
     }
  }
}</pre>			<p>The following example shows how a timer can be used to limit the time it takes to return from a function. If the computation completes within a second, the response is returned. If the computation takes longer, the function returns a channel that the caller can use to receive the <a id="_idIndexMarker123"/>result. This function also demonstrates how you can stop <span class="No-Break">a timer:</span></p>
			<pre class="source-code">
func longComputation() (concurrent chan Result, result Result) {
  timer:=time.NewTimer(time.Second)
  concurrent=make(chan Result)
  // Start the concurrent computation. Its result will be received 
  // from the channel
  go func() {
     concurrent &lt;- processData()
  }()
  // Wait until result is available, or timer expires
  select {
     case result:=&lt;-concurrent:
        // Result became available quickly. Stop the timer and return 
        //the result.
        timer.Stop()
        return nil,result
     case &lt;-timer.C:
        // Timer expired before result is computed. Return the channel
        return concurrent,Result{}
  }
}</pre>			<p>Note that the timer can expire right before the <strong class="source-inline">timer.Stop()</strong> call. This is okay. Timers will eventually expire and be garbage collected. Calling <strong class="source-inline">timer.Stop()</strong> simply prevents the timer from being active longer <span class="No-Break">than necessary.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">You cannot call <strong class="source-inline">Timer.Stop</strong> concurrently while another goroutine is listening from the timer. So, if you have to call <strong class="source-inline">Timer.Stop</strong>, call it from the same goroutine that listens to the <span class="No-Break">timer’s channel.</span></p>
			<p>The same thing <a id="_idIndexMarker124"/>can be achieved <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">time.After</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
  concurrent=make(chan Result)
  // Start the concurrent computation. Its result will be received 
  // from the channel
  go func() {
     concurrent &lt;- processData()
  }()
  select {
     case result:=&lt;-concurrent:
        return nil,result
     case &lt;-time.After(time.Second):
        return concurrent,Result{}
  }</pre>			<h1 id="_idParaDest-112"><a id="_idTextAnchor112"/>Tickers</h1>
			<p>Use <strong class="source-inline">time.Ticker</strong> to perform a<a id="_idIndexMarker125"/> task periodically. You will periodically receive a signal through a channel. Unlike <strong class="source-inline">time.Timer</strong>, you have to be careful about how you dispose of tickers. If you forget to stop a ticker, it will not be garbage collected once it is out of scope, and it <span class="No-Break">will leak.</span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor113"/>How to do it...</h2>
			<ol>
				<li>Use <strong class="source-inline">time.Ticker</strong> to create a <span class="No-Break">new ticker.</span></li>
				<li>Read from the ticker’s channel to receive the <span class="No-Break">periodic ticks.</span></li>
				<li>When you are done with the ticker, stop it. You don’t have to drain the <span class="No-Break">ticker’s channel.</span></li>
			</ol>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor114"/>How it works...</h2>
			<p>Use a ticker for<a id="_idIndexMarker126"/> periodic events. A common pattern is <span class="No-Break">the following:</span></p>
			<pre class="source-code">
func poorMansClock(done chan struct{}) {
  // Create a new ticker with a 1 second period
  ticker:=time.NewTicker(time.Second)
  // Stop the ticker once we're done
  defer ticker.Stop()
  for {
    select {
      case &lt;-done:
         return
      case &lt;-ticker.C:
         fmt.Println(time.Now())
    }
  }
}</pre>			<p>What happens if you miss ticks? This is possible if you run a long process that prevents you from listening to the ticker channel. Will the ticker send a flood of ticks when you start <span class="No-Break">listening again?</span></p>
			<p>Similar to <strong class="source-inline">time.Timer</strong>, <strong class="source-inline">time.Ticker</strong> uses a channel with a capacity of <strong class="source-inline">1</strong>. Because of this, if you do not read from the channel, it can store, at most, one tick. When you start listening from the channel again, you will receive the tick that you missed immediately, and the next tick when its period expires. For example, consider the following program <a id="_idIndexMarker127"/>that calls a given function <span class="No-Break">every second:</span></p>
			<pre class="source-code">
func everySecond(f func(), done chan struct{}) {
  // Create a new ticker with a 1 second period
  ticker:=time.NewTicker(time.Second)
  start:=time.Now()
  // Stop the ticker once we're done
  defer ticker.Stop()
  for {
    select {
      case &lt;-done:
         return
      case &lt;-ticker.C:
         fmt.Println(time.Since(start).Milliseconds())
         // Call the function
         f()
    }
  }
}</pre>			<p>Let’s say the first call to <strong class="source-inline">f()</strong> runs for 10 milliseconds, but the second call runs for 1.5 seconds. While <strong class="source-inline">f()</strong> is running, there is nobody reading from the ticker’s channel, so a tick will be missed. Once <strong class="source-inline">f()</strong> returns, the <strong class="source-inline">select</strong> statement will immediately read this missed tick, and<a id="_idIndexMarker128"/> after 500 milliseconds, it will receive the next tick. The output looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
1000
2000
3500
4000
5000
...</pre>			<p class="callout-heading">Tip</p>
			<p class="callout">Unlike <strong class="source-inline">time.Timer</strong>, you can stop a ticker concurrently while reading from <span class="No-Break">its channel.</span></p>
		</div>
	</div></div></body></html>