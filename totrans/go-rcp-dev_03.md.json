["```go\nd := time.Date(2020, 3, 31, 15, 30, 0, 0, time.UTC)\nfmt.Println(d)\n// 2020-03-31 15:30:00 +0000 UTC\n```", "```go\nd := time.Date(2020, 3, 0, 15, 30, 0, 0, time.UTC)\nfmt.Println(d)\n// 2020-02-29 15:30:00 +0000 UTC\n```", "```go\nd := time.Date(2020, 3, 0, 15, 30, 0, 0, time.UTC)\nfmt.Println(d.Day())\n// 29\n```", "```go\ndur := tm1.Sub(tm2)\n```", "```go\n// Add 1 day to duration\ndur+=time.Hour*24\n```", "```go\nnow := time.Now()\nthen := now.Add(dur)\n```", "```go\nfmt.Println( then.Add(-dur).Equal(now) )\n```", "```go\nif object.Expiration.After(time.Now()) {\n   // Object expired\n}\n```", "```go\nt:=time.Now()\n// Subtract 1 year from now to get this moment in last year\nlastYear := t.AddDate(-1,0,0)\n// Add 1 day to get same time tomorrow\ntomorrow := t.AddDate(0,0,1)\n// Add 1 day to get the next month\nnextMonth := t.AddDate(0,1,0)\n```", "```go\nd := time.Date(2020, 3, 31, 0, 0, 0, 0, time.UTC)\nfmt.Println(d.AddDate(0, 1, 0).AddDate(0, 1, 0))\n// 2020-06-01 00:00:00 +0000 UTC\nfmt.Println(d.AddDate(0, 2, 0))\n// 2020-05-31 00:00:00 +0000 UTC\n```", "```go\nfunc main() {\n  t := time.Date(2024, 3, 8, 18, 2, 13, 500, time.UTC)\n  fmt.Println(\"Date in yyyy/mm/dd format\", t.Format(\"2006/01/02\"))\n  // Date in yyyy/mm/dd format 2024/03/08\n  fmt.Println(\"Date in yyyy/m/d format\", t.Format(\"2006/1/2\"))\n  // Date in yyyy/m/d format 2024/3/8\n  fmt.Println(\"Date in yy/m/d format\", t.Format(\"06/1/2\"))\n  // Date in yy/m/d format 24/3/8\n  fmt.Println(\"Time in hh:mm format (12 hr)\", t.Format(\"03:04\"))\n  // Time in hh:mm format (12 hr) 06:02\n  fmt.Println(\"Time in hh:m format (24 hr)\", t.Format(\"15:4\"))\n  // Time in hh:m format (24 hr) 18:2\n  fmt.Println(\"Date-time with time zone\", t.Format(\"2006-01-02 \n  13:04:05 -07:00\"))\n  // Date-time with time zone 2024-03-08 36:02:13 +00:00\n}\n```", "```go\nloc, _ := time.LoadLocation(\"America/Denver\")\nconst format = \"Jan 2, 2006 at 3:04pm\"\nstr, _ := time.ParseInLocation(format, \"Jul 9, 2012 at 5:02am\", loc)\nfmt.Println(str)\n// 2012-07-09 05:02:00 -0600 MDT\nstr, _ = time.ParseInLocation(format, \"Jan 9, 2012 at 5:02am\", loc)\nfmt.Println(str)\n// 2012-01-09 05:02:00 -0700 MST\n```", "```go\n// Create a new time using the local time zone\nt := time.Date(2021,12,31,15,0,0,0, time.Local)\n// 2021-12-31 15:00:00 -0700 MST\n```", "```go\nutcTime := t.In(time.UTC)\nfmt.Println(utcTime)\n// 2021-12-31 22:00:00 +0000 UTC\nny,err:=time.LoadLocation(\"America/New_York\")\nif err!=nil {\n  panic(err)\n}\nnyTime := t.In(ny)\nfmt.Println(nyTime)\n// 2021-12-31 17:00:00 -0500 EST\n```", "```go\nzone30 := time.FixedZone(\"30min\", 30)\nfmt.Println(t.In(zone30))\n// 2021-12-31 22:00:30 +0000 30min\n```", "```go\n// Create a local time, UTC zone\nt := time.Date(2021,12,31,15,0,0,0, time.UTC)\n// 2021-12-31 15:00:00 +0000 UTC\n```", "```go\nny,err:=time.LoadLocation(\"America/New_York\")\nif err!=nil {\n  panic(err)\n}\nnyTime := time.Date(t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second(), t.Nanosecond(), ny)\nfmt.Println(nyTime)\n// 2021-12-31 15:00:00 -0500 EST\n```", "```go\n    func GetTimeOfDay(t time.Time) time.Duration {\n      beginningOfDay:=time.Date(t.Year(),t.Month(),t.\n      Day(),0,0,0,0,t.Location())\n      return t.Sub(beginningOfDay)\n    }\n    ```", "```go\n    date:=time.Date(t.Year(), t.Month(), t.Day(), 0,0,0,0,t.Location())\n    ```", "```go\n// Create a 10-second timer\ntimer := time.NewTimer(time.Second*10)\n```", "```go\nfunc longProcess() {\n  timer := time.NewTimer(time.Second*10)\n  for {\n     processData()\n     select {\n       case <-timer.C:\n          // 2 seconds passed\n          return\n       default:\n     }\n  }\n}\n```", "```go\nfunc longComputation() (concurrent chan Result, result Result) {\n  timer:=time.NewTimer(time.Second)\n  concurrent=make(chan Result)\n  // Start the concurrent computation. Its result will be received \n  // from the channel\n  go func() {\n     concurrent <- processData()\n  }()\n  // Wait until result is available, or timer expires\n  select {\n     case result:=<-concurrent:\n        // Result became available quickly. Stop the timer and return \n        //the result.\n        timer.Stop()\n        return nil,result\n     case <-timer.C:\n        // Timer expired before result is computed. Return the channel\n        return concurrent,Result{}\n  }\n}\n```", "```go\n  concurrent=make(chan Result)\n  // Start the concurrent computation. Its result will be received \n  // from the channel\n  go func() {\n     concurrent <- processData()\n  }()\n  select {\n     case result:=<-concurrent:\n        return nil,result\n     case <-time.After(time.Second):\n        return concurrent,Result{}\n  }\n```", "```go\nfunc poorMansClock(done chan struct{}) {\n  // Create a new ticker with a 1 second period\n  ticker:=time.NewTicker(time.Second)\n  // Stop the ticker once we're done\n  defer ticker.Stop()\n  for {\n    select {\n      case <-done:\n         return\n      case <-ticker.C:\n         fmt.Println(time.Now())\n    }\n  }\n}\n```", "```go\nfunc everySecond(f func(), done chan struct{}) {\n  // Create a new ticker with a 1 second period\n  ticker:=time.NewTicker(time.Second)\n  start:=time.Now()\n  // Stop the ticker once we're done\n  defer ticker.Stop()\n  for {\n    select {\n      case <-done:\n         return\n      case <-ticker.C:\n         fmt.Println(time.Since(start).Milliseconds())\n         // Call the function\n         f()\n    }\n  }\n}\n```", "```go\n1000\n2000\n3500\n4000\n5000\n...\n```"]