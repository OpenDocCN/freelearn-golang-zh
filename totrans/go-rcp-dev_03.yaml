- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Date and Time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with date and time can be difficult in any programming language. Go’s
    standard library offers easy-to-use tools to work with date and time constructs.
    These may be somewhat different from what many people are used to. For example,
    there are libraries in different languages that make a distinction between a `time`
    type and a `date` type. Go’s standard library only includes a `time.Time` type.
    That might make you feel disoriented when you’re working with Go’s time.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’d like to think that Go’s treatment of date/time reduces the chances of creating
    subtle bugs. You see, you have to be really careful and clear about what you mean
    when you talk about time: are you talking about a point in time or an interval?
    A date is actually an interval (for instance, 08/01/2024 starts at 08/01/2024T00:00:00
    and continues until 08/01/2024T23:59:59) even though usually that is not the intent.
    A specific date/time value also depends on where you are measuring time. 2023-11-05T08:00
    in Denver, Colorado is different from 2023-11-05T08:00 in Berlin, Germany. Time
    always moves forward, but date/time may skip or go backward: after 2023-11-05T02:59
    in Denver, Colorado, time goes back to 2023-11-05T02:00 because that is when daylight
    savings time ends in Colorado. So there are actually two time instances for 2023-11-05T02:10:10,
    one in Mountain Daylight Time, and one in Mountain Standard Time.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many software bugs in production today that handle time incorrectly.
    For example, if you are computing when the subscription of a customer ends, you
    have to take into account the location of that customer and the time of day that
    subscription ends, otherwise, their subscriptions may terminate early (or late)
    on their last day.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes for working with date/time correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Unix time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date/time components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date/time arithmetic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatting and parsing date/time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with time zones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tickers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing time information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Unix time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unix time is the number of seconds (or milliseconds, microseconds, or nanoseconds)
    passed since January 1, 1970 UTC (the epoch.) Go uses `int64` to represent these
    values, so Unix time as seconds can represent billions of years into the past
    or the future. Unix time as nanoseconds can represent date values between 1678
    and 2262\. Unix time is an absolute measure of an instance as the duration since
    (or until) the epoch. It is independent of the location, so with two Unix times,
    `s` and `t`, if `s<t`, then `s` happened before `t`, no matter the location. Because
    of these properties, Unix time is usually used as a timestamp that marks when
    an event happened (when a log is written, when a record is inserted, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get the current Unix time, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.Now().Unix() int64`: Unix time in seconds'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.Now().UnixMilli() int64`: Unix time in milliseconds'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.Now().UnixMicro() int64`: Unix time in microseconds'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.Now().UnixNano() int64`: Unix time in nanoseconds'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given a Unix time, convert it to a `time.Time` type using the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.Unix(sec, nanosec int64) time.Time`: Translate Unix time in seconds and/or
    nanoseconds to `time.Time`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.UnixMilli(int64) time.Time`: Translate Unix time in milliseconds to `time.Time`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.UnixMicro(int64) time.Time`: Translate Unix time in microseconds to `time.Time`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To translate a Unix time to local time, use `localTime := time.Unix(unixTimeSeconds,0).In(location)`,
    where `location` is a `*time.Location` for the location in which to interpret
    the Unix time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Date/time components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with date values, you often have to compose a date/time from its
    components or need to access the components of a date/time value. This recipe
    shows how it can be done.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To build a date/time value from parts, use the `time.Date` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get the parts of a date/time value, use the `time.Time` methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.Day() int`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.Month() time.Month`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.Year() int`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.Date() (year, month,` `day int)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.Hour() int`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.Minute() int`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.Second() int`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.Nanosecond() int`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.Zone() (name` `string,offset int)`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.Location() *time.Location`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time.Date` will create a time value from its components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be normalized, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since the day of the month starts from 1, creating a date with a `0` day will
    result in the last day of the previous month.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a `time.Time` value, you can get its components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Again, `time.Date` normalizes the date value, so `d.Day()` will return `29`.
  prefs: []
  type: TYPE_NORMAL
- en: Date/time arithmetic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Date/time arithmetic is necessary to answer questions such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How long did it take to complete an operation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What time will it be after 5 minutes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many days are there until next month?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe shows how you can answer these questions using the `time` package.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To find out how much time has passed between two instances in time, use the
    `Time.Sub` method to subtract them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find the duration from now to a later time, use `time.Until(laterTime)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find how much time has passed since a given time, use `time.Since(beforeTime)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find out what time it will be after a certain duration, use the `Time.Add`
    method. Use negative duration to find the time before a certain duration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add/subtract years, months, or days to/from a time, use the `Time.AddDate`
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To compare two `time.Time` values, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Time.Equal` to check whether two time values represent the same instance'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Time.Before` or `Time.After` to check whether a time value is before or after
    a given time value'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `time.Duration` type represents the time elapsed between two instances in
    nanoseconds as an `int64` value. In other words, if you subtract a `time.Time`
    value from another, you get a `time.Duration`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `Duration` is an `int64` representing nanoseconds, you can do duration
    arithmetic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that the last operation in the preceding also involves multiplication since
    `time.Hour` is of the `time.Duration` type itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add a duration value to a `time.Time` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Duration being an `int64` means that a `time.Duration` value is limited to around
    290 years. This should be sufficient for most practical cases. However, if this
    is not the case for you, you need to build a solution for yourself or find a third-party
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can subtract the duration from a `time.Time` value by adding a negative
    duration value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the `Time.Equal` method. This compares two time instances taking
    into account their time zones, which can be different. For instance, `Time.Equal`
    will return `true` for `2024-01-09 09:00 MST` and `2024-01-09` `08:00 PST`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `Time.Before` and `Time.After` to compare time values. For instance, you
    can check whether an object with an expiration date has expired by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add years/months/days to a given date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of these operations will be normalized. For instance, if you subtract
    a year from `2020-02-29`, you will get `2019-03-01`. This causes problems when
    you are working with a date at the end of a month and you have to add/subtract
    month values. Adding a month to `2020-03-31` twice will yield `2020-06-01`, but
    adding two months will yield `2020-05-31`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Formatting and parsing date/time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go uses an interesting and somewhat controversial date/time formatting scheme.
    The date/time format is expressed using a specific point in time, adjusted such
    that every component of the date/time is a unique number:'
  prefs: []
  type: TYPE_NORMAL
- en: '1 is the month: “Jan” “January” “01” “1”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2 is the day of the month: “2” “_2” “02”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3 is the hour of the day in a 12-hour format: “15” “3” “03”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 15 is the hour of the day in a 24-hour format,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '4 is the minute: “4” “04”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '5 is the second: “5” “05”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '6 is the year: “2006” “06”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MST is the timezone: “-0700” “-07:00” “-07” “-070000” “-07:00:00” “MST”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '0 is the millisecond padded with 0s: “0” “000”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '9 is the millisecond that is not padded: “9” “999”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `time.Parse` with an appropriate format to parse date/time. Any parts of
    the date/time that are not specified in the format will be initialized to its
    zero value, which is January for months, 1 for the year, 1 for the day of the
    month, and 0 for everything else. If the time zone information is missing, the
    parsed date/time will be in UTC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `time.ParseInLocation` to parse date/time in a given location. The time
    zone will be determined based on the date value and the location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `Format()` method to format a date/time value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Time zones change by location and by date. In the following example, even though
    the same location is used to parse the date, the time zone changes because July
    9 is Mountain Daylight Time, but January 9 is Mountain Standard Time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Working with time zones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Go `time.Time` value includes `time.Location`, which can be one of two
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: A real location, such as `America/Denver`. If this is the case, the actual time
    zone depends on the time value. For `Denver`, the time zone will be either `MDT`
    (Mountain Daylight Time) or `MST` (Mountain Standard Time) depending on the actual
    time value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A fixed time zone that gives the offset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some applications work with **local time**. This is the date/time value captured
    at a particular location, and interpreted as the same value everywhere, as opposed
    to being interpreted as the same point in time. Birthdays (and thus, ages) are
    usually interpreted using local time. That is, if you are born on 2005-07-14,
    you will be considered 2 years old in New York (Eastern time zone) on 2007-07-14
    at 00:00, but still be 1 year old at the same moment in time in Los Angeles, which
    is 2007-07-13 at 21:00 (Pacific time zone).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are working with moments in time, always capture date/time values with
    the associated location. Such date/time values can be translated into other time
    zones easily.
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with local time in multiple time zones, recreate `time.Time`
    in a new location or time zone to translate.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you create a `time.Time`, it is always associated with a location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have a `time.Time`, you can get the same moment in time in different
    time zones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: These are different representations of the same moment in time in different
    time zones.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create a custom time zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When you are dealing with local time, you discard the location and time zone
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the same time value in New York, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Storing time information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common problem is storing date/time information in databases, files, and so
    on in a portable manner, so that it can be interpreted correctly.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should first identify the exact needs: do you need to store an instant
    of time or time of day?'
  prefs: []
  type: TYPE_NORMAL
- en: 'To store an instant of time, do one of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store Unix time at the needed granularity (that is, `time.Unix` for seconds,
    `time.UnixMilli` for milliseconds, etc.)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Store UTC time (`time.UTC()`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To store the time of day, store the `time.Duration` value that gives the instant
    in the day. The following function computes the instant within that day as `time.Duration`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To store a date value, you can clear the time portions of `time.Time`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that comparing dates stored in this manner can be problematic as each day
    will be interpreted to be a different instant in different time zones.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use `time.Timer` to schedule some work to be done in the future. When the timer
    expires, you will receive a signal from a channel. You can use a timer to run
    a function later or to cancel a process that ran too long.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create a timer in one of two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `time.NewTimer` or `time.After`. The timer will send a signal through a
    channel when it expires. Use a `select` statement, or read from the channel to
    receive the timer expiration signal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `time.AfterFunc` to call a function when the timer expires.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `time.Timer` timer is created with `time.Duration`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The timer contains a channel that will receive the current timestamp after 10
    seconds pass. A timer is created with a channel capacity of `1`, so the timer
    runtime will always be able to write to that channel and stop the timer. In other
    words, if you fail to read from a timer, it will not leak; it will eventually
    be garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The timer can be used to stop a long-running process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how a timer can be used to limit the time it takes
    to return from a function. If the computation completes within a second, the response
    is returned. If the computation takes longer, the function returns a channel that
    the caller can use to receive the result. This function also demonstrates how
    you can stop a timer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that the timer can expire right before the `timer.Stop()` call. This is
    okay. Timers will eventually expire and be garbage collected. Calling `timer.Stop()`
    simply prevents the timer from being active longer than necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You cannot call `Timer.Stop` concurrently while another goroutine is listening
    from the timer. So, if you have to call `Timer.Stop`, call it from the same goroutine
    that listens to the timer’s channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same thing can be achieved with `time.After`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tickers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use `time.Ticker` to perform a task periodically. You will periodically receive
    a signal through a channel. Unlike `time.Timer`, you have to be careful about
    how you dispose of tickers. If you forget to stop a ticker, it will not be garbage
    collected once it is out of scope, and it will leak.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `time.Ticker` to create a new ticker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read from the ticker’s channel to receive the periodic ticks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you are done with the ticker, stop it. You don’t have to drain the ticker’s
    channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use a ticker for periodic events. A common pattern is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: What happens if you miss ticks? This is possible if you run a long process that
    prevents you from listening to the ticker channel. Will the ticker send a flood
    of ticks when you start listening again?
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to `time.Timer`, `time.Ticker` uses a channel with a capacity of `1`.
    Because of this, if you do not read from the channel, it can store, at most, one
    tick. When you start listening from the channel again, you will receive the tick
    that you missed immediately, and the next tick when its period expires. For example,
    consider the following program that calls a given function every second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s say the first call to `f()` runs for 10 milliseconds, but the second
    call runs for 1.5 seconds. While `f()` is running, there is nobody reading from
    the ticker’s channel, so a tick will be missed. Once `f()` returns, the `select`
    statement will immediately read this missed tick, and after 500 milliseconds,
    it will receive the next tick. The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `time.Timer`, you can stop a ticker concurrently while reading from its
    channel.
  prefs: []
  type: TYPE_NORMAL
