<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer012">
			<h1 id="_idParaDest-115" class="chapter-number"><a id="_idTextAnchor115"/>4</h1>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor116"/>Working with Arrays, Slices, and Maps</h1>
			<p>Arrays, slices, and maps are the built-in container types defined by the Go language. They are essential parts of almost every program, and usually, the building blocks of other data structures. This section describes some of the common patterns of working with these basic data structures, as they have nuances that may not be obvious to <span class="No-Break">a newcomer.</span></p>
			<p>In this chapter, we will talk about <span class="No-Break">the following:</span></p>
			<ul>
				<li>Working <span class="No-Break">with arrays</span></li>
				<li>Working <span class="No-Break">with slices</span></li>
				<li>Implementing a stack <span class="No-Break">using slices</span></li>
				<li>Working <span class="No-Break">with maps</span></li>
				<li><span class="No-Break">Implementing sets</span></li>
				<li>Using maps for <span class="No-Break">thread-safe caching</span></li>
			</ul>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor117"/>Working with arrays</h1>
			<p>Arrays are fixed-size data structures. There is no way to resize an array or to create an array using a <a id="_idIndexMarker129"/>variable as its size (in other words, <strong class="source-inline">[n]int</strong> is valid only if <strong class="source-inline">n</strong> is a constant integer). Because of this, arrays are useful to represent an object with a fixed number of elements, such as a SHA256 hash, which is <span class="No-Break">32 bytes.</span></p>
			<p>The zero-value for an array has zero-values for every element of the array. For instance, <strong class="source-inline">[5]int</strong> is initialized with five integers, all 0. A string array will have <span class="No-Break">empty strings.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor118"/>Creating arrays and passing them around</h2>
			<p>This recipe <a id="_idIndexMarker130"/>shows how you can create arrays and pass array values <a id="_idIndexMarker131"/>to functions and methods. We will also talk about the effects of passing arrays <span class="No-Break">as values.</span></p>
			<h3>How to do it...</h3>
			<ol>
				<li>Create arrays using a <span class="No-Break">fixed size:</span><pre class="source-code">
var arr [2]int // Array of 2 ints</pre><p class="list-inset">You can also declare an array using an array literal without specifying <span class="No-Break">its size:</span></p><pre class="source-code">x := [...]int{1,2} // Array of 2 ints</pre><p class="list-inset">You can specify array indexes similar to defining <span class="No-Break">a map:</span></p><pre class="source-code">y := [...]int{1, 4: 10} // Array of 5 ints,
// [0]1, y[4]=10, all other elements are 0
// [1 0 0 0 10]</pre></li>				<li>Use arrays to define new types of <span class="No-Break">fixed-size data:</span><pre class="source-code">
// SHA256 hash is 256 bits - 32 bytes
type SHA256 [32]byte</pre></li>				<li>Arrays are passed <span class="No-Break">by value:</span><pre class="source-code">
func main() {
  var h SHA256
  h = getHash()
  // f will get a 32-byte array that is a copy of h
  f(h)
...
}
func f(hash SHA256) {
  hash[0]=0 // This changes the copy of `hash` passed to `f`.
            // It does not affect the `h` value declared in main
  ...
}</pre></li>			</ol>
			<p class="callout-heading">Warning</p>
			<p class="callout">Passing an array <a id="_idIndexMarker132"/>by value means that every time you use an array as an argument to a function, the array will be copied. If you pass an array <strong class="source-inline">[1000]int64</strong> to a function, the runtime will allocate and copy 8,000 bytes (int64 is 64 bits, which is 8 bytes, and 1,000 int64 values is 8,000 bytes.) The copy will be a shallow copy – that is, you pass an array containing pointers, or, if you pass an array containing structures containing pointers, the pointers will be copied, not the contents of <span class="No-Break">those pointers.</span></p>
			<p>See the <a id="_idIndexMarker133"/><span class="No-Break">following example:</span></p>
			<pre class="source-code">
func f(m [2]map[string]int) {
   m[0]["x"]=1
}
func main() {
  array := [2]map[string]int{}
  // A copy of array is passed to f
  // but array[0] and array[1] are maps
  // Contents of those maps are not copied.
  f(array)
  fmt.Println(array[0])
  // This will print [x:1]
}</pre>			<h1 id="_idParaDest-119"><a id="_idTextAnchor119"/>Working with slices</h1>
			<p>A slice is a <a id="_idIndexMarker134"/>view over an array. You may be dealing with multiple slices that work with the same <span class="No-Break">underlying data.</span></p>
			<p>The zero-value for a slice is nil. Reading or writing a nil slice will <strong class="source-inline">panic</strong>; however, you can append to a nil slice, which will create a <span class="No-Break">new slice.</span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor120"/>Creating slices</h2>
			<p>There are <a id="_idIndexMarker135"/>several ways a slice can <span class="No-Break">be created.</span></p>
			<h3>How to do it...</h3>
			<p><span class="No-Break">Use </span><span class="No-Break"><strong class="source-inline">make(sliceType,length[,capacity])</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
slice1 := make([]int,0)
// len(slice1)=0, cap(slice1)=0
slice2 := make([]int,0,10)
// len(slice2)=0, cap(slice2)=10
slice3 := make([]int,10)
// len(slice3)=10, cap(slice3)=10</pre>			<p>In the previous code snippet, you see three different uses of <strong class="source-inline">make</strong> to create <span class="No-Break">a slice:</span></p>
			<ul>
				<li><strong class="source-inline">slice1:=make([]int,0)</strong> creates an empty slice, <strong class="source-inline">0</strong> being the length of the slice. The <strong class="source-inline">slice1</strong> variable is initialized as a non-nil, <span class="No-Break">0-length slice.</span></li>
				<li><strong class="source-inline">slice2 := make([]int,0,10)</strong> creates an empty slice with capacity <strong class="source-inline">10</strong>. This is what you should prefer if you know the likely maximum size for this slice. This slice allocation avoids an allocate/copy operation up until the 11th element <span class="No-Break">is appended.</span></li>
				<li><strong class="source-inline">slice3 := make([]int,10)</strong> creates a slice with size <strong class="source-inline">10</strong> and capacity <strong class="source-inline">10</strong>. The slice elements are initialized to 0. In general, with this form, the allocated slice will be initialized to the zero-value of its <span class="No-Break">element type.</span></li>
			</ul>
			<p class="callout-heading">Tip</p>
			<p class="callout">Be careful about allocating a slice with a non-zero length. I personally had to deal with really obscure bugs because I mistyped <strong class="source-inline">make([]int,10)</strong> instead of <strong class="source-inline">make([]int,0,10)</strong>, and continued to append the 10 elements to the allocated slice, ending with <span class="No-Break">20 elements.</span></p>
			<p>See the <a id="_idIndexMarker136"/><span class="No-Break">following example:</span></p>
			<pre class="source-code">
values:=make([]string,10)
for _,s:=range results {
  if someFunc(s) {
    values=append(values,s)
  }
}</pre>			<p>The previous code snippet creates a string slice that has <strong class="source-inline">10</strong> empty strings, then the strings are appended by <span class="No-Break">the for-loop.</span></p>
			<p>You can also initialize a slice using <span class="No-Break">a literal:</span></p>
			<pre class="source-code">
slice := []int{1,2,3,4,5}
// len(slice)=5 cap(slice)=5</pre>			<p>Alternatively, you can leave a slice variable <strong class="source-inline">nil</strong>, and append to it. The <strong class="source-inline">append</strong> built-in will accept a <strong class="source-inline">nil</strong> slice, and <span class="No-Break">create one:</span></p>
			<pre class="source-code">
// values slice is nil after declaration
var values []string
for _,x:=range results {
  if someFunc(s) {
    values=appennd(values, s)
  }
}</pre>			<h1 id="_idParaDest-121"><a id="_idTextAnchor121"/>Creating a slice from an array</h1>
			<p>Many functions <a id="_idIndexMarker137"/>will accept slices and not arrays. If you have an <a id="_idIndexMarker138"/>array of values and need to pass it to a function that wants a slice, you need to create a slice from an array. This is easy and efficient. Creating a slice from an array is a <span class="No-Break">constant-time operation.</span></p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor122"/>How to do it...</h2>
			<p>Use the <strong class="source-inline">[:]</strong> notation to create a slice from the array. The slice will have the array as its <span class="No-Break">underlying storage:</span></p>
			<pre class="source-code">
arr := [...]int{0, 1, 2, 3, 4, 5}
slice := arr[:] // slice has all elements of arr
slice[2]=10
// Here, arr = [...]int{0,1,10,3, 4,5}
// len(slice) = 6
// cap(slice) = 6</pre>			<p>You can create a slice pointing to a section of <span class="No-Break">the array:</span></p>
			<pre class="source-code">
slice2 := arr[1:3]
// Here, slice2 = {1,10}
// len(slice2) = 2
// cap(slice2) = 5</pre>			<p>You can slice an existing slice. The bounds of the slicing operation are determined by the capacity of the <span class="No-Break">original slice:</span></p>
			<pre class="source-code">
slice3 := slice2[0:4]
// len(slice3)=4
// cap(slice3)=5
// slice3 = {1,10,3,4}</pre>			<h2 id="_idParaDest-123"><a id="_idTextAnchor123"/>How it works...</h2>
			<p>A slice is <a id="_idIndexMarker139"/>a data structure containing three values: slice length, capacity, and pointer to the underlying array. Slicing an array simply creates this data structure <a id="_idIndexMarker140"/>with a pointer initialized to the array. It is a <span class="No-Break">constant-time operation.</span></p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B21961_04_1.jpg" alt="Figure 4.1 – Difference between an array arr and a slice arr[:]" width="561" height="680"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Difference between an array arr and a slice arr[:]</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor124"/>Appending/inserting/deleting slice elements</h1>
			<p>Slices use arrays as their underlying storage, but it is not possible to grow arrays when you run <a id="_idIndexMarker141"/>out of space. Because of this, if an <strong class="source-inline">append</strong> operation <a id="_idIndexMarker142"/>exceeds the slice capacity, a new and larger <a id="_idIndexMarker143"/>array is allocated, and slice contents are copied to this <span class="No-Break">new array.</span></p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor125"/>How to do it...</h2>
			<p>To add new values to the end of the slice, use the <strong class="source-inline">append</strong> <span class="No-Break">built-in function:</span></p>
			<pre class="source-code">
// Create an empty integer slice
islice := make([]int, 0)
// Append values 1, 2, 3 to islice, assign it to newSlice
newSlice := append(islice, 1, 2, 3)
// islice:  []
// newSlice: [1 2 3]
// Create an empty integer slice
islice = make([]int, 0)
// Another integer slice with 3 elements
otherSlice := []int{1, 2, 3}
// Append 'otherSlice' to 'islice'
newSlice = append(islice, otherSlice...)
newSlice = append(newSlice, otherSlice...)
// islice: []
// otherSlice: [1 2 3]
// newSlice: [1 2 3 1 2 3]</pre>			<p>To remove elements from the beginning or the end of a slice, <span class="No-Break">use slicing:</span></p>
			<pre class="source-code">
slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
// Slice elements starting from index 1
suffix := slice[1:]
// suffix: [1 2 3 4 5 6 7 8 9]
// Slice elements starting from index 3
suffix2 := slice[3:]
// suffix2: [3 4 5 6 7 8 9]
// Slice elements up to index 5 (excluding 5)
prefix := slice[:5]
// prefix: [0 1 2 3 4]
// Slice elements from 3 up to index 6 (excluding 6)
mid := slice[3:6]
// [3 4 5]</pre>			<p>Use the <strong class="source-inline">slices</strong> package <a id="_idIndexMarker144"/>to insert/delete elements from <a id="_idIndexMarker145"/>arbitrary locations in <span class="No-Break">a slice:</span></p>
			<ul>
				<li><strong class="source-inline">slices.Delete(slice,i,j)</strong> removes <strong class="source-inline">slice[i:j]</strong> elements from the slice <a id="_idIndexMarker146"/>and returns the <span class="No-Break">modified slice</span></li>
				<li><strong class="source-inline">slices.Insert(slice,i,value...)</strong> inserts the values starting at index <strong class="source-inline">i</strong>, shifting all elements starting from <strong class="source-inline">i</strong> to <span class="No-Break">make space</span></li>
			</ul>
			<pre class="source-code">
slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
// Remove the section slice[3:7]
edges := slices.Delete(slice, 3, 7)
// edges: [0 1 2 7 8 9]
// slice: [0 1 2 7 8 9 0 0 0 0]
inserted := slices.Insert(slice, 3, 3, 4)
// inserted: [0 1 2 3 4 7 8 9 0 0 0 0]
// edges: [0 1 2 7 8 9]
// slices: [0 1 2 7 8 9 0 0 0 0]</pre>			<p>Alternatively, you <a id="_idIndexMarker147"/>can remove <a id="_idIndexMarker148"/>elements from <a id="_idIndexMarker149"/>a slice and truncate it using a for-loop, like in <span class="No-Break">the following:</span></p>
			<pre class="source-code">
slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
// Keep an index to write to
write:=0
for _, elem := range slice {
  if elem %2 == 0 { // Copy only even numbers
    slice[write]=elem
    write++
  }
}
// Truncate the slice
slice=slice[:write]</pre>			<h2 id="_idParaDest-126"><a id="_idTextAnchor126"/>How it works...</h2>
			<p>A slice is a view over an array. It contains three pieces <span class="No-Break">of information:</span></p>
			<ul>
				<li><strong class="source-inline">ptr</strong>: A pointer to an element of an array, which is the starting location of <span class="No-Break">the slice</span></li>
				<li><strong class="source-inline">len</strong>: The number of elements in <span class="No-Break">the slice</span></li>
				<li><strong class="source-inline">cap</strong>: The capacity remaining in the underlying array for <span class="No-Break">this slice</span></li>
			</ul>
			<p>If you append elements to a slice beyond its capacity, a larger array is allocated by the runtime, and the contents of the slice are copied there. After this, the new slice points to a <span class="No-Break">new array.</span></p>
			<p>This is a <a id="_idIndexMarker150"/>source of confusion for many. A slice may share its elements <a id="_idIndexMarker151"/>with other slices. Thus, modifying one slice may <a id="_idIndexMarker152"/>modify others <span class="No-Break">as well.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.2</em> illustrates a case where the same underlying array is used for four <span class="No-Break">different slices:</span></p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B21961_04_2.jpg" alt="Figure 4.2 – Slices sharing the same underlying array" width="911" height="684"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Slices sharing the same underlying array</p>
			<p>See the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
// Appends 1 to a slice, and returns the new slice
func Append1(input []int) []int {
  return append(input,1)
}
func main() {
   slice:= []int{0,1,2,3,4,5,6,7,8,9}
   shortSlice := slice[:4]
   // shortSlice: []int{0,1,2,3}
   newSlice:=Append1(slice[:4])
   // newSlice:= []int{0,1,2,3,1}
   // slice: []int{0,1,2,3,1,5,6,7,8,9}
}</pre>			<p>Note that appending to <strong class="source-inline">newSlice</strong> also modified an element of <strong class="source-inline">slice</strong>, because <strong class="source-inline">newSlice</strong> has enough capacity to accommodate one more element, which <span class="No-Break">overwrites </span><span class="No-Break"><strong class="source-inline">slice[4]</strong></span><span class="No-Break">.</span></p>
			<p>Truncating a <a id="_idIndexMarker153"/>slice is simply creating a new slice that is shorter <a id="_idIndexMarker154"/>than the original. The underlying array does not change. See <a id="_idIndexMarker155"/><span class="No-Break">the following:</span></p>
			<pre class="source-code">
slice:= []int{0,1,2,3,4,5,6,7,8,9}
newSlice:=slice[:5]
// newSlice: []int{0,1,2,3,4}</pre>			<p>Remember, <strong class="source-inline">newSlice</strong> is simply a data structure containing the same <strong class="source-inline">ptr</strong> and <strong class="source-inline">cap</strong> as <strong class="source-inline">slice</strong>, with a shorter <strong class="source-inline">len</strong>. Because of this, creating a new slice from an existing slice or an array is a constant-time <span class="No-Break">operation (O(1)).</span></p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor127"/>Implementing a stack using a slice</h1>
			<p>A surprisingly <a id="_idIndexMarker156"/>common use of a slice is to implement <a id="_idIndexMarker157"/>a stack. Here is how it <span class="No-Break">is done.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor128"/>How to do it...</h2>
			<p>A stack push is <span class="No-Break">simply </span><span class="No-Break"><strong class="source-inline">append</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// A generic stack of type T
type Stack[T any] []T
func (s *Stack[T]) Push(val T) {
     *s = append(*s, val)
}</pre>			<p>To implement <strong class="source-inline">pop</strong>, truncate <span class="No-Break">the slice:</span></p>
			<pre class="source-code">
func (s *Stack[T]) Pop() (val T) {
     val = (*s)[len(*s)-1]
     *s = (*s)[:len(*s)-1]
     return
}</pre>			<p>Again, note the use of parentheses and indirections. We cannot write <strong class="source-inline">*s[len(*s)-1]</strong>, because that is interpreted as <strong class="source-inline">*(s[len(*s)-1]</strong>. To prevent that, we <span class="No-Break">have </span><span class="No-Break"><strong class="source-inline">(*s)</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor129"/>Working with maps</h1>
			<p>You access <a id="_idIndexMarker158"/>the elements of an array or a slice using integer indexes. Maps provide a similar syntax to use index keys that are not only integers but also any type that is “comparable” (which means it can be compared using <strong class="source-inline">==</strong> or <strong class="source-inline">!=</strong>.) A map is an associative data type – that is, it stores key-value pairs. Each key appears once in a map. A Go map provides amortized constant-time access to its elements (that is, when measured over time, map element access should look like a <span class="No-Break">constant-time operation.)</span></p>
			<p>The Go <strong class="source-inline">map</strong> type provides convenient access to an underlying complicated data structure. It is one of the “reference” types –  that is, assigning a map variable to another map <a id="_idIndexMarker159"/>simply assigns a pointer to the underlying structure and does not copy the elements of <span class="No-Break">the map.</span></p>
			<p class="callout-heading">Warning</p>
			<p class="callout">A map is an unordered collection. Do not rely on the ordering of elements in a map. The same order of insertion may result in different iteration orders in the same program at a <span class="No-Break">different time.</span></p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor130"/>Defining, initializing, and using maps</h2>
			<p>Similar <a id="_idIndexMarker160"/>to a slice, the zero-value for a map is nil. Reading from a nil map will <a id="_idIndexMarker161"/>have the same result as reading from a non-nil map that has <a id="_idIndexMarker162"/>no elements. Writing to a nil map will panic. This section shows different ways a map can be initialized <span class="No-Break">and used.</span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor131"/>How to do it...</h2>
			<p>Use <strong class="source-inline">make</strong> to create a new map, or use a literal. You cannot write to a nil map (but you can read from it!), so you must initialize all maps either with <strong class="source-inline">make</strong>, or by using <span class="No-Break">a literal:</span></p>
			<pre class="source-code">
func main() {
   // Make a new empty map
   m1 := make(map[int]string)
   // Initilize a map using empty map literal
   m2 := map[int]string{}
   // Initialize a map using a map literal
   m3 := map[int]string {
      1: "a",
      2: "b",
  }
 ...</pre>			<p>Unlike <a id="_idIndexMarker163"/>a slice, map <a id="_idIndexMarker164"/>values are <span class="No-Break">not </span><span class="No-Break"><strong class="bold">addressable</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type User struct {
  Name string
}
func main() {
   usersByID := make(map[int]User)
   usersByID[1]=User{Name:"John Doe"}
   fmt.Println(usersByID[1].Name)
   // Prints: John Doe
   // The following will give a compile error
   usersByID[1].Name="James"
...
}</pre>			<p>In the previous example, you cannot set a member variable of a struct stored in a map. When you <a id="_idIndexMarker165"/>access that map element with <strong class="source-inline">usersByID[1]</strong>, what you get back is a copy of <strong class="source-inline">User</strong> stored in the map, and the effect of setting its <strong class="source-inline">Name</strong> to something else will be lost, as that copy is not <span class="No-Break">stored anywhere.</span></p>
			<p>So, instead, you can read and assign the map value to an addressable variable, change it, and set <span class="No-Break">it back:</span></p>
			<pre class="source-code">
  user := usersByID[1]
  user.Name="James"
  usersByID[1]=user</pre>			<p>Alternatively, you can store pointers in <span class="No-Break">the map:</span></p>
			<pre class="source-code">
  userPtrsByID := make(map[int]*User)
  userPtrsByID[1]=&amp;User {
    Name: "John Doe"
  }
  userPtrsByID[1].Name = "James" // This works.</pre>			<p>If the map <a id="_idIndexMarker166"/>does not have an element for the given key, it will return the zero-value for the map <span class="No-Break">value type:</span></p>
			<pre class="source-code">
  user := usersByID[2]  // user is set to User{}
  userPtr := userPtrsByID[2] // userPtr is set to nil</pre>			<p>To distinguish <a id="_idIndexMarker167"/>whether the zero-value is returned because the map doesn’t <a id="_idIndexMarker168"/>have the element from the situation where the zero-value is stored in the map, use the two-return value version of <span class="No-Break">map lookup:</span></p>
			<pre class="source-code">
  user, exists := usersByID[1] // exists = true
  userPtr, exists := userPtrsByID[2] // exists = false</pre>			<p>Use <strong class="source-inline">delete</strong> to delete an element from <span class="No-Break">a map:</span></p>
			<pre class="source-code">
delete(usersByID, 1)</pre>			<h1 id="_idParaDest-132"><a id="_idTextAnchor132"/>Implementing a set using a map</h1>
			<p>A set is useful <a id="_idIndexMarker169"/>to remove duplicates from a collection <a id="_idIndexMarker170"/>of values. Maps can be used as sets efficiently by utilizing a zero-size <span class="No-Break">value structure.</span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor133"/>How to do it...</h2>
			<p>Use a map whose key type is the element type of the set, and whose value type <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">struct{}</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
stringSet := make(map[string]struct{})</pre>			<p>Add values to the set with the <span class="No-Break"><strong class="source-inline">struct{}{}</strong></span><span class="No-Break"> value:</span></p>
			<pre class="source-code">
stringSet[value]=struct{}{}</pre>			<p>Check for value existence using the two-value version of <span class="No-Break">map lookup:</span></p>
			<pre class="source-code">
if _,exists:=stringSet[str]; exists {
  // String str exists in the set
}</pre>			<p>A map <a id="_idIndexMarker171"/>is not ordered. If the ordering of elements <a id="_idIndexMarker172"/>is important, keep a slice with <span class="No-Break">the map:</span></p>
			<pre class="source-code">
// Remove duplicate inputs from the input, preserving order
func DedupOrdered(input []string) []string {
   set:=make(map[string]struct{})
   output:=make([]string,0,len(input))
   for _,in:=range input {
     if _,exists:=set[in]; exists {
       continue
     }
     output=append(output,in)
     set[in]=struct{}{}
   }
   return output
}</pre>			<h2 id="_idParaDest-134"><a id="_idTextAnchor134"/>How it works...</h2>
			<p>The <strong class="source-inline">struct{}</strong> structure is <a id="_idIndexMarker173"/>a zero-sized object. Such objects are handled separately by the compiler and the runtime. When used as a value in a map, the map will only allocate storage for its keys. So, it is an efficient way to <span class="No-Break">implement sets.</span></p>
			<p class="callout-heading">Warning</p>
			<p class="callout">Never rely on pointer equivalence for zero-sized structures. The compiler may choose to place two separate variables that have zero-size to the same <span class="No-Break">memory location.</span></p>
			<p class="callout">The <a id="_idIndexMarker174"/>result of <a id="_idIndexMarker175"/>the following comparison is <span class="No-Break">not defined:</span></p>
			<p class="callout"><span class="No-Break"><strong class="source-inline">x:=&amp;struct{}{}</strong></span></p>
			<p class="callout"><span class="No-Break"><strong class="source-inline">y:=&amp;struct{}{}</strong></span></p>
			<p class="callout"><strong class="source-inline">if </strong><span class="No-Break"><strong class="source-inline">x==y {</strong></span></p>
			<p class="callout"><strong class="source-inline">  // </strong><span class="No-Break"><strong class="source-inline">Do something</strong></span></p>
			<p class="callout"><strong class="source-inline">}</strong></p>
			<p class="callout">The result of <strong class="source-inline">x==y</strong> may return <strong class="source-inline">true</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor135"/>Composite keys</h1>
			<p>You need <a id="_idIndexMarker176"/>composite keys when you have multiple values that identify a particular object. For example, say you are dealing with a system where users may have multiple sessions. You can store this information in a map of maps, or you can create a composite key containing the user ID and <span class="No-Break">session ID.</span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor136"/>How to do it...</h2>
			<p>Use a comparable struct or an array as the map key. A comparable struct is, in general, a struct that does <em class="italic">not</em> contain <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">Slices</span></li>
				<li><span class="No-Break">Channels</span></li>
				<li><span class="No-Break">Functions</span></li>
				<li><span class="No-Break">Maps</span></li>
				<li>Other <span class="No-Break">non-comparable structs</span></li>
			</ul>
			<p>So, to use composite keys, perform the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>Define a <span class="No-Break">comparable struct:</span></li>
			</ol>
			<pre class="source-code">
type Key struct {
  UserID string
  SessionID string
}
type User struct {
  Name string
  ...
}
var compositeKeyMap = map[Key]User{}</pre>			<ol>
				<li value="2">Use an <a id="_idIndexMarker177"/>instance of the map key to <span class="No-Break">access elements:</span></li>
			</ol>
			<pre class="source-code">
compositeKeyMap[Key{
  UserID: "123",
  SessionID: "1",
   }] = User {
    Name: "John Doe",
  }</pre>			<ol>
				<li value="3">You can use a literal map to <span class="No-Break">initialize it:</span></li>
			</ol>
			<pre class="source-code">
var compositeKeyMap = map[Key]User {
   Key {
     UserID: "123",
     SessionID: "1",
   }: User {
      Name: "John Doe",
  },
}</pre>			<h2 id="_idParaDest-137"><a id="_idTextAnchor137"/>How it works...</h2>
			<p>The map implementation generates hash values from its keys and then uses comparison operators to check for equivalence. Because of this, any data structure that is comparable can be used as a <span class="No-Break">key value.</span></p>
			<p>Be careful <a id="_idIndexMarker178"/>about pointer comparisons. A struct containing a pointer field will check for the equivalence of the pointer. Consider the <span class="No-Break">following key:</span></p>
			<pre class="source-code">
type KeyWithPointer struct {
  UserID string
  SessionID *int
}
var sessionMap = map[KeyWithPointer]{}
func main() {
  session := 1
  key := KeyWithPointer{
     UserID: "John",
     SessionID: &amp;session,
  }
  sessionMap[key]=User{ Name: "John Doe"}</pre>			<p>In the previous code snippet, the composite map key contains a pointer to <strong class="source-inline">session</strong>, an integer. After you add an element to the map, changing the value of <strong class="source-inline">session</strong> will not affect the keys of the map pointing to that variable. The map key will still be pointing to the same variable. Another instance of <strong class="source-inline">KeyWithPointer</strong> can be used to locate the <strong class="source-inline">User</strong> object only <a id="_idIndexMarker179"/>if it is also pointing to the same <strong class="source-inline">session</strong> variable, as per <span class="No-Break">the following:</span></p>
			<pre class="source-code">
fmt.Println( sessionMap[KeyWithPointer{
   UserID: "John",
   SessionID: &amp;session,
   }].Name) // "John Doe"</pre>			<p><span class="No-Break">But:</span></p>
			<pre class="source-code">
i:=1
fmt.Println( sessionMap[KeyWithPointer{
   UserID: "John",
   SessionID: &amp;i,
   }].Name) // ""</pre>			<h1 id="_idParaDest-138"><a id="_idTextAnchor138"/>Thread-safe caching with maps</h1>
			<p>Caching is sometimes necessary to attain an acceptable performance. The idea is to reuse values <a id="_idIndexMarker180"/>that have been computed or retrieved before. A map <a id="_idIndexMarker181"/>is a natural choice for caching such values but, due to their nature, caches are usually shared among multiple goroutines and you must be careful when <span class="No-Break">using them.</span></p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor139"/>Simple cache</h2>
			<p>This is a <a id="_idIndexMarker182"/>simple cache with a <strong class="source-inline">get/put</strong> method to <a id="_idIndexMarker183"/>retrieve objects from the cache and put elements <span class="No-Break">into it.</span></p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor140"/>How to do it...</h2>
			<p>To cache values that are accessible with a key, use a structure with a map <span class="No-Break">and mutex:</span></p>
			<pre class="source-code">
type ObjectCache struct {
   mutex sync.RWMutex
   values map[string]*Object
}
// Initialize and return a new instance of the cache
func NewObjectCache() *ObjectCache {
    return &amp;ObjectCache{
        values: make(map[string]*Object),
    }
}</pre>			<p>Direct access to <a id="_idIndexMarker184"/>cache internals should be prevented to ensure the proper protocol is observed whenever the cache <span class="No-Break">is used:</span></p>
			<pre class="source-code">
// Get an object from the cache
func (cache *ObjectCache) Get(key string) (*Object, bool) {
    cache.mutex.RLock()
    obj, exists := cache.values[key]
    cache.mutex.RUnlock()
    return obj, exists
}
// Put an object into the cache with the given key
func (cache *ObjectCache) Put(key string, value *Object) {
    cache.mutex.Lock()
    cache.values[key] = value
    cache.mutex.Unlock()
}</pre>			<h1 id="_idParaDest-141"><a id="_idTextAnchor141"/>Cache with blocking behavior</h1>
			<p>If multiple goroutines ask for the same key from the simple cache in the previous example, they may <a id="_idIndexMarker185"/>all decide to retrieve the object and put it back into the cache. That is inefficient. Usually, you would want one of those goroutines to retrieve the object while the other waits. This can be done <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">sync.Once</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor142"/>How to do it...</h2>
			<p>Cache elements are <a id="_idIndexMarker186"/>structures containing <strong class="source-inline">sync.Once</strong> to ensure one goroutine gets the object while others wait for it. Also, the cache contains a <strong class="source-inline">Get</strong> method that <a id="_idIndexMarker187"/>uses a <strong class="source-inline">getObjectFunc</strong> callback to retrieve an object if it is not in <span class="No-Break">the cache:</span></p>
			<pre class="source-code">
type cacheItem struct {
   sync.Once
   object *Object
}
type ObjectCache struct {
   mutex sync.RWMutex
   values map[string]*cacheItem
   getObjectFunc func(string) (*Object, error)
}
func NewObjectCache(getObjectFunc func(string) (*Object,error)) *ObjectCache {
  return &amp;ObjectCache{
     values: make(map[string]*cacheItem),
     getObjectFunc: getObjectFunc,
  }
}
func (item *cacheItem) get(key string, cache *ObjectCache) (err error) {
  // Calling item.Once.Do
  item.Do(func() {
     item.object, err=cache.getObjectFunc(key)
  })
  return
}
func (cache *ObjectCache) Get(key string) (*Object, error) {
  cache.mutex.RLock()
  object, exists := cache.values[key]
  cache.mutex.RUnlock()
  if exists {
    return object.object, nil
  }
  cache.mutex.Lock()
  object, exists = cache.values[key]
  if !exists {
    object = &amp;cacheItem{}
    cache.values[key] = object
  }
  cache.mutex.Unlock()
  err := object.get(key, cache)
  return object.object, err
}</pre>			<h2 id="_idParaDest-143"><a id="_idTextAnchor143"/>How it works...</h2>
			<p>The <strong class="source-inline">Get</strong> method starts by read-locking the cache. Then it checks whether the key exists in the cache and unlocks it. If the value is cached, it <span class="No-Break">is returned.</span></p>
			<p>If the value <a id="_idIndexMarker188"/>is not in the cache, then the cache is write-locked, because this will be a concurrent modification to the <strong class="source-inline">values</strong> map. The <strong class="source-inline">values</strong> map is checked again to make sure another goroutine did not already put a value there. If not, this goroutine puts an uninitialized <strong class="source-inline">cacheItem</strong> in the cache and <span class="No-Break">unlocks it.</span></p>
			<p>The <strong class="source-inline">cacheItem</strong> contains a <strong class="source-inline">sync.Once</strong>, which will allow only one goroutine to call <strong class="source-inline">Once.Go</strong> while others are blocked waiting for the winning call to complete. This is when the <strong class="source-inline">getObjectFunc</strong> callback is invoked from the <strong class="source-inline">cacheItem.get</strong> method. At this point, there is no chance for a memory race, because only one goroutine can be executing the <strong class="source-inline">item.Do</strong> function. The result of the function will be stored in the <strong class="source-inline">cacheItem</strong>, so it will not cause any problems with the users of the <strong class="source-inline">values</strong> map. In fact, note that while <strong class="source-inline">getObjectFunc</strong> is running, the cache is not locked. There can be many other goroutines reading and/or writing to <span class="No-Break">the cache.</span></p>
		</div>
	</div></div></body></html>