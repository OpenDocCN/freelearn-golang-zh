["```go\n    var arr [2]int // Array of 2 ints\n    x := [...]int{1,2} // Array of 2 ints\n    ```", "```go\n    y := [...]int{1, 4: 10} // Array of 5 ints,\n    // [0]1, y[4]=10, all other elements are 0\n    // [1 0 0 0 10]\n    ```", "```go\n    // SHA256 hash is 256 bits - 32 bytes\n    type SHA256 [32]byte\n    ```", "```go\n    func main() {\n      var h SHA256\n      h = getHash()\n      // f will get a 32-byte array that is a copy of h\n      f(h)\n    ...\n    }\n    func f(hash SHA256) {\n      hash[0]=0 // This changes the copy of `hash` passed to `f`.\n                // It does not affect the `h` value declared in main\n      ...\n    }\n    ```", "```go\nfunc f(m [2]map[string]int) {\n   m[0][\"x\"]=1\n}\nfunc main() {\n  array := [2]map[string]int{}\n  // A copy of array is passed to f\n  // but array[0] and array[1] are maps\n  // Contents of those maps are not copied.\n  f(array)\n  fmt.Println(array[0])\n  // This will print [x:1]\n}\n```", "```go\nslice1 := make([]int,0)\n// len(slice1)=0, cap(slice1)=0\nslice2 := make([]int,0,10)\n// len(slice2)=0, cap(slice2)=10\nslice3 := make([]int,10)\n// len(slice3)=10, cap(slice3)=10\n```", "```go\nvalues:=make([]string,10)\nfor _,s:=range results {\n  if someFunc(s) {\n    values=append(values,s)\n  }\n}\n```", "```go\nslice := []int{1,2,3,4,5}\n// len(slice)=5 cap(slice)=5\n```", "```go\n// values slice is nil after declaration\nvar values []string\nfor _,x:=range results {\n  if someFunc(s) {\n    values=appennd(values, s)\n  }\n}\n```", "```go\narr := [...]int{0, 1, 2, 3, 4, 5}\nslice := arr[:] // slice has all elements of arr\nslice[2]=10\n// Here, arr = [...]int{0,1,10,3, 4,5}\n// len(slice) = 6\n// cap(slice) = 6\n```", "```go\nslice2 := arr[1:3]\n// Here, slice2 = {1,10}\n// len(slice2) = 2\n// cap(slice2) = 5\n```", "```go\nslice3 := slice2[0:4]\n// len(slice3)=4\n// cap(slice3)=5\n// slice3 = {1,10,3,4}\n```", "```go\n// Create an empty integer slice\nislice := make([]int, 0)\n// Append values 1, 2, 3 to islice, assign it to newSlice\nnewSlice := append(islice, 1, 2, 3)\n// islice:  []\n// newSlice: [1 2 3]\n// Create an empty integer slice\nislice = make([]int, 0)\n// Another integer slice with 3 elements\notherSlice := []int{1, 2, 3}\n// Append 'otherSlice' to 'islice'\nnewSlice = append(islice, otherSlice...)\nnewSlice = append(newSlice, otherSlice...)\n// islice: []\n// otherSlice: [1 2 3]\n// newSlice: [1 2 3 1 2 3]\n```", "```go\nslice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n// Slice elements starting from index 1\nsuffix := slice[1:]\n// suffix: [1 2 3 4 5 6 7 8 9]\n// Slice elements starting from index 3\nsuffix2 := slice[3:]\n// suffix2: [3 4 5 6 7 8 9]\n// Slice elements up to index 5 (excluding 5)\nprefix := slice[:5]\n// prefix: [0 1 2 3 4]\n// Slice elements from 3 up to index 6 (excluding 6)\nmid := slice[3:6]\n// [3 4 5]\n```", "```go\nslice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n// Remove the section slice[3:7]\nedges := slices.Delete(slice, 3, 7)\n// edges: [0 1 2 7 8 9]\n// slice: [0 1 2 7 8 9 0 0 0 0]\ninserted := slices.Insert(slice, 3, 3, 4)\n// inserted: [0 1 2 3 4 7 8 9 0 0 0 0]\n// edges: [0 1 2 7 8 9]\n// slices: [0 1 2 7 8 9 0 0 0 0]\n```", "```go\nslice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n// Keep an index to write to\nwrite:=0\nfor _, elem := range slice {\n  if elem %2 == 0 { // Copy only even numbers\n    slice[write]=elem\n    write++\n  }\n}\n// Truncate the slice\nslice=slice[:write]\n```", "```go\n// Appends 1 to a slice, and returns the new slice\nfunc Append1(input []int) []int {\n  return append(input,1)\n}\nfunc main() {\n   slice:= []int{0,1,2,3,4,5,6,7,8,9}\n   shortSlice := slice[:4]\n   // shortSlice: []int{0,1,2,3}\n   newSlice:=Append1(slice[:4])\n   // newSlice:= []int{0,1,2,3,1}\n   // slice: []int{0,1,2,3,1,5,6,7,8,9}\n}\n```", "```go\nslice:= []int{0,1,2,3,4,5,6,7,8,9}\nnewSlice:=slice[:5]\n// newSlice: []int{0,1,2,3,4}\n```", "```go\n// A generic stack of type T\ntype Stack[T any] []T\nfunc (s *Stack[T]) Push(val T) {\n     *s = append(*s, val)\n}\n```", "```go\nfunc (s *Stack[T]) Pop() (val T) {\n     val = (*s)[len(*s)-1]\n     *s = (*s)[:len(*s)-1]\n     return\n}\n```", "```go\nfunc main() {\n   // Make a new empty map\n   m1 := make(map[int]string)\n   // Initilize a map using empty map literal\n   m2 := map[int]string{}\n   // Initialize a map using a map literal\n   m3 := map[int]string {\n      1: \"a\",\n      2: \"b\",\n  }\n ...\n```", "```go\ntype User struct {\n  Name string\n}\nfunc main() {\n   usersByID := make(map[int]User)\n   usersByID[1]=User{Name:\"John Doe\"}\n   fmt.Println(usersByID[1].Name)\n   // Prints: John Doe\n   // The following will give a compile error\n   usersByID[1].Name=\"James\"\n...\n}\n```", "```go\n  user := usersByID[1]\n  user.Name=\"James\"\n  usersByID[1]=user\n```", "```go\n  userPtrsByID := make(map[int]*User)\n  userPtrsByID[1]=&User {\n    Name: \"John Doe\"\n  }\n  userPtrsByID[1].Name = \"James\" // This works.\n```", "```go\n  user := usersByID[2]  // user is set to User{}\n  userPtr := userPtrsByID[2] // userPtr is set to nil\n```", "```go\n  user, exists := usersByID[1] // exists = true\n  userPtr, exists := userPtrsByID[2] // exists = false\n```", "```go\ndelete(usersByID, 1)\n```", "```go\nstringSet := make(map[string]struct{})\n```", "```go\nstringSet[value]=struct{}{}\n```", "```go\nif _,exists:=stringSet[str]; exists {\n  // String str exists in the set\n}\n```", "```go\n// Remove duplicate inputs from the input, preserving order\nfunc DedupOrdered(input []string) []string {\n   set:=make(map[string]struct{})\n   output:=make([]string,0,len(input))\n   for _,in:=range input {\n     if _,exists:=set[in]; exists {\n       continue\n     }\n     output=append(output,in)\n     set[in]=struct{}{}\n   }\n   return output\n}\n```", "```go\ntype Key struct {\n  UserID string\n  SessionID string\n}\ntype User struct {\n  Name string\n  ...\n}\nvar compositeKeyMap = map[Key]User{}\n```", "```go\ncompositeKeyMap[Key{\n  UserID: \"123\",\n  SessionID: \"1\",\n   }] = User {\n    Name: \"John Doe\",\n  }\n```", "```go\nvar compositeKeyMap = map[Key]User {\n   Key {\n     UserID: \"123\",\n     SessionID: \"1\",\n   }: User {\n      Name: \"John Doe\",\n  },\n}\n```", "```go\ntype KeyWithPointer struct {\n  UserID string\n  SessionID *int\n}\nvar sessionMap = map[KeyWithPointer]{}\nfunc main() {\n  session := 1\n  key := KeyWithPointer{\n     UserID: \"John\",\n     SessionID: &session,\n  }\n  sessionMap[key]=User{ Name: \"John Doe\"}\n```", "```go\nfmt.Println( sessionMap[KeyWithPointer{\n   UserID: \"John\",\n   SessionID: &session,\n   }].Name) // \"John Doe\"\n```", "```go\ni:=1\nfmt.Println( sessionMap[KeyWithPointer{\n   UserID: \"John\",\n   SessionID: &i,\n   }].Name) // \"\"\n```", "```go\ntype ObjectCache struct {\n   mutex sync.RWMutex\n   values map[string]*Object\n}\n// Initialize and return a new instance of the cache\nfunc NewObjectCache() *ObjectCache {\n    return &ObjectCache{\n        values: make(map[string]*Object),\n    }\n}\n```", "```go\n// Get an object from the cache\nfunc (cache *ObjectCache) Get(key string) (*Object, bool) {\n    cache.mutex.RLock()\n    obj, exists := cache.values[key]\n    cache.mutex.RUnlock()\n    return obj, exists\n}\n// Put an object into the cache with the given key\nfunc (cache *ObjectCache) Put(key string, value *Object) {\n    cache.mutex.Lock()\n    cache.values[key] = value\n    cache.mutex.Unlock()\n}\n```", "```go\ntype cacheItem struct {\n   sync.Once\n   object *Object\n}\ntype ObjectCache struct {\n   mutex sync.RWMutex\n   values map[string]*cacheItem\n   getObjectFunc func(string) (*Object, error)\n}\nfunc NewObjectCache(getObjectFunc func(string) (*Object,error)) *ObjectCache {\n  return &ObjectCache{\n     values: make(map[string]*cacheItem),\n     getObjectFunc: getObjectFunc,\n  }\n}\nfunc (item *cacheItem) get(key string, cache *ObjectCache) (err error) {\n  // Calling item.Once.Do\n  item.Do(func() {\n     item.object, err=cache.getObjectFunc(key)\n  })\n  return\n}\nfunc (cache *ObjectCache) Get(key string) (*Object, error) {\n  cache.mutex.RLock()\n  object, exists := cache.values[key]\n  cache.mutex.RUnlock()\n  if exists {\n    return object.object, nil\n  }\n  cache.mutex.Lock()\n  object, exists = cache.values[key]\n  if !exists {\n    object = &cacheItem{}\n    cache.values[key] = object\n  }\n  cache.mutex.Unlock()\n  err := object.get(key, cache)\n  return object.object, err\n}\n```"]