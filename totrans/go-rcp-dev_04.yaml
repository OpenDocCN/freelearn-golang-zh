- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Arrays, Slices, and Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays, slices, and maps are the built-in container types defined by the Go
    language. They are essential parts of almost every program, and usually, the building
    blocks of other data structures. This section describes some of the common patterns
    of working with these basic data structures, as they have nuances that may not
    be obvious to a newcomer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will talk about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with slices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a stack using slices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using maps for thread-safe caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays are fixed-size data structures. There is no way to resize an array or
    to create an array using a variable as its size (in other words, `[n]int` is valid
    only if `n` is a constant integer). Because of this, arrays are useful to represent
    an object with a fixed number of elements, such as a SHA256 hash, which is 32
    bytes.
  prefs: []
  type: TYPE_NORMAL
- en: The zero-value for an array has zero-values for every element of the array.
    For instance, `[5]int` is initialized with five integers, all 0\. A string array
    will have empty strings.
  prefs: []
  type: TYPE_NORMAL
- en: Creating arrays and passing them around
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows how you can create arrays and pass array values to functions
    and methods. We will also talk about the effects of passing arrays as values.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create arrays using a fixed size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can specify array indexes similar to defining a map:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use arrays to define new types of fixed-size data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Arrays are passed by value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Passing an array by value means that every time you use an array as an argument
    to a function, the array will be copied. If you pass an array `[1000]int64` to
    a function, the runtime will allocate and copy 8,000 bytes (int64 is 64 bits,
    which is 8 bytes, and 1,000 int64 values is 8,000 bytes.) The copy will be a shallow
    copy – that is, you pass an array containing pointers, or, if you pass an array
    containing structures containing pointers, the pointers will be copied, not the
    contents of those pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Working with slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A slice is a view over an array. You may be dealing with multiple slices that
    work with the same underlying data.
  prefs: []
  type: TYPE_NORMAL
- en: The zero-value for a slice is nil. Reading or writing a nil slice will `panic`;
    however, you can append to a nil slice, which will create a new slice.
  prefs: []
  type: TYPE_NORMAL
- en: Creating slices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways a slice can be created.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use `make(sliceType,length[,capacity])`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code snippet, you see three different uses of `make` to create
    a slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '`slice1:=make([]int,0)` creates an empty slice, `0` being the length of the
    slice. The `slice1` variable is initialized as a non-nil, 0-length slice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slice2 := make([]int,0,10)` creates an empty slice with capacity `10`. This
    is what you should prefer if you know the likely maximum size for this slice.
    This slice allocation avoids an allocate/copy operation up until the 11th element
    is appended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slice3 := make([]int,10)` creates a slice with size `10` and capacity `10`.
    The slice elements are initialized to 0\. In general, with this form, the allocated
    slice will be initialized to the zero-value of its element type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Be careful about allocating a slice with a non-zero length. I personally had
    to deal with really obscure bugs because I mistyped `make([]int,10)` instead of
    `make([]int,0,10)`, and continued to append the 10 elements to the allocated slice,
    ending with 20 elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The previous code snippet creates a string slice that has `10` empty strings,
    then the strings are appended by the for-loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also initialize a slice using a literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can leave a slice variable `nil`, and append to it. The
    `append` built-in will accept a `nil` slice, and create one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Creating a slice from an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many functions will accept slices and not arrays. If you have an array of values
    and need to pass it to a function that wants a slice, you need to create a slice
    from an array. This is easy and efficient. Creating a slice from an array is a
    constant-time operation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `[:]` notation to create a slice from the array. The slice will have
    the array as its underlying storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create a slice pointing to a section of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can slice an existing slice. The bounds of the slicing operation are determined
    by the capacity of the original slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A slice is a data structure containing three values: slice length, capacity,
    and pointer to the underlying array. Slicing an array simply creates this data
    structure with a pointer initialized to the array. It is a constant-time operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Difference between an array arr and a slice arr[:]](img/B21961_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Difference between an array arr and a slice arr[:]
  prefs: []
  type: TYPE_NORMAL
- en: Appending/inserting/deleting slice elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Slices use arrays as their underlying storage, but it is not possible to grow
    arrays when you run out of space. Because of this, if an `append` operation exceeds
    the slice capacity, a new and larger array is allocated, and slice contents are
    copied to this new array.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add new values to the end of the slice, use the `append` built-in function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove elements from the beginning or the end of a slice, use slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `slices` package to insert/delete elements from arbitrary locations
    in a slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '`slices.Delete(slice,i,j)` removes `slice[i:j]` elements from the slice and
    returns the modified slice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slices.Insert(slice,i,value...)` inserts the values starting at index `i`,
    shifting all elements starting from `i` to make space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can remove elements from a slice and truncate it using a
    for-loop, like in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A slice is a view over an array. It contains three pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ptr`: A pointer to an element of an array, which is the starting location
    of the slice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`len`: The number of elements in the slice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cap`: The capacity remaining in the underlying array for this slice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you append elements to a slice beyond its capacity, a larger array is allocated
    by the runtime, and the contents of the slice are copied there. After this, the
    new slice points to a new array.
  prefs: []
  type: TYPE_NORMAL
- en: This is a source of confusion for many. A slice may share its elements with
    other slices. Thus, modifying one slice may modify others as well.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.2* illustrates a case where the same underlying array is used for
    four different slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Slices sharing the same underlying array](img/B21961_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Slices sharing the same underlying array
  prefs: []
  type: TYPE_NORMAL
- en: 'See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that appending to `newSlice` also modified an element of `slice`, because
    `newSlice` has enough capacity to accommodate one more element, which overwrites
    `slice[4]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Truncating a slice is simply creating a new slice that is shorter than the
    original. The underlying array does not change. See the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Remember, `newSlice` is simply a data structure containing the same `ptr` and
    `cap` as `slice`, with a shorter `len`. Because of this, creating a new slice
    from an existing slice or an array is a constant-time operation (O(1)).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a stack using a slice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A surprisingly common use of a slice is to implement a stack. Here is how it
    is done.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A stack push is simply `append`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement `pop`, truncate the slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Again, note the use of parentheses and indirections. We cannot write `*s[len(*s)-1]`,
    because that is interpreted as `*(s[len(*s)-1]`. To prevent that, we have `(*s)`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You access the elements of an array or a slice using integer indexes. Maps provide
    a similar syntax to use index keys that are not only integers but also any type
    that is “comparable” (which means it can be compared using `==` or `!=`.) A map
    is an associative data type – that is, it stores key-value pairs. Each key appears
    once in a map. A Go map provides amortized constant-time access to its elements
    (that is, when measured over time, map element access should look like a constant-time
    operation.)
  prefs: []
  type: TYPE_NORMAL
- en: The Go `map` type provides convenient access to an underlying complicated data
    structure. It is one of the “reference” types – that is, assigning a map variable
    to another map simply assigns a pointer to the underlying structure and does not
    copy the elements of the map.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: A map is an unordered collection. Do not rely on the ordering of elements in
    a map. The same order of insertion may result in different iteration orders in
    the same program at a different time.
  prefs: []
  type: TYPE_NORMAL
- en: Defining, initializing, and using maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to a slice, the zero-value for a map is nil. Reading from a nil map
    will have the same result as reading from a non-nil map that has no elements.
    Writing to a nil map will panic. This section shows different ways a map can be
    initialized and used.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `make` to create a new map, or use a literal. You cannot write to a nil
    map (but you can read from it!), so you must initialize all maps either with `make`,
    or by using a literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike a slice, map values are not **addressable**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, you cannot set a member variable of a struct stored
    in a map. When you access that map element with `usersByID[1]`, what you get back
    is a copy of `User` stored in the map, and the effect of setting its `Name` to
    something else will be lost, as that copy is not stored anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead, you can read and assign the map value to an addressable variable,
    change it, and set it back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can store pointers in the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If the map does not have an element for the given key, it will return the zero-value
    for the map value type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To distinguish whether the zero-value is returned because the map doesn’t have
    the element from the situation where the zero-value is stored in the map, use
    the two-return value version of map lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `delete` to delete an element from a map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a set using a map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A set is useful to remove duplicates from a collection of values. Maps can be
    used as sets efficiently by utilizing a zero-size value structure.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use a map whose key type is the element type of the set, and whose value type
    is `struct{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add values to the set with the `struct{}{}` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Check for value existence using the two-value version of map lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A map is not ordered. If the ordering of elements is important, keep a slice
    with the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `struct{}` structure is a zero-sized object. Such objects are handled separately
    by the compiler and the runtime. When used as a value in a map, the map will only
    allocate storage for its keys. So, it is an efficient way to implement sets.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Never rely on pointer equivalence for zero-sized structures. The compiler may
    choose to place two separate variables that have zero-size to the same memory
    location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the following comparison is not defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x:=&struct{}{}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`y:=&struct{}{}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if` `x==y {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`//` `Do something`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: The result of `x==y` may return `true` or `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Composite keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need composite keys when you have multiple values that identify a particular
    object. For example, say you are dealing with a system where users may have multiple
    sessions. You can store this information in a map of maps, or you can create a
    composite key containing the user ID and session ID.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use a comparable struct or an array as the map key. A comparable struct is,
    in general, a struct that does *not* contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other non-comparable structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, to use composite keys, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a comparable struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Use an instance of the map key to access elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use a literal map to initialize it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The map implementation generates hash values from its keys and then uses comparison
    operators to check for equivalence. Because of this, any data structure that is
    comparable can be used as a key value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful about pointer comparisons. A struct containing a pointer field will
    check for the equivalence of the pointer. Consider the following key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code snippet, the composite map key contains a pointer to `session`,
    an integer. After you add an element to the map, changing the value of `session`
    will not affect the keys of the map pointing to that variable. The map key will
    still be pointing to the same variable. Another instance of `KeyWithPointer` can
    be used to locate the `User` object only if it is also pointing to the same `session`
    variable, as per the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'But:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Thread-safe caching with maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching is sometimes necessary to attain an acceptable performance. The idea
    is to reuse values that have been computed or retrieved before. A map is a natural
    choice for caching such values but, due to their nature, caches are usually shared
    among multiple goroutines and you must be careful when using them.
  prefs: []
  type: TYPE_NORMAL
- en: Simple cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a simple cache with a `get/put` method to retrieve objects from the
    cache and put elements into it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To cache values that are accessible with a key, use a structure with a map
    and mutex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Direct access to cache internals should be prevented to ensure the proper protocol
    is observed whenever the cache is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Cache with blocking behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If multiple goroutines ask for the same key from the simple cache in the previous
    example, they may all decide to retrieve the object and put it back into the cache.
    That is inefficient. Usually, you would want one of those goroutines to retrieve
    the object while the other waits. This can be done using `sync.Once`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cache elements are structures containing `sync.Once` to ensure one goroutine
    gets the object while others wait for it. Also, the cache contains a `Get` method
    that uses a `getObjectFunc` callback to retrieve an object if it is not in the
    cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Get` method starts by read-locking the cache. Then it checks whether the
    key exists in the cache and unlocks it. If the value is cached, it is returned.
  prefs: []
  type: TYPE_NORMAL
- en: If the value is not in the cache, then the cache is write-locked, because this
    will be a concurrent modification to the `values` map. The `values` map is checked
    again to make sure another goroutine did not already put a value there. If not,
    this goroutine puts an uninitialized `cacheItem` in the cache and unlocks it.
  prefs: []
  type: TYPE_NORMAL
- en: The `cacheItem` contains a `sync.Once`, which will allow only one goroutine
    to call `Once.Go` while others are blocked waiting for the winning call to complete.
    This is when the `getObjectFunc` callback is invoked from the `cacheItem.get`
    method. At this point, there is no chance for a memory race, because only one
    goroutine can be executing the `item.Do` function. The result of the function
    will be stored in the `cacheItem`, so it will not cause any problems with the
    users of the `values` map. In fact, note that while `getObjectFunc` is running,
    the cache is not locked. There can be many other goroutines reading and/or writing
    to the cache.
  prefs: []
  type: TYPE_NORMAL
