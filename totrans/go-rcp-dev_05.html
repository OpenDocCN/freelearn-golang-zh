<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer014">
			<h1 id="_idParaDest-144" class="chapter-number"><a id="_idTextAnchor144"/>5</h1>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor145"/>Working with Types, Structs, and Interfaces</h1>
			<p>Go is a strongly typed language. That means every value in a program must be defined using a set of predefined basic types. The rules of the type system determine what can be done with those values, and how values of different types interact. The Go type system takes a simplistic approach; it only allows explicit conversions between values of different <span class="No-Break">compatible types.</span></p>
			<p>Go is also a statically typed language, which means that types of values are explicitly declared and checked at compile time, as opposed to being checked at runtime. This is different from scripting languages such as Python <span class="No-Break">or Java</span><span class="No-Break">S</span><span class="No-Break">cript.</span></p>
			<p>In this chapter, we will look at some of the properties of the Go type system, defining new types, structures, and interfaces, and considering how to make effective use of it to implement some <span class="No-Break">common patterns.</span></p>
			<p>This chapter contains the <span class="No-Break">following recipes:</span></p>
			<ul>
				<li>Creating <span class="No-Break">new types</span></li>
				<li>Using composition to <span class="No-Break">extend types</span></li>
				<li><span class="No-Break">Initializing structures</span></li>
				<li>Working <span class="No-Break">with interfaces</span></li>
				<li><span class="No-Break">Factory pattern</span></li>
				<li><span class="No-Break">Polymorphic containers</span></li>
			</ul>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor146"/>Creating new types</h1>
			<p>There are several <a id="_idIndexMarker189"/>reasons why you want to define new types. An important one is ensuring type safety. Type safety ensures that operations receive the correct type of data. A type-safe program is free of type errors, limiting possible errors in the program to logic <span class="No-Break">errors only.</span></p>
			<p>Other reasons for creating new types also include <span class="No-Break">the following:</span></p>
			<ul>
				<li>You can share the methods and data fields of a type in multiple different types by <span class="No-Break"><em class="italic">embedding</em></span><span class="No-Break"> it.</span></li>
				<li>Later in this chapter, we will look at interfaces. You can define a set of methods for a new type to implement a given interface that lets you use that type in <span class="No-Break">different contexts.</span></li>
			</ul>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor147"/>Creating a new type based on an existing type</h1>
			<p>Creating a new<a id="_idIndexMarker190"/> type allows you to enforce type-safety rules, and add <span class="No-Break">type-specific methods.</span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor148"/>How to do it...</h2>
			<p>Create a new type based on an existing type using the <span class="No-Break">following syntax:</span></p>
			<p class="HTML-Preformatted" lang="en-US" xml:lang="en-US"><strong class="source-inline">type &lt;NewTypeName&gt; &lt;ExistingTypeName&gt;</strong></p>
			<p>For example, the following declaration defines a new data type, <strong class="source-inline">Duration</strong>, as an unsigned <span class="No-Break">64-bit integer:</span></p>
			<p class="HTML-Preformatted" lang="en-US" xml:lang="en-US"><strong class="source-inline">type Duration uint64</strong></p>
			<p>This is how the Go standard library defines <strong class="source-inline">time.Duration</strong>. To call the <strong class="source-inline">time.Sleep(d Duration)</strong> function, you now have to use a <strong class="source-inline">time.Duration</strong> value, or explicitly convert a numeric value to a <span class="No-Break"><strong class="source-inline">time.Duration</strong></span><span class="No-Break"> value.</span></p>
			<p class="callout-heading">Warning</p>
			<p class="callout">When you create a new type from an existing type, the new type is created without any methods even if the existing <a id="_idIndexMarker191"/>type has <span class="No-Break">methods defined.</span></p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor149"/>Creating type-safe enumerations</h1>
			<p>In this recipe, we <a id="_idIndexMarker192"/>will define a set of constants (an enumeration) with a <span class="No-Break">new type.</span></p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor150"/>How to do it...</h2>
			<ol>
				<li>Define a <span class="No-Break">new type:</span><pre class="source-code">
type Direction int</pre></li>				<li>Create a sequence of constants representing the values of the enumeration using the new type. You can use <strong class="source-inline">iota</strong> for numeric constants to generate <span class="No-Break">increasing numbers:</span><pre class="source-code">
const (
  DirectionLeft Direction = iota
  DirectionRight
)</pre></li>				<li>Use the new type in functions or data elements expecting this <span class="No-Break">new type:</span><pre class="source-code">
func SetDirection(dir Direction) {...}
func main() {
  SetDirection(DirectionLeft)
  SetDirection(Direction(0))
  ...
}</pre></li>			</ol>
			<p class="callout-heading">Tip</p>
			<p class="callout">This does not prevent someone from calling <strong class="source-inline">SetDirection(Direction(3))</strong>, which is an invalid value. This is usually only a problem for enumerated values read from user input or from <a id="_idIndexMarker193"/>third-party sources. You should validate the input at <span class="No-Break">that point.</span></p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor151"/>Creating struct types</h1>
			<p>A Go struct is a collection<a id="_idIndexMarker194"/> of fields. Define structs to group interrelated data fields to form a record. This recipe shows how to create new struct types in <span class="No-Break">your program.</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor152"/>How to do it...</h2>
			<p>Create a struct type using the <span class="No-Break">following syntax:</span></p>
			<pre class="source-code">
type NewTypeName struct {
   // List of fields
}</pre>			<p><span class="No-Break">For instance:</span></p>
			<pre class="source-code">
type User struct {
  Username string
  Password string
}</pre>			<h1 id="_idParaDest-153"><a id="_idTextAnchor153"/>Extending types</h1>
			<p>Go uses type <a id="_idIndexMarker195"/>composition through embedding, and structural typing through the use of interfaces. Let’s start by examining what <span class="No-Break">these mean.</span></p>
			<p>When you embed an existing type into another, the methods and data fields defined for the embedded type become the methods and data fields of the embedding type. If you have worked with object-oriented languages, this may seem similar to class inheritance, but there is a crucial difference: if a class <strong class="source-inline">A</strong> is derived from a class <strong class="source-inline">B</strong>, then <strong class="source-inline">A</strong> is-a <strong class="source-inline">B</strong>, meaning wherever <strong class="source-inline">B</strong> is needed, you can substitute an instance of <strong class="source-inline">A</strong>. With composition, if <strong class="source-inline">A</strong> embeds <strong class="source-inline">B</strong>, <strong class="source-inline">A</strong> and <strong class="source-inline">B</strong> are distinct types, and you cannot use <strong class="source-inline">A</strong> where <strong class="source-inline">B</strong> <span class="No-Break">is needed.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">There is no type inheritance in Go. Go chooses composition over inheritance. The primary reason for this is the simplicity of combining components to build more complex ones. Most use cases of inheritance in object-oriented languages can be rearchitected using composition, interfaces, and structural typing. I used the word “<em class="italic">rearchitecting</em>” intentionally here: do <em class="italic">not</em> try to port existing object-oriented programs to Go by emulating inheritance. Instead, redesign and refactor them to be idiomatic Go programs using composition <span class="No-Break">and interfaces.</span></p>
			<p>The next recipes <a id="_idIndexMarker196"/>will look at how this can <span class="No-Break">be done.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor154"/>Extending a base type</h2>
			<p>First, we’ll look <a id="_idIndexMarker197"/>at how we can extend a base type to share its data elements and methods in <span class="No-Break">new types.</span></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor155"/>How to do it...</h2>
			<p>Let’s say you have some data fields and functionality shared between multiple data types. Then you can create a base data type, and embed it into multiple other data types to share <span class="No-Break">common parts:</span></p>
			<pre class="source-code">
type Common struct {
  commonField int
}
func (a Common) CommonMethod() {}
type A struct {
  Common
  aField int
}
func (a A) AMethod() {}
type B struct {
  Common
  bField int
}
func (b B) BMethod() {}</pre>			<p>In the preceding code snippet, the fields and methods <a id="_idIndexMarker198"/>of each struct are <span class="No-Break">as follows:</span></p>
			<table id="table001" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Type</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Fields</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Methods</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Common</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">commonField</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">CommonMethod</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>A</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">commonField, aField</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">CommonMethod, AMethod</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>B</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">commonField, bField</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">CommonMethod, BMethod</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor156"/>How it works...</h2>
			<p>We have used struct embedding to share common data elements and functionality in the previous section. The following example shows two structs, <strong class="source-inline">Customer</strong> and <strong class="source-inline">Product</strong>, that share the same <strong class="source-inline">Metadata</strong> structure. <strong class="source-inline">Metadata</strong> contains the unique identifier, creation date, and modification <a id="_idIndexMarker199"/>date of <span class="No-Break">a record:</span></p>
			<pre class="source-code">
type Metadata struct {
  ID string
  CreatedAt time.Time
  ModifiedAt time.Time
}
// New initializes metadata fields
func (m *Metadata) New() {
  m.ID=uuid.New().String()
  m.CreatedAt=time.Now()
  m.ModifiedAt=m.CreatedAt
}
// Customer.New() uses the promoted Metadata.New() method.
// Calling Customer.New() will initialize Customer.Metadata, but
// will not modify Customer specific fields.
type Customer struct {
  Metadata
  Name string
}
// Product.New(string) shadows `Metadata.New() method. You cannot
// call `Product.New()`, but call `Product.New(string)` or
// `Product.Metadata.New()`
type Product struct {
  Metadata
  SKU string
}
func (p *Product) New(sku string) {
  // Initialize the metadata part of product
  p.Metadata.New()
  p.SKU=sku
}
func main() {
   c:=Customer{}
   c.New() // Initialize customer metadata
   p:=Product{}
   p.New("sku") // Initialize product metadata and sku
   // p.New() // Compile error: p.New() takes a string argument
}</pre>			<p><em class="italic">Embedding is not inheritance</em>. The receiver<a id="_idIndexMarker200"/> of an embedded struct method is <em class="italic">not</em> a copy of the defined struct. In the preceding snippet, when we call <strong class="source-inline">c.New()</strong>, the <strong class="source-inline">Metedata.New()</strong> method gets a receiver that is an instance of <strong class="source-inline">*Metadata</strong>, not an instance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">*Customer</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor157"/>Initializing structs</h1>
			<p>This recipe shows how<a id="_idIndexMarker201"/> you can use struct literals to initialize complex data structures containing <span class="No-Break">embedded structures.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor158"/>How to do it...</h2>
			<p>Go guarantees that all declared variables are initialized to their zero values. This is not very useful if you have a complicated data structure that should be initialized with default values or non-nil pointer components. For such cases, use constructor-like functions to create a new instance of a struct. The established convention is to write a <strong class="source-inline">NewX</strong> function for a type <strong class="source-inline">X</strong> that initializes an instance of <strong class="source-inline">X</strong> or <strong class="source-inline">*X</strong> and <span class="No-Break">returns it.</span></p>
			<p><a id="_idTextAnchor159"/>Here, <strong class="source-inline">NewIndex</strong> creates a new initialized instance of the <span class="No-Break"><strong class="source-inline">Index</strong></span><span class="No-Break"> type:</span></p>
			<pre class="source-code">
type Index struct {
   index map[string]any
   name string
}
func NewIndex(name string) *Index {
  return &amp;Index{
    index:make(map[string]any),
    name:name,
  }
}
func (index *Index) Name() string {return index.name}
func (index *Index) Add(key string, value any) {
  index.index[key]=value
}</pre>			<p>Also, observe that the <strong class="source-inline">Index.name</strong> and <strong class="source-inline">Index.index</strong> fields are not exported. Thus, they can only be accessed using exported methods of <strong class="source-inline">Index</strong>. This pattern is useful for preventing <a id="_idIndexMarker202"/>unintentional modification of <span class="No-Break">data fields.</span></p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor160"/>Defining interfaces</h1>
			<p>Go uses “structural <a id="_idIndexMarker203"/>typing.” If a type <strong class="source-inline">T</strong> defines all the methods of an interface <strong class="source-inline">I</strong>, then <strong class="source-inline">T</strong> implements <strong class="source-inline">I.</strong> This causes some confusion among developers who are well-versed in languages that use nominative typing, such as Java, where you explicitly have to <em class="italic">name</em> the <span class="No-Break">constituent types.</span></p>
			<p>Go interfaces are simply method sets. When a data type defines a set of methods, it also automatically implements all interfaces that contain a subset of its methods. For instance, if data type <strong class="source-inline">A</strong> defines a <strong class="source-inline">func (A) F()</strong> method, then <strong class="source-inline">A</strong> also implements the <strong class="source-inline">interface { func F() }</strong> and <strong class="source-inline">interface{}</strong> interfaces. If interface <strong class="source-inline">A</strong> is a subset of interface <strong class="source-inline">B</strong>, then a data type implementing interface <strong class="source-inline">B</strong> can be used wherever <strong class="source-inline">A</strong> <span class="No-Break">is needed.</span></p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor161"/>Interfaces as contracts</h2>
			<p>An interface can be <a id="_idIndexMarker204"/>used as a “specification,” or like a “contract” that defines certain functions an implementation <span class="No-Break">should satisfy.</span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor162"/>How to do it...</h2>
			<p>Define an interface or<a id="_idIndexMarker205"/> a set of interfaces to specify the expected behavior of an object. This is suitable when multiple different implementations of the same interface are expected. For instance, the standard library <strong class="source-inline">database/driver</strong> SQL driver package defines a set of interfaces that should be implemented by different <span class="No-Break">database drivers.</span></p>
			<p>For example, the following code snippet defines a storage backend for <span class="No-Break">storing files:</span></p>
			<pre class="source-code">
type Storage interface {
   Create(name string, reader io.Reader) error
   Read(name string) (io.ReadCloser,error)
   Update(name string, reader io.Reader) error
   Delete(name string) error
}</pre>			<p>You can use the instances of objects that implement the <strong class="source-inline">Storage</strong> interface to store data in different backends, such as a filesystem or some network <span class="No-Break">storage system.</span></p>
			<p>In many cases, the data types used to declare the methods of such an interface are themselves dependent on the actual implementation. In that case, a system of interfaces is necessary. The standard library <strong class="source-inline">database/driver</strong> package uses this approach. As an example, consider<a id="_idIndexMarker206"/> the following authentication <span class="No-Break">provider interface:</span></p>
			<pre class="source-code">
// Authenticator uses implementation-specific credentials to create an
// implementation-specific session
type Authenticator interface {
  Login(credentials Credentials) (Session,error)
}
// Credentials contains the credentials to authenticate a user to the 
// backend
type Credentials interface {
  Serialize() []byte
  Type() string
}
// CredentialParse implementation parses backend-specific credentials 
// from []byte input
type CredentialParser interface {
  Parse([]byte) (Credentials, error)
}
// A backend-specific session identifies the user and provides a way 
// to close the session
type Session interface {
  UserID() string
  Close()
}</pre>			<h1 id="_idParaDest-162"><a id="_idTextAnchor163"/>Factories</h1>
			<p>This section<a id="_idIndexMarker207"/> shows a recipe that is often used to support extendible structures, such as database drivers, where importing a particular database driver package automatically “registers” the driver to <span class="No-Break">a factory.</span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor164"/>How to do it...</h2>
			<ol>
				<li>Define an interface, or set of interfaces specifying how an implementation <span class="No-Break">should behave.</span></li>
				<li>Create a registry (a map), and a function to <span class="No-Break">register implementations.</span></li>
				<li>Every different implementation registers itself with the registry <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">init()</strong></span><span class="No-Break">.</span></li>
				<li>Import the implementations that will be included in the program using the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> package.</span></li>
			</ol>
			<p>Let’s implement an authentication framework using the <strong class="source-inline">Authenticator</strong> example from the last section. We will allow different implementations of the <span class="No-Break"><strong class="source-inline">Authenticator</strong></span><span class="No-Break"> framework.</span></p>
			<p>First, define a factory interface and a map to keep all <span class="No-Break">registered implementations:</span></p>
			<pre class="source-code">
package auth
type AuthenticatorFactory interface {
   NewInstance() Authenticator
}
var registry = map[string]AuthenticatorFactory{}</pre>			<p>Then, declare an exported <span class="No-Break"><strong class="source-inline">Register</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
func RegisterAuthenticator(name string, factory AuthenticatorFactory) {
   registry[name]=factory
}</pre>			<p>To dynamically create instances of authenticator, we’ll need a function that looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
func NewInstance(authType string) Authenticator {
   // Create a new instance using the selected factory.
   // If the given authType has not been registered, this will panic
   return registry[authType].NewInstance()
}</pre>			<p>Implementations <a id="_idIndexMarker208"/>can register their own factories using the <span class="No-Break"><strong class="source-inline">init()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
type factory struct{}
func (factory) NewInstance() auth.Authenticator {
  // Create and return a new instance of db authenticator
}
func init() {
  auth.RegisterAuthenticator("dbauthenticator",factory{})
}</pre>			<p>Finally, you have to stitch this together. The Go build system will only include packages that have been directly or indirectly used by the code accessible from <strong class="source-inline">main()</strong>, and the implementations are not directly referenced. We have to make sure those packages are imported, and thus, the implementations are registered. So, import them <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
package main
import (
  _ "import/path/of/the/implementation"
  ...
)</pre>			<p>The preceding <strong class="source-inline">import</strong> will include the implementation package in the program. Since the package is included in the program, its <strong class="source-inline">init()</strong> function will be called during program initialization, and <a id="_idIndexMarker209"/>the authenticator type it provides will <span class="No-Break">be registered.</span></p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor165"/>Defining interfaces where you use them</h1>
			<p>Structural typing<a id="_idIndexMarker210"/> allows you to define an interface when you need to use one, as opposed to pre-defining an exported interface. This is sometimes confused with “duck-typing” (if something walks like a duck and talks like a duck, it is a duck). The difference is that duck-typing refers to determining data type compatibility by looking at the subset of a type’s structure at runtimes, whereas structural typing refers to looking at the structure of a type at compile time. This recipe shows how you can define interfaces as you <span class="No-Break">need them.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor166"/>How to do it...</h2>
			<p>Let’s say you have code that looks like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
type A struct {
  ...
  options  map[string]any
}
func (a A) GetOptions() map[string]any {return a.options}
type B struct {
  ...
  options map[string]any
}
func (b B) GetOptions() map[string]any {return b.options}</pre>			<p>If you want to write a function that will operate on the options of a variable of type <strong class="source-inline">A</strong> or <strong class="source-inline">B</strong> (or any<a id="_idIndexMarker211"/> type that has options), you can simply define an interface <span class="No-Break">right there:</span></p>
			<pre class="source-code">
type withOptions interface {
  GetOptions() map[string]any
}
func ProcessOptions(item withOptions) {
  for key, value:=range item.GetOptions() {
    ...
  }
}</pre>			<h2 id="_idParaDest-166"><a id="_idTextAnchor167"/>How it works...</h2>
			<p>Remember, Go uses structural typing. So, you can create an interface specifying a set of methods, and any data type declaring those methods will automatically implement that interface. Thus, you can create such interfaces ad hoc, and write functions that take instances of those interfaces to work with a potentially large number of <span class="No-Break">data types.</span></p>
			<p>If you used a nominative language, you would have had to specify that those types implement your interface. Not so <span class="No-Break">in Go.</span></p>
			<p>That also means that if you have an interface <strong class="source-inline">A</strong> and another interface <strong class="source-inline">B</strong> such that <strong class="source-inline">A</strong> declares the same methods as <strong class="source-inline">B</strong>, then any type that implements <strong class="source-inline">A</strong> also implements <strong class="source-inline">B</strong>. In other words, if you cannot import an interface because it is in a package that will cause a circular dependency if imported, or if that interface is not exported by that <a id="_idIndexMarker212"/>package, you can simply define an equivalent interface in your <span class="No-Break">current package.</span></p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor168"/>Using a function as an interface</h1>
			<p>Sometimes, you<a id="_idIndexMarker213"/> might encounter a situation where you have a function <a id="_idIndexMarker214"/>when an interface is needed. This recipe shows how you can define a new function data type that also implements <span class="No-Break">an interface.</span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor169"/>How to do it...</h2>
			<p>If you need to implement a single-method interface without any data elements, you can define a new type based on an empty struct and declare a method for that type to implement that interface. Alternatively, you can simply use the function itself as an implementation of that interface. The following excerpt is from the standard library <span class="No-Break"><strong class="source-inline">net/http</strong></span><span class="No-Break"> package:</span></p>
			<pre class="source-code">
// An interface with a single function
type Handler interface {
     ServeHTTP(ResponseWriter, *Request)
}
// Define a new function type matching the interface method signature
type HandlerFunc func(ResponseWriter, *Request)
// Implement the method for the function type
func (h HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
   h(w.r) // Call the underlying function
}</pre>			<p>Here, you can use functions of the <strong class="source-inline">HandlerFunc</strong> type whenever an implementation of the <strong class="source-inline">Handler</strong> interface <span class="No-Break">is needed.</span></p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor170"/>How it works...</h2>
			<p>The Go type system treats function<a id="_idIndexMarker215"/> types as any other defined type. Thus, you <a id="_idIndexMarker216"/>can declare methods for a function type. When you declare methods for a function type, the function type automatically implements all the interfaces that define all or some of <span class="No-Break">those methods.</span></p>
			<p>Let’s examine this statement with an example. We can declare a new empty type as an implementation of the <span class="No-Break"><strong class="source-inline">Handler</strong></span><span class="No-Break"> interface:</span></p>
			<pre class="source-code">
type MyHandler struct{}
func (MyHandler) ServeHTTP(w ResponseWriter, r *Request) {...}</pre>			<p>With this declaration, you can use instances of <strong class="source-inline">MyHandler</strong> wherever a <strong class="source-inline">Handler</strong> is required. However, observe that <strong class="source-inline">MyHandler</strong> has no data elements and only one method. So instead, we define a <span class="No-Break">function type:</span></p>
			<p class="HTML-Preformatted" lang="en-US" xml:lang="en-US"><strong class="source-inline">type MyHandler func(ResponseWriter,*Request)</strong></p>
			<p>Now <strong class="source-inline">MyHandler</strong> is a new named type. This is not that much different from declaring <strong class="source-inline">MyHandler</strong> as a struct, but in this case, <strong class="source-inline">MyHandler</strong> is a function with a <span class="No-Break">fixed signature.</span></p>
			<p>Since <strong class="source-inline">MyHandler</strong> is a named type, we can define methods <span class="No-Break">for it:</span></p>
			<pre class="source-code">
func (h MyHandler) ServeHTTP(w ResponseWriter, r *Request) {
  h(w,r)
}</pre>			<p>Since <strong class="source-inline">MyHandler</strong> now defined <strong class="source-inline">ServeHTTP</strong> method, it implements the <strong class="source-inline">Handler</strong> interface. However, <strong class="source-inline">MyHandler</strong> is a function type, so <strong class="source-inline">h</strong> is actually a function that has the same signature as <strong class="source-inline">ServeHTTP</strong>. Due to that, the <strong class="source-inline">h(w,r)</strong> call works, and <strong class="source-inline">MyHandler</strong> can be<a id="_idIndexMarker217"/> used in places where a <strong class="source-inline">Handler</strong> <span class="No-Break">is</span><span class="No-Break"><a id="_idIndexMarker218"/></span><span class="No-Break"> required.</span></p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor171"/>Discovering capabilities of data types at runtime – testing "implements" relationship</h1>
			<p>An interface<a id="_idIndexMarker219"/> provides a way to call the methods of an<a id="_idIndexMarker220"/> underlying data object. If the same interface is implemented by many different types, you can use a function to manipulate diverse data types by simply using their common interface. However, many times, you need to access the underlying object stored in an interface. Go provides several mechanisms to achieve that. We will look at <strong class="source-inline">type-assertion</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">type-switch</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor172"/>How to do it...</h2>
			<p>Use interfaces and type assertions to discover different methods a type provides. Remember that an interface is a method set. A type that implements the methods given in an interface automatically implements <span class="No-Break">that interface.</span></p>
			<p>Use the following patterns to determine whether a data type has <span class="No-Break">a method:</span></p>
			<pre class="source-code">
func f(rd io.Reader) {
  // Is rd also an io.Writer?
  if wr, ok:= rd.(io.Writer); ok {
     // Yes, rd is an io.Writer, and wr is that writer.
     ...
  }
  // Does rd have a function ReadLine() (string,error)?
  // Define an interface here
  type hasReadLine interface {
     ReadLine() (string,error)
  }
  // And see if rd implements it:
  if readLine, ok:=rd.(hasReadLine); ok {
    // Yes, you can use readLine:
    line, err:=readLine.ReadLine()
    ...
  }
  // You can even define anonymous interfaces inline:
  if readLine, ok:=rd.(interface{ReadLine()(string,error)}); ok {
     line, err:=readLine.ReadLine()
  }
}</pre>			<h2 id="_idParaDest-172"><a id="_idTextAnchor173"/>How it works...</h2>
			<p>Type assertions have<a id="_idIndexMarker221"/> two<a id="_idIndexMarker222"/> forms. The following form tests if an <strong class="source-inline">intf</strong> interface variable contains a concrete value of the <span class="No-Break"><strong class="source-inline">concreteValue</strong></span><span class="No-Break"> type:</span></p>
			<p class="HTML-Preformatted" lang="en-US" xml:lang="en-US"><strong class="source-inline">value, ok:=intf.(concreteValue)</strong></p>
			<p>If the interface contains a value of that type, then <strong class="source-inline">value</strong> now has that value, and <strong class="source-inline">ok</strong> <span class="No-Break">becomes </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<p>The second form tests whether the concrete value contained within the <strong class="source-inline">intf</strong> interface also implements the <span class="No-Break"><strong class="source-inline">otherIntf</strong></span><span class="No-Break"> interface:</span></p>
			<p class="HTML-Preformatted" lang="en-US" xml:lang="en-US"><strong class="source-inline">value, ok:=intf.(otherIntf)</strong></p>
			<p>If the value contained in <strong class="source-inline">intf</strong> also has the methods declared by <strong class="source-inline">otherIntf</strong>, then <strong class="source-inline">value</strong> is now an interface value of the <strong class="source-inline">otherIntf</strong> type containing the same concrete value as <strong class="source-inline">intf</strong>, and <strong class="source-inline">ok</strong> is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
			<p>Using this second form, you can test whether an interface variable implements the methods <span class="No-Break">you need.</span></p>
			<p>You may think you can do the same thing using reflection. Reflection is a method for discovering the names <a id="_idIndexMarker223"/>of <a id="_idIndexMarker224"/>fields and methods of types at runtime. It is not a performant or easy method to check such type equivalences. </p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor174"/>Testing whether an interface value is one of the known types</h1>
			<p>A type-switch is<a id="_idIndexMarker225"/> used to test whether an interface value is a known concrete type, or whether it implements a certain interface. This recipe shows how it can <span class="No-Break">be used.</span></p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor175"/>How to do it...</h2>
			<p>Use a type-switch instead of a sequence of type assertions if you need to check an interface against <span class="No-Break">multiple types.</span></p>
			<p>The following example uses an <strong class="source-inline">interface{}</strong> to add two values. The values can either both be <strong class="source-inline">int</strong>, or both <strong class="source-inline">float64</strong>. The function also provides a way to override the addition behavior: if the value has a compatible <strong class="source-inline">Add</strong> method, it calls <span class="No-Break">that instead:</span></p>
			<pre class="source-code">
// a and b must have the same types. They can be int, float64, or 
// another type
// that has Add method.
func Add(a, b interface{}) interface{} {
  // type switch:
  // In this form, a matching case block will declare aValue
  // with the correct type
  switch aValue:=a.(type) {
    case int:
      // Here, aValue is an int
      // b must be an int!
      bValue:=b.(int)
      return aValue+bValue
    case float64:
      // Here, aValue is a float64
      // b must be a float64!
      bValue:=b.(float64)
      return aValue+bValue
    case interface { Add(interface{}) interface{} }:
      // Here, aValue is an interface {Add{interface{}) interface{}}
      return aValue.Add(b)
    default:
      // Here, aValue is not defined
      // This is an unhandled case
      return nil
  }
}</pre>			<p>Note the way the type switch<a id="_idIndexMarker226"/> is used to extract the value contained in the interface if the case matches. This only works if the case lists a single type, and if the case is not the <strong class="source-inline">default</strong> case. For those cases, the variable is simply not defined and you work with <span class="No-Break">the interface.</span></p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor176"/>Ensuring a type implements an interface during development</h1>
			<p>During the development <a id="_idIndexMarker227"/>stages of a project, interface types may change quickly by adding new methods, or modifying existing method signatures by changing argument types or return types. How can developers make sure certain implementations of those interfaces are not broken by <span class="No-Break">those changes?</span></p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor177"/>How to do it...</h2>
			<p>Let’s say your team defined the <span class="No-Break">following interface:</span></p>
			<pre class="source-code">
type Car interface {
   Move(int,int)
}</pre>			<p>We’ll also say that you implemented that interface with the <span class="No-Break">following struct:</span></p>
			<pre class="source-code">
type RaceCar struct {
   X, Y int
}
func (r *RaceCar) Move(dx, dy int) {
  r.X+=dx
  r.Y+=dy
}</pre>			<p>However, later in the development, it turned out not all cars can move successfully, so the signature of the interface changes to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
type Car interface {
   Move(int,int) error
}</pre>			<p>With this change, <strong class="source-inline">RaceCar</strong> no longer implements <strong class="source-inline">Car</strong>. Many times this error will be caught at compile time, but not always. For instance, if instances of <strong class="source-inline">*RaceCar</strong> are passed to functions that require <strong class="source-inline">any</strong>, the compilation will succeed, but a runtime panic will be raised if that argument is converted to a <strong class="source-inline">Car</strong> or <strong class="source-inline">*RaceCar</strong> via <span class="No-Break">type assertion:</span></p>
			<pre class="source-code">
rc := item.(Car)</pre>			<p>Let’s say that you declare <span class="No-Break">the following:</span></p>
			<pre class="source-code">
var _ Car = &amp;RaceCar{}</pre>			<p>Any modification to the <strong class="source-inline">Car</strong> interface that makes <strong class="source-inline">*RaceCar</strong> no longer implement the <strong class="source-inline">Car</strong> interface will be a <span class="No-Break">compile error.</span></p>
			<p>So, in general: declare <a id="_idIndexMarker228"/>a blank variable with the interface type, and assign it to the <span class="No-Break">concrete type:</span></p>
			<pre class="source-code">
type I interface {...}
type Implem struct { ... }
// If something changes in Implem or I that causes Implem
// to no longer implement interface I, this will give a
// compile-time error
var _ I = Implem{}
// Same as above, but this ensures *Implem implements I
var _ I = &amp;Implem{}</pre>			<p>If there are changes<a id="_idIndexMarker229"/> that cause the type to no longer implement that interface, a compile error will <span class="No-Break">be raised.</span></p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor178"/>Deciding whether to use a pointer receiver or value receiver for methods</h1>
			<p>In this recipe, we’ll explore<a id="_idIndexMarker230"/> how to choose between a pointer receiver and a value receiver <span class="No-Break">for methods.</span></p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor179"/>How to do it...</h2>
			<p>In general, use one kind, not both. There are two reasons <span class="No-Break">for this:</span></p>
			<ul>
				<li>Consistency throughout <span class="No-Break">the code.</span></li>
				<li>Mixing value and pointer receivers can result in <span class="No-Break">data races.</span></li>
			</ul>
			<p>If a method modifies the receiver object, use a pointer receiver. If a method does not modify the receiver object, or if the method relies on getting a copy of the receiver object, you can use a <span class="No-Break">value receiver.</span></p>
			<p>If you are implementing an immutable type, in most cases, you should use a <span class="No-Break">value receiver.</span></p>
			<p>If your structures are large, using a pointer receiver will reduce copy overhead. You can find different guidelines on whether or not a structure can be considered large. When in doubt, write a benchmark <span class="No-Break">and measure.</span></p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor180"/>How it works...</h2>
			<p>For a type <strong class="source-inline">T</strong>, if you declare a method using a value receiver, that method is declared for both <strong class="source-inline">T</strong> and <strong class="source-inline">*T</strong>. The method gets a copy of the receiver, not a pointer to it, so any modifications performed on the receiver will not be reflected to the object used for calling <span class="No-Break">the method.</span></p>
			<p>For example, the following method returns a copy of the original object while modifying <span class="No-Break">one field:</span></p>
			<pre class="source-code">
type Action struct {
   Option string
}
// Returns a copy of a with the given option. The original a is not 
// modified.
func (a Action) WithOption(option string) Action {
   a.Option=option
   return a
}
func main() {
   x:=Action{
      Option:"a",
   }
   y:=x.WithOption("b")
   fmt.Println(x.Option, y.Option) // Outputs: a b
}</pre>			<p>A value receiver creates a shallow copy of the original. If the receiver struct has maps, slices, or pointers to other objects, only the map headers, slice headers, or pointers will be copied, not the contents of the pointed object. That means that even though the method gets a value <a id="_idIndexMarker231"/>receiver in the following example, changes to the map are reflected in both the original and <span class="No-Break">the copy:</span></p>
			<pre class="source-code">
type T struct {
  m map[string]int
}
func (t T) add(k string, v int) {
   t.m[k]=v
}
func main() {
  t:=T{
     m:make(map[string]int,
  }
  t.add("a",1)
  fmt.Println(t) // [a:1]
}</pre>			<p>Be careful about how this affects slice operations. A slice is a triple <strong class="source-inline">(pointer, len, cap)</strong>, and that is <a id="_idIndexMarker232"/>what’s copied when you pass a <span class="No-Break">value receiver:</span></p>
			<pre class="source-code">
type T struct {
  s []string
}
func (t T) set(i int, s string) {
  t.s[i]=s
}
func (t T) add(s string) {
  t.s=append(t.s,s)
}
func main() {
  t:=T{
    s: []string{"a","b"},
  }
  fmt.Println(t.s) // [a, b]
  // Setting a slice element contained in the value receiver will be 
  // visible here
  t.set(0,"x")
  fmt.Println(t.s) // [x, b]
  // Appending to the slice contained in the value receiver will not 
  // be visible here
  // The appended slice header is set in the copy of t, the original 
  // never sees that update
  t.add("y")
  fmt.Println(t.s) // [x, b]
}</pre>			<p>A pointer receiver is more straightforward to work with. The method always gets a pointer to the <a id="_idIndexMarker233"/>object it is called with. In the preceding example, declaring the <strong class="source-inline">add</strong> method with a pointer receiver behaves <span class="No-Break">as expected:</span></p>
			<pre class="source-code">
func (t *T) add(s string) {
  t.s=append(t.s,s)
}
...
 t.add("y")
 fmt.Println(t.s) // [x, b, y]</pre>			<p>At the beginning of this section, I also mentioned that mixing pointer and value receivers causes a data race. Here is how <span class="No-Break">it happens.</span></p>
			<p>Remember that a data race happens when a goroutine reads from a variable that is being concurrently modified by another. Consider the following example where the <strong class="source-inline">Version</strong> method <a id="_idIndexMarker234"/>uses a value receiver that causes a copy of <strong class="source-inline">T</strong> to <span class="No-Break">be created:</span></p>
			<pre class="source-code">
type T struct {
  X int
}
func (t T) Version() int  {return 1}
func (t *T) SetValue(x int) {t.X=x}
func main() {
  t:=T{}
  go func () {
     t.SetValue(1) // Writes to t.X
  }()
  ver := t.Version() // Makes a copy of t, which reads t.X
  ...
}</pre>			<p>The act of calling <strong class="source-inline">t.Version()</strong> creates a copy of the variable <strong class="source-inline">t</strong>, reading <strong class="source-inline">t.X</strong> concurrently as it is being modified, hence causing a race. This race is more obvious if <strong class="source-inline">t.Version</strong> reads from <strong class="source-inline">t.X</strong> explicitly. There is no guarantee that that read operation will see<a id="_idIndexMarker235"/> the effects of the write operation in <span class="No-Break">the goroutine.</span></p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor181"/>Polymorphic containers</h1>
			<p>In this context, a container <a id="_idIndexMarker236"/>is a data structure that holds many objects. The principles of this section can be applied to single objects as well. In other words, you can use the same idea when you have a single polymorphic variable or a <span class="No-Break">struct field.</span></p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor182"/>How to do it...</h2>
			<ol>
				<li>Define an interface containing the methods common to all data types that will be stored in <span class="No-Break">the container.</span></li>
				<li>Declare the container type using <span class="No-Break">that interface.</span></li>
				<li>Put instances of actual objects into <span class="No-Break">the container.</span></li>
				<li>When you retrieve objects from the container, you can either work with the object through the interface, or type-assert, get the actual type or another interface, and work <span class="No-Break">with that.</span></li>
			</ol>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor183"/>How it works...</h2>
			<p>Here’s a simple example that works with <strong class="source-inline">Shape</strong> objects. A <strong class="source-inline">Shape</strong> object is something that can be drawn on an image, and <span class="No-Break">moved around:</span></p>
			<pre class="source-code">
type Shape interface {
  Draw(image.Image)
  Move(dx, dy int)
}</pre>			<p>Shape has <span class="No-Break">several implementations:</span></p>
			<pre class="source-code">
type Rectangle struct {
   rect image.Rectangle
   color color.Color
}
func (r *Rectangle) Draw(target image.Image) {...}
func (r *Rectangle) Move(dx, dy int) {...}
type Circle struct {
   center image.Point
   color color.Color
}
func (c *Circle) Draw(target image.Image) {...}
func (c *Circle) Move(dx, dy int) {...}</pre>			<p>Both <strong class="source-inline">*Rectangle</strong> and <strong class="source-inline">*Circle</strong> implement the <strong class="source-inline">Shape</strong> interface (note that <strong class="source-inline">Rectangle</strong> and <strong class="source-inline">Circle</strong> do not.) Now <a id="_idIndexMarker237"/>we can work with a slice <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Shapes</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func Draw(target image.Image, shapes []Shape) {
  for _,shape:=range shapes {
    shape.Draw(targeT)
  }
}</pre>			<p>This is what the <strong class="source-inline">shapes</strong> slice <span class="No-Break">looks like:</span></p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B21961_05_1.jpg" alt="Figure 5.1 – Slice of interface variables" width="926" height="464"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Slice of interface variables</p>
			<p>Since every interface contains a pointer to the actual shape, it is possible to use the interface to call <a id="_idIndexMarker238"/>methods that modify the object <span class="No-Break">as well:</span></p>
			<pre class="source-code">
func Move(dx, dy int, shapes []Shape) {
  for _,shape:=range shapes {
    shape.Move(dx, dy)
  }
}</pre>			<h1 id="_idParaDest-183"><a id="_idTextAnchor184"/>Accessing parts of an object not directly exposed via the interface</h1>
			<p>When working with<a id="_idIndexMarker239"/> interfaces, there are many occasions where you need to access the underlying object. This is achieved by type-assertion, that is, testing whether the value of an interface satisfies a given type, and if so, <span class="No-Break">retrieving it.</span></p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor185"/>How to do it...</h2>
			<p>Use type assertion <a id="_idIndexMarker240"/>or a type switch to test the type of the object contained in <span class="No-Break">an interface:</span></p>
			<pre class="source-code">
func f(shape Shape) {
   if rect, ok := shape.(*Rectangle); ok {
      // shape contains a *Rectangle, and rect now points to it
   }
   switch actualShape := shape.(type) {
      case *Circle :
         // shape is a *Circle, and actualShape is a *Circle variable
      case *Rectangle:
         // shape is a *Rectangle, and actualShape is a *Rectangle 
         // variable
      default:
         // shape is not a circle or rectangle. actualShape is not 
         // defined here
   }
}</pre>			<h1 id="_idParaDest-185"><a id="_idTextAnchor186"/>Accessing the embedding struct from the embedded struct</h1>
			<p>In object-oriented<a id="_idIndexMarker241"/> languages such as Java or C++, there is the concept of an abstract method or virtual method, together with type inheritance. One effect of this feature is that if you call a method <strong class="source-inline">M</strong> of a base class <strong class="source-inline">base</strong>, then the method that runs at runtime is the implementation of <strong class="source-inline">M</strong> that is declared for the actual object at runtime. In other words, you can invoke a method that will be overridden by other declarations, and you just don’t know which method you are <span class="No-Break">actually calling.</span></p>
			<p>There are ways of doing the same thing in Go. This recipe <span class="No-Break">shows how.</span></p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor187"/>How to do it...</h2>
			<p>Let’s say you need to write a circular linked list data structure whose elements will be structs embedding a <span class="No-Break">base struct:</span></p>
			<pre class="source-code">
type ListNodeHeader struct {
  next Node
  prev Node
  list *List
}</pre>			<p>The list itself is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
type List struct {
  first Node
}</pre>			<p>So, the list points to the <strong class="source-inline">first</strong> node, which is an arbitrary node in the list, and every node points to the<a id="_idIndexMarker242"/> next one, with the last node pointing back to <span class="No-Break">the first.</span></p>
			<p>We need a <strong class="source-inline">Node</strong> interface that defines the mechanics of maintaining a list. Of course, the <strong class="source-inline">Node</strong> interface will be implemented by <strong class="source-inline">ListNodeHeader</strong>, and thus, by all the nodes of <span class="No-Break">the list:</span></p>
			<pre class="source-code">
type Node interface {
  ...
}</pre>			<p>The users of the list are supposed to embed <strong class="source-inline">ListHeader</strong> to implement a <span class="No-Break"><strong class="source-inline">list</strong></span><span class="No-Break"> node:</span></p>
			<pre class="source-code">
type ByteSliceElement struct {
  ListNodeHeader
  Payload []byte
}
type StringElement struct {
  ListNodeHeader
  Payload string
}</pre>			<p>Now the hard part is to implement the <strong class="source-inline">Node</strong> interface. Let’s assume you would like to insert a <strong class="source-inline">ByteSliceElement</strong> in this list. Since <strong class="source-inline">ByteSliceElement</strong> embeds <strong class="source-inline">ListNodeHeader</strong>, it has all its methods and thus implements <strong class="source-inline">Node</strong>. However, we can’t write, for instance, an <strong class="source-inline">Insert</strong> method for <strong class="source-inline">ListNodeHeader</strong> without knowing the actual object <span class="No-Break">being inserted.</span></p>
			<p>One way of doing this is by <a id="_idIndexMarker243"/>using the <span class="No-Break">following pattern:</span></p>
			<pre class="source-code">
type Node interface {
   Insert(list *List, this Node)
   getHeader() *ListNodeHeader
}
func (header *ListNodeHeader) getHeader() *ListNodeHeader {return header}
func (header *ListNodeHeader) Insert(list *List,this Node) {
   // If list is empty, this is the only node
   if list.first == nil {
      list.first = this
      header.next = this
      header.prev = this
      return
   }
   header.next=list.first
   header.prev=list.first.getHeader().prev
   header.prev.getHeader().next=this
   header.next.getHeader().prev=this
}</pre>			<p>There are several things going on here. First, the <strong class="source-inline">Insert</strong> method gets two views of the node being inserted. If the node being inserted is a <strong class="source-inline">*ByteSliceElement</strong>, then it gets a <strong class="source-inline">Node</strong> version of this, and then it also gets the <strong class="source-inline">*ListNodeHeader</strong> embedded in <strong class="source-inline">ByteSliceElement</strong> as the receiver. Using this, it can adjust the members of the <strong class="source-inline">ByteSliceElement</strong> to point to the previous and <span class="No-Break">next nodes.</span></p>
			<p>However, it cannot access the <strong class="source-inline">prev</strong> and <strong class="source-inline">next</strong> members of <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">Node</strong></span><span class="No-Break">.</span></p>
			<p>One option is what is shown: declare an unexported method in the <strong class="source-inline">Node</strong> interface that will return the <strong class="source-inline">ListNodeHeader</strong> from a given node. Another option is to add <strong class="source-inline">getNext/setNext</strong> and <strong class="source-inline">getPrev/setPrev</strong> methods to <span class="No-Break">the interface.</span></p>
			<p>Now you have achieved two things: first, any user of this list structure outside this package <em class="italic">must</em> embed <strong class="source-inline">ListNodeHeader</strong> to implement a list node. There is an unexported method in the interface. There is no way to implement such an interface in a different package. The only way is to embed a struct that already <span class="No-Break">implements it.</span></p>
			<p>Second, you have a <a id="_idIndexMarker244"/>polymorphic container data structure whose mechanics are managed by a <span class="No-Break">base struct.</span></p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor188"/>Checking whether an interface is nil</h1>
			<p>You may wonder <a id="_idIndexMarker245"/>why this is even a problem. After all, don’t you just compare with nil? <span class="No-Break">Not always.</span></p>
			<p>An interface contains two values: the type of the value contained in the interface, and a pointer to that value. An interface is nil if both of those are nil. There are cases where an interface may point to a nil value of a type other than nil, which makes the <span class="No-Break">interface non-nil.</span></p>
			<p>You can’t check for this case easily. You have to avoid creating interfaces with <span class="No-Break">nil values.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor189"/>How to do it...</h2>
			<p>Avoid converting a pointer to a variable that can be nil to <span class="No-Break">an interface:</span></p>
			<pre class="source-code">
type myerror struct{}
func (myerror) Error() string { return "" }
func main() {
   var x *myerror
   var y error
   y = x // Avoid this
   if y!=nil {
      // y is not nil!
   }
}</pre>			<p>Check for nil interface<a id="_idIndexMarker246"/> values explicitly instead, such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
var y error
if x!=nil {
   y=x
}</pre>			<p>Alternatively, use value errors instead of pointers. The following code avoids this <span class="No-Break">problem altogether:</span></p>
			<p class="HTML-Preformatted" lang="en-US" xml:lang="en-US"><strong class="source-inline">var x myerror</strong></p>
			<p>There is no chance of <strong class="source-inline">x</strong> <span class="No-Break">being nil.</span></p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor190"/>How it works...</h2>
			<p>As I explained earlier, an interface contains two values: type and value. What you are trying to avoid is creating an interface that contains a nil value with a <span class="No-Break">non-nil type.</span></p>
			<p>After the declaration that follows, the <strong class="source-inline">y</strong> interface is nil because both its type and its value <span class="No-Break">are nil:</span></p>
			<p class="HTML-Preformatted" lang="en-US" xml:lang="en-US"><strong class="source-inline">var y error</strong></p>
			<p>After the following assignment, the type stored in <strong class="source-inline">y</strong> is now the type of <strong class="source-inline">x</strong>, and the value is nil. Thus, <strong class="source-inline">y</strong> is no <span class="No-Break">longer nil:</span></p>
			<p class="HTML-Preformatted" lang="en-US" xml:lang="en-US"><strong class="source-inline">y=x</strong></p>
			<p>This also applies <a id="_idIndexMarker247"/>to return from <span class="No-Break">a function:</span></p>
			<pre class="source-code">
func f() error {
     var x *myerror
     return x
}</pre>			<p>The <strong class="source-inline">f</strong> function never <span class="No-Break">returns nil.</span></p>
		</div>
	</div></div></body></html>