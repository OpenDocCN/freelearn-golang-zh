["```go\n    type Direction int\n    ```", "```go\n    const (\n      DirectionLeft Direction = iota\n      DirectionRight\n    )\n    ```", "```go\n    func SetDirection(dir Direction) {...}\n    func main() {\n      SetDirection(DirectionLeft)\n      SetDirection(Direction(0))\n      ...\n    }\n    ```", "```go\ntype NewTypeName struct {\n   // List of fields\n}\n```", "```go\ntype User struct {\n  Username string\n  Password string\n}\n```", "```go\ntype Common struct {\n  commonField int\n}\nfunc (a Common) CommonMethod() {}\ntype A struct {\n  Common\n  aField int\n}\nfunc (a A) AMethod() {}\ntype B struct {\n  Common\n  bField int\n}\nfunc (b B) BMethod() {}\n```", "```go\ntype Metadata struct {\n  ID string\n  CreatedAt time.Time\n  ModifiedAt time.Time\n}\n// New initializes metadata fields\nfunc (m *Metadata) New() {\n  m.ID=uuid.New().String()\n  m.CreatedAt=time.Now()\n  m.ModifiedAt=m.CreatedAt\n}\n// Customer.New() uses the promoted Metadata.New() method.\n// Calling Customer.New() will initialize Customer.Metadata, but\n// will not modify Customer specific fields.\ntype Customer struct {\n  Metadata\n  Name string\n}\n// Product.New(string) shadows `Metadata.New() method. You cannot\n// call `Product.New()`, but call `Product.New(string)` or\n// `Product.Metadata.New()`\ntype Product struct {\n  Metadata\n  SKU string\n}\nfunc (p *Product) New(sku string) {\n  // Initialize the metadata part of product\n  p.Metadata.New()\n  p.SKU=sku\n}\nfunc main() {\n   c:=Customer{}\n   c.New() // Initialize customer metadata\n   p:=Product{}\n   p.New(\"sku\") // Initialize product metadata and sku\n   // p.New() // Compile error: p.New() takes a string argument\n}\n```", "```go\ntype Index struct {\n   index map[string]any\n   name string\n}\nfunc NewIndex(name string) *Index {\n  return &Index{\n    index:make(map[string]any),\n    name:name,\n  }\n}\nfunc (index *Index) Name() string {return index.name}\nfunc (index *Index) Add(key string, value any) {\n  index.index[key]=value\n}\n```", "```go\ntype Storage interface {\n   Create(name string, reader io.Reader) error\n   Read(name string) (io.ReadCloser,error)\n   Update(name string, reader io.Reader) error\n   Delete(name string) error\n}\n```", "```go\n// Authenticator uses implementation-specific credentials to create an\n// implementation-specific session\ntype Authenticator interface {\n  Login(credentials Credentials) (Session,error)\n}\n// Credentials contains the credentials to authenticate a user to the \n// backend\ntype Credentials interface {\n  Serialize() []byte\n  Type() string\n}\n// CredentialParse implementation parses backend-specific credentials \n// from []byte input\ntype CredentialParser interface {\n  Parse([]byte) (Credentials, error)\n}\n// A backend-specific session identifies the user and provides a way \n// to close the session\ntype Session interface {\n  UserID() string\n  Close()\n}\n```", "```go\npackage auth\ntype AuthenticatorFactory interface {\n   NewInstance() Authenticator\n}\nvar registry = map[string]AuthenticatorFactory{}\n```", "```go\nfunc RegisterAuthenticator(name string, factory AuthenticatorFactory) {\n   registry[name]=factory\n}\n```", "```go\nfunc NewInstance(authType string) Authenticator {\n   // Create a new instance using the selected factory.\n   // If the given authType has not been registered, this will panic\n   return registry[authType].NewInstance()\n}\n```", "```go\ntype factory struct{}\nfunc (factory) NewInstance() auth.Authenticator {\n  // Create and return a new instance of db authenticator\n}\nfunc init() {\n  auth.RegisterAuthenticator(\"dbauthenticator\",factory{})\n}\n```", "```go\npackage main\nimport (\n  _ \"import/path/of/the/implementation\"\n  ...\n)\n```", "```go\ntype A struct {\n  ...\n  options  map[string]any\n}\nfunc (a A) GetOptions() map[string]any {return a.options}\ntype B struct {\n  ...\n  options map[string]any\n}\nfunc (b B) GetOptions() map[string]any {return b.options}\n```", "```go\ntype withOptions interface {\n  GetOptions() map[string]any\n}\nfunc ProcessOptions(item withOptions) {\n  for key, value:=range item.GetOptions() {\n    ...\n  }\n}\n```", "```go\n// An interface with a single function\ntype Handler interface {\n     ServeHTTP(ResponseWriter, *Request)\n}\n// Define a new function type matching the interface method signature\ntype HandlerFunc func(ResponseWriter, *Request)\n// Implement the method for the function type\nfunc (h HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {\n   h(w.r) // Call the underlying function\n}\n```", "```go\ntype MyHandler struct{}\nfunc (MyHandler) ServeHTTP(w ResponseWriter, r *Request) {...}\n```", "```go\nfunc (h MyHandler) ServeHTTP(w ResponseWriter, r *Request) {\n  h(w,r)\n}\n```", "```go\nfunc f(rd io.Reader) {\n  // Is rd also an io.Writer?\n  if wr, ok:= rd.(io.Writer); ok {\n     // Yes, rd is an io.Writer, and wr is that writer.\n     ...\n  }\n  // Does rd have a function ReadLine() (string,error)?\n  // Define an interface here\n  type hasReadLine interface {\n     ReadLine() (string,error)\n  }\n  // And see if rd implements it:\n  if readLine, ok:=rd.(hasReadLine); ok {\n    // Yes, you can use readLine:\n    line, err:=readLine.ReadLine()\n    ...\n  }\n  // You can even define anonymous interfaces inline:\n  if readLine, ok:=rd.(interface{ReadLine()(string,error)}); ok {\n     line, err:=readLine.ReadLine()\n  }\n}\n```", "```go\n// a and b must have the same types. They can be int, float64, or \n// another type\n// that has Add method.\nfunc Add(a, b interface{}) interface{} {\n  // type switch:\n  // In this form, a matching case block will declare aValue\n  // with the correct type\n  switch aValue:=a.(type) {\n    case int:\n      // Here, aValue is an int\n      // b must be an int!\n      bValue:=b.(int)\n      return aValue+bValue\n    case float64:\n      // Here, aValue is a float64\n      // b must be a float64!\n      bValue:=b.(float64)\n      return aValue+bValue\n    case interface { Add(interface{}) interface{} }:\n      // Here, aValue is an interface {Add{interface{}) interface{}}\n      return aValue.Add(b)\n    default:\n      // Here, aValue is not defined\n      // This is an unhandled case\n      return nil\n  }\n}\n```", "```go\ntype Car interface {\n   Move(int,int)\n}\n```", "```go\ntype RaceCar struct {\n   X, Y int\n}\nfunc (r *RaceCar) Move(dx, dy int) {\n  r.X+=dx\n  r.Y+=dy\n}\n```", "```go\ntype Car interface {\n   Move(int,int) error\n}\n```", "```go\nrc := item.(Car)\n```", "```go\nvar _ Car = &RaceCar{}\n```", "```go\ntype I interface {...}\ntype Implem struct { ... }\n// If something changes in Implem or I that causes Implem\n// to no longer implement interface I, this will give a\n// compile-time error\nvar _ I = Implem{}\n// Same as above, but this ensures *Implem implements I\nvar _ I = &Implem{}\n```", "```go\ntype Action struct {\n   Option string\n}\n// Returns a copy of a with the given option. The original a is not \n// modified.\nfunc (a Action) WithOption(option string) Action {\n   a.Option=option\n   return a\n}\nfunc main() {\n   x:=Action{\n      Option:\"a\",\n   }\n   y:=x.WithOption(\"b\")\n   fmt.Println(x.Option, y.Option) // Outputs: a b\n}\n```", "```go\ntype T struct {\n  m map[string]int\n}\nfunc (t T) add(k string, v int) {\n   t.m[k]=v\n}\nfunc main() {\n  t:=T{\n     m:make(map[string]int,\n  }\n  t.add(\"a\",1)\n  fmt.Println(t) // [a:1]\n}\n```", "```go\ntype T struct {\n  s []string\n}\nfunc (t T) set(i int, s string) {\n  t.s[i]=s\n}\nfunc (t T) add(s string) {\n  t.s=append(t.s,s)\n}\nfunc main() {\n  t:=T{\n    s: []string{\"a\",\"b\"},\n  }\n  fmt.Println(t.s) // [a, b]\n  // Setting a slice element contained in the value receiver will be \n  // visible here\n  t.set(0,\"x\")\n  fmt.Println(t.s) // [x, b]\n  // Appending to the slice contained in the value receiver will not \n  // be visible here\n  // The appended slice header is set in the copy of t, the original \n  // never sees that update\n  t.add(\"y\")\n  fmt.Println(t.s) // [x, b]\n}\n```", "```go\nfunc (t *T) add(s string) {\n  t.s=append(t.s,s)\n}\n...\n t.add(\"y\")\n fmt.Println(t.s) // [x, b, y]\n```", "```go\ntype T struct {\n  X int\n}\nfunc (t T) Version() int  {return 1}\nfunc (t *T) SetValue(x int) {t.X=x}\nfunc main() {\n  t:=T{}\n  go func () {\n     t.SetValue(1) // Writes to t.X\n  }()\n  ver := t.Version() // Makes a copy of t, which reads t.X\n  ...\n}\n```", "```go\ntype Shape interface {\n  Draw(image.Image)\n  Move(dx, dy int)\n}\n```", "```go\ntype Rectangle struct {\n   rect image.Rectangle\n   color color.Color\n}\nfunc (r *Rectangle) Draw(target image.Image) {...}\nfunc (r *Rectangle) Move(dx, dy int) {...}\ntype Circle struct {\n   center image.Point\n   color color.Color\n}\nfunc (c *Circle) Draw(target image.Image) {...}\nfunc (c *Circle) Move(dx, dy int) {...}\n```", "```go\nfunc Draw(target image.Image, shapes []Shape) {\n  for _,shape:=range shapes {\n    shape.Draw(targeT)\n  }\n}\n```", "```go\nfunc Move(dx, dy int, shapes []Shape) {\n  for _,shape:=range shapes {\n    shape.Move(dx, dy)\n  }\n}\n```", "```go\nfunc f(shape Shape) {\n   if rect, ok := shape.(*Rectangle); ok {\n      // shape contains a *Rectangle, and rect now points to it\n   }\n   switch actualShape := shape.(type) {\n      case *Circle :\n         // shape is a *Circle, and actualShape is a *Circle variable\n      case *Rectangle:\n         // shape is a *Rectangle, and actualShape is a *Rectangle \n         // variable\n      default:\n         // shape is not a circle or rectangle. actualShape is not \n         // defined here\n   }\n}\n```", "```go\ntype ListNodeHeader struct {\n  next Node\n  prev Node\n  list *List\n}\n```", "```go\ntype List struct {\n  first Node\n}\n```", "```go\ntype Node interface {\n  ...\n}\n```", "```go\ntype ByteSliceElement struct {\n  ListNodeHeader\n  Payload []byte\n}\ntype StringElement struct {\n  ListNodeHeader\n  Payload string\n}\n```", "```go\ntype Node interface {\n   Insert(list *List, this Node)\n   getHeader() *ListNodeHeader\n}\nfunc (header *ListNodeHeader) getHeader() *ListNodeHeader {return header}\nfunc (header *ListNodeHeader) Insert(list *List,this Node) {\n   // If list is empty, this is the only node\n   if list.first == nil {\n      list.first = this\n      header.next = this\n      header.prev = this\n      return\n   }\n   header.next=list.first\n   header.prev=list.first.getHeader().prev\n   header.prev.getHeader().next=this\n   header.next.getHeader().prev=this\n}\n```", "```go\ntype myerror struct{}\nfunc (myerror) Error() string { return \"\" }\nfunc main() {\n   var x *myerror\n   var y error\n   y = x // Avoid this\n   if y!=nil {\n      // y is not nil!\n   }\n}\n```", "```go\nvar y error\nif x!=nil {\n   y=x\n}\n```", "```go\nfunc f() error {\n     var x *myerror\n     return x\n}\n```"]