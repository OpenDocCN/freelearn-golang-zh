- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Types, Structs, and Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go is a strongly typed language. That means every value in a program must be
    defined using a set of predefined basic types. The rules of the type system determine
    what can be done with those values, and how values of different types interact.
    The Go type system takes a simplistic approach; it only allows explicit conversions
    between values of different compatible types.
  prefs: []
  type: TYPE_NORMAL
- en: Go is also a statically typed language, which means that types of values are
    explicitly declared and checked at compile time, as opposed to being checked at
    runtime. This is different from scripting languages such as Python or JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at some of the properties of the Go type system,
    defining new types, structures, and interfaces, and considering how to make effective
    use of it to implement some common patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating new types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using composition to extend types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphic containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several reasons why you want to define new types. An important one
    is ensuring type safety. Type safety ensures that operations receive the correct
    type of data. A type-safe program is free of type errors, limiting possible errors
    in the program to logic errors only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other reasons for creating new types also include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You can share the methods and data fields of a type in multiple different types
    by *embedding* it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later in this chapter, we will look at interfaces. You can define a set of methods
    for a new type to implement a given interface that lets you use that type in different
    contexts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new type based on an existing type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a new type allows you to enforce type-safety rules, and add type-specific
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new type based on an existing type using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type <NewTypeName> <ExistingTypeName>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following declaration defines a new data type, `Duration`,
    as an unsigned 64-bit integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type Duration uint64`'
  prefs: []
  type: TYPE_NORMAL
- en: This is how the Go standard library defines `time.Duration`. To call the `time.Sleep(d
    Duration)` function, you now have to use a `time.Duration` value, or explicitly
    convert a numeric value to a `time.Duration` value.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new type from an existing type, the new type is created without
    any methods even if the existing type has methods defined.
  prefs: []
  type: TYPE_NORMAL
- en: Creating type-safe enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will define a set of constants (an enumeration) with a new
    type.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define a new type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a sequence of constants representing the values of the enumeration using
    the new type. You can use `iota` for numeric constants to generate increasing
    numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the new type in functions or data elements expecting this new type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: This does not prevent someone from calling `SetDirection(Direction(3))`, which
    is an invalid value. This is usually only a problem for enumerated values read
    from user input or from third-party sources. You should validate the input at
    that point.
  prefs: []
  type: TYPE_NORMAL
- en: Creating struct types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Go struct is a collection of fields. Define structs to group interrelated
    data fields to form a record. This recipe shows how to create new struct types
    in your program.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a struct type using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Extending types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go uses type composition through embedding, and structural typing through the
    use of interfaces. Let’s start by examining what these mean.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you embed an existing type into another, the methods and data fields defined
    for the embedded type become the methods and data fields of the embedding type.
    If you have worked with object-oriented languages, this may seem similar to class
    inheritance, but there is a crucial difference: if a class `A` is derived from
    a class `B`, then `A` is-a `B`, meaning wherever `B` is needed, you can substitute
    an instance of `A`. With composition, if `A` embeds `B`, `A` and `B` are distinct
    types, and you cannot use `A` where `B` is needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no type inheritance in Go. Go chooses composition over inheritance.
    The primary reason for this is the simplicity of combining components to build
    more complex ones. Most use cases of inheritance in object-oriented languages
    can be rearchitected using composition, interfaces, and structural typing. I used
    the word “*rearchitecting*” intentionally here: do *not* try to port existing
    object-oriented programs to Go by emulating inheritance. Instead, redesign and
    refactor them to be idiomatic Go programs using composition and interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: The next recipes will look at how this can be done.
  prefs: []
  type: TYPE_NORMAL
- en: Extending a base type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we’ll look at how we can extend a base type to share its data elements
    and methods in new types.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say you have some data fields and functionality shared between multiple
    data types. Then you can create a base data type, and embed it into multiple other
    data types to share common parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, the fields and methods of each struct are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Fields** | **Methods** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Common | commonField | CommonMethod |'
  prefs: []
  type: TYPE_TB
- en: '| A | commonField, aField | CommonMethod, AMethod |'
  prefs: []
  type: TYPE_TB
- en: '| B | commonField, bField | CommonMethod, BMethod |'
  prefs: []
  type: TYPE_TB
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have used struct embedding to share common data elements and functionality
    in the previous section. The following example shows two structs, `Customer` and
    `Product`, that share the same `Metadata` structure. `Metadata` contains the unique
    identifier, creation date, and modification date of a record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Embedding is not inheritance*. The receiver of an embedded struct method is
    *not* a copy of the defined struct. In the preceding snippet, when we call `c.New()`,
    the `Metedata.New()` method gets a receiver that is an instance of `*Metadata`,
    not an instance of `*Customer`.'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how you can use struct literals to initialize complex data
    structures containing embedded structures.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go guarantees that all declared variables are initialized to their zero values.
    This is not very useful if you have a complicated data structure that should be
    initialized with default values or non-nil pointer components. For such cases,
    use constructor-like functions to create a new instance of a struct. The established
    convention is to write a `NewX` function for a type `X` that initializes an instance
    of `X` or `*X` and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `NewIndex` creates a new initialized instance of the `Index` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Also, observe that the `Index.name` and `Index.index` fields are not exported.
    Thus, they can only be accessed using exported methods of `Index`. This pattern
    is useful for preventing unintentional modification of data fields.
  prefs: []
  type: TYPE_NORMAL
- en: Defining interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go uses “structural typing.” If a type `T` defines all the methods of an interface
    `I`, then `T` implements `I.` This causes some confusion among developers who
    are well-versed in languages that use nominative typing, such as Java, where you
    explicitly have to *name* the constituent types.
  prefs: []
  type: TYPE_NORMAL
- en: Go interfaces are simply method sets. When a data type defines a set of methods,
    it also automatically implements all interfaces that contain a subset of its methods.
    For instance, if data type `A` defines a `func (A) F()` method, then `A` also
    implements the `interface { func F() }` and `interface{}` interfaces. If interface
    `A` is a subset of interface `B`, then a data type implementing interface `B`
    can be used wherever `A` is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces as contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interface can be used as a “specification,” or like a “contract” that defines
    certain functions an implementation should satisfy.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Define an interface or a set of interfaces to specify the expected behavior
    of an object. This is suitable when multiple different implementations of the
    same interface are expected. For instance, the standard library `database/driver`
    SQL driver package defines a set of interfaces that should be implemented by different
    database drivers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code snippet defines a storage backend for storing
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can use the instances of objects that implement the `Storage` interface
    to store data in different backends, such as a filesystem or some network storage
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases, the data types used to declare the methods of such an interface
    are themselves dependent on the actual implementation. In that case, a system
    of interfaces is necessary. The standard library `database/driver` package uses
    this approach. As an example, consider the following authentication provider interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Factories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section shows a recipe that is often used to support extendible structures,
    such as database drivers, where importing a particular database driver package
    automatically “registers” the driver to a factory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Define an interface, or set of interfaces specifying how an implementation should
    behave.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a registry (a map), and a function to register implementations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every different implementation registers itself with the registry using `init()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the implementations that will be included in the program using the `main`
    package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s implement an authentication framework using the `Authenticator` example
    from the last section. We will allow different implementations of the `Authenticator`
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, define a factory interface and a map to keep all registered implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, declare an exported `Register` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To dynamically create instances of authenticator, we’ll need a function that
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementations can register their own factories using the `init()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you have to stitch this together. The Go build system will only include
    packages that have been directly or indirectly used by the code accessible from
    `main()`, and the implementations are not directly referenced. We have to make
    sure those packages are imported, and thus, the implementations are registered.
    So, import them in `main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `import` will include the implementation package in the program.
    Since the package is included in the program, its `init()` function will be called
    during program initialization, and the authenticator type it provides will be
    registered.
  prefs: []
  type: TYPE_NORMAL
- en: Defining interfaces where you use them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structural typing allows you to define an interface when you need to use one,
    as opposed to pre-defining an exported interface. This is sometimes confused with
    “duck-typing” (if something walks like a duck and talks like a duck, it is a duck).
    The difference is that duck-typing refers to determining data type compatibility
    by looking at the subset of a type’s structure at runtimes, whereas structural
    typing refers to looking at the structure of a type at compile time. This recipe
    shows how you can define interfaces as you need them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say you have code that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to write a function that will operate on the options of a variable
    of type `A` or `B` (or any type that has options), you can simply define an interface
    right there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember, Go uses structural typing. So, you can create an interface specifying
    a set of methods, and any data type declaring those methods will automatically
    implement that interface. Thus, you can create such interfaces ad hoc, and write
    functions that take instances of those interfaces to work with a potentially large
    number of data types.
  prefs: []
  type: TYPE_NORMAL
- en: If you used a nominative language, you would have had to specify that those
    types implement your interface. Not so in Go.
  prefs: []
  type: TYPE_NORMAL
- en: That also means that if you have an interface `A` and another interface `B`
    such that `A` declares the same methods as `B`, then any type that implements
    `A` also implements `B`. In other words, if you cannot import an interface because
    it is in a package that will cause a circular dependency if imported, or if that
    interface is not exported by that package, you can simply define an equivalent
    interface in your current package.
  prefs: []
  type: TYPE_NORMAL
- en: Using a function as an interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you might encounter a situation where you have a function when an
    interface is needed. This recipe shows how you can define a new function data
    type that also implements an interface.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to implement a single-method interface without any data elements,
    you can define a new type based on an empty struct and declare a method for that
    type to implement that interface. Alternatively, you can simply use the function
    itself as an implementation of that interface. The following excerpt is from the
    standard library `net/http` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can use functions of the `HandlerFunc` type whenever an implementation
    of the `Handler` interface is needed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Go type system treats function types as any other defined type. Thus, you
    can declare methods for a function type. When you declare methods for a function
    type, the function type automatically implements all the interfaces that define
    all or some of those methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine this statement with an example. We can declare a new empty type
    as an implementation of the `Handler` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With this declaration, you can use instances of `MyHandler` wherever a `Handler`
    is required. However, observe that `MyHandler` has no data elements and only one
    method. So instead, we define a function type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type MyHandler func(ResponseWriter,*Request)`'
  prefs: []
  type: TYPE_NORMAL
- en: Now `MyHandler` is a new named type. This is not that much different from declaring
    `MyHandler` as a struct, but in this case, `MyHandler` is a function with a fixed
    signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `MyHandler` is a named type, we can define methods for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since `MyHandler` now defined `ServeHTTP` method, it implements the `Handler`
    interface. However, `MyHandler` is a function type, so `h` is actually a function
    that has the same signature as `ServeHTTP`. Due to that, the `h(w,r)` call works,
    and `MyHandler` can be used in places where a `Handler` is required.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering capabilities of data types at runtime – testing "implements" relationship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interface provides a way to call the methods of an underlying data object.
    If the same interface is implemented by many different types, you can use a function
    to manipulate diverse data types by simply using their common interface. However,
    many times, you need to access the underlying object stored in an interface. Go
    provides several mechanisms to achieve that. We will look at `type-assertion`
    and `type-switch`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use interfaces and type assertions to discover different methods a type provides.
    Remember that an interface is a method set. A type that implements the methods
    given in an interface automatically implements that interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following patterns to determine whether a data type has a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type assertions have two forms. The following form tests if an `intf` interface
    variable contains a concrete value of the `concreteValue` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value, ok:=intf.(concreteValue)`'
  prefs: []
  type: TYPE_NORMAL
- en: If the interface contains a value of that type, then `value` now has that value,
    and `ok` becomes `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second form tests whether the concrete value contained within the `intf`
    interface also implements the `otherIntf` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value, ok:=intf.(otherIntf)`'
  prefs: []
  type: TYPE_NORMAL
- en: If the value contained in `intf` also has the methods declared by `otherIntf`,
    then `value` is now an interface value of the `otherIntf` type containing the
    same concrete value as `intf`, and `ok` is set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Using this second form, you can test whether an interface variable implements
    the methods you need.
  prefs: []
  type: TYPE_NORMAL
- en: You may think you can do the same thing using reflection. Reflection is a method
    for discovering the names of fields and methods of types at runtime. It is not
    a performant or easy method to check such type equivalences.
  prefs: []
  type: TYPE_NORMAL
- en: Testing whether an interface value is one of the known types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A type-switch is used to test whether an interface value is a known concrete
    type, or whether it implements a certain interface. This recipe shows how it can
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a type-switch instead of a sequence of type assertions if you need to check
    an interface against multiple types.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example uses an `interface{}` to add two values. The values can
    either both be `int`, or both `float64`. The function also provides a way to override
    the addition behavior: if the value has a compatible `Add` method, it calls that
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note the way the type switch is used to extract the value contained in the interface
    if the case matches. This only works if the case lists a single type, and if the
    case is not the `default` case. For those cases, the variable is simply not defined
    and you work with the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring a type implements an interface during development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the development stages of a project, interface types may change quickly
    by adding new methods, or modifying existing method signatures by changing argument
    types or return types. How can developers make sure certain implementations of
    those interfaces are not broken by those changes?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say your team defined the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also say that you implemented that interface with the following struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'However, later in the development, it turned out not all cars can move successfully,
    so the signature of the interface changes to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With this change, `RaceCar` no longer implements `Car`. Many times this error
    will be caught at compile time, but not always. For instance, if instances of
    `*RaceCar` are passed to functions that require `any`, the compilation will succeed,
    but a runtime panic will be raised if that argument is converted to a `Car` or
    `*RaceCar` via type assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s say that you declare the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Any modification to the `Car` interface that makes `*RaceCar` no longer implement
    the `Car` interface will be a compile error.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in general: declare a blank variable with the interface type, and assign
    it to the concrete type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If there are changes that cause the type to no longer implement that interface,
    a compile error will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding whether to use a pointer receiver or value receiver for methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we’ll explore how to choose between a pointer receiver and a
    value receiver for methods.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In general, use one kind, not both. There are two reasons for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Consistency throughout the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixing value and pointer receivers can result in data races.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a method modifies the receiver object, use a pointer receiver. If a method
    does not modify the receiver object, or if the method relies on getting a copy
    of the receiver object, you can use a value receiver.
  prefs: []
  type: TYPE_NORMAL
- en: If you are implementing an immutable type, in most cases, you should use a value
    receiver.
  prefs: []
  type: TYPE_NORMAL
- en: If your structures are large, using a pointer receiver will reduce copy overhead.
    You can find different guidelines on whether or not a structure can be considered
    large. When in doubt, write a benchmark and measure.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For a type `T`, if you declare a method using a value receiver, that method
    is declared for both `T` and `*T`. The method gets a copy of the receiver, not
    a pointer to it, so any modifications performed on the receiver will not be reflected
    to the object used for calling the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following method returns a copy of the original object while
    modifying one field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'A value receiver creates a shallow copy of the original. If the receiver struct
    has maps, slices, or pointers to other objects, only the map headers, slice headers,
    or pointers will be copied, not the contents of the pointed object. That means
    that even though the method gets a value receiver in the following example, changes
    to the map are reflected in both the original and the copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful about how this affects slice operations. A slice is a triple `(pointer,
    len, cap)`, and that is what’s copied when you pass a value receiver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'A pointer receiver is more straightforward to work with. The method always
    gets a pointer to the object it is called with. In the preceding example, declaring
    the `add` method with a pointer receiver behaves as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of this section, I also mentioned that mixing pointer and value
    receivers causes a data race. Here is how it happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that a data race happens when a goroutine reads from a variable that
    is being concurrently modified by another. Consider the following example where
    the `Version` method uses a value receiver that causes a copy of `T` to be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The act of calling `t.Version()` creates a copy of the variable `t`, reading
    `t.X` concurrently as it is being modified, hence causing a race. This race is
    more obvious if `t.Version` reads from `t.X` explicitly. There is no guarantee
    that that read operation will see the effects of the write operation in the goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this context, a container is a data structure that holds many objects. The
    principles of this section can be applied to single objects as well. In other
    words, you can use the same idea when you have a single polymorphic variable or
    a struct field.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Define an interface containing the methods common to all data types that will
    be stored in the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare the container type using that interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put instances of actual objects into the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you retrieve objects from the container, you can either work with the object
    through the interface, or type-assert, get the actual type or another interface,
    and work with that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s a simple example that works with `Shape` objects. A `Shape` object is
    something that can be drawn on an image, and moved around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Shape has several implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `*Rectangle` and `*Circle` implement the `Shape` interface (note that
    `Rectangle` and `Circle` do not.) Now we can work with a slice of `Shapes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the `shapes` slice looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Slice of interface variables](img/B21961_05_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Slice of interface variables
  prefs: []
  type: TYPE_NORMAL
- en: 'Since every interface contains a pointer to the actual shape, it is possible
    to use the interface to call methods that modify the object as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Accessing parts of an object not directly exposed via the interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with interfaces, there are many occasions where you need to access
    the underlying object. This is achieved by type-assertion, that is, testing whether
    the value of an interface satisfies a given type, and if so, retrieving it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use type assertion or a type switch to test the type of the object contained
    in an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the embedding struct from the embedded struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In object-oriented languages such as Java or C++, there is the concept of an
    abstract method or virtual method, together with type inheritance. One effect
    of this feature is that if you call a method `M` of a base class `base`, then
    the method that runs at runtime is the implementation of `M` that is declared
    for the actual object at runtime. In other words, you can invoke a method that
    will be overridden by other declarations, and you just don’t know which method
    you are actually calling.
  prefs: []
  type: TYPE_NORMAL
- en: There are ways of doing the same thing in Go. This recipe shows how.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say you need to write a circular linked list data structure whose elements
    will be structs embedding a base struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The list itself is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So, the list points to the `first` node, which is an arbitrary node in the list,
    and every node points to the next one, with the last node pointing back to the
    first.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a `Node` interface that defines the mechanics of maintaining a list.
    Of course, the `Node` interface will be implemented by `ListNodeHeader`, and thus,
    by all the nodes of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The users of the list are supposed to embed `ListHeader` to implement a `list`
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now the hard part is to implement the `Node` interface. Let’s assume you would
    like to insert a `ByteSliceElement` in this list. Since `ByteSliceElement` embeds
    `ListNodeHeader`, it has all its methods and thus implements `Node`. However,
    we can’t write, for instance, an `Insert` method for `ListNodeHeader` without
    knowing the actual object being inserted.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way of doing this is by using the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: There are several things going on here. First, the `Insert` method gets two
    views of the node being inserted. If the node being inserted is a `*ByteSliceElement`,
    then it gets a `Node` version of this, and then it also gets the `*ListNodeHeader`
    embedded in `ByteSliceElement` as the receiver. Using this, it can adjust the
    members of the `ByteSliceElement` to point to the previous and next nodes.
  prefs: []
  type: TYPE_NORMAL
- en: However, it cannot access the `prev` and `next` members of a `Node`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One option is what is shown: declare an unexported method in the `Node` interface
    that will return the `ListNodeHeader` from a given node. Another option is to
    add `getNext/setNext` and `getPrev/setPrev` methods to the interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you have achieved two things: first, any user of this list structure outside
    this package *must* embed `ListNodeHeader` to implement a list node. There is
    an unexported method in the interface. There is no way to implement such an interface
    in a different package. The only way is to embed a struct that already implements
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: Second, you have a polymorphic container data structure whose mechanics are
    managed by a base struct.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether an interface is nil
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may wonder why this is even a problem. After all, don’t you just compare
    with nil? Not always.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interface contains two values: the type of the value contained in the interface,
    and a pointer to that value. An interface is nil if both of those are nil. There
    are cases where an interface may point to a nil value of a type other than nil,
    which makes the interface non-nil.'
  prefs: []
  type: TYPE_NORMAL
- en: You can’t check for this case easily. You have to avoid creating interfaces
    with nil values.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Avoid converting a pointer to a variable that can be nil to an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Check for nil interface values explicitly instead, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, use value errors instead of pointers. The following code avoids
    this problem altogether:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var x myerror`'
  prefs: []
  type: TYPE_NORMAL
- en: There is no chance of `x` being nil.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I explained earlier, an interface contains two values: type and value. What
    you are trying to avoid is creating an interface that contains a nil value with
    a non-nil type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the declaration that follows, the `y` interface is nil because both its
    type and its value are nil:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var y error`'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the following assignment, the type stored in `y` is now the type of `x`,
    and the value is nil. Thus, `y` is no longer nil:'
  prefs: []
  type: TYPE_NORMAL
- en: '`y=x`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This also applies to return from a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `f` function never returns nil.
  prefs: []
  type: TYPE_NORMAL
