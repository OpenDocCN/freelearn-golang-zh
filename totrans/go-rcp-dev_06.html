<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer015">
			<h1 id="_idParaDest-190" class="chapter-number"><a id="_idTextAnchor191"/>6</h1>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor192"/>Working with Generics</h1>
			<p>It happens often that you write a function that does some computation using values of a certain type (say, integers), but as the development progresses, you suddenly need to do the same thing but with another data type as well (say, <strong class="source-inline">float64</strong>). So you copy/paste the first function and modify it to have a different name and data types. Perhaps the most obvious and well-known examples of this situation are container data types such as maps and sets. You build a container type for integer values, then you do the same for it using strings, then for a struct, and <span class="No-Break">so on.</span></p>
			<p>Generics is a way of doing this code copy/paste at compile time using code templates. First, you create a function template (generic function) or a data type template (generic type). You instantiate a generic function or type by providing types. The compiler takes care of instantiating the template with the types you provided, and checks if the instantiated generic type or function is compilable with the types <span class="No-Break">you provided.</span></p>
			<p>In this chapter, you will learn how to use generic functions and data types for <span class="No-Break">common scenarios:</span></p>
			<ul>
				<li><span class="No-Break">Generic functions</span><ul><li>Writing a generic function that <span class="No-Break">adds numbers</span></li><li>Declaring constraints <span class="No-Break">as interfaces</span></li><li>Using generic functions as adapters <span class="No-Break">and accessors</span></li></ul></li>
				<li><span class="No-Break">Generic types</span><ul><li>Writing a <span class="No-Break">type-safe set</span></li><li>An ordered map -- using multiple <span class="No-Break">type parameters</span></li></ul></li>
			</ul>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor193"/>Generic functions</h1>
			<p>A generic function is a function template that takes types as parameters. The generic function must <a id="_idIndexMarker248"/>compile for all possible type assignments of its arguments. The types a generic function can accept are described by “type constraints.” We will learn about these concepts in <span class="No-Break">this section.</span></p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor194"/>Writing a generic function that adds numbers</h2>
			<p>A good introductory example for illustrating generics is a function that adds numbers. These <a id="_idIndexMarker249"/>numbers can be various types of integers or floating-point numbers. Here, we will study several recipes with <span class="No-Break">different capabilities.</span></p>
			<h3>How to do it...</h3>
			<p>A generic summation function that accepts <strong class="source-inline">int</strong> and <strong class="source-inline">float64</strong> numbers is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
func Sum[T int | float64](values ...T) T {
  var result T
  for _, x := range values {
    result += x
  }
  return result
}</pre>			<p>The construct <strong class="source-inline">[T int | float64]</strong> defines the type parameter for the <span class="No-Break"><strong class="source-inline">Sum</strong></span><span class="No-Break"> function:</span></p>
			<ul>
				<li><strong class="source-inline">T</strong> is the type name. For instance, if you instantiate the <strong class="source-inline">Sum</strong> function for <strong class="source-inline">int</strong>, then <strong class="source-inline">T</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break">.</span></li>
				<li>The <strong class="source-inline">int | float64</strong> expression is the type constraint for <strong class="source-inline">T</strong>. In this case, it means “<strong class="source-inline">T</strong> is either  <strong class="source-inline">int</strong> or <strong class="source-inline">float64</strong>.” The constraint tells the compiler that the <strong class="source-inline">Sum</strong> function can only be instantiated for <strong class="source-inline">int</strong> or <span class="No-Break"><strong class="source-inline">float64</strong></span><span class="No-Break"> values.</span></li>
			</ul>
			<p>As I explained before, a generic function is only a template. For instance, you cannot declare a function variable and assign it to <strong class="source-inline">Sum</strong>, because <strong class="source-inline">Sum</strong> is not a real function. The following statement instantiates the <strong class="source-inline">Sum</strong> generic function <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">int</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
fmt.Println(Sum[int](1,2,3))</pre>			<p>For many cases, the compiler can infer the type parameter, so the following is also valid. Since all the arguments are <strong class="source-inline">int</strong> values, the compiler infers that what is meant here <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">Sum[int]</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
fmt.Println(Sum(1,2,3))</pre>			<p>But in the following case, the instantiated function is <strong class="source-inline">Sum[float64]</strong>, and the arguments are interpreted as <span class="No-Break"><strong class="source-inline">float64</strong></span><span class="No-Break"> values:</span></p>
			<pre class="source-code">
fmt.Println(Sum[float64](1,2,3))</pre>			<p>The generic <a id="_idIndexMarker250"/>function must compile successfully for all possible <strong class="source-inline">T</strong>. In this case, <strong class="source-inline">T</strong> can be an <strong class="source-inline">int</strong> or a <strong class="source-inline">float64</strong>, so the function body must be valid for <strong class="source-inline">T</strong> being an <strong class="source-inline">int</strong> and <strong class="source-inline">T</strong> being a <strong class="source-inline">float64</strong>. The type constraints allow the compiler to produce meaningful compile-time errors. For example, the <strong class="source-inline">[T int | float64 | big.Int]</strong> constraint does not compile, because <strong class="source-inline">result+=x</strong> does not compile <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">big.Int</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">Sum</strong> function will not work for types derived from <strong class="source-inline">int</strong> or <strong class="source-inline">float64</strong>, <span class="No-Break">for instance:</span></p>
			<pre class="source-code">
type ID int</pre>			<p>Even though <strong class="source-inline">ID</strong> is an <strong class="source-inline">int</strong>, <strong class="source-inline">Sum[ID]</strong> will result in a compile error, because <strong class="source-inline">ID</strong> is a new type. To include all types derived from an <strong class="source-inline">int</strong>, use <strong class="source-inline">~int</strong> in the constraint – <span class="No-Break">for example:</span></p>
			<pre class="source-code">
func Sum[T ~int | ~float64](values ...T) T{...}</pre>			<p>This declaration will handle all types derived from <strong class="source-inline">int</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">float64</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor195"/>Declaring constraints as interfaces</h2>
			<p>It is not <a id="_idIndexMarker251"/>practical to keep repeating constraints when you declare new functions. Instead, you can define them in an interface as a type list or as a <span class="No-Break">method list.</span></p>
			<h3>How to do it...</h3>
			<p>A Go interface specifies a method set. Go generics implementation extends this definition so that interfaces define type sets when used as constraints. This requires some changes to accommodate basic types because basic types (such as <strong class="source-inline">int</strong>) do not have methods. So there are two types of syntax when it comes to interfaces <span class="No-Break">as constraints:</span></p>
			<ol>
				<li>Type lists specify the list of types acceptable in place of a type parameter. For example, the following <strong class="source-inline">UnsignedInteger</strong> constraint accepts all unsigned integer types and all types derived from <span class="No-Break">unsigned integers:</span><pre class="source-code">
type UnsignedInteger interface {
  ~uint8 | ~uint16 | ~uint32 | ~uint64
}</pre></li>				<li>Method <a id="_idIndexMarker252"/>sets specify the methods that must be implemented by types that are acceptable. The following <strong class="source-inline">Stringer</strong> constraint accepts all types that have the <strong class="source-inline">String() </strong><span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break"> method:</span><pre class="source-code">
type Stringer interface {
  String() string
}</pre></li>			</ol>
			<p>These constraints can be combined. For instance, the following <strong class="source-inline">UnsignedIntegerStringer</strong> constraint accepts types that are derived from an unsigned integer type, and that have the <strong class="source-inline">String() </strong><span class="No-Break"><strong class="source-inline">string</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
type UnsignedIntegerString interface {
  UnsignedInteger
  Stringer
}</pre>			<p>The <strong class="source-inline">Stringer</strong> interface can <a id="_idIndexMarker253"/>both be used as a constraint and as an interface. The <strong class="source-inline">UnsignedInteger</strong> and <strong class="source-inline">UnsignedIntegerString</strong> interfaces can only be used <span class="No-Break">as constraints.</span></p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor196"/>Using generic functions as accessors and adapters</h2>
			<p>Generic <a id="_idIndexMarker254"/>functions offer practical solutions for <a id="_idIndexMarker255"/>type-safe accessors and type adapters. For instance, initializing an <strong class="source-inline">*int</strong> variable with a constant value requires declaring a temporary value, which can be simplified by a generic function. This recipe includes several such accessors <span class="No-Break">and adapters.</span></p>
			<h3>How to do it...</h3>
			<p>This generic function makes a pointer from <span class="No-Break">arbitrary values:</span></p>
			<pre class="source-code">
func ToPtr[T any](value T) *T {
  return &amp;value
}</pre>			<p>This can be used to initialize pointers without a <span class="No-Break">temporary variable:</span></p>
			<pre class="source-code">
type UpdateRequest struct {
  Name *string
  ...
}
...
request:=UpdateRequest {
  Name:ToPtr("test"),
}</pre>			<p>Similarly, this generic function makes a slice from <span class="No-Break">arbitrary values:</span></p>
			<pre class="source-code">
func ToSlice[T any](value T) []T {
        return []T{value}
}
func main() {
  fmt.Println(ToSlice(1))
  // Prints an int slice: [1]
}</pre>			<p>The following generic function returns the last element of <span class="No-Break">a slice:</span></p>
			<pre class="source-code">
func Last[T any](slice []T) (T, bool) {
  if len(slice) == 0 {
    var zero T
    return zero, false
  }
  return slice[len(slice)-1], true
}</pre>			<p>It returns <strong class="source-inline">false</strong> if the slice <span class="No-Break">is empty.</span></p>
			<p>The following <a id="_idIndexMarker256"/>generic function can be used <a id="_idIndexMarker257"/>to adapt functions that return a value and an error to be used in contexts that accept only the value. The function panics if there is <span class="No-Break">an error:</span></p>
			<pre class="source-code">
func Must[T any](value T, err error) T {
  if err != nil {
    panic(err)
  }
  return value
}</pre>			<p>This adapts the <strong class="source-inline">f() (T, error)</strong> function into <span class="No-Break"><strong class="source-inline">Must(f()) T</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor197"/>Returning a zero value from a generic function</h2>
			<p>As I said <a id="_idIndexMarker258"/>before, a generic function must compile for all possible types allowed by the type constraints. This may cause trouble when creating a <span class="No-Break">zero value.</span></p>
			<h3>How to do it...</h3>
			<p>To create a zero value of a parameterized type, simply declare <span class="No-Break">a variable:</span></p>
			<pre class="source-code">
func Search[T []E, E comparable](slice T,value E) (E, bool) {
  for _,v:=range slice {
    if v==value {
      return v,true
    }
  }
  // Declare a zero value like this
  var zero E
  return zero, false
}</pre>			<h2 id="_idParaDest-197"><a id="_idTextAnchor198"/>Using type assertion on generic arguments</h2>
			<p>Sometimes you need to do something different based on the type of a value in a generic function. That <a id="_idIndexMarker259"/>requires a type assertion or a type switch – both work for interfaces. However, there is no guarantee that the function will be instantiated for an interface. This recipe shows how you can <span class="No-Break">achieve this.</span></p>
			<h3>How to do it...</h3>
			<p>Let’s say you have a generic function that treats <span class="No-Break">integers differently:</span></p>
			<pre class="source-code">
func Print[T any](value T) {
  // The following does not work because value is not necessarily an 
  // interface{}.
  if intValue, ok:=value.(int); ok {
    ...
  } else {
    ...
  }
}</pre>			<p>To make <a id="_idIndexMarker260"/>this work, you have to make sure the <strong class="source-inline">value</strong> is <span class="No-Break">an interface:</span></p>
			<pre class="source-code">
func Print[T any](value T) {
  // Convert value to an interface
  valueIntf := any{value)
  if intValue, ok:=valueIntf.(int); ok {
    // Value is an integer
  } else {
    // Value is not an integer
  }
}</pre>			<p>The same idea works for a <span class="No-Break">type switch:</span></p>
			<pre class="source-code">
func Print[T any](value T) {
  switch v:=any(value).(type) {
  case int:
    // Value is an integer
  default;
    // Value is not an integer
  }
}</pre>			<h1 id="_idParaDest-198"><a id="_idTextAnchor199"/>Generic types</h1>
			<p>The generic function syntax extends naturally to generic types. A generic type also has the same type <a id="_idIndexMarker261"/>parameters and constraints, and every method of that type also implicitly has the same parameters as the <span class="No-Break">type itself.</span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor200"/>Writing a type-safe set</h2>
			<p>A type-safe <a id="_idIndexMarker262"/>set can be implemented using a <strong class="source-inline">map[T]struct{}</strong>. One thing <a id="_idIndexMarker263"/>to be careful about is that <strong class="source-inline">T</strong> cannot be any type. Only comparable types can be map keys, and there is a predefined constraint to address <span class="No-Break">this need.</span></p>
			<h3>How to do it...</h3>
			<ol>
				<li>Declare a parameterized set type <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">map</strong></span><span class="No-Break">:</span><pre class="source-code">
type Set[T comparable] map[T]struct{}</pre></li>				<li>Declare the methods of the type using the same type parameter(s). When declaring methods, you have to refer to the type parameters by <span class="No-Break">name only:</span></li>
			</ol>
			<pre class="source-code">
// Has returns if the set has the given value
func (s Set[T]) Has(value T) bool {
     _, exists := s[value]
     return exists
}
// Add adds values to s
func (s Set[T]) Add(values ...T) {
     for _, v := range values {
          s[v] = struct{}{}
     }
}
// Remove removes values from s
func (s Set[T]) Remove(values ...T) {
     for _, v := range values {
          delete(s, v)
     }
}</pre>			<ol>
				<li value="3">If necessary, create <a id="_idIndexMarker264"/>a generic constructor for the <span class="No-Break">new type:</span></li>
			</ol>
			<pre class="source-code">
// NewSet creates a new set
func NewSet[T comparable]() Set[T] {
     return make(Set[T])
}</pre>			<ol>
				<li value="4">Instantiate <a id="_idIndexMarker265"/>the type to <span class="No-Break">use it:</span></li>
			</ol>
			<pre class="source-code">
stringSet := NewSet[string]()</pre>			<p>Note the explicit instantiation of the <strong class="source-inline">NewSet</strong> function with the <strong class="source-inline">string</strong> type parameter. The compiler cannot infer what type you mean, so you have to spell out <strong class="source-inline">NewSet[string]()</strong>. Then the compiler instantiates the <strong class="source-inline">Set[string]</strong> type, which also instantiates all methods of <span class="No-Break">that type.</span></p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor201"/>An ordered map – using multiple type parameters</h2>
			<p>This implementation <a id="_idIndexMarker266"/>of an ordered map allows you to keep the order <a id="_idIndexMarker267"/>of elements added to a map using a slice combined with <span class="No-Break">a map.</span></p>
			<h3>How to do it...</h3>
			<ol>
				<li>Define a struct with two <span class="No-Break">type parameters:</span></li>
			</ol>
			<pre class="source-code">
type OrderedMap[Key comparable, Value any] struct {
     m     map[Key]Value
     slice []Key
}</pre>			<p>Since <strong class="source-inline">Key</strong> will be <a id="_idIndexMarker268"/>used as the map key, it has to be <strong class="source-inline">comparable</strong>. There are <a id="_idIndexMarker269"/>no constraints on the <span class="No-Break">value type.</span></p>
			<p>Define the methods for the type. The methods are now declared using both <strong class="source-inline">Key</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Value</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// Add key:value to the map
func (m *OrderedMap[Key, Value]) Add(key Key, value Value) {
     _, exists := m.m[key]
     if exists {
          m.m[key] = value
     } else {
          m.slice = append(m.slice, key)
          m.m[key] = value
     }
}
// ValueAt returns the value at the given index
func (m *OrderedMap[Key, Value]) ValueAt(index int) Value {
     return m.m[m.slice[index]]
}
// KeyAt returns the key at the given index
func (m *OrderedMap[Key, Value]) KeyAt(index int) Key {
     return m.slice[index]
}
// Get returns the value corresponding to the key, and whether or not
// key exists
func (m *OrderedMap[Key, Value]) Get(key Key) (Value, bool) {
     v, bool := m.m[key]
     return v, bool
}</pre>			<p class="callout-heading">Tip</p>
			<p class="callout">The type parameters <a id="_idIndexMarker270"/>for the receiver are matched by position, not name. In other words, you can define a method <span class="No-Break">as follows:</span></p>
			<p class="callout"><strong class="source-inline">func (m *OrderedMap[K, V]) ValueAt(index int) </strong><span class="No-Break"><strong class="source-inline">V {</strong></span></p>
			<p class="callout"><strong class="source-inline">     </strong><span class="No-Break"><strong class="source-inline">return m.m[m.slice[index]]</strong></span></p>
			<p class="callout"><strong class="source-inline">}</strong></p>
			<p>Here, <strong class="source-inline">K</strong> is for <strong class="source-inline">Key</strong>, and <strong class="source-inline">V</strong> is <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">Value</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li>Define a <a id="_idIndexMarker271"/>constructor <a id="_idIndexMarker272"/>generic function <span class="No-Break">if necessary:</span></li>
			</ol>
			<pre class="source-code">
func NewOrderedMap[Key comparable, Value any]() *OrderedMap[Key, Value] {
     return &amp;OrderedMap[Key, Value]{
          m:     make(map[Key]Value),
          slice: make([]Key, 0),
     }
}</pre>			<p class="callout-heading">Tip</p>
			<p class="callout">A constructor is <a id="_idIndexMarker273"/>necessary in this case because we want to initialize the map in the generic struct. It is tempting to check for a nil map every time you want to add something to the container. You have to choose between the convenience of having a container type whose zero value is ready to use versus the performance penalty you pay checking a nil map every time something <span class="No-Break">is added.</span></p>
		</div>
	</div></div></body></html>