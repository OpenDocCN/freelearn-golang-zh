["```go\nfunc Sum[T int | float64](values ...T) T {\n  var result T\n  for _, x := range values {\n    result += x\n  }\n  return result\n}\n```", "```go\nfmt.Println(Sum[int](1,2,3))\n```", "```go\nfmt.Println(Sum(1,2,3))\n```", "```go\nfmt.Println(Sum[float64](1,2,3))\n```", "```go\ntype ID int\n```", "```go\nfunc Sum[T ~int | ~float64](values ...T) T{...}\n```", "```go\n    type UnsignedInteger interface {\n      ~uint8 | ~uint16 | ~uint32 | ~uint64\n    }\n    ```", "```go\n    type Stringer interface {\n      String() string\n    }\n    ```", "```go\ntype UnsignedIntegerString interface {\n  UnsignedInteger\n  Stringer\n}\n```", "```go\nfunc ToPtr[T any](value T) *T {\n  return &value\n}\n```", "```go\ntype UpdateRequest struct {\n  Name *string\n  ...\n}\n...\nrequest:=UpdateRequest {\n  Name:ToPtr(\"test\"),\n}\n```", "```go\nfunc ToSlice[T any](value T) []T {\n        return []T{value}\n}\nfunc main() {\n  fmt.Println(ToSlice(1))\n  // Prints an int slice: [1]\n}\n```", "```go\nfunc Last[T any](slice []T) (T, bool) {\n  if len(slice) == 0 {\n    var zero T\n    return zero, false\n  }\n  return slice[len(slice)-1], true\n}\n```", "```go\nfunc Must[T any](value T, err error) T {\n  if err != nil {\n    panic(err)\n  }\n  return value\n}\n```", "```go\nfunc Search[T []E, E comparable](slice T,value E) (E, bool) {\n  for _,v:=range slice {\n    if v==value {\n      return v,true\n    }\n  }\n  // Declare a zero value like this\n  var zero E\n  return zero, false\n}\n```", "```go\nfunc Print[T any](value T) {\n  // The following does not work because value is not necessarily an \n  // interface{}.\n  if intValue, ok:=value.(int); ok {\n    ...\n  } else {\n    ...\n  }\n}\n```", "```go\nfunc Print[T any](value T) {\n  // Convert value to an interface\n  valueIntf := any{value)\n  if intValue, ok:=valueIntf.(int); ok {\n    // Value is an integer\n  } else {\n    // Value is not an integer\n  }\n}\n```", "```go\nfunc Print[T any](value T) {\n  switch v:=any(value).(type) {\n  case int:\n    // Value is an integer\n  default;\n    // Value is not an integer\n  }\n}\n```", "```go\n    type Set[T comparable] map[T]struct{}\n    ```", "```go\n// Has returns if the set has the given value\nfunc (s Set[T]) Has(value T) bool {\n     _, exists := s[value]\n     return exists\n}\n// Add adds values to s\nfunc (s Set[T]) Add(values ...T) {\n     for _, v := range values {\n          s[v] = struct{}{}\n     }\n}\n// Remove removes values from s\nfunc (s Set[T]) Remove(values ...T) {\n     for _, v := range values {\n          delete(s, v)\n     }\n}\n```", "```go\n// NewSet creates a new set\nfunc NewSet[T comparable]() Set[T] {\n     return make(Set[T])\n}\n```", "```go\nstringSet := NewSet[string]()\n```", "```go\ntype OrderedMap[Key comparable, Value any] struct {\n     m     map[Key]Value\n     slice []Key\n}\n```", "```go\n// Add key:value to the map\nfunc (m *OrderedMap[Key, Value]) Add(key Key, value Value) {\n     _, exists := m.m[key]\n     if exists {\n          m.m[key] = value\n     } else {\n          m.slice = append(m.slice, key)\n          m.m[key] = value\n     }\n}\n// ValueAt returns the value at the given index\nfunc (m *OrderedMap[Key, Value]) ValueAt(index int) Value {\n     return m.m[m.slice[index]]\n}\n// KeyAt returns the key at the given index\nfunc (m *OrderedMap[Key, Value]) KeyAt(index int) Key {\n     return m.slice[index]\n}\n// Get returns the value corresponding to the key, and whether or not\n// key exists\nfunc (m *OrderedMap[Key, Value]) Get(key Key) (Value, bool) {\n     v, bool := m.m[key]\n     return v, bool\n}\n```", "```go\nfunc NewOrderedMap[Key comparable, Value any]() *OrderedMap[Key, Value] {\n     return &OrderedMap[Key, Value]{\n          m:     make(map[Key]Value),\n          slice: make([]Key, 0),\n     }\n}\n```"]