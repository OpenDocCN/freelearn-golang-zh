- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Generics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It happens often that you write a function that does some computation using
    values of a certain type (say, integers), but as the development progresses, you
    suddenly need to do the same thing but with another data type as well (say, `float64`).
    So you copy/paste the first function and modify it to have a different name and
    data types. Perhaps the most obvious and well-known examples of this situation
    are container data types such as maps and sets. You build a container type for
    integer values, then you do the same for it using strings, then for a struct,
    and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Generics is a way of doing this code copy/paste at compile time using code templates.
    First, you create a function template (generic function) or a data type template
    (generic type). You instantiate a generic function or type by providing types.
    The compiler takes care of instantiating the template with the types you provided,
    and checks if the instantiated generic type or function is compilable with the
    types you provided.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to use generic functions and data types
    for common scenarios:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Generic functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a generic function that adds numbers
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring constraints as interfaces
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generic functions as adapters and accessors
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic types
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a type-safe set
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An ordered map -- using multiple type parameters
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic functions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A generic function is a function template that takes types as parameters. The
    generic function must compile for all possible type assignments of its arguments.
    The types a generic function can accept are described by “type constraints.” We
    will learn about these concepts in this section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Writing a generic function that adds numbers
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good introductory example for illustrating generics is a function that adds
    numbers. These numbers can be various types of integers or floating-point numbers.
    Here, we will study several recipes with different capabilities.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A generic summation function that accepts `int` and `float64` numbers is as
    follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The construct `[T int | float64]` defines the type parameter for the `Sum`
    function:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '`T` is the type name. For instance, if you instantiate the `Sum` function for
    `int`, then `T` is `int`.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `int | float64` expression is the type constraint for `T`. In this case,
    it means “`T` is either `int` or `float64`.” The constraint tells the compiler
    that the `Sum` function can only be instantiated for `int` or `float64` values.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As I explained before, a generic function is only a template. For instance,
    you cannot declare a function variable and assign it to `Sum`, because `Sum` is
    not a real function. The following statement instantiates the `Sum` generic function
    for `int`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For many cases, the compiler can infer the type parameter, so the following
    is also valid. Since all the arguments are `int` values, the compiler infers that
    what is meant here is `Sum[int]`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But in the following case, the instantiated function is `Sum[float64]`, and
    the arguments are interpreted as `float64` values:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但在以下情况下，实例化的函数是`Sum[float64]`，并且参数被解释为`float64`值：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The generic function must compile successfully for all possible `T`. In this
    case, `T` can be an `int` or a `float64`, so the function body must be valid for
    `T` being an `int` and `T` being a `float64`. The type constraints allow the compiler
    to produce meaningful compile-time errors. For example, the `[T int | float64
    | big.Int]` constraint does not compile, because `result+=x` does not compile
    for `big.Int`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型函数必须对所有可能的`T`成功编译。在这种情况下，`T`可以是`int`或`float64`，因此函数体必须对`T`是`int`和`T`是`float64`有效。类型约束允许编译器产生有意义的编译时错误。例如，`[T
    int | float64 | big.Int]`约束无法编译，因为`result+=x`对`big.Int`不起作用。
- en: 'The `Sum` function will not work for types derived from `int` or `float64`,
    for instance:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sum`函数对从`int`或`float64`派生的类型不起作用，例如：'
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Even though `ID` is an `int`, `Sum[ID]` will result in a compile error, because
    `ID` is a new type. To include all types derived from an `int`, use `~int` in
    the constraint – for example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`ID`是`int`类型，`Sum[ID]`也会导致编译错误，因为`ID`是一个新类型。要包含从`int`派生的所有类型，在约束中使用`~int`
    - 例如：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This declaration will handle all types derived from `int` and `float64`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此声明将处理从`int`和`float64`派生的所有类型。
- en: Declaring constraints as interfaces
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将约束声明为接口
- en: It is not practical to keep repeating constraints when you declare new functions.
    Instead, you can define them in an interface as a type list or as a method list.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明新函数时重复约束并不实用。相反，您可以在接口中定义它们，作为类型列表或方法列表。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'A Go interface specifies a method set. Go generics implementation extends this
    definition so that interfaces define type sets when used as constraints. This
    requires some changes to accommodate basic types because basic types (such as
    `int`) do not have methods. So there are two types of syntax when it comes to
    interfaces as constraints:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Go接口指定了一个方法集。Go泛型实现扩展了此定义，以便当用作约束时，接口定义类型集。这需要对基本类型进行一些修改，因为基本类型（如`int`）没有方法。因此，在接口作为约束时，有两种语法：
- en: 'Type lists specify the list of types acceptable in place of a type parameter.
    For example, the following `UnsignedInteger` constraint accepts all unsigned integer
    types and all types derived from unsigned integers:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型列表指定了可以替代类型参数的类型列表。例如，以下`UnsignedInteger`约束接受所有无符号整数类型以及从无符号整数派生的所有类型：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Method sets specify the methods that must be implemented by types that are
    acceptable. The following `Stringer` constraint accepts all types that have the
    `String()` `string` method:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法集指定了可接受类型必须实现的方法。以下`Stringer`约束接受所有具有`String()` `string`方法的类型：
- en: '[PRE7]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'These constraints can be combined. For instance, the following `UnsignedIntegerStringer`
    constraint accepts types that are derived from an unsigned integer type, and that
    have the `String()` `string` method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约束可以组合。例如，以下`UnsignedIntegerStringer`约束接受从无符号整数类型派生的类型，并且具有`String()` `string`方法：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Stringer` interface can both be used as a constraint and as an interface.
    The `UnsignedInteger` and `UnsignedIntegerString` interfaces can only be used
    as constraints.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stringer`接口既可以用作约束，也可以用作接口。`UnsignedInteger`和`UnsignedIntegerString`接口只能用作约束。'
- en: Using generic functions as accessors and adapters
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将泛型函数用作访问器和适配器
- en: Generic functions offer practical solutions for type-safe accessors and type
    adapters. For instance, initializing an `*int` variable with a constant value
    requires declaring a temporary value, which can be simplified by a generic function.
    This recipe includes several such accessors and adapters.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型函数为类型安全的访问器和类型适配器提供了实用解决方案。例如，使用常量值初始化`*int`变量需要声明一个临时值，这可以通过泛型函数简化。这个配方包括几个这样的访问器和适配器。
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'This generic function makes a pointer from arbitrary values:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此泛型函数将任意值转换为指针：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This can be used to initialize pointers without a temporary variable:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用来初始化指针而不使用临时变量：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similarly, this generic function makes a slice from arbitrary values:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这个泛型函数可以从任意值创建切片：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following generic function returns the last element of a slice:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下泛型函数返回切片的最后一个元素：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It returns `false` if the slice is empty.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果切片为空，则返回`false`。
- en: 'The following generic function can be used to adapt functions that return a
    value and an error to be used in contexts that accept only the value. The function
    panics if there is an error:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下泛型函数可以用来适配返回值和错误的函数，以便在只接受值的上下文中使用。如果存在错误，函数会引发恐慌：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This adapts the `f() (T, error)` function into `Must(f()) T`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `f() (T, error)` 函数适配为 `Must(f()) T`。
- en: Returning a zero value from a generic function
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从泛型函数返回零值
- en: As I said before, a generic function must compile for all possible types allowed
    by the type constraints. This may cause trouble when creating a zero value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所说，一个泛型函数必须对所有允许的类型约束进行编译。这可能在创建零值时引起麻烦。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To create a zero value of a parameterized type, simply declare a variable:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建参数化类型的零值，只需声明一个变量：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using type assertion on generic arguments
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在泛型参数上使用类型断言
- en: Sometimes you need to do something different based on the type of a value in
    a generic function. That requires a type assertion or a type switch – both work
    for interfaces. However, there is no guarantee that the function will be instantiated
    for an interface. This recipe shows how you can achieve this.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，根据泛型函数中值的类型，你需要做不同的事情。这需要类型断言或类型选择器 – 两者都适用于接口。然而，没有保证函数会为接口实例化。这个配方展示了你如何实现这一点。
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let’s say you have a generic function that treats integers differently:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个处理整数不同的泛型函数：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To make this work, you have to make sure the `value` is an interface:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这生效，你必须确保 `value` 是一个接口：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The same idea works for a type switch:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的想法也适用于类型选择器：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Generic types
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型
- en: The generic function syntax extends naturally to generic types. A generic type
    also has the same type parameters and constraints, and every method of that type
    also implicitly has the same parameters as the type itself.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型函数的语法自然扩展到泛型类型。泛型类型也有相同的类型参数和约束，并且该类型的每个方法也隐式具有与类型本身相同的参数。
- en: Writing a type-safe set
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写类型安全的集合
- en: A type-safe set can be implemented using a `map[T]struct{}`. One thing to be
    careful about is that `T` cannot be any type. Only comparable types can be map
    keys, and there is a predefined constraint to address this need.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `map[T]struct{}` 实现一个类型安全的集合。需要注意的一件事是 `T` 不能是任何类型。只有可比较的类型可以作为映射键，并且有一个预定义的约束来满足这一需求。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Declare a parameterized set type using `map`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `map` 声明一个参数化集合类型：
- en: '[PRE18]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Declare the methods of the type using the same type parameter(s). When declaring
    methods, you have to refer to the type parameters by name only:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的类型参数（s）声明类型的函数。在声明方法时，你必须通过名称引用类型参数：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If necessary, create a generic constructor for the new type:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，为新的类型创建一个泛型构造函数：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Instantiate the type to use it:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化类型以使用它：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note the explicit instantiation of the `NewSet` function with the `string` type
    parameter. The compiler cannot infer what type you mean, so you have to spell
    out `NewSet[string]()`. Then the compiler instantiates the `Set[string]` type,
    which also instantiates all methods of that type.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `NewSet` 函数使用 `string` 类型参数的显式实例化。编译器无法推断你指的是什么类型，所以你必须明确写出 `NewSet[string]()`。然后编译器实例化
    `Set[string]` 类型，这也实例化了该类型的所有方法。
- en: An ordered map – using multiple type parameters
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有序映射 – 使用多个类型参数
- en: This implementation of an ordered map allows you to keep the order of elements
    added to a map using a slice combined with a map.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这种有序映射的实现允许你使用切片与映射的组合来保持添加到映射中的元素的顺序。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Define a struct with two type parameters:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含两个类型参数的结构体：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since `Key` will be used as the map key, it has to be `comparable`. There are
    no constraints on the value type.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Key` 将用作映射键，它必须是 `comparable` 的。对值类型没有约束。
- en: 'Define the methods for the type. The methods are now declared using both `Key`
    and `Value`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为类型定义方法。现在方法使用 `Key` 和 `Value` 同时声明：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The type parameters for the receiver are matched by position, not name. In
    other words, you can define a method as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接收器的类型参数是通过位置匹配的，而不是通过名称。换句话说，你可以这样定义一个方法：
- en: '`func (m *OrderedMap[K, V]) ValueAt(index int)` `V {`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`func (m *OrderedMap[K, V]) ValueAt(index int) V {`'
- en: '`return m.m[m.slice[index]]`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`return m.m[m.slice[index]]`'
- en: '`}`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: Here, `K` is for `Key`, and `V` is for `Value`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`K` 代表 `Key`，而 `V` 代表 `Value`。
- en: 'Define a constructor generic function if necessary:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，定义一个构造函数泛型函数：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: A constructor is necessary in this case because we want to initialize the map
    in the generic struct. It is tempting to check for a nil map every time you want
    to add something to the container. You have to choose between the convenience
    of having a container type whose zero value is ready to use versus the performance
    penalty you pay checking a nil map every time something is added.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下需要一个构造函数，因为我们想在泛型结构体中初始化映射。每次想要向容器中添加内容时检查空映射很有诱惑力。你必须在拥有零值即可使用的容器类型带来的便利和每次添加内容时检查空映射所付出的性能代价之间做出选择。
