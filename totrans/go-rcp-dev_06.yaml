- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It happens often that you write a function that does some computation using
    values of a certain type (say, integers), but as the development progresses, you
    suddenly need to do the same thing but with another data type as well (say, `float64`).
    So you copy/paste the first function and modify it to have a different name and
    data types. Perhaps the most obvious and well-known examples of this situation
    are container data types such as maps and sets. You build a container type for
    integer values, then you do the same for it using strings, then for a struct,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Generics is a way of doing this code copy/paste at compile time using code templates.
    First, you create a function template (generic function) or a data type template
    (generic type). You instantiate a generic function or type by providing types.
    The compiler takes care of instantiating the template with the types you provided,
    and checks if the instantiated generic type or function is compilable with the
    types you provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to use generic functions and data types
    for common scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Generic functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a generic function that adds numbers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring constraints as interfaces
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generic functions as adapters and accessors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a type-safe set
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An ordered map -- using multiple type parameters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A generic function is a function template that takes types as parameters. The
    generic function must compile for all possible type assignments of its arguments.
    The types a generic function can accept are described by “type constraints.” We
    will learn about these concepts in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a generic function that adds numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good introductory example for illustrating generics is a function that adds
    numbers. These numbers can be various types of integers or floating-point numbers.
    Here, we will study several recipes with different capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A generic summation function that accepts `int` and `float64` numbers is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The construct `[T int | float64]` defines the type parameter for the `Sum`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`T` is the type name. For instance, if you instantiate the `Sum` function for
    `int`, then `T` is `int`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `int | float64` expression is the type constraint for `T`. In this case,
    it means “`T` is either `int` or `float64`.” The constraint tells the compiler
    that the `Sum` function can only be instantiated for `int` or `float64` values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As I explained before, a generic function is only a template. For instance,
    you cannot declare a function variable and assign it to `Sum`, because `Sum` is
    not a real function. The following statement instantiates the `Sum` generic function
    for `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For many cases, the compiler can infer the type parameter, so the following
    is also valid. Since all the arguments are `int` values, the compiler infers that
    what is meant here is `Sum[int]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'But in the following case, the instantiated function is `Sum[float64]`, and
    the arguments are interpreted as `float64` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The generic function must compile successfully for all possible `T`. In this
    case, `T` can be an `int` or a `float64`, so the function body must be valid for
    `T` being an `int` and `T` being a `float64`. The type constraints allow the compiler
    to produce meaningful compile-time errors. For example, the `[T int | float64
    | big.Int]` constraint does not compile, because `result+=x` does not compile
    for `big.Int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Sum` function will not work for types derived from `int` or `float64`,
    for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though `ID` is an `int`, `Sum[ID]` will result in a compile error, because
    `ID` is a new type. To include all types derived from an `int`, use `~int` in
    the constraint – for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This declaration will handle all types derived from `int` and `float64`.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring constraints as interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is not practical to keep repeating constraints when you declare new functions.
    Instead, you can define them in an interface as a type list or as a method list.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Go interface specifies a method set. Go generics implementation extends this
    definition so that interfaces define type sets when used as constraints. This
    requires some changes to accommodate basic types because basic types (such as
    `int`) do not have methods. So there are two types of syntax when it comes to
    interfaces as constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type lists specify the list of types acceptable in place of a type parameter.
    For example, the following `UnsignedInteger` constraint accepts all unsigned integer
    types and all types derived from unsigned integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Method sets specify the methods that must be implemented by types that are
    acceptable. The following `Stringer` constraint accepts all types that have the
    `String()` `string` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These constraints can be combined. For instance, the following `UnsignedIntegerStringer`
    constraint accepts types that are derived from an unsigned integer type, and that
    have the `String()` `string` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Stringer` interface can both be used as a constraint and as an interface.
    The `UnsignedInteger` and `UnsignedIntegerString` interfaces can only be used
    as constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Using generic functions as accessors and adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generic functions offer practical solutions for type-safe accessors and type
    adapters. For instance, initializing an `*int` variable with a constant value
    requires declaring a temporary value, which can be simplified by a generic function.
    This recipe includes several such accessors and adapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This generic function makes a pointer from arbitrary values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be used to initialize pointers without a temporary variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, this generic function makes a slice from arbitrary values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following generic function returns the last element of a slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It returns `false` if the slice is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following generic function can be used to adapt functions that return a
    value and an error to be used in contexts that accept only the value. The function
    panics if there is an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This adapts the `f() (T, error)` function into `Must(f()) T`.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a zero value from a generic function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I said before, a generic function must compile for all possible types allowed
    by the type constraints. This may cause trouble when creating a zero value.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a zero value of a parameterized type, simply declare a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using type assertion on generic arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you need to do something different based on the type of a value in
    a generic function. That requires a type assertion or a type switch – both work
    for interfaces. However, there is no guarantee that the function will be instantiated
    for an interface. This recipe shows how you can achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s say you have a generic function that treats integers differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this work, you have to make sure the `value` is an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The same idea works for a type switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Generic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The generic function syntax extends naturally to generic types. A generic type
    also has the same type parameters and constraints, and every method of that type
    also implicitly has the same parameters as the type itself.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a type-safe set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A type-safe set can be implemented using a `map[T]struct{}`. One thing to be
    careful about is that `T` cannot be any type. Only comparable types can be map
    keys, and there is a predefined constraint to address this need.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Declare a parameterized set type using `map`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the methods of the type using the same type parameter(s). When declaring
    methods, you have to refer to the type parameters by name only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If necessary, create a generic constructor for the new type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Instantiate the type to use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note the explicit instantiation of the `NewSet` function with the `string` type
    parameter. The compiler cannot infer what type you mean, so you have to spell
    out `NewSet[string]()`. Then the compiler instantiates the `Set[string]` type,
    which also instantiates all methods of that type.
  prefs: []
  type: TYPE_NORMAL
- en: An ordered map – using multiple type parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This implementation of an ordered map allows you to keep the order of elements
    added to a map using a slice combined with a map.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Define a struct with two type parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since `Key` will be used as the map key, it has to be `comparable`. There are
    no constraints on the value type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the methods for the type. The methods are now declared using both `Key`
    and `Value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The type parameters for the receiver are matched by position, not name. In
    other words, you can define a method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func (m *OrderedMap[K, V]) ValueAt(index int)` `V {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return m.m[m.slice[index]]`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `K` is for `Key`, and `V` is for `Value`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a constructor generic function if necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: A constructor is necessary in this case because we want to initialize the map
    in the generic struct. It is tempting to check for a nil map every time you want
    to add something to the container. You have to choose between the convenience
    of having a container type whose zero value is ready to use versus the performance
    penalty you pay checking a nil map every time something is added.
  prefs: []
  type: TYPE_NORMAL
