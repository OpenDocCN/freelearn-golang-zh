["```go\nNumber of threads per core * Number of cores per CPU * Number of CPUs\n```", "```go\nfunc f() {\n  // Do some work\n}\nfunc main() {\n  go f()\n  ...\n}\n```", "```go\nfunc f(i int) {\n  // Do some work\n}\nfunc main() {\n  var x int\n  go f(x)\n  ...\n}\n```", "```go\nfunc main() {\n  var x int\n  var y int\n  ...\n  go func(i int) {\n    if y > 0 {\n      // Do some work\n    }\n  }(x)\n  ...\n}\n```", "```go\n    wg := sync.WaitGroup{}\n    ```", "```go\n        wg.Add(1)\n        go func() {\n          defer wg.Done()\n          // Do work\n        }()\n        ```", "```go\n    wg.Wait()\n    ```", "```go\n    ch := make(chan string)\n    ```", "```go\n    go func() {\n      for _, str := range stringData {\n         // Send the string to the channel. This will block until\n         // another goroutine can receive from the channel.\n         ch <- str\n      }\n      // Close the channel when done. This is the way to signal the\n      // receiver goroutine that there is no more data available.\n      close(ch)\n    }()\n    ```", "```go\n    for str := range ch {\n      fmt.Println(str)\n    }\n    ```", "```go\n    ch := make(chan string)\n    ```", "```go\n    // Allocate results\n    results := make([]string,0)\n    // WaitGroup will be used later to wait for the listener \n    // goroutine to end\n    listenerWg := sync.WaitGroup{}\n    listenerWg.Add(1)\n    go func() {\n      defer listenerWg.Done()\n      // Collect results and store in a slice\n      for str:=range ch {\n        results=append(results,str)\n      }\n    }()\n    ```", "```go\n    wg := sync.WaitGroup{}\n    for _,input := range inputs {\n      wg.Add(1)\n      go func(data string) {\n        defer wg.Done()\n        ch <- processInput(data)\n      }(input)\n    }\n    ```", "```go\n    // Wait for all goroutines to end\n    wg.Wait()\n    // Close the channel to signal end of data\n    // This will signal the listener goroutine that no more data \n    // will be arriving via the channel\n    close(ch)\n    ```", "```go\n    listenerWg.Wait()\n    ```", "```go\n    resultCh := make(chan int)\n    ```", "```go\n    wg := sync.WaitGroup{}\n    ```", "```go\n    var inputs [][]int=[]int{...}\n    ...\n    for i:=range inputs {\n      wg.Add(1)\n      go func(data []int) {\n         defer wg.Done()\n         // Perform the computation\n         // computeResult takes a []int, and returns int\n         // Send the result to resultCh\n         resultCh <- computeResult(data)\n      }(inputs[i])\n    }\n    ```", "```go\n        go func() {\n          // Wait for the goroutines to end\n          wg.Wait()\n          // When all goroutines are done, close the channel\n          close(resultCh)\n        }()\n        // Create a slice to contain results of the computations\n        results:=make([]int,0)\n        // Collect the results from the `resultCh`\n        // The for-loop will terminate when resultCh is closed\n        for result:=range resultCh {\n          results=append(results,result)\n        }\n        ```", "```go\n        results:=make([]int,0)\n        // Create a new wait group just for the result collection \n        // goroutine\n        collectWg := sync.WaitGroup{}\n        // Add the collection goroutine to the waitgroup\n        collectWg.Add(1)\n        go func() {\n          // Announce the completion of this goroutine\n          defer collectWg.Done()\n          // Collect results. The for-loop will terminate when resultCh \n          // is closed.\n          for result:= range resultCh {\n            results=append(results,result)\n          }\n        }()\n        // Wait for the goroutines to end.\n        wg.Wait()\n        // Close the channel so the result collection goroutine can \n        // finish\n        close(resultCh)\n        // Now wait for the result collection goroutine to finish\n        collectWg.Wait()\n        // results slice is ready\n        ```", "```go\nch1:=make(chan int)\nch2:=make(chan int)\ngo func() {\n  ch1<-1\n}()\ngo func() {\n  ch2<-2\n}()\nselect {\ncase data1:= <- ch1:\n  fmt.Println(\"Read from channel 1: %v\", data1)\ncase data2:= <- ch2:\n  fmt.Println(\"Read from channel 2: %v\", data2)\n}\n```", "```go\n    done:=make(chan struct{})\n    ```", "```go\n    input := make(chan int)\n    ```", "```go\n    go func() {\n      for {\n        select {\n          case data:= <- input:\n            // Process data\n          case <-done:\n            // Done signal. Terminate\n            return\n         }\n      }\n    }()\n    ```", "```go\nclose(done)\n```", "```go\n    done:=make(chan struct{})\n    ```", "```go\n    go func() {\n      for {\n        select {\n          case <-done:\n            // Done signal. Terminate\n            return\n           default:\n             // Done signal is not sent. Continue\n         }\n         // Do work\n      }\n    }()\n    ```", "```go\nclose(done)\n```", "```go\nfunc main() {\n  done:=false\n  go func() {\n    // Wait while done==false\n    for !done {}\n    fmt.Println(\"Done is true now\")\n  }()\n  done=true\n  // Wait indefinitely\n  select{}\n}\n```", "```go\n// cacheMutex will be used to protect access to cache\nvar cacheMutex sync.Mutex\nvar cache map[string]any = map[string]any{}\n```", "```go\ncacheMutex.Lock()\ncache[key]=value\ncacheMutex.Unlock()\n```", "```go\ncacheMutex.Lock()\ncachedValue, cached := cache[key]\ncacheMutex.Unlock()\nif cached {\n  // Value found in cache\n}\n```"]