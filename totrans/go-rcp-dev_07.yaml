- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency is a core part of the Go language. Unlike many other languages that
    support concurrency via rich multi-threading libraries, Go provides relatively
    few language primitives to write concurrent programs.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by emphasizing that concurrency is **not** parallelism. Concurrency
    is about how you write programs; parallelism is about how programs run. A concurrent
    program specifies what parts of the program can run in parallel. Depending on
    the actual execution, concurrent parts of a program may run sequentially, concurrently
    using time-sharing, or in parallel. A correct concurrent program yields the same
    result regardless of how it is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces some of the Go concurrency primitives using recipes.
    In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating goroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running multiple independent functions concurrently and waiting for them to
    end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending and receiving data using channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending data to a channel from multiple goroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting the results of concurrent computations using channels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with multiple channels using the `select` statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling a goroutine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting cancelation using nonblocking `select`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating shared variables concurrently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing things concurrently using goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A goroutine is a function that runs concurrently with other goroutines. When
    a program starts, the Go runtime creates several goroutines. One of these goroutines
    runs the garbage collector. Another goroutine runs the `main` function. As the
    program executes, it creates more goroutines as necessary. A typical go program
    may have thousands of goroutines all running concurrently. The Go runtime schedules
    these goroutines to operating system threads. Each operating system thread is
    assigned a number of goroutines that it runs using time sharing. At any given
    moment, there can be as many active goroutines as the number of logical processors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating goroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Goroutines are an integral part of the Go language. You create goroutines using
    the `go` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create goroutines using the `go` keyword followed by a function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When `go f()` is evaluated, the runtime creates a new goroutine and calls the
    `f` function. The goroutine running `main` also continues running. In other words,
    when the `go` keyword is evaluated, the program execution splits into two concurrent
    execution streams – one is the original execution stream (in the preceding example,
    the stream that is running `main`) and the other runs the function that comes
    after the `go` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function can take arguments if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The arguments to the function are evaluated before the goroutine starts. That
    is, the `main` goroutine first evaluates the argument of `f` (which is, in this
    case, the `x` value) and then creates a new goroutine and runs `f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is common practice to use a closure to run goroutines. They provide the
    context necessary for understanding code. They also prevent passing many variables
    as arguments to goroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `x` is passed as an argument to the goroutine, but `y` is captured.
  prefs: []
  type: TYPE_NORMAL
- en: When the function run by the `go` keyword ends, the goroutine terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Running multiple independent functions concurrently and waiting for them to
    complete
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you have multiple independent functions that do not share data, you can
    use this recipe to run them concurrently. We will also use `sync.WaitGroup` to
    wait for the goroutines to finish.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create an instance of `sync.WaitGroup` to wait for goroutines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A `sync.WaitGroup` is simply a thread-safe counter. We will use `wg.Add(1)`
    for each goroutine we create, and use `wg.Done()` to subtract 1 whenever a goroutine
    ends. Then we can wait for the waitgroup to reach zero, signaling the termination
    of all goroutines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For each function that will run concurrently, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add 1 to the wait group
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Start a new goroutine
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `defer wg.Done()` to make sure you signal goroutine termination
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Instead of adding 1 to the wait group for every goroutine, you can simply add
    the number of goroutines. For instance, if you know that you will create 5 goroutines,
    you can simply do `wg.Add(5)` before creating the first goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait for the goroutines to end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This call will block until `wg` reaches zero, that is, until all goroutines
    call `wg.Done()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, you can use the results of all the goroutines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The crucial detail of this recipe is that all goroutines are independent, which
    means the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All variables written by each goroutine are used exclusively by that goroutine
    until `wg.Done()`. Goroutines may read shared variables, but they cannot write
    to them. After `wg.Done()`, all goroutines are terminated and the variables they
    wrote can be used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: No goroutine depends on the result of another goroutine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should not attempt to read the results of a goroutine before `wg.Wait`.
    That is a memory race with undefined behavior.
  prefs: []
  type: TYPE_NORMAL
- en: A **memory race** happens when you write to a shared variable concurrently with
    other writes or reads. The result of a program containing a memory race is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Communicating between goroutines using channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More often than not, multiple goroutines have to communicate and coordinate
    to distribute work, manage state, and collate results of computations. Channels
    are the preferred mechanism for this. A channel is a synchronization mechanism
    with an optional fixed-size buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tip:'
  prefs: []
  type: TYPE_NORMAL
- en: The following recipes show channels that are closed. Closing a channel is a
    method for communicating end of data. If you do not close a channel, it will be
    garbage collected when it is no longer referenced. In other words, you don't need
    to close a channel if you don't need to signal end of data to the receivers.
  prefs: []
  type: TYPE_NORMAL
- en: Sending and receiving data using channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A goroutine can send to a channel if there is another goroutine waiting to receive
    from it, or in the case of a buffered channel, there is space available in the
    channel buffer. Otherwise, the goroutine is blocked until it can send.
  prefs: []
  type: TYPE_NORMAL
- en: A goroutine can receive from a channel if there is another goroutine waiting
    to send to it, or in the case of a buffered channel, there is data in the channel
    buffer. Otherwise, the receiver is blocked until it can receive.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create a channel with the type of data it will pass. The following example creates
    a channel that can pass strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a goroutine, send data elements to the channel. When all data elements are
    sent, close the channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Receive data from the channel in another goroutine. In the following example,
    the main goroutine receives strings from the channel and prints them. The `for`
    loop ends when the channel is closed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sending data to a channel from multiple goroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are cases where you have many goroutines working on a piece of a problem,
    and when they are done, they send the result using a channel. A problem with this
    situation is deciding when to close the channel. This recipe shows how it is done.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create the result channel with the data type it will pass:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the listener goroutine and a wait group to wait for its completion later.
    This goroutine will be blocked until the other goroutines start sending data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a wait group to keep track of the goroutines that will write to the
    result channel. Then, create goroutines that send to the channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wait for the processing goroutines to end and close the result channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Wait for the listener goroutine to end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now you can use the `results` slice.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting the results of concurrent computations using channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, you have multiple goroutines working on parts of a problem and you have
    to collect the result of each goroutine to compile a single result object. Channels
    are the perfect mechanism for this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a channel to collect the results of the computation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, the `resultCh` channel is a channel of `int` values. That is,
    the results of the computations will be integers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a `sync.WaitGroup` instance to wait for the goroutines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Distribute work among goroutines. Each goroutine should have access to the `resultCh`.
    Add each goroutine to the wait group, and make sure to call `defer wg.Done()`
    in the goroutine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Perform the computation in the goroutine, and send the result to the `resultCh`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, you have to do two things: wait for all goroutines to complete and collect
    the results from the `resultCh`. There are two ways you can do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Collect the results while waiting for the goroutines to end concurrently. That
    is, create a goroutine and wait for the goroutines to end. When all goroutines
    are done, close the channel:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Collect the results asynchronously while waiting for the goroutines to end.
    When all goroutines are completed, close the channel. However, when you close
    the channel, the goroutine that collects the results may still be running. We
    have to wait for that goroutine to end as well. We can use another wait group
    for that purpose:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Working with multiple channels using the select statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can only send data or receive data from a channel at any given time. If
    you are interacting with multiple goroutines (and thus, multiple concurrent events),
    you need a language construct that will let you interact with multiple channels
    at once. That construct is the `select` statement.
  prefs: []
  type: TYPE_NORMAL
- en: This section shows how `select` is used.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A blocking `select` statement chooses an active case from zero or more cases.
    Each case is a channel send or channel receive event. If there are no active cases
    (that is, none of the channels can be sent to or received from), `select` is blocked.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `select` statement waits to receive from one
    of two channels. The program receives from only one of the channels. If both channels
    are ready, one of the channels will be picked randomly. The other channel will
    be left unread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Canceling goroutines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating goroutines is easy and efficient in Go, but you also have to make sure
    your goroutines end eventually. If a goroutine is left running unintentionally,
    it is called a “leaked” goroutine. If a program keeps leaking goroutines, eventually
    it crashes with an out-of-memory error.
  prefs: []
  type: TYPE_NORMAL
- en: Some goroutines perform a limited number of operations and terminate naturally,
    but some run indefinitely until an external stimulus is received. A common pattern
    for long-running goroutines to receive such stimulus is to use a `done` channel.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a `done` channel with an empty data type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a channel to provide input to goroutines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create goroutines that look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To cancel the goroutine(s), simply close the `done` channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will enable the `case <-done` branch in all the goroutines that are listening
    to the `done` channel, and they will terminate.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting cancelation using nonblocking select
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A non-blocking `select` has a `default` case. When the `select` statement runs,
    it checks all the available cases, and if none of them are available, the `default`
    case is selected. This allows a `select` to continue without blocking.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a `done` channel with an empty data type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create goroutines that look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To cancel the goroutine(s), simply close the `done` channel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Sharing memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most famous Go idioms is: “Do not communicate by sharing memory,
    share memory by communicating.” Channels are for sharing memory by communicating.
    Communicating by sharing memory is done using shared variables in multiple goroutines.
    Even though it is discouraged, there are many use cases where shared memory makes
    more sense than a channel. If at least one of the goroutines updates a shared
    variable that is read by other goroutines, you have to ensure that there are no
    memory races.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A memory race happens when a goroutine updates a variable concurrently while
    another goroutine reads from it or writes to it. When this happens, there is no
    guarantee that the update to that variable will be seen by other goroutines. A
    famous example of this situation is the `busy-wait` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This program has a memory race. The `done=true` assignment is concurrent with
    the `for !done` loop. That means, even though the main goroutine runs `done=true`,
    the goroutine reading `done` may never see that update, staying in the `for` loop
    indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: Updating shared variables concurrently
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Go memory model guarantees that the effect of a variable write is visible
    to instructions that come after that write within that goroutine only. That is,
    if you update a shared variable, you have to use special tools to make that update
    visible to other goroutines. A simple way to ensure this is to use a mutex. Mutex
    stands for “mutual exclusion.” A mutex is a tool you can use to ensure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Only one goroutine updates a variable at any given time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once that update is done and the mutex is released, all goroutines can see that
    update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we show how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The section of a program that updates shared variables is a “critical section.”
    You use a mutex to ensure that only a single goroutine can enter its critical
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a mutex to protect a critical section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: A mutex protects a set of shared variables. For instance, if you have goroutines
    that update a single integer, you declare a mutex for the critical sections that
    update that integer. You must use the same mutex every time you read or write
    that integer value.
  prefs: []
  type: TYPE_NORMAL
- en: 'When updating the shared variable(s), first lock the mutex. Then perform the
    update and unlock the mutex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With this pattern, if multiple goroutines attempt to update `cache`, they will
    queue at `cacheMutex.Lock()` and only one will be allowed. When that goroutine
    performs the update, it will call `cacheMutex.Unlock()`, which will enable one
    of the waiting goroutines to acquire the lock and update the cache again.
  prefs: []
  type: TYPE_NORMAL
- en: 'When reading the shared variable, first lock the mutex. Then perform the read,
    and then unlock the mutex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
