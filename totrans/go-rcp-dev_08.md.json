["```go\nfunc DoesNotReturnError() {...}\nfunc MayReturnError() error {...}\nfunc MayReturnStringAndError() (string,error) {...}\n```", "```go\nfunc LoadConfig(f string) (*Config, error) {\n   file, err:=os.Open(f)\n   if err!=nil {\n      return nil, fmt.Errorf(\"file %s: %w\", f,err)\n   }\n   defer file.Close()\n   var cfg Config\n   err = json.NewDecoder(file).Decode(&cfg)\n   if err!=nil {\n     return nil, fmt.Errorf(\"While unmarshaling %s: %w\",f,err)\n   }\n   return &cfg, nil\n}\n```", "```go\nfile, err := os.Open(fileName)\nif err!=nil {\n   return fmt.Errorf(\"%w: While opening %s\",err,fileName)\n}\n```", "```go\nfile, err := os.Open(fileName)\nif err!=nil {\n  // File could not be opened\n}\n```", "```go\nfile, err := os.Open(fileName)\nif errors.Is(err,os.ErrNotExist) {\n  // File does not exist\n}\n```", "```go\nvar e1 = errors.New(\"test\")\nvar e2 = errors.New(\"test\")\nif e1 != e2 {\n   fmt.Println(\"Errors are different!\")\n}\n```", "```go\nvar (\n  ErrNotFound = errors.New(\"Not found\")\n)\n```", "```go\ntype ErrSyntax struct {\n   Line int\n   Col int\n   Diag string\n}\nfunc (err ErrSyntax) Error() string {\n  return fmt.Sprintf(\"Syntax error line: %d col: %d, %s\", err.Line, \n  err.Col, err.Diag)\n}\n```", "```go\nfunc ParseInput(input string) error {\n  ...\n  if nextRune != ',' {\n     return ErrSyntax {\n        Line: line,\n        Col: col,\n        Diag: \"Expected comma\",\n    }\n  }\n  ...\n}\n```", "```go\ntype ErrFile struct {\n   Name string\n   When string\n   Err error\n}\nfunc (err ErrFile) Error() string {\n   return fmt.Sprintf(\"%s: file %s, when %s\", err.Err, err.Name, err.\n   When)\n}\nfunc (err ErrFile) Unwrap() error { return err.Err }\nfunc ReadConfigFile(name string) error {\n  f, err:=os.Open(name)\n  if err!=nil {\n     return ErrFile {\n        Name: name,\n        Err:err,\n        When: \"opening configuration file\",\n     }\n  }\n  ...\n}\n```", "```go\nerr:=ReadConfig(\"config.json\")\nif errors.Is(err,os.ErrNotFound) {\n   // file not found\n}\n```", "```go\ntype ErrSyntax struct {\n   Line int\n   Col int\n   Err error\n}\nfunc (err ErrSyntax) Error() string {...}\nfunc (err ErrSyntax) Is(e error) bool {\n  _,ok:=e.(ErrSyntax)\n  return ok\n}\n```", "```go\nerr:=Parse(input)\nif errors.Is(err,ErrSyntax{}) {\n   // err is a syntax error\n}\n```", "```go\nfunc (err ErrSyntax) As(target any) bool {\n   if tgt, ok:=target.(*ErrSyntax); ok {\n      *tgt=err\n      return true\n   }\n   return false\n}\nfunc main() {\n  ...\n  err:=Parse(in)\n  var syntaxError ErrSyntax\n  if errors.As(err,&syntaxError) {\n    // syntaxError has a copy of the ErrSyntax\n  }\n  ...\n}\n```", "```go\nfunc (g *Graph) NewEdge(from,to *Node) *Edge {\n  if from.graph!=g {\n     panic(\"from node is not in graph\")\n  }\n  if to.graph!=g {\n     panic(\"to node is not in graph\")\n  }\n   ...\n}\n```", "```go\nfunc main() {\n  defer func() {\n     if r:=recover(); r != nil {\n        // deal with the panic\n     }\n  }()\n  ...\n}\n```", "```go\nfunc process() (err error) {\n  defer func() {\n     r:=recover()\n     if e, ok:=r.(error); ok {\n         err = e\n     }\n```", "```go\nimport \"runtime/debug\"\nimport \"fmt\"\nfunc main() {\n    defer func() {\n        if r := recover(); r != nil {\n            stackTrace := string(debug.Stack())\n            // Work with stackTrace\n            fmt.Println(stackTrace)\n        }\n    }()\n    f()\n}\nfunc f() {\n   var i *int\n   *i=0\n}\n```", "```go\ngoroutine 1 [running]:\nruntime/debug.Stack()\n     /usr/local/go-faketime/src/runtime/debug/stack.go:24 +0x5e\nmain.main.func1()\n     /tmp/sandbox381445105/prog.go:13 +0x25\npanic({0x48bbc0?, 0x5287c0?})\n     /usr/local/go-faketime/src/runtime/panic.go:770 +0x132\nmain.f(...)\n     /tmp/sandbox381445105/prog.go:23\nmain.main()\n     /tmp/sandbox381445105/prog.go:18 +0x2e\n```"]