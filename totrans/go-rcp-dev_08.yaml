- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Errors and Panics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go error handling has been nothing but polarizing. Those who came from a background
    in languages with exception handling (such as Java) tend to hate it, and those
    who came from a background in languages where errors are values returned from
    functions (such as C) feel comfortable with it.
  prefs: []
  type: TYPE_NORMAL
- en: Having a background in both, I am of the opinion that the explicit nature of
    error handling forces you to think about exceptional situations at every step
    of the development. Error generation, error passing, and error handling require
    the same type of discipline and scrutiny as the “happy path” (which is when no
    errors happen).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you noticed, I make a distinction between three phases of dealing with errors:'
  prefs: []
  type: TYPE_NORMAL
- en: Detection and generation of errors deal with detecting an exceptional situation
    and capturing diagnostic information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing of errors deals with allowing errors to be propagated up the stack,
    optionally decorating them with contextual information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling of errors deals with actually resolving the error, which may include
    terminating the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to generate errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to pass them by annotating them using contextual information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing errors in a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with panics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning and handling errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to detect errors and how to wrap errors with additional
    contextual information.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the last return value of a function or method for errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If the function or method is successful, it will return `nil` error. If an
    error condition is detected within the function or method, either return that
    error verbatim or wrap the error with another one containing contextual information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Do not use `panic` as a replacement for error. `panic` should be used to signal
    a potential bug or unrecoverable situation. An error is used to signal a context-dependent
    situation, such as a missing file or invalid input.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go uses explicit error detection and handling. That means there is no implicit
    or hidden execution path for errors (such as throwing an exception). Go errors
    are simply interface values and an error being `nil` is interpreted as the absence
    of an error. The above function calls some file management functions that can
    return an error. When that happens (that is, when the function returns a non-`nil`
    error), this function simply wraps that error with additional information and
    returns it. The additional information allows the caller, and sometimes the user
    of the program to determine the correct course of action.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping errors to add contextual information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the standard library `errors` package, you can wrap an error with another
    error that contains additional contextual information. This package also provides
    facilities and conventions that will let you check if an error tree contains a
    particular error or extract a particular error from an error tree.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add contextual information to an error using `fmt.Errorf`. In the following
    example, the returned error will contain the error returned from `os.Open`, and
    it will also include the file name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `%w` verb in `fmt.Errorf` above. The %w verb is used to create
    an error wrapping the one given as its argument. If we used %v or %s, the returned
    error would contain the text of the original error, but it would not wrap it.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you wrap an error with additional information, the new error value is not
    of the same type or value as the original error. For instance, `os.Open` may return
    `os.ErrNotExist` if the file is not found, and if you wrap this error with additional
    information, such as the file name, the caller of this function will need a way
    to get to the original error to handle it properly. This recipe shows how to deal
    with such wrapped error values.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Checking if there is an error or not is simple: check if an error value is
    `nil` or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking if an error is what you expect should be done using `errors.Is`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`errors.Is(err,target error)` compares if `err` is equal to `target` by doing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks if `err==target`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If that fails, it checks if `err` has an `Is(error) bool` method by calling
    `err.Is(target)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If that fails, it checks if `err` has an `Unwrap() error` method and `err.Unwrap()`
    is not `nil` by checking if `err.Unwrap()` is equal to `target`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If that fails, it checks if `err` has an `Unwrap() []error` method, and if `target`
    is equal to any one of those slice elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The meaning of this is that if you wrap an error, the caller can still check
    if the wrapped error happened and behave accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you define an error using `errors.New()` or `fmt.Errorf()`, then the returned
    error interface contains a pointer to an object. In this case, the fact that two
    errors have the same string representation doesn’t mean that they are equal. The
    following program shows this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, even though the error strings are the same, `e1` and `e2` are pointers
    pointing to different objects. The program will print `Errors are different`.
    Thus, declaring errors like the following works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A comparison to `ErrNotFound` will compare if an error value is a pointer to
    the same object as `ErrNotFound`.
  prefs: []
  type: TYPE_NORMAL
- en: Structured errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **structured error** provides contextual information that can be crucial in
    handling the errors before they reach the user of a program. This recipe shows
    how such errors can be used.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Define a struct containing metadata that captures the error situation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `Error() string` method to make it an `error`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the error can wrap other errors, include an `error` or `[]error` to store
    those.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, implement the `Is(error) bool` method to control how to compare
    this error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, implement `Unwrap() error` or `Unwrap() []error` to return wrapped
    errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any data type implementing the `error` interface (containing only one method,
    `Error() string`) can be used as an error. This means that you can create data
    structures containing detailed error information that can be later acted upon.
    So, if you need several data fields to describe an error, instead of building
    an elaborate string and returning it via `fmt.Errorf`, you can use a struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s assume you are parsing a multi-line formatted text input.
    Returning accurate and useful information to your users is important; nobody will
    enjoy receiving a `Syntax error` message without showing where the error is. So,
    you declare this error structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now generate useful error information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can use this error information to display useful messages to your users
    or control an interactive response, such as positioning the cursor to where the
    error is or highlighting text near the error location.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping structured errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A structured error can be used to decorate another error with additional information
    by wrapping it. This recipe shows how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keep an error member variable (or a slice of errors) to store the root cause
    in the structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement `Unwrap() error` (or `Unwrap() []``error`) method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can wrap the root cause error in a structured error. This allows you to
    add structured contextual information about the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `Unwrap` is necessary. Without that, the following code will fail
    to detect that the error is derived from `os.ErrNotFound`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With the `Unwrap` method, the `errors.Is` function can descend the enclosed
    errors, and determine if at least one of them is `os.ErrNotFound`.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing structured errors by type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In languages that support `try`-`catch` blocks, you usually catch errors based
    on their type. You can emulate the same functionality relying on `errors.Is`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implement the `Is(error) bool` method in your error type to define what type
    of equivalence you care about.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may remember that the `errors.Is(err,target)` function first tests if `err
    = target`, and if that fails, it tests if `err.Is(target)`, provided `err` implements
    the `Is(error) bool` method. So, you can use the `Is(error) bool` method to tune
    how to compare your custom error types. Without the `Is(error) bool` method, `errors.Is`
    will compare using `==`, which will fail if the contents of two errors are different
    even if they are the same type. The following example allows you to check if the
    given error contains `ErrSyntax` somewhere in the error tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can test if an error is a syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Extracting a specific error from the error tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `errors.As` function to descend an error tree, find a particular error,
    and extract it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to the `errors.Is` function, `errors.As(err error, target any) bool`
    descends the error tree of `err` until an error that is assignable to `target`
    is found. That is done by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks if the value pointed to by `target` is assignable to the value pointed
    to by `err`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If that fails, it checks if `err` has an `As(error) bool` method by calling
    `err.As(target)`. If it returns `true`, then an error is found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If not, it checks if `err` has an `Unwrap() error` method and `err.Unwrap()`
    is not `nil`, descending the tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, it checks if `err` has an `Unwrap() []error` method, and if it returns
    a non-empty slice, it descends the tree for each of those until a match is found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In other words, `errors.As` copies the error that can be assigned to `target`
    into `target`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example can be used to extract an instance of `ErrSyntax` from
    an error tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the use of pointers here. The error struct is used as a value, and you
    want a copy of that error struct, so you pass a pointer to it: an instance of
    `ErrSyntax` can be copied into an instance of `*ErrSyntax`. If your program used
    `*ErrSyntax` as the error value, you need to send `**ErrSyntax` by declaring `var
    syntaxError *ErrSyntax` and passing `&syntaxError` to copy the pointer into the
    memory location pointed to by the double-pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with panics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, a **panic** is an unrecoverable situation, such as resource exhaustion
    or a violation of an invariant (that is, a bug). Some panics, such as out of memory
    or divide by zero, will be raised by the runtime (or raised by the hardware and
    transferred to the program as a panic). You should generate a panic in your program
    when you detect a bug. But how do you decide if a situation is a bug and you should
    panic or an error?
  prefs: []
  type: TYPE_NORMAL
- en: In general, an external input (user input, data submitted by an API, or data
    read from a file) should not cause a panic. Such situations should be detected
    and returned as meaningful errors to the user. A panic in this situation would
    be, for instance, a failed compilation of a regular expression that is declared
    as a constant string in your program. The input is not something that can be fixed
    by re-running the program with different inputs; it is simply a bug.
  prefs: []
  type: TYPE_NORMAL
- en: If a panic is not handled with `recover`, the program will terminate by printing
    diagnostic output, including the reason for panic and the stacks of active goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Panicking when necessary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, deciding whether to panic or to return an error is not an
    easy decision. This recipe offers some guidelines to make that decision easier.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two situations where you can panic. Panic if either of the following
    is the case:'
  prefs: []
  type: TYPE_NORMAL
- en: An invariant is violated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program cannot continue in the current state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An invariant is a condition that cannot be violated in a program. Thus, if you
    detect that it is violated, instead of returning an error, panic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is from a graph library I wrote. A graph contains nodes
    and edges, managed by a `*Graph` structure. The `Graph.NewEdge` method creates
    a new edge between two nodes. Those two nodes must belong to the same graph as
    the receiver of the `NewEdge` method so it is appropriate to panic if that is
    not the case, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Above, there is nothing that can be gained by returning an error from this method.
    This is clearly a bug the caller did not realize, and if the program is allowed
    to continue, the integrity of the `Graph` object will be violated, creating hard-to-find
    bugs. The best course of action is to panic.
  prefs: []
  type: TYPE_NORMAL
- en: The second situation is a broad case where continuation is not possible. As
    an example, consider you are writing a web application and you load HTML templates
    from the file system. If the compilation of such a template fails, the program
    cannot continue. You should panic.
  prefs: []
  type: TYPE_NORMAL
- en: Recovering from panics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An unhandled panic will terminate the program. Often, this is the only correct
    course of action. However, there are cases where you want to fail whatever caused
    the error, log it, and continue. For example, a server handling many requests
    concurrently does not terminate just because one of the requests panicked. This
    recipe shows how you can recover from a panic.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use a `recover` statement in a `defer` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a program panics, the panicking function will return after all deferred
    blocks are executed. The stack of that goroutine will unroll one function after
    the other, cleaning up by running their `deferred` statements, until the beginning
    of the goroutine is reached, or one of the deferred functions invokes `recover`.
    If the panic is not recovered, the program will crash by printing out diagnostic
    and stack information. If the panic is recovered, the `recover()` function will
    return whatever parameter was given to `panic`, which can be any value.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you recover from a panic, you should check if the recovered value is
    an error that you can use to give more useful information.
  prefs: []
  type: TYPE_NORMAL
- en: Changing return value in recover
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you recover from a panic, you usually want to return some sort of error
    describing what happened. This recipe shows you how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To change the return value of a function when recovered from a panic, use named
    return values.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **named return value** allows you to access and set the return values of
    a function. As shown below, you can change the return value of a function using
    named return values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Capturing the stack trace of a panic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Printing or logging a stack trace when a panic is detected is a critical tool
    in identifying problems at runtime. This recipe shows how you can add a stack
    trace to your logging messages.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `debug.Stack` function with `recover`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When inside the recovery function, the `debug.Stack` function will return the
    stack of the panic that is being recovered, not the stack where it is called.
    Thus, if you can log this information or print it, it will show you the exact
    location of the source of the panic.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Getting the stack this way is an expensive operation. Use it carefully and only
    when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding program will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`prog.go:13` is where `debug.Stack()` is called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prog.go:23` is where `*i=0` is executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prog.go:18` is where `f()` is called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the stack pinpoints the exact location of the error (`prog.go:23`).
  prefs: []
  type: TYPE_NORMAL
