["```go\n    type requestIDKeyType int\n    ```", "```go\n    var requestIDKey requestIDKeyType\n    ```", "```go\n    func WithRequestID(ctx context.Context,requestID string) context.Context {\n      return context.WithValue(ctx,requestIDKey,requestID)\n    }\n    func GetRequestID(ctx context.Context) string {\n      id,_:=ctx.Value(requestIDKey).(string)\n      return id\n    }\n    ```", "```go\n    newCtx:=WithRequestID(ctx,requestID)\n    handleRequest(newCtx)\n    ```", "```go\n// ctx: An empty context\nctx := context.Background()\n// ctx1: ctx + {key1:value1}\nctx1 := context.WithValue(ctx, \"key1\", \"value1\")\n// ctx2: ctx1 + {key2:value2}\nctx2 := context.WithValue(ctx, \"key2\", \"value2\")\n```", "```go\nval1,_ := ctx2.Value(\"key1\")\nval2,_ := ctx2.Value(\"key2\")\nfmt.Println(val1, val2)\n```", "```go\nvalue1 value2\n```", "```go\nval1,_ = ctx1.Value(\"key1\")\nval2,_ = ctx1.Value(\"key2\")\nfmt.Println(val1, val2)\n```", "```go\nvalue1 <nil>\n```", "```go\nval1,_ = ctx.Value(\"key1\")\nval2,_ = ctx.Value(\"key2\")\nfmt.Println(val1, val2)\n```", "```go\n<nil> <nil>\n```", "```go\ntype ctxData struct {\n  value int\n}\n...\nctx:=context.WithValue(context.Background(),dataKey, &ctxData{})\n...\nif data,exists:=ctx.Value(dataKey); exists {\n  data.(*ctxData).value=1\n}\n```", "```go\ntype AuthInfo struct {\n  // Set when AuthInfo is created\n  UserID string\n  // Lazy-initialized\n  privileges map[string]Privilege\n}\ntype authInfoKeyType int\nvar authInfoKey authInfoKeyType\n// Set the privileges if is it not initialized.\n// Do not do this!!\nfunc (auth *AuthInfo) GetPrivileges() map[string]Privilege {\n   if auth.privileges==nil {\n      auth.privileges=GetPrivileges(auth.UserID)\n   }\n   return auth.privileges\n}\n// Authentication middleware\nfunc AuthMiddleware(next http.Handler) func(http.Handler) http.Handler {\n    return func(next http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.\n        Request) {\n            // Authenticate the caller\n            var authInfo *AuthInfo\n            var err error\n            authInfo, err = authenticate(r)\n            if err != nil {\n                http.Error(w, err.Error(), http.StatusUnauthorized)\n                return\n            }\n            // Create a new context with the authentication info\n            newCtx := context.WithValue(r.Context(), authInfoKey, \n            authInfo)\n            // Pass the new context to the next handler\n            next.ServeHTTP(w, r.WithContext(newCtx))\n        })\n    }\n}\n```", "```go\ntype AuthInfo struct {\n  sync.Mutex\n  UserID string\n  privileges map[string]Privilege\n}\nfunc (auth *AuthInfo) GetPrivileges() map[string]Privilege {\n   // Use mutex to initialize the privileges in a thread-safe way\n   auth.Lock()\n   defer auth.Unlock()\n   if auth.privileges==nil {\n      auth.privileges=GetPrivileges(auth.UserID)\n   }\n   return auth.privileges\n}\n```", "```go\n     authInfo, err=authenticate(r)\n     if err!=nil {\n       http.Error(w,err.Error(),http.StatusUnauthorized)\n       return\n     }\n     // Initialize the privileges here when the structure is created\n     authInfo.GetPrivileges()\n```", "```go\n    ctx:=context.Background()\n    cancelable, cancel:=context.WithCancel(ctx)\n    defer cancel()\n    ```", "```go\n    go cancelableGoroutine1(cancelable)\n    go cancelableGoroutine2(cancelable)\n    cancelableFunc(cancelable)\n    ```", "```go\n    func cancelableFunc(ctx context.Context) {\n      // Process some data\n      // Check context cancelation\n      select {\n         case <-ctx.Done():\n            // Context canceled\n            return\n         default:\n      }\n      // Continue computation\n    }\n    ```", "```go\n     func cancelableFunc(ctx context.Context) {\n       // Process some data\n       // Check context cancelation\n       if ctx.Err()!=nil {\n           // Context canceled\n           return\n       }\n       // Continue computation\n    }\n    ```", "```go\n    ctx:=context.Background()\n    cancelable, cancel:=context.WithCancel(ctx)\n    defer cancel()\n    wg:=sync.WaitGroup{}\n    wg.Add(1)\n    go cancelableGoroutine1(cancelable,&wg)\n    if err:=process(ctx); err!=nil {\n       // Cancel the context\n       cancel()\n       // Do other things\n    }\n    wg.Wait()\n    ```", "```go\ncancelable, cancel := context.WithCancel(ctx)\ndefer cancel()\n...\n```", "```go\n// Empty context, no cancelation\noriginalContext := context.Background()\n// Cancelable context based on originalContext\ncancelableContext1, cancel1 := context.WithCancel(originalContext)\n```", "```go\ngo f1(cancelableContext1)\ngo f2(cancelableContext1)\n```", "```go\ncancelableContext2, cancel2 := context.WithCancel(cancelableContext)\ngo g1(cancelableContext2)\ngo g2(cancelableContext2)\n```", "```go\ncancal2() // canceling g1 and g2 only\n```", "```go\ncancel1() // canceling f1, f2, g1, g2\n```", "```go\nfunc f1(cancelableContext context.Context) {\n   for {\n      if cancelableContext.Err()!=nil {\n         // Context is canceled\n         // Cleanup and return\n         return\n      }\n      // Process\n   }\n}\n```", "```go\n    ctx:=context.Background()\n    timeoutable, cancel:=context.WithTimeout(ctx,5*time.Second)\n    defer cancel()\n    ```", "```go\n    go longRunningGoroutine1(timeoutable)\n    go longRunningGoroutine2(timeoutable)\n    ```", "```go\n    func longRunningGoroutine(ctx context.Context) {\n      // Process some data\n      // Check context cancelation\n      select {\n         case <-ctx.Done():\n            // Context canceled\n            return\n         default:\n      }\n      // Continue computation\n    }\n    ```", "```go\n     func cancelableFunc(ctx context.Context) {\n       // Process some data\n       // Check context cancelation\n       if ctx.Err()!=nil {\n           // Context canceled\n           return\n       }\n       // Continue computation\n    }\n    ```", "```go\n    ctx:=context.Background()\n    timeoutable, cancel:=context.WithTimeout(ctx, 5*time.Second)\n    defer cancel()\n    wg:=sync.WaitGroup{}\n    wg.Add(1)\n    go longRunningGoroutine(timeoutable,&wg)\n    if err:=process(ctx); err!=nil {\n       // Cancel the context\n       cancel()\n       // Do other things\n    }\n    wg.Wait()\n    ```", "```go\n    timeoutable, cancel := context.WithTimeout(ctx,5*time.Second)\n    defer cancel()\n    ...\n    ```", "```go\nfunc readData(conn net.Conn) {\n  // Read a block of data from the connection\n  msg:=make([]byte,1024)\n  n, err:=conn.Read(msg)\n  ...\n}\n```", "```go\ntimeout, cancel := context.WithTimeout(context.Background(),1*time.Second)\ndefer cancel()\n// Close the connection when context times out\ngo func() {\n   // Wait for cancelation signal\n   <-cancelable.Done()\n   // Close the connection\n   conn.Close()\n}()\nwg:=sync.WaitGroup()\nwg.Add(1)\n// This goroutine must complete within a second, or the connection \n// will be closed\ngo func() {\n   defer wg.Done()\n    // Read a block of data from the connetion\n   msg:=make([]byte,1024)\n   // This call may block\n   n, err:=conn.Read(msg)\n   if err!=nil {\n      return\n   }\n   // Process data\n}()\nwg.Wait() // Wait for the processing of connection to complete\n...\n```", "```go\n    ln, err:=net.Listen(\"tcp\",\":8080\")\n    if err!=nil {\n      return err\n    }\n    for {\n      conn, err:=ln.Accept()\n      if err!=nil {\n        return err\n      }\n      go func(c net.Conn) {\n         // Step 1:\n         // Request times out after duration: RequestTimeout\n         ctx, cancel:=context.WithTimeout(context.\n         Background(),RequestTimeout)\n         // Step 2:\n         // Make sure cancel is called\n         defer cancel()\n         // Step 3:\n         // Pass the context to handler\n         handleRequest(ctx,c)\n      }(conn)\n    }\n    ```"]