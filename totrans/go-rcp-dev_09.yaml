- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Context Package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Context is the circumstances in which something happens. When we are talking
    about a program, the context is the program environment, settings, and so on.
    For a server program (an HTTP server responding to a client request, an RPC server
    responding to function calls, etc.) or a program that responds to user requests
    (an interactive program, a command-line application, etc.), you can talk about
    a request-specific context. A request-specific context is created when the server
    or program starts processing a particular request and terminates when the processing
    ends. The request context contains information such as a request identifier that
    helps you identify log messages generated while processing a request, or the identity
    of the caller so you can determine the access rights of the caller. One of the
    uses of the `context` package is to provide an abstraction of such a request context,
    that is, an object that keeps request-specific data.
  prefs: []
  type: TYPE_NORMAL
- en: You may also have concerns about the running time of a request. You usually
    want to limit the amount of time a request is processed, or you may want to detect
    that the client is no longer interested in the results of the request (such as
    a WebSocket peer disconnecting). The `context` package is designed to handle these
    use cases as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `context` package defines the `context.Context` interface. It has two uses:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a timeout and/or cancellation to request processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass request-specific metadata down the stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The use of `context.Context` is not limited to server programs. The term “request
    processing” should be taken in a broad sense: the request can be a network request
    through a TCP connection, an HTTP request, a command read from a command line,
    running a program with a certain flag, and so on. So, the uses for `context.Context`
    are much more diverse.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter shows common uses of the `context` package. In this chapter, you
    will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing request-scoped data using context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using contexts for cancellation and timeouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using context for passing request-scoped data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Request-scoped objects are those that are created when request processing starts
    and discarded when request processing ends. These are usually lightweight objects,
    such as a request identifier, authentication information identifying the caller,
    or loggers. In this section, you will see how these objects can be passed around
    using a context.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idiomatic way of adding data values to a context is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a context key type. This avoids accidental name collisions. The use
    of an unexported type name such as the following is common. This pattern limits
    the ability to put or get context values of this particular type to the current
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: You might be tempted to use `struct{}` instead of `int` here. After all, `struct{}`
    does not consume any additional memory. You have to be very careful when working
    with 0-size structures as the Go language specification does not offer any guarantees
    about the equivalence of two 0-size structures. That is, if you create multiple
    variables of a 0-size type, they may sometimes be equal and sometimes not. In
    short, do not use `struct{}` for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the key value, or values, using the key type. In the following code
    line, `requestIDKey` is defined to be of type `requestIDKeyType` with the value
    `0` (`requestIDKey` is initialized to its `0` value when declared):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `context.WithValue` to add the new value to the context. You can define
    a couple of helper functions to set and get values to and from the context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Pass the new context to the functions called from the current function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed that `context.Context` does not exactly look like a key-value
    map (there is no `SetValue` method; in fact, `context.Context` is immutable) even
    though you can use it to store key-value pairs. In fact, you cannot add a key
    value to a context, but you can get a new context containing that key value while
    keeping the old context. Contexts have layers like an onion; every addition to
    a context creates a new context that is linked to the old one, but with more features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, `ctx`, `ctx1`, and `ctx2` are three different contexts.
    The `ctx` context is empty. `ctx1` contains `ctx` and the `key1: value1` key-value
    pair. `ctx2` contains `ctx1` and the `key2: value2` key-value pair . So, say you
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Say you do the same with `ctx1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is used for `ctx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Even though you cannot set the values in a context (that is, a context is immutable),
    you can set a pointer to a struct and set the values in that struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The standard library provides a couple of predefined context values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`context.Background()` returns a context that has no values and that cannot
    be canceled. This is usually the base context for most operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context.TODO()` is similar to `context.Background()` with a name that says
    wherever it is used should eventually be refactored to accept a real context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A context is usually shared among multiple goroutines. You have to be careful
    about concurrency issues especially if you put pointers to objects in a context.
    Take a look at the following example, which shows an authentication middleware
    for an HTTP service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The authentication middleware creates an `*AuthInfo` instance and calls the
    next handler in the chain using a context with the authentication info. The problem
    in this code is that `*AuthInfo` contains a `privileges` field that is initialized
    when `AuthInfo.GetPrivileges` is called. Since the context can be passed to multiple
    goroutines by the handlers, this lazy initialization scheme is prone to data races;
    several goroutines calling `AuthInfo.GetPrivileges` may attempt to initialize
    the map multiple times, one overwriting the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be corrected using a mutex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be corrected by initializing the privileges once in the middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Using context for cancellations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several reasons why you might want to cancel a computation: the client
    may have disconnected, or you may have multiple goroutines working on a computation
    and one of them failed, so you no longer want the others to continue. You can
    use other methods, such as a `done` channel that you close to signal cancellation,
    but a context can be more convenient depending on the use case. A context can
    be canceled many times (only the first call will actually cancel; the remaining
    ones will be ignored), whereas you cannot close an already closed channel as it
    will panic. Also, you can create a tree of contexts where canceling one context
    only cancels goroutines controlled by it, without affecting others.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are the steps to create a cancelable context and to detect a cancellation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `context.WithCancel` to create a new cancelable context based on an existing
    context, and a cancellation function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure the `cancel` function is eventually called. Canceling releases the
    resources associated with the context.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Pass the cancelable context to computations or goroutines that can be canceled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the cancelable function, check whether the context is canceled using the
    `ctx.Done()` channel, or `ctx.Err()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or, use the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To cancel a function manually, call the cancellation function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure the `cancel` function is called eventually (use `defer cancel()`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring `cancel` is called is important. If you do not cancel a cancelable
    context, goroutines associated with that context will leak (i.e., there will be
    no way to terminate the goroutines and they will consume memory).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The `cancel` function can be called multiple times. Subsequent calls will be
    ignored.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`context.WithCancel` returns a new context and the `cancel` closure. The returned
    context is a cancelable context based on the original context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use this context to control several goroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create other cancelable contexts based on a cancelable context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have two cancelable contexts. Calling `cancel2` will only cancel `cancelableContext2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `cancel1` will cancel both `cancelableContext1` and `cancelableContext2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Context cancellation is not an automated way to cancel goroutines. You have
    to check for context cancellation and cleanup accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Using context for timeouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A timeout is simply an automated cancellation. The context will cancel after
    a timer expires. This is useful in limiting resource consumption for computations
    that are not likely to finish.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are the steps to create a context with timeout and to detect when a timeout
    event happens:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `context.WithTimeout` to create a new cancelable context that will auto-cancel
    after a given duration based on an existing context and a cancellation function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Alternatively, you can use `WithDeadline` to cancel the context at a given moment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure the `cancel` function is eventually called.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Pass the timeout context to computations or goroutines that can time out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the goroutine, check whether the context is canceled using the `ctx.Done()`
    channel or `ctx.Err()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, use the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To cancel a function manually, call the cancellation function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Ensure the `cancel` function is called eventually (use `defer cancel()`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The timeout feature is simply cancellation with an attached timer. When the
    timer expires, the context is canceled.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There may be situations where a goroutine blocks without any obvious way to
    cancel it. For instance, you may block waiting to read from a network connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation cannot be canceled, because `Read` does not take `Context`.
    If you want to cancel such an operation, you can close the underlying connection
    (or file) asynchronously. The following code snippet demonstrates a use case where
    all data from a connection must be read within one second, or a goroutine will
    close the connection asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Using cancellations and timeouts in servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network servers usually start a new context when a new request is received.
    Usually, the server cancels the context when the requester closes the connection.
    Most HTTP frameworks, including the standard library, follow this basic pattern.
    If you are writing your own TCP server, you have to implement it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are the steps to handle network connections with a timeout or cancellation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you accept a network connection, create a new context with a cancellation
    or timeout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the context is canceled eventually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pass the context to the handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
