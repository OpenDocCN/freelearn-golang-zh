- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Working with Large Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理大量数据
- en: There are several ways you can utilize Go concurrency primitives to process
    large amounts of data efficiently. Unlike threads, goroutines can be created without
    much overhead. Having thousands of goroutines in a program is common. With that
    in mind, we will look at some common patterns of dealing with large amounts of
    data concurrently.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种方式利用Go并发原语有效地处理大量数据。与线程不同，goroutines可以创建而不需要太多开销。在程序中拥有数千个goroutines是很常见的。考虑到这一点，我们将探讨一些处理大量数据并发的常见模式。
- en: 'This chapter includes the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下食谱：
- en: Worker pools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作者池
- en: Connection pools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接池
- en: Pipelines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道
- en: Working with large result sets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理大量结果集
- en: Worker pools
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作者池
- en: Let’s say you have large amounts of data elements (for instance, image files)
    and you want to apply the same logic to each of them. You can write a function
    that processes one instance of the input, and then call this function in a `for`
    loop. Such a program will process the input elements sequentially, and if each
    element takes `t` seconds to process, all inputs will be completed at last at
    `n.t` seconds, `n` being the number of inputs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有很多数据元素（例如，图像文件），并且你想将相同的逻辑应用于每个元素。你可以编写一个处理输入实例的函数，然后在`for`循环中调用此函数。这样的程序将顺序处理输入元素，如果每个元素处理需要`t`秒，所有输入最终将在`n.t`秒内完成，其中`n`是输入的数量。
- en: If you want to increase throughput by using concurrent programming, you can
    create a pool of worker goroutines. You can feed the next input to an idle member
    of the worker pool, and while that is being processed, you can assign the subsequent
    input to another member. If you have `p` logical processors (which can be cores
    of physical processors) running in parallel, the result can be available in as
    fast as `n.t/p` seconds (this is a theoretical upper limit because the distribution
    of load among parallel processes is not always perfect, and there is also synchronization
    and communication overhead).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想通过使用并发编程来提高吞吐量，你可以创建一个工作者goroutine池。你可以将下一个输入提供给空闲的工作者池成员，在处理过程中，你可以将后续输入分配给另一个成员。如果你有`p`个逻辑处理器（可以是物理处理器的核心）并行运行，结果可以在`n.t/p`秒内可用（这是一个理论上的上限，因为并行进程之间的负载分布并不总是完美的，而且还有同步和通信开销）。
- en: We will look at two different ways of implementing worker pools next.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨两种实现工作者池的不同方法。
- en: Capped worker pools
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有限工作者池
- en: If there is not an expensive initialization (for instance, loading a file or
    establishing a network connection can be expensive) for each worker, it is best
    to create workers as necessary with a given limit on the number of workers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个工作者的初始化成本不高（例如，加载文件或建立网络连接可能成本较高），那么最好根据需要创建工作者，并限制工作者的数量。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new goroutine for each input. Use a channel as a synchronized counter
    to limit the maximum number of workers (here, the channel is used as a *semaphore*).
    Use an output channel to collect the results, if any:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个输入创建一个新的goroutine。使用通道作为同步计数器以限制最大工作者数量（在此，通道用作*信号量*）。如果需要，使用输出通道收集结果：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First is initialization. We create two channels:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先是初始化。我们创建两个通道：
- en: '`outputCh`: The output of the worker pool. Each worker will write the result
    to this channel.'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outputCh`：工作者池的输出。每个工作者将结果写入此通道。'
- en: '`sem`: The semaphore channel that will be used to limit the number of active
    workers. It is created with a `maxPoolSize` capacity. When we start a new worker
    goroutines, we send one element to this channel. Send operations will not block
    as long as the `sem` channel has fewer than `maxPoolSize` elements in it. When
    a worker goroutine is done, it receives one element from the channel, freeing
    capacity. Since this channel has `maxPoolSize` capacity, a `send` operation will
    block until a goroutine ends and receives from the channel if `maxPoolSize` workers
    are running.'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sem`：将用于限制活动工作者数量的信号量通道。它具有`maxPoolSize`容量。当我们启动新的工作者goroutine时，我们向此通道发送一个元素。只要`sem`通道中的元素少于`maxPoolSize`，发送操作就不会阻塞。当一个工作者goroutine完成时，它从通道接收一个元素，释放容量。由于此通道具有`maxPoolSize`容量，如果正在运行`maxPoolSize`个工作者，则发送操作将阻塞，直到goroutine结束并从通道接收。'
- en: '`outputCh` before starting the process, so the results can be read before all
    the input is sent to workers. Since the number of workers is limited, the workers
    will block after creating `maxPoolSize` of them, so we have to start listening
    for the outputs before creating the worker pool.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始处理之前关闭`outputCh`，这样就可以在将所有输入发送到工作者之前读取结果。由于工作者的数量有限，创建`maxPoolSize`个工作者后，工作者将阻塞，因此我们必须在创建工作者池之前开始监听输出。
- en: '`wg` WaitGroup, which will later be used to wait for the workers to finish.
    Before creating a new worker, we send an element to the semaphore channel. If
    there are already `maxPoolSize` workers running, this will block until one of
    them terminates. The worker processes the input, writes the output to the `outputCh`
    and terminates, receiving one element from the semaphore.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`wg` WaitGroup，稍后将用于等待工作者完成。在创建新工作者之前，我们向信号量通道发送一个元素。如果有`maxPoolSize`个工作者在运行，这将阻塞，直到其中之一终止。工作者处理输入，将输出写入`outputCh`并终止，从信号量接收一个元素。'
- en: This goroutine waits for the WaitGroup that keeps track of the workers. When
    all workers are done, the output channel is closed. That also signals the reader
    WaitGroup created at *Step 2*.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此goroutine等待跟踪工作者的WaitGroup。当所有工作者都完成后，输出通道被关闭。这也标志着在*步骤2*中创建的读取WaitGroup。
- en: 'Wait until output processing is complete. The program has to wait until all
    outputs are generated. This only happens after the closing of the `outputCh` (which
    happens at #4), and then releasing of the `readerWg`.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待输出处理完成。程序必须等待所有输出都生成。这只有在`outputCh`关闭（在#4发生）之后，然后释放`readerWg`才会发生。
- en: Fixed-size worker pools
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 固定大小的工作者池
- en: A fixed-size worker pool makes sense if creating a worker is an expensive operation.
    Simply create the maximum number of workers that read from a common input channel.
    This input channel deals with distributing work among the available workers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建工作者是一个昂贵的操作，固定大小的工作者池是有意义的。只需创建从公共输入通道读取的最大数量的工作者。此输入通道负责在可用的工作者之间分配工作。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做...
- en: There are several ways this can be achieved. We will look at two.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以实现这一点。我们将查看两种。
- en: 'In the following function, a fixed-size worker pool is created with `poolSize`
    workers. All workers read from the same input channel and write the output to
    the same output channel. This program uses a reader goroutine to collect the results
    from the worker pool while providing the inputs in the same goroutine as the caller:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下函数中，使用`poolSize`个工作者创建了一个固定大小的工作者池。所有工作者都从相同的输入通道读取，并将输出写入相同的输出通道。此程序使用一个读取goroutine从工作者池收集结果，同时在调用者的同一个goroutine中提供输入：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following version uses a goroutine to submit the work to the worker pool,
    while reading the results in the same goroutine as the caller:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下版本使用goroutine将工作提交给工作者池，同时在调用者的同一个goroutine中读取结果：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First is initialization. We create two channels:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先是初始化。我们创建两个通道：
- en: '`inputCh`: This is the input to the worker pool. Each worker in the pool reads
    from the same `inputCh` in a `for-range` loop, so when a worker receives an input,
    it stops listening from the channel, allowing another worker to pick up the next
    input.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inputCh`：这是工作者池的输入。池中的每个工作者都在`for-range`循环中从相同的`inputCh`读取，因此当工作者收到输入时，它停止监听通道，允许另一个工作者拾取下一个输入。'
- en: '`outputCh`: This is the output of the worker pool. All workers write the output
    to this channel when they are done.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outputCh`：这是工作者池的输出。所有工作者在完成时都将输出写入此通道。'
- en: 'Create the pool of workers: Since this is a fixed-size pool, we can create
    the workers in a simple for-loop. A `WaitGroup` is necessary so that we can wait
    for the processing to complete. Each worker reads from the `inputCh` until it
    is closed, processes the input, and writes to the `outputCh`.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建工作者池：由于这是一个固定大小的池，我们可以通过简单的for-loop创建工作者。需要一个`WaitGroup`，这样我们就可以等待处理完成。每个工作者从`inputCh`读取，直到它关闭，处理输入，并将输出写入`outputCh`。
- en: 'The rest of the algorithm is different for the two examples. Let’s start by
    looking at the first case:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的其余部分对于两个示例是不同的。让我们先看看第一个案例：
- en: '`outputCh` is closed. When the `outputCh` is closed, the `readerWg` is signaled.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`outputCh`已关闭。当`outputCh`关闭时，`readerWg`被信号。'
- en: '`inputCh` is closed), it closes the `outputCh`.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`inputCh`关闭时)，它关闭了`outputCh`。
- en: 'This `for` loop sends inputs to the `inputCh`, and then closes the `inputCh`.
    This causes all the workers to terminate when they complete their work. When all
    the workers terminate, the `outputCh` is closed by the goroutine created at #4\.
    When the output processing is complete, `readerWg` is signaled, terminating computation.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '此 `for` 循环将输入发送到 `inputCh`，然后关闭 `inputCh`。这将在工作线程完成其工作后导致所有工作线程终止。当所有工作线程终止时，由
    #4 处创建的 goroutine 将关闭 `outputCh`。当输出处理完成时，`readerWg` 被通知，从而终止计算。'
- en: 'Next, let’s look at the second case:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看第二种情况：
- en: '`inputCh` one by one, and when all inputs are sent, it closes the `inputCh`,
    causing the worker pool to terminate.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐个读取 `inputCh`，当所有输入都发送完毕后，关闭 `inputCh`，这将导致工作线程池终止。
- en: '**Wait workers**: These work the same as in the preceding case.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**等待工作线程**：这些工作与前面的情况相同。'
- en: '`for` loop reads the results from the `outputCh` until it is closed. The `outputCh`
    will be closed when all workers are completed.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`for` 循环从 `outputCh` 读取结果，直到其关闭。当所有工作线程完成时，`outputCh` 将被关闭。'
- en: Connection pools
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接池
- en: A connection pool is useful when dealing with multiple users of a scarce resource
    where establishing an instance of that resource can be expensive, such as a network
    connection, or database connection. Using a pair of channels, you can implement
    an efficient thread-safe connection pool.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 连接池在处理稀缺资源的多个用户时非常有用，例如网络连接或数据库连接，因为建立该资源的实例可能成本高昂。使用一对通道，您可以实现一个高效的线程安全连接池。
- en: How to do it...
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Create a connection pool type with two channels with `PoolSize` capacity :'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个具有 `PoolSize` 容量的连接池类型：
- en: '`available` keeps the connections that are already established, but returned
    to the pool'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`available` 保留已建立但返回到池中的连接'
- en: '`total` keeps the total number of connections, that is, the number of `available`
    plus the number of connections that are actively in use'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`total` 保留连接总数，即 `available` 的数量加上正在积极使用的连接数量。'
- en: To get a connection from the pool, check the `available` channel. If one is
    available, return that. Otherwise, check the `total` connection pool , and create
    a new one if the limit is not exceeded.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要从池中获取连接，检查 `available` 通道。如果有一个可用，则返回它。否则，检查 `total` 连接池，如果未超过限制，则创建一个新的连接。
- en: Users of this pool should return the connections to the pool after they are
    done by sending the connection to the `available` channel.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此池的用户在完成使用后应通过将连接发送到 `available` 通道将连接返回到池中。
- en: 'The following code snippet illustrates such a connection pool:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了这样一个连接池：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Initialize the connection pool with a `PoolSize`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `PoolSize` 初始化连接池：
- en: '[PRE4]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will create two channels, both with `PoolSize` capacity. The `available`
    channel will hold all connections that are returned to the pool while `total`
    will keep the number of established connections.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将创建两个通道，容量均为 `PoolSize`。`available` 通道将保留所有返回到池中的连接，而 `total` 将保留已建立的连接数。
- en: 'To get a new connection, use the following:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取新的连接，请使用以下方法：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This implementation of `GetConnection` illustrates how channel priorities can
    be established. `GetConnection` will return an idle connection if one is available
    in the `available` channel. Otherwise, it will enter the `default` case where
    it will either create a new connection or use one that is returned to the `available`
    channel.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GetConnection` 的这种实现说明了如何建立通道优先级。如果 `available` 通道中有可用空闲连接，`GetConnection`
    将返回一个空闲连接。否则，它将进入 `default` 情况，在那里它将创建一个新的连接或使用返回到 `available` 通道的连接。'
- en: Note the pattern of nested `select` statements in `GetConnection`. This is a
    common pattern for implementing priority among channels. If there is a connection
    available, then `case conn := <-pool.available` will be chosen and the connection
    will be removed from the available connections channel. However, if there are
    no connections available when the first `select` statement is run, the `default`
    case will execute, which will execute a `select` between the `conn:=<-pool.available`
    and `pool.total<-struct{}{}` cases. If the first case becomes available (which
    happens when some other goroutine returns a connection to the pool), that connection
    will be returned to the caller. If the second case becomes available (which happens
    when a connection is closed, thus removing an element from `pool.total`), a new
    connection is created and returned to the caller.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意`GetConnection`中嵌套`select`语句的模式。这是实现通道之间优先级的常见模式。如果有可用的连接，则`case conn := <-pool.available`将被选择，并且连接将从可用的连接通道中移除。然而，如果在第一次`select`语句运行时没有可用的连接，则执行`default`情况，这将执行`conn:=<-pool.available`和`pool.total<-struct{}{}`情况之间的`select`。如果第一个情况变得可用（这发生在其他goroutine将连接返回到池中时），该连接将被返回给调用者。如果第二个情况变得可用（这发生在连接关闭，从而从`pool.total`中移除一个元素时），将创建一个新的连接并返回给调用者。
- en: 'When the client of the pool is done with the connection, it should call the
    following:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当池的客户端完成连接时，它应该调用以下操作：
- en: '[PRE6]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will add the connection to the `available` channel.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会将连接添加到`available`通道。
- en: 'If a connection becomes unresponsive, it can be closed by the client. When
    this happens, the pool should be notified, and `total` should be decremented but
    the connection should not be added to `available`. This is done by the following:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果连接变得无响应，客户端可以将其关闭。当这种情况发生时，池应该被通知，`total`应该递减，但连接不应添加到`available`。这是通过以下操作完成的：
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Pipelines
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: Whenever you have several stages of operations performed on an input, you can
    construct a pipeline. Goroutines and channels can be used to construct high-throughput
    processing pipelines with different structures.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在输入上执行多个操作阶段时，你可以构建一个管道。goroutines和channels可以用来构建具有不同结构的具有高吞吐量的处理管道。
- en: Simple pipeline without fan-out/fan-in
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有扇出/扇入的简单管道
- en: A simple pipeline can be constructed by connecting each stage running in its
    own goroutine using channels. The structure of the pipeline looks like *Figure
    10**.1*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用channels连接在各自goroutine中运行的每个阶段来构建一个简单的管道。管道的结构看起来像*图10**.1*。
- en: '![Figure 10.1: Simple asynchronous pipeline](img/B21961_10_1.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1：简单的异步管道](img/B21961_10_1.jpg)'
- en: 'Figure 10.1: Simple asynchronous pipeline'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：简单的异步管道
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This pipeline uses a separate error channel to report processing errors. We
    use a custom error type to capture diagnostic information:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此管道使用单独的错误通道来报告处理错误。我们使用自定义错误类型来捕获诊断信息：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Every stage is implemented as a function that creates a new goroutine. The
    goroutine reads input data from an input channel, and writes the output to an
    output channel:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段都实现为一个函数，该函数创建一个新的goroutine。该goroutine从输入通道读取输入数据，并将输出写入输出通道：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Stages 2 and 3 are implemented using the same pattern.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段2和3使用相同的模式实现。
- en: 'The pipeline is put together as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 管道按照以下方式组合：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For each stage, follow these steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个阶段，遵循以下步骤：
- en: Create the output channel for the stage. This will be passed into the next stage
    as the `input` channel.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为阶段创建输出通道。这将被传递到下一个阶段作为`input`通道。
- en: The processing goroutine continues running after the stage function returns.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理goroutine在阶段函数返回后继续运行。
- en: Make sure the output channel of this stage is closed when the processing goroutine
    terminates.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在处理goroutine终止时关闭此阶段的输出通道。
- en: Read inputs from the previous stage until the input channel is closed.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上一个阶段读取输入，直到输入通道关闭。
- en: Process the input.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理输入。
- en: If there is an error, send the error to the error channel. No output will be
    generated.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果发生错误，将错误发送到错误通道。不会生成任何输出。
- en: Send the output to the next stage.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输出发送到下一个阶段。
- en: Warning
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Each stage runs in its own goroutine. That means that once you pass the payload
    to the next stage, you should not access that payload in the current stage. If
    the payload contains pointers, or if the payload itself is a pointer, data races
    may occur.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段都在自己的goroutine中运行。这意味着一旦你将有效负载传递到下一个阶段，就不应该在当前阶段访问该有效负载。如果有效负载包含指针，或者有效负载本身就是一个指针，可能会发生数据竞争。
- en: 'The pipeline setup is done as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 管道设置如下：
- en: Create the input channel and the error channel.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建输入通道和错误通道。
- en: Attach stages to form the pipeline. The output of stage `n` becomes the input
    of stage `n+1`. The output of the last stage becomes the `output` channel.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将阶段附加到管道中。阶段 `n` 的输出成为阶段 `n+1` 的输入。最后一个阶段的输出成为 `output` 通道。
- en: Send the inputs to the input channel asynchronously. When all inputs are sent,
    close the input channel. This will terminate the first stage, closing its output
    channel, which is also the input channel for stage 2\. This goes on until all
    stages exit.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 异步将输入发送到输入通道。当所有输入都发送后，关闭输入通道。这将终止第一个阶段，关闭其输出通道，该输出通道也是阶段2的输入通道。这个过程一直持续到所有阶段退出。
- en: Start a goroutine to listen and record errors.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个goroutine来监听和记录错误。
- en: Collect the outputs.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集输出。
- en: Close the error channel so that the error collecting goroutine terminates.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭错误通道，以便错误收集goroutine终止。
- en: Pipeline with worker pools as stages
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以工人池作为阶段的管道
- en: The previous example used a single worker for each stage. You can increase the
    throughput of a pipeline by replacing each stage with worker pools. The resulting
    pipeline is depicted in *Figure 10**.2*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子为每个阶段使用了一个工作者。您可以通过将每个阶段替换为工作池来提高管道的吞吐量。结果管道如图 *图10**.2* 所示。
- en: '![Figure 10.2: Pipeline with worker pools as stages](img/B21961_10_2.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2：作为阶段的工人池的管道](img/B21961_10_2.jpg)'
- en: 'Figure 10.2: Pipeline with worker pools as stages'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：作为阶段的工人池的管道
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Each stage now creates multiple goroutines, all reading from the same input
    channel (fan-out). The output of each worker is written to a common output channel
    (fan-in), which becomes the input for the next stage. We can no longer close the
    stage output channel whenever the input channel is closed because there are now
    multiple goroutines writing to that output channel. Instead, we use a wait group
    and a second goroutine to close the output when all of the processing goroutines
    terminate:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段现在创建多个goroutine，所有goroutine都从相同的输入通道读取（扇出）。每个工作者的输出写入一个公共输出通道（扇入），它成为下一阶段的输入。由于现在有多个goroutine写入该输出通道，因此我们不能再在关闭输入通道时关闭阶段输出通道。相反，我们使用一个wait
    group和一个第二个goroutine在所有处理goroutine终止时关闭输出：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The pipeline is constructed as in the previous case:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 管道构建与上一个案例相同：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'For each stage, follow these steps:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个阶段，遵循以下步骤：
- en: Create the output channel, which will become the input channel for the next
    stage.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建输出通道，它将成为下一阶段的输入通道。
- en: There are multiple goroutines reading from the same input channel in a for-range
    loop, so when the input channel is closed, all those goroutines will terminate.
    However, we cannot `defer close` the output channel, because that will result
    in closing the output channel multiple times (which will panic). So instead, we
    use a `WaitGroup` to keep track of the worker goroutines. A separate goroutine
    waits on that wait group, and when all goroutines terminate, it closes the output
    channel.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在for-range循环中，有多个goroutine从相同的输入通道读取，因此当输入通道关闭时，所有这些goroutine都将终止。然而，我们不能使用
    `defer close` 关闭输出通道，因为这会导致输出通道多次关闭（这将引发panic）。因此，我们使用 `WaitGroup` 来跟踪工作者goroutine。一个单独的goroutine等待该wait
    group，当所有goroutine终止时，它关闭输出通道。
- en: Create `nInstances` goroutines that all read from the same input channel, and
    write to the output channel. In case of an error, the workers send the error to
    the error channel.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `nInstances` 个goroutine，它们都从相同的输入通道读取，并将输出写入输出通道。在发生错误的情况下，工作者将错误发送到错误通道。
- en: This is the goroutine that waits for the worker goroutines to finish. When they
    do, it closes the output channel.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是等待工作者goroutine完成的goroutine。当它们完成时，它关闭输出通道。
- en: The pipeline setup is identical to the previous section, except that the initialization
    also sends the worker pool size to stage functions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 管道设置与上一节相同，不同之处在于初始化时还会将工作池大小发送到阶段函数。
- en: Pipeline with fan-out and fan-in
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 具有扇出和扇入的管道
- en: 'In this setup, stages are wired one after the other using dedicated channels,
    as shown in *Figure 10**.3*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设置中，阶段通过专用通道依次连接，如图 *图10**.3* 所示：
- en: '![Figure 10.3: Pipeline with fan-out and fan-in](img/B21961_10_3.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3：具有扇出和扇入的管道](img/B21961_10_3.jpg)'
- en: 'Figure 10.3: Pipeline with fan-out and fan-in'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：具有扇出和扇入的管道
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Each pipeline stage reads from a given input channel, and writes to an output
    channel, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每个管道阶段从给定的输入通道读取，并写入输出通道，如下所示：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A separate `fanIn` function takes a list of output channels, and combines them
    using a goroutine listening to each channel:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个独立的`fanIn`函数接收一个输出通道列表，并使用监听每个通道的goroutine将它们合并：
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The pipeline is setup in a for-loop by combining the output of each stage to
    the input of the next stage. The resulting output channels are all directed to
    the `fanIn` function:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是通过将每个阶段的输出组合到下一个阶段输入中，在for循环中设置的。生成的输出通道都导向`fanIn`函数：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The worker stages are identical to the simple pipeline case. The fan-in stage
    works as follows.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 工作阶段与简单的管道情况相同。fan-in阶段的工作方式如下。
- en: For every output channel, the fan-in function creates a goroutine that reads
    data from that output channel and writes to a common channel. This common channel
    becomes the combined output channel of the pipeline. The fan-in function creates
    another goroutine that waits on a `wait` group that keeps track of all the goroutines.
    When they are all complete, this goroutine closes the output channel.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个输出通道，fan-in函数创建一个goroutine，该goroutine从该输出通道读取数据并将其写入一个公共通道。这个公共通道成为管道的合并输出通道。fan-in函数创建另一个goroutine，该goroutine等待一个`wait`组，该组跟踪所有goroutine。当它们都完成时，这个goroutine关闭输出通道。
- en: The `main` constructs the pipeline by connecting the output of each stage to
    the input of the next. The output channels of the last stage are stored in a slice
    and passed to the fan-in function. The output channel of the fan-in function becomes
    the combined output of the pipeline.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`通过连接每个阶段的输出到下一个阶段的输入来构建管道。最后一个阶段的输出通道被存储在一个切片中，并传递给fan-in函数。fan-in函数的输出通道成为管道的合并输出。'
- en: 'Note that all these pipeline variations use a separate error channel. An alternative
    approach is to store any error in the payload and pass it to the next stage. If
    the incoming payload has a non-nil error, all stages pass it to the next one,
    so the payload can be recorded as an error at the end of the pipeline:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有这些管道变体都使用一个单独的错误通道。另一种方法是存储任何错误在有效负载中，并将其传递到下一个阶段。如果传入的有效负载有一个非nil的错误，所有阶段都会将其传递到下一个阶段，因此有效负载可以在管道的末尾记录为错误：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Also note that except for the simple pipeline case, they also return results
    out of order because multiple inputs go through the pipeline at any given moment,
    and there is no guarantee on the order they arrive at the output.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，除了简单的管道情况外，它们还以无序的方式返回结果，因为任何给定时刻有多个输入通过管道，并且无法保证它们到达输出的顺序。
- en: Working with large result sets
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理大型结果集
- en: When working with potentially large result sets, it may not always be feasible
    to load all data to memory and work on it. You may need to stream data elements
    in a controlled manner. This section shows how to deal with such situations using
    concurrency primitives.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理可能很大的结果集时，可能并不总是可行将所有数据加载到内存中并对其进行处理。你可能需要以受控的方式流式传输数据元素。本节展示了如何使用并发原语处理此类情况。
- en: Streaming results using a goroutine
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用goroutine进行流式结果
- en: In this use case, a goroutine sends the results of a query via a channel. A
    context can be used to cancel the streaming goroutine.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在此用例中，一个goroutine通过通道发送查询结果。可以使用上下文来取消流式goroutine。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a data structure that holds the data elements and error information:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含数据元素和错误信息的结构体：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `StreamResults` function runs the database query and creates a goroutine
    that iterates the query results. The goroutine sends each result via a channel:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamResults`函数运行数据库查询并创建一个goroutine，该goroutine迭代查询结果。goroutine通过通道发送每个结果：'
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use the streaming results as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如下使用流式结果：
- en: '[PRE19]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Even though we looked at a database query example, this pattern is useful any
    time you are dealing with a function that generates potentially large amounts
    of data. Instead of loading all data into memory, this pattern loads and processes
    data items one by one.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们查看了一个数据库查询示例，但这种模式在处理任何生成大量数据的函数时都很有用。而不是将所有数据加载到内存中，这种模式一次加载和处理一个数据项。
- en: The `StreamResults` generator function starts a goroutine closure that captures
    the context and additional information necessary to produce results (in this case,
    a `sql.Rows` instance). The generator function creates a channel and returns immediately.
    The goroutine collects results and sends them to the channel. When all results
    are processed or an error is detected, the channel is closed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamResults`生成函数启动一个goroutine闭包，该闭包捕获生成结果所需的环境和附加信息（在这种情况下，一个`sql.Rows`实例）。生成函数创建一个通道并立即返回。goroutine收集结果并将它们发送到通道。当所有结果都处理完毕或检测到错误时，通道被关闭。'
- en: It is now up to the caller to communicate with the goroutine. The caller collects
    the results from the channel until the channel is closed, and processes them one
    by one. The caller also checks the error field in the received message to handle
    any errors detected by the goroutine.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在轮到调用者与goroutine进行通信。调用者从通道中收集结果，直到通道关闭，并逐个处理它们。调用者还会检查接收到的消息中的错误字段，以处理goroutine检测到的任何错误。
- en: This scheme uses a cancelable context. When the context is canceled, the goroutine
    sends another message through the channel before closing it, so the caller must
    drain the channel if context cancellation happens.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此方案使用可取消的上下文。当上下文被取消时，goroutine在关闭通道之前通过通道发送另一条消息，因此如果发生上下文取消，调用者必须清空通道。
