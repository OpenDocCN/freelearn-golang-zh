<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer023">
			<h1 id="_idParaDest-275" class="chapter-number"><a id="_idTextAnchor276"/>11</h1>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor277"/>Working with JSON</h1>
			<p>JSON is an acronym for JavaScript Object Notation. It is a popular format for data interchange <a id="_idIndexMarker412"/>because JSON objects closely resemble structured types (<strong class="source-inline">struct</strong>s in Go), and it is text-based encoding, making the encoded data human-readable. It supports arrays, objects (name-value pairs), and relatively few basic types (strings, numbers, booleans, and <strong class="source-inline">null</strong>). These properties make JSON a fairly easy format to <span class="No-Break">work with.</span></p>
			<p>Encoding refers to the process of transforming data elements into a sequence of bytes. When you encode (or marshal) data elements in JSON, you create a textual representation of those data elements while following JSON syntax rules. The reverse process, decoding (or unmarshaling) assigns JSON values to Go objects. The encoding process is lossy: you have to describe data values as text, and that is not always obvious for complex data types. When you decode such data, you have to know how to interpret the textual representation so you can parse the JSON <span class="No-Break">representation correctly.</span></p>
			<p>In this chapter, we will first look at the encoding and decoding of basic data types. Then we will look at some recipes that deal with more complicated data types and use cases. You should use these recipes as a guide when implementing your own solutions. These recipes demonstrate solutions to particular use cases, and you may need to adopt them for your <span class="No-Break">specific needs.</span></p>
			<p>This chapter includes the <span class="No-Break">following recipes:</span></p>
			<ul>
				<li><span class="No-Break">Encoding structs</span></li>
				<li>Dealing with <span class="No-Break">embedded structs</span></li>
				<li>Encoding without <span class="No-Break">defining structs</span></li>
				<li><span class="No-Break">Decoding structs</span></li>
				<li>Decoding with interfaces, maps, <span class="No-Break">and slices</span></li>
				<li>Other ways of <span class="No-Break">decoding numbers</span></li>
				<li>Marshaling/unmarshaling custom <span class="No-Break">data types</span></li>
				<li>Custom marshaling/unmarshaling of <span class="No-Break">object keys</span></li>
				<li>Dynamic <span class="No-Break">field names</span></li>
				<li>Polymorphic <span class="No-Break">data structures</span></li>
				<li>Streaming <span class="No-Break">JSON data</span></li>
			</ul>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor278"/>Marshaling/unmarshaling basics</h2>
			<p>The <strong class="source-inline">encoding/json</strong> package of <a id="_idIndexMarker413"/>the standard library provides convenient functions and conventions to encode/decode <span class="No-Break">JSON data.</span></p>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor279"/>Encoding structs</h1>
			<p>Go struct types <a id="_idIndexMarker414"/>are usually encoded as JSON objects. This section shows the standard library tools that deal with the encoding of <span class="No-Break">data types.</span></p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor280"/>How to do it...</h2>
			<ol>
				<li>Use <strong class="source-inline">json</strong> tags to annotate struct fields with their <span class="No-Break">JSON keys:</span></li>
			</ol>
			<pre class="source-code">
type Config struct {
  Version   string `json:"ver"`  // Encoded as "ver"
  Name      string               // Encoded as "Name"
  Type      string `json:"type,omitempty"` // Encoded as "type",
                                           // and will be omitted if 
                                           // empty
  Style     string `json:"-"`    // Not encoded
  value     string               // Unexported field, not encoded
  kind      string `json:"kind"` // Unexported field, not encoded
}</pre>			<ol>
				<li value="2">Use the <strong class="source-inline">json.Marshal</strong> function to encode Go data objects in JSON. The standard <a id="_idIndexMarker415"/>library uses the following conventions for <span class="No-Break">basic types:</span></li>
			</ol>
			<table id="table001-1" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Go Declaration</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Value</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">JSON output</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">NumberValue </strong><span class="No-Break"><strong class="source-inline">int json:”num”</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">0</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">“</strong><span class="No-Break"><strong class="source-inline">num”: 0</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">NumberValue *</strong><span class="No-Break"><strong class="source-inline">int json:”num”</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">nil</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">“</strong><span class="No-Break"><strong class="source-inline">num”: null</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">NumberValue *</strong><span class="No-Break"><strong class="source-inline">int json:”num,omitempty”</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">nil</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">omitted</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">BoolValue </strong><span class="No-Break"><strong class="source-inline">bool json:”bvalue”</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">true</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">“</strong><span class="No-Break"><strong class="source-inline">bvalue”: true</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">BoolValue *</strong><span class="No-Break"><strong class="source-inline">bool json:”bvalue”</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">nil</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">“</strong><span class="No-Break"><strong class="source-inline">bvalue”: null</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">BoolValue *</strong><span class="No-Break"><strong class="source-inline">bool json:”bvalue,omitempty”</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">nil</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">omitted</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">StringValue </strong><span class="No-Break"><strong class="source-inline">string json:”svalue”</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">“</strong><span class="No-Break"><strong class="source-inline">str”</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">“</strong><span class="No-Break"><strong class="source-inline">svalue”:”str”</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">StringValue </strong><span class="No-Break"><strong class="source-inline">string json:”svalue”</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">“”</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">“</strong><span class="No-Break"><strong class="source-inline">svalue”:””</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">StringValue </strong><span class="No-Break"><strong class="source-inline">string json:”svalue,omitempty”</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">“</strong><span class="No-Break"><strong class="source-inline">str”</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">“</strong><span class="No-Break"><strong class="source-inline">svalue”:”str”</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">StringValue </strong><span class="No-Break"><strong class="source-inline">string json:”svalue,omitempty”</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">“”</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">omitted</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">StringValue *</strong><span class="No-Break"><strong class="source-inline">string `json:”svalue”</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">nil</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">“</strong><span class="No-Break"><strong class="source-inline">svalue”: null</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">StringValue *</strong><span class="No-Break"><strong class="source-inline">string `json:”svalue,omitempty”</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">nil</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">omitted</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<ul>
				<li>The <strong class="source-inline">struct</strong> and <strong class="source-inline">map</strong> types are marshaled as <span class="No-Break">JSON objects</span></li>
				<li>Slice and array types are marshaled as <span class="No-Break">JSON arrays</span></li>
				<li>If a type implements the <strong class="source-inline">json.Marshaler</strong> interface, then the <strong class="source-inline">json.Marshaler.MarshalJSON</strong> method of the variable instance is called to <span class="No-Break">encode data</span></li>
				<li>If a type implements the <strong class="source-inline">encoding.TextMarshaler</strong> interface, then the value is <a id="_idIndexMarker416"/>encoded as a JSON string, and the string value is obtained from the <strong class="source-inline">encoding.TextMarshaler.MarshalText</strong> method of <span class="No-Break">the value</span></li>
				<li>Anything else will fail <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">UnsupportedValueError</strong></span></li>
			</ul>
			<p class="callout-heading">Tip</p>
			<p class="callout">Only exported fields of struct types can <span class="No-Break">be marshaled.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If there are no JSON tags for a struct field, its JSON object key will be the same as the <span class="No-Break">field name.</span></p>
			<p>Consider the following <span class="No-Break">code segment:</span></p>
			<pre class="source-code">
type Config struct {
  Version   string `json:"ver"`  // Encoded as "ver"
  Name      string               // Encoded as "Name"
  Type      string `json:"type,omitempty"` // Encoded as "type",
                                           // and will be omitted if 
                                           // empty
  Style     string `json:"-"`    // Not encoded
  value     string               // Unexported field, not encoded
  kind      string `json:"kind"` // Unexported field, not encoded
}
...
cfg := Config{
     Version: "1.1",
     Name:    "name",
     Type:    "example",
     Style:   "json",
     value:   "example config value",
     kind:    "test",
}
data, err := json.Marshal(cfg)
fmt.Println(string(err))</pre>			<p>This <a id="_idIndexMarker417"/>prints <span class="No-Break">the following:</span></p>
			<pre class="source-code">
{"ver":"1.1","Name":"name","type":"example"}</pre>			<p class="callout-heading">Tip</p>
			<p class="callout">The order of fields in the encoded JSON object is the same as the order in which fields <span class="No-Break">are declared.</span></p>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor281"/>Dealing with embedded structs</h1>
			<p>Fields <a id="_idIndexMarker418"/>of a struct type will be encoded as JSON objects. If there are embedded structs, then the encoder has two options: encode the embedded struct at the same level as the enclosing struct or as a new <span class="No-Break">JSON object.</span></p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor282"/>How to do it...</h2>
			<ol>
				<li>Use JSON tags to name enclosing struct fields and the embedded <span class="No-Break">struct fields:</span><pre class="source-code">
type Enclosing struct {
     Field string `json:"field"`
     Embedded
}
type Embedded struct {
     Field string `json:"embeddedField"`
}</pre></li>				<li>Use <strong class="source-inline">json.Marshal</strong> to encode <a id="_idIndexMarker419"/>the struct as a <span class="No-Break">JSON object:</span><pre class="source-code">
enc := Enclosing{
     Field: "enclosing",
     Embedded: Embedded{
          Field: "embedded",
     },
}
data, err = json.Marshal(enc)
// {"field":"enclosing","embeddedField":"embedded"}</pre></li>				<li>Adding a <strong class="source-inline">json</strong> tag to the embedded struct will create a nested <span class="No-Break">JSON object:</span><pre class="source-code">
type Enclosing struct {
     Field string `json:"field"`
     Embedded `json:"embedded"`
}
type Embedded struct {
     Field string `json:"embeddedField"`
}
...
enc := Enclosing{
     Field: "enclosing",
     Embedded: Embedded{
          Field: "embedded",
     },
}
data, err = json.Marshal(enc)
// {"field":"enclosing","embedded":{"embeddedField":"embedded"}}</pre></li>			</ol>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor283"/>Encoding without defining structs</h1>
			<p>Basic <a id="_idIndexMarker420"/>data types, slices, and maps can be used to encode <span class="No-Break">JSON data.</span></p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor284"/>How to do it...</h2>
			<ul>
				<li>Use a map to represent <span class="No-Break">JSON objects:</span><pre class="source-code">
config:=map[string]any{
  "ver": "1.0",
  "Name": "config",
  "type": "example",
  }
data, err:=json.Marshal(config)
// `{"ver":"1.0","Name":"config","type":"example"}`</pre></li>				<li>Use a slice to represent <span class="No-Break">JSON arrays:</span><pre class="source-code">
numbersWithNil:=[]any{ 1, 2, nil, 3 }
data, err:=json.Marshal(numbersWithNil)
// `[1,2,null,3]`</pre></li>				<li>Match the <a id="_idIndexMarker421"/>desired JSON structure to <span class="No-Break">Go equivalents:</span><pre class="source-code">
configurations:=map[string]map[string]any {
  "cfg1": {
     "ver": "1.0",
     "Name": "config1",
  },
  "cfg2": {
     "ver": "1.1",
     "Name" : "config2",
 },
}
data, err:=json.Marshal(configurations)
// {"cfg1":{"Name":"config1","ver":"1.0"},
"cfg2":{"Name":"config2","ver":"1.1"}}`</pre></li>			</ul>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor285"/>Decoding structs</h1>
			<p>Encoding Go data objects in JSON is a relatively easy task: well-defined data types and semantics <a id="_idIndexMarker422"/>are translated into a less expressive representation, usually resulting in some information loss. For instance, an integer variable and a <strong class="source-inline">float64</strong> variable may be encoded to give identical output. Because of this, decoding JSON data is usually <span class="No-Break">more difficult.</span></p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor286"/>How to do it...</h2>
			<ol>
				<li>Use JSON tags to map JSON keys to <span class="No-Break">struct fields.</span></li>
				<li>Use the <strong class="source-inline">json.Unmarshal</strong> function to decode JSON data into Go data objects. The standard <a id="_idIndexMarker423"/>library uses the following conventions for <span class="No-Break">basic types:</span></li>
			</ol>
			<table id="table002" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">JSON Input</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Go type</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Result</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">strValue"</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">string</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">strValue"</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">1 (number)</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">int</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">1</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">1.2 (number)</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">int</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">error</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">1.2 (number)</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">float64, float32</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">1.2</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">true</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">bool</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">true</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">null</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">string</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Variable <span class="No-Break">left unmodified</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">null</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">int</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Variable <span class="No-Break">left unmodified</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">strValue"</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">*</strong><span class="No-Break"><strong class="source-inline">string</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">strValue"</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">null</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">*</strong><span class="No-Break"><strong class="source-inline">string</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">nil</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">1</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">*</strong><span class="No-Break"><strong class="source-inline">int</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">1</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">null</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">*</strong><span class="No-Break"><strong class="source-inline">int</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">nil</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">true</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">*</strong><span class="No-Break"><strong class="source-inline">bool</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">true</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">null</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">*</strong><span class="No-Break"><strong class="source-inline">bool</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">nil</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>If the Go <a id="_idIndexMarker424"/>type is <strong class="source-inline">interface{}</strong>, the standard library creates objects using the <span class="No-Break">following convention:</span></p>
			<table id="table003" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">JSON Input</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Result</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">strValue"</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">strValue"</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">1</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">float64(1)</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">1.2</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">float64(1.2)</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">true</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">true</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">null</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">nil</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">JSON Object</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">map[string]any</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">JSON array</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">[]</strong><span class="No-Break"><strong class="source-inline">any</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<ul>
				<li>If the target Go type implements the <strong class="source-inline">json.Unmarshaler</strong> interface, then <strong class="source-inline">json.Unmarshal.UnmarshalJSON</strong> is called to decode data. This operation may involve creating a new instance of the target type <span class="No-Break">if necessary.</span></li>
				<li>If the target Go type implements the <strong class="source-inline">encoding.TextUnmarshaler</strong> interface and the input is a quoted JSON string, then <strong class="source-inline">encoding.TextUnmarshaler.UnmarshalText</strong> is called to decode <span class="No-Break">the value.</span></li>
				<li>Anything <a id="_idIndexMarker425"/>else will fail <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">UnsupportedValueError</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p class="callout-heading">Tip</p>
			<p class="callout">Numeric values may cause confusion if the JSON input includes values of various numeric types. For instance, if a JSON numeric value is unmarshaled to an <strong class="source-inline">int</strong> value, it will work if the JSON data is representable as an integer, but fail if the JSON data has a <span class="No-Break">floating-point value.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The JSON decoder will never change the unexported fields of a struct. The decoder uses reflection, and only the exported fields are accessible <span class="No-Break">via reflection.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">JSON fields that do not have matching Go fields will <span class="No-Break">be ignored.</span></p>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor287"/>Decoding with interfaces, maps, and slices</h1>
			<p>When decoding <a id="_idIndexMarker426"/>Go values to JSON, the Go value types dictate how <a id="_idIndexMarker427"/>JSON encoding will be done. JSON does not have a rich <a id="_idIndexMarker428"/>type system like Go. Valid JSON types are string, number, boolean, object, array, and null. When you decode JSON data into a Go struct, it is still the Go type system that dictates how JSON data should be interpreted. But when you decode JSON into an <strong class="source-inline">interface{}</strong>, things change. Now it is the JSON data that dictates how Go values should be constructed, and this sometimes causes <span class="No-Break">unexpected results.</span></p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor288"/>How to do it...</h2>
			<p>To unmarshal <a id="_idIndexMarker429"/>JSON data into an interface, use <span class="No-Break">the following:</span></p>
			<pre class="source-code">
var output interface{}
err:=json.Unmarshal(jsonData,&amp;output)</pre>			<p>This <a id="_idIndexMarker430"/>creates <a id="_idIndexMarker431"/>an object tree based on the following <span class="No-Break">translation rules:</span></p>
			<table id="table004" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">JSON</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Go</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Object</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">map[string]interface{}</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Array</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">[]</strong><span class="No-Break"><strong class="source-inline">interface{}</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">number</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">float64</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">boolean</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">bool</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">string</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">string</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">null</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">nil</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor289"/>Other ways of decoding numbers</h1>
			<p>When <a id="_idIndexMarker432"/>decoded into an <strong class="source-inline">interface{}</strong>, JSON numbers are converted to <strong class="source-inline">float64</strong>. This is not always the desired result. You can use <span class="No-Break"><strong class="source-inline">json.Number</strong></span><span class="No-Break"> instead.</span></p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor290"/>How to do it...</h2>
			<p>Use <strong class="source-inline">json.Decoder</strong> <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">UseNumber</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
var output interface{}
decoder:=json.NewDecoder(strings.NewReader(`[1.1,2,3,4.4]`))
// Tell the decoder to use json.Number instead of float64
decoder.UseNumber()
err:=decoder.Decode(&amp;output)
// [1.1 2 3 4.4]</pre>			<p>Every <a id="_idIndexMarker433"/>element of <strong class="source-inline">output</strong> in the preceding example is an instance of <strong class="source-inline">json.Number</strong>. You can translate it to an <strong class="source-inline">int</strong>, <strong class="source-inline">float64</strong>, or <strong class="source-inline">big.Int</strong> <span class="No-Break">as necessary.</span></p>
			<h1 id="_idParaDest-290"><a id="_idTextAnchor291"/>Dealing with missing and optional values</h1>
			<p>You usually <a id="_idIndexMarker434"/>have to deal with JSON <a id="_idIndexMarker435"/>input with missing fields and have to generate JSON where empty fields are omitted. This section provides recipes showing how to deal with <span class="No-Break">these scenarios.</span></p>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor292"/>Omitting empty fields when encoding</h1>
			<p>Omitting empty fields <a id="_idIndexMarker436"/>from JSON encoding usually saves space and makes the JSON more reader-friendly. However, what is meant by “empty” should <span class="No-Break">be clear.</span></p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor293"/>How to do it...</h2>
			<p>Use the <strong class="source-inline">,omitempty</strong> JSON tag to omit empty string values, zero integer/floating-point values, zero <strong class="source-inline">time.Duration</strong> values, and <strong class="source-inline">nil</strong> <span class="No-Break">pointer values.</span></p>
			<p>The <strong class="source-inline">,omitempty</strong> tag does not work for <strong class="source-inline">time.Time</strong> values. Use <strong class="source-inline">*time.Time</strong> and set it to <strong class="source-inline">nil</strong> to omit empty <span class="No-Break">time values:</span></p>
			<pre class="source-code">
type Config struct {
    ...
     Type       string `json:"type,omitempty"`
     IntValue   int     `json:"intValue,omitempty"`
     FloatValue float64 `json:"floatValue,omitempty"`
     When       *time.Time    `json:"when,omitempty"`
     HowLong    time.Duration `json:"howLong,omitempty"`
}</pre>			<p>Sometimes <a id="_idIndexMarker437"/>it is important to distinguish between an empty string and a null string. In JavaScript and JSON, <strong class="source-inline">null</strong> is a valid value for strings. If that is the case, <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">*string</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type Config struct {
  Value  *string `json:"value,omitempty"`
  ...
}
...
emptyString := ""
emptyValue := Config {
   Value: &amp;emptyString,
}
// JSON output: { "value": "" }
nullValue := Config {
   Value: nil,
}
// JSON output: {}</pre>			<h1 id="_idParaDest-293"><a id="_idTextAnchor294"/>Dealing with missing fields when decoding</h1>
			<p>There are several use cases where developers have to deal with sparse JSON data that does not <a id="_idIndexMarker438"/>include all data fields. For instance, a partial update API call may accept a JSON object that contains only those fields that should be updated, without modifying any unspecified data field. In such cases, it becomes important to identify which fields were provided. Then there are use cases where it is appropriate to assume default values for <span class="No-Break">missing fields.</span></p>
			<h2 id="_idParaDest-294"><a id="_idTextAnchor295"/>How to do it...</h2>
			<p>If you want to determine which fields are specified in a JSON input, use pointer fields. Any fields missing in the input will remain <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">nil</strong></span><span class="No-Break">.</span></p>
			<p>To provide default values for missing fields, initialize those fields to their default values <span class="No-Break">before unmarshaling:</span></p>
			<pre class="source-code">
type APIRequest struct {
   // If type is not specified, it will be nil
   Type    *string `json:"type"`
   // There will be a default value for seq
   Seq     int     `json:"seq"`
   ...
}
func handler(w http.ResponseWriter,r *http.Request) {
  data, err:=io.ReadAll(r.Body)
  if err!=nil {
     http.Error(w, "Bad request",http.StatusBadRequest)
     return
  }
  req:=APIRequest{
     Seq: 1,  // Set the default value
  }
  if err:=json.Unmarshal(data, &amp;req); err!=nil {
     http.Error(w, "Bad request", http.StatusBadRequest)
     return
  }
  // Check which fields are provided
  if req.Type!=nil {
     ...
  }
  // If seq is provided in the input, req.Seq will be set to that 
  // value. Otherwise, it will be 1.
  if req.Seq==1 {
    ...
  }
}</pre>			<h2 id="_idParaDest-295"><a id="_idTextAnchor296"/>Customizing JSON encoding/decoding</h2>
			<p>Sometimes <a id="_idIndexMarker439"/>JSON encoding of certain data <a id="_idIndexMarker440"/>structures does not match their representations in the program. When this happens, you have to customize how a certain data element is encoded to JSON or decoded <span class="No-Break">from JSON.</span></p>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor297"/>Marshaling/unmarshaling custom data types</h1>
			<p>Use these <a id="_idIndexMarker441"/>recipes when you have data elements whose JSON <a id="_idIndexMarker442"/>representation needs to be <span class="No-Break">generated programmatically.</span></p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor298"/>How to do it...</h2>
			<p>To control how a data object is encoded in JSON, implement the <span class="No-Break"><strong class="source-inline">json.Marshaler</strong></span><span class="No-Break"> interface:</span></p>
			<pre class="source-code">
// TypeAndID is encoded to JSON as type:id
type TypeAndID struct {
  Type string
  ID int
}
// Implementation of json.Marshaler
func (t TypeAndID) MarshalJSON() (out []byte, err error) {
  s := fmt.Sprintf(`"%s:%d"`,t.Type,t.ID)
  out=[]byte(s)
  return
}</pre>			<p>To <a id="_idIndexMarker443"/>control how a data object is decoded from JSON, implement <a id="_idIndexMarker444"/>the <span class="No-Break"><strong class="source-inline">json.Unmarshaler</strong></span><span class="No-Break"> interface</span><span class="No-Break">:</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">An unmarshaler must have a <span class="No-Break">pointer receiver.</span></p>
			<pre class="source-code">
// Implementation of json.Unmarshaler. Note the pointer receiver
func (t *TypeAndID) UnmarshalJSON(in []byte) (err error) {
    if len(in)&lt;2 || in[0] != '"' || in[len(in)-1] != '"' {
        err = ErrInvalidTypeAndID
        return
    }
    in = in[1 : len(in)-1]
    parts := strings.Split(string(in), ":")
    if len(parts) != 2 {
        err = ErrInvalidTypeAndID
        return
     }
    // The second part must be a valid integer
    t.ID, err = strconv.Atoi(parts[1])
    if err != nil {
        return
    }
    t.Type = parts[0]
    return
}</pre>			<h1 id="_idParaDest-298"><a id="_idTextAnchor299"/>Custom marshaling/unmarshaling of object keys</h1>
			<p>Maps are <a id="_idIndexMarker445"/>marshaled/unmarshaled as JSON objects. But if <a id="_idIndexMarker446"/>you have a map that has keys other than a string type, how can you marshal/unmarshal it <span class="No-Break">to JSON?</span></p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor300"/>How to do it...</h2>
			<p>The solution depends on the exact type of <span class="No-Break">the key:</span></p>
			<ol>
				<li>Maps with key types derived from string or integer types can be marshaled/unmarshaled using the standard <span class="No-Break">library methods:</span><pre class="source-code">
type Key int64
func main() {
     var m map[Key]int
     err := json.Unmarshal([]byte(`{"123":123}`), &amp;m)
    if err!=nil {
       panic(err)
    }
     fmt.Println(m[123]) // Prints 123
}</pre></li>				<li>If map <a id="_idIndexMarker447"/>keys require additional processing <a id="_idIndexMarker448"/>for marshaling/unmarshaling, implement the <strong class="source-inline">encoding.TextMarshaler</strong> and <span class="No-Break"><strong class="source-inline">encoding.TextUnmarshaler</strong></span><span class="No-Break"> interfaces:</span><pre class="source-code">
// Key is an uint that is encoded as an hex strings for JSON key
type Key uint
func (k *Key) UnmarshalText(data []byte) error {
     v, err := strconv.ParseInt(string(data), 16, 64)
     if err != nil {
          return err
     }
     *k = Key(v)
     return nil
}
func (k Key) MarshalText() ([]byte, error) {
     s := strconv.FormatUint(uint64(k), 16)
     return []byte(s), nil
}
func main() {
     input := `{
    "13AD": "5037",
    "3E22": "15906",
    "90A3": "37027"
  }`
     var data map[Key]string
     if err := json.Unmarshal([]byte(input), &amp;data); err != nil {
          panic(err)
     }
     fmt.Println(data)
     d, err := json.Marshal(map[Key]any{
          Key(123): "123",
          Key(255): "255",
     })
     if err != nil {
          panic(err)
     }
     fmt.Println(string(d))
}</pre></li>			</ol>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor301"/>Dynamic field names</h2>
			<p>There are cases <a id="_idIndexMarker449"/>where the field names (object keys) are not constant. For example, an API may prefer to return a list of objects as a JSON object where unique identifiers of each object are the key. In such cases, it is not possible to use <strong class="source-inline">json</strong> tags in <span class="No-Break">a struct.</span></p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor302"/>How to do it...</h2>
			<p>Use a <strong class="source-inline">map[string]ValueType</strong> to represent an object with dynamic <span class="No-Break">field names:</span></p>
			<pre class="source-code">
type User struct {
     Name string `json:"name"`
     Type string `json:"type"`
}
type Users struct {
     Users map[string]User `json:"users"`
}
func main() {
     input := `{
  "users": {
      "abb64dfe-d4a8-47a5-b7b0-7613fe3fd11f": {
         "name": "John",
         "type": "admin"
      },
      "b158161c-0588-4c67-8e4b-c07a8978f711": {
         "name": "Amy",
         "type": "editor"
      }
   }
  }`
     var users Users
     if err := json.Unmarshal([]byte(input), &amp;users); err != nil {
          panic(err)
     }
}</pre>			<h2 id="_idParaDest-302"><a id="_idTextAnchor303"/>Polymorphic data structures</h2>
			<p>A polymorphic data structure <a id="_idIndexMarker450"/>can be one of several different types that share a common interface. The actual type is determined at runtime. For runtime objects, the Go type system ensures type-safe operations using such fields. With the use of interfaces, polymorphic objects can be marshaled as JSON easily. A problem arises when you need to unmarshal a polymorphic JSON object. In this recipe, we will look at one way of <span class="No-Break">achieving this.</span></p>
			<h1 id="_idParaDest-303"><a id="_idTextAnchor304"/>Custom unmarshaling with two passes</h1>
			<p>The first pass <a id="_idIndexMarker451"/>unmarshals discriminator fields while leaving the rest of the input unprocessed. Based on the discriminator, the concrete instance of the object is constructed <span class="No-Break">and unmarshaled.</span></p>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor305"/>How to do it...</h2>
			<ol>
				<li>We will work with an example <strong class="source-inline">Key</strong> structure in this section. The <strong class="source-inline">Key</strong> structure holds different types of cryptographic public keys, whose type is given in a <span class="No-Break"><strong class="source-inline">Type</strong></span><span class="No-Break"> field:</span><pre class="source-code">
type KeyType string
const (
     KeyTypeRSA     = "rsa"
     KeyTypeED25519 = "ed25519"
)
type Key struct {
     Type KeyType          `json:"type"`
     Key  crypto.PublicKey `json:"key"`
}</pre></li>				<li>Define the JSON tags for the data structure as usual. Most polymorphic structures can be marshaled without a custom marshaler because the runtime type of objects is known <span class="No-Break">during marshaling.</span><p class="list-inset">Define another struct that is a copy of the original, with dynamically typed parts replaced with a <strong class="source-inline">json.RawMessage</strong> <span class="No-Break">type field:</span></p><pre class="source-code">
type keyUnmarshal struct {
     Type KeyType         `json:"type"`
     Key  json.RawMessage `json:"key"`
}</pre></li>				<li>Create an <a id="_idIndexMarker452"/>unmarshaler for the original struct. In this unmarshaler, first unmarshal the input to an instance of the struct created in <span class="No-Break">step 2:</span><pre class="source-code">
func (k *Key) UnmarshalJSON(in []byte) error {
     var key keyUnmarshal
     err := json.Unmarshal(in, &amp;key)
     if err != nil {
          return err
     }</pre></li>				<li>Using the type discriminator fields, decide how to decode the dynamic part. The following example uses a factory to obtain a <span class="No-Break">type-specific unmarshaler:</span><pre class="source-code">
     k.Type = key.Type
     unmarshaler := KeyUnmarshalers[key.Type]
     if unmarshaler == nil {
          return ErrInvalidKeyType
     }</pre></li>				<li>Unmarshal the dynamically typed part (which is a <strong class="source-inline">json.RawMessage</strong>) into an instance of the correctly <span class="No-Break">typed variable:</span><pre class="source-code">
     k.Key, err = unmarshaler(key.Key)
   if err != nil {
        return err
   }
   return nil
}</pre><p class="list-inset">The factory <a id="_idIndexMarker453"/>is a simple map that knows the unmarshalers for different types <span class="No-Break">of keys:</span></p><pre class="source-code">var (
     KeyUnmarshalers = map[KeyType]func(json.RawMessage) 
     (crypto.PublicKey, error){}
)
func RegisterKeyUnmarshaler(keyType KeyType, unmarshaler func(json.RawMessage) (crypto.PublicKey, error)) {
     KeyUnmarshalers[keyType] = unmarshaler
}
...
RegisterKeyUnmarshaler(KeyTypeRSA, func(in json.RawMessage) (crypto.PublicKey, error) {
     var key rsa.PublicKey
     if err := json.Unmarshal(in, &amp;key); err != nil {
          return nil, err
     }
     return &amp;key, nil
})
RegisterKeyUnmarshaler(KeyTypeED25519, func(in json.RawMessage) (crypto.PublicKey, error) {
     var key ed25519.PublicKey
     if err := json.Unmarshal(in, &amp;key); err != nil {
          return nil, err
     }
     return &amp;key, nil
})</pre></li>			</ol>
			<p>This is an <a id="_idIndexMarker454"/>extensible factory framework that can be initialized with additional unmarshalers determined at build time. Simply create an unmarshaler function for a type of object, and register it using the preceding <strong class="source-inline">RegisterKeyUnmarshaler</strong> function to <a id="_idIndexMarker455"/>support new <span class="No-Break">key types.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">A common way to <a id="_idIndexMarker456"/>register such features is to use the <strong class="source-inline">init()</strong> function of packages. When you import that package, unmarshaler types supported by the package will <span class="No-Break">be registered.</span></p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor306"/>Streaming JSON data</h2>
			<p>When you <a id="_idIndexMarker457"/>have to deal with large amounts of data efficiently, you should consider streaming data instead of working on the whole dataset at once. This section describes some methods for streaming <span class="No-Break">JSON data.</span></p>
			<h1 id="_idParaDest-306"><a id="_idTextAnchor307"/>Streaming an array of objects</h1>
			<p>This recipe <a id="_idIndexMarker458"/>is useful if you have a generator (a goroutine, a database cursor, etc.) that produces data elements, and you want to stream these as a JSON array instead of storing everything before <span class="No-Break">marshaling it.</span></p>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor308"/>How to do it...</h2>
			<ol>
				<li>Create a generator. This <span class="No-Break">can be</span><ul><li>a goroutine that sends data elements through a channel, </li><li>a cursor-like object containing a <strong class="source-inline">Next()</strong> method, </li><li>or some other <span class="No-Break">data generator.</span></li></ul></li>
				<li>Create an instance of <strong class="source-inline">json.Encoder</strong> with  <strong class="source-inline">io.Writer</strong> representing the target. The target can be a file, standard output, a buffer, a network connection, and <span class="No-Break">so on.</span></li>
				<li>Write the <a id="_idIndexMarker459"/>array beginning delimiter for the array, that <span class="No-Break">is, </span><span class="No-Break"><strong class="source-inline">[</strong></span><span class="No-Break">.</span></li>
				<li>Encode each data element, preceded by a comma <span class="No-Break">if necessary.</span></li>
				<li>Write the array closing delimiter, that <span class="No-Break">is, </span><span class="No-Break"><strong class="source-inline">]</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>The following example assumes there is a generator goroutine writing <strong class="source-inline">Data</strong> instances to the <strong class="source-inline">input</strong> channel. The generator closes the channel when there are no more <strong class="source-inline">Data</strong> instances. Here, we assume <strong class="source-inline">Data</strong> is <span class="No-Break">JSON marshalable:</span></p>
			<pre class="source-code">
func stream(out io.Writer, input &lt;-chan Data) error {
     enc := json.NewEncoder(out)
     if _, err := out.Write([]byte{'['}); err != nil {
          return err
     }
     first := true
     for obj := range input {
          if first {
               first = false
          } else {
               if _, err := out.Write([]byte{','}); err != nil {
                    return err
               }
          }
          if err := enc.Encode(obj); err != nil {
               return err
          }
     }
     if _, err := out.Write([]byte{']'}); err != nil {
          return err
     }
     return nil
}</pre>			<h1 id="_idParaDest-308"><a id="_idTextAnchor309"/>Parsing an array of objects</h1>
			<p>If you have <a id="_idIndexMarker460"/>a JSON data source providing an array of objects, you can parse these elements and process them using  <span class="No-Break"><strong class="source-inline">json.Decoder</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor310"/>How to do it...</h2>
			<ol>
				<li>Create  <strong class="source-inline">json.Decoder</strong> reading from the <span class="No-Break">input stream.</span></li>
				<li>Parse the array beginning delimiter (<strong class="source-inline">[</strong>) <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">json.Decoder.Token()</strong></span><span class="No-Break">.</span></li>
				<li>Decode each element of the array until <span class="No-Break">decoding fails.</span></li>
				<li>When decoding fails, you have to determine whether the stream ended, or whether there is really an error. To check for that, read the next token using <strong class="source-inline">json.Decoder.Token()</strong>. If the next token is read successfully and if it is an array end delimiter, <strong class="source-inline">]</strong>, then the stream parsing ended successfully. Otherwise, there is an error in the <span class="No-Break">input data.</span></li>
			</ol>
			<p>The following example assumes that  <strong class="source-inline">json.Decoder</strong> is already constructed to read from an input stream. The output is stored in a slice. Alternatively, the output can be processed as <a id="_idIndexMarker461"/>elements are parsed, or each element can be sent to a processing goroutine through <span class="No-Break">a channel:</span></p>
			<pre class="source-code">
func parse(input *json.Decoder) (output []Data, err error) {
     // Parse the array beginning delimiter
     var tok json.Token
     tok, err = input.Token()
     if err != nil {
          return
     }
     if tok != json.Delim('[') {
          err = fmt.Errorf("Array begin delimiter expected")
          return
     }
     // Parse array elements using Decode
     for {
          var data Data
          err = input.Decode(&amp;data)
          if err != nil {
               // Decode failed. Either there is an input error, or
               // we are at the end of the stream
               tok, err = input.Token()
               if err != nil {
                    // Data error
                    return
               }
               // Are we at the end?
               if tok == json.Delim(']') {
                    // Yes, there is no error
                    err = nil
                    break
               }
          }
          output = append(output, data)
     }
     return
}</pre>			<h1 id="_idParaDest-310"><a id="_idTextAnchor311"/>Other ways of streaming JSON</h1>
			<p>There are <a id="_idIndexMarker462"/>other ways of <span class="No-Break">streaming JSON:</span></p>
			<ul>
				<li>Concatenated JSON simply writes JSON objects one after <span class="No-Break">the other</span></li>
				<li>Newline-delimited JSON writes every JSON object as a <span class="No-Break">separate line</span></li>
				<li>Record separator-delimited JSON uses a special record separator character, 0x1E, and optionally a newline between each <span class="No-Break">JSON object</span></li>
				<li>Length-prefixed JSON prefixes the string length of every JSON object as a <span class="No-Break">decimal number</span></li>
			</ul>
			<p>All these can be read and written using <strong class="source-inline">json.Decoder</strong> and <strong class="source-inline">json.Encoder</strong>. A simple package for JSON streaming can be found <span class="No-Break">here: </span><a href="https://github.com/bserdar/jsonstream"><span class="No-Break">https://github.com/bserdar/jsonstream</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-311"><a id="_idTextAnchor312"/>Security considerations</h2>
			<p>Whenever you <a id="_idIndexMarker463"/>accept data from outside your application (user-entered data, API calls, reading a file, etc.), you have to be concerned about malicious input. JSON input is relatively safe because JSON parsers do not perform data expansions like YAML or XML parsers do. Nevertheless, there are still things you need to consider when dealing with <span class="No-Break">JSON data.</span></p>
			<h2 id="_idParaDest-312"><a id="_idTextAnchor313"/>How to do it...</h2>
			<ul>
				<li>Limit the amount of data when accepting third-party JSON input. Do not blindly use <strong class="source-inline">io.ReadAll</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">json.Decode</strong></span><span class="No-Break">:</span><pre class="source-code">
const MessageSizeLimit = 10240
func handler(w http.ResponseWriter, r *http.Request) {
  reader:=http.MaxBytesReader(w,r.Body,MessageSizeLimit)
  data, err := io.ReadAll(reader)
  if errors.Is(err,&amp;http.MaxBytesError{}) {
    // If this happens, error is already sent.
    return
  }
  ...
}</pre></li>				<li>Always provide an upper limit for resource allocations based on data you read from third-party input. For instance, if you are reading a length-prefixed JSON stream where each JSON object is prefixed by its length, do not allocate a `[]byte` to store the next object. Reject the input if the length is <span class="No-Break">too large.</span></li>
			</ul>
		</div>
	</div></div></body></html>