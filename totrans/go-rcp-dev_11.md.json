["```go\ntype Config struct {\n  Version   string `json:\"ver\"`  // Encoded as \"ver\"\n  Name      string               // Encoded as \"Name\"\n  Type      string `json:\"type,omitempty\"` // Encoded as \"type\",\n                                           // and will be omitted if \n                                           // empty\n  Style     string `json:\"-\"`    // Not encoded\n  value     string               // Unexported field, not encoded\n  kind      string `json:\"kind\"` // Unexported field, not encoded\n}\n```", "```gostring `json:”svalue”`` | `nil` | `“``svalue”: null` |\n| `StringValue *```", "```go\ntype Config struct {\n  Version   string `json:\"ver\"`  // Encoded as \"ver\"\n  Name      string               // Encoded as \"Name\"\n  Type      string `json:\"type,omitempty\"` // Encoded as \"type\",\n                                           // and will be omitted if \n                                           // empty\n  Style     string `json:\"-\"`    // Not encoded\n  value     string               // Unexported field, not encoded\n  kind      string `json:\"kind\"` // Unexported field, not encoded\n}\n...\ncfg := Config{\n     Version: \"1.1\",\n     Name:    \"name\",\n     Type:    \"example\",\n     Style:   \"json\",\n     value:   \"example config value\",\n     kind:    \"test\",\n}\ndata, err := json.Marshal(cfg)\nfmt.Println(string(err))\n```", "```go\n{\"ver\":\"1.1\",\"Name\":\"name\",\"type\":\"example\"}\n```", "```go\n    type Enclosing struct {\n         Field string `json:\"field\"`\n         Embedded\n    }\n    type Embedded struct {\n         Field string `json:\"embeddedField\"`\n    }\n    ```", "```go\n    enc := Enclosing{\n         Field: \"enclosing\",\n         Embedded: Embedded{\n              Field: \"embedded\",\n         },\n    }\n    data, err = json.Marshal(enc)\n    // {\"field\":\"enclosing\",\"embeddedField\":\"embedded\"}\n    ```", "```go\n    type Enclosing struct {\n         Field string `json:\"field\"`\n         Embedded `json:\"embedded\"`\n    }\n    type Embedded struct {\n         Field string `json:\"embeddedField\"`\n    }\n    ...\n    enc := Enclosing{\n         Field: \"enclosing\",\n         Embedded: Embedded{\n              Field: \"embedded\",\n         },\n    }\n    data, err = json.Marshal(enc)\n    // {\"field\":\"enclosing\",\"embedded\":{\"embeddedField\":\"embedded\"}}\n    ```", "```go\n    config:=map[string]any{\n      \"ver\": \"1.0\",\n      \"Name\": \"config\",\n      \"type\": \"example\",\n      }\n    data, err:=json.Marshal(config)\n    // `{\"ver\":\"1.0\",\"Name\":\"config\",\"type\":\"example\"}`\n    ```", "```go\n    numbersWithNil:=[]any{ 1, 2, nil, 3 }\n    data, err:=json.Marshal(numbersWithNil)\n    // `[1,2,null,3]`\n    ```", "```go\n    configurations:=map[string]map[string]any {\n      \"cfg1\": {\n         \"ver\": \"1.0\",\n         \"Name\": \"config1\",\n      },\n      \"cfg2\": {\n         \"ver\": \"1.1\",\n         \"Name\" : \"config2\",\n     },\n    }\n    data, err:=json.Marshal(configurations)\n    // {\"cfg1\":{\"Name\":\"config1\",\"ver\":\"1.0\"},\n    \"cfg2\":{\"Name\":\"config2\",\"ver\":\"1.1\"}}`\n    ```", "```go\nvar output interface{}\nerr:=json.Unmarshal(jsonData,&output)\n```", "```go\nvar output interface{}\ndecoder:=json.NewDecoder(strings.NewReader(`[1.1,2,3,4.4]`))\n// Tell the decoder to use json.Number instead of float64\ndecoder.UseNumber()\nerr:=decoder.Decode(&output)\n// [1.1 2 3 4.4]\n```", "```go\ntype Config struct {\n    ...\n     Type       string `json:\"type,omitempty\"`\n     IntValue   int     `json:\"intValue,omitempty\"`\n     FloatValue float64 `json:\"floatValue,omitempty\"`\n     When       *time.Time    `json:\"when,omitempty\"`\n     HowLong    time.Duration `json:\"howLong,omitempty\"`\n}\n```", "```go\ntype Config struct {\n  Value  *string `json:\"value,omitempty\"`\n  ...\n}\n...\nemptyString := \"\"\nemptyValue := Config {\n   Value: &emptyString,\n}\n// JSON output: { \"value\": \"\" }\nnullValue := Config {\n   Value: nil,\n}\n// JSON output: {}\n```", "```go\ntype APIRequest struct {\n   // If type is not specified, it will be nil\n   Type    *string `json:\"type\"`\n   // There will be a default value for seq\n   Seq     int     `json:\"seq\"`\n   ...\n}\nfunc handler(w http.ResponseWriter,r *http.Request) {\n  data, err:=io.ReadAll(r.Body)\n  if err!=nil {\n     http.Error(w, \"Bad request\",http.StatusBadRequest)\n     return\n  }\n  req:=APIRequest{\n     Seq: 1,  // Set the default value\n  }\n  if err:=json.Unmarshal(data, &req); err!=nil {\n     http.Error(w, \"Bad request\", http.StatusBadRequest)\n     return\n  }\n  // Check which fields are provided\n  if req.Type!=nil {\n     ...\n  }\n  // If seq is provided in the input, req.Seq will be set to that \n  // value. Otherwise, it will be 1.\n  if req.Seq==1 {\n    ...\n  }\n}\n```", "```go\n// TypeAndID is encoded to JSON as type:id\ntype TypeAndID struct {\n  Type string\n  ID int\n}\n// Implementation of json.Marshaler\nfunc (t TypeAndID) MarshalJSON() (out []byte, err error) {\n  s := fmt.Sprintf(`\"%s:%d\"`,t.Type,t.ID)\n  out=[]byte(s)\n  return\n}\n```", "```go\n// Implementation of json.Unmarshaler. Note the pointer receiver\nfunc (t *TypeAndID) UnmarshalJSON(in []byte) (err error) {\n    if len(in)<2 || in[0] != '\"' || in[len(in)-1] != '\"' {\n        err = ErrInvalidTypeAndID\n        return\n    }\n    in = in[1 : len(in)-1]\n    parts := strings.Split(string(in), \":\")\n    if len(parts) != 2 {\n        err = ErrInvalidTypeAndID\n        return\n     }\n    // The second part must be a valid integer\n    t.ID, err = strconv.Atoi(parts[1])\n    if err != nil {\n        return\n    }\n    t.Type = parts[0]\n    return\n}\n```", "```go\n    type Key int64\n    func main() {\n         var m map[Key]int\n         err := json.Unmarshal([]byte(`{\"123\":123}`), &m)\n        if err!=nil {\n           panic(err)\n        }\n         fmt.Println(m[123]) // Prints 123\n    }\n    ```", "```go\n    // Key is an uint that is encoded as an hex strings for JSON key\n    type Key uint\n    func (k *Key) UnmarshalText(data []byte) error {\n         v, err := strconv.ParseInt(string(data), 16, 64)\n         if err != nil {\n              return err\n         }\n         *k = Key(v)\n         return nil\n    }\n    func (k Key) MarshalText() ([]byte, error) {\n         s := strconv.FormatUint(uint64(k), 16)\n         return []byte(s), nil\n    }\n    func main() {\n         input := `{\n        \"13AD\": \"5037\",\n        \"3E22\": \"15906\",\n        \"90A3\": \"37027\"\n      }`\n         var data map[Key]string\n         if err := json.Unmarshal([]byte(input), &data); err != nil {\n              panic(err)\n         }\n         fmt.Println(data)\n         d, err := json.Marshal(map[Key]any{\n              Key(123): \"123\",\n              Key(255): \"255\",\n         })\n         if err != nil {\n              panic(err)\n         }\n         fmt.Println(string(d))\n    }\n    ```", "```go\ntype User struct {\n     Name string `json:\"name\"`\n     Type string `json:\"type\"`\n}\ntype Users struct {\n     Users map[string]User `json:\"users\"`\n}\nfunc main() {\n     input := `{\n  \"users\": {\n      \"abb64dfe-d4a8-47a5-b7b0-7613fe3fd11f\": {\n         \"name\": \"John\",\n         \"type\": \"admin\"\n      },\n      \"b158161c-0588-4c67-8e4b-c07a8978f711\": {\n         \"name\": \"Amy\",\n         \"type\": \"editor\"\n      }\n   }\n  }`\n     var users Users\n     if err := json.Unmarshal([]byte(input), &users); err != nil {\n          panic(err)\n     }\n}\n```", "```go\n    type KeyType string\n    const (\n         KeyTypeRSA     = \"rsa\"\n         KeyTypeED25519 = \"ed25519\"\n    )\n    type Key struct {\n         Type KeyType          `json:\"type\"`\n         Key  crypto.PublicKey `json:\"key\"`\n    }\n    ```", "```go\n    type keyUnmarshal struct {\n         Type KeyType         `json:\"type\"`\n         Key  json.RawMessage `json:\"key\"`\n    }\n    ```", "```go\n    func (k *Key) UnmarshalJSON(in []byte) error {\n         var key keyUnmarshal\n         err := json.Unmarshal(in, &key)\n         if err != nil {\n              return err\n         }\n    ```", "```go\n         k.Type = key.Type\n         unmarshaler := KeyUnmarshalers[key.Type]\n         if unmarshaler == nil {\n              return ErrInvalidKeyType\n         }\n    ```", "```go\n         k.Key, err = unmarshaler(key.Key)\n       if err != nil {\n            return err\n       }\n       return nil\n    }\n    ```", "```go\n    var (\n         KeyUnmarshalers = map[KeyType]func(json.RawMessage) \n         (crypto.PublicKey, error){}\n    )\n    func RegisterKeyUnmarshaler(keyType KeyType, unmarshaler func(json.RawMessage) (crypto.PublicKey, error)) {\n         KeyUnmarshalers[keyType] = unmarshaler\n    }\n    ...\n    RegisterKeyUnmarshaler(KeyTypeRSA, func(in json.RawMessage) (crypto.PublicKey, error) {\n         var key rsa.PublicKey\n         if err := json.Unmarshal(in, &key); err != nil {\n              return nil, err\n         }\n         return &key, nil\n    })\n    RegisterKeyUnmarshaler(KeyTypeED25519, func(in json.RawMessage) (crypto.PublicKey, error) {\n         var key ed25519.PublicKey\n         if err := json.Unmarshal(in, &key); err != nil {\n              return nil, err\n         }\n         return &key, nil\n    })\n    ```", "```go\nfunc stream(out io.Writer, input <-chan Data) error {\n     enc := json.NewEncoder(out)\n     if _, err := out.Write([]byte{'['}); err != nil {\n          return err\n     }\n     first := true\n     for obj := range input {\n          if first {\n               first = false\n          } else {\n               if _, err := out.Write([]byte{','}); err != nil {\n                    return err\n               }\n          }\n          if err := enc.Encode(obj); err != nil {\n               return err\n          }\n     }\n     if _, err := out.Write([]byte{']'}); err != nil {\n          return err\n     }\n     return nil\n}\n```", "```go\nfunc parse(input *json.Decoder) (output []Data, err error) {\n     // Parse the array beginning delimiter\n     var tok json.Token\n     tok, err = input.Token()\n     if err != nil {\n          return\n     }\n     if tok != json.Delim('[') {\n          err = fmt.Errorf(\"Array begin delimiter expected\")\n          return\n     }\n     // Parse array elements using Decode\n     for {\n          var data Data\n          err = input.Decode(&data)\n          if err != nil {\n               // Decode failed. Either there is an input error, or\n               // we are at the end of the stream\n               tok, err = input.Token()\n               if err != nil {\n                    // Data error\n                    return\n               }\n               // Are we at the end?\n               if tok == json.Delim(']') {\n                    // Yes, there is no error\n                    err = nil\n                    break\n               }\n          }\n          output = append(output, data)\n     }\n     return\n}\n```", "```go\n    const MessageSizeLimit = 10240\n    func handler(w http.ResponseWriter, r *http.Request) {\n      reader:=http.MaxBytesReader(w,r.Body,MessageSizeLimit)\n      data, err := io.ReadAll(reader)\n      if errors.Is(err,&http.MaxBytesError{}) {\n        // If this happens, error is already sent.\n        return\n      }\n      ...\n    }\n    ```"]