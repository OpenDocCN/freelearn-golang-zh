- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON is an acronym for JavaScript Object Notation. It is a popular format for
    data interchange because JSON objects closely resemble structured types (`struct`s
    in Go), and it is text-based encoding, making the encoded data human-readable.
    It supports arrays, objects (name-value pairs), and relatively few basic types
    (strings, numbers, booleans, and `null`). These properties make JSON a fairly
    easy format to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Encoding refers to the process of transforming data elements into a sequence
    of bytes. When you encode (or marshal) data elements in JSON, you create a textual
    representation of those data elements while following JSON syntax rules. The reverse
    process, decoding (or unmarshaling) assigns JSON values to Go objects. The encoding
    process is lossy: you have to describe data values as text, and that is not always
    obvious for complex data types. When you decode such data, you have to know how
    to interpret the textual representation so you can parse the JSON representation
    correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will first look at the encoding and decoding of basic data
    types. Then we will look at some recipes that deal with more complicated data
    types and use cases. You should use these recipes as a guide when implementing
    your own solutions. These recipes demonstrate solutions to particular use cases,
    and you may need to adopt them for your specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Encoding structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with embedded structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding without defining structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoding structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoding with interfaces, maps, and slices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other ways of decoding numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marshaling/unmarshaling custom data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom marshaling/unmarshaling of object keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic field names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphic data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming JSON data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marshaling/unmarshaling basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `encoding/json` package of the standard library provides convenient functions
    and conventions to encode/decode JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go struct types are usually encoded as JSON objects. This section shows the
    standard library tools that deal with the encoding of data types.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `json` tags to annotate struct fields with their JSON keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `json.Marshal` function to encode Go data objects in JSON. The standard
    library uses the following conventions for basic types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Go Declaration** | **Value** | **JSON output** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `NumberValue` `int json:”num”` | `0` | `“``num”: 0` |'
  prefs: []
  type: TYPE_TB
- en: '| `NumberValue *``int json:”num”` | `nil` | `“``num”: null` |'
  prefs: []
  type: TYPE_TB
- en: '| `NumberValue *``int json:”num,omitempty”` | `nil` | omitted |'
  prefs: []
  type: TYPE_TB
- en: '| `BoolValue` `bool json:”bvalue”` | `true` | `“``bvalue”: true` |'
  prefs: []
  type: TYPE_TB
- en: '| `BoolValue *``bool json:”bvalue”` | `nil` | `“``bvalue”: null` |'
  prefs: []
  type: TYPE_TB
- en: '| `BoolValue *``bool json:”bvalue,omitempty”` | `nil` | omitted |'
  prefs: []
  type: TYPE_TB
- en: '| `StringValue` `string json:”svalue”` | `“``str”` | `“``svalue”:”str”` |'
  prefs: []
  type: TYPE_TB
- en: '| `StringValue` `string json:”svalue”` | `“”` | `“``svalue”:””` |'
  prefs: []
  type: TYPE_TB
- en: '| `StringValue` `string json:”svalue,omitempty”` | `“``str”` | `“``svalue”:”str”`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `StringValue` `string json:”svalue,omitempty”` | `“”` | omitted |'
  prefs: []
  type: TYPE_TB
- en: '| `StringValue *[PRE1]string `json:”svalue,omitempty”`` | `nil` | omitted |'
  prefs: []
  type: TYPE_TB
- en: The `struct` and `map` types are marshaled as JSON objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slice and array types are marshaled as JSON arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a type implements the `json.Marshaler` interface, then the `json.Marshaler.MarshalJSON`
    method of the variable instance is called to encode data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a type implements the `encoding.TextMarshaler` interface, then the value
    is encoded as a JSON string, and the string value is obtained from the `encoding.TextMarshaler.MarshalText`
    method of the value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything else will fail with `UnsupportedValueError`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Only exported fields of struct types can be marshaled.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If there are no JSON tags for a struct field, its JSON object key will be the
    same as the field name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The order of fields in the encoded JSON object is the same as the order in which
    fields are declared.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with embedded structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fields of a struct type will be encoded as JSON objects. If there are embedded
    structs, then the encoder has two options: encode the embedded struct at the same
    level as the enclosing struct or as a new JSON object.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use JSON tags to name enclosing struct fields and the embedded struct fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `json.Marshal` to encode the struct as a JSON object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Adding a `json` tag to the embedded struct will create a nested JSON object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Encoding without defining structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic data types, slices, and maps can be used to encode JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use a map to represent JSON objects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use a slice to represent JSON arrays:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Match the desired JSON structure to Go equivalents:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Decoding structs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Encoding Go data objects in JSON is a relatively easy task: well-defined data
    types and semantics are translated into a less expressive representation, usually
    resulting in some information loss. For instance, an integer variable and a `float64`
    variable may be encoded to give identical output. Because of this, decoding JSON
    data is usually more difficult.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use JSON tags to map JSON keys to struct fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `json.Unmarshal` function to decode JSON data into Go data objects.
    The standard library uses the following conventions for basic types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **JSON Input** | **Go type** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `"``strValue"` | `string` | `"``strValue"` |'
  prefs: []
  type: TYPE_TB
- en: '| `1 (number)` | `int` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `1.2 (number)` | `int` | `error` |'
  prefs: []
  type: TYPE_TB
- en: '| `1.2 (number)` | `float64, float32` | `1.2` |'
  prefs: []
  type: TYPE_TB
- en: '| `true` | `bool` | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `string` | Variable left unmodified |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `int` | Variable left unmodified |'
  prefs: []
  type: TYPE_TB
- en: '| `"``strValue"` | `*``string` | `"``strValue"` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `*``string` | `nil` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `*``int` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `*``int` | `nil` |'
  prefs: []
  type: TYPE_TB
- en: '| `true` | `*``bool` | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `*``bool` | `nil` |'
  prefs: []
  type: TYPE_TB
- en: 'If the Go type is `interface{}`, the standard library creates objects using
    the following convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **JSON Input** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `"``strValue"` | `"``strValue"` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `float64(1)` |'
  prefs: []
  type: TYPE_TB
- en: '| `1.2` | `float64(1.2)` |'
  prefs: []
  type: TYPE_TB
- en: '| `true` | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `null` | `nil` |'
  prefs: []
  type: TYPE_TB
- en: '| JSON Object | `map[string]any` |'
  prefs: []
  type: TYPE_TB
- en: '| JSON array | `[]``any` |'
  prefs: []
  type: TYPE_TB
- en: If the target Go type implements the `json.Unmarshaler` interface, then `json.Unmarshal.UnmarshalJSON`
    is called to decode data. This operation may involve creating a new instance of
    the target type if necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the target Go type implements the `encoding.TextUnmarshaler` interface and
    the input is a quoted JSON string, then `encoding.TextUnmarshaler.UnmarshalText`
    is called to decode the value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything else will fail with `UnsupportedValueError`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Numeric values may cause confusion if the JSON input includes values of various
    numeric types. For instance, if a JSON numeric value is unmarshaled to an `int`
    value, it will work if the JSON data is representable as an integer, but fail
    if the JSON data has a floating-point value.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The JSON decoder will never change the unexported fields of a struct. The decoder
    uses reflection, and only the exported fields are accessible via reflection.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: JSON fields that do not have matching Go fields will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding with interfaces, maps, and slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When decoding Go values to JSON, the Go value types dictate how JSON encoding
    will be done. JSON does not have a rich type system like Go. Valid JSON types
    are string, number, boolean, object, array, and null. When you decode JSON data
    into a Go struct, it is still the Go type system that dictates how JSON data should
    be interpreted. But when you decode JSON into an `interface{}`, things change.
    Now it is the JSON data that dictates how Go values should be constructed, and
    this sometimes causes unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To unmarshal JSON data into an interface, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates an object tree based on the following translation rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **JSON** | **Go** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Object | `map[string]interface{}` |'
  prefs: []
  type: TYPE_TB
- en: '| Array | `[]``interface{}` |'
  prefs: []
  type: TYPE_TB
- en: '| number | `float64` |'
  prefs: []
  type: TYPE_TB
- en: '| boolean | `bool` |'
  prefs: []
  type: TYPE_TB
- en: '| string | `string` |'
  prefs: []
  type: TYPE_TB
- en: '| null | `nil` |'
  prefs: []
  type: TYPE_TB
- en: Other ways of decoding numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When decoded into an `interface{}`, JSON numbers are converted to `float64`.
    This is not always the desired result. You can use `json.Number` instead.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `json.Decoder` with `UseNumber`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Every element of `output` in the preceding example is an instance of `json.Number`.
    You can translate it to an `int`, `float64`, or `big.Int` as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with missing and optional values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You usually have to deal with JSON input with missing fields and have to generate
    JSON where empty fields are omitted. This section provides recipes showing how
    to deal with these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Omitting empty fields when encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Omitting empty fields from JSON encoding usually saves space and makes the JSON
    more reader-friendly. However, what is meant by “empty” should be clear.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `,omitempty` JSON tag to omit empty string values, zero integer/floating-point
    values, zero `time.Duration` values, and `nil` pointer values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `,omitempty` tag does not work for `time.Time` values. Use `*time.Time`
    and set it to `nil` to omit empty time values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes it is important to distinguish between an empty string and a null
    string. In JavaScript and JSON, `null` is a valid value for strings. If that is
    the case, use `*string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Dealing with missing fields when decoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several use cases where developers have to deal with sparse JSON data
    that does not include all data fields. For instance, a partial update API call
    may accept a JSON object that contains only those fields that should be updated,
    without modifying any unspecified data field. In such cases, it becomes important
    to identify which fields were provided. Then there are use cases where it is appropriate
    to assume default values for missing fields.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to determine which fields are specified in a JSON input, use pointer
    fields. Any fields missing in the input will remain as `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide default values for missing fields, initialize those fields to their
    default values before unmarshaling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Customizing JSON encoding/decoding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes JSON encoding of certain data structures does not match their representations
    in the program. When this happens, you have to customize how a certain data element
    is encoded to JSON or decoded from JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Marshaling/unmarshaling custom data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use these recipes when you have data elements whose JSON representation needs
    to be generated programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To control how a data object is encoded in JSON, implement the `json.Marshaler`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To control how a data object is decoded from JSON, implement the `json.Unmarshaler`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: An unmarshaler must have a pointer receiver.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Custom marshaling/unmarshaling of object keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maps are marshaled/unmarshaled as JSON objects. But if you have a map that has
    keys other than a string type, how can you marshal/unmarshal it to JSON?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The solution depends on the exact type of the key:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Maps with key types derived from string or integer types can be marshaled/unmarshaled
    using the standard library methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If map keys require additional processing for marshaling/unmarshaling, implement
    the `encoding.TextMarshaler` and `encoding.TextUnmarshaler` interfaces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Dynamic field names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are cases where the field names (object keys) are not constant. For example,
    an API may prefer to return a list of objects as a JSON object where unique identifiers
    of each object are the key. In such cases, it is not possible to use `json` tags
    in a struct.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use a `map[string]ValueType` to represent an object with dynamic field names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Polymorphic data structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A polymorphic data structure can be one of several different types that share
    a common interface. The actual type is determined at runtime. For runtime objects,
    the Go type system ensures type-safe operations using such fields. With the use
    of interfaces, polymorphic objects can be marshaled as JSON easily. A problem
    arises when you need to unmarshal a polymorphic JSON object. In this recipe, we
    will look at one way of achieving this.
  prefs: []
  type: TYPE_NORMAL
- en: Custom unmarshaling with two passes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first pass unmarshals discriminator fields while leaving the rest of the
    input unprocessed. Based on the discriminator, the concrete instance of the object
    is constructed and unmarshaled.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will work with an example `Key` structure in this section. The `Key` structure
    holds different types of cryptographic public keys, whose type is given in a `Type`
    field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define the JSON tags for the data structure as usual. Most polymorphic structures
    can be marshaled without a custom marshaler because the runtime type of objects
    is known during marshaling.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define another struct that is a copy of the original, with dynamically typed
    parts replaced with a `json.RawMessage` type field:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an unmarshaler for the original struct. In this unmarshaler, first unmarshal
    the input to an instance of the struct created in step 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the type discriminator fields, decide how to decode the dynamic part.
    The following example uses a factory to obtain a type-specific unmarshaler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unmarshal the dynamically typed part (which is a `json.RawMessage`) into an
    instance of the correctly typed variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The factory is a simple map that knows the unmarshalers for different types
    of keys:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is an extensible factory framework that can be initialized with additional
    unmarshalers determined at build time. Simply create an unmarshaler function for
    a type of object, and register it using the preceding `RegisterKeyUnmarshaler`
    function to support new key types.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: A common way to register such features is to use the `init()` function of packages.
    When you import that package, unmarshaler types supported by the package will
    be registered.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming JSON data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you have to deal with large amounts of data efficiently, you should consider
    streaming data instead of working on the whole dataset at once. This section describes
    some methods for streaming JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming an array of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is useful if you have a generator (a goroutine, a database cursor,
    etc.) that produces data elements, and you want to stream these as a JSON array
    instead of storing everything before marshaling it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a generator. This can be
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a goroutine that sends data elements through a channel,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a cursor-like object containing a `Next()` method,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: or some other data generator.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an instance of `json.Encoder` with `io.Writer` representing the target.
    The target can be a file, standard output, a buffer, a network connection, and
    so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the array beginning delimiter for the array, that is, `[`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encode each data element, preceded by a comma if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the array closing delimiter, that is, `]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following example assumes there is a generator goroutine writing `Data`
    instances to the `input` channel. The generator closes the channel when there
    are no more `Data` instances. Here, we assume `Data` is JSON marshalable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Parsing an array of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a JSON data source providing an array of objects, you can parse
    these elements and process them using `json.Decoder`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create `json.Decoder` reading from the input stream.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parse the array beginning delimiter (`[`) using `json.Decoder.Token()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decode each element of the array until decoding fails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When decoding fails, you have to determine whether the stream ended, or whether
    there is really an error. To check for that, read the next token using `json.Decoder.Token()`.
    If the next token is read successfully and if it is an array end delimiter, `]`,
    then the stream parsing ended successfully. Otherwise, there is an error in the
    input data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following example assumes that `json.Decoder` is already constructed to
    read from an input stream. The output is stored in a slice. Alternatively, the
    output can be processed as elements are parsed, or each element can be sent to
    a processing goroutine through a channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Other ways of streaming JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are other ways of streaming JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: Concatenated JSON simply writes JSON objects one after the other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Newline-delimited JSON writes every JSON object as a separate line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Record separator-delimited JSON uses a special record separator character, 0x1E,
    and optionally a newline between each JSON object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Length-prefixed JSON prefixes the string length of every JSON object as a decimal
    number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All these can be read and written using `json.Decoder` and `json.Encoder`.
    A simple package for JSON streaming can be found here: [https://github.com/bserdar/jsonstream](https://github.com/bserdar/jsonstream).'
  prefs: []
  type: TYPE_NORMAL
- en: Security considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you accept data from outside your application (user-entered data, API
    calls, reading a file, etc.), you have to be concerned about malicious input.
    JSON input is relatively safe because JSON parsers do not perform data expansions
    like YAML or XML parsers do. Nevertheless, there are still things you need to
    consider when dealing with JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Limit the amount of data when accepting third-party JSON input. Do not blindly
    use `io.ReadAll` or `json.Decode`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Always provide an upper limit for resource allocations based on data you read
    from third-party input. For instance, if you are reading a length-prefixed JSON
    stream where each JSON object is prefixed by its length, do not allocate a `[]byte`
    to store the next object. Reject the input if the length is too large.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
