- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Working with JSON
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与JSON一起工作
- en: JSON is an acronym for JavaScript Object Notation. It is a popular format for
    data interchange because JSON objects closely resemble structured types (`struct`s
    in Go), and it is text-based encoding, making the encoded data human-readable.
    It supports arrays, objects (name-value pairs), and relatively few basic types
    (strings, numbers, booleans, and `null`). These properties make JSON a fairly
    easy format to work with.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是JavaScript对象表示法的缩写。它是一种流行的数据交换格式，因为JSON对象与结构化类型（Go中的`struct`）非常相似，并且它是基于文本的编码，使得编码后的数据可读。它支持数组、对象（键值对）以及相对较少的基本类型（字符串、数字、布尔值和`null`）。这些特性使得JSON成为一个相对容易处理的格式。
- en: 'Encoding refers to the process of transforming data elements into a sequence
    of bytes. When you encode (or marshal) data elements in JSON, you create a textual
    representation of those data elements while following JSON syntax rules. The reverse
    process, decoding (or unmarshaling) assigns JSON values to Go objects. The encoding
    process is lossy: you have to describe data values as text, and that is not always
    obvious for complex data types. When you decode such data, you have to know how
    to interpret the textual representation so you can parse the JSON representation
    correctly.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编码是指将数据元素转换成一系列字节的进程。当你使用JSON编码（或序列化）数据元素时，你会在遵循JSON语法规则的同时创建这些数据元素的文字表示。相反的过程，解码（或反序列化）将JSON值分配给Go对象。编码过程是有损的：你必须将数据值描述为文本，而对于复杂的数据类型来说，这并不总是显而易见的。当你解码这样的数据时，你必须知道如何解释文本表示，以便你能正确地解析JSON表示。
- en: In this chapter, we will first look at the encoding and decoding of basic data
    types. Then we will look at some recipes that deal with more complicated data
    types and use cases. You should use these recipes as a guide when implementing
    your own solutions. These recipes demonstrate solutions to particular use cases,
    and you may need to adopt them for your specific needs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先查看基本数据类型的编码和解码。然后我们将查看一些处理更复杂的数据类型和用例的食谱。在实现自己的解决方案时，你应该将这些食谱作为指南。这些食谱展示了特定用例的解决方案，你可能需要根据你的具体需求对其进行调整。
- en: 'This chapter includes the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下食谱：
- en: Encoding structs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体的编码
- en: Dealing with embedded structs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理嵌套结构
- en: Encoding without defining structs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不定义结构体的编码
- en: Decoding structs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体的解码
- en: Decoding with interfaces, maps, and slices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口、映射和切片进行解码
- en: Other ways of decoding numbers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解码数字的其他方式
- en: Marshaling/unmarshaling custom data types
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义数据类型的序列化和反序列化
- en: Custom marshaling/unmarshaling of object keys
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象键的自定义序列化和反序列化
- en: Dynamic field names
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态字段名
- en: Polymorphic data structures
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态数据结构
- en: Streaming JSON data
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式传输JSON数据
- en: Marshaling/unmarshaling basics
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化和反序列化基础
- en: The `encoding/json` package of the standard library provides convenient functions
    and conventions to encode/decode JSON data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中的`encoding/json`包提供了方便的函数和约定来编码/解码JSON数据。
- en: Encoding structs
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体的编码
- en: Go struct types are usually encoded as JSON objects. This section shows the
    standard library tools that deal with the encoding of data types.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Go结构体类型通常被编码为JSON对象。本节展示了处理数据类型编码的标准库工具。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Use `json` tags to annotate struct fields with their JSON keys:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`json`标签注释结构体字段及其JSON键：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Use the `json.Marshal` function to encode Go data objects in JSON. The standard
    library uses the following conventions for basic types:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`json.Marshal`函数将Go数据对象编码为JSON。标准库为基本类型使用以下约定：
- en: '| **Go Declaration** | **Value** | **JSON output** |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **Go声明** | **值** | **JSON输出** |'
- en: '| --- | --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `NumberValue` `int json:”num”` | `0` | `“``num”: 0` |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `NumberValue` `int json:”num”` | `0` | `“``num”: 0` |'
- en: '| `NumberValue *``int json:”num”` | `nil` | `“``num”: null` |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `NumberValue *``int json:”num”` | `nil` | `“``num”: null` |'
- en: '| `NumberValue *``int json:”num,omitempty”` | `nil` | omitted |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `NumberValue *``int json:”num,omitempty”` | `nil` | omitted |'
- en: '| `BoolValue` `bool json:”bvalue”` | `true` | `“``bvalue”: true` |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `BoolValue` `bool json:”bvalue”` | `true` | `“``bvalue”: true` |'
- en: '| `BoolValue *``bool json:”bvalue”` | `nil` | `“``bvalue”: null` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `BoolValue *``bool json:”bvalue”` | `nil` | `“``bvalue”: null` |'
- en: '| `BoolValue *``bool json:”bvalue,omitempty”` | `nil` | omitted |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `BoolValue *``bool json:”bvalue,omitempty”` | `nil` | omitted |'
- en: '| `StringValue` `string json:”svalue”` | `“``str”` | `“``svalue”:”str”` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `StringValue` `string json:”svalue”` | `“``str”` | `“``svalue”:”str”` |'
- en: '| `StringValue` `string json:”svalue”` | `“”` | `“``svalue”:””` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `StringValue` `string json:”svalue”` | `“”` | `“``svalue”:””` |'
- en: '| `StringValue` `string json:”svalue,omitempty”` | `“``str”` | `“``svalue”:”str”`
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `StringValue` `string json:”svalue,omitempty”` | `“``str”` | `“``svalue”:”str”`
    |'
- en: '| `StringValue` `string json:”svalue,omitempty”` | `“”` | omitted |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `StringValue string json:"svalue,omitempty"` | `""` | 被省略 |'
- en: '| `StringValue *[PRE1]string `json:”svalue,omitempty”`` | `nil` | omitted |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `StringValue *[PRE1]string `json:”svalue,omitempty”`` | `nil` | 被省略 |'
- en: The `struct` and `map` types are marshaled as JSON objects
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`struct` 和 `map` 类型被编码为 JSON 对象'
- en: Slice and array types are marshaled as JSON arrays
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片和数组类型被编码为 JSON 数组
- en: If a type implements the `json.Marshaler` interface, then the `json.Marshaler.MarshalJSON`
    method of the variable instance is called to encode data
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类型实现了 `json.Marshaler` 接口，则调用变量的实例的 `json.Marshaler.MarshalJSON` 方法来编码数据
- en: If a type implements the `encoding.TextMarshaler` interface, then the value
    is encoded as a JSON string, and the string value is obtained from the `encoding.TextMarshaler.MarshalText`
    method of the value
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个类型实现了 `encoding.TextMarshaler` 接口，则值将被编码为 JSON 字符串，字符串值是从值的 `encoding.TextMarshaler.MarshalText`
    方法中获得的
- en: Anything else will fail with `UnsupportedValueError`
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他任何内容都将因 `UnsupportedValueError` 而失败
- en: Tip
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Only exported fields of struct types can be marshaled.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 只有结构体类型的导出字段可以被编码。
- en: Tip
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If there are no JSON tags for a struct field, its JSON object key will be the
    same as the field name.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果结构体字段没有 JSON 标签，其 JSON 对象键将与字段名相同。
- en: 'Consider the following code segment:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码段：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This prints the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The order of fields in the encoded JSON object is the same as the order in which
    fields are declared.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 编码 JSON 对象中字段的顺序与字段声明的顺序相同。
- en: Dealing with embedded structs
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理嵌套结构体
- en: 'Fields of a struct type will be encoded as JSON objects. If there are embedded
    structs, then the encoder has two options: encode the embedded struct at the same
    level as the enclosing struct or as a new JSON object.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体类型的字段将被编码为 JSON 对象。如果存在嵌套的结构体，则编码器有两个选择：将嵌套的结构体编码在与封装结构体相同的级别，或者作为一个新的 JSON
    对象。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Use JSON tags to name enclosing struct fields and the embedded struct fields:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 JSON 标签命名封装结构体字段和嵌套结构体字段：
- en: '[PRE4]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Use `json.Marshal` to encode the struct as a JSON object:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `json.Marshal` 将结构体编码为 JSON 对象：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Adding a `json` tag to the embedded struct will create a nested JSON object:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在嵌套结构体中添加 `json` 标签将创建一个嵌套的 JSON 对象：
- en: '[PRE6]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Encoding without defining structs
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不定义结构体的编码
- en: Basic data types, slices, and maps can be used to encode JSON data.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 基本数据类型、切片和映射可以用来编码 JSON 数据。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Use a map to represent JSON objects:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用映射来表示 JSON 对象：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Use a slice to represent JSON arrays:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用切片来表示 JSON 数组：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Match the desired JSON structure to Go equivalents:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所需的 JSON 结构与 Go 等效项匹配：
- en: '[PRE9]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Decoding structs
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码结构体
- en: 'Encoding Go data objects in JSON is a relatively easy task: well-defined data
    types and semantics are translated into a less expressive representation, usually
    resulting in some information loss. For instance, an integer variable and a `float64`
    variable may be encoded to give identical output. Because of this, decoding JSON
    data is usually more difficult.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSON 中编码 Go 数据对象是一个相对简单的任务：定义良好的数据类型和语义被转换为表达性较低的表现形式，通常会导致一些信息丢失。例如，整数变量和
    `float64` 变量可能被编码为相同的输出。因此，解码 JSON 数据通常更困难。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Use JSON tags to map JSON keys to struct fields.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 JSON 标签将 JSON 键映射到结构体字段。
- en: 'Use the `json.Unmarshal` function to decode JSON data into Go data objects.
    The standard library uses the following conventions for basic types:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `json.Unmarshal` 函数将 JSON 数据解码为 Go 数据对象。标准库使用以下约定来处理基本类型：
- en: '| **JSON Input** | **Go type** | **Result** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **JSON 输入** | **Go 类型** | **结果** |'
- en: '| --- | --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `"``strValue"` | `string` | `"``strValue"` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `"strValue"` | `string` | `"strValue"` |'
- en: '| `1 (number)` | `int` | `1` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `1 (number)` | `int` | `1` |'
- en: '| `1.2 (number)` | `int` | `error` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `1.2 (number)` | `int` | `error` |'
- en: '| `1.2 (number)` | `float64, float32` | `1.2` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `1.2 (number)` | `float64, float32` | `1.2` |'
- en: '| `true` | `bool` | `true` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `true` | `bool` | `true` |'
- en: '| `null` | `string` | Variable left unmodified |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `string` | 变量保持未修改 |'
- en: '| `null` | `int` | Variable left unmodified |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `int` | 变量保持未修改 |'
- en: '| `"``strValue"` | `*``string` | `"``strValue"` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `"strValue"` | `*string` | `"strValue"` |'
- en: '| `null` | `*``string` | `nil` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `*string` | `nil` |'
- en: '| `1` | `*``int` | `1` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `*int` | `1` |'
- en: '| `null` | `*``int` | `nil` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `*int` | `nil` |'
- en: '| `true` | `*``bool` | `true` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `true` | `*bool` | `true` |'
- en: '| `null` | `*``bool` | `nil` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `*bool` | `nil` |'
- en: 'If the Go type is `interface{}`, the standard library creates objects using
    the following convention:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Go 类型是 `interface{}`，标准库将使用以下约定创建对象：
- en: '| **JSON Input** | **Result** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **JSON 输入** | **结果** |'
- en: '| --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `"``strValue"` | `"``strValue"` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `"strValue"` | `"strValue"` |'
- en: '| `1` | `float64(1)` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `1` | `float64(1)` |'
- en: '| `1.2` | `float64(1.2)` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `1.2` | `float64(1.2)` |'
- en: '| `true` | `true` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `true` | `true` |'
- en: '| `null` | `nil` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `null` | `nil` |'
- en: '| JSON Object | `map[string]any` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| JSON 对象 | `map[string]any` |'
- en: '| JSON array | `[]``any` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| JSON 数组 | `[]any` |'
- en: If the target Go type implements the `json.Unmarshaler` interface, then `json.Unmarshal.UnmarshalJSON`
    is called to decode data. This operation may involve creating a new instance of
    the target type if necessary.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标 Go 类型实现了 `json.Unmarshaler` 接口，则调用 `json.Unmarshal.UnmarshalJSON` 来解码数据。此操作可能需要根据需要创建目标类型的新实例。
- en: If the target Go type implements the `encoding.TextUnmarshaler` interface and
    the input is a quoted JSON string, then `encoding.TextUnmarshaler.UnmarshalText`
    is called to decode the value.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标 Go 类型实现了 `encoding.TextUnmarshaler` 接口，并且输入是引号中的 JSON 字符串，则调用 `encoding.TextUnmarshaler.UnmarshalText`
    来解码值。
- en: Anything else will fail with `UnsupportedValueError`.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他任何内容都将因 `UnsupportedValueError` 而失败。
- en: Tip
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Numeric values may cause confusion if the JSON input includes values of various
    numeric types. For instance, if a JSON numeric value is unmarshaled to an `int`
    value, it will work if the JSON data is representable as an integer, but fail
    if the JSON data has a floating-point value.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 JSON 输入包含各种数值类型的值，数值可能会导致混淆。例如，如果 JSON 数值被反序列化为 `int` 值，如果 JSON 数据可以表示为整数，则可以正常工作，但如果
    JSON 数据包含浮点值，则将失败。
- en: Tip
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The JSON decoder will never change the unexported fields of a struct. The decoder
    uses reflection, and only the exported fields are accessible via reflection.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 解码器永远不会更改结构体的非导出字段。解码器使用反射，并且只有导出字段可以通过反射访问。
- en: Tip
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: JSON fields that do not have matching Go fields will be ignored.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 没有匹配 Go 字段的 JSON 字段将被忽略。
- en: Decoding with interfaces, maps, and slices
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用接口、映射和切片进行解码
- en: When decoding Go values to JSON, the Go value types dictate how JSON encoding
    will be done. JSON does not have a rich type system like Go. Valid JSON types
    are string, number, boolean, object, array, and null. When you decode JSON data
    into a Go struct, it is still the Go type system that dictates how JSON data should
    be interpreted. But when you decode JSON into an `interface{}`, things change.
    Now it is the JSON data that dictates how Go values should be constructed, and
    this sometimes causes unexpected results.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 Go 值解码为 JSON 时，Go 值类型决定了 JSON 编码的方式。JSON 没有像 Go 那样丰富的类型系统。有效的 JSON 类型是字符串、数字、布尔值、对象、数组和
    null。当你将 JSON 数据解码到 Go 结构体时，仍然是 Go 类型系统决定了如何解释 JSON 数据。但是，当你将 JSON 解码到 `interface{}`
    时，情况就改变了。现在 JSON 数据决定了如何构建 Go 值，这有时会导致意外的结果。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To unmarshal JSON data into an interface, use the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 JSON 数据反序列化到接口中，请使用以下方法：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This creates an object tree based on the following translation rules:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将根据以下翻译规则创建基于以下翻译规则的对象树：
- en: '| **JSON** | **Go** |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| **JSON** | **Go** |'
- en: '| --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Object | `map[string]interface{}` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 对象 | `map[string]interface{}` |'
- en: '| Array | `[]``interface{}` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | `[]interface{}` |'
- en: '| number | `float64` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 数字 | `float64` |'
- en: '| boolean | `bool` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 布尔值 | `bool` |'
- en: '| string | `string` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | `string` |'
- en: '| null | `nil` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| null | `nil` |'
- en: Other ways of decoding numbers
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码数字的其他方式
- en: When decoded into an `interface{}`, JSON numbers are converted to `float64`.
    This is not always the desired result. You can use `json.Number` instead.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当解码到 `interface{}` 时，JSON 数值被转换为 `float64`。这并不总是期望的结果。你可以使用 `json.Number` 代替。
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use `json.Decoder` with `UseNumber`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `json.Decoder` 并设置 `UseNumber`：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Every element of `output` in the preceding example is an instance of `json.Number`.
    You can translate it to an `int`, `float64`, or `big.Int` as necessary.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`output` 的每个元素都是 `json.Number` 的实例。你可以根据需要将其转换为 `int`、`float64` 或 `big.Int`。
- en: Dealing with missing and optional values
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理缺失和可选值
- en: You usually have to deal with JSON input with missing fields and have to generate
    JSON where empty fields are omitted. This section provides recipes showing how
    to deal with these scenarios.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你必须处理缺少字段的 JSON 输入，并生成省略空字段的 JSON。本节提供了处理这些场景的配方。
- en: Omitting empty fields when encoding
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码时省略空字段
- en: Omitting empty fields from JSON encoding usually saves space and makes the JSON
    more reader-friendly. However, what is meant by “empty” should be clear.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSON 编码中省略空字段通常可以节省空间并使 JSON 更易于阅读。然而，“空”的含义应该是明确的。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Use the `,omitempty` JSON tag to omit empty string values, zero integer/floating-point
    values, zero `time.Duration` values, and `nil` pointer values.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `,omitempty` JSON标签省略空字符串值、零整数/浮点值、零 `time.Duration` 值和 `nil` 指针值。
- en: 'The `,omitempty` tag does not work for `time.Time` values. Use `*time.Time`
    and set it to `nil` to omit empty time values:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`,omitempty` 标签对 `time.Time` 值不起作用。使用 `*time.Time` 并将其设置为 `nil` 以省略空时间值：'
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Sometimes it is important to distinguish between an empty string and a null
    string. In JavaScript and JSON, `null` is a valid value for strings. If that is
    the case, use `*string`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时区分空字符串和null字符串很重要。在JavaScript和JSON中，`null`是字符串的有效值。如果是这种情况，请使用 `*string`：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Dealing with missing fields when decoding
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码时处理缺失字段
- en: There are several use cases where developers have to deal with sparse JSON data
    that does not include all data fields. For instance, a partial update API call
    may accept a JSON object that contains only those fields that should be updated,
    without modifying any unspecified data field. In such cases, it becomes important
    to identify which fields were provided. Then there are use cases where it is appropriate
    to assume default values for missing fields.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种用例，开发者必须处理不包含所有数据字段的稀疏JSON数据。例如，部分更新API调用可能接受一个仅包含应更新的字段而不修改任何未指定数据字段的JSON对象。在这种情况下，识别哪些字段被提供变得很重要。然后还有适合为缺失字段假设默认值的用例。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: If you want to determine which fields are specified in a JSON input, use pointer
    fields. Any fields missing in the input will remain as `nil`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想确定在JSON输入中指定了哪些字段，请使用指针字段。输入中缺失的任何字段都将保持为 `nil`。
- en: 'To provide default values for missing fields, initialize those fields to their
    default values before unmarshaling:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要为缺失字段提供默认值，在反序列化之前将这些字段初始化为其默认值：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Customizing JSON encoding/decoding
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义JSON编码/解码
- en: Sometimes JSON encoding of certain data structures does not match their representations
    in the program. When this happens, you have to customize how a certain data element
    is encoded to JSON or decoded from JSON.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 有时某些数据结构的JSON编码与其在程序中的表示不匹配。当这种情况发生时，你必须自定义如何将某个特定数据元素编码为JSON或从JSON中解码。
- en: Marshaling/unmarshaling custom data types
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化/反序列化自定义数据类型
- en: Use these recipes when you have data elements whose JSON representation needs
    to be generated programmatically.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有数据元素，其JSON表示需要程序化生成时，请使用这些食谱。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To control how a data object is encoded in JSON, implement the `json.Marshaler`
    interface:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制数据对象在JSON中的编码方式，实现 `json.Marshaler` 接口：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To control how a data object is decoded from JSON, implement the `json.Unmarshaler`
    interface:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制数据对象从JSON中解码的方式，实现 `json.Unmarshaler` 接口：
- en: Tip
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: An unmarshaler must have a pointer receiver.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 解码器必须有一个指针接收器。
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Custom marshaling/unmarshaling of object keys
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义对象键的序列化/反序列化
- en: Maps are marshaled/unmarshaled as JSON objects. But if you have a map that has
    keys other than a string type, how can you marshal/unmarshal it to JSON?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 映射作为JSON对象进行序列化/反序列化。但如果你有一个键类型不是字符串类型的映射，你如何将其序列化/反序列化为JSON？
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The solution depends on the exact type of the key:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案取决于键的确切类型：
- en: 'Maps with key types derived from string or integer types can be marshaled/unmarshaled
    using the standard library methods:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串或整数类型派生的键类型的映射可以采用标准库方法进行序列化/反序列化：
- en: '[PRE17]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If map keys require additional processing for marshaling/unmarshaling, implement
    the `encoding.TextMarshaler` and `encoding.TextUnmarshaler` interfaces:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果映射键在序列化/反序列化时需要额外的处理，实现 `encoding.TextMarshaler` 和 `encoding.TextUnmarshaler`
    接口：
- en: '[PRE18]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Dynamic field names
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态字段名
- en: There are cases where the field names (object keys) are not constant. For example,
    an API may prefer to return a list of objects as a JSON object where unique identifiers
    of each object are the key. In such cases, it is not possible to use `json` tags
    in a struct.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有时字段名（对象键）不是固定的。例如，一个API可能更喜欢以JSON对象的形式返回对象的列表，其中每个对象的唯一标识符是键。在这种情况下，无法在结构体中使用
    `json` 标签。
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Use a `map[string]ValueType` to represent an object with dynamic field names:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `map[string]ValueType` 来表示具有动态字段名的对象：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Polymorphic data structures
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态数据结构
- en: A polymorphic data structure can be one of several different types that share
    a common interface. The actual type is determined at runtime. For runtime objects,
    the Go type system ensures type-safe operations using such fields. With the use
    of interfaces, polymorphic objects can be marshaled as JSON easily. A problem
    arises when you need to unmarshal a polymorphic JSON object. In this recipe, we
    will look at one way of achieving this.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 多态数据结构可以是几种不同类型中的一种，这些类型共享一个公共接口。实际类型是在运行时确定的。对于运行时对象，Go 的类型系统通过使用这些字段确保类型安全的操作。使用接口，多态对象可以轻松地序列化为
    JSON。当你需要反序列化一个多态 JSON 对象时，就会出现问题。在这个菜谱中，我们将探讨实现这一目标的一种方法。
- en: Custom unmarshaling with two passes
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用两次遍历进行自定义反序列化
- en: The first pass unmarshals discriminator fields while leaving the rest of the
    input unprocessed. Based on the discriminator, the concrete instance of the object
    is constructed and unmarshaled.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次遍历会反序列化判别器字段，而将输入的其余部分留待未处理。根据判别器，构建并反序列化对象的具体实例。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will work with an example `Key` structure in this section. The `Key` structure
    holds different types of cryptographic public keys, whose type is given in a `Type`
    field:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用一个示例 `Key` 结构。`Key` 结构包含不同类型的加密公钥，其类型在 `Type` 字段中给出：
- en: '[PRE20]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Define the JSON tags for the data structure as usual. Most polymorphic structures
    can be marshaled without a custom marshaler because the runtime type of objects
    is known during marshaling.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照惯例定义数据结构的 JSON 标签。大多数多态结构可以不使用自定义序列化器进行序列化，因为在序列化期间已知对象的运行时类型。
- en: 'Define another struct that is a copy of the original, with dynamically typed
    parts replaced with a `json.RawMessage` type field:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义另一个与原始结构相同的结构，将动态类型部分替换为 `json.RawMessage` 类型字段：
- en: '[PRE21]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create an unmarshaler for the original struct. In this unmarshaler, first unmarshal
    the input to an instance of the struct created in step 2:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为原始结构创建一个反序列化器。在这个反序列化器中，首先将输入反序列化到步骤 2 中创建的结构实例：
- en: '[PRE22]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using the type discriminator fields, decide how to decode the dynamic part.
    The following example uses a factory to obtain a type-specific unmarshaler:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类型判别器字段，决定如何解码动态部分。以下示例使用工厂来获取特定类型的反序列化器：
- en: '[PRE23]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Unmarshal the dynamically typed part (which is a `json.RawMessage`) into an
    instance of the correctly typed variable:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将动态类型部分（它是一个 `json.RawMessage`）反序列化到正确类型的变量实例中：
- en: '[PRE24]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The factory is a simple map that knows the unmarshalers for different types
    of keys:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 工厂是一个简单的映射，它知道不同类型键的反序列化器：
- en: '[PRE25]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is an extensible factory framework that can be initialized with additional
    unmarshalers determined at build time. Simply create an unmarshaler function for
    a type of object, and register it using the preceding `RegisterKeyUnmarshaler`
    function to support new key types.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可扩展的工厂框架，可以在构建时初始化额外的反序列化器。只需为对象类型创建一个反序列化函数，并使用前面的 `RegisterKeyUnmarshaler`
    函数注册它以支持新的键类型。
- en: Tip
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: A common way to register such features is to use the `init()` function of packages.
    When you import that package, unmarshaler types supported by the package will
    be registered.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注册此类功能的一种常见方式是使用包的 `init()` 函数。当你导入该包时，该包支持的反序列化类型将被注册。
- en: Streaming JSON data
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流式传输 JSON 数据
- en: When you have to deal with large amounts of data efficiently, you should consider
    streaming data instead of working on the whole dataset at once. This section describes
    some methods for streaming JSON data.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要高效地处理大量数据时，你应该考虑流式传输数据而不是一次性处理整个数据集。本节描述了一些流式传输 JSON 数据的方法。
- en: Streaming an array of objects
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流式传输对象数组
- en: This recipe is useful if you have a generator (a goroutine, a database cursor,
    etc.) that produces data elements, and you want to stream these as a JSON array
    instead of storing everything before marshaling it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个生成器（goroutine、数据库游标等）产生数据元素，并且你想将这些元素作为 JSON 数组流式传输而不是在序列化之前存储所有内容，这个菜谱就很有用。
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a generator. This can be
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个生成器。这可以是
- en: a goroutine that sends data elements through a channel,
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个通过通道发送数据元素的 goroutine，
- en: a cursor-like object containing a `Next()` method,
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类似游标的对象，包含一个 `Next()` 方法，
- en: or some other data generator.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或其他数据生成器。
- en: Create an instance of `json.Encoder` with `io.Writer` representing the target.
    The target can be a file, standard output, a buffer, a network connection, and
    so on.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `json.Encoder` 实例，它使用 `io.Writer` 表示目标。目标可以是文件、标准输出、缓冲区、网络连接等。
- en: Write the array beginning delimiter for the array, that is, `[`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为数组写入开始分隔符，即`[`。
- en: Encode each data element, preceded by a comma if necessary.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，在数据元素前加上逗号进行编码。
- en: Write the array closing delimiter, that is, `]`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写入数组的结束分隔符，即`]`。
- en: 'The following example assumes there is a generator goroutine writing `Data`
    instances to the `input` channel. The generator closes the channel when there
    are no more `Data` instances. Here, we assume `Data` is JSON marshalable:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例假设存在一个生成器goroutine将`Data`实例写入`input`通道。当没有更多的`Data`实例时，生成器会关闭通道。在这里，我们假设`Data`是JSON可序列化的：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Parsing an array of objects
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析对象数组
- en: If you have a JSON data source providing an array of objects, you can parse
    these elements and process them using `json.Decoder`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个提供对象数组的JSON数据源，你可以解析这些元素并使用`json.Decoder`处理它们。
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Create `json.Decoder` reading from the input stream.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建从输入流读取的`json.Decoder`。
- en: Parse the array beginning delimiter (`[`) using `json.Decoder.Token()`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`json.Decoder.Token()`解析数组开始分隔符（`[`）。
- en: Decode each element of the array until decoding fails.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解码数组中的每个元素，直到解码失败。
- en: When decoding fails, you have to determine whether the stream ended, or whether
    there is really an error. To check for that, read the next token using `json.Decoder.Token()`.
    If the next token is read successfully and if it is an array end delimiter, `]`,
    then the stream parsing ended successfully. Otherwise, there is an error in the
    input data.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当解码失败时，你必须确定是流结束了，还是确实存在错误。为了检查这一点，使用`json.Decoder.Token()`读取下一个标记。如果成功读取下一个标记，并且它是数组结束分隔符`]`，那么流解析成功结束。否则，输入数据中存在错误。
- en: 'The following example assumes that `json.Decoder` is already constructed to
    read from an input stream. The output is stored in a slice. Alternatively, the
    output can be processed as elements are parsed, or each element can be sent to
    a processing goroutine through a channel:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例假设`json.Decoder`已经构建好，用于从输入流中读取。输出存储在切片中。或者，可以在解析元素时处理输出，或者将每个元素通过通道发送到处理goroutine：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Other ways of streaming JSON
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他流式传输JSON的方式
- en: 'There are other ways of streaming JSON:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方式来流式传输JSON：
- en: Concatenated JSON simply writes JSON objects one after the other
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接JSON简单地连续写入JSON对象
- en: Newline-delimited JSON writes every JSON object as a separate line
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 换行符分隔的JSON将每个JSON对象作为单独的一行写入
- en: Record separator-delimited JSON uses a special record separator character, 0x1E,
    and optionally a newline between each JSON object
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录分隔符分隔的JSON使用特殊的记录分隔符字符0x1E，并在每个JSON对象之间可选地添加换行符
- en: Length-prefixed JSON prefixes the string length of every JSON object as a decimal
    number
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长度前缀JSON将每个JSON对象的字符串长度作为十进制数字进行前缀
- en: 'All these can be read and written using `json.Decoder` and `json.Encoder`.
    A simple package for JSON streaming can be found here: [https://github.com/bserdar/jsonstream](https://github.com/bserdar/jsonstream).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以使用`json.Decoder`和`json.Encoder`进行读取和写入。一个简单的JSON流式传输包可以在以下位置找到：[https://github.com/bserdar/jsonstream](https://github.com/bserdar/jsonstream)。
- en: Security considerations
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全考虑
- en: Whenever you accept data from outside your application (user-entered data, API
    calls, reading a file, etc.), you have to be concerned about malicious input.
    JSON input is relatively safe because JSON parsers do not perform data expansions
    like YAML or XML parsers do. Nevertheless, there are still things you need to
    consider when dealing with JSON data.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时从你的应用程序外部接受数据（用户输入的数据、API调用、读取文件等），你都必须关注恶意输入。JSON输入相对安全，因为JSON解析器不执行数据扩展，如YAML或XML解析器所做的那样。然而，在处理JSON数据时，你仍然需要考虑一些事情。
- en: How to do it...
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Limit the amount of data when accepting third-party JSON input. Do not blindly
    use `io.ReadAll` or `json.Decode`:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接受第三方JSON输入时限制数据量。不要盲目使用`io.ReadAll`或`json.Decode`：
- en: '[PRE28]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Always provide an upper limit for resource allocations based on data you read
    from third-party input. For instance, if you are reading a length-prefixed JSON
    stream where each JSON object is prefixed by its length, do not allocate a `[]byte`
    to store the next object. Reject the input if the length is too large.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于从第三方输入读取的数据，始终为资源分配提供上限。例如，如果你正在读取一个长度前缀的JSON流，其中每个JSON对象都由其长度前缀，不要分配一个`[]byte`来存储下一个对象。如果长度太大，则拒绝输入。
