["```go\n// Run \"go build\" to build the subprocess in the \"sub\" directory\nfunc buildProgram() {\n    // Create a Command with the executable and its arguments\n     cmd := exec.Command(\n       \"go\", \"build\", \"-o\", \"subprocess\", \".\")\n    // Set the working directory\n     cmd.Dir = \"sub\"\n    // Collect the stdout and stderr as a combined output from the \n    // process\n    // This will run the process, and wait for it to end\n     output, err := cmd.CombinedOutput()\n     if err != nil {\n          panic(err)\n     }\n     // The build command will not print anything if successful. So if\n     // there is any output, it is a failure.\n     if len(output) > 0 {\n          panic(string(output))\n     }\n}\n```", "```go\n// Run the program built by buildProgram function for 10ms, reading \n// from the output\n// and error pipes concurrently\nfunc runSubProcessStreamingOutputs() {\n    // Create a context with timeout\n     ctx, cancel := context.WithTimeout(context.Background(), 10*time.\n     Millisecond)\n     defer cancel()\n    // Create the command that will timeout in 10ms\n     cmd := exec.CommandContext(ctx, \"sub/subprocess\")\n    // Pipe the output and error streams\n     stdout, err := cmd.StdoutPipe()\n     if err != nil {\n          panic(err)\n     }\n     stderr, err := cmd.StderrPipe()\n     if err != nil {\n          panic(err)\n     }\n     // Read from stderr from a separate goroutine\n     go func() {\n          io.Copy(os.Stderr, stderr)\n     }()\n    // Start running the program\n     err = cmd.Start()\n     if err != nil {\n          panic(err)\n     }\n    // Copy the stdout of the child program to our stdout\n     io.Copy(os.Stdout, stdout)\n    // Wait for the program to end\n     err = cmd.Wait()\n     if err != nil {\n          fmt.Println(err)\n     }\n}\n```", "```go\n// Run the build subprocess for 10 ms with combined output\nfunc runSubProcessCombinedOutput() {\n    // Create a context with timeout\n     ctx, cancel := context.WithTimeout(context.Background(), 10*time.\n     Millisecond)\n     defer cancel()\n    // Define the command with the context\n     cmd := exec.CommandContext(ctx, \"sub/subprocess\")\n    // Assign both stdout and stderr to the same stream. This is \n    // equivalent to calling CombinedOutput\n     cmd.Stdout = os.Stdout\n     cmd.Stderr = os.Stdout\n    // Start the process\n     err := cmd.Start()\n     if err != nil {\n          panic(err)\n     }\n    // Wait until it ends. The output will be printed to our stdout\n     err = cmd.Wait()\n     if err != nil {\n          fmt.Println(err)\n     }\n}\n```", "```go\nvar cmd *exec.Cmd\nswitch runtime.GOOS {\ncase \"windows\":\n     cmd = exec.Command(\"cmd\", \"/C\", \"echo test>test.txt\")\ncase \"darwin\": // Mac OS\n     cmd = exec.Command(\"/bin/sh\", \"-c\", \"echo test>test.txt\")\ncase \"linux\": // Linux system, assuming there is bash\n     cmd = exec.Command(\"/bin/bash\", \"-c\", \"echo test>test.txt\")\ndefault: // Some other OS. Assume it has `sh`\n     cmd = exec.Command(\"/bin/sh\", \"-c\", \"echo test>test.txt\")\n}\nout, err := cmd.Output()\n```", "```go\n    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Millisecond)\n    defer cancel()\n    cmd := exec.CommandContext(ctx, \"sub/subprocess\")\n    pipe, err := cmd.StdoutPipe()\n    if err != nil {\n      panic(err)\n    }\n    ```", "```go\n    // Read from the pipe in a separate goroutine\n    go func() {\n      // Filter lines that contain \"0\"\n      scanner := bufio.NewScanner(pipe)\n      for scanner.Scan() {\n        line := scanner.Text()\n        if strings.Contains(line, \"0\")  {\n          fmt.Printf(\"Filtered line: %s\\n\", line)\n        }\n      }\n      if err := scanner.Err(); err != nil {\n        fmt.Println(\"Scanner error: %v\", err)\n      }\n    }()\n    ```", "```go\n    err = cmd.Start()\n    if err != nil {\n      panic(err)\n    }\n    ```", "```go\n    err = cmd.Wait()\n    if err != nil {\n      fmt.Println(err)\n    }\n    ```", "```go\n    // Run grep and search for a word\n    cmd := exec.Command(\"grep\", word)\n    ```", "```go\n    // Open a file\n    input, err := os.Open(\"input.txt\")\n    if err != nil {\n      panic(err)\n    }\n    cmd.Stdin = input\n    ```", "```go\n    if err = cmd.Start(); err != nil {\n      panic(err)\n    }\n    if err = cmd.Wait(); err != nil {\n      panic(err)\n    }\n    ```", "```go\n    // Run grep and search for a word\n    cmd := exec.Command(\"grep\", word)\n    ```", "```go\n    input, err:=cmd.StdinPipe()\n    if err!=nil {\n      panic(err)\n    }\n    ```", "```go\n    go func() {\n      // Defer close the pipe\n      defer input.Close()\n      // Open a file\n      file, err := os.Open(\"input.txt\")\n      if err != nil {\n        panic(err)\n      }\n      defer file.Close()\n      io.Copy(input,file)\n    }()\n    ```", "```go\n    if err = cmd.Start(); err != nil {\n      panic(err)\n    }\n    if err = cmd.Wait(); err != nil {\n      panic(err)\n    }\n    ```", "```go\n    // Run the server\n    cmd:=exec.Command(\"./server\")\n    // Copy current process environment variables\n    cmd.Env=os.Environ()\n    // Append new environment variables\n    // Set the authentication key as an environment variable\n    // of the current process\n    cmd.Env=append(cmd.Env,fmt.Sprintf(\"AUTH_KEY=%s\", authkey))\n    // Start the server process. Parent process environment is copied to\n    cmd.Start()\n    ```", "```go\nfunc main() {\n  // Create a simple HTTP echo service\n  http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n    io.Copy(w, r.Body)\n  })\n  server := &http.Server{Addr: \":8080\"}\n  // Listen for SIGINT and SIGTERM signals\n  // Terminate the server with the signal\n  sigTerm := make(chan os.Signal, 1)\n  signal.Notify(sigTerm, syscall.SIGINT, syscall.SIGTERM)\n  go func() {\n    <-sigTerm\n    // 5 second timeout for the server to shutdown\n    ctx, cancel := context.WithTimeout(context.Background(), 5*time.\n    Second)\n    defer cancel()\n    server.Shutdown(ctx)\n  }()\n  // Start the server. When the server shuts down, program will end\n  server.ListenAndServe()\n}\n```"]