["```go\n    // The address:port to listen. If none given, use :0 to select \n    // port randomly\n    addr:=\":8080\"\n    // Create a TCP listener\n    listener, err := net.Listen(\"tcp\", addr)\n    if err != nil {\n      panic(err)\n    }\n    // Print out the address we are listening\n    fmt.Println(\"Listening on \", listener.Addr())\n    defer listener.Close()\n    ```", "```go\n    // Listen to incoming TCP connections\n    for {\n      // Accept a connection\n      conn, err := listener.Accept()\n      if err != nil {\n        fmt.Println(err)\n        return\n      }\n      // Handle the connection in its own goroutine\n      go handleConnection(conn)\n    }\n    ```", "```go\n    func handleConnection(conn net.Conn) {\n      io.Copy(conn,conn)\n    }\n    This program will write everything it reads from the connection back to the connection, forming an echo service. When the client terminates the connection, the read operation will return `io.EOF`, terminating the copy operation.\n    ```", "```go\n         conn, err := net.Dial(\"tcp\", addr)\n         if err != nil {\n          // Handle error\n         }\n    ```", "```go\n       // Send a line of text\n       text := []byte(\"Hello echo server!\")\n       conn.Write(text)\n       // Read the response\n       response := make([]byte, len(text))\n       conn.Read(response)\n       fmt.Println(string(response))\n    ```", "```go\n    conn.Close()\n    ```", "```go\nvar address = flag.String(\"a\", \":8008\", \"Server address\")\nfunc main() {\n     flag.Parse()\n     conn, err := net.Dial(\"tcp\", *address)\n     if err != nil {\n          panic(err)\n     }\n     // Send a line of text\n     text := []byte(\"Hello echo server!\")\n     conn.Write(text)\n     // Read the response\n     response := make([]byte, len(text))\n     conn.Read(response)\n     fmt.Println(string(response))\n     conn.Close()\n}\n```", "```go\n// Limit line length to 1KiB.\nconst MaxLineLength = 1024\nfunc handleConnection(conn net.Conn) error {\n  defer conn.Close()\n  // Wrap the connection with a limited reader\n  // to prevent the client from sending unbounded\n  // amount of data\n  limiter := &io.LimitedReader {\n    R: conn,\n    N: MaxLineLength+1, // Read one extra byte to detect long lines\n  }\n  reader := bufio.NewReader(limiter)\n  for {\n    bytes, err := reader.ReadBytes(byte('\\n'))\n    if err != nil {\n      if err != io.EOF {\n        // Some error other than end-of-stream\n        return err\n      }\n      // End of stream. It could be because the line is too long\n      if limiter.N==0 {\n        // Line was too long\n        return fmt.Errorf(\"Received a line that is too long\")\n      }\n      // End of stream\n      return nil\n    }\n    // Reset the limiter, so the next line can be read with\n    // newlimit\n    limiter.N=MaxLineLength+1\n    // Process the line: send it back to client\n    if _, err := conn.Write(bytes); err != nil {\n      return err\n    }\n  }\n}\n```", "```go\ntype fileMetadata struct {\n     Size    uint64\n     Mode    uint32\n     NameLen uint16\n}\n```", "```go\nvar address = flag.String(\"a\", \":8008\", \"Server address\")\nvar file = flag.String(\"file\", \"\", \"File to send\")\nfunc main() {\n     flag.Parse()\n     // Open the file\n     file, err := os.Open(*file)\n     if err != nil {\n          panic(err)\n     }\n     // Connect the receiver\n     conn, err := net.Dial(\"tcp\", *address)\n     if err != nil {\n          panic(err)\n     }\n     // Encode file metadata\n     fileInfo, err := file.Stat()\n     if err != nil {\n          panic(err)\n     }\n     md := fileMetadata{\n          Size:    uint64(fileInfo.Size()),\n          Mode:    uint32(fileInfo.Mode()),\n          NameLen: uint16(len(fileInfo.Name())),\n     }\n     if err := binary.Write(conn, binary.LittleEndian, md); err != nil {\n          panic(err)\n     }\n     // The file name\n     if _, err := conn.Write([]byte(fileInfo.Name())); err != nil {\n          panic(err)\n     }\n     // The file contents\n     if _, err := io.Copy(conn, file); err != nil {\n          panic(err)\n     }\n     conn.Close()\n}\n```", "```go\nfunc handleConnection(conn net.Conn) {\n     defer conn.Close()\n     // Read the file metadata\n     var meta fileMetadata\n     err := binary.Read(conn, binary.LittleEndian, &meta)\n     if err != nil {\n          fmt.Println(err)\n          return\n     }\n     // Do not allow file names that are too long\n     if meta.NameLen > 255 {\n          fmt.Println(\"File name too long\")\n          return\n     }\n     // Read the file name\n     name := make([]byte, meta.NameLen)\n     _, err = io.ReadFull(conn, name)\n     if err != nil {\n          fmt.Println(err)\n          return\n     }\n     path:=filepath.Join(\"downloads\",string(name))\n     // Create the file\n     file, err := os.OpenFile(\n          path,\n          os.O_CREATE|os.O_WRONLY,\n          os.FileMode(meta.Mode),\n     )\n     if err != nil {\n          fmt.Println(err)\n          return\n     }\n     defer file.Close()\n     // Copy the file contents\n     _, err = io.CopyN(file, conn, int64(meta.Size))\n     if err != nil {\n          // Remove file in case of error\n             os.Remove(path)\n             fmt.Println(err)\n             return\n     }\n     fmt.Printf(\"Received file %s: %d bytes\\n\", string(name), meta.\n     Size)\n}\n```", "```go\nvar (\n   address     = flag.String(\n     \"a\", \":4433\", \"Address to listen\")\n   certificate = flag.String(\n     \"c\", \"../server.crt\", \"Certificate file\")\n   key         = flag.String(\n     \"k\", \"../privatekey.pem\", \"Private key\")\n)\nfunc main() {\n   flag.Parse()\n   // 2.1 Load the key pair\n   cer, err := tls.LoadX509KeyPair(*certificate, *key)\n   if err != nil {\n        panic(err)\n   }\n   // 2.2 Create TLS configuration for the listener\n   config := &tls.Config{\n        Certificates: []tls.Certificate{cer},\n   }\n   // 2.3 Create the listener\n   listener, err := tls.Listen(\"tcp\", *address, config)\n   if err != nil {\n        panic(err)\n        return\n   }\n   defer listener.Close()\n   fmt.Println(\"Listening TLS on \", listener.Addr())\n   // 2.4 Listen to incoming TCP connections\n   for {\n        conn, err := listener.Accept()\n        if err != nil {\n             fmt.Println(err)\n             return\n        }\n        go handleConnection(conn)\n   }\n}\n```", "```go\nvar (\n     addr     = flag.String(\n       \"addr\", \"\", \"Server address\")\n     certFile = flag.String(\n       \"cert\", \"../server.crt\", \"TLS certificate file\")\n)\nfunc main() {\n     flag.Parse()\n     // 3.1 Create new certificate pool\n     roots := x509.NewCertPool()\n     // 3.2 Load server certificate\n     certData, err := os.ReadFile(*certFile)\n     if err != nil {\n          panic(err)\n     }\n     ok := roots.AppendCertsFromPEM(certData)\n     if !ok {\n          panic(\"failed to parse root certificate\")\n     }\n     // 3.3 Connect the server\n     conn, err := tls.Dial(\"tcp\", *addr, &tls.Config{\n          RootCAs: roots,\n     })\n     if err != nil {\n          panic(err)\n     }\n     // 3.4 Send a line of text\n     text := []byte(\"Hello echo server!\")\n     conn.Write(text)\n     // Read the response\n     response := make([]byte, len(text))\n     conn.Read(response)\n     fmt.Println(string(response))\n     conn.Close()\n}\n```", "```go\nvar (\n     tlsAddress      = flag.String(\n       \"a\", \":4433\", \"TLS address to listen\")\n     serverAddresses = flag.String(\n       \"s\", \":8080\", \"Server addresses, comma separated\")\n     certificate     = flag.String(\n       \"c\", \"../server.crt\", \"Certificate file\")\n     key             = flag.String(\n       \"k\", \"../privatekey.pem\", \"Private key\")\n)\nfunc main() {\n     flag.Parse()\n     // 1\\. Create external facing TLS receiver\n     // Load the key pair\n     cer, err := tls.LoadX509KeyPair(*certificate, *key)\n     if err != nil {\n          panic(err)\n     }\n     // Create TLS configuration for the listener\n     config := &tls.Config{\n          Certificates: []tls.Certificate{cer},\n     }\n     // Create the tls listener\n     tlsListener, err := tls.Listen(\"tcp\", *tlsAddress, config)\n     if err != nil {\n          panic(err)\n     }\n     defer tlsListener.Close()\n     fmt.Println(\"Listening TLS on \", tlsListener.Addr())\n     // Listen to incoming TLS connections\n     servers := strings.Split(*serverAddresses, \",\")\n     fmt.Println(\"Forwarding to servers: \", servers)\n     nextServer := 0\n     for {\n          // 2\\. Listen to incoming TLS connections\n          conn, err := tlsListener.Accept()\n          if err != nil {\n               fmt.Println(err)\n               return\n          }\n          retries := 0\n          for {\n               // 3\\. Select the next server\n               server := servers[nextServer]\n               nextServer++\n               if nextServer >= len(servers) {\n                    nextServer = 0\n               }\n               // Start a connection to this server\n               targetConn, err := net.Dial(\"tcp\", server)\n               if err != nil {\n                    retries++\n                    fmt.Errorf(\"Cannot connect to %s\", server)\n                    if retries > len(servers) {\n                         panic(\"None of the servers are available\")\n                    }\n                    continue\n               }\n               // 4\\. Start the proxy\n               go handleProxy(conn, targetConn)\n          }\n     }\n}\n```", "```go\nfunc handleProxy(conn, targetConn net.Conn) {\n     defer conn.Close()\n     defer targetConn.Close()\n     // Copy data from the client to the server\n     go io.Copy(targetConn, conn)\n     // Copy data from the server to the client\n     io.Copy(conn, targetConn)\n}\n```", "```go\n    conn.SetDeadline(time.Now().Add(timeoutSeconds * timeSecond))\n    if n, err:=conn.Read(data); err!=nil {\n      if errors.Is(err, os.ErrDeadlineExceeded) {\n        // Deadline exceeded.\n      } else {\n        // Some other error\n      }\n    }\n    ```", "```go\n    conn.SetDeadline(time.Time{})\n    ```", "```go\n    cancel:=make(chan struct{})\n    done:=make(chan struct{})\n    // Close the connection if a message is sent to cancel channel\n    go func() {\n       select {\n          case <-cancel:\n             conn.Close()\n          case <-done:\n       }\n    }()\n    go handleConnection(conn)\n    ```", "```go\n    unblock:=make(chan struct{})\n    // Unblock the connection if a message is sent to unblock channel\n    go func() {\n      <-unblock\n      conn.SetDeadline(time.Now())\n    }()\n    timedout:=false\n    if n, err:=conn.Read(data); err!=nil {\n       if errors.Is(err,os.ErrDeadlineExceeded) {\n          // Reset connection deadline\n          conn.SetDeadline(time.Time{})\n          timedout=true\n          // continue using the connection\n       } else {\n          // Handle error\n       }\n    }\n    if timedout {\n      // Read timedout\n    } else {\n      // Read did not timeout\n    }\n    ```", "```go\n      addr, err := net.ResolveUDPAddr(\"udp4\", *address)\n      if err != nil {\n        panic(err)\n      }\n    ```", "```go\n      // Create a UDP connection\n      conn, err := net.ListenUDP(\"udp4\", addr)\n      if err != nil {\n        panic(err)\n      }\n      defer conn.Close()\n    ```", "```go\n      // Listen to incoming UDP connections\n      buf := make([]byte, 1024)\n      n, remoteAddr, err := conn.ReadFromUDP(buf)\n      if err != nil {\n        // Handle the error\n      }\n      fmt.Printf(\"Received %d bytes from %s\\n\", n, remoteAddr)\n    ```", "```go\n      if n > 0 {\n        _, err := conn.WriteToUDP(buf[:n], remoteAddr)\n        if err != nil {\n          // Handle the error\n        }\n      }\n    ```", "```go\n      addr, err := net.ResolveUDPAddr(\"udp4\", *serverAddress)\n      if err != nil {\n        panic(err)\n      }\n    ```", "```go\n      // Create a UDP connection, local address chosen randomly\n      conn, err := net.DialUDP(\"udp4\", nil, addr)\n      if err != nil {\n        panic(err)\n      }\n      fmt.Printf(\"UDP server %s\\n\", conn.RemoteAddr())\n      defer conn.Close()\n    ```", "```go\n      // Send a line of text\n      text := []byte(\"Hello echo server!\")\n      n, err := conn.Write(text)\n      if err != nil {\n        panic(err)\n      }\n      fmt.Printf(\"Written %d bytes\\n\", n)\n    ```", "```go\n      // Read the response\n      response := make([]byte, 1024)\n      conn.ReadFromUDP(response)\n    ```", "```go\n    response, err := http.Get(\"http://example.com\")\n    if err!=nil {\n      // Handle error\n    }\n    // Always close response body\n    defer response.Body.Close()\n    if response.StatusCode/100==2 {\n      // HTTP 2xx, call was successful.\n      // Work with response.Body\n    }\n    ```", "```go\n    client:=http.Client{\n      // Set a timeout for all outgoing calls.\n      // If the call does not complete within 30 seconds, timeout.\n      Timeout: 30*time.Second,\n    }\n    response, err:=client.Get(\"http://example.com\")\n    if err!=nil {\n      // handle error\n    }\n    // Always close response body\n    defer response.Body.Close()\n    ```", "```go\n    response, err := http.Get(\"https://example.com\")\n    ```", "```go\n        roots := x509.NewCertPool()\n        ```", "```go\n        certData, err := os.ReadFile(*certFile)\n        if err != nil {\n          panic(err)\n        }\n        ```", "```go\n        ok := roots.AppendCertsFromPEM(certData)\n        if !ok {\n          panic(\"failed to parse root certificate\")\n        }\n        ```", "```go\n        config:=tls.Config{\n          RootCAs: roots,\n        }\n        ```", "```go\n        transport := &http.Transport {\n          TLSClientConfig: &config,\n        }\n        ```", "```go\n        client:= &http.Client{\n          Transport: transport,\n        }\n        ```", "```go\n        resp, err:=client.Get(url)\n        if err!=nil {\n          // Handle error\n        }\n        defer resp.Body.Close()\n        ```", "```go\n    func myHandler(w http.ResponseWriter, req *http.Request) {\n      if req.Method == http.MethodGet {\n        // Handle an HTTP GET request\n      }\n      ...\n    }\n    ```", "```go\n    err:=http.ListenAndServe(\":8080\",http.HandlerFunc(myHandler))\n    log.Fatal(err)\n    ```", "```go\n        server := http.Server {\n          // The address to listen\n          Addr: \":8080\",\n          // The handler function\n          Handler: http.HandlerFunc(myHandler),\n          // The handlers must read the request within 10 seconds\n          ReadTimeout: 10*time.Second,\n          // The headers of a request must be read within 5 seconds\n          ReadHeaderTimeout: 5*time.Second,\n        }\n        ```", "```go\n        err:=server.ListenAndServe()\n        log.Fatal(err)\n        ```", "```go\n    server := http.Server {\n       Addr: \":4443\",\n       Handler: handler,\n    }\n    server.ListenAndServeTLS(\"cert.pem\", \"key.pem\")\n    ```", "```go\n    http.HandleFunc(\"/\",func(w http.ResponseWriter, req *http.Request) {\n      // Handle request\n    })\n    http.ListenAndServeTLS(\"cert.pem\", \"key.pem\")\n    ```", "```go\n    cert, err := tls.LoadX509KeyPair(\"cert.pem\", \"key.pem\")\n    if err!=nil {\n      panic(err)\n    }\n    ```", "```go\n    tlsConfig := &tls.Config{\n      Certificates: []tls.Certificate{cert},\n    }\n    ```", "```go\n    server := http.Server{\n      Addr:      \":4443\",\n      Handler:   handler,\n      TLSConfig: tlsConfig,\n    }\n    ```", "```go\n    server.ListenAndServeTLS(\"\",\"\")\n    ```", "```go\n    mux := http.NewServeMux()\n    mux.HandleFunc(\"GET /health\",func(w http.ResponseWriter, req *http.Request) {\n      w.Write([]byte(\"Ok\")\n    })\n    ...\n    server := http.Server {\n      Handler: mux,\n      Addr: \":8080\",\n      ...\n    }\n    server.ListenAndServe()\n    ```", "```go\n        // The RandomService reads random data from a source, and \n        // returns random numbers\n        type RandomService struct {\n          rndSource io.Reader\n        }\n        ```", "```go\n        func (svc RandomService) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n          // Read 4 bytes from the random number source, convert it to string\n          data:= make([]byte,4)\n          _,err:=svc.rndSource.Read(data)\n          if err!=nil {\n            // This will return an HTTP 500 error with the error message\n            // as the message body\n            http.Error(w,err.Error(),http.StatusInternalServerError)\n            return\n          }\n          // Decode random data using binary little endian encoding\n          value:=binary.LittleEndian.Uint32(data)\n          // Write the data to the output\n          w.Write([]byte(strconv.Itoa(int(value))))\n        }\n        ```", "```go\n        file, err:=os.Open(\"/dev/random\")\n        if err!=nil {\n          panic(err)\n        }\n        defer file.Close()\n        svc:=RandomService {\n          rndSource: file,\n        }\n        ```", "```go\n    mux:=http.NewServeMux()\n    ```", "```go\n    mux.Handle(\"GET /rnd\", svc)\n    ```", "```go\n    server := http.Server {\n      Handler: mux,\n      Addr: \":8080\",\n      ...\n    }\n    server.ListenAndServe()\n    ```", "```go\n        type UserHandler struct {\n          DB *sql.DB\n        }\n        ```", "```go\n    func (hnd UserHandler) GetUser(w http.ResponseWriter, req *http.Request) {\n      ...\n    }\n    ```", "```go\n    userDb, err:=sql.Open(driver, UserDBUrl)\n    if err!=nil {\n      panic(err)\n    }\n    userHandler := UserHandler {\n      DB: userDb,\n    }\n    ```", "```go\n    mux := http.NewServeMux()\n    ```", "```go\n    mux.Handle(\"GET /users/{userId}\",userHandler.GetUser)\n    mux.Handle(\"POST /users\", userHandler.NewUser)\n    mux.Handle(\"DELETE /users/{userId}\", userHandler.DeleteUser)\n    ```", "```go\n    server := http.Server{\n       Addr: serverAddr,\n       Handler: mux,\n    }\n    server.ListenAndServe()\n    ```", "```go\nfunc (hnd UserHandler) GetUser(w http.ResponseWriter, req *http.Request) {\n  // User req.PathValue(\"userId\") to get userId portion of /users/\n  // {userId}\n  // That is, if this API is invoked with GET /users/123, then after \n  // the following line `userId` is assigned to \"123\"\n  userId:=req.PathValue(\"userId\")\n  // Get user data from the DB\n  user, err:=GetUserInformation(hnd.DB,userId)\n  if err!=nil {\n    http.Error(w,err.Error(),http.StatusNotFound)\n    return\n  }\n  // Marshal user data to JSON\n  data, err:=json.Marshal(user)\n  if err!=nil {\n    http.Error(w, err.Error(),http.StatusInternalServerError)\n    return\n  }\n  // Set the content type header. You **must** set all headers before\n  // writing the body. Once the body is placed on the write, there is \n  // no way to change a header that is already written.\n  w.Header().Set(\"Content-Type\",\"application/json\")\n  w.Write(data)\n}\n```", "```go\n    fileHandler := http.FileServer(http.Dir(\"/var/www\"))\n    server:=http.Server{\n      Addr: addr,\n      Handler: fileHandler,\n    }\n    http.ListenAndServe()\n    /var/www at the root path. That is, a GET /index.html request will serve the /var/www/index.html file with Content-Type: text/html. Similarly, a GET /css/styles.css will serve /var/www/css/styles.css with Content-Type: text/css.\n    ```", "```go\n    fileHandler := http.StripPrefix(\"/static/\", http.FileHandler(http.Dir(\"/var/www\"))\n    ```", "```go\n    // Serve only HTML files in the given directory\n    type htmlFS struct {\n      fs *http.FileSystem\n    }\n    // Filter file names by their extension before opening them\n    func (h htmlFS) Open(name string) (http.File, error) {\n      if strings.ToLower(filepath.Ext(name))==\".html\" {\n        return h.fs.Open(name)\n      }\n      return nil, os.ErrNotFound\n    }\n    ...\n    htmlHandler := http.FileHandler(htmlFS{fs:http.Dir(\"/var/www\"))\n    // htmlHandler serves all HTML files under /var/www\n    ```", "```go\n    <form method=\"POST\" action=\"/auth/login\">\n    <input type=\"text\" name=\"userName\">\n    <input type=\"password\" name=\"password\">\n    <button type=\"submit\">Submit</button>\n    </form>\n    ```", "```go\n    type UserHandler struct {\n      Auth Authenticator\n    }\n    func (h UserHandler) HandleLogin(w http.ResponseWriter, req *http.Request) {\n      // Parse the submitted form. This fills up req.PostForm\n      // with the submitted information\n      if err:=req.ParseForm(); err!=nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n      }\n      // Get the submitted fields\n      userName := req.PostForm.Get(\"userName\")\n      password := req.PostForm.Get(\"password\")\n      // Handle the login request, and get a cookie\n      cookie,err:=h.Auth.Authenticate(userName,password);\n      if err!=nil {\n        // Send the user back to login page, setting an error\n        // cookie containing an error message\n        http.SetCookie(w,h.NewErrorCookie(\"Username or password \n        invalid\"))\n        http.Redirect(w, req, \"/login.html\", http.StatusFound)\n        return\n      }\n      // Set the cookie representing user session\n      http.SetCookie(w,cookie)\n      // Redirect the user to the main page\n      http.Redirect(w,req,\"/dashboard.html\",http.StatusFound)\n    }\n    ```", "```go\n        userHandler := UserHandler {\n          Auth: authenticator,\n        }\n        mux := http.NewServeMux()\n        mux.HandleFunc(\"POST /auth/login\", userHandler.HandleLogin)\n        mux.HandleFunc(\"GET /login.html\", userHandler.ShowLoginPage)\n        ```", "```go\nfunc (h UserHandler) ShowLoginPage(w http.ResponseWriter, req *http.Request) {\n  loginFormData:=map[string]any{}\n  cookie, err:= req.Cookie(\"error_cookie\")\n  if err==nil {\n    loginFormData[\"error\"] = cookie.Value\n    // Unset the cookie\n    http.SetCookie(w, &http.cookie {\n      Name: \"error_cookie\",\n      MaxAge: 0,\n    })\n  }\n  w.Header().Set(\"Content-Type\",\"text/html\")\n  loginFormTemplate.Execute(w,loginFormData)\n}\n```", "```go\nfunc (h UserHandler) NewErrorCookie(msg string) *http.Cookie {\n  return &http.Cookie {\n    Name: \"error_cookie\",\n    Value: msg,\n    MaxAge: 60, // Cookie lives for 60 seconds\n    Path:   \"/\",\n  }\n}\n```", "```go\nfunc DownloadHandler(w http.ResponseWriter, req *http.Request) {\n  fileName := req.PathValue(\"fileName\")\n  f, err:= os.Open(filepath.Join(\"/data\",fileName))\n  if err!=nil {\n    http.Error(w,err.Error(),http.StatusNotFound)\n    return\n  }\n  defer f.Close()\n  w.Header.Set(\"Content-Type\",\"application/octet-stream\")\n  w.Header.Set(\"Content-Length\",  strconv.Itoa(f.Length()))\n  io.Copy(w,f)\n}\n```", "```go\n<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\n  <input type=\"text\" name=\"textField\">\n  <input type=\"file\" name=\"fileField\">\n  <button type=\"submit\">submit</button>\n</form>\n```", "```go\n    reader, err:=request.MultipartReader()\n    if err!=nil {\n      http.Error(w,\"Not a multipart request\",http.StatusBadRequest)\n      return\n    }\n    ```", "```go\n    for {\n      part, err:= reader.NextPart()\n      if errors.Is(err,io.EOF) {\n        break\n      }\n      if err!=nil {\n        http.Error(w,err.Error(),http.StatusBadRequest)\n        return\n      }\n    }\n    ```", "```go\n        formValues:=make(url.Values)\n        if fileName:=part.FileName(); fileName!=\"\" {\n          // This part contains a file\n          output, err:=os.Create(fileName)\n          if err!=nil {\n            // Handle error\n          }\n          defer output.Close()\n          if err:=io.Copy(output,part); err!=nil {\n            // Handle error\n          }\n        } else if fieldName := part.FormName(); fieldName!=\"\" {\n          // This part contains form data for an input field\n          data, err := io.ReadAll(part)\n          if err!=nil {\n            // Handle error\n          }\n          formValues[fieldName]=append(formValues[fieldName],\n          string(data))\n        }\n        ```"]