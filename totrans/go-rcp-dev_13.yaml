- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Network Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络编程
- en: Network programming is a crucial skill for application developers. An extensive
    treatise on the topic would be a formidable endeavor, so we will look at some
    of the select examples you might encounter in your work. An important point to
    keep in mind is that network programming is the primary means of creating vulnerabilities
    in an application. Network programs are also inherently concurrent, making correct
    and safe network programming especially difficult. So, this section will include
    examples written with security and scalability in mind.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络编程是应用程序开发者的一项关键技能。关于这个主题的广泛论述将是一项艰巨的任务，因此我们将探讨您在工作中可能会遇到的一些精选示例。需要记住的一个重要观点是，网络编程是创建应用程序漏洞的主要手段。网络程序本质上也是并发的，这使得正确和安全的网络编程特别困难。因此，本节将包括一些考虑安全和可扩展性的示例。
- en: 'This chapter contains the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下示例：
- en: Writing TCP servers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 TCP 服务器
- en: Writing TCP clients
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 TCP 客户端
- en: Writing a line-based TCP server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写基于行的 TCP 服务器
- en: Sending/receiving files using a TCP connection
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TCP 连接发送/接收文件
- en: Writing a TLS client/server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 TLS 客户端/服务器
- en: A TCP proxy for TLS termination and load-balancing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 TLS 终止和负载均衡的 TCP 代理
- en: Setting read/write deadlines
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置读写截止日期
- en: Unblocking a blocked read or write operation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解除阻塞的读写操作
- en: Writing UDP clients/servers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 UDP 客户端/服务器
- en: Making HTTP calls
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送 HTTP 调用
- en: Running an HTTP server
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 HTTP 服务器
- en: HTTPS – setting up a TLS server
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 TLS 服务器以使用 HTTPS
- en: Writing HTTP handlers
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 HTTP 处理器
- en: Serving static files on the file system
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件系统上提供静态文件
- en: Handling HTML forms
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 HTML 表单
- en: Writing a handler for downloading large files
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写用于下载大文件的处理器
- en: Handling HTTP uploaded files and forms as a stream
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 HTTP 上传文件和表单作为流处理
- en: TCP networking
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP 网络
- en: '**Transmission Control Protocol** (**TCP**) is a connection-oriented protocol
    that provides the following guarantees:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输控制协议**（**TCP**）是一种面向连接的协议，它提供了以下保证：'
- en: '**Reliability**: The sender will know whether the intended recipient received
    the data'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：发送者将知道预期的接收者是否已收到数据'
- en: '**Ordering**: Messages will be received in the order they are sent in'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序**：消息将以发送的顺序接收'
- en: '**Error-checked**: Messages will be protected against corruption during transit'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误检查**：消息将在传输过程中受到保护，防止损坏'
- en: Thanks to these guarantees, TCP is relatively easy to work with. It is the basis
    for many higher-level protocols such as HTTP and WebSockets. In this section,
    we will look at some recipes that show how to write TCP servers and clients.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些保证，TCP 相对容易处理。它是许多高级协议（如 HTTP 和 WebSockets）的基础。在本节中，我们将探讨一些示例，展示如何编写 TCP
    服务器和客户端。
- en: Writing TCP servers
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 TCP 服务器
- en: A TCP server is a program that listens to connection requests on a network port.
    Once a connection is established with a client, the communication between the
    client and the server takes place over a `net.Conn` object. The server may continue
    to listen for new connections. This way, a single server can communicate with
    many clients.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 服务器是一个监听网络端口连接请求的程序。一旦与客户端建立连接，客户端和服务器之间的通信将通过 `net.Conn` 对象进行。服务器可以继续监听新的连接。这样，单个服务器就可以与多个客户端通信。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Select a port that will connect to the clients server.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个将连接到客户端服务器的端口号。
- en: This is usually a matter of application configuration. The first 1,024 (`0`
    to `1023`) ports usually require a server program to have root privileges. Most
    of these ports are reserved for well-known server programs, such as port 22 for
    ssh, or port 80 for HTTP. Ports 1024 and above are ephemeral ports. Your server
    program can use any port number of 1,024 and above without additional privileges
    as long as no other program is listening to it.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这通常是一个应用程序配置问题。前 1,024 (`0` 到 `1023`) 个端口通常需要服务器程序具有 root 权限。这些端口中的大多数都保留给了知名的服务器程序，例如端口
    22 用于 ssh，或端口 80 用于 HTTP。端口 1024 及以上是临时端口。只要没有其他程序监听，您的服务器程序可以使用 1,024 及以上的任何端口号，而无需额外的权限。
- en: Use port number 0 to let the kernel pick a random unused port. You can create
    a listener for port `0`, and then query the listener to find out what port number
    was selected.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用端口号 0 让内核选择一个随机未使用的端口。您可以创建一个监听端口 `0` 的监听器，然后查询监听器以找出所选的端口号。
- en: Create a listener. A listener is a mechanism that binds the `address:port`.
    Once you create a listener using a port number, no other process on the same host,
    or within the same container, can use that port number to listen to network traffic.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个监听器。监听器是一种绑定 `address:port` 的机制。一旦使用端口号创建了一个监听器，同一主机或同一容器上的其他进程就无法使用该端口号来监听网络流量。
- en: 'The following program snippet shows how to create a listener:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面的程序片段显示了如何创建监听器：
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The program first determines the network address to listen to. The exact format
    of the address depends on the protocol chosen, which is TCP in this case. If no
    hostname or IP address is given, the listener will listen to all available unicast
    IP addresses of the local system. If you give a hostname or IP address, the listener
    will only listen to the traffic coming from the given IP address. That means if
    you give `localhost:1234`, the listener will listen to traffic coming from `localhost`
    only. It will not listen to external traffic.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 程序首先确定要监听的网络地址。地址的确切格式取决于选择的协议，在这个例子中是 TCP。如果没有提供主机名或 IP 地址，监听器将监听本地系统上所有可用的单播
    IP 地址。如果你提供了一个主机名或 IP 地址，监听器将只监听来自给定 IP 地址的流量。这意味着如果你提供了 `localhost:1234`，监听器将只监听来自
    `localhost` 的流量。它不会监听外部流量。
- en: The above example prints `listener.Addr()`. This is useful if you provide `:0`
    as the listen address, or if you do not provide one at all. In this case, the
    listener will listen to a random port, and `listener.Addr()` will return the address
    that clients can connect to.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述示例打印 `listener.Addr()`。如果你提供 `:0` 作为监听地址，或者根本不提供地址，这将很有用。在这种情况下，监听器将监听一个随机端口，`listener.Addr()`
    将返回客户端可以连接到的地址。
- en: 'Listen and accept connections. Accept incoming connections using `Listener.Accept()`.
    This is usually done in a loop as follows:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听并接受连接。使用 `Listener.Accept()` 接受传入的连接。这通常在一个循环中完成，如下所示：
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, the `listener.Accept` call will fail with an error if the listener
    is closed.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，如果监听器被关闭，`listener.Accept` 调用将失败并返回错误。
- en: Handle the connection in its own goroutine. This way, the listener will continue
    to accept connections while the server communicates with the connected clients
    in their own goroutines, using the connections created specifically for those
    clients.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在自己的 goroutine 中处理连接。这样，监听器将继续接受连接，同时服务器在其自己的 goroutine 中与连接的客户端通信，使用为这些客户端创建的特定连接。
- en: 'A connection handler for a simple echo server can be written as follows:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 简单回声服务器的连接处理器可以编写如下：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `net.Conn` interface has both the `Read([]byte) (int,error)` method (which
    makes it an `io.Reader`), and `Write([]byte) (int,error)` (which also makes it
    an `io.Writer`). Due to this, whatever is read from the connection is written
    back to it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.Conn` 接口既有 `Read([]byte) (int,error)` 方法（这使得它成为一个 `io.Reader`），也有 `Write([]byte)
    (int,error)` 方法（这也使得它成为一个 `io.Writer`）。正因为如此，从连接中读取的任何内容都会被写回连接。'
- en: You may notice that because of `io.Copy`, every byte read will be written back
    to the connection, so this is not a line-based protocol.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，由于 `io.Copy`，读取的每个字节都会被写回连接，所以这不是一个基于行的协议。
- en: Writing TCP clients
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 TCP 客户端
- en: A TCP client connects to a TCP server that is listening on a port of some host.
    Once the connection is established, communication is bidirectional. In other words,
    the distinction between a server and a client is based on how the connection is
    established. When we say “server,” we mean the program that waits listening to
    a port, and when we say “client,” we mean the program that connects (“dials”)
    a port on a host that is being listened on by a server. Once the connection is
    established, both sides send and receive data asynchronously. TCP guarantees that
    the messages will be received in the order they are sent, and that the messages
    will not be lost, but there are no guarantees on when a message will be received
    by the other side.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 客户端连接到一个在某个主机端口上监听的 TCP 服务器。一旦建立连接，通信是双向的。换句话说，服务器和客户端的区别在于连接是如何建立的。当我们说“服务器”时，我们指的是等待监听端口的程序，当我们说“客户端”时，我们指的是连接到正在被服务器监听的主机端口的程序。一旦建立连接，双方将异步发送和接收数据。TCP
    保证消息将以发送的顺序接收，并且消息不会丢失，但无法保证消息将在何时被对方接收。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: The client side has to know the server address and port. This should be provided
    by the environment (command line, configuration, etc.).
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端必须知道服务器地址和端口号。这应该由环境（命令行、配置等）提供。
- en: 'Use `net.Dial` to create a connection to the server:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`net.Dial`创建到服务器的连接：
- en: '[PRE3]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use the returned `net.Conn` object to send data to the server, or to receive
    data from the server:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用返回的`net.Conn`对象向服务器发送数据，或从服务器接收数据：
- en: '[PRE4]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Close the connection when done:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后关闭连接：
- en: '[PRE5]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is the complete program:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完整的程序：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This example demonstrates a request-response type of interaction with the server.
    This is not necessarily always the case. A network connection provides both an
    `io.Writer` and an `io.Reader` interface, and they can be used concurrently.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例演示了与服务器之间的请求-响应类型交互。这并不一定是始终如此。网络连接提供了`io.Writer`和`io.Reader`接口，并且它们可以并发使用。
- en: Writing a line-based TCP server
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写基于行的TCP服务器
- en: In this recipe, we will look at a TCP server that works with lines instead of
    bytes. There are some points you need to be careful about when reading lines from
    a network connection, especially related to the security of the server. Just because
    you are expecting to read lines does not mean the client will send well-formed
    lines.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看一个使用行而不是字节而不是字节的TCP服务器。在从网络连接读取行时，有一些需要注意的点，特别是与服务器安全相关。仅仅因为你在期待读取行，并不意味着客户端会发送格式良好的行。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Use the same structure to set up the server as given in the previous section.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与上一节中给出的相同结构来设置服务器。
- en: In the connection handler, use a `bufio.Reader` or `bufio.Scanner` to read lines.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在连接处理程序中，使用`bufio.Reader`或`bufio.Scanner`读取行。
- en: Wrap the connection with an `io.LimitedReader` to limit line length.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`io.LimitedReader`包装连接以限制行长度。
- en: 'Let’s take a look at how this can work. The following example shows how a connection
    handler can be implemented:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的。以下示例展示了如何实现连接处理程序：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The connection handling routine starts by wrapping the connection in an `io.LimitedReader`.
    This is necessary to prevent `reader.ReadBytes` from reading an unlimited amount
    of data until it sees the newline character. Without this, a malicious client
    can send large amounts of data without any newline characters, consuming all the
    server memory. Putting a hard limit on the line length prevents this attack vector.
    After reading every line, we reset the `limiter.N` to its original value so the
    next line can be read using the same limits. Note that the limiter is set to read
    one extra byte. This is because the `io.LimitedReader` returns `io.EOF` for both
    a legitimate `EOF` (which means the client disconnected), and a read exceeding
    the limit. If the reader exceeds the limit, that means the last line read is at
    least one byte above the limit, allowing us to decide this is an invalid line.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 连接处理例程首先将连接包装在`io.LimitedReader`中。这是必要的，以防止`reader.ReadBytes`在没有看到换行符的情况下读取无限量的数据。如果没有这个，恶意客户端可以发送大量数据而没有换行符，消耗所有服务器内存。对行长度设置硬限制可以防止这种攻击向量。读取每一行后，我们将`limiter.N`重置为其原始值，以便使用相同的限制读取下一行。请注意，限制器被设置为读取一个额外的字节。这是因为`io.LimitedReader`对于合法的`EOF`（意味着客户端断开连接）和超出限制的读取都返回`io.EOF`。如果读取器超出限制，这意味着最后读取的行至少比限制多一个字节，这使我们能够决定这是一条无效的行。
- en: Sending/receiving files using a TCP connection
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TCP连接发送/接收文件
- en: Sending and receiving files over a TCP connection demonstrates several important
    points about network programming, namely the protocol design (which deals with
    who sends what when) and encoding (which deals with how data elements are represented
    on the wire). This example will show how to transfer metadata and an octet stream
    over a TCP connection.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过TCP连接发送和接收文件演示了网络编程的几个重要点，即协议设计（处理何时发送什么）和编码（处理数据元素如何在线路上表示）。此示例将展示如何在TCP连接上传输元数据和八位字节流。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Use the same structure to set up the server as in the previous section.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与上一节相同的结构来设置服务器。
- en: 'On the sender end (client), do the following:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在发送端（客户端）执行以下操作：
- en: Encode file metadata containing the filename, size, and mode and send it.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码包含文件名、大小和模式的文件元数据并发送。
- en: Send the contents of the file.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送文件内容。
- en: Close the connection.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭连接。
- en: 'On the receiver end (server), do the following:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接收端（服务器）执行以下操作：
- en: Decode file metadata. Create a file to store the received file contents with
    the given mode.
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解码文件元数据。创建一个文件以存储接收到的文件内容，并使用给定的模式。
- en: Receive file contents and write the file.
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收文件内容并写入文件。
- en: After all file content is received, close the file.
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有文件内容接收完毕后，关闭文件。
- en: 'The first part is the transfer of metadata about the file. There are several
    ways this can be done: you can work with a text-based encoding scheme such as
    key-value pairs or JSON, but the problem with such schemes is that they are not
    fixed length. A simple, effective, and portable encoding scheme is binary encoding
    using the `encoding/binary` package. That does not solve the encoding of the filename,
    which is not a fixed-sized string. So, we include the length of the filename in
    the file metadata, and encode the filename using exactly the necessary number
    of bytes.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是传输关于文件的元数据。有几种方法可以实现这一点：你可以使用基于文本的编码方案，如键值对或 JSON，但这类方案的问题是它们不是固定长度的。一个简单、有效且可移植的编码方案是使用
    `encoding/binary` 包的二进制编码。这并不能解决文件名的编码问题，因为文件名不是一个固定大小的字符串。因此，我们在文件元数据中包含文件名的长度，并使用恰好必要的字节数来编码文件名。
- en: 'The fixed-sized `fileMetadata` structure is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 固定大小的 `fileMetadata` 结构如下：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This structure is 14 bytes on all platforms (eight bytes of `Size`, four bytes
    of `Mode`, and two bytes of `NameLen`.) Using `binary/encoding.Write`, you can
    encode this fixed-size structure on the wire using either `binary.BigEndian` or
    `binary.LittleEndian` encoding, and the receiving end will decode it successfully.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构在所有平台上都是 14 字节（8 字节的 `Size`，4 字节的 `Mode` 和 2 字节的 `NameLen`）。使用 `binary/encoding.Write`，你可以使用
    `binary.BigEndian` 或 `binary.LittleEndian` 编码在网络上编码这个固定大小的结构，接收端将成功解码它。
- en: More detailed information on endianness is included in the next chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关于字节序的更详细信息将在下一章中介绍。
- en: 'The rest of the client is as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的其余部分如下：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note the use of `io.Copy` to transfer the actual contents of the file. Using
    `io.Copy`, you can transfer arbitrary-size files to the receiver without consuming
    significant amounts of memory.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用 `io.Copy` 来传输文件的实际内容。使用 `io.Copy`，你可以将任意大小的文件传输给接收者，而不会消耗大量的内存。
- en: 'Now let’s look at the server (receiver):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看服务器（接收者）：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first operation is a fixed-size read operation of the file metadata. Then
    we read the filename. Note the filename length check before reading the filename.
    It is an important defensive approach to validate and limit all memory allocations
    involving size read from an external system or user. Here, we reject filenames
    that are longer than 255 bytes. Then, we create the file using the given mode
    and use `io.CopyN` to read exact file size bytes from the input. In case of an
    error, we remove the partially downloaded file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首个操作是读取文件元数据的固定大小读取操作。然后我们读取文件名。注意在读取文件名之前的文件名长度检查。这是验证和限制所有涉及从外部系统或用户读取的大小内存分配的重要防御方法。在这里，我们拒绝长度超过
    255 字节的文件名。然后，我们使用给定的模式创建文件，并使用 `io.CopyN` 从输入中读取确切的文件大小字节。如果发生错误，我们将删除部分下载的文件。
- en: Writing a TLS client/server
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 TLS 客户端/服务器
- en: '**Transport Layer Security** (**TLS**) provides end-to-end encryption without
    revealing the encryption key to prevent man-in-the-middle attacks. It also provides
    authentication of peers and message integrity guarantees. This recipe shows how
    to set up a TLS server for securing network communications. However, first, a
    few words on public key cryptography can be useful.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**传输层安全性**（**TLS**）提供端到端加密，同时不泄露加密密钥以防止中间人攻击。它还提供对等方的身份验证和消息完整性保证。本食谱展示了如何设置
    TLS 服务器以保护网络通信。然而，首先，关于公钥加密的一些话可能是有用的。'
- en: A cryptographic **key pair** contains a private key and a public key. The private
    key is kept secret and the public key is published.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学 **密钥对** 包含一个私钥和一个公钥。私钥是保密的，公钥是公开的。
- en: 'This is how a key pair is used to encrypt messages: Since the public key of
    a party is published, anybody can create a message and encrypt it using the public
    key, then send it to the party that has the private key. Only the private key
    owner can decrypt that message. That also means that if the private key is revealed,
    anybody with that private key can eavesdrop on such messages.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是密钥对如何用于加密消息：由于一方的公钥是公开的，任何人都可以创建一条消息并使用该公钥加密它，然后将其发送给拥有私钥的一方。只有私钥的所有者才能解密该消息。这也意味着，如果私钥被泄露，拥有该私钥的任何人都可以监听此类消息。
- en: 'This is how a key pair is used to ensure message integrity: The owner of a
    private key can create a signature (hash) of a message using its private key.
    Anybody with a public key can verify the integrity of the message, that is, the
    public key can be used to validate whether a signature is generated by the corresponding
    private key.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用密钥对来确保消息完整性：私钥的所有者可以使用其私钥创建一个消息的签名（散列）。任何拥有公钥的人都可以验证消息的完整性，也就是说，公钥可以用来验证签名是否由相应的私钥生成。
- en: Public keys are distributed in the form of **digital certificates**. A digital
    certificate is a file that contains the public key of an entity signed by a trusted
    third party, a **certificate authority** (**CA**). There are many well-known CAs
    that publish their own public keys as certificates (root certificates), and these
    root certificates are shipped with most modern operating systems, so when you
    get a certificate, you can validate its authenticity using the public key of the
    CA that signed it. Once you validate that a public key is authentic, you can connect
    the owner of the public key, which has the corresponding private key, and establish
    a secure channel.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥以**数字证书**的形式分发。数字证书是一个文件，包含由受信任的第三方、**证书颁发机构**（CA）签名的实体的公钥。有许多知名的CA会将其公钥作为证书（根证书）发布，这些根证书通常包含在大多数现代操作系统中，因此当你获得一个证书时，你可以使用签发该证书的CA的公钥来验证其真实性。一旦验证公钥是真实的，你就可以将公钥的所有者（拥有相应的私钥）连接起来，并建立一个安全通道。
- en: The root certificate of a CA is usually signed by the CA itself.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: CA的根证书通常由CA本身签名。
- en: If you need to create certificates for your internal servers, you usually create
    a CA for your environment by creating a self-signed root CA. You keep the private
    key for that CA secret and publish the public key internally. There are automated
    tools that will help you create CAs and certificates for your servers.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为内部服务器创建证书，你通常通过创建一个自签名的根CA来为你的环境创建一个CA。你将那个CA的私钥保密，并在内部发布公钥。有一些自动化工具可以帮助你为服务器创建CA和证书。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here’s how you can set up a server and client for TLS:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何设置TLS服务器和客户端的步骤：
- en: Create or purchase an X.509 certificate for your server. If the server is not
    an internet-facing server, a self-signed certificate is usually sufficient. If
    this is an internet-facing server, you either have to get a certificate from one
    of the CA organizations, or publish your own public key certificate so the clients
    that want to connect to your servers can use that certificate to authenticate
    and encrypt traffic.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的服务器创建或购买一个X.509证书。如果服务器不是面向互联网的服务器，自签名证书通常就足够了。如果是面向互联网的服务器，你必须从CA组织之一获取证书，或者发布你自己的公钥证书，以便想要连接到你的服务器的客户端可以使用该证书进行身份验证和加密流量。
- en: 'For the server, do the following:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于服务器，请执行以下操作：
- en: Load the certificate using `crypto/tls.LoadX509KeyPair`.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`crypto/tls.LoadX509KeyPair`加载证书。
- en: Create a `crypto/tls.Config` using the certificate.
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用证书创建一个`crypto/tls.Config`。
- en: Create a listener using `crypto/tls.Listen`.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`crypto/tls.Listen`创建一个监听器。
- en: The rest of the server follows the same TCP server layout.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器其余部分遵循相同的TCP服务器布局。
- en: 'The following code segment illustrates these steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码段说明了这些步骤：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that both the certificate and the private key are necessary to set up the
    server. Once the TLS listener is set up, the rest of the code is identical to
    an unencrypted TCP server.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，设置服务器需要证书和私钥。一旦TLS监听器设置完成，其余的代码与未加密的TCP服务器相同。
- en: 'For the client, please follow these steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端，请按照以下步骤操作：
- en: If you are using a certificate from a well-known CA, use `crypto/x509.SystemCertPool`.
    If you have a self-signed certificate or some other custom certificate, create
    an empty certificate pool using `crypto/x509.NewCertPool`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用的是知名CA的证书，请使用`crypto/x509.SystemCertPool`。如果你有自签名证书或其他自定义证书，请使用`crypto/x509.NewCertPool`创建一个空的证书池。
- en: Load the server certificate, and add it to the certificate pool.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载服务器证书，并将其添加到证书池中。
- en: Use `crypto/tls.Dial` with a TLS configuration initialized using the certificate
    pool.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用使用证书池初始化的TLS配置的`crypto/tls.Dial`。
- en: The rest of the client follows the same TCP client layout described here.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端其余部分遵循这里描述的相同的TCP客户端布局。
- en: 'The following code segment shows these steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码段展示了这些步骤：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Again, loading the certificate and adding it to a certificate pool is only
    required if the server certificate is signed by a CA that is not recognized by
    the operating system. Many websites that use HTTPS have certificates signed by
    a well-known CA, and that’s why you can connect them without installing custom
    certificates: the operating system already trusts the CA.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，只有在服务器证书由操作系统未识别的CA签名时，才需要加载证书并将其添加到证书池中。许多使用HTTPS的网站都由知名的CA签名，这就是为什么您可以在不安装自定义证书的情况下连接到它们：操作系统已经信任该CA。
- en: Note
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are examples of this under the book’s GitHub ([https://github.com/PacktPublishing/Go-Recipes-for-Developers/tree/main/src/chp13](https://github.com/PacktPublishing/Go-Recipes-for-Developers/tree/main/src/chp13)).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的GitHub页面下有这个示例（[https://github.com/PacktPublishing/Go-Recipes-for-Developers/tree/main/src/chp13](https://github.com/PacktPublishing/Go-Recipes-for-Developers/tree/main/src/chp13))。
- en: A TCP proxy for TLS termination and load-balancing
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于TLS终止和负载均衡的TCP代理
- en: Most internet-facing applications use a reverse proxy (ingress) to separate
    the internal resources from the external world. The reverse proxy is usually connected
    by the external clients using encrypted connections (TLS), and forwards the requests
    to backend services via unencrypted channels (*Figure 11**.1*) or by re-encrypting
    the connection using the internal CA. The reverse proxy usually also performs
    some sort of load-balancing to distribute the work evenly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数面向互联网的应用程序都使用反向代理（入口）来将内部资源与外部世界分开。反向代理通常通过外部客户端使用加密连接（TLS）连接，并通过未加密的通道（*图11.1*）或使用内部CA重新加密连接将请求转发到后端服务。反向代理通常还执行某种形式的负载均衡，以均匀分配工作。
- en: '![Figure 13.1 – TLS proxy with round-robin load balancing and TLS termination](img/B21961_13_1.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – 带有轮询负载均衡和TLS终止的TLS代理](img/B21961_13_1.jpg)'
- en: Figure 13.1 – TLS proxy with round-robin load balancing and TLS termination
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 带有轮询负载均衡和TLS终止的TLS代理
- en: In this section, we will look at such a reverse proxy that accepts TLS traffic
    from external hosts, and forwards that traffic to backend servers using unencrypted
    TCP while distributing the requests to those servers in a round-robin fashion.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨这样一个反向代理，它接受来自外部主机的TLS流量，并使用未加密的TCP将流量转发到后端服务器，同时以轮询方式将这些请求分配给服务器。
- en: As a Go developer, you are unlikely to write your own reverse proxy or load
    balancer, as there are multiple options available already. However, it is an interesting
    application and I am including it here to show how something like this can be
    done in Go, in particular the proxy itself.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Go开发者，您不太可能编写自己的反向代理或负载均衡器，因为已经有很多选项可供选择。然而，这是一个有趣的应用，我在这里包括它，以展示如何在Go中完成类似的事情，特别是代理本身。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Here, we assume that the proxy is given the list of available backend servers.
    Many times, you will need to use a platform-specific discovery mechanism to find
    out what the available servers are:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们假设代理已获得可用后端服务器的列表。很多时候，您需要使用特定平台的发现机制来找出可用的服务器：
- en: Create an external facing TLS receiver using the certificate and key for the
    proxy host.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用代理主机的证书和密钥创建一个面向外部的TLS接收器。
- en: Listen to incoming TLS connections.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听传入的TLS连接。
- en: When a client connects, select a backend server and connect.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当客户端连接时，选择一个后端服务器并连接。
- en: Start a proxy goroutine to forward all traffic coming from the external host
    to the backend server, and traffic coming from the backend server to the external
    host.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个代理goroutine，将来自外部主机的所有流量转发到后端服务器，并将来自后端服务器的流量转发到外部主机。
- en: Terminate the proxy when one of the connections closes.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当其中一个连接关闭时，终止代理。
- en: 'The following program illustrates these steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下程序说明了这些步骤：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have already covered the details of setting up a TLS receiver in the previous
    recipes, so let’s take a look at how the backend server is selected. This implementation
    is given a list of all available backend servers. Every accepted client connection
    is assigned the next server in the list, pointed to by the `nextServer` index.
    The proxy uses `net.Dial` to connect the selected server, and if the connection
    fails (the server may be temporarily down), it skips to the next server in the
    list. If this fails `len(servers)` times, then all backend servers are unavailable,
    and the program terminates. However, if one server is selected, a proxy is started
    and the main goroutine goes back to listening to new connections.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的菜谱中介绍了设置TLS接收器的详细情况，所以让我们看看后端服务器是如何选择的。这个实现提供了一个所有可用后端服务器的列表。每个接受的客户端连接都被分配到列表中的下一个服务器，由`nextServer`索引指向。代理使用`net.Dial`连接选定的服务器，如果连接失败（服务器可能暂时不可用），它将跳转到列表中的下一个服务器。如果这失败了`len(servers)`次，那么所有后端服务器都不可用，程序将终止。然而，如果选择了一个服务器，将启动代理，并且主goroutine返回监听新的连接。
- en: 'Let’s see how the proxy handler is written:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代理处理器的编写方式：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As I mentioned in the previous sections, a network connection contains two concurrent
    streams, one going from the client host to the server, and the other going from
    the server to the client host. Both of these streams can include data in flight
    at the same time. Due to this, proxying a TCP connection involves two `io.Copy`
    operations, one from server to client, and one from client to server. Furthermore,
    at least one of these has to run in a separate goroutine. In the preceding example,
    the traffic from the external connection to the backend server is copied in a
    separate goroutine, and the traffic from the backend server to the external host
    is copied in the proxy goroutine. The copy operation will terminate if either
    side closes the connection, which will cause the last copy operation to terminate,
    closing the other connection as well.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，网络连接包含两个并发流，一个从客户端主机到服务器，另一个从服务器到客户端主机。这两个流可以同时包含正在传输的数据。因此，代理TCP连接涉及两个`io.Copy`操作，一个从服务器到客户端，另一个从客户端到服务器。此外，至少有一个操作必须在单独的goroutine中运行。在前面的示例中，来自外部连接到后端服务器的流量在一个单独的goroutine中复制，来自后端服务器到外部主机的流量在代理goroutine中复制。如果任一方关闭连接，复制操作将终止，这将导致最后一个复制操作终止，并关闭另一个连接。
- en: Setting read/write deadlines
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置读写截止时间
- en: If you do not want to wait indefinitely for a connected host to send data, or
    for the connected host to receive the data you sent, you have to set a deadline.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想无限期地等待连接的主机发送数据，或者等待连接的主机接收您发送的数据，您必须设置一个截止时间。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Depending on your specific protocol, you can set read or write deadlines, and
    you may choose to set these deadlines for individual I/O operations, or globally:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的特定协议，您可以设置读写截止时间，您可以选择为单个I/O操作设置这些截止时间，或者全局设置：
- en: 'Set the deadline before the operation:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在操作之前设置截止时间：
- en: '[PRE15]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you will continue using the connection after a deadline is exceeded, you
    have to reset the deadline:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您将在截止时间超过后继续使用连接，您必须重置截止时间：
- en: '[PRE16]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Or, set a new deadline with a time in the future.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，设置一个未来的时间的新截止时间。
- en: Unblocking a blocked read or write operation
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解锁阻塞的读写操作
- en: Sometimes, you need to unblock a read or write operation based on an external
    event. This recipe shows how you can unblock such an I/O operation.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能需要根据外部事件解锁一个读写操作。这个菜谱展示了您如何解锁这样的I/O操作。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'If you want to unblock an I/O operation with no intention of reusing the connection
    again, close the connection asynchronously:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您无意再次重用连接，只想解锁I/O操作，则异步关闭连接：
- en: '[PRE17]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you want to unblock an I/O operation but not terminate it, set the deadline
    to now:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您想解锁I/O操作但不终止它，将截止时间设置为现在：
- en: '[PRE18]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A TCP read operation blocks until there is something available to read, which
    only happens when some data is received from the peer. A TCP write operation will
    block when no more data can be buffered on the sending side. The preceding recipe
    shows two ways you can unblock these calls.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: TCP读取操作会阻塞，直到有可读内容，这只有在从对等方接收到数据时才会发生。TCP写入操作将在发送方无法再缓冲更多数据时阻塞。前面的菜谱展示了两种您可以解锁这些调用的方法。
- en: Closing a connection unblocks read/write operations with an error because the
    connection is closed while waiting for data to arrive, or while waiting for data
    to be written. Closing a connection discards all unread or unwritten data and
    destroys all resources allocated for that connection.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭连接会在等待数据到达或等待写入数据时因连接关闭而阻塞读写操作，并返回一个错误。关闭连接会丢弃所有未读或未写的数据，并销毁为该连接分配的所有资源。
- en: Setting the timeout asynchronously will set a deadline for the waiting operation,
    and when that deadline passes, the operation fails but the connection remains
    open. You can reset the deadline and retry the operation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 异步设置超时将为等待操作设置一个截止日期，当该截止日期通过时，操作失败但连接保持打开。你可以重置截止日期并重试操作。
- en: Writing UDP clients/servers
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写UDP客户端/服务器
- en: Unlike TCP, UDP is connectionless. That means instead of establishing a connection
    with another peer and sending data back and forth, you simply send data packets
    and receive them. There are no delivery or ordering guarantees.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与TCP不同，UDP是无连接的。这意味着你不需要与另一个对等方建立连接并来回发送数据，你只需发送数据包并接收它们。没有交付或排序保证。
- en: One of the prominent uses of UDP is the **Domain Name Service** (**DNS**) protocol.
    UDP is also the choice for many streaming protocols (voice over IP, video streaming,
    etc.) where occasional package loss is tolerable. Network monitoring tools also
    favor UDP.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: UDP的一个显著用途是**域名服务**（**DNS**）协议。UDP也是许多流式协议（如IP语音、视频流等）的选择，在这些协议中，偶尔的数据包丢失是可以容忍的。网络监控工具也更倾向于使用UDP。
- en: Despite being connectionless, the UDP networking APIs offer an interface similar
    to the TCP networking APIs. Here, we will show a simple client-server UDP echo
    server to demonstrate how these APIs can be used.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管UDP是无连接的，但UDP网络API提供了与TCP网络API类似的接口。在这里，我们将展示一个简单的客户端-服务器UDP回显服务器，以演示如何使用这些API。
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following steps show how to write a UDP server:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤展示了如何编写UDP服务器：
- en: 'Resolve the UDP address the server will listen on using `net.ResolveUDPAddr`:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`net.ResolveUDPAddr`解析服务器将监听的UDP地址：
- en: '[PRE19]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a UDP listener:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个UDP监听器：
- en: '[PRE20]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Even though `net.ListenUDP` returns a `*net.UDPConn`, the returned object resembles
    a listener and not a connection. UDP is connectionless, so this call starts listening
    UDP packets on the given address. The clients technically do not *connect* the
    server and start a two-way stream; they simply send a packet. That’s why, in the
    next step, the read operation also returns the address of the sender, so a response
    can be sent.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即使`net.ListenUDP`返回一个`*net.UDPConn`，返回的对象更像是一个监听器而不是一个连接。UDP是无连接的，所以这个调用开始在给定地址上监听UDP数据包。客户端实际上并没有*连接*服务器并启动双向流；他们只是发送一个数据包。这就是为什么在下一步中，读取操作也会返回发送者的地址，以便可以发送响应。
- en: 'Read from the listener. This will return the remote address of the peer:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从监听器读取。这将返回对等方的远程地址：
- en: '[PRE21]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Send the response to the peer using the address obtained in the previous step:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上一步获得的地址向对等方发送响应：
- en: '[PRE22]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now let’s take a look at the UDP client:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看UDP客户端：
- en: 'Resolve the address of the server:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析服务器的地址：
- en: '[PRE23]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a UDP connection. This requires a local address and a remote address.
    If the local address is nil, the local address is automatically chosen. If the
    remote address is nil, it is assumed to be the local system:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个UDP连接。这需要一个本地地址和一个远程地址。如果本地地址为nil，则自动选择本地地址。如果远程地址为nil，则假定是本地系统：
- en: '[PRE24]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Again, UDP is connectionless. The preceding call to `DialUDP` creates a socket
    that will be used in subsequent calls. It does not create a connection to the
    server.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，UDP是无连接的。前面的`DialUDP`调用创建了一个将在后续调用中使用的套接字。它不会创建到服务器的连接。
- en: 'Send data to the server using `conn.Write`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`conn.Write`向服务器发送数据：
- en: '[PRE25]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Read data from the server using `conn.Read`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`conn.Read`从服务器读取数据：
- en: '[PRE26]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Working with HTTP
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与HTTP一起工作
- en: HTTP is a client-server protocol where the client (a user agent or proxy) sends
    requests to a server, and the server returns a response. It is an application
    layer hypertext protocol, and the backbone of the World Wide Web.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一种客户端-服务器协议，其中客户端（用户代理或代理）向服务器发送请求，服务器返回响应。它是一种应用层超文本协议，是万维网的基础。
- en: Making HTTP calls
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行HTTP调用
- en: 'The Go standard library offers two basic ways of issuing HTTP calls to interact
    with websites and web services: if you do not need to configure timeouts, transport
    properties, or redirect policies, simply use the shared client. If you need to
    do additional configuration, use `http.Client`. This recipe demonstrates both.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库提供了两种基本方式来发出HTTP调用以与网站和Web服务交互：如果你不需要配置超时、传输属性或重定向策略，只需使用共享客户端。如果你需要做额外的配置，使用`http.Client`。这个食谱演示了两种方法。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The standard library includes a shared HTTP client. You can use that to interact
    with web servers using the default configuration:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准库包含一个共享的HTTP客户端。你可以使用它来使用默认配置与Web服务器交互：
- en: '[PRE27]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you need to apply different timeout values, change the redirect policy,
    or configure the transport, create a new `http.Client`, initialize it, and use
    that:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要应用不同的超时值，更改重定向策略，或配置传输，创建一个新的`http.Client`，初始化它，并使用它：
- en: '[PRE28]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You can call websites using HTTPS (using TLS) if the operating system already
    has the certificate for the CA that issued that website’s certificate. This is
    the case for most public websites over the internet:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作系统已经拥有该网站证书的CA证书，你可以使用HTTPS（使用TLS）来调用网站。这在互联网上大多数公共网站上都是这种情况：
- en: '[PRE29]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you are using TLS with a custom CA, or if you are using self-signed certificates,
    you have to create a `http.Client` with a `Transport` containing the certificate.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是自定义CA的TLS，或者如果你使用的是自签名证书，你必须创建一个包含证书的`http.Client`的`Transport`。
- en: 'Create a new certificate pool:'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的证书池：
- en: '[PRE30]'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Load the server certificate:'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载服务器证书：
- en: '[PRE31]'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the certificate to the certificate pool:'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将证书添加到证书池中：
- en: '[PRE32]'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Create a TLS config:'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个TLS配置：
- en: '[PRE33]'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create an HTTP Transport using the TLS config:'
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TLS配置创建一个HTTP传输：
- en: '[PRE34]'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Create an HTTP client:'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建HTTP客户端：
- en: '[PRE35]'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Use the client:'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用客户端：
- en: '[PRE36]'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tip
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Always close the response body when you are done working with it, and try to
    read all data available in the body. The `response.Body` represents a streaming
    connection to the server. The server will reserve resources for the connection
    as long as there is data in transit and the client keeps the connection open.
    It also prevents the client from reusing keep-alive connections.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 完成与响应体的工作后，始终关闭它，并尝试读取身体中所有可用的数据。`response.Body`代表到服务器的流连接。只要传输中有数据，服务器就会保留连接的资源，并且客户端保持连接打开。它还防止客户端重用keep-alive连接。
- en: Running an HTTP server
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行HTTP服务器
- en: The standard Go library offers an HTTP server with sensible defaults that you
    can use out of the box, similar to the way HTTP clients are implemented. If you
    need to configure transport specifics, timeouts, and so on, then you can create
    a new `http.Server` and work with it. This section describes both approaches.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 标准Go库提供了一个具有合理默认值的HTTP服务器，你可以直接使用，类似于HTTP客户端的实现方式。如果你需要配置传输特定设置、超时等，则可以创建一个新的`http.Server`并与之一起工作。本节描述了这两种方法。
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create an `http.Handler` to handle HTTP requests:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`http.Handler`来处理HTTP请求：
- en: '[PRE37]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Call `http.ListenAndServe`:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`http.ListenAndServe`：
- en: '[PRE38]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `ListenAndServe` function either returns immediately due to an error setting
    up a network listener (for example, if the address is already in use) or successfully
    starts listening. When the server is asynchronously closed (by calling `server.Close()`
    or `server.Shutdown()`), it returns `ErrServerClosed`.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListenAndServe`函数要么因为设置网络监听器时出错（例如，如果地址已被占用）而立即返回，要么成功开始监听。当服务器异步关闭（通过调用`server.Close()`或`server.Shutdown()`）时，它返回`ErrServerClosed`。'
- en: 'Alternatively, you can use a `http.Server` struct to better control server
    options:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以使用`http.Server`结构体来更好地控制服务器选项：
- en: Create an `http.Handler` as described.
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照描述创建一个`http.Handler`。
- en: 'Initialize an `http.Server` instance:'
  id: totrans-223
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化一个`http.Server`实例：
- en: '[PRE39]'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listen HTTP requests:'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监听HTTP请求：
- en: '[PRE40]'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Tip
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: A common way to create an HTTP handler is to use a request multiplexer. Recipes
    for using a request multiplexer will be covered later.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 创建HTTP处理器的常见方法是使用请求多路复用器。关于使用请求多路复用器的食谱将在稍后介绍。
- en: HTTPS – setting up a TLS server
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTPS – 设置TLS服务器
- en: To start a TLS server, you need a certificate and a private key. You can either
    purchase one from a CA or generate our own certificates with your internal CA.
    Once you have your certificate, you can use the recipes in this section to start
    your HTTPS server.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动TLS服务器，你需要一个证书和一个私钥。你可以从CA购买一个，或者使用你的内部CA生成自己的证书。一旦你有了证书，你就可以使用本节中的食谱来启动你的HTTPS服务器。
- en: How to do it...
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a TLS HTTP server, use one of the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 TLS HTTP 服务器，可以使用以下方法之一：
- en: 'Use the `Server.ListenAndServeTLS` method with the certificate and key files:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用证书和密钥文件调用 `Server.ListenAndServeTLS` 方法：
- en: '[PRE41]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To use the default HTTP server, set a handler function (or `http.Handler`)
    and call `http.ListenAndServeTLS`:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用默认 HTTP 服务器，设置处理程序函数（或 `http.Handler`）并调用 `http.ListenAndServeTLS`：
- en: '[PRE42]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Or prepare a `http.Transport` with certificates:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者准备一个带有证书的 `http.Transport`：
- en: '3.1 Load the TLS certificate:'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.1 加载 TLS 证书：
- en: '[PRE43]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '3.2 Create a `tls.Config` using the certificate:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.2 使用证书创建一个 `tls.Config`：
- en: '[PRE44]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '3.3 Create a `http.Server` using the `tlsConfig`:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.3 使用 `tlsConfig` 创建一个 `http.Server`：
- en: '[PRE45]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 3.4 Call `server.ListenAndServeTLS`
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 3.4 调用 `server.ListenAndServeTLS`
- en: '[PRE46]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Writing HTTP handlers
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 HTTP 处理程序
- en: When an HTTP request arrives at a server, the server looks at the HTTP method
    (GET, POST, etc), the hostname the client used (the `Host` header), and the URL
    to decide how to handle the request. The mechanism that determines which handler
    should handle such a request is called a **request multiplexer**. The Go standard
    library comes with one, and there are many third-party open source multiplexers.
    In this section, we will look at the standard library multiplexer and how it can
    be used.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当 HTTP 请求到达服务器时，服务器会查看 HTTP 方法（GET、POST 等）、客户端使用的域名（`Host` 标头）和 URL，以决定如何处理请求。确定哪个处理程序应该处理此类请求的机制称为
    **请求多路复用器**。Go 标准库自带了一个，还有许多第三方开源的多路复用器。在本节中，我们将查看标准库多路复用器及其使用方法。
- en: How to do it...
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'You can use an anonymous function for simple cases, such as a health-check
    endpoint:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于简单情况，例如健康检查端点，您可以使用匿名函数：
- en: '[PRE47]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The preceding handler will respond to `GET /health` endpoint requests with an
    `Ok` and `HTTP` `200` status.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的处理程序将响应 `GET /health` 端点请求，返回 `Ok` 和 `HTTP` `200` 状态码。
- en: 'You can use a data type that implements the `http.Handler` interface:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用实现 `http.Handler` 接口的数据类型：
- en: 'Create a new data type, which can be a struct containing information that you
    will need to implement the handler:'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的数据类型，这可以是一个包含您将需要实现处理程序所需信息的结构：
- en: '[PRE48]'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Implement the `http.Handler` interface:'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现 `http.Handler` 接口：
- en: '[PRE49]'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Create an instance of the handler type and initialize it
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建处理程序类型的实例并初始化它
- en: '[PRE50]'
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a multiplexer:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个多路复用器：
- en: '[PRE51]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Assign the handler to a pattern. The following example assigns `GET` requests
    for `/rnd` path to the instance constructed at *step 3*.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将处理程序分配给模式。以下示例将 `/rnd` 路径的 `GET` 请求分配给在 *步骤 3* 中构建的实例。
- en: '[PRE52]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Start the server.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动服务器。
- en: '[PRE53]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'A more general method involves creating data types with multiple methods as
    handlers. This pattern is especially useful for web service development because
    it allows for creating structures that serve all the APIs related to a specific
    business domain:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种更通用的方法涉及创建具有多个方法作为处理程序的数据类型。这种模式对于 Web 服务开发特别有用，因为它允许创建服务于特定业务域所有相关 API 的结构：
- en: 'Create a data type. This can be a struct containing all the necessary information
    to implement handlers, such as database connections, public/private keys, and
    so on:'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个数据类型。这可以是一个包含实现处理程序所需所有必要信息的结构，例如数据库连接、公钥/私钥等：
- en: '[PRE54]'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create methods using the signature for `http.HandlerFunc` to implement multiple
    API endpoints:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `http.HandlerFunc` 的签名创建方法以实现多个 API 端点：
- en: '[PRE55]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Create an initialize the handlers.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并初始化处理程序。
- en: '[PRE56]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Create a request multiplexer
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建请求多路复用器
- en: '[PRE57]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Assign handler methods to patterns:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将处理程序方法分配给模式：
- en: '[PRE58]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Use the multiplexer to start the server.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用多路复用器启动服务器。
- en: '[PRE59]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The following code snippet illustrates how you can use the standard library
    request multiplexer tools when writing HTTP handlers:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段说明了在编写 HTTP 处理程序时如何使用标准库请求多路复用工具：
- en: '[PRE60]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Serving static files on the file system
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在文件系统上提供静态文件
- en: Not all files served by web applications are dynamically generated. JavaScript
    files, cascading stylesheets, and some HTML pages are usually served verbatim.
    This section shows several methods to serve such files.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有由 Web 应用程序提供的文件都是动态生成的。JavaScript 文件、层叠样式表和一些 HTML 页面通常以纯文本形式提供。本节展示了提供此类文件的一些方法。
- en: How to do it...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'There are several ways a static file can be served via HTTP:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 静态文件可以通过多种方式通过 HTTP 提供服务：
- en: 'To serve all static files under a directory, use `http.FileServer` to create
    a handler:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在目录下提供所有静态文件，请使用 `http.FileServer` 创建处理程序：
- en: '[PRE61]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To serve all static files under a directory but with a different URL path prefix,
    use `http.StripPrefix`:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在目录下提供所有静态文件，但使用不同的 URL 路径前缀，请使用 `http.StripPrefix`：
- en: '[PRE62]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The above call wraps the given file handler with another that strips the given
    prefix from the URL path. For a `GET /static/index.hml` request , this handler
    will serve `/var/www/index.html` with `Content-Type: text/html`. If the path does
    not include the given prefix, this will return `HTTP 404` `Not Found`.'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To add additional logic to URL-filename mapping, implement the `http.FileSystem`
    interface and use `FileServerFS` with that file system. You can combine this handler
    with `http.StripPrefix` to further change URL path processing:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Handling HTML forms
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML forms are an essential component of capturing data in web applications.
    An HTML form can be processed on the server side through the use of a `Form` HTML
    element, or it can be processed on the client side using JavaScript. In this section,
    we will look at handling HTTP form submissions for server-side processing.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the client side, do the following.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Enclose data input fields in a `Form` HTML element:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Here, the `method` attribute determines the HTTP method, which is `POST`, and
    the `action` attribute determines the URL. Note that this URL is relative to the
    current page URL. When the form is submitted, the client-side processing will
    prepare a `POST` request for the given URL, and send the contents of input fields
    as name-value pairs encoded as `application/x-www-form-urlencoded` encoding.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On the server side, do the following:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a handler to process the `POST` request. In the handler, do the following:'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `http.Request.ParseForm` to process submitted data.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the submitted information from `http.Request.PostForm`.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Process the request.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example implements a simple login scenario using the submitted
    username and password. The handler uses an authenticator that performs the actual
    user validation and returns a cookie if the login is successful. This cookie contains
    information to identify the user in the subsequent calls:'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Register the handler to handle the `POST` requests for the URL:'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Tip
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: You have to be careful when working with cookies. In our example, a cookie was
    created by the server application and sent to the client. Subsequent calls to
    the server will include that cookie for the server to keep track of the user session.
    However, there is no guarantee that the cookie submitted by the client is a valid
    cookie. Malicious clients can send forged or expired cookies. Use cryptographic
    methods to ensure the cookie is created by the server, such as signing a cookie
    using a secret key, or using a JSON Web Token.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example includes another usage of cookies to send status information
    from one page to another. If login fails, the user is redirected to the login
    page with a cookie containing the error message. The login page handler can check
    the presence of this cookie and display the message.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'An example implementation is given here:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'An implementation of the `NewErrorCookie` method looks like the following:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Writing a handler for downloading large files
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写用于下载大文件的处理器
- en: When an HTTP client requests a large file, it is usually not feasible to load
    all the file data and then send it to the client. Use `io.Copy` to stream large
    content to clients.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当HTTP客户端请求大文件时，通常不可行一次性加载所有文件数据然后发送给客户端。使用`io.Copy`将大内容流式传输到客户端。
- en: How to do it...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This is how you can write a handler to download a large file:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何编写一个用于下载大文件的处理器：
- en: Set the `Content-Type` header.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`Content-Type`头。
- en: Set the `Content-Length` header.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`Content-Length`头。
- en: Write the file contents using `io.Copy`.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`io.Copy`写入文件内容。
- en: 'These steps are illustrated here:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在此处展示：
- en: '[PRE69]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Handling HTTP uploaded files and forms as a stream
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将HTTP上传文件和表单作为流处理
- en: 'The standard library provides methods to deal with file uploads. You can call
    `http.Request.ParseMultipartForm`, and work with uploaded files. There is one
    problem with this approach: `ParseMultipartForm` processes all uploads up to a
    given memory limit. It may even use temporary files. This is not a scalable approach
    if you are dealing with large files. This section describes how you can work with
    file uploads without creating temporary files or a large memory footprint.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库提供了处理文件上传的方法。你可以调用`http.Request.ParseMultipartForm`，并处理上传的文件。这种方法有一个问题：`ParseMultipartForm`处理所有上传直到一个给定的内存限制。它甚至可能使用临时文件。如果你处理的是大文件，这不是一个可扩展的方法。本节描述了如何在不需要创建临时文件或大内存占用的情况下处理文件上传。
- en: How to do it...
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'On the client side, do the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，执行以下操作：
- en: Create an HTML form with `multipart/form-data` encoding.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用`multipart/form-data`编码的HTML表单。
- en: Add the form fields and files that you are planning to upload.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加你计划上传的表单字段和文件。
- en: 'An example is given here:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这里提供了一个示例：
- en: '[PRE70]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When submitted, this form will create a multipart message containing two parts:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当提交此表单时，它将创建一个包含两部分的复合消息：
- en: 'There’s a part with `Content-Disposition: form-data; name="textField"`. The
    contents of this part will contain the input the user typed for the `textField`
    input field.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '也有一个部分带有`Content-Disposition: form-data; name="textField"`。这个部分的内容将包含用户为`textField`输入字段输入的输入。'
- en: 'There’s also a part with `Content-Disposition: form-data; name="fileField";
    filename=<name of the file user selected>`. The contents of this part will contain
    the file contents.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '也有一个部分带有`Content-Disposition: form-data; name="fileField"; filename=<用户选择的文件名>`。这个部分的
    内容将包含文件内容。'
- en: 'On the server side, do the following:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，执行以下操作：
- en: 'Use `http.Request.MultipartReader` to get a multipart body reader from the
    request. If the request is not a multipart request (multipart/mixes or multipart/form-data),
    this will fail:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`http.Request.MultipartReader`从请求中获取一个复合体部分读取器。如果请求不是一个复合请求（multipart/mixes或multipart/form-data），这将失败：
- en: '[PRE71]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Process the parts of the submitted data one by one by calling `MultipartReader.NextPart`:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`MultipartReader.NextPart`逐个处理提交数据的部分：
- en: '[PRE72]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Check whether the part is form data or file using the `Content-Disposition`
    header:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Content-Disposition`头检查部分是否为表单数据或文件：
- en: If `Content-Disposition` is `form-data` without a `filename` parameter, then
    this part contains a form field.
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Content-Disposition`是`form-data`但没有`filename`参数，那么这个部分包含一个表单字段。
- en: If `Content-Disposition` is `form-data` with a `filename` parameter, then this
    part is a file. You can read the file contents from the body.
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`Content-Disposition`是带有`filename`参数的`form-data`，那么这个部分是一个文件。你可以从体中读取文件内容。
- en: '[PRE73]'
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
