- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network programming is a crucial skill for application developers. An extensive
    treatise on the topic would be a formidable endeavor, so we will look at some
    of the select examples you might encounter in your work. An important point to
    keep in mind is that network programming is the primary means of creating vulnerabilities
    in an application. Network programs are also inherently concurrent, making correct
    and safe network programming especially difficult. So, this section will include
    examples written with security and scalability in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing TCP servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing TCP clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a line-based TCP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending/receiving files using a TCP connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a TLS client/server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A TCP proxy for TLS termination and load-balancing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting read/write deadlines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unblocking a blocked read or write operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing UDP clients/servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running an HTTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTPS – setting up a TLS server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing HTTP handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving static files on the file system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling HTML forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a handler for downloading large files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling HTTP uploaded files and forms as a stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Transmission Control Protocol** (**TCP**) is a connection-oriented protocol
    that provides the following guarantees:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability**: The sender will know whether the intended recipient received
    the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ordering**: Messages will be received in the order they are sent in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error-checked**: Messages will be protected against corruption during transit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to these guarantees, TCP is relatively easy to work with. It is the basis
    for many higher-level protocols such as HTTP and WebSockets. In this section,
    we will look at some recipes that show how to write TCP servers and clients.
  prefs: []
  type: TYPE_NORMAL
- en: Writing TCP servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A TCP server is a program that listens to connection requests on a network port.
    Once a connection is established with a client, the communication between the
    client and the server takes place over a `net.Conn` object. The server may continue
    to listen for new connections. This way, a single server can communicate with
    many clients.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Select a port that will connect to the clients server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is usually a matter of application configuration. The first 1,024 (`0`
    to `1023`) ports usually require a server program to have root privileges. Most
    of these ports are reserved for well-known server programs, such as port 22 for
    ssh, or port 80 for HTTP. Ports 1024 and above are ephemeral ports. Your server
    program can use any port number of 1,024 and above without additional privileges
    as long as no other program is listening to it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use port number 0 to let the kernel pick a random unused port. You can create
    a listener for port `0`, and then query the listener to find out what port number
    was selected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a listener. A listener is a mechanism that binds the `address:port`.
    Once you create a listener using a port number, no other process on the same host,
    or within the same container, can use that port number to listen to network traffic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following program snippet shows how to create a listener:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The program first determines the network address to listen to. The exact format
    of the address depends on the protocol chosen, which is TCP in this case. If no
    hostname or IP address is given, the listener will listen to all available unicast
    IP addresses of the local system. If you give a hostname or IP address, the listener
    will only listen to the traffic coming from the given IP address. That means if
    you give `localhost:1234`, the listener will listen to traffic coming from `localhost`
    only. It will not listen to external traffic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The above example prints `listener.Addr()`. This is useful if you provide `:0`
    as the listen address, or if you do not provide one at all. In this case, the
    listener will listen to a random port, and `listener.Addr()` will return the address
    that clients can connect to.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Listen and accept connections. Accept incoming connections using `Listener.Accept()`.
    This is usually done in a loop as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, the `listener.Accept` call will fail with an error if the listener
    is closed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Handle the connection in its own goroutine. This way, the listener will continue
    to accept connections while the server communicates with the connected clients
    in their own goroutines, using the connections created specifically for those
    clients.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A connection handler for a simple echo server can be written as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `net.Conn` interface has both the `Read([]byte) (int,error)` method (which
    makes it an `io.Reader`), and `Write([]byte) (int,error)` (which also makes it
    an `io.Writer`). Due to this, whatever is read from the connection is written
    back to it.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that because of `io.Copy`, every byte read will be written back
    to the connection, so this is not a line-based protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Writing TCP clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A TCP client connects to a TCP server that is listening on a port of some host.
    Once the connection is established, communication is bidirectional. In other words,
    the distinction between a server and a client is based on how the connection is
    established. When we say “server,” we mean the program that waits listening to
    a port, and when we say “client,” we mean the program that connects (“dials”)
    a port on a host that is being listened on by a server. Once the connection is
    established, both sides send and receive data asynchronously. TCP guarantees that
    the messages will be received in the order they are sent, and that the messages
    will not be lost, but there are no guarantees on when a message will be received
    by the other side.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The client side has to know the server address and port. This should be provided
    by the environment (command line, configuration, etc.).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use `net.Dial` to create a connection to the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the returned `net.Conn` object to send data to the server, or to receive
    data from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the connection when done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the complete program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates a request-response type of interaction with the server.
    This is not necessarily always the case. A network connection provides both an
    `io.Writer` and an `io.Reader` interface, and they can be used concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a line-based TCP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at a TCP server that works with lines instead of
    bytes. There are some points you need to be careful about when reading lines from
    a network connection, especially related to the security of the server. Just because
    you are expecting to read lines does not mean the client will send well-formed
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the same structure to set up the server as given in the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the connection handler, use a `bufio.Reader` or `bufio.Scanner` to read lines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrap the connection with an `io.LimitedReader` to limit line length.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s take a look at how this can work. The following example shows how a connection
    handler can be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The connection handling routine starts by wrapping the connection in an `io.LimitedReader`.
    This is necessary to prevent `reader.ReadBytes` from reading an unlimited amount
    of data until it sees the newline character. Without this, a malicious client
    can send large amounts of data without any newline characters, consuming all the
    server memory. Putting a hard limit on the line length prevents this attack vector.
    After reading every line, we reset the `limiter.N` to its original value so the
    next line can be read using the same limits. Note that the limiter is set to read
    one extra byte. This is because the `io.LimitedReader` returns `io.EOF` for both
    a legitimate `EOF` (which means the client disconnected), and a read exceeding
    the limit. If the reader exceeds the limit, that means the last line read is at
    least one byte above the limit, allowing us to decide this is an invalid line.
  prefs: []
  type: TYPE_NORMAL
- en: Sending/receiving files using a TCP connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending and receiving files over a TCP connection demonstrates several important
    points about network programming, namely the protocol design (which deals with
    who sends what when) and encoding (which deals with how data elements are represented
    on the wire). This example will show how to transfer metadata and an octet stream
    over a TCP connection.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the same structure to set up the server as in the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the sender end (client), do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encode file metadata containing the filename, size, and mode and send it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Send the contents of the file.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Close the connection.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the receiver end (server), do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decode file metadata. Create a file to store the received file contents with
    the given mode.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Receive file contents and write the file.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After all file content is received, close the file.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first part is the transfer of metadata about the file. There are several
    ways this can be done: you can work with a text-based encoding scheme such as
    key-value pairs or JSON, but the problem with such schemes is that they are not
    fixed length. A simple, effective, and portable encoding scheme is binary encoding
    using the `encoding/binary` package. That does not solve the encoding of the filename,
    which is not a fixed-sized string. So, we include the length of the filename in
    the file metadata, and encode the filename using exactly the necessary number
    of bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fixed-sized `fileMetadata` structure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This structure is 14 bytes on all platforms (eight bytes of `Size`, four bytes
    of `Mode`, and two bytes of `NameLen`.) Using `binary/encoding.Write`, you can
    encode this fixed-size structure on the wire using either `binary.BigEndian` or
    `binary.LittleEndian` encoding, and the receiving end will decode it successfully.
  prefs: []
  type: TYPE_NORMAL
- en: More detailed information on endianness is included in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the client is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `io.Copy` to transfer the actual contents of the file. Using
    `io.Copy`, you can transfer arbitrary-size files to the receiver without consuming
    significant amounts of memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at the server (receiver):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first operation is a fixed-size read operation of the file metadata. Then
    we read the filename. Note the filename length check before reading the filename.
    It is an important defensive approach to validate and limit all memory allocations
    involving size read from an external system or user. Here, we reject filenames
    that are longer than 255 bytes. Then, we create the file using the given mode
    and use `io.CopyN` to read exact file size bytes from the input. In case of an
    error, we remove the partially downloaded file.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a TLS client/server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Transport Layer Security** (**TLS**) provides end-to-end encryption without
    revealing the encryption key to prevent man-in-the-middle attacks. It also provides
    authentication of peers and message integrity guarantees. This recipe shows how
    to set up a TLS server for securing network communications. However, first, a
    few words on public key cryptography can be useful.'
  prefs: []
  type: TYPE_NORMAL
- en: A cryptographic **key pair** contains a private key and a public key. The private
    key is kept secret and the public key is published.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how a key pair is used to encrypt messages: Since the public key of
    a party is published, anybody can create a message and encrypt it using the public
    key, then send it to the party that has the private key. Only the private key
    owner can decrypt that message. That also means that if the private key is revealed,
    anybody with that private key can eavesdrop on such messages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how a key pair is used to ensure message integrity: The owner of a
    private key can create a signature (hash) of a message using its private key.
    Anybody with a public key can verify the integrity of the message, that is, the
    public key can be used to validate whether a signature is generated by the corresponding
    private key.'
  prefs: []
  type: TYPE_NORMAL
- en: Public keys are distributed in the form of **digital certificates**. A digital
    certificate is a file that contains the public key of an entity signed by a trusted
    third party, a **certificate authority** (**CA**). There are many well-known CAs
    that publish their own public keys as certificates (root certificates), and these
    root certificates are shipped with most modern operating systems, so when you
    get a certificate, you can validate its authenticity using the public key of the
    CA that signed it. Once you validate that a public key is authentic, you can connect
    the owner of the public key, which has the corresponding private key, and establish
    a secure channel.
  prefs: []
  type: TYPE_NORMAL
- en: The root certificate of a CA is usually signed by the CA itself.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to create certificates for your internal servers, you usually create
    a CA for your environment by creating a self-signed root CA. You keep the private
    key for that CA secret and publish the public key internally. There are automated
    tools that will help you create CAs and certificates for your servers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s how you can set up a server and client for TLS:'
  prefs: []
  type: TYPE_NORMAL
- en: Create or purchase an X.509 certificate for your server. If the server is not
    an internet-facing server, a self-signed certificate is usually sufficient. If
    this is an internet-facing server, you either have to get a certificate from one
    of the CA organizations, or publish your own public key certificate so the clients
    that want to connect to your servers can use that certificate to authenticate
    and encrypt traffic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the server, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the certificate using `crypto/tls.LoadX509KeyPair`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `crypto/tls.Config` using the certificate.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a listener using `crypto/tls.Listen`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the server follows the same TCP server layout.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code segment illustrates these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that both the certificate and the private key are necessary to set up the
    server. Once the TLS listener is set up, the rest of the code is identical to
    an unencrypted TCP server.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the client, please follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a certificate from a well-known CA, use `crypto/x509.SystemCertPool`.
    If you have a self-signed certificate or some other custom certificate, create
    an empty certificate pool using `crypto/x509.NewCertPool`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the server certificate, and add it to the certificate pool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `crypto/tls.Dial` with a TLS configuration initialized using the certificate
    pool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rest of the client follows the same TCP client layout described here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code segment shows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, loading the certificate and adding it to a certificate pool is only
    required if the server certificate is signed by a CA that is not recognized by
    the operating system. Many websites that use HTTPS have certificates signed by
    a well-known CA, and that’s why you can connect them without installing custom
    certificates: the operating system already trusts the CA.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are examples of this under the book’s GitHub ([https://github.com/PacktPublishing/Go-Recipes-for-Developers/tree/main/src/chp13](https://github.com/PacktPublishing/Go-Recipes-for-Developers/tree/main/src/chp13)).
  prefs: []
  type: TYPE_NORMAL
- en: A TCP proxy for TLS termination and load-balancing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most internet-facing applications use a reverse proxy (ingress) to separate
    the internal resources from the external world. The reverse proxy is usually connected
    by the external clients using encrypted connections (TLS), and forwards the requests
    to backend services via unencrypted channels (*Figure 11**.1*) or by re-encrypting
    the connection using the internal CA. The reverse proxy usually also performs
    some sort of load-balancing to distribute the work evenly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – TLS proxy with round-robin load balancing and TLS termination](img/B21961_13_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – TLS proxy with round-robin load balancing and TLS termination
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at such a reverse proxy that accepts TLS traffic
    from external hosts, and forwards that traffic to backend servers using unencrypted
    TCP while distributing the requests to those servers in a round-robin fashion.
  prefs: []
  type: TYPE_NORMAL
- en: As a Go developer, you are unlikely to write your own reverse proxy or load
    balancer, as there are multiple options available already. However, it is an interesting
    application and I am including it here to show how something like this can be
    done in Go, in particular the proxy itself.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we assume that the proxy is given the list of available backend servers.
    Many times, you will need to use a platform-specific discovery mechanism to find
    out what the available servers are:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an external facing TLS receiver using the certificate and key for the
    proxy host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Listen to incoming TLS connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a client connects, select a backend server and connect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a proxy goroutine to forward all traffic coming from the external host
    to the backend server, and traffic coming from the backend server to the external
    host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Terminate the proxy when one of the connections closes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following program illustrates these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We have already covered the details of setting up a TLS receiver in the previous
    recipes, so let’s take a look at how the backend server is selected. This implementation
    is given a list of all available backend servers. Every accepted client connection
    is assigned the next server in the list, pointed to by the `nextServer` index.
    The proxy uses `net.Dial` to connect the selected server, and if the connection
    fails (the server may be temporarily down), it skips to the next server in the
    list. If this fails `len(servers)` times, then all backend servers are unavailable,
    and the program terminates. However, if one server is selected, a proxy is started
    and the main goroutine goes back to listening to new connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the proxy handler is written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As I mentioned in the previous sections, a network connection contains two concurrent
    streams, one going from the client host to the server, and the other going from
    the server to the client host. Both of these streams can include data in flight
    at the same time. Due to this, proxying a TCP connection involves two `io.Copy`
    operations, one from server to client, and one from client to server. Furthermore,
    at least one of these has to run in a separate goroutine. In the preceding example,
    the traffic from the external connection to the backend server is copied in a
    separate goroutine, and the traffic from the backend server to the external host
    is copied in the proxy goroutine. The copy operation will terminate if either
    side closes the connection, which will cause the last copy operation to terminate,
    closing the other connection as well.
  prefs: []
  type: TYPE_NORMAL
- en: Setting read/write deadlines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you do not want to wait indefinitely for a connected host to send data, or
    for the connected host to receive the data you sent, you have to set a deadline.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Depending on your specific protocol, you can set read or write deadlines, and
    you may choose to set these deadlines for individual I/O operations, or globally:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the deadline before the operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you will continue using the connection after a deadline is exceeded, you
    have to reset the deadline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Or, set a new deadline with a time in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Unblocking a blocked read or write operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you need to unblock a read or write operation based on an external
    event. This recipe shows how you can unblock such an I/O operation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to unblock an I/O operation with no intention of reusing the connection
    again, close the connection asynchronously:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to unblock an I/O operation but not terminate it, set the deadline
    to now:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A TCP read operation blocks until there is something available to read, which
    only happens when some data is received from the peer. A TCP write operation will
    block when no more data can be buffered on the sending side. The preceding recipe
    shows two ways you can unblock these calls.
  prefs: []
  type: TYPE_NORMAL
- en: Closing a connection unblocks read/write operations with an error because the
    connection is closed while waiting for data to arrive, or while waiting for data
    to be written. Closing a connection discards all unread or unwritten data and
    destroys all resources allocated for that connection.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the timeout asynchronously will set a deadline for the waiting operation,
    and when that deadline passes, the operation fails but the connection remains
    open. You can reset the deadline and retry the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Writing UDP clients/servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike TCP, UDP is connectionless. That means instead of establishing a connection
    with another peer and sending data back and forth, you simply send data packets
    and receive them. There are no delivery or ordering guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: One of the prominent uses of UDP is the **Domain Name Service** (**DNS**) protocol.
    UDP is also the choice for many streaming protocols (voice over IP, video streaming,
    etc.) where occasional package loss is tolerable. Network monitoring tools also
    favor UDP.
  prefs: []
  type: TYPE_NORMAL
- en: Despite being connectionless, the UDP networking APIs offer an interface similar
    to the TCP networking APIs. Here, we will show a simple client-server UDP echo
    server to demonstrate how these APIs can be used.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following steps show how to write a UDP server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Resolve the UDP address the server will listen on using `net.ResolveUDPAddr`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a UDP listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Even though `net.ListenUDP` returns a `*net.UDPConn`, the returned object resembles
    a listener and not a connection. UDP is connectionless, so this call starts listening
    UDP packets on the given address. The clients technically do not *connect* the
    server and start a two-way stream; they simply send a packet. That’s why, in the
    next step, the read operation also returns the address of the sender, so a response
    can be sent.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Read from the listener. This will return the remote address of the peer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Send the response to the peer using the address obtained in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let’s take a look at the UDP client:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Resolve the address of the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a UDP connection. This requires a local address and a remote address.
    If the local address is nil, the local address is automatically chosen. If the
    remote address is nil, it is assumed to be the local system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, UDP is connectionless. The preceding call to `DialUDP` creates a socket
    that will be used in subsequent calls. It does not create a connection to the
    server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Send data to the server using `conn.Write`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read data from the server using `conn.Read`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP is a client-server protocol where the client (a user agent or proxy) sends
    requests to a server, and the server returns a response. It is an application
    layer hypertext protocol, and the backbone of the World Wide Web.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Go standard library offers two basic ways of issuing HTTP calls to interact
    with websites and web services: if you do not need to configure timeouts, transport
    properties, or redirect policies, simply use the shared client. If you need to
    do additional configuration, use `http.Client`. This recipe demonstrates both.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard library includes a shared HTTP client. You can use that to interact
    with web servers using the default configuration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you need to apply different timeout values, change the redirect policy,
    or configure the transport, create a new `http.Client`, initialize it, and use
    that:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can call websites using HTTPS (using TLS) if the operating system already
    has the certificate for the CA that issued that website’s certificate. This is
    the case for most public websites over the internet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you are using TLS with a custom CA, or if you are using self-signed certificates,
    you have to create a `http.Client` with a `Transport` containing the certificate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new certificate pool:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Load the server certificate:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the certificate to the certificate pool:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a TLS config:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an HTTP Transport using the TLS config:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an HTTP client:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the client:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Always close the response body when you are done working with it, and try to
    read all data available in the body. The `response.Body` represents a streaming
    connection to the server. The server will reserve resources for the connection
    as long as there is data in transit and the client keeps the connection open.
    It also prevents the client from reusing keep-alive connections.
  prefs: []
  type: TYPE_NORMAL
- en: Running an HTTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The standard Go library offers an HTTP server with sensible defaults that you
    can use out of the box, similar to the way HTTP clients are implemented. If you
    need to configure transport specifics, timeouts, and so on, then you can create
    a new `http.Server` and work with it. This section describes both approaches.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an `http.Handler` to handle HTTP requests:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call `http.ListenAndServe`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ListenAndServe` function either returns immediately due to an error setting
    up a network listener (for example, if the address is already in use) or successfully
    starts listening. When the server is asynchronously closed (by calling `server.Close()`
    or `server.Shutdown()`), it returns `ErrServerClosed`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alternatively, you can use a `http.Server` struct to better control server
    options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an `http.Handler` as described.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Initialize an `http.Server` instance:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Listen HTTP requests:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: A common way to create an HTTP handler is to use a request multiplexer. Recipes
    for using a request multiplexer will be covered later.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS – setting up a TLS server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start a TLS server, you need a certificate and a private key. You can either
    purchase one from a CA or generate our own certificates with your internal CA.
    Once you have your certificate, you can use the recipes in this section to start
    your HTTPS server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a TLS HTTP server, use one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `Server.ListenAndServeTLS` method with the certificate and key files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use the default HTTP server, set a handler function (or `http.Handler`)
    and call `http.ListenAndServeTLS`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or prepare a `http.Transport` with certificates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '3.1 Load the TLS certificate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '3.2 Create a `tls.Config` using the certificate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '3.3 Create a `http.Server` using the `tlsConfig`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 3.4 Call `server.ListenAndServeTLS`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Writing HTTP handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an HTTP request arrives at a server, the server looks at the HTTP method
    (GET, POST, etc), the hostname the client used (the `Host` header), and the URL
    to decide how to handle the request. The mechanism that determines which handler
    should handle such a request is called a **request multiplexer**. The Go standard
    library comes with one, and there are many third-party open source multiplexers.
    In this section, we will look at the standard library multiplexer and how it can
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use an anonymous function for simple cases, such as a health-check
    endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding handler will respond to `GET /health` endpoint requests with an
    `Ok` and `HTTP` `200` status.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can use a data type that implements the `http.Handler` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new data type, which can be a struct containing information that you
    will need to implement the handler:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `http.Handler` interface:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Create an instance of the handler type and initialize it
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a multiplexer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Assign the handler to a pattern. The following example assigns `GET` requests
    for `/rnd` path to the instance constructed at *step 3*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Start the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A more general method involves creating data types with multiple methods as
    handlers. This pattern is especially useful for web service development because
    it allows for creating structures that serve all the APIs related to a specific
    business domain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a data type. This can be a struct containing all the necessary information
    to implement handlers, such as database connections, public/private keys, and
    so on:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Create methods using the signature for `http.HandlerFunc` to implement multiple
    API endpoints:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create an initialize the handlers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a request multiplexer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Assign handler methods to patterns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the multiplexer to start the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code snippet illustrates how you can use the standard library
    request multiplexer tools when writing HTTP handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Serving static files on the file system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all files served by web applications are dynamically generated. JavaScript
    files, cascading stylesheets, and some HTML pages are usually served verbatim.
    This section shows several methods to serve such files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several ways a static file can be served via HTTP:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To serve all static files under a directory, use `http.FileServer` to create
    a handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To serve all static files under a directory but with a different URL path prefix,
    use `http.StripPrefix`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The above call wraps the given file handler with another that strips the given
    prefix from the URL path. For a `GET /static/index.hml` request , this handler
    will serve `/var/www/index.html` with `Content-Type: text/html`. If the path does
    not include the given prefix, this will return `HTTP 404` `Not Found`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To add additional logic to URL-filename mapping, implement the `http.FileSystem`
    interface and use `FileServerFS` with that file system. You can combine this handler
    with `http.StripPrefix` to further change URL path processing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Handling HTML forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML forms are an essential component of capturing data in web applications.
    An HTML form can be processed on the server side through the use of a `Form` HTML
    element, or it can be processed on the client side using JavaScript. In this section,
    we will look at handling HTTP form submissions for server-side processing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the client side, do the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enclose data input fields in a `Form` HTML element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `method` attribute determines the HTTP method, which is `POST`, and
    the `action` attribute determines the URL. Note that this URL is relative to the
    current page URL. When the form is submitted, the client-side processing will
    prepare a `POST` request for the given URL, and send the contents of input fields
    as name-value pairs encoded as `application/x-www-form-urlencoded` encoding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On the server side, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a handler to process the `POST` request. In the handler, do the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Call `http.Request.ParseForm` to process submitted data.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the submitted information from `http.Request.PostForm`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Process the request.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example implements a simple login scenario using the submitted
    username and password. The handler uses an authenticator that performs the actual
    user validation and returns a cookie if the login is successful. This cookie contains
    information to identify the user in the subsequent calls:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Register the handler to handle the `POST` requests for the URL:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You have to be careful when working with cookies. In our example, a cookie was
    created by the server application and sent to the client. Subsequent calls to
    the server will include that cookie for the server to keep track of the user session.
    However, there is no guarantee that the cookie submitted by the client is a valid
    cookie. Malicious clients can send forged or expired cookies. Use cryptographic
    methods to ensure the cookie is created by the server, such as signing a cookie
    using a secret key, or using a JSON Web Token.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example includes another usage of cookies to send status information
    from one page to another. If login fails, the user is redirected to the login
    page with a cookie containing the error message. The login page handler can check
    the presence of this cookie and display the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example implementation is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'An implementation of the `NewErrorCookie` method looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Writing a handler for downloading large files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an HTTP client requests a large file, it is usually not feasible to load
    all the file data and then send it to the client. Use `io.Copy` to stream large
    content to clients.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is how you can write a handler to download a large file:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the `Content-Type` header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Content-Length` header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the file contents using `io.Copy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These steps are illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Handling HTTP uploaded files and forms as a stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard library provides methods to deal with file uploads. You can call
    `http.Request.ParseMultipartForm`, and work with uploaded files. There is one
    problem with this approach: `ParseMultipartForm` processes all uploads up to a
    given memory limit. It may even use temporary files. This is not a scalable approach
    if you are dealing with large files. This section describes how you can work with
    file uploads without creating temporary files or a large memory footprint.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the client side, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an HTML form with `multipart/form-data` encoding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the form fields and files that you are planning to upload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An example is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'When submitted, this form will create a multipart message containing two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a part with `Content-Disposition: form-data; name="textField"`. The
    contents of this part will contain the input the user typed for the `textField`
    input field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There’s also a part with `Content-Disposition: form-data; name="fileField";
    filename=<name of the file user selected>`. The contents of this part will contain
    the file contents.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the server side, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `http.Request.MultipartReader` to get a multipart body reader from the
    request. If the request is not a multipart request (multipart/mixes or multipart/form-data),
    this will fail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Process the parts of the submitted data one by one by calling `MultipartReader.NextPart`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the part is form data or file using the `Content-Disposition`
    header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `Content-Disposition` is `form-data` without a `filename` parameter, then
    this part contains a form field.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If `Content-Disposition` is `form-data` with a `filename` parameter, then this
    part is a file. You can read the file contents from the body.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
