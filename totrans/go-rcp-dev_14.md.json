["```go\n    buffer := make([]byte,1024)\n    ```", "```go\n    nRead, err := reader.Read(buffer)\n    ```", "```go\n    buffer = buffer[:nRead]\n    ```", "```go\n    if errors.Is(err,io.EOF) {\n      // End of file reached. Return data\n      return buffer, nil\n    }\n    if err!=nil {\n      // Some other error, handle it or return\n      return nil,err\n    }\n    ```", "```go\n    buffer, err:=json.Marshal(data)\n    if err!=nil {\n      return err\n    }\n    ```", "```go\n    _, err:= writer.Write(buffer)\n    if err!=nil {\n      return err\n    }\n    ```", "```go\n    data, err:=json.Marshal(myStruct)\n    if err!=nil {\n      return err\n    }\n    rsp, err:=http.Post(postUrl, \"application/json\", bytes.NewReader(data))\n    ```", "```go\n    buffer := &bytes.Buffer{}\n    encoder := json.NewEncoder(buffer)\n    if err:=encoder.Encode(myStruct); err!=nil {\n       return err\n    }\n    data := buffer.Bytes()\n    ```", "```go\nbuffer := &bytes.Buffer{}\nencoder := json.NewEncoder(buffer)\nif err:=encoder.Encode(myStruct); err!=nil {\n   return err\n}\nrsp,err:=http.Post(postUrl, \"application/json\", buffer)\n```", "```go\nrsp, err:=http.Post(postUrl,\"application/json\",strings.NewReader(`{\"key\":\"value\"}`))\n```", "```go\nquery:=strings.Builder{}\nargs:=make([]interface{},0)\nquery.WriteString(\"SELECT id,name FROM users \")\nif !createdAt.IsZero() {\n  args=append(args,createdAt)\n  fmt.Fprintf(&query,\"where createdAt < $%d\",len(args))\n}\nrows, err:=tx.Query(ctx,query.String(),args...)\n```", "```go\nfile, err := os.Open(fileName)\nif err!=nil {\n // handle error\n}\n```", "```go\nfile, err := os.Create(fileName)\nif err!=nil {\n  // handle error\n}\n```", "```go\n    file, err := os.OpenFile(fileName,os.O_RDWR, 0)\n    ```", "```go\n    file, err := os.OpenFile(fileName,os.O_RDONLY, 0)\n    ```", "```go\n    file, err := os.OpenFile(fileName,os.O_WRONLY, 0)\n    ```", "```go\n    file, err := os.OpenFile(fileName,os.O_WRONLY|os.O_APPEND, 0)\n    ```", "```go\n    file, err := os.OpenFile(fileName,os.O_RDWR|os.O_CREATE, 0o644)\n    ```", "```go\nfile, err:= os.Open(fileName, os.O_RDWR|os.O_CREATE|os.O_TRUNC,0o644)\n```", "```go\nfile, err := os.Open(fileName, os.O_RDWR|os.O_CREATE|os.O_EXCL,0o644)\n```", "```go\nfile, err:=os.Open(fileName)\nif err!=nil {\n  // handle error\n}\ndefer file.Close()\n// Work with the file\n```", "```go\nfor _,fileName:=range files {\n   file, err:=os.Open(fileName)\n   if err!=nil {\n     // handle error\n   }\n   defer file.Close()\n   // Work with file\n}\n```", "```go\nfor _,fileName:=range files {\n   file, err:=os.Open(fileName)\n   if err!=nil {\n     return err\n   }\n   // Work with file\n   err:=useFile(file)\n   if err!=nil {\n     file.Close()\n     return err\n   }\n   err:=useFileAgain(file)\n   if err!=nil {\n     file.Close()\n     return err\n   }\n   // Do more work\n   file.Close()\n}\n```", "```go\nfor _,fileName:=range files {\n   file, err:=os.Open(fileName)\n   if err!=nil {\n     return err\n   }\n   err=func() error {\n     defer file.Close()\n     // Work with file\n     err:=useFile(file)\n     if err!=nil {\n       return err\n     }\n     err:=useFileAgain(file)\n     if err!=nil {\n       return err\n     }\n     // Do more work\n     return nil\n   }()\n   if err!=nil {\n     return err\n   }\n}\n```", "```go\n    file, err:=os.Open(fileName)\n    if err!=nil {\n      return err\n    }\n    // Current location: 0\n    buffer:=make([]byte,100)\n    // Read 100 bytes\n    n, err:=file.Read(buffer)\n    // Current location: n\n    // n tells how many bytes actually read\n    data:=buffer[:n]\n    if err!=nil {\n      if errors.Is(err, io.EOF) {\n      }\n    }\n    ```", "```go\n    slices := make([][]byte,0)\n    for {\n      buffer:=make([]byte,1024)\n      n, err:=file.Read(buffer)\n      if n>0 {\n        slices=append(slices,buffer[:n])\n        buffer=make([]byte,1024)\n      }\n      if err!=nil {\n        if errors.Is(err,io.EOF) {\n          break\n        }\n        return err\n      }\n    }\n    ```", "```go\n    buffer:=[]byte(\"Hello world!\")\n    n, err:=io.Write(buffer)\n    if err!=nil {\n      return err\n    }\n    ```", "```go\n    data, err:= os.ReadFile(\"config.yaml\")\n    if err!=nil {\n      // Handle error\n    }\n    ```", "```go\n    // Read file in 10K chunks\n    buf:=make([]byte,10240)\n    for {\n      n, err:=file.Read(buf)\n      if n>0 {\n        // Process buffer contents:\n        processData(buf[:n])\n      }\n      // Check for errors. Check for io.EOF and handle it\n      if err!=nil {\n        if errors.Is(err,io.EOF) {\n          // End of file. We are done\n          break\n        }\n        // Some other error\n        return err\n      }\n    }\n    ```", "```go\n    err:=os.WriteFile(\"config.yaml\", data, 0o644)\n    ```", "```go\n    // Move to offset 100 in file\n    newLocation, err := file.Seek(100,io.SeekStart)\n    ```", "```go\n    // Move to the end of the file:\n    newLocation, err := file.Seek(0,io.SeekEnd)\n    ```", "```go\n    // Go to 100 after the end of file and write 1 byte\n    newLocation, err:=file.Seek(100, io.SeekEnd)\n    if err!=nil {\n      panic(err)\n    }\n    // Write 1 byte.\n    file.Write([]byte{0})\n    // The file is 101 bytes larger now.\n    ```", "```go\n    // Go to offset 1000\n    _,err:=file.Seek(1000,io.SeekStart)\n    // Write \"Hello world\" to offset 10.\n    n, err:=file.WriteAt([]byte(\"Hello world!\"),10)\n    if err!=nil {\n      panic(err)\n    }\n    // Write to offset 1000, because WriteAt does not move\n    // the current location\n    _,err:=file.WriteAt([]byte{\"offset 1000\")\n    buffer:=make([]byte,5)\n    file.ReadAt(buffer,10)\n    fmt.Println(string(buffer))\n    // Prints \"Hello\"\n    ```", "```go\n    file, err:=os.OpenFile(\"test.txt\", os.O_RDWR|os.O_TRUNC,0o644)\n    // File is opened and truncated to 0 size\n    ```", "```go\n    // Truncate the file to 0-size\n    err:=file.Truncate(0)\n    if err!=nil {\n      panic(err)\n    }\n    // Extend the file to 100-bytes\n    err=file.Truncate(100)\n    if err!=nil {\n      panic(err)\n    }\n    ```", "```go\n    file, err:=os.OpenFile(\"test.txt\", os.O_WRONLY|os.O_APPEND,0)\n    // File is opened for writing, current location is set to the\n    // end of the file\n    ```", "```go\n    // Seek to the end\n    _,err:=file.Seek(0,io.SeekEnd)\n    if err!=nil {\n      panic(err)\n    }\n    // Write new data to the end of the file\n    _,err:=file.Write(data)\n    ```", "```go\nfileSize, err:= file.Seek(0,io.SeekEnd)\n```", "```go\n// Get current location\ncurrentLocation, err:=file.Seek(0,io.SeekCurrent)\nif err!=nil {\n  return err\n}\n// Find file size\nfileSize, err:=file.Seek(0,io.SeekEnd)\nif err!=nil {\n  return err\n}\n// Move back to the saved location\n_,err:=file.Seek(currentLocation,io.SeekStart)\nif err!=nil {\n  return err\n}\n```", "```go\nfileInfo, err:=os.Stat(fileName)\nif err!=nil {\n  return err\n}\nfileSize := fileInfo.Size()\n```", "```go\ntype Data struct {\n  IntValue int64\n  BoolValue bool\n  ArrayValue [2]int64\n}\nfunc main() {\n  output := bytes.Buffer{}\n  data:=Data{\n    IntValue: 1,\n    BoolValue: true,\n    ArrayValue: [2]int64{1,2},\n  }\n  // Encode data using big endian byte order\n  binary.Write(&output, binary.BigEndian, data)\n  stream := output.Bytes()\n  fmt.Printf(\"Big endian encoded data   : %v\\n\", stream)\n  // Decode data\n  var value1 Data\n  binary.Read(bytes.NewReader(stream), binary.BigEndian, &value1)\n  fmt.Printf(\"Decoded data: %v\\n\", value1)\n  // Encode data using little endian byte order\n  output = bytes.Buffer{}\n  binary.Write(&output, binary.LittleEndian, data)\n  stream = output.Bytes()\n  fmt.Printf(\"Little endian encoded data: %v\\n\", stream)\n  // Decode data\n  var value2 Data\n  binary.Read(bytes.NewReader(stream), binary.LittleEndian, &value2)\n  fmt.Printf(\"Decoded data: %v\\n\", value2)\n}\n```", "```go\nBig endian encoded data   : [0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 2]\nDecoded data: {1 true [1 2]}\nLittle endian encoded data: [1 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0]\nDecoded data: {1 true [1 2]}\n```", "```go\nfunc EncodeString(s string) []byte {\n  // Allocate the output buffer for string length (int16) + \n  // len(string)\n  buffer:=make([]byte, 0, len(s)+2)\n  // Encode the length little endian - 2 bytes\n  binary.LittleEndian.PutUint16(buffer,uint16(len(s)))\n  // Copy the string bytes\n  copy(buffer[2:],[]byte(s))\n  return buffer\n}\n```", "```go\nfunc DecodeString(input []byte) (string, error) {\n     // Read the string length. It must be at least 2 bytes\n     if len(input) < 2 {\n          return \"\", fmt.Errorf(\"invalid input\")\n     }\n     n := binary.LittleEndian.Uint16(input)\n     if int(n)+2 > len(input) {\n          return \"\", fmt.Errorf(\"invalid input\")\n     }\n     return string(input[2 : n+2]), nil\n}\n```", "```go\nsourceFile, err:=os.Open(sourceFileName)\nif err!=nil {\n  panic(err)\n}\ndefer sourceFile.Close()\ntargetFile, err:=os.Create(targetFileName)\nif err!=nil {\n  panic(err)\n}\ndefer targetFile.Close()\nif _,err:=io.Copy(targetFile,sourceFile);err!=nil {\n  panic(err)\n}\n```", "```go\n// Handle GET /path/{fileName}\nfunc HandleGetImage(w http.ResponseWriter, req *http.Request) {\n  // Get the file name from the request\n  file, err:=os.Open(req.PathValue(\"fileName\"))\n  if err!=nil {\n    http.Error(w,err.Error(),http.StatusNotFound)\n    return\n  }\n  defer file.Close()\n  // Write file contents to the response writer\n  io.Copy(w,file)\n}\n```", "```go\n    fmt.Println(filepath.Join(\"/a/b/\",\"/c/d\")\n    // Prints /a/b/c\n    fmt.Println(filepath.Join(\"/a/b/c/d/\",\"../../x\")\n    // Prints a/b/x\n    ```", "```go\n    fmt.Println(filepath.Split(\"/home/bserdar/work.txt\"))\n    // dir: \"/home/bserdar\" file: \"work.txt\"\n    fmt.Println(filepath.Split(\"/home/bserdar/projects/\"))\n    // dir: \"/home/bserdar/projects/\" file: \"\"\n    ```", "```go\n    dir, err:=os.MkdirTemp(\"\",\"tempdir\")\n    if err!=nil {\n      // Handle error\n    }\n    // Clean up when done\n    defer os.RemoveAll(dir)\n    fmt.Println(dir)\n    // Prints /tmp/example10287493\n    ```", "```go\n    // Create a temporary directory under the current directory\n    dir, err:=os.MkdirTemp(\".\",\"tempdir\")\n    if err!=nil {\n      // Handle error\n    }\n    // Cleanup when done\n    defer os.RemoveAll(dir)\n    ```", "```go\n    dir, err:=os.MkdirTemp(\".\", \"myapp.*.txt\")\n    if err!=nil {\n      // Handle error\n    }\n    defer os.RemoveAll(dir)\n    fmt.Println(dir)\n    // Prints ./myapp.13984873.txt\n    ```", "```go\n    file, err:=os.CreateTemp(\"\",\"app.*.txt\")\n    if err!=nil {\n      // Handle error\n    }\n    fmt.Println(\"Temp file\", file.Name)\n    // Cleanup when done\n    defer os.Remove(file.Name)\n    defer file.Close()\n    ```", "```go\n    entries, err:=os.ReadDir(\".\")\n    if err!=nil {\n      // handle error\n    }\n    for _, entry:=range entries {\n       // Name contains the file name only, not the directory\n       name := entry.Name()\n       if entry.IsDir() {\n         // This is a directory\n       } else {\n         // This is not a directory. Does not mean it is a regular \n         // file Can be a named pipe, device, etc.\n       }\n    }\n    ```", "```go\n    // Open the directory\n    dir, err:= os.Open(\"/tmp\")\n    if err!=nil {\n      panic(err)\n    }\n    defer dir.Close()\n    // Read directory entries unordered, 10 at a time\n    for {\n      entries, err:=dir.ReadDir(10)\n      // Are we done reading\n      if errors.Is(err, io.EOF) {\n        break\n      }\n      if err!=nil {\n        panic(err)\n      }\n      // There are at most 10 fileInfo entries\n      for _,entry:=range entries {\n        // Process the entry\n      }\n    }\n    ```", "```go\n    err:=fs.WalkDir(os.DirFS(\"/\"), \"/tmp\", func(path string,d fs.DirEntry,err error) error {\n      if err!=nil {\n         fmt.Println(\"Error during directory traversal\", err)\n         return err\n      }\n      if !d.IsDir() {\n        // This is not  a directory\n        fmt.Println(filepath.Join(path,d))\n      }\n      return nil\n    })\n    ```", "```go\n    err:=filepath.WalkDir(\"/tmp\", func(path string,d fs.DirEntry,err error) error {\n      if err!=nil {\n         fmt.Println(\"Error during directory traversal\", err)\n         return err\n      }\n      if d.IsDir() {\n        // This is a directory\n        fmt.Println(filepath.Join(path,d), \" directory\")\n      }\n      return nil\n    })\n    ```", "```go\n    pipeReader, pipeWriter := io.Pipe()\n    ```", "```go\n    go func() {\n      // Close the writer side, so the reader knows when it is done\n      defer pipeWriter.Close()\n      encoder:=json.NewEncoder(pipeWriter)\n      if err:=encoder.Encode(payload); err!=nil {\n        if errors.Is(err,io.ErrClosedPipe) {\n          // The reader side terminated with error\n        } else {\n          // Handle error\n        }\n      }\n    }()\n    ```", "```go\n    if _, err:= http.Post(serverURL, \"application/json\", pipeReader); err!=nil {\n      // Close the reader, so the writing goroutine terminates\n      pipeReader.Close()\n      // Handle error\n    }\n    ```", "```go\n    pipeReader, pipeWriter := io.Pipe()\n    ```", "```go\n    file, err:=os.Open(dataFile)\n    if err!=nil {\n      // Handle error\n    }\n    defer file.Close()\n    tee := io.TeeReader(file, pipeWriter)\n    ```", "```go\n    go func() {\n      // Copy the file to stdout\n      io.Copy(os.Stdout,pipeReader)\n    }()\n    ```", "```go\n    _,err:=http.Post(serverURL, \"text/plain\", tee)\n    if err!=nil {\n      // Make sure pipe is closed\n      pipeReader.Close()\n    }\n    ```"]