- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Streaming Input/Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is flexibility and elegance in simplicity. Unlike several languages that
    decided to implement a feature-rich streaming framework, Go chose a simple capability-based
    approach: a reader is something from which you read bytes, and a writer is something
    to which you write bytes. In-memory buffers, files, network connections, and so
    on are all readers and writers, defined by `io.Reader` and `io.Writer`. A file
    is also an `io.Seeker`, as you can randomly change the reading/writing location,
    but a network connection is not. A file and a network connection can be closed,
    so they are both `io.Closer`, but a memory buffer is not. Such simple and elegant
    abstractions are the key to writing algorithms that can be used in different contexts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at some recipes showing how this capability-based
    streaming framework can be used idiomatically. We will also look at how to work
    with files and the filesystem. The recipes covered in this chapter are in the
    following main sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Readers/writers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with binary data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Readers/writers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember, Go uses a structural type system. This makes any data type that implements
    `Read([]byte) (int,error)` an `io.Reader`, and any data type that implements `Write([]byte)
    (int,error)` an `io.Writer`. There are many uses of this property in the standard
    library. In this recipe, we will look at some of the common uses of readers and
    writers.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from a reader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An `io.Reader` fills a byte slice you pass to it. By passing a slice, you actually
    pass two pieces of information: how much you want to read (the length of the slice)
    and where to put the data that was read (the underlying array of the slice).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a byte slice large enough to hold the data you want to read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Read the data into the byte slice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check how much was read. The number of bytes actually read may be smaller than
    the buffer size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check the error. If the error is `io.EOF`, then the reader reached the end
    of the stream. If the error is something else, handle the error or return it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the ordering of *steps 3* and *4*. Returning `io.EOF` is not necessarily
    an error, it simply means the end of the file has been reached or the network
    connection has been closed, so you should stop reading. There is probably some
    data read in the buffer, and you should process that data. The reader returns
    how much data was read.
  prefs: []
  type: TYPE_NORMAL
- en: Writing data to a writer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Encode the data you want to write as a byte slice; for instance, use `json.Marshal`
    to get the JSON representation of your data as a `[]byte`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the encoded data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Check and handle errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Unlike a reader, all errors returned from a writer should be treated as errors.
    A writer does not return `io.EOF`. Even when there is an error, a write may have
    written some part of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from and writing to a byte slice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A reader or a writer does not have to be a file or a network connection. This
    section shows how you can work with byte slices as readers and writers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a reader from a `[]byte`, use `bytes.NewReader`. The following example
    marshals a data structure to JSON (which returns a `[]byte`), then sends that
    `[]byte` to an HTTP `POST` request by creating a reader from it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use a `[]byte` as a writer, use `bytes.Buffer`. The buffer will append to
    the underlying byte slice as you write to it. When you are done, you can get the
    contents of the buffer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A `bytes.Buffer` is also an `io.Reader`, with a separate read location. Writing
    to a `bytes.Buffer` appends to the end of the underlying slice. Reading from a
    `bytes.Buffer` starts reading from the beginning of the underlying slice. Because
    of this, you can read the bytes you wrote, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Reading from and writing to a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a reader from a string, use `strings.NewReader`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Do *not* use `bytes.NewReader([]byte(stringValue))` instead of `strings.NewReader(stringValue)`.
    The former copies the contents of the string to create a byte slice. The latter
    accesses the underlying bytes without copying.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a string as an `io.Writer`, use `strings.Builder`. For instance, as
    an `io.Writer`, `strings.Builder` can be passed to the `fmt.Fprint` family of
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Working with files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Files are simply sequences of bytes on a storage system. There are two ways
    of working with files: as a random access byte sequence or as a stream of bytes.
    We will look at both types of recipes in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and opening files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work with the contents of a file, you first have to open it or create it.
    This recipe shows how that can be done.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To open an existing file for reading, use `os.Open`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can read data from the returned file object, and when you are done, you
    should close it using `file.Close()`. So, you can use it as an `io.Reader` or
    `io.ReadCloser` (there are more interfaces that `*``os.File` implements!)
  prefs: []
  type: TYPE_NORMAL
- en: If you attempt to write to the file, you will receive an error from the write
    operation. On my Linux system, this error is a `*fs.PathError` message saying
    `bad` `file descriptor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new file or to overwrite an existing one, use `os.Create`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If the above call is successful, the returned file can be read from or written
    to. The file is created with `0o666 & ^umask`. If the file already existed before
    this call, it will be truncated to a length of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: '`umask` defines the set of permissions applications cannot set on files. In
    the preceding text, `0o666` means that the owner, group, and others can read and
    write the file. A `umask` value of `0o022`, for instance, will change the file
    mode from `0o666` to `0o644`, which means the owner can read and write, but the
    group and others can only read.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To open an existing file for reading/writing, use `os.OpenFile`. This is the
    most general form of the open/create family of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To open an existing file for both reading and writing, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last argument is `0`. This argument is only used when creating the file
    is an option. We will see this case later shortly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To open an existing file for reading only, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To open an existing file for writing only, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To open an existing file for appending only, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Trying to write somewhere other than the end of the file will fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To open an existing file or to create one if it does not exist, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The above operation will open the file for reading and writing if it exists.
    If the file does not exist, it will be created using the `0o644 & ^umask` permission
    bits. `0o644` means the owner can read/write (`06`), users from the same group
    can read (`04`), and other users can read (`04`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following is equivalent to `os.Create`; that is, truncate and open the
    file if it exists but create if it does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to create the file only if it does not exist, use the “exclusive”
    bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This call will fail if the file already exists.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: This is a common way of ensuring a single instance of a process is running,
    or to lock a resource if it is not locked. For instance, if you want to lock a
    directory, you can use this call to create a lock file. It will fail if some other
    process already locked it (created the file before you.)
  prefs: []
  type: TYPE_NORMAL
- en: Closing a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two reasons why you should always explicitly close files you open:'
  prefs: []
  type: TYPE_NORMAL
- en: All data stored in buffers are flushed when you close the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are limits to how many files you can keep open at any given time. These
    limits change from platform to platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following steps show how you can do this consistently.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you are done working with a file, close it. Use `defer file.Close()` where
    possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Do *not* rely on `defer` if you are working with many files. Do not do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Deferred calls will execute when the function returns, not when the block in
    which you used them ends. The above code will keep all the files open until the
    function returns, and if there is a large number of files, `os.Open` will start
    failing once you pass the open file limit. You can do one of two things. The first
    is to explicitly close the file for all exit points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The second is to use a closure with `defer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Files are garbage collected. If you open/create files and then work with file
    descriptors directly instead of using `*os.File`, the garbage collector is not
    your friend. Use `runtime.KeepAlive(file)` to prevent the garbage collector from
    closing the file while you’re working with it through the file descriptor and/or
    syscalls. Avoid relying on the garbage collector to close your files. Always close
    files explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Reading/writing data from/to files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you open a file for reading and writing, the operating system keeps the
    `0`. Then if you read 10 bytes from the file, the current location becomes `10`
    (assuming the file is larger than 10 bytes). The next time you read from the file
    or write to it, you will read the contents or write starting from an offset of
    `10`. Keep this behavior in mind, especially if you are mixing reads and writes
    to a file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To read some data starting from the current location, use `file.Read`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The ordering of checking for `n` (the number of bytes read) and checking whether
    there was an error is important. An `io.Reader` may do a partial read and return
    the number of bytes read along with an error. That error may be `io.EOF`, signifying
    that the file has less data than you attempted to read. For instance, a file with
    10 bytes will return `n=10` and `err=io.EOF`. Also note that this behavior is
    dependent on the current location of the file. The following code segment reads
    the file as a slice of byte slices:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the current location in the file is `0` when the preceding code begins, after
    every read operation, the current location will progress by `n`. Note that all
    the byte slices will be `1024` bytes except the last. The last slice can be anywhere
    from `1` to `1024` bytes, depending on the file size.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Writing to a file is done similarly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A write operation will not return `io.EOF`. If you write past the end of the
    file, the file will be enlarged to accommodate the written bytes. If the write
    operation cannot write all the given bytes, the error will always be non-nil,
    and you should check and handle the error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the current location is `0` at the beginning, it will be `n` after the write
    operation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To read everything from a file, use `os.ReadFile`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Be careful when using `os.ReadFile`. It allocates a `[]byte` that is the size
    of the file. Use this function only if you are sure the file you are reading is
    of a reasonable size.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read a large file in fixed-size chunks, allocate a fixed-size buffer and
    read iteratively until `io.EOF` is returned:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To write a byte slice to a new file, use `os.WriteFile`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Reading/writing from/to a specific location
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We talked about the concept of the **current location** previously. This section
    is about moving the current location to start reading or writing from a random
    location in a file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may change the current location using `File.Seek`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the current location relative to the beginning of the file, use the
    following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The returned `newLocation` is the new current location of the file. Subsequent
    read or write operations will read from or write to that location.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To set the current location relative to the end of the file, use the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is also a quick way of determining the current file size, as `newLocation`
    is 0 bytes ahead of the end of the file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can seek beyond the end of the file. Reading from such a location will
    read 0 bytes. Writing to such a location will extend the file size to accommodate
    the data written at that location:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When you extend a file like this, the area between the end of the file and the
    newly written bytes is filled with 0s. The underlying platform may implement this
    as a **hole**; that is, the area that is not written may not be actually allocated.
  prefs: []
  type: TYPE_NORMAL
- en: '`os.File` supports additional methods for such random access. `File.WriteAt`
    will write data to the given location (relative to the beginning of the file)
    without moving the current location. `File.ReadAt` will read from the given location
    without moving the current location:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Changing the file size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extending a file is usually achieved by writing more data to the end of it,
    but how can you shrink an existing file? This recipe describes different ways
    to change the file size.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To truncate a file to a size of `0`, you can open a file with the truncate
    flag:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the file is already open, you can use `File.Truncate` to set the file size.
    `File.Truncate` works both ways – you can extend a file or you can shrink it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also extend a file by appending to it. You can do this in one of two
    ways. You can open the file for append-only:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you open a file append-only, you cannot read/write from other locations of
    the file, you can only append to it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Alternatively, you can seek the end of the file and start writing there:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finding the file size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the file is open, you can obtain the file size as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will return the current file size, including any data that was appended
    but not yet flushed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above operation will move the file pointer to the end of the file. To preserve
    the current location, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If the file is not open, use `os.Stat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you have the file open and you appended data to the file, the file size reported
    by `os.Stat` may be different from the file size you obtained by `File.Seek`.
    The `os.Stat` function reads the file information from the directory. The `File.Seek`
    method uses process-specific file information that may not have been reflected
    in the directory entry yet.
  prefs: []
  type: TYPE_NORMAL
- en: Working with binary data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need to send a piece of data over a network connection or store it in
    a file, you first have to encode it (or serialize it, or marshal it.) This is
    necessary because the system at the other end of the network connection or the
    application that will read the file you wrote may be running on a different platform.
    A portable, easy-to-debug but not necessarily efficient way to do this is to use
    text-based encodings such as JSON. If performance is paramount or when the use
    case demands it, you use binary encoding.
  prefs: []
  type: TYPE_NORMAL
- en: There are many high-level binary encoding schemes. Gob ([https://pkg.go.dev/encoding/gob](https://pkg.go.dev/encoding/gob))
    is a Go-specific encoding scheme that can be used for networking applications.
    Protocol buffers ([https://protobuf.dev](https://protobuf.dev)) provide a language-neutral,
    extensible, schema-driven mechanism for encoding structured data. There are more.
    Here, we will look at the basics of binary encoding that every software engineer
    should know about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Encoding data involves transforming data elements into a stream of bytes. If
    you have a data element that is a single byte or a data element that is already
    a sequence of bytes, you can encode them verbatim. When working with multi-byte
    data types (`int16`, `int32`, `int64`, etc.), how you order those bytes becomes
    important. For example, if you have an `int16` value of `0xABCD`, how should you
    encode those bytes as a `[]byte`? There are two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0xABCD` is encoded as `[]``byte{0xCD, 0xAB}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0xABCD` is encoded as `[]``byte{0xAB, 0xCD}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, a 32-bit integer, `0x01234567`, encoded in little-endian byte order
    gives `[]byte{0x67,0x45,0x23,0x01}` and encoded in big-endian byte ordering gives
    `[]byte{0x01,0x23,0x45,0x67}`. Most modern hardware uses little-endian byte ordering
    to represent values in memory. Network protocols (such as IP) tend to use big-endian.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two main approaches to encoding binary data:'
  prefs: []
  type: TYPE_NORMAL
- en: The first is using a fixed structure. In this approach, the ordering and type
    of data fields are fixed. For instance, the IPv4 header defines where every header
    field starts and ends. There is no way to omit a field or add extensions in this
    approach. An example is shown in *Figure 14**.1*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 14.1: Fixed-length encoding example](img/B21961_14_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Fixed-length encoding example'
  prefs: []
  type: TYPE_NORMAL
- en: The second is using a dynamic encoding scheme, such as `string` field, then
    the length, and then the string itself. An example TLV encoding scheme is shown
    in *Figure 14**.2*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 14.2: TLV encoding example](img/B21961_14_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: TLV encoding example'
  prefs: []
  type: TYPE_NORMAL
- en: This example uses 16-bit string length and 64-bit slice length encoding.
  prefs: []
  type: TYPE_NORMAL
- en: Use `encoding/binary` to encode data in big-endian or little-endian byte ordering.
  prefs: []
  type: TYPE_NORMAL
- en: 'For fixed-length encoding, you can use `encoding.Write` to encode, and `encoding.Read`
    to decode data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This program outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Take special care when defining the `Data` structure. You cannot use variable
    length or platform-specific types if you want to use `encoding.Read` or `encoding.Write`:'
  prefs: []
  type: TYPE_NORMAL
- en: No `int` because the size of `int` is platform-specific
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No slices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No maps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How can we encode these values, then? Let’s take a look at an LV encoding scheme
    to encode a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is one to decode a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Copying data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`io.Copy` reads data from a reader and writes it to a writer until one of the
    operations fails or the reader returns `io.EOF`. There are many use cases where
    you need to get chunks of data from a reader and send it to a writer. `io.Copy`
    works at an abstract layer that allows you to copy data from a file to a network
    connection, or from a string to a file. It also performs capability-based optimizations
    to minimize data copying. For instance, if the platform supports the splice system
    call, `io.Copy` can use it to bypass buffer usage. In this section, we will see
    some uses of `io.Copy`.'
  prefs: []
  type: TYPE_NORMAL
- en: Copying files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To copy a file, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the target file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `io.Copy` to copy data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close both files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These steps are illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `io.Copy` works with `io.Reader` and `io.Writer`, any object implementing
    these interfaces can be used as the source or the target. For example, the following
    code segment returns a file as a response to an HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Working with the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many aspects of filesystems that are platform-specific. This section
    talks about portable ways of working with filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Working with filenames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `path/filepath` package to work with filenames in a portable way.
  prefs: []
  type: TYPE_NORMAL
- en: How do to it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build a path from several path segments, use `filepath.Join`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that `filepath.Join` does not allow consecutive separators, and interprets
    `".."` correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To split a path to its directory and filename parts, use `filepath.Split`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Avoid using path separators (`/` and `\`) in your code. Use `filepath.Separator`,
    which is a platform-specific rune value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating temporary directories and files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you will need to create unique directory names and filenames, mostly
    for temporary data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create a temporary directory under the platform-specific default directory
    for temporary files, use `os.MkdirTemp("",prefix)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The created name is unique. If there are multiple calls to create a temporary
    directory, each will generate a unique name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a temporary directory under a specific directory, use `os.MkdirTemp(dir,prefix)`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create a temporary directory with the random part of the name not as a suffix,
    use `*`. The random string replaces the last `*` character:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create a temporary file, use `os.CreateTemp`. A unique file is created and
    opened for reading and writing. The name of the created file can be obtained from
    the returned `file.Name` value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similar to `os.MkdirTemp`, if the filename contains `*`, a random string is
    inserted in place of the last `*` character. If the filename does not contain
    `*`, the random string is appended at the end of the name.
  prefs: []
  type: TYPE_NORMAL
- en: Reading directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `os.ReadDir` to list or discover files under a directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Call `os.ReadDir` to get the contents of a directory. This returns directory
    entries in order sorted by name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You may notice that `os.ReadDir` is not your best bet if you are dealing with
    potentially large directories. It returns an unbounded slice, and it also spends
    time sorting it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For performance and memory-conscious applications, open the directory and read
    it using `File.ReadDir`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To recursively iterate directory entries in a portable way, use `io.fs.WalkDir`.
    This function uses `"/"` as the path separator regardless of the platform. The
    following example prints all the files under `/tmp`, skipping directories:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To recursively iterate directory entries, use `filepath.WalkDir`. This function
    uses a platform-specific path separator. The following example prints all directories
    under `/``tmp` recursively:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Working with pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a piece of code that expects a reader and another piece of code
    that expects a writer, you can connect the two using `io.Pipe`.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting code expecting a reader with code expecting a writer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A good example of this use case is preparing an HTTP `POST` request, which requires
    a reader. If you have all of the data available, or if you already have a reader
    (such as `os.File`), you can use that. However, if the data is produced by a function
    that takes a writer, use a pipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A pipe is a synchronously connected reader and writer. That is, if you write
    to a pipe, there must be a reader consuming from it concurrently. So make sure
    you put the data-producing side (where you use the writer) in a different goroutine
    than the data-consuming side (where you use the reader).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a pipe reader and pipe writer using `io.Pipe`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`pipeReader` will read everything written to `pipeWriter`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `pipeWriter` to produce data in a goroutine. When everything is written,
    close `pipeWriter`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `pipeReader` where a reader is needed. If the function fails and not everything
    in the pipe can be consumed, close `pipeReader` so the writer can terminate:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Above, the goroutine that encodes the JSON data will block until the `POST`
    request establishes a connection and streams the data. If there is an error during
    this process, `pipeReader.Close()` ensures that the goroutine that encodes JSON
    data does not leak.
  prefs: []
  type: TYPE_NORMAL
- en: Intercepting a reader using TeeReader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In plumbing, a tee pipe is a fitting that has a T shape. It splits the flow
    into two. `TeeReader` takes its name from that. An `io.TeeReader(r io.Reader,
    w io.Writer) io.Reader` function returns a new reader that reads from `r` at the
    same time as writing whatever it read to `w`. This is very useful for intercepting
    the data going through a reader.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a pipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `TeeReader` from another reader, using `pipeWriter` as the writer
    that will receive data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this stage, reading some data from `tee` will read data from `file` and write
    that data to `pipeWriter`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `pipeReader` in a separate goroutine to process data read from the original
    reader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `TeeReader` to read the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that working with a pipe requires at least one other goroutine where writing
    to or reading from the pipe happens. In case of error, make sure all goroutines
    working with the pipe terminate by closing one end of the pipe.
  prefs: []
  type: TYPE_NORMAL
