["```go\npackage main\nimport (\n    \"fmt\"\n    \"database/sql\"\n    \"context\"\n    // Import the mysql driver\n    _ \"github.com/go-sql-driver/mysql\"\n)\nfunc main() {\n    // Use mysql driver name and driver specific connection string\n    db, err := sql.Open(\"mysql\", \"username:password@tcp(host:port)/\n    databaseName\")\n    if err != nil {\n        panic(err.Error())\n    }\n    defer db.Close()\n    // Check if database connection succeeded, with 5 second timeout\n    ctx, cancel := context.WithTimeout(context.\n    Background(),5*time,Second)\n    defer cancel()\n    if err:=db.PingContext(ctx); err!=nil {\n        panic(err)\n    }\n    fmt.Println(\"Success!\")\n}\n```", "```go\npackage main\nimport (\n    \"database/sql\"\n    \"fmt\"\n    \"os\"\n    // Import the database driver\n    _ \"github.com/mattn/go-sqlite3\"\n)\nfunc main() {\n    // Open the sqlite database using the given local file ./database.\n    // db\n    db, err := sql.Open(\"sqlite3\", \"./database.db\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer db.Close()\n    // You don't need to ping an embedded database\n}\n```", "```go\n    result, err:=db.ExecContext(ctx,`UPDATE users SET user.last_login=? WHERE user_id=?\",time.Now(), userId)\n    if err!=nil {\n      // Handle error\n    }\n    n, err:=result.RowsAffected()\n    if err!=nil {\n      // Handle error\n    }\n    if n!=1 {\n      return errors.New(\"Cannot update last login time\")\n    }\n    ```", "```go\n    func AddUsers(db *sql.DB, users []User) error {\n      stmt, err := db.Prepare(`INSERT INTO users (user_name,email) \n      VALUES (?,?)`)\n      if err!=nil {\n        return err\n      }\n      // Close the prepared statement when done\n      defer stmt.Close()\n      for _,user:=range users {\n        // Run the prepared statement with different arguments\n        _, err := stmt.Exec(user.Name,user.Email)\n        if err!=nil {\n          return err\n        }\n      }\n      return nil\n    }\n    ```", "```go\nfunc GetUserNamesLoggedInAfter(db *sql.DB, after time.Time) ([]string,error) {\n  rows, err:=db.Query(`SELECT users.user_name FROM users WHERE \n  last_login > ?`, after)\n  if err!=nil {\n    return nil,err\n  }\n  defer rows.Close()\n  names:=make([]string,0)\n  for rows.Next() {\n    var name string\n    if err:=rows.Scan(&name); err!=nil {\n      return nil,err\n    }\n    names=append(names,name)\n  }\n  // Check if iteration produced any errors\n  if err:=rows.Err(); err!=nil {\n    return nil,err\n  }\n  return names,nil\n}\n```", "```go\nfunc GetUserByID(db *sql.DB, id string) (*User, error) {\n  var user User\n  err:=db.QueryRow(`SELECT user_id, user_name, last_login FROM \n  users WHERE user_id=?`,id).\n    Scan(&user.Id, &user.Name, &user.LastLogin)\n  if errors.Is(err,sql.ErrNoRows) {\n    return nil,nil\n  }\n  if err!=nil {\n    return nil,err\n  }\n  return &user,nil\n}\n```", "```go\nctx, cancel := context.WithCancel(context.Background())\ndefer cancel()\n// 1\\. Start transaction\ntx, err := db.BeginTx(ctx, &sql.TxOptions{\n  Isolation: sql.LevelReadCommitted,\n  })\nif err!=nil {\n  // Handle error\n}\n// 2\\. Call rollback with defer, so in case of error, transaction\n// rolls back\ndefer tx.Rollback()\n```", "```go\n_, err:= tx.Exec(`UPDATE users SET user.last_login=? WHERE user_id=?\",time.Now()`, userId)\nif err!=nil {\n  // Do not commit, handle error\n}\n```", "```go\ntx.Commit()\n```", "```go\n    txStmt := tx.Stmt(stmt)\n    ```", "```go\ntype User struct {\n  ID        uint64\n  Name      string\n  LastLogin time.Time\n  AvatarURL string\n}\n```", "```go\nCREATE TABLE users (\n  user_id int not null,\n  user_name varchar(32) not null,\n  last_login timestamp null,\n  avatar_url varchar(128) null\n)\n```", "```go\nrows, err := db.Query(`SELECT user_id, user_name, last_login, avatar_url FROM users WHERE last_login > ?`, after)\nif err!=nil {\n  return err\n}\n// Close the rows object when done\ndefer rows.Close()\nfor rows.Next() {\n  // Retrieve data from this row\n}\n```", "```go\nusers:=make([]User,0)\nfor rows.Next() {\n  // Retrieve data from this row\n  var user User\n  // avatar column is nullable, so we pass a *string instead of string\n  var avatarURL *string\n  if err:=rows.Scan(\n    &user.ID,\n    &user.Name,\n    &user.LastLogin,\n    &avatarURL);err!=nil {\n      return err\n    }\n    // avatar URL can be nil in the db\n    if avatarURL!=nil {\n      user.AvatarURL=*avatarURL\n    }\n    users=append(users,user)\n}\n```", "```go\n// Check if there was an error during iteration\nif err:=rows.Err(); err!=nil {\n  return err\n}\n```", "```go\nvar user User\nrow:=db.QueryRow(`SELECT user_id, user_name, last_login, avatar_url FROM users WHERE user_id = ?`, id)\nif err:=row.Scan(\n   &user.ID,\n   &user.Name,\n   &user.LastLogin,\n   &avatarURL);err!=nil {\n  return err\n}\nreturn user\n```", "```go\n        type UpdateUserRequest struct {\n          Name *string\n          LastLogin *time.Time\n          AvatarURL *string\n        }\n        ```", "```go\n    now:=time.Now()\n    urlString:=\"https://example.org/avatar.jpg\"\n    update:=UpdateUserRequest {\n      LastLogin: &now,\n      AvatarURL: &urlString,\n    }\n    ```", "```go\n    func UpdateUser(ctx context.Context, db *sql.DB, userId uint64, req *UpdateUserRequest) error {\n      ...\n    }\n    ```", "```go\n        query:=strings.Builder{}\n        args:=make([]interface{},0)\n        // Start building the query. Be mindful of spaces to separate \n        // query clauses\n        query.WriteString(\"UPDATE users SET \")\n        ```", "```go\n    if req.Name != nil {\n      args=append(args,*req.Name)\n      query.WriteString(\"user_name=?\")\n    }\n    if req.LastLogin!=nil {\n      if len(args)>0 {\n        query.WriteString(\",\")\n      }\n      args=append(args,*req.LastLogin)\n      query.WriteString(\"last_login=?\")\n    }\n    if req.AvatarURL!=nil {\n      if len(args)>0 {\n        query.WriteString(\",\")\n      }\n      args=append(args,*req.AvatarURL)\n      query.WriteString(\"avatar_url=?\")\n    }\n    ```", "```go\n    query.WriteString(\" WHERE user_id=?\")\n    args=append(args,userId)\n    ```", "```go\n    _,err:=db.ExecContext(ctx,query.String(),args...)\n    ```", "```go\nif req.Name != nil {\n  args=append(args,*req.Name)\n  fmt.Fprintf(&query,\"user_name=$%d\",len(args))\n}\nif req.LastLogin!=nil {\n  if len(args)>0 {\n    query.WriteString(\",\")\n  }\n  args=append(args,*req.LastLogin)\n  fmt.Fprintf(&query,\"last_login=$%d\",len(args))\n}\nif req.AvatarURL!=nil {\n  if len(args)>0 {\n    query.WriteString(\",\")\n  }\n  args=append(args,*req.AvatarURL)\n  fmt.Fprintf(&query,\"avatar_url=$%d\",len(args))\n}\n```", "```go\n    type UserSearchRequest struct {\n      Ids            []uint64\n      Name           *string\n      LoggedInBefore *time.Time\n      LoggedInAfter  *time.Time\n      AvatarURL      *string\n    }\n    ```", "```go\n    func SearchUsers(ctx context.Context, db *sql.DB, req *UserSearchRequest) ([]User,error) {\n      ...\n    }\n    ```", "```go\n    query:=strings.Builder{}\n    where:= strings.Builder{}\n    args:=make([]interface{},0)\n    // Start building the query. Be mindful of spaces to separate \n    // query clauses\n    query.WriteString(\"SELECT user_id, user_name, last_login, avatar_url FROM users \")\n    ```", "```go\n    if len(req.Ids)>0 {\n       // Add this to the WHERE clause with an AND\n       if where.Len()>0 {\n          where.WriteString(\" AND \")\n       }\n      // Build an IN clause.\n      // We have to add one argument for each id\n      where.WriteString(\"user_id IN (\")\n      for i,id:=range req.Ids {\n        if i>0 {\n          where.WriteString(\",\")\n        }\n        args=append(args,id)\n        where.WriteString(\"?\")\n      }\n      where.WriteString(\")\")\n    }\n    if req.Name!=nil {\n      if where.Len()>0 {\n        where.WriteString(\" AND \")\n      }\n      args=append(args,*req.Name)\n      where.WriteString(\"user_name=?\")\n    }\n    if req.LoggedInBefore!=nil {\n      if where.Len()>0 {\n        where.WriteString(\" AND \")\n      }\n      args=append(args,*req.LoggedInBefore)\n      where.WriteString(\"last_login<?\")\n    }\n    if req.LoggedInAfter!=nil {\n      if where.Len()>0 {\n        where.WriteString(\" AND \")\n      }\n      args=append(args,*req.LoggedInAfter)\n      where.WriteString(\"last_login>?\")\n    }\n    if req.AvatarURL!=nil {\n      if where.Len()>0 {\n        where.WriteString(\" AND \")\n      }\n      args=append(args,*req.AvatarURL)\n      where.WriteString(\"avatar_url=?\")\n    }\n    ```", "```go\n    if where.Len()>0 {\n      query.WriteString(\" WHERE \")\n      query.WriteString(where.String())\n    }\n    rows, err:= db.QueryContext(ctx,query.String(), args...)\n    ```"]