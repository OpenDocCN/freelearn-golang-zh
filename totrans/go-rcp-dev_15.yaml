- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications have to work with at least one type of database. SQL databases
    are common enough that the Go standard library offers a unified way to connect
    and use them. This chapter shows some of the patterns you can use to work with
    the standard library implementation of the SQL package.
  prefs: []
  type: TYPE_NORMAL
- en: Many databases offer nonstandard extensions, in terms of both functionality
    and query language. Even if you use the standard library to interface with a database,
    you should always check the vendor-specific database driver to understand potential
    limitations, implementation differences, and the supported SQL dialect.
  prefs: []
  type: TYPE_NORMAL
- en: Here, it might be useful to mention NoSQL databases. The Go standard library
    does not offer a NoSQL database package. This is because, unlike SQL, most NoSQL
    databases have nonstandard query languages that are purpose-built for the specific
    database. NoSQL databases built for specific workloads perform much better than
    a general-purpose SQL database. If you are using such a database, refer to its
    documentation. However, many of the concepts presented in this chapter will apply
    to some degree to NoSQL databases as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter has the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running SQL statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running SQL statements without explicit transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running SQL statements with transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running prepared statements within a transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting values from a query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically building SQL statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building `UPDATE` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building `WHERE` clauses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways you can incorporate a database into your applications: you
    can use a database server or an embedded database. Let’s start by defining what
    those are.'
  prefs: []
  type: TYPE_NORMAL
- en: A database server runs as a separate process on the same or a different host
    but is independent of your application. Usually, your application connects to
    this database server through a network connection, so you have to know its network
    address and port. There is usually a library you have to import into your program,
    a “database driver” specific to the database server you use. This driver provides
    the interface between your application and the database by managing the connections,
    queries, transactions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: An embedded database is not a separate process. It is included in your application
    as a library and runs in the same address space. A database driver acts as an
    adapter that presents a standard interface (i.e., using the `database/sql` package)
    to the application. When using an embedded database, you have to be mindful of
    the resources you share with other processes. Many embedded databases will not
    let multiple programs access the same underlying data.
  prefs: []
  type: TYPE_NORMAL
- en: Before performing any operations, you must connect to the database server (such
    as a MySQL or PostgreSQL server) or to the embedded database engine (such as SQLite).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'This page contains a list of SQL drivers: [https://go.dev/wiki/SQLDrivers](https://go.dev/wiki/SQLDrivers).'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Find the database-specific driver you need. This driver may be provided by the
    database vendor or published as an open source project. Import this database driver
    in the `main` package.
  prefs: []
  type: TYPE_NORMAL
- en: You need a driver-specific driver name and connection string to connect to the
    database server or the embedded database engine. If you are connecting to a database
    server, this connection string usually includes the host/port information, authentication
    information, and connection options. If this is an embedded database engine, it
    may include filename/directory information. Then, you either call `sql.Open` or
    use a driver-specific connection function that returns a `*sql.DB`.
  prefs: []
  type: TYPE_NORMAL
- en: A database driver may defer the actual connection to the first database operation.
    That is, connecting to a database using `sql.Open` may not actually connect immediately.
    To ensure you are connected to the database, use `DB.Ping`. An embedded database
    driver usually would not require a ping.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example showing a connection to a MySQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example showing a connection to an in-memory SQLite database
    using a local file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of blank identifier, `_`, for the database driver import. That
    means the package is imported only for its side effects, which, in this case,
    are the `init()` functions that register the database driver. For instance, importing
    the `go-sqlite3` package in `main` causes the `init()` function declared in `go-sqlite3`
    to register itself with the name `sqlite3`.
  prefs: []
  type: TYPE_NORMAL
- en: Running SQL statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After acquiring an instance of `*sql.DB`, you can run SQL statements to modify
    or query data. These queries are simply SQL strings, but the flavor of SQL varies
    between database vendors.
  prefs: []
  type: TYPE_NORMAL
- en: Running SQL statements without explicit transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When interacting with a database, an important consideration is determining
    transaction boundaries. If you need to perform a single operation, such as inserting
    a row or running a query, you usually do not need to create a transaction explicitly.
    You can execute a single SQL statement that will start and end the transaction.
    However, if you have multiple SQL statements that should either run as an atomic
    unit or not run at all, you have to use a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To run a SQL statement to update data, use `DB.Exec` or `DB.ExecContext`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To run the same statement multiple times with different values, use a prepared
    statement. A prepared statement usually sends the statement to the database server
    where it is parsed and prepared. Then, you can simply run this parsed statement
    with different arguments, bypassing the parsing and optimization stages of the
    database engine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should close the prepared statement when you are done using it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can create prepared statements after connecting to the database and use
    them in your program until the program ends. Prepared statements can be executed
    from multiple goroutines concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: To run a query that returns results, use `DB.Query` or `DB.QueryContext`. To
    run a query that is expected to return at most one row, you can use the `DB.QueryRow`
    or `DB.QueryRowContext` convenience functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `DB.Query` and `DB.QueryContext` methods return a `*sql.Rows` object that
    is essentially a uni-directional cursor over the results of a query. This provides
    an interface that allows you to process large result sets without loading all
    results to the memory. Database engines usually return the results in batches,
    and the `*sql.Rows` object allows you to go through the result rows one by one,
    fetching results in batches as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing to keep in mind is that many database engines defer the actual
    execution of the query until you start fetching the results. In other words, just
    because you ran a query, does not mean that the query is actually evaluated by
    the server. The query evaluation may happen when you fetch the first result row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If the expected result set has at most one row (in other words, you are looking
    for a specific object that may or may not be there), you can shorten the above
    pattern by using `DB.QueryRow` or `DB.QueryRowContext`. You can determine whether
    the operation found the row by checking whether the returned error is `sql.ErrNoRows`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Never use values provided by a user, read from a configuration file, or received
    from an API request to build a SQL statement without validating first. Use query
    arguments to avoid SQL injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Running SQL statements with transactions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to perform multiple updates atomically, you must execute those updates
    in a transaction. In this context, atomically means either all updates complete
    successfully or none of them complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transaction isolation level determines how other concurrent transactions
    see the updates performed within a transaction. You can find many resources that
    describe transaction isolation levels. Here, I will provide a summary to help
    you decide which isolation level is best for your use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sql.LevelReadUncommitted`: This is the lowest transaction isolation level.
    A transaction may see uncommitted changes performed by another transaction. Another
    transaction may read some uncommitted data and perform business logic based on
    what was read. and the uncommitted data may be rolled back, invalidating the business
    logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sql.ReadCommitted`: A transaction reads only committed changes performed by
    another transaction. That means if one transaction attempts to read/write data
    that is being modified by another transaction, the first transaction has to wait
    until the second transaction completes. However, once a transaction in the ReadCommitted
    isolation level reads data, another transaction may change it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sql.RepeatableRead`: A transaction reads only committed changes performed
    by another transaction. Furthermore, the value read by the transaction in the
    RepeatableRead isolation level is guaranteed to remain unchanged until the transaction
    is committed or rolled back. Any other transaction attempting to modify data read
    by a repeatable-read transaction will wait until the repeatable-read transaction
    ends. However, this isolation level does not prevent another transaction from
    inserting rows into a table that satisfy the query criteria of a repeatable-read
    transaction, so querying the same table with range queries may yield different
    results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sql.Serializable`: This is the highest transaction isolation level. A serializable
    transaction reads only committed changes, prevents other transactions from modifying
    data it reads, and prevents other transactions from inserting/updating/deleting
    rows that match the criteria of any of the queries performed within the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Level of concurrency decreases as the transaction isolation level increases.
    This also affects the performance: lower transaction isolation levels are faster.
    You have to select the isolation level carefully: choose the lowest isolation
    level that is safe for the operation. Usually, there is a driver-specific default
    isolation level that will be used if you do not specify a level explicitly.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Start a transaction with the desired isolation level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the transaction either commits or rolls back. You can do this by deferring
    `tx.Rollback`. This causes the transaction to roll back if the function returns
    without committing it. If the transaction is successful, you commit the transaction.
    Once a transaction is committed, the deferred rollback does not have any effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform database operations using the transaction. All database operations
    performed using the methods of `*sql.Tx` will be done within the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are no errors, commit the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Some database drivers may roll back and cancel a transaction when a query cannot
    complete due to a constraint violation, such as a duplicate value on a unique
    index. Check your driver documentation to see whether it performs an auto-rollback.
  prefs: []
  type: TYPE_NORMAL
- en: Running prepared statements within a transaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A statement can be prepared by calling the `*sql.Tx.Prepare` or `*sql.Tx.PrepareContext`
    method of the transaction struct. The prepared statement returned by these two
    will be associated with that transaction only. That is, you cannot prepare a statement
    using one transaction and use that statement for another transaction.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways you can use prepared statements in a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is using a statement prepared by `*DB`:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare the statement using `DB.Prepare` or `DB.PrepareContext`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get a transaction-specific copy of the transaction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the operations using the new statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second is using a statement prepared by `*Tx`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the statement using `Tx.Prepare` or `Tx.PrepareContext`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the operations using this statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting values from a query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A SQL query returns `*sql.Rows`, or if you use the `QueryRow` methods, it returns
    `*sql.Row`. The next thing you have to do is iterate over the rows and scan the
    values into Go variables.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Running `Query` or `QueryContext` implies you are expecting zero or more rows
    from the query. Because of that, it returns `*sql.Rows`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the code snippets in this section, we use the following `User` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is used with the following table definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate through the rows and work with each individual result row. In the following
    example, the query returns zero or more rows. The first call to `rows.Next` moves
    to the first row in the result set, and each subsequent call to `rows.Next` moves
    to the next row. This allows for the use of a `for` statement, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For each row, use `Scan` to copy data into Go variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The order of arguments to `Scan` must match the order of columns retrieved from
    the `SELECT` statement. That is, the first argument, `&user.ID`, corresponds to
    the `user_id` column; the next argument, `&user.Name`, corresponds to the `user_name`
    column; and so on. The number of arguments to `Scan` thus must be equal to the
    number of columns fetched.
  prefs: []
  type: TYPE_NORMAL
- en: The SQL driver performs the translation from database-native types to Go data
    types. If the translation results in data or precision loss, the driver usually
    returns an error. For instance, if you try to scan a large integer value into
    an `int16` variable and the translation cannot represent the value, `Scan` returns
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: If the database column is defined as nullable (in this example, `avatar_url
    varchar(128) NULL`), and if the data value retrieved from the database is null,
    then the Go value must be able to accommodate the null value. For instance, if
    we used `&user.AvatarURL` in `Scan` and the value in the database was null, then
    `Scan` would have returned an error complaining that a null value cannot be scanned
    to a string. To prevent such errors, we used `*string` instead of `string`. In
    general, if the underlying database column is nullable, you should use a pointer
    in `Scan` for that column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check for errors after fetching all rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Close `*sql.Rows`. This is usually done with a `defer rows.Close()` statement
    as previously.
  prefs: []
  type: TYPE_NORMAL
- en: Running `QueryRow` or `QueryRowContext` implies you are expecting zero or one
    row from the query. Then, return a `*sql.Row` object that you can use to scan
    values and check for errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `QueryRow` or `QueryRowContext`, and scan the values as described previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If there is an error during query execution, it will be returned by the row.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically building SQL statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In any nontrivial application using a SQL database, you will have to build
    SQL statements dynamically. This becomes necessary for cases such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using flexible search criteria that may change based on user input or requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally joining multiple tables based on requested fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selectively updating a subset of columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a variable number of columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section shows several common methods to build SQL statements for different
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: There are many open source query builder packages. You might want to explore
    those packages before writing your own.
  prefs: []
  type: TYPE_NORMAL
- en: Building UPDATE statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need to update a given number of columns of a table without modifying
    others, you can follow the pattern given in this section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need two pieces of information to run an UPDATE statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The data to update**: A common way of describing such information is to use
    pointers to represent updated values. Consider the following example:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, a column will only be updated if the corresponding field is not null.
    For instance, with the following instance of `UpdateUserRequest`, only the `LastLogin`
    and `AvatarURL` fields will be updated:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**The record locator**: This is usually the unique identifier of the row that
    needs to be updated. However, it is also common to use a query that will locate
    multiple records.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this information, a common way to write an update function is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, the record locator is `userId`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `strings.Builder` to build the statement while keeping track of the query
    arguments in a slice:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `SET` clause for each column that needs to be updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `WHERE` clause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Not all database drivers use `?` for query arguments. For example, one of the
    Postgres drivers uses `$n`, where `n` is a number starting from 1 giving the order
    of the argument. The algorithm is a bit different for such drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Building WHERE clauses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `WHERE` clause can be a part of a `SELECT`, `UPDATE`, or `DELETE` statement.
    Here, I will show a `SELECT` example, and you can extend this to apply to `UPDATE`
    and `DELETE`. Be careful with the arguments as an `UPDATE` statement will include
    arguments for update column values as well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example shows the case where AND is used in the search criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need a data structure that gives which columns to include in the `WHERE`
    clause. Take the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this structure, the search function looks as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `strings.Builder` to build the statement parts while keeping track of the
    query arguments in a slice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build a predicate for each search item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build and run the query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, not all database drivers use the `?` marker. See the previous section
    for an alternative if your database driver is one of those.
  prefs: []
  type: TYPE_NORMAL
