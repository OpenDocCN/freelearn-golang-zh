- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Databases
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库
- en: Most applications have to work with at least one type of database. SQL databases
    are common enough that the Go standard library offers a unified way to connect
    and use them. This chapter shows some of the patterns you can use to work with
    the standard library implementation of the SQL package.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序至少需要与一种类型的数据库进行交互。SQL 数据库足够常见，以至于 Go 标准库提供了一个统一的方式来连接和使用它们。本章展示了你可以使用的某些模式，以与
    SQL 包的标准库实现一起工作。
- en: Many databases offer nonstandard extensions, in terms of both functionality
    and query language. Even if you use the standard library to interface with a database,
    you should always check the vendor-specific database driver to understand potential
    limitations, implementation differences, and the supported SQL dialect.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据库在功能和查询语言方面都提供了非标准扩展。即使你使用标准库与数据库接口，你也应该始终检查特定供应商的数据库驱动程序，以了解潜在的限制、实现差异和支持的
    SQL 语法。
- en: Here, it might be useful to mention NoSQL databases. The Go standard library
    does not offer a NoSQL database package. This is because, unlike SQL, most NoSQL
    databases have nonstandard query languages that are purpose-built for the specific
    database. NoSQL databases built for specific workloads perform much better than
    a general-purpose SQL database. If you are using such a database, refer to its
    documentation. However, many of the concepts presented in this chapter will apply
    to some degree to NoSQL databases as well.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，提到 NoSQL 数据库可能会有所帮助。Go 标准库不提供 NoSQL 数据库包。这是因为，与 SQL 不同，大多数 NoSQL 数据库都有非标准的查询语言，这些语言是为特定数据库专门定制的。为特定工作负载构建的
    NoSQL 数据库比通用 SQL 数据库表现要好得多。如果你正在使用此类数据库，请参阅其文档。然而，本章中提出的许多概念在一定程度上也适用于 NoSQL 数据库。
- en: 'This chapter has the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下食谱：
- en: Connecting to a database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: Running SQL statements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 SQL 语句
- en: Running SQL statements without explicit transactions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用显式事务执行 SQL 语句
- en: Running SQL statements with transactions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事务执行 SQL 语句
- en: Running prepared statements within a transaction
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事务中执行预定义语句
- en: Getting values from a query
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从查询中获取值
- en: Dynamically building SQL statements
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态构建 SQL 语句
- en: Building `UPDATE` statements
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 `UPDATE` 语句
- en: Building `WHERE` clauses
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 `WHERE` 子句
- en: Connecting to a database
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'There are two ways you can incorporate a database into your applications: you
    can use a database server or an embedded database. Let’s start by defining what
    those are.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将数据库集成到你的应用程序中的两种方式：你可以使用数据库服务器或嵌入式数据库。让我们首先定义一下它们是什么。
- en: A database server runs as a separate process on the same or a different host
    but is independent of your application. Usually, your application connects to
    this database server through a network connection, so you have to know its network
    address and port. There is usually a library you have to import into your program,
    a “database driver” specific to the database server you use. This driver provides
    the interface between your application and the database by managing the connections,
    queries, transactions, and so on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库服务器作为一个独立进程在同一主机或不同主机上运行，但与你的应用程序无关。通常，你的应用程序通过网络连接连接到这个数据库服务器，因此你必须知道它的网络地址和端口号。通常有一个库需要导入到你的程序中，这是一个针对你使用的数据库服务器的“数据库驱动程序”。这个驱动程序通过管理连接、查询、事务等，为你的应用程序和数据库提供接口。
- en: An embedded database is not a separate process. It is included in your application
    as a library and runs in the same address space. A database driver acts as an
    adapter that presents a standard interface (i.e., using the `database/sql` package)
    to the application. When using an embedded database, you have to be mindful of
    the resources you share with other processes. Many embedded databases will not
    let multiple programs access the same underlying data.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入式数据库不是一个独立的进程。它作为库包含在你的应用程序中，并在相同的地址空间中运行。数据库驱动程序充当适配器，向应用程序提供一个标准接口（即使用 `database/sql`
    包）。当使用嵌入式数据库时，你必须注意与其他进程共享的资源。许多嵌入式数据库不允许多个程序访问相同的基本数据。
- en: Before performing any operations, you must connect to the database server (such
    as a MySQL or PostgreSQL server) or to the embedded database engine (such as SQLite).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行任何操作之前，你必须连接到数据库服务器（如 MySQL 或 PostgreSQL 服务器）或嵌入式数据库引擎（如 SQLite）。
- en: Tip
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'This page contains a list of SQL drivers: [https://go.dev/wiki/SQLDrivers](https://go.dev/wiki/SQLDrivers).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面包含 SQL 驱动程序的列表：[https://go.dev/wiki/SQLDrivers](https://go.dev/wiki/SQLDrivers)。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Find the database-specific driver you need. This driver may be provided by the
    database vendor or published as an open source project. Import this database driver
    in the `main` package.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 找到你需要的数据库特定驱动程序。这个驱动程序可能由数据库供应商提供，或者作为一个开源项目发布。在`main`包中导入这个数据库驱动程序。
- en: You need a driver-specific driver name and connection string to connect to the
    database server or the embedded database engine. If you are connecting to a database
    server, this connection string usually includes the host/port information, authentication
    information, and connection options. If this is an embedded database engine, it
    may include filename/directory information. Then, you either call `sql.Open` or
    use a driver-specific connection function that returns a `*sql.DB`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个特定于驱动程序的驱动程序名称和连接字符串来连接到数据库服务器或嵌入式数据库引擎。如果你正在连接到数据库服务器，这个连接字符串通常包括主机/端口信息、认证信息和连接选项。如果是嵌入式数据库引擎，它可能包括文件名/目录信息。然后，你可以调用`sql.Open`或使用特定于驱动程序的连接函数，该函数返回一个`*sql.DB`。
- en: A database driver may defer the actual connection to the first database operation.
    That is, connecting to a database using `sql.Open` may not actually connect immediately.
    To ensure you are connected to the database, use `DB.Ping`. An embedded database
    driver usually would not require a ping.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库驱动程序可能会延迟实际连接到第一次数据库操作。也就是说，使用`sql.Open`连接到数据库可能不会立即连接。为确保你已连接到数据库，请使用`DB.Ping`。嵌入式数据库驱动程序通常不需要ping。
- en: 'The following is an example showing a connection to a MySQL database:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个连接到MySQL数据库的示例：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following is an example showing a connection to an in-memory SQLite database
    using a local file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用本地文件连接到内存中SQLite数据库的示例：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note the use of blank identifier, `_`, for the database driver import. That
    means the package is imported only for its side effects, which, in this case,
    are the `init()` functions that register the database driver. For instance, importing
    the `go-sqlite3` package in `main` causes the `init()` function declared in `go-sqlite3`
    to register itself with the name `sqlite3`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用空白标识符`_`来导入数据库驱动程序。这意味着包仅为了其副作用而导入，在这种情况下，是注册数据库驱动的`init()`函数。例如，在`main`包中导入`go-sqlite3`包会导致在`go-sqlite3`中声明的`init()`函数使用名称`sqlite3`注册自己。
- en: Running SQL statements
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行SQL语句
- en: After acquiring an instance of `*sql.DB`, you can run SQL statements to modify
    or query data. These queries are simply SQL strings, but the flavor of SQL varies
    between database vendors.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取`*sql.DB`实例后，你可以运行SQL语句来修改或查询数据。这些查询只是SQL字符串，但SQL的样式在不同的数据库供应商之间有所不同。
- en: Running SQL statements without explicit transactions
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不使用显式事务运行SQL语句
- en: When interacting with a database, an important consideration is determining
    transaction boundaries. If you need to perform a single operation, such as inserting
    a row or running a query, you usually do not need to create a transaction explicitly.
    You can execute a single SQL statement that will start and end the transaction.
    However, if you have multiple SQL statements that should either run as an atomic
    unit or not run at all, you have to use a transaction.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当与数据库交互时，一个重要的考虑因素是确定事务边界。如果你需要执行单个操作，例如插入一行或运行一个查询，你通常不需要显式创建事务。你可以执行一个将开始和结束事务的单个SQL语句。然而，如果你有多个SQL语句，这些语句应该作为一个原子单元运行或者根本不运行，你必须使用事务。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To run a SQL statement to update data, use `DB.Exec` or `DB.ExecContext`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行SQL语句更新数据，请使用`DB.Exec`或`DB.ExecContext`：
- en: '[PRE2]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To run the same statement multiple times with different values, use a prepared
    statement. A prepared statement usually sends the statement to the database server
    where it is parsed and prepared. Then, you can simply run this parsed statement
    with different arguments, bypassing the parsing and optimization stages of the
    database engine.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要多次运行相同的语句但使用不同的值，请使用预编译语句。预编译语句通常将语句发送到数据库服务器，在那里它被解析和准备。然后，你可以简单地使用不同的参数运行这个解析后的语句，绕过数据库引擎的解析和优化阶段。
- en: 'You should close the prepared statement when you are done using it:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你完成使用预编译语句时，你应该关闭它：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can create prepared statements after connecting to the database and use
    them in your program until the program ends. Prepared statements can be executed
    from multiple goroutines concurrently.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接到数据库后，你可以创建预编译语句并在程序结束时使用它们。预编译语句可以从多个goroutines并发执行。
- en: To run a query that returns results, use `DB.Query` or `DB.QueryContext`. To
    run a query that is expected to return at most one row, you can use the `DB.QueryRow`
    or `DB.QueryRowContext` convenience functions.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行返回结果的查询，请使用`DB.Query`或`DB.QueryContext`。要运行预期最多返回一行的查询，你可以使用`DB.QueryRow`或`DB.QueryRowContext`便利函数。
- en: The `DB.Query` and `DB.QueryContext` methods return a `*sql.Rows` object that
    is essentially a uni-directional cursor over the results of a query. This provides
    an interface that allows you to process large result sets without loading all
    results to the memory. Database engines usually return the results in batches,
    and the `*sql.Rows` object allows you to go through the result rows one by one,
    fetching results in batches as necessary.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`DB.Query`和`DB.QueryContext`方法返回一个`*sql.Rows`对象，它本质上是对查询结果的单向游标。这提供了一个接口，允许你在不将所有结果加载到内存的情况下处理大型结果集。数据库引擎通常分批返回结果，而`*sql.Rows`对象允许你逐行遍历结果行，按需批量获取结果。'
- en: 'Another thing to keep in mind is that many database engines defer the actual
    execution of the query until you start fetching the results. In other words, just
    because you ran a query, does not mean that the query is actually evaluated by
    the server. The query evaluation may happen when you fetch the first result row:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要记住的是，许多数据库引擎会延迟查询的实际执行，直到你开始获取结果。换句话说，仅仅因为你运行了一个查询，并不意味着该查询实际上被服务器评估。查询评估可能发生在你获取第一行结果时：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If the expected result set has at most one row (in other words, you are looking
    for a specific object that may or may not be there), you can shorten the above
    pattern by using `DB.QueryRow` or `DB.QueryRowContext`. You can determine whether
    the operation found the row by checking whether the returned error is `sql.ErrNoRows`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预期的结果集最多只有一行（换句话说，你正在寻找一个可能存在也可能不存在的特定对象），你可以通过使用`DB.QueryRow`或`DB.QueryRowContext`来缩短上述模式。你可以通过检查返回的错误是否为`sql.ErrNoRows`来确定操作是否找到了该行：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Never use values provided by a user, read from a configuration file, or received
    from an API request to build a SQL statement without validating first. Use query
    arguments to avoid SQL injection attacks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要在未经验证的情况下使用用户提供的值、从配置文件中读取的值或从API请求中接收的值来构建SQL语句。使用查询参数来避免SQL注入攻击。
- en: Running SQL statements with transactions
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事务运行SQL语句
- en: If you need to perform multiple updates atomically, you must execute those updates
    in a transaction. In this context, atomically means either all updates complete
    successfully or none of them complete.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要原子性地执行多个更新，你必须在一个事务中执行这些更新。在这种情况下，原子性意味着要么所有更新都成功完成，要么没有任何一个更新完成。
- en: 'The transaction isolation level determines how other concurrent transactions
    see the updates performed within a transaction. You can find many resources that
    describe transaction isolation levels. Here, I will provide a summary to help
    you decide which isolation level is best for your use case:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 事务隔离级别决定了其他并发事务如何看到事务内执行的更新。你可以找到许多描述事务隔离级别的资源。在这里，我将提供一个总结，帮助你决定哪种隔离级别最适合你的用例：
- en: '`sql.LevelReadUncommitted`: This is the lowest transaction isolation level.
    A transaction may see uncommitted changes performed by another transaction. Another
    transaction may read some uncommitted data and perform business logic based on
    what was read. and the uncommitted data may be rolled back, invalidating the business
    logic.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql.LevelReadUncommitted`：这是最低的事务隔离级别。一个事务可能看到另一个事务执行的未提交更改。另一个事务可能读取一些未提交的数据，并基于读取的内容执行业务逻辑。而这些未提交的数据可能会回滚，从而使业务逻辑无效。'
- en: '`sql.ReadCommitted`: A transaction reads only committed changes performed by
    another transaction. That means if one transaction attempts to read/write data
    that is being modified by another transaction, the first transaction has to wait
    until the second transaction completes. However, once a transaction in the ReadCommitted
    isolation level reads data, another transaction may change it.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql.ReadCommitted`：一个事务只读取另一个事务执行的已提交更改。这意味着如果一个事务试图读取/写入另一个事务正在修改的数据，第一个事务必须等待第二个事务完成。然而，一旦一个事务在ReadCommitted隔离级别读取了数据，另一个事务可能改变它。'
- en: '`sql.RepeatableRead`: A transaction reads only committed changes performed
    by another transaction. Furthermore, the value read by the transaction in the
    RepeatableRead isolation level is guaranteed to remain unchanged until the transaction
    is committed or rolled back. Any other transaction attempting to modify data read
    by a repeatable-read transaction will wait until the repeatable-read transaction
    ends. However, this isolation level does not prevent another transaction from
    inserting rows into a table that satisfy the query criteria of a repeatable-read
    transaction, so querying the same table with range queries may yield different
    results.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql.RepeatableRead`：事务只读取另一个事务执行的已提交更改。此外，在可重复读隔离级别下，事务读取的值保证在事务提交或回滚之前保持不变。任何尝试修改可重复读事务读取的数据的其他事务都将等待直到可重复读事务结束。然而，此隔离级别不能防止其他事务向表中插入满足可重复读事务查询准则的行，因此使用范围查询查询同一表可能会得到不同的结果。'
- en: '`sql.Serializable`: This is the highest transaction isolation level. A serializable
    transaction reads only committed changes, prevents other transactions from modifying
    data it reads, and prevents other transactions from inserting/updating/deleting
    rows that match the criteria of any of the queries performed within the transaction.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql.Serializable`：这是最高的事务隔离级别。可序列化事务只读取已提交的更改，防止其他事务修改它所读取的数据，并防止其他事务插入/更新/删除与事务内执行的任何查询的准则相匹配的行。'
- en: 'Level of concurrency decreases as the transaction isolation level increases.
    This also affects the performance: lower transaction isolation levels are faster.
    You have to select the isolation level carefully: choose the lowest isolation
    level that is safe for the operation. Usually, there is a driver-specific default
    isolation level that will be used if you do not specify a level explicitly.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 随着事务隔离级别的提高，并发级别会降低。这也影响性能：较低的隔离级别更快。你必须仔细选择隔离级别：选择对操作安全的最低隔离级别。通常，如果你没有明确指定级别，将使用特定于驱动程序的默认隔离级别。
- en: How to do it...
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Start a transaction with the desired isolation level:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用期望的隔离级别启动事务：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Make sure the transaction either commits or rolls back. You can do this by deferring
    `tx.Rollback`. This causes the transaction to roll back if the function returns
    without committing it. If the transaction is successful, you commit the transaction.
    Once a transaction is committed, the deferred rollback does not have any effect.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 确保事务要么提交要么回滚。你可以通过延迟调用`tx.Rollback`来实现这一点。如果在函数返回之前没有提交事务，这将导致事务回滚。如果事务成功，你将提交事务。一旦事务被提交，延迟回滚将不会有任何效果。
- en: 'Perform database operations using the transaction. All database operations
    performed using the methods of `*sql.Tx` will be done within the transaction:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事务执行数据库操作。所有使用`*sql.Tx`方法执行的数据库操作都将在该事务内完成：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If there are no errors, commit the transaction:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，提交事务：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Some database drivers may roll back and cancel a transaction when a query cannot
    complete due to a constraint violation, such as a duplicate value on a unique
    index. Check your driver documentation to see whether it performs an auto-rollback.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据库驱动程序可能在由于约束违反（如唯一索引上的重复值）而无法完成查询时回滚并取消事务。请检查你的驱动程序文档，以查看它是否执行自动回滚。
- en: Running prepared statements within a transaction
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在事务内运行准备好的语句
- en: A statement can be prepared by calling the `*sql.Tx.Prepare` or `*sql.Tx.PrepareContext`
    method of the transaction struct. The prepared statement returned by these two
    will be associated with that transaction only. That is, you cannot prepare a statement
    using one transaction and use that statement for another transaction.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用事务结构体的`*sql.Tx.Prepare`或`*sql.Tx.PrepareContext`方法来准备一个语句。这两个方法返回的准备语句仅与该事务相关联。也就是说，你不能使用一个事务准备一个语句，然后用于另一个事务。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: There are two ways you can use prepared statements in a transaction.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两种方法可以在事务中使用准备好的语句。
- en: 'The first is using a statement prepared by `*DB`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是使用由`*DB`准备的语句：
- en: Prepare the statement using `DB.Prepare` or `DB.PrepareContext`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`DB.Prepare`或`DB.PrepareContext`准备语句。
- en: 'Get a transaction-specific copy of the transaction:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取特定于事务的事务副本：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run the operations using the new statement.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新语句运行操作。
- en: 'The second is using a statement prepared by `*Tx`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二种方法是使用由`*Tx`准备的语句：
- en: Prepare the statement using `Tx.Prepare` or `Tx.PrepareContext`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Tx.Prepare` 或 `Tx.PrepareContext` 准备语句。
- en: Run the operations using this statement.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此语句运行操作。
- en: Getting values from a query
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从查询中获取值
- en: A SQL query returns `*sql.Rows`, or if you use the `QueryRow` methods, it returns
    `*sql.Row`. The next thing you have to do is iterate over the rows and scan the
    values into Go variables.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 查询返回 `*sql.Rows`，或者如果你使用 `QueryRow` 方法，它返回 `*sql.Row`。接下来你必须做的事情是遍历行并将值扫描到
    Go 变量中。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Running `Query` or `QueryContext` implies you are expecting zero or more rows
    from the query. Because of that, it returns `*sql.Rows`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `Query` 或 `QueryContext` 意味着你期望从查询中获取零行或多行。因此，它返回 `*sql.Rows`。
- en: 'For the code snippets in this section, we use the following `User` struct:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节中的代码片段，我们使用以下 `User` 结构体：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is used with the following table definition:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下表定义一起使用：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Iterate through the rows and work with each individual result row. In the following
    example, the query returns zero or more rows. The first call to `rows.Next` moves
    to the first row in the result set, and each subsequent call to `rows.Next` moves
    to the next row. This allows for the use of a `for` statement, as in the following
    example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历行并处理每个单独的结果行。在以下示例中，查询返回零行或多行。对 `rows.Next` 的第一次调用将移动到结果集的第一行，对 `rows.Next`
    的后续调用将移动到下一行。这允许使用 `for` 语句，如下面的示例所示：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For each row, use `Scan` to copy data into Go variables:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一行，使用 `Scan` 将数据复制到 Go 变量中：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The order of arguments to `Scan` must match the order of columns retrieved from
    the `SELECT` statement. That is, the first argument, `&user.ID`, corresponds to
    the `user_id` column; the next argument, `&user.Name`, corresponds to the `user_name`
    column; and so on. The number of arguments to `Scan` thus must be equal to the
    number of columns fetched.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scan` 的参数顺序必须与从 `SELECT` 语句检索到的列的顺序相匹配。也就是说，第一个参数 `&user.ID` 对应于 `user_id`
    列；下一个参数 `&user.Name` 对应于 `user_name` 列；依此类推。因此，`Scan` 的参数数量必须等于检索到的列数。'
- en: The SQL driver performs the translation from database-native types to Go data
    types. If the translation results in data or precision loss, the driver usually
    returns an error. For instance, if you try to scan a large integer value into
    an `int16` variable and the translation cannot represent the value, `Scan` returns
    an error.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 驱动程序将数据库原生类型转换为 Go 数据类型。如果转换导致数据或精度丢失，驱动程序通常会返回一个错误。例如，如果你尝试将大整数值扫描到 `int16`
    变量中，并且转换无法表示该值，`Scan` 将返回一个错误。
- en: If the database column is defined as nullable (in this example, `avatar_url
    varchar(128) NULL`), and if the data value retrieved from the database is null,
    then the Go value must be able to accommodate the null value. For instance, if
    we used `&user.AvatarURL` in `Scan` and the value in the database was null, then
    `Scan` would have returned an error complaining that a null value cannot be scanned
    to a string. To prevent such errors, we used `*string` instead of `string`. In
    general, if the underlying database column is nullable, you should use a pointer
    in `Scan` for that column.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库列定义为可空（在这个例子中，`avatar_url varchar(128) NULL`），并且如果从数据库检索到的数据值为空，那么 Go 值必须能够容纳空值。例如，如果我们使用
    `&user.AvatarURL` 在 `Scan` 中，并且数据库中的值是空，那么 `Scan` 将返回一个错误，抱怨空值不能扫描到字符串。为了防止此类错误，我们使用了
    `*string` 而不是 `string`。一般来说，如果底层数据库列是可空的，你应该在 `Scan` 中为该列使用指针。
- en: 'Check for errors after fetching all rows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取所有行后检查错误：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Close `*sql.Rows`. This is usually done with a `defer rows.Close()` statement
    as previously.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭 `*sql.Rows`。这通常通过之前的 `defer rows.Close()` 语句来完成。
- en: Running `QueryRow` or `QueryRowContext` implies you are expecting zero or one
    row from the query. Then, return a `*sql.Row` object that you can use to scan
    values and check for errors.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `QueryRow` 或 `QueryRowContext` 意味着你期望从查询中获取零行或一行。然后，返回一个 `*sql.Row` 对象，你可以使用它来扫描值并检查错误。
- en: 'Run `QueryRow` or `QueryRowContext`, and scan the values as described previously:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `QueryRow` 或 `QueryRowContext`，并按前面描述的方式扫描值：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If there is an error during query execution, it will be returned by the row.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查询执行期间发生错误，它将通过行返回。
- en: Dynamically building SQL statements
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态构建 SQL 语句
- en: 'In any nontrivial application using a SQL database, you will have to build
    SQL statements dynamically. This becomes necessary for cases such as the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何使用 SQL 数据库的非平凡应用程序中，你将不得不动态构建 SQL 语句。这在以下情况下变得必要：
- en: Using flexible search criteria that may change based on user input or requests
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用灵活的搜索条件，这些条件可能根据用户输入或请求而变化
- en: Optionally joining multiple tables based on requested fields
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据请求的字段可选地连接多个表
- en: Selectively updating a subset of columns
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择性地更新列子集
- en: Inserting a variable number of columns
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入可变数量的列
- en: This section shows several common methods to build SQL statements for different
    use cases.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了构建SQL语句的几种常见方法，适用于不同的用例。
- en: Tip
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: There are many open source query builder packages. You might want to explore
    those packages before writing your own.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多开源查询构建器包。在编写自己的包之前，您可能想要探索这些包。
- en: Building UPDATE statements
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建UPDATE语句
- en: If you need to update a given number of columns of a table without modifying
    others, you can follow the pattern given in this section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更新表中的一定数量的列而不修改其他列，您可以遵循本节中给出的模式。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You need two pieces of information to run an UPDATE statement:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行UPDATE语句需要两份数据：
- en: '**The data to update**: A common way of describing such information is to use
    pointers to represent updated values. Consider the following example:'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**要更新的数据**：描述此类信息的一种常见方式是使用指针来表示更新的值。考虑以下示例：'
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, a column will only be updated if the corresponding field is not null.
    For instance, with the following instance of `UpdateUserRequest`, only the `LastLogin`
    and `AvatarURL` fields will be updated:'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，只有当相应的字段不为空时，列才会被更新。例如，在以下`UpdateUserRequest`实例中，只有`LastLogin`和`AvatarURL`字段将被更新：
- en: '[PRE17]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**The record locator**: This is usually the unique identifier of the row that
    needs to be updated. However, it is also common to use a query that will locate
    multiple records.'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录定位器**：这通常是需要更新的行的唯一标识符。然而，也常见使用一个查询来定位多个记录。'
- en: 'With this information, a common way to write an update function is as follows:'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据这些信息，编写更新函数的常见方式如下：
- en: '[PRE18]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code, the record locator is `userId`.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，记录定位器是`userId`。
- en: 'Use `strings.Builder` to build the statement while keeping track of the query
    arguments in a slice:'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`strings.Builder`构建语句，同时在一个切片中跟踪查询参数：
- en: '[PRE19]'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a `SET` clause for each column that needs to be updated:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个需要更新的列创建一个`SET`子句：
- en: '[PRE20]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the `WHERE` clause:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`WHERE`子句：
- en: '[PRE21]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run the statement:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行该语句：
- en: '[PRE22]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Not all database drivers use `?` for query arguments. For example, one of the
    Postgres drivers uses `$n`, where `n` is a number starting from 1 giving the order
    of the argument. The algorithm is a bit different for such drivers:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有数据库驱动程序都使用`?`作为查询参数。例如，Postgres的一个驱动程序使用`$n`，其中`n`是从1开始的数字，表示参数的顺序。对于此类驱动程序，算法略有不同：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Building WHERE clauses
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建WHERE子句
- en: A `WHERE` clause can be a part of a `SELECT`, `UPDATE`, or `DELETE` statement.
    Here, I will show a `SELECT` example, and you can extend this to apply to `UPDATE`
    and `DELETE`. Be careful with the arguments as an `UPDATE` statement will include
    arguments for update column values as well.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE`子句可以是`SELECT`、`UPDATE`或`DELETE`语句的一部分。在这里，我将展示一个`SELECT`示例，您可以将此扩展到`UPDATE`和`DELETE`。请注意，`UPDATE`语句将包括更新列值的参数。'
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This example shows the case where AND is used in the search criteria:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例显示了在搜索条件中使用AND的情况：
- en: 'You need a data structure that gives which columns to include in the `WHERE`
    clause. Take the following example:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要一个数据结构，以确定在`WHERE`子句中包含哪些列。以下是一个示例：
- en: '[PRE24]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With this structure, the search function looks as follows:'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用此结构，搜索函数如下所示：
- en: '[PRE25]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use `strings.Builder` to build the statement parts while keeping track of the
    query arguments in a slice:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`strings.Builder`构建语句部分，同时在一个切片中跟踪查询参数：
- en: '[PRE26]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Build a predicate for each search item:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个搜索项构建谓词：
- en: '[PRE27]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Build and run the query:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行查询：
- en: '[PRE28]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Again, not all database drivers use the `?` marker. See the previous section
    for an alternative if your database driver is one of those.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，并非所有数据库驱动程序都使用`?`占位符。如果您的数据库驱动程序是这些之一，请参阅上一节以获取替代方案。
