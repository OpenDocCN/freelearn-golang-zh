<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer031">
			<h1 id="_idParaDest-409" class="chapter-number"><a id="_idTextAnchor410"/>16</h1>
			<h1 id="_idParaDest-410"><a id="_idTextAnchor411"/>Logging</h1>
			<p>Printing log messages from a program can be an important tool for troubleshooting. Log messages tell you what is going on at any given moment, and provide much-needed contextual information when something goes wrong. Go standard library provides convenient packages to generate and manage log messages from programs. Here, we will look at using the <strong class="source-inline">log</strong> package, which can be used to generate text messages, and the <strong class="source-inline">slog</strong> package, which can be used to generate structured log messages <span class="No-Break">from programs.</span></p>
			<p>This chapter contains the <span class="No-Break">following recipes:</span></p>
			<ul>
				<li>Using the <span class="No-Break">standard logger</span><ul><li>Writing <span class="No-Break">log messages</span></li><li><span class="No-Break">Controlling format</span></li><li>Changing where <span class="No-Break">to log</span></li></ul></li>
				<li>Using the <span class="No-Break">structured logger</span><ul><li>Logging using the <span class="No-Break">global logger</span></li><li>Writing structured logs using <span class="No-Break">different levels</span></li><li>Changing log level <span class="No-Break">at runtime</span></li><li>Using loggers with <span class="No-Break">additional attributes</span></li><li>Changing where <span class="No-Break">to log</span></li><li>Adding logging information from <span class="No-Break">the context</span></li></ul></li>
			</ul>
			<h1 id="_idParaDest-411"><a id="_idTextAnchor412"/>Using the standard logger</h1>
			<p>The standard library <a id="_idIndexMarker672"/>logger is defined in the <strong class="source-inline">log</strong> package. It is a simple logging library that can be used to print formatted log messages that show the progression of a program. For most practical purposes, the standard library logger functionality is too limited, but it can be a useful tool that requires minimal setup for proof-of-concepts and smaller programs. Use the structured logger <strong class="source-inline">log/slog</strong> package for any <span class="No-Break">nontrivial project.</span></p>
			<h2 id="_idParaDest-412"><a id="_idTextAnchor413"/>Writing log messages</h2>
			<p>The standard logger is<a id="_idIndexMarker673"/> a simple logging implementation to print diagnostic messages. It does not offer structured output or multiple log levels but can be useful for programs where log messages are geared toward the end users <span class="No-Break">or developers.</span></p>
			<h3>How to do it...</h3>
			<p>You can use the default logger to print <span class="No-Break">log messages:</span></p>
			<pre class="source-code">
log.Println("This is a log message similar to fmt.Println")
log.Printf("This is a log message similar to fmt.Printf")</pre>			<p>Here is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
2024/09/17 23:05:26 This is a log message similar to fmt.Println
2024/09/17 23:05:26 This is a log message similar to fmt.Printf</pre>			<p>The above functions use a singleton instance of <strong class="source-inline">log.Logger</strong>, which can be obtained by <strong class="source-inline">log.Default()</strong>. In other words, calling <strong class="source-inline">log.Println</strong> is equivalent to <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">log.Default().Println</strong></span><span class="No-Break">.</span></p>
			<p>You can also create a new logger, configure it, and pass <span class="No-Break">it around:</span></p>
			<pre class="source-code">
logger := log.New(os.Stderr, "", log.LstdFlags)
logger.Println("This is a log message written to stderr")</pre>			<p>Here is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
2024/09/17 23:10:34 This is a log message written to stderr</pre>			<p>Other than <strong class="source-inline">log.Println</strong> and <strong class="source-inline">log.Printf</strong>, you can use <strong class="source-inline">log.Fatal</strong> or <strong class="source-inline">log.Panic</strong> to stop <span class="No-Break">a program:</span></p>
			<pre class="source-code">
log.Fatal("Fatal error")</pre>			<p>This will terminate the program with exit code <strong class="source-inline">1</strong> and output <span class="No-Break">the following:</span></p>
			<pre class="source-code">
2024/09/17 23:05:26 Fatal error</pre>			<p>We can observe something similar with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
log.Panic("Fatal error")</pre>			<p>This will panic and <a id="_idIndexMarker674"/>generate the output <span class="No-Break">that follows:</span></p>
			<pre class="source-code">
2024/09/17 23:05:26 Fatal error
panic: Fatal error
goroutine 1 [running]:
log.Panic({0xc000104f30?, 0xc00007c060?, 0x556310?})
    /usr/local/go-faketime/src/log/log.go:432 +0x5a
main.main()
    /tmp/sandbox255937470/prog.go:8 +0x38</pre>			<h2 id="_idParaDest-413"><a id="_idTextAnchor414"/>Controlling format</h2>
			<p>You can control the<a id="_idIndexMarker675"/> output format of the logger using bit flags. You can also define a prefix for the subsequent <span class="No-Break">log messages.</span></p>
			<h3>How to do it...</h3>
			<p>You can create a new logger with a prefix <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
logger := log.New(log.Writer(), "prefix: ", log.LstdFlags)
logger.Println("This is a log message with a prefix")</pre>			<p>This outputs <span class="No-Break">the following:</span></p>
			<pre class="source-code">
prefix: 2024/09/17 23:10:34 This is a log message with a prefix</pre>			<p>You can also set the prefix of an <span class="No-Break">existing logger:</span></p>
			<pre class="source-code">
logger.SetPrefix("newPrefix")
logger.Println("This is a log message with the new prefix")</pre>			<p>Here is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
newPrefix: 2024/09/17 23:10:34 This is a log message with the new prefix</pre>			<p>The output fields and how they are printed are controlled by the flags. The <strong class="source-inline">log.LstdFlags</strong> tells the logger that the date and time of the log should also <span class="No-Break">be written.</span></p>
			<p>The <strong class="source-inline">log.Lshortfile</strong> prints the file name and line number showing where the log <span class="No-Break">statement is:</span></p>
			<pre class="source-code">
logger.SetFlags(log.LstdFlags | log.Lshortfile)
logger.Println("This is a log message with a prefix and file name")</pre>			<p>This gives the<a id="_idIndexMarker676"/> <span class="No-Break">following output:</span></p>
			<pre class="source-code">
prefix: 2024/09/17 23:10:34 main.go:17: This is a log message with a prefix and file name</pre>			<p>The <strong class="source-inline">log.Llongfile</strong> prints the <span class="No-Break">full path:</span></p>
			<pre class="source-code">
logger.SetFlags(log.LstdFlags | log.Llongfile) 
logger.Println("This is a log message with a prefix and long file name")</pre>			<p>Here is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
prefix: 2024/09/17 23:10:34 /home/github.com/PacktPublishing/Go-Recipes-for-Developers/blob/main/src/chp16/stdlogger/main.go:19: This is a log message with a prefix and long file name</pre>			<p>You can combine multiple flags using the bitwise <strong class="source-inline">|</strong> OR operator. The <strong class="source-inline">log.Lmsgprefix</strong> moves the prefix string (if one exists) to the beginning of the message from the beginning of the <span class="No-Break">log line:</span></p>
			<pre class="source-code">
logger.SetFlags(log.LstdFlags | log.Lshortfile | log.Lmsgprefix)
logger.Println("This is a log message with a prefix moved to the beginning of the message</pre>			<p>Here’s <span class="No-Break">the output::</span></p>
			<pre class="source-code">
2024/09/17 23:10:34 main.go:21: prefix: This is a log message with a prefix moved to the beginning of the message</pre>			<p>The following flags print the time and date in UTC, as well as the short <span class="No-Break">file name:</span></p>
			<pre class="source-code">
logger.SetFlags(log.LstdFlags | log.Lshortfile | log.LUTC)
logger.Println("This is a log message with with UTC time") ```</pre>			<p>This outputs<a id="_idIndexMarker677"/> <span class="No-Break">the following:</span></p>
			<pre class="source-code">
prefix: 2024/09/18 05:10:34 main.go:23: This is a log message with with UTC time</pre>			<h2 id="_idParaDest-414"><a id="_idTextAnchor415"/>Changing where to log</h2>
			<p>By default, the<a id="_idIndexMarker678"/> logging output goes to standard error (<strong class="source-inline">os.Stderr</strong>), but it can be changed without affecting the <span class="No-Break">logging directives.</span></p>
			<h3>How to do it...</h3>
			<p>You can create a logger with a given output using <strong class="source-inline">log.NewLogger</strong>. The following example creates <strong class="source-inline">logger</strong> to print its output to <span class="No-Break">standard error:</span></p>
			<pre class="source-code">
logger := log.New(os.Stderr, "", log.LstdFlags)</pre>			<p>You can then change the logging target <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">Logger.SetOutput</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
output, err := os.Create("log.txt")
if err != nil {
    log.Fatal(err)
}
defer output.Close()
logger.SetOutput(output)
logger.Println("This is a log message to log.txt")
logger.SetOutput(os.Stderr)
logger.Println("Message to log.txt was written")</pre>			<p>Use <strong class="source-inline">io.Discard</strong> as the<a id="_idIndexMarker679"/> log output to <span class="No-Break">stop logging:</span></p>
			<pre class="source-code">
logger.SetOutput(io.Discard)
logger.Println("This message will not be logged")</pre>			<h1 id="_idParaDest-415"><a id="_idTextAnchor416"/>Using the structured logger</h1>
			<p>Since the standard logger <a id="_idIndexMarker680"/>has limited practical use, many third-party logging libraries were developed by the community. Some of the patterns that emerged from these libraries emphasized structured logging and performance. The structured logging package was added to the standard library with these usage patterns in mind. The <strong class="source-inline">log</strong> package is still a useful tool for development as it provides a simple interface for developers and the users of the program, but the <strong class="source-inline">log/slog</strong> package is a production quality library that enables automated log analysis tools while providing a simple-to-use and <span class="No-Break">flexible interface.</span></p>
			<h2 id="_idParaDest-416"><a id="_idTextAnchor417"/>Logging using the global logger</h2>
			<p>Similar to the <strong class="source-inline">log</strong> package, there<a id="_idIndexMarker681"/> is a global structured<a id="_idIndexMarker682"/> logger accessible via the <strong class="source-inline">slog.Default()</strong> function. You can simply configure a global logger and use that in <span class="No-Break">your program.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">It is advisable to pass an instance of a logger around for any nontrivial project. The logging requirements may change from environment to environment, so having a dedicated <span class="No-Break">logger helps.</span></p>
			<h3>How to do it...</h3>
			<p>Use <strong class="source-inline">slog</strong> logging functions to <span class="No-Break">write logs:</span></p>
			<pre class="source-code">
slog.Debug("This is a debug message")
slog.Info("This is an info message with an integer field", "arg", 42)
slog.Info("This is another info message with an integer field", slog.Int("arg",42))</pre>			<p>You cannot modify the settings of the default logger, but you can create a new one and set it as the default. The <a id="_idIndexMarker683"/>following example shows how you can set a JSON logger as the <span class="No-Break">default </span><span class="No-Break"><a id="_idIndexMarker684"/></span><span class="No-Break">logger:</span></p>
			<pre class="source-code">
logger := slog.New(slog.NewJSONHandler(os.Stderr, &amp;slog.HandlerOptions{
        Level: slog.LevelDebug,
    },
))
slog.SetDefault(logger)</pre>			<p class="callout-heading">Tip</p>
			<p class="callout"><strong class="source-inline">slog.SetDefault()</strong> also sets the <strong class="source-inline">log</strong> package default logger, so the <strong class="source-inline">log</strong> package functions call the <strong class="source-inline">slog</strong> functions. Use <strong class="source-inline">slog.SetLogLoggerLevel</strong> to set the level of the log <span class="No-Break">package messages.</span></p>
			<h2 id="_idParaDest-417"><a id="_idTextAnchor418"/>Writing structured logs using different levels</h2>
			<p>The structured logger<a id="_idIndexMarker685"/> allows you to log messages at different levels. For instance, you can log detailed messages at the <strong class="source-inline">slog.LevelDebug</strong> level, warning messages at the <strong class="source-inline">slog.LevelWarn</strong> level, and error messages at the <strong class="source-inline">slog.LevelError</strong> level, and set the logging level of your program from a configuration or command <span class="No-Break">line argument.</span></p>
			<h3>How to do it...</h3>
			<ol>
				<li>Create a <strong class="source-inline">slog.Handler</strong> with <strong class="source-inline">slog.HandlerOptions.Level</strong> set to the desired level. The following example creates a text log handler that prints every log message as a separate line of text. It uses <strong class="source-inline">os.Stderr</strong> as the output, and the logging level is set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">slog.LevelDebug</strong></span><span class="No-Break">:</span><pre class="source-code">
handler:= slog.NewTextHandler(os.Stderr, &amp;slog.HandlerOptions{
    Level: slog.LevelDebug,
})</pre></li>				<li>Create a logger using <span class="No-Break">the handler:</span><pre class="source-code">
logger := slog.New(handler)</pre></li>				<li>Use the logger to create messages at different levels. Only those messages that are equal to or above the level determined by the handler options will be printed to <span class="No-Break">the output:</span><pre class="source-code">
logger.Debug("This is a debug message")
logger.Info("This is an info message with an integer argument", "arg", 42)
logger.Warn("This is a warning message with a string argument", "arg", "foo")</pre></li>				<li>If logging <a id="_idIndexMarker686"/>performance is a concern, you can check whether a specific logging level <span class="No-Break">is enabled:</span><pre class="source-code">
// Checking if logging is enabled for a specific level
if logger.Enabled(context.Background(), slog.LevelError) {
  logger.Error("This is an error message", slog.String("arg", "foo"))
}</pre></li>			</ol>
			<h2 id="_idParaDest-418"><a id="_idTextAnchor419"/>Changing log level at runtime</h2>
			<p>Most applications <a id="_idIndexMarker687"/>set up a logger at the beginning of the application using a command line option or a configuration file and do not change logging at runtime. However, the ability to set log levels at runtime can be an invaluable tool to identify production problems. You can set the debug level of a running server to <strong class="source-inline">slog.LevelDebug</strong>, record logs to find out about a troubling behavior, and set it back to its original level. This recipe shows how you can <span class="No-Break">do this.</span></p>
			<h3>How to do it...</h3>
			<ol>
				<li>Use a <strong class="source-inline">slog.LevelVar</strong> to wrap a log level value (this is<a id="_idIndexMarker688"/> called <strong class="bold">boxing</strong> <span class="No-Break">a variable):</span><pre class="source-code">
level = new(slog.LevelVar)</pre></li>				<li>Set the initial <span class="No-Break">log level:</span><pre class="source-code">
level.Set(slog.LevelError)</pre></li>				<li>Create a handler using the <span class="No-Break"><strong class="source-inline">boxed</strong></span><span class="No-Break"> level:</span><pre class="source-code">
handler:=slog.NewTextHandler(os.Stderr, &amp;slog.HandlerOptions{
        Level: level,
    })</pre></li>				<li>Create a logger using <span class="No-Break">the handler:</span><pre class="source-code">
logger:=slog.New(handler)</pre></li>				<li>Change <strong class="source-inline">level</strong> to <a id="_idIndexMarker689"/>control the <span class="No-Break">log level:</span><pre class="source-code">
level.Set(slog.LevelDebug)
// Now all loggers will start printing debug level messages</pre></li>			</ol>
			<h2 id="_idParaDest-419"><a id="_idTextAnchor420"/>Using loggers with additional attributes</h2>
			<p>Let’s say you have<a id="_idIndexMarker690"/> a server where you handle requests using functions that are shared among multiple request handlers. When the request is received, you can log which handler is running, but when you pass that logger to the common functions, they lose that information. They don’t know which request handler called. Instead of passing this information to those common functions (after all, they don’t really need that information), you can decorate a logger with such information and pass <span class="No-Break">the logger.</span></p>
			<h3>How to do it...</h3>
			<ol>
				<li>Create a new logger using <strong class="source-inline">Logger.With</strong>, and attach <span class="No-Break">additional attributes:</span><pre class="source-code">
func HandlerA(w http.ResponseWriter, req *http.Request) {
  reqId:=getRequestIdFromRequest(req)
  // Create a new logger with additional attributes
  logger:=slog.With(slog.String("handler", "a"),slog.
  String("reqId",reqId))
  logger.Debug("Start handling request")
  defer logger.Debug("Completed request")</pre></li>				<li>Use this<a id="_idIndexMarker691"/> logger to <span class="No-Break">log messages:</span><pre class="source-code">
  HandleRequest(logger, w,req)</pre><p class="list-inset">This will output a log message that looks <span class="No-Break">like this:</span></p><pre class="source-code">{"time":"2024-09-19T14:49:42.064787730-06:00","level":"DEBUG","msg":"Start handling request","handler":"a","reqId":"123"}
{"time":"2024-09-19T14:49:42.308187758-06:00","level":"DEBUG","msg":"This is a debug message","handler":"a","reqId":"123","key":"value"}
{"time":"2024-09-19T14:49:42.945674637-06:00","level":"DEBUG","msg":"Completed request","handler":"a","reqId":"123"}</pre></li>			</ol>
			<h2 id="_idParaDest-420"><a id="_idTextAnchor421"/>Changing where to log</h2>
			<p>The default <a id="_idIndexMarker692"/>logger writes to <strong class="source-inline">os.Stderr</strong>, and similar to the <strong class="source-inline">log</strong> package, this can be changed when you create <span class="No-Break">the logger.</span></p>
			<h3>How to do it...</h3>
			<p>The logger output is determined by the <strong class="source-inline">slog.Handler</strong>. The following example creates <strong class="source-inline">logger</strong> to print its output to <span class="No-Break">standard error:</span></p>
			<pre class="source-code">
logger := slog.New(slog.NewTextHandler(os.Stderr, &amp;slog.HandlerOptions{
        Level: slog.LevelDebug,
    }))</pre>			<p>Unlike the <strong class="source-inline">log</strong> package, you cannot change where to log after creating a logger, unless you write your <span class="No-Break">own handler.</span></p>
			<h2 id="_idParaDest-421"><a id="_idTextAnchor422"/>Adding logging information from the context</h2>
			<p>Often, the information<a id="_idIndexMarker693"/> you need to log is available in the context. Every <strong class="source-inline">slog</strong> logging function has two variants, one with context and one without. If you use the variants with context, you can write a handler that can extract information from that context containing information from the <span class="No-Break">call site.</span></p>
			<h3>How to do it...</h3>
			<p>Create a new handler, potentially wrapping an existing one. The following code snippet shows a handler that will extract an <strong class="source-inline">id</strong> from the context by wrapping <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">slog.Handler</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
type ContextIDHandler struct {
    slog.Handler
}</pre>			<p>Define the <strong class="source-inline">Handle</strong> method. Extract information from the context, modify the log record, and pass it to the <span class="No-Break">wrapped handler:</span></p>
			<pre class="source-code">
func (h ContextIDHandler) Handle(ctx context.Context, r slog.Record) error {
    // If the context has a string id, retrieve it and add it to the 
    // record
    if id, ok := ctx.Value("id").(string); ok {
        r.Add(slog.String("id", id))
    }
    return h.Handler.Handle(ctx, r)
}</pre>			<p>Use the logging functions that <span class="No-Break">take </span><span class="No-Break"><strong class="source-inline">context.Context</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
func Handler(w http.ResponseWriter, req *http.Request) {
  logger.Debug(req.Context(),"Handler started")
  ...</pre>			<p>This will add the <strong class="source-inline">id</strong> from the <a id="_idIndexMarker694"/>request context to the log message if there <span class="No-Break">is one:</span></p>
			<pre class="source-code">
{"time":"2024-09-19T15:02:12.163787730-06:00","level":"DEBUG","msg":"Handler started","id":"123"}</pre>		</div>
	</div></div></body></html>