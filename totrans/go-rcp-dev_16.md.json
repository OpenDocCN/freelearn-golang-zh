["```go\nlog.Println(\"This is a log message similar to fmt.Println\")\nlog.Printf(\"This is a log message similar to fmt.Printf\")\n```", "```go\n2024/09/17 23:05:26 This is a log message similar to fmt.Println\n2024/09/17 23:05:26 This is a log message similar to fmt.Printf\n```", "```go\nlogger := log.New(os.Stderr, \"\", log.LstdFlags)\nlogger.Println(\"This is a log message written to stderr\")\n```", "```go\n2024/09/17 23:10:34 This is a log message written to stderr\n```", "```go\nlog.Fatal(\"Fatal error\")\n```", "```go\n2024/09/17 23:05:26 Fatal error\n```", "```go\nlog.Panic(\"Fatal error\")\n```", "```go\n2024/09/17 23:05:26 Fatal error\npanic: Fatal error\ngoroutine 1 [running]:\nlog.Panic({0xc000104f30?, 0xc00007c060?, 0x556310?})\n    /usr/local/go-faketime/src/log/log.go:432 +0x5a\nmain.main()\n    /tmp/sandbox255937470/prog.go:8 +0x38\n```", "```go\nlogger := log.New(log.Writer(), \"prefix: \", log.LstdFlags)\nlogger.Println(\"This is a log message with a prefix\")\n```", "```go\nprefix: 2024/09/17 23:10:34 This is a log message with a prefix\n```", "```go\nlogger.SetPrefix(\"newPrefix\")\nlogger.Println(\"This is a log message with the new prefix\")\n```", "```go\nnewPrefix: 2024/09/17 23:10:34 This is a log message with the new prefix\n```", "```go\nlogger.SetFlags(log.LstdFlags | log.Lshortfile)\nlogger.Println(\"This is a log message with a prefix and file name\")\n```", "```go\nprefix: 2024/09/17 23:10:34 main.go:17: This is a log message with a prefix and file name\n```", "```go\nlogger.SetFlags(log.LstdFlags | log.Llongfile) \nlogger.Println(\"This is a log message with a prefix and long file name\")\n```", "```go\nprefix: 2024/09/17 23:10:34 /home/github.com/PacktPublishing/Go-Recipes-for-Developers/blob/main/src/chp16/stdlogger/main.go:19: This is a log message with a prefix and long file name\n```", "```go\nlogger.SetFlags(log.LstdFlags | log.Lshortfile | log.Lmsgprefix)\nlogger.Println(\"This is a log message with a prefix moved to the beginning of the message\n```", "```go\n2024/09/17 23:10:34 main.go:21: prefix: This is a log message with a prefix moved to the beginning of the message\n```", "```go\nlogger.SetFlags(log.LstdFlags | log.Lshortfile | log.LUTC)\nlogger.Println(\"This is a log message with with UTC time\") ```", "```go\n\nThis outputs the following:\n\n```", "```go\n\n## Changing where to log\n\nBy default, the logging output goes to standard error (`os.Stderr`), but it can be changed without affecting the logging directives.\n\n### How to do it...\n\nYou can create a logger with a given output using `log.NewLogger`. The following example creates `logger` to print its output to standard error:\n\n```", "```go\n\nYou can then change the logging target using `Logger.SetOutput`:\n\n```", "```go\n\nUse `io.Discard` as the log output to stop logging:\n\n```", "```go\n\n# Using the structured logger\n\nSince the standard logger has limited practical use, many third-party logging libraries were developed by the community. Some of the patterns that emerged from these libraries emphasized structured logging and performance. The structured logging package was added to the standard library with these usage patterns in mind. The `log` package is still a useful tool for development as it provides a simple interface for developers and the users of the program, but the `log/slog` package is a production quality library that enables automated log analysis tools while providing a simple-to-use and flexible interface.\n\n## Logging using the global logger\n\nSimilar to the `log` package, there is a global structured logger accessible via the `slog.Default()` function. You can simply configure a global logger and use that in your program.\n\nTip\n\nIt is advisable to pass an instance of a logger around for any nontrivial project. The logging requirements may change from environment to environment, so having a dedicated logger helps.\n\n### How to do it...\n\nUse `slog` logging functions to write logs:\n\n```", "```go\n\nYou cannot modify the settings of the default logger, but you can create a new one and set it as the default. The following example shows how you can set a JSON logger as the default logger:\n\n```", "```go\n\nTip\n\n`slog.SetDefault()` also sets the `log` package default logger, so the `log` package functions call the `slog` functions. Use `slog.SetLogLoggerLevel` to set the level of the log package messages.\n\n## Writing structured logs using different levels\n\nThe structured logger allows you to log messages at different levels. For instance, you can log detailed messages at the `slog.LevelDebug` level, warning messages at the `slog.LevelWarn` level, and error messages at the `slog.LevelError` level, and set the logging level of your program from a configuration or command line argument.\n\n### How to do it...\n\n1.  Create a `slog.Handler` with `slog.HandlerOptions.Level` set to the desired level. The following example creates a text log handler that prints every log message as a separate line of text. It uses `os.Stderr` as the output, and the logging level is set to `slog.LevelDebug`:\n\n    ```", "```go\n\n2.  Create a logger using the handler:\n\n    ```", "```go\n\n3.  Use the logger to create messages at different levels. Only those messages that are equal to or above the level determined by the handler options will be printed to the output:\n\n    ```", "```go\n\n4.  If logging performance is a concern, you can check whether a specific logging level is enabled:\n\n    ```", "```go\n\n## Changing log level at runtime\n\nMost applications set up a logger at the beginning of the application using a command line option or a configuration file and do not change logging at runtime. However, the ability to set log levels at runtime can be an invaluable tool to identify production problems. You can set the debug level of a running server to `slog.LevelDebug`, record logs to find out about a troubling behavior, and set it back to its original level. This recipe shows how you can do this.\n\n### How to do it...\n\n1.  Use a `slog.LevelVar` to wrap a log level value (this is called **boxing** a variable):\n\n    ```", "```go\n\n2.  Set the initial log level:\n\n    ```", "```go\n\n3.  Create a handler using the `boxed` level:\n\n    ```", "```go\n\n4.  Create a logger using the handler:\n\n    ```", "```go\n\n5.  Change `level` to control the log level:\n\n    ```", "```go\n\n## Using loggers with additional attributes\n\nLet’s say you have a server where you handle requests using functions that are shared among multiple request handlers. When the request is received, you can log which handler is running, but when you pass that logger to the common functions, they lose that information. They don’t know which request handler called. Instead of passing this information to those common functions (after all, they don’t really need that information), you can decorate a logger with such information and pass the logger.\n\n### How to do it...\n\n1.  Create a new logger using `Logger.With`, and attach additional attributes:\n\n    ```", "```go\n\n2.  Use this logger to log messages:\n\n    ```", "```go\n\n    This will output a log message that looks like this:\n\n    ```", "```go\n\n## Changing where to log\n\nThe default logger writes to `os.Stderr`, and similar to the `log` package, this can be changed when you create the logger.\n\n### How to do it...\n\nThe logger output is determined by the `slog.Handler`. The following example creates `logger` to print its output to standard error:\n\n```", "```go\n\nUnlike the `log` package, you cannot change where to log after creating a logger, unless you write your own handler.\n\n## Adding logging information from the context\n\nOften, the information you need to log is available in the context. Every `slog` logging function has two variants, one with context and one without. If you use the variants with context, you can write a handler that can extract information from that context containing information from the call site.\n\n### How to do it...\n\nCreate a new handler, potentially wrapping an existing one. The following code snippet shows a handler that will extract an `id` from the context by wrapping a `slog.Handler`:\n\n```", "```go\n\nDefine the `Handle` method. Extract information from the context, modify the log record, and pass it to the wrapped handler:\n\n```", "```go\n\nUse the logging functions that take `context.Context`:\n\n```", "```go\n\nThis will add the `id` from the request context to the log message if there is one:\n\n```"]