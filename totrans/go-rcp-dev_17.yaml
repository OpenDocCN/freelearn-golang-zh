- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing, Benchmarking, and Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having tests and benchmarks for your code will help you in several ways. During
    development, tests ensure that what you are developing works and that you do not
    break existing functionality as part of your development work. Benchmarks ensure
    that your program stays within certain resource and time constraints. After the
    development is complete, the same tests and benchmarks will ensure that any maintenance
    work (bug fixes, feature enhancements, etc.) does not introduce bugs in existing
    functionality. So, you should consider writing tests and benchmarks as a core
    development activity, and develop both your program and its tests together.
  prefs: []
  type: TYPE_NORMAL
- en: Testing should focus on testing the expected behavior when everything works
    (“happy path testing”) as well as when things fail. It should not focus on testing
    all possible execution paths. Tests developed to exercise all possible implementation
    choices quickly become harder to maintain than the program itself. You should
    find a balance between practicality and test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section shows idiomatic ways of dealing with several common testing and
    benchmarking scenarios. These are the topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging in tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skipping tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing HTTP servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing HTTP handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking test coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benchmarking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing benchmarks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing multiple benchmarks with different input sizes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running benchmarks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will work on an example function that sorts `time.Time` values in ascending
    or descending order, which is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will use the built-in testing tools provided by the Go build system and the
    standard library. For this, let’s suppose we stored the preceding function in
    a file called `sort.go`. Then, the unit tests for this function will be in a file
    called `sort_test.go` in the same directory as `sort.go`. The Go build system
    will recognize source files that end with `_test.go` as unit tests, and will exclude
    them from regular builds.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A unit test ideally tests whether a single unit (a function, a group of interrelated
    functions, or the methods of a type) behaves as expected.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create unit test files with the `_test.go` suffix. For `sort.go`, we create
    `sort_test.go`. The files that end with `_test.go` will be excluded from a regular
    build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can also write tests in a separate test package that ends with `_test`.
    In this example, it becomes `package sort_test`. Writing tests in a separate package
    allows you to test the functions of a package as they are seen from the outside
    because you will not have access to the unexported names of the package under
    test. You will have to import the package under test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go testing system will run functions that follow the `Test<Feature>(*testing.T)`
    pattern. Declare a test function that fits this pattern, and write a unit test
    that exercises a behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The layout of a test function usually follows this structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare input data and any necessary environment in which the function under
    test will run
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the function under test with the necessary input
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure the function under test returned the correct result or behaved as
    expected
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the test detects errors, notify the testing system that the test failed using
    the `t.Error` family of functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Running unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use the Go build system tools to run unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run all unit tests in the current package, input the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run all unit tests in a package, input the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or, you can input the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run all unit tests in all packages of a module recursively, input the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Do this from the root directory of the module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To run a single test in the current package, input the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `^` denotes the string beginning and `$` denotes the string end symbols
    used in regular expressions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For instance, the following will run all tests that end with `Ascending`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Logging in tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often additional logging functionality is useful for tests to show the state
    of critical variables, especially if a failure occurs. By default, the Go test
    executor does not print any logging information if tests pass, but if a test fails,
    the logging information is also included in the output.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `testing.T.Log` and `testing.T.Logf` functions to record log messages in
    tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests. If the test passes, no log information will be printed. If the
    test fails, logs will be printed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To run the tests with logs, use the `-``v` flag:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Skipping tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can skip certain tests based on an input flag. This feature lets you have
    a quick test where only a subset of the tests are run and a comprehensive test
    where all the tests are run.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Check the `testing.Short()` flag for tests that should be excluded from short
    test runs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run tests with the `test.short` flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Testing HTTP servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `net/http/httptest` package complements the `testing` package by providing
    HTTP server testing facilities that allow you to create test HTTP servers quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this section, suppose we extend our sorting function by converting it to
    an HTTP service, as given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `GetServeMux` function prepares a request multiplexer that handles `POST
    /sort/asc` and `POST /sort/desc` HTTP endpoints for ascending and descending sort
    requests respectively. The input is a JSON array of time values. The handler returns
    a sorted JSON array.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `net/http/httptest` package that includes support for a test server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the test function, create a handler or multiplexer, and use that to create
    a test server. Make sure the server shuts down when the test ends -- use `defer
    server.Close()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the server using `server.URL`. This is initialized to use an unallocated
    local port by the `httptest.NewServer` function. In the following example, we
    are sending an invalid input to the server to verify if the server returns an
    error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `http.Post` function does not return an error. An error from `http.Post`
    would mean the `POST` operation failed. In this case, the `POST` operation was
    successful, but an HTTP error status was returned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can issue multiple calls to the server to test different inputs and check
    the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Testing HTTP handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `net/http/httptest` package also contains `ResponseRecorder`, which can
    be used as `http.ResponseWriter` for HTTP handlers to test a single handler without
    creating a server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create `ResponseRecorder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the handler, passing the response recorder instead of `http.ResponseWriter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The response recorder stores the HTTP response built by the handler. Validate
    that the response is correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Checking test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A test coverage report shows which lines of source code were covered by tests.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get a quick coverage result, run tests with the `cover` flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To write a test coverage profile to a separate file so you can get detailed
    reports on it, give the test run a cover profile file name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command opens the browser and allows you to see which lines were covered
    by tests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Benchmarking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests check correctness while benchmarks check performance and memory usage.
  prefs: []
  type: TYPE_NORMAL
- en: Writing benchmarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to a unit test, benchmarks are stored in the `_test.go` files, but these
    functions start with `Benchmark` instead of `Test`. A benchmark is given a number
    `N` where you repeat the same operation `N` times while the runtime is measuring
    the performance.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a benchmark function in one of the `_test.go` files. The following example
    is in the `sort_test.go` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Do the setup before the benchmark loop, otherwise, you will be benchmarking
    the setup code as well, not the actual algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write a `for` loop iterating `b.N` times and perform the operation that will
    be benchmarked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Avoid logging or printing data in benchmark loops.
  prefs: []
  type: TYPE_NORMAL
- en: Writing multiple benchmarks with different input sizes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You usually want to see the behavior of your algorithms with different input
    sizes. The Go testing framework only provides the number of times a benchmark
    should run, not with what input size. Use the following pattern to exercise different
    input sizes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define an unexported parameterized benchmark function that accepts input size
    information or inputs of different sizes. The following example gets the number
    of items and sort direction as arguments, and creates a randomly shuffled input
    slice with the given size before performing the benchmark:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define exported benchmark functions by calling the common benchmark with different
    values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running benchmarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go tooling runs unit tests before running benchmarks -- there is no point in
    benchmarking failing code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `go test -bench=<regexp>` tool. To run all benchmarks, use the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter a benchmark regular expression if you want to run a subset of the benchmarks.
    The following only runs benchmarks containing `1000` in their names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A profiler samples a running program to find how much time is spent in certain
    functions. You can profile a benchmark, create a profile, and then inspect that
    profile to find bottlenecks in your programs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get a CPU profile and analyze it, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run benchmarks with the `cpuprofile` flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the `pprof` tool using the profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `topN` command to see the top `N` samples in the profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This shows that most time is spent in the anonymous function that compares two
    time values. The `flat` column shows how much time is spent in a function, excluding
    the time spent in functions called by it. `cum`, which stands for cumulative,
    includes the time spent in a function, defined as the point in time the function
    returned minus the point in time the function started running. That is, the cumulative
    value includes the time spent in the functions called by the function. For example
    `sort.partition_func` ran for `620ms`, but only `230ms` of that time was spent
    in `sort.partition_func` and the remaining time was spent in functions called
    by `sort.partition_func`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use the `web` command to see a visual representation of the call graph and how
    much time is spent on each function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To get a memory profile and analyze it, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run benchmarks with the `memprofile` flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the `pprof` tool using the profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `topN` command to see the top `N` samples in the profile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similar to the CPU profile output, this table shows how much memory was allocated
    to each function. Again, `flat` refers to memory allocated in that function only,
    and `cum` refers to memory allocated in that function and any function called
    by that function. Here, you can see that `sort.SortTimes` is the function that
    allocates most of the memory. This is because it first creates a copy of the slice
    and then sorts it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Use the `web` command to see a visual representation of the memory allocations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The definitive guide to profiling Go Programs is available at [https://go.dev/blog/pprof](https://go.dev/blog/pprof)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `pprof` README explains the node and edge representations: [https://github.com/google/pprof/blob/main/doc/README.md](https://github.com/google/pprof/blob/main/doc/README.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
