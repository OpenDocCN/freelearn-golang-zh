- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Testing, Benchmarking, and Profiling
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试、基准测试和性能分析
- en: Having tests and benchmarks for your code will help you in several ways. During
    development, tests ensure that what you are developing works and that you do not
    break existing functionality as part of your development work. Benchmarks ensure
    that your program stays within certain resource and time constraints. After the
    development is complete, the same tests and benchmarks will ensure that any maintenance
    work (bug fixes, feature enhancements, etc.) does not introduce bugs in existing
    functionality. So, you should consider writing tests and benchmarks as a core
    development activity, and develop both your program and its tests together.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的代码编写测试和基准测试将帮助你以多种方式。在开发过程中，测试确保你正在开发的功能正常工作，并且在开发工作中不会破坏现有功能。基准测试确保你的程序保持在某些资源和时间限制内。在开发完成后，相同的测试和基准测试将确保任何维护工作（错误修复、功能增强等）不会在现有功能中引入错误。因此，你应该将编写测试和基准测试视为核心开发活动，并一起开发你的程序及其测试。
- en: Testing should focus on testing the expected behavior when everything works
    (“happy path testing”) as well as when things fail. It should not focus on testing
    all possible execution paths. Tests developed to exercise all possible implementation
    choices quickly become harder to maintain than the program itself. You should
    find a balance between practicality and test coverage.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应关注在一切正常时测试预期的行为（“正常路径测试”）以及当事情失败时的行为。它不应专注于测试所有可能的执行路径。旨在测试所有可能实现选择的测试很快就会比程序本身更难维护。你应该在实用性和测试覆盖率之间找到平衡。
- en: 'This section shows idiomatic ways of dealing with several common testing and
    benchmarking scenarios. These are the topics covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了处理几个常见测试和基准测试场景的惯用方法。这些是本章涵盖的主题：
- en: Working with unit tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与单元测试一起工作
- en: Writing unit tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: Running unit tests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行单元测试
- en: Logging in tests
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试中的日志记录
- en: Skipping tests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳过测试
- en: Testing HTTP servers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试HTTP服务器
- en: Testing HTTP handlers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试HTTP处理器
- en: Checking test coverage
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查测试覆盖率
- en: Benchmarking
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基准测试
- en: Writing benchmarks
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写基准测试
- en: Writing multiple benchmarks with different input sizes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写具有不同输入大小的多个基准测试
- en: Running benchmarks
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行基准测试
- en: Profiling
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析
- en: Working with unit tests
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与单元测试一起工作
- en: 'We will work on an example function that sorts `time.Time` values in ascending
    or descending order, which is given here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将处理一个示例函数，该函数按升序或降序对`time.Time`值进行排序，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will use the built-in testing tools provided by the Go build system and the
    standard library. For this, let’s suppose we stored the preceding function in
    a file called `sort.go`. Then, the unit tests for this function will be in a file
    called `sort_test.go` in the same directory as `sort.go`. The Go build system
    will recognize source files that end with `_test.go` as unit tests, and will exclude
    them from regular builds.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Go构建系统和标准库提供的内置测试工具。为此，假设我们将前面的函数存储在一个名为`sort.go`的文件中。那么，这个函数的单元测试将在这个`sort.go`文件所在的目录中的`sort_test.go`文件中。Go构建系统将识别以`_test.go`结尾的源文件为单元测试，并将它们排除在常规构建之外。
- en: Writing a unit test
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个单元测试
- en: A unit test ideally tests whether a single unit (a function, a group of interrelated
    functions, or the methods of a type) behaves as expected.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试理想情况下测试单个单元（一个函数、一组相互关联的函数或类型的成员函数）是否按预期行为。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create unit test files with the `_test.go` suffix. For `sort.go`, we create
    `sort_test.go`. The files that end with `_test.go` will be excluded from a regular
    build:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有`_test.go`后缀的单元测试文件。对于`sort.go`，我们创建`sort_test.go`。以`_test.go`结尾的文件将不会被常规构建包含：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also write tests in a separate test package that ends with `_test`.
    In this example, it becomes `package sort_test`. Writing tests in a separate package
    allows you to test the functions of a package as they are seen from the outside
    because you will not have access to the unexported names of the package under
    test. You will have to import the package under test.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在以`_test`结尾的单独测试包中编写测试。在这个例子中，它变成了`package sort_test`。在单独的包中编写测试允许你从外部测试包中的函数，因为你将无法访问正在测试的包中的未导出名称。你将不得不导入正在测试的包。
- en: 'The Go testing system will run functions that follow the `Test<Feature>(*testing.T)`
    pattern. Declare a test function that fits this pattern, and write a unit test
    that exercises a behavior:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go测试系统将运行遵循`Test<Feature>(*testing.T)`模式的函数。声明一个符合此模式的测试函数，并编写一个测试该行为的单元测试：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The layout of a test function usually follows this structure:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试函数的布局通常遵循以下结构：
- en: Prepare input data and any necessary environment in which the function under
    test will run
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备输入数据和测试函数运行所需的任何必要环境
- en: Call the function under test with the necessary input
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用必要的输入调用测试函数
- en: Make sure the function under test returned the correct result or behaved as
    expected
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保测试函数返回了正确的结果或表现如预期。
- en: If the test detects errors, notify the testing system that the test failed using
    the `t.Error` family of functions.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果测试检测到错误，使用 `t.Error` 系列函数通知测试系统测试失败。
- en: Running unit tests
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行单元测试
- en: Use the Go build system tools to run unit tests.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Go 构建系统工具运行单元测试。
- en: How to do it...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To run all unit tests in the current package, input the following:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行当前包中的所有单元测试，输入以下内容：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To run all unit tests in a package, input the following:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行包中的所有单元测试，输入以下内容：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or, you can input the following:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，您可以输入以下内容：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To run all unit tests in all packages of a module recursively, input the following:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要递归地运行模块中所有包的所有单元测试，输入以下内容：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Do this from the root directory of the module.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从模块的根目录执行此操作。
- en: 'To run a single test in the current package, input the following:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行当前包中的单个测试，输入以下内容：
- en: '[PRE7]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, `^` denotes the string beginning and `$` denotes the string end symbols
    used in regular expressions.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`^` 表示正则表达式中的字符串开头符号，`$` 表示字符串结尾符号。
- en: 'For instance, the following will run all tests that end with `Ascending`:'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，以下将运行所有以 `Ascending` 结尾的测试：
- en: '[PRE8]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Logging in tests
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试中的日志记录
- en: Often additional logging functionality is useful for tests to show the state
    of critical variables, especially if a failure occurs. By default, the Go test
    executor does not print any logging information if tests pass, but if a test fails,
    the logging information is also included in the output.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于测试来说，额外的日志功能很有用，可以显示关键变量的状态，尤其是在发生失败时。默认情况下，如果测试通过，Go 测试执行器不会打印任何日志信息，但如果测试失败，则日志信息也会包含在输出中。
- en: How to do it...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use `testing.T.Log` and `testing.T.Logf` functions to record log messages in
    tests:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `testing.T.Log` 和 `testing.T.Logf` 函数在测试中记录日志信息：
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run the tests. If the test passes, no log information will be printed. If the
    test fails, logs will be printed.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。如果测试通过，则不会打印日志信息。如果测试失败，则打印日志。
- en: 'To run the tests with logs, use the `-``v` flag:'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要使用日志运行测试，使用 `-v` 标志：
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Skipping tests
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳过测试
- en: You can skip certain tests based on an input flag. This feature lets you have
    a quick test where only a subset of the tests are run and a comprehensive test
    where all the tests are run.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据输入标志跳过某些测试。此功能允许您快速测试，其中只运行测试子集，以及全面测试，其中运行所有测试。
- en: How to do it...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Check the `testing.Short()` flag for tests that should be excluded from short
    test runs:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 `testing.Short()` 标志以确定应从短测试运行中排除的测试：
- en: '[PRE11]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run tests with the `test.short` flag:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `test.short` 标志运行测试：
- en: '[PRE12]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Testing HTTP servers
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 HTTP 服务器
- en: The `net/http/httptest` package complements the `testing` package by providing
    HTTP server testing facilities that allow you to create test HTTP servers quickly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http/httptest` 包通过提供快速创建测试 HTTP 服务器的设施来补充 `testing` 包。'
- en: 'For this section, suppose we extend our sorting function by converting it to
    an HTTP service, as given here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节，假设我们通过将其转换为 HTTP 服务来扩展我们的排序函数，如下所示：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `GetServeMux` function prepares a request multiplexer that handles `POST
    /sort/asc` and `POST /sort/desc` HTTP endpoints for ascending and descending sort
    requests respectively. The input is a JSON array of time values. The handler returns
    a sorted JSON array.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetServeMux` 函数准备一个请求多路复用器，该复用器处理 `POST /sort/asc` 和 `POST /sort/desc` HTTP
    端点，分别用于升序和降序排序请求。输入是时间值的 JSON 数组。处理程序返回排序后的 JSON 数组。'
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the `net/http/httptest` package that includes support for a test server:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用包含对测试服务器支持的 `net/http/httptest` 包：
- en: '[PRE14]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the test function, create a handler or multiplexer, and use that to create
    a test server. Make sure the server shuts down when the test ends -- use `defer
    server.Close()`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试函数中，创建一个处理程序或多路复用器，并使用它来创建测试服务器。确保测试结束时服务器关闭 -- 使用 `defer server.Close()`：
- en: '[PRE15]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Call the server using `server.URL`. This is initialized to use an unallocated
    local port by the `httptest.NewServer` function. In the following example, we
    are sending an invalid input to the server to verify if the server returns an
    error:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `server.URL` 调用服务器。这是由 `httptest.NewServer` 函数初始化的，使用未分配的本地端口。在以下示例中，我们向服务器发送无效输入以验证服务器是否返回错误：
- en: '[PRE16]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the `http.Post` function does not return an error. An error from `http.Post`
    would mean the `POST` operation failed. In this case, the `POST` operation was
    successful, but an HTTP error status was returned.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`http.Post` 函数不会返回错误。`http.Post` 的错误意味着 `POST` 操作失败。在这种情况下，`POST` 操作是成功的，但返回了
    HTTP 错误状态。
- en: 'You can issue multiple calls to the server to test different inputs and check
    the output:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以向服务器发出多个调用以测试不同的输入并检查输出：
- en: '[PRE17]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Testing HTTP handlers
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 HTTP 处理器
- en: The `net/http/httptest` package also contains `ResponseRecorder`, which can
    be used as `http.ResponseWriter` for HTTP handlers to test a single handler without
    creating a server.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`net/http/httptest` 包还包含 `ResponseRecorder`，它可以作为 `http.ResponseWriter` 用于
    HTTP 处理器，以测试单个处理器而不创建服务器。'
- en: How to do it...
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create `ResponseRecorder`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `ResponseRecorder`：
- en: '[PRE18]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Call the handler, passing the response recorder instead of `http.ResponseWriter`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用处理器，传递响应记录器而不是 `http.ResponseWriter`：
- en: '[PRE19]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The response recorder stores the HTTP response built by the handler. Validate
    that the response is correct:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应记录器存储由处理器构建的 HTTP 响应。验证响应是否正确：
- en: '[PRE20]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Checking test coverage
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查测试覆盖率
- en: A test coverage report shows which lines of source code were covered by tests.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 测试覆盖率报告显示哪些源代码行被测试覆盖。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To get a quick coverage result, run tests with the `cover` flag:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要快速获取覆盖率结果，使用 `cover` 标志运行测试：
- en: '[PRE21]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To write a test coverage profile to a separate file so you can get detailed
    reports on it, give the test run a cover profile file name:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将测试覆盖率配置文件写入到单独的文件中，以便你可以获取详细的报告，给测试运行指定一个覆盖率配置文件名：
- en: '[PRE22]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This command opens the browser and allows you to see which lines were covered
    by tests.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令打开浏览器并允许你看到哪些行被测试覆盖。
- en: Benchmarking
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基准测试
- en: Unit tests check correctness while benchmarks check performance and memory usage.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试检查正确性，而基准测试检查性能和内存使用。
- en: Writing benchmarks
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写基准测试
- en: Similar to a unit test, benchmarks are stored in the `_test.go` files, but these
    functions start with `Benchmark` instead of `Test`. A benchmark is given a number
    `N` where you repeat the same operation `N` times while the runtime is measuring
    the performance.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与单元测试类似，基准测试存储在 `_test.go` 文件中，但这些函数以 `Benchmark` 开头而不是 `Test`。基准测试给定一个数字 `N`，其中你重复相同的操作
    `N` 次同时运行时测量性能。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a benchmark function in one of the `_test.go` files. The following example
    is in the `sort_test.go` file:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `_test.go` 文件中创建一个基准测试函数。以下示例在 `sort_test.go` 文件中：
- en: '[PRE23]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Do the setup before the benchmark loop, otherwise, you will be benchmarking
    the setup code as well, not the actual algorithm:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基准测试循环之前进行设置，否则你将基准测试设置代码以及实际算法：
- en: '[PRE24]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Write a `for` loop iterating `b.N` times and perform the operation that will
    be benchmarked:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个迭代 `b.N` 次的 `for` 循环并执行将被基准测试的操作：
- en: '[PRE25]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tip
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Avoid logging or printing data in benchmark loops.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在基准测试循环中避免记录或打印数据。
- en: Writing multiple benchmarks with different input sizes
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写具有不同输入大小的多个基准测试
- en: You usually want to see the behavior of your algorithms with different input
    sizes. The Go testing framework only provides the number of times a benchmark
    should run, not with what input size. Use the following pattern to exercise different
    input sizes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常想看到你的算法在不同输入大小下的行为。Go 测试框架只提供了基准测试应该运行多少次，而不是使用什么输入大小。使用以下模式来练习不同的输入大小。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Define an unexported parameterized benchmark function that accepts input size
    information or inputs of different sizes. The following example gets the number
    of items and sort direction as arguments, and creates a randomly shuffled input
    slice with the given size before performing the benchmark:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个未导出的参数化基准测试函数，该函数接受输入大小信息或不同大小的输入。以下示例获取项目数量和排序方向作为参数，并在执行基准测试之前创建一个给定大小的随机打乱输入切片：
- en: '[PRE26]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Define exported benchmark functions by calling the common benchmark with different
    values:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用公共基准测试并使用不同的值来定义导出的基准测试函数：
- en: '[PRE27]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Running benchmarks
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行基准测试
- en: Go tooling runs unit tests before running benchmarks -- there is no point in
    benchmarking failing code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Go工具在运行基准测试之前运行单元测试——对失败的代码进行基准测试没有意义。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the `go test -bench=<regexp>` tool. To run all benchmarks, use the following
    command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`go test -bench=<regexp>`工具。要运行所有基准测试，请使用以下命令：
- en: '[PRE28]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Enter a benchmark regular expression if you want to run a subset of the benchmarks.
    The following only runs benchmarks containing `1000` in their names:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想运行基准测试的子集，请输入一个基准正则表达式。以下命令仅运行名称中包含`1000`的基准测试：
- en: '[PRE29]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Profiling
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析
- en: A profiler samples a running program to find how much time is spent in certain
    functions. You can profile a benchmark, create a profile, and then inspect that
    profile to find bottlenecks in your programs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器通过采样运行中的程序来查找在特定函数中花费的时间。你可以分析基准测试，创建配置文件，然后检查该配置文件以找到程序中的瓶颈。
- en: How to do it…
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To get a CPU profile and analyze it, follow these steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取CPU配置文件并进行分析，请按照以下步骤操作：
- en: 'Run benchmarks with the `cpuprofile` flag:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cpuprofile`标志运行基准测试：
- en: '[PRE30]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Start the `pprof` tool using the profile:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用配置文件启动`pprof`工具：
- en: '[PRE31]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Use the `topN` command to see the top `N` samples in the profile:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`topN`命令查看配置文件中的前`N`个样本：
- en: '[PRE32]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This shows that most time is spent in the anonymous function that compares two
    time values. The `flat` column shows how much time is spent in a function, excluding
    the time spent in functions called by it. `cum`, which stands for cumulative,
    includes the time spent in a function, defined as the point in time the function
    returned minus the point in time the function started running. That is, the cumulative
    value includes the time spent in the functions called by the function. For example
    `sort.partition_func` ran for `620ms`, but only `230ms` of that time was spent
    in `sort.partition_func` and the remaining time was spent in functions called
    by `sort.partition_func`.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这表明大部分时间都花在比较两个时间值的匿名函数中。`flat`列显示了在函数中花费的时间，不包括由该函数调用的函数所花费的时间。`cum`（累积）包括在函数中花费的时间，定义为函数返回的时间点减去函数开始运行的时间点。也就是说，累积值包括该函数调用的函数所花费的时间。例如`sort.partition_func`运行了`620ms`，但其中只有`230ms`是在`sort.partition_func`中花费的，其余时间是在`sort.partition_func`调用的函数中花费的。
- en: Use the `web` command to see a visual representation of the call graph and how
    much time is spent on each function.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`web`命令查看调用图和每个函数花费的时间的视觉表示。
- en: 'To get a memory profile and analyze it, follow these steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取内存配置文件并进行分析，请按照以下步骤操作：
- en: 'Run benchmarks with the `memprofile` flag:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`memprofile`标志运行基准测试：
- en: '[PRE33]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Start the `pprof` tool using the profile:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用配置文件启动`pprof`工具：
- en: '[PRE34]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Use the `topN` command to see the top `N` samples in the profile:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`topN`命令查看配置文件中的前`N`个样本：
- en: '[PRE35]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Similar to the CPU profile output, this table shows how much memory was allocated
    to each function. Again, `flat` refers to memory allocated in that function only,
    and `cum` refers to memory allocated in that function and any function called
    by that function. Here, you can see that `sort.SortTimes` is the function that
    allocates most of the memory. This is because it first creates a copy of the slice
    and then sorts it.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与CPU配置文件输出类似，此表显示了每个函数分配了多少内存。同样，`flat`指的是仅在该函数中分配的内存，而`cum`指的是在该函数及其调用的任何函数中分配的内存。在这里，你可以看到`sort.SortTimes`是分配最多内存的函数。这是因为它首先创建切片的副本，然后对其进行排序。
- en: Use the `web` command to see a visual representation of the memory allocations.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`web`命令查看内存分配的视觉表示。
- en: See also
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The definitive guide to profiling Go Programs is available at [https://go.dev/blog/pprof](https://go.dev/blog/pprof)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go程序分析的权威指南可在[https://go.dev/blog/pprof](https://go.dev/blog/pprof)找到
- en: 'The `pprof` README explains the node and edge representations: [https://github.com/google/pprof/blob/main/doc/README.md](https://github.com/google/pprof/blob/main/doc/README.md)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pprof`的README文件解释了节点和边的表示：[https://github.com/google/pprof/blob/main/doc/README.md](https://github.com/google/pprof/blob/main/doc/README.md)'
