<html><head></head><body>
		<div>
			<div id="_idContainer008" class="Content">
			</div>
		</div>
		<div id="_idContainer009" class="Content">
			<h1 id="_idParaDest-17"><a id="_idTextAnchor018"/>1. Variables and Operators</h1>
		</div>
		<div id="_idContainer033" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, you will be introduced to features of Go and will gain a basic understanding of what Go code looks like. You will also be provided with a deep understanding of how variables work and will perform exercises and activities to get hands-on and get going.</p>
			<p class="callout">By the end of this chapter, you will be able to use variables, packages, and functions in Go. You will learn to change variable values in Go. Later in the chapter you will use operators with numbers and design functions using pointers.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor019"/>Introduction</h1>
			<p>Go (or golang as it's often called) is a programming language popular with developers because of how rewarding it is to use to develop software. It's also popular with companies because teams of all sizes can be productive with it. Go has also earned a reputation for consistently delivering software with exceptionally high performance.</p>
			<p>Go has an impressive pedigree since it was created by a team from Google with a long history of building great programming languages and operating systems. They created a language that has the feel of a dynamic language such as JavaScript or PHP but with the performance and efficiency of strongly typed languages such as C++ and Java. They wanted a language that was engaging for the programmer but practical in projects with hundreds of developers.</p>
			<p>Go is packed with interesting and unique features, such as being complied with memory safety and channel-based concurrency. We'll explore these features in this chapter. By doing so, you'll see that their unique implementation within Go is what makes Go truly special.</p>
			<p>Go is written in text files that are then compiled down to machine code and packaged into a single, standalone executable file. The executable is self-contained, with nothing needed to be installed first to allow it to run. Having a single file makes deploying and distributing Go software hassle-free. When compiling, you can pick one of several target operating systems, including but not limited to Windows, Linux, macOS, and Android. With Go, you write your code once and run it anywhere. Complied languages fell out of favor because programmers hated long waits for their code to compile. The Go team knew this and built a lightning-fast compiler that remains fast as projects grow.</p>
			<p>Go has a statically typed and type-safe memory model with a garbage collector. This combination protects developers from creating many of the most common bugs and security flaws found in software while still providing excellent performance and efficiency. Dynamically typed languages such as Ruby and Python have become popular in part because programmers felt they could be more productive if they didn't have to worry about types and memory. The downside of these languages is that they gave up performance and memory efficiency and can be more prone to type-mismatch bugs. Go has the same levels of productivity as dynamically typed languages while not giving up performance and efficiency.</p>
			<p>A massive shift in computer performance has taken place. Going fast now means you need to be able to do as much work parallel or concurrently as possible. This change is due to the design of modern CPUs, which emphasize more cores over high clock speed. None of the currently popular programming languages have been designed to take advantage of this fact, which makes writing parallel and concurrent code in them error-prone. Go is designed to take advantage of multiple CPU cores, and it removes all the frustration and bug-filled code. Go is designed to allow any developer to easily and safely write parallel and concurrent code that enables them to take advantage of modern multicore CPUs and cloud computing <strong class="source-inline">–</strong> unlocking high-performance processing and massive scalability without the drama.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor020"/>What Does Go Look Like?</h2>
			<p>Let's take our first look at some Go code. This code randomly prints a message to the console from a pre-defined list of messages:</p>
			<p class="source-code">package main</p>
			<p class="source-code">// Import extra functionality from packages</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "errors"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "log"</p>
			<p class="source-code">  "math/rand"</p>
			<p class="source-code">  "strconv"</p>
			<p class="source-code">  "time"</p>
			<p class="source-code">)// Taken from: https://en.wiktionary.org/wiki/Hello_World#Translations</p>
			<p class="source-code">var helloList = []string{</p>
			<p class="source-code">  "Hello, world",</p>
			<p class="source-code">  "Καλημέρα κόσμε",</p>
			<p class="source-code">  "こんにちは世界",</p>
			<p class="source-code">  "سلام دنیا‎",</p>
			<p class="source-code">  "Привет, мир",</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">main()</strong> function is defined as:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  // Seed random number generator using the current time</p>
			<p class="source-code">  rand.Seed(time.Now().UnixNano())</p>
			<p class="source-code">  // Generate a random number in the range of out list</p>
			<p class="source-code">  index := rand.Intn(len(helloList))</p>
			<p class="source-code">  // Call a function and receive multiple return values</p>
			<p class="source-code">  msg, err := hello(index)</p>
			<p class="source-code">  // Handle any errors</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">  log.Fatal(err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  // Print our message to the console</p>
			<p class="source-code">  fmt.Println(msg)</p>
			<p class="source-code">}</p>
			<p>Let's consider the <strong class="source-inline">hello()</strong> function:</p>
			<p class="source-code">func hello(index int) (string, error) {</p>
			<p class="source-code">  if index &lt; 0 || index &gt; len(helloList)-1 {</p>
			<p class="source-code">  // Create an error, convert the int type to a string</p>
			<p class="source-code">  return "", errors.New("out of range: " + strconv.Itoa(index))</p>
			<p class="source-code">  }</p>
			<p class="source-code">  return helloList[index], nil</p>
			<p class="source-code">}</p>
			<p>Now, let's step through this code piece by piece.</p>
			<p>At the top of our script is the following:</p>
			<p class="source-code">package main</p>
			<p>This code is our package declaration. All Go files must start with one of these. If you want to run the code directly, you'll need to name it <strong class="source-inline">main</strong>. If you don't name it <strong class="source-inline">main</strong>, then you can use it as a library and import it into other Go code. When creating an importable package, you can give it any name. All Go files in the same directory are considered part of the same package, which means all the files must have the same package name.</p>
			<p>In the following code, we're importing code from packages:</p>
			<p class="source-code">// Import extra functionality from packages</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "errors"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "log"</p>
			<p class="source-code">  "math/rand"</p>
			<p class="source-code">  "strconv"</p>
			<p class="source-code">  "time"</p>
			<p class="source-code">)</p>
			<p>In this example, the packages are all from Go's standard library. Go's standard library is very high-quality and comprehensive. You are strongly recommended to maximize your use of it. You can tell if a package isn't from the standard library because it'll look like a URL, for example, <strong class="source-inline">github.com/fatih/color</strong>.</p>
			<p>Go has a module system that makes using external packages easy. To use a new module, add it to your import path. Go will automatically download it for you the next time you build code.</p>
			<p>Imports only apply to the file they're declared in, which means you must declare the same imports over and over in the same package and project. Fear not, though you don't need to do this by hand. There are many tools and Go editors that automatically add and remove the imports for you:</p>
			<p class="source-code">// Taken from: https://en.wiktionary.org/wiki/Hello_World#Translations</p>
			<p class="source-code">var helloList = []string{</p>
			<p class="source-code">  "Hello, world",</p>
			<p class="source-code">  "Καλημέρα κόσμε",</p>
			<p class="source-code">  "こんにちは世界",</p>
			<p class="source-code">  "سلام دنیا‎",</p>
			<p class="source-code">  "Привет, мир",</p>
			<p class="source-code">}</p>
			<p>Here, we're declaring a global variable, which is a list of strings, and initializing it with data. The text or strings in Go support multi-byte UFT-8 encoding, making them safe for any language. The type of list we're using here is called a slice. There are three types of lists in Go: slices, arrays, and maps. All three are collections of keys and values, where you use the key to get a value from the collection. Slice and array collections use a number as the key. The first key is always 0 in slices and arrays. Also, in slices and arrays, the numbers are contiguous, which means there is never a break in the sequence of numbers. With the <strong class="source-inline">map</strong> type, you get to choose the <strong class="source-inline">key</strong> type. You use this when you want to use some other data to look up the value in the map. For example, you could use a book's ISBN to look up its title and author:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">…</p>
			<p class="source-code">}</p>
			<p>Here, we're declaring a function. A function is some code that runs when called. You can pass data in the form of one or more variables to a function and optionally receive one or more variables back from it. The <strong class="source-inline">main()</strong> function in Go is special. The <strong class="source-inline">main()</strong> function is the entry point of your Go code. When your code runs, Go automatically calls <strong class="source-inline">main</strong> to get things started:</p>
			<p class="source-code">  // Seed random number generator using the current time</p>
			<p class="source-code">  rand.Seed(time.Now().UnixNano())</p>
			<p class="source-code">  // Generate a random number in the range of out list</p>
			<p class="source-code">  index := rand.Intn(len(helloList))</p>
			<p>In the preceding code, we are generating a random number. The first thing we need to do is ensure it's a good random number, so to do that, we must "seed" the random number generator. We seed it using the current time formatted to a Unix timestamp with nanoseconds. To get the time, we call the <strong class="source-inline">Now</strong> function in the <strong class="source-inline">time</strong> package. The <strong class="source-inline">Now</strong> function returns a struct type variable. Structs are a collection of properties and functions, a little like objects in other languages. In this case, we are calling the <strong class="source-inline">UnixNano</strong> function on that struct straight away. The <strong class="source-inline">UnixNano</strong> function returns a variable of the <strong class="source-inline">int64</strong> type, which is a 64-bit integer or, more simply, a number. This number is passed into <strong class="source-inline">rand.Seed</strong>. The <strong class="source-inline">rand.Seed</strong> function accepts an <strong class="source-inline">int64</strong> variable as its input. Note that the type of the variable from <strong class="source-inline">time.UnixNano</strong> and <strong class="source-inline">rand.Seed</strong> must be the same. Now, we've successfully seeded the random number generator. </p>
			<p>What we want is a number we can use to get a random message. We'll use <strong class="source-inline">rand.Intn</strong> for this job. This function gives us a random number between 0 and 1, minus the number you pass in. This may sound a bit strange, but it works out perfectly for what we're trying to do. This is because our list is a slice where the keys start from 0 and increment by 1 for each value. This means the last index is 1 less than the length of the slice.</p>
			<p>To show you what this means, here is some simple code:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  helloList := []string{</p>
			<p class="source-code">  "Hello, world",</p>
			<p class="source-code">  "Καλημέρα κόσμε",</p>
			<p class="source-code">  "こんにちは世界",</p>
			<p class="source-code">  "سلام دنیا‎",</p>
			<p class="source-code">  "Привет, мир",</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Println(len(helloList))</p>
			<p class="source-code">  fmt.Println(helloList[len(helloList)-1])</p>
			<p class="source-code">  fmt.Println(helloList[len(helloList)])</p>
			<p class="source-code">}</p>
			<p>This code prints the length of the list and then uses that length to print the last element. To do that, we must subtract 1, otherwise, we'd get an error, which is what the last line causes:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B14177_01_01.jpg" alt="Figure 1.01: Output displaying an error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.01: Output displaying an error</p>
			<p>Once we've generated our random number, we assign it to a variable. We do this with the <strong class="source-inline">:=</strong> notation, which is a very popular shortcut in Go. It tells the compiler to go ahead and assign that value to my variable and select the appropriate type for that value. This shortcut is one of the many things that makes Go feel like a dynamically typed language:</p>
			<p class="source-code">  // Call a function and receive multiple return values</p>
			<p class="source-code">  msg, err := hello(index)</p>
			<p>We then use that variable to call a function named <strong class="source-inline">hello</strong>. We'll look at <strong class="source-inline">hello</strong> in just a moment. The important thing to note is that we're receiving two values back from the function and we're able to assign them to two new variables, <strong class="source-inline">msg</strong> and <strong class="source-inline">err</strong>, using the <strong class="source-inline">:=</strong> notation:</p>
			<p class="source-code">func hello(index int) (string, error) {</p>
			<p class="source-code">…</p>
			<p class="source-code">}</p>
			<p>This code is the definition of the <strong class="source-inline">hello</strong> function; we're not showing the body for now. A function acts as a unit of logic that's called when and as often as is needed. When calling a function, the code that calls it stops running and waits for the function to finish running. Functions are a great tool for keeping your code organized and understandable. In the signature of <strong class="source-inline">hello</strong>, we've defined that it accepts a single <strong class="source-inline">int</strong> value and that it returns a <strong class="source-inline">string</strong> and an <strong class="source-inline">error</strong> value. Having an <strong class="source-inline">error</strong> as your last return value is a very common thing to have in Go. The code between the <strong class="source-inline">{}</strong> is the body of the function. The following code is what's run when the function's called:</p>
			<p class="source-code">  if index &lt; 0 || index &gt; len(helloList)-1 {</p>
			<p class="source-code">  // Create an error, convert the int type to a string</p>
			<p class="source-code">  return "", errors.New("out of range: " + strconv.Itoa(index))</p>
			<p class="source-code">  }</p>
			<p class="source-code">  return helloList[index], nil</p>
			<p>Here, we are inside the function; the first line of the body is an <strong class="source-inline">if</strong> statement. An <strong class="source-inline">if</strong> statement runs the code inside its <strong class="source-inline">{}</strong> if its Boolean expression is true. The Boolean expression is the logic between the <strong class="source-inline">if</strong> and the <strong class="source-inline">{</strong>. In this case, we're testing to see if the passed <strong class="source-inline">index</strong> variable is greater than 0 or less than the largest possible slice index key. </p>
			<p>If the Boolean expression were to be true, then our code would return an empty <strong class="source-inline">string</strong> and an <strong class="source-inline">error</strong>. At this point, the function would stop running, and the code that called the function would continue to run. If the Boolean expression were not true, its code would be skipped over, and our function would return a value from <strong class="source-inline">helloList</strong> and <strong class="source-inline">nil</strong>. In Go, <strong class="source-inline">nil</strong> represents something with no value and no type:</p>
			<p class="source-code">  // Handle any errors</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">  log.Fatal(err)</p>
			<p class="source-code">  }</p>
			<p>After we've run <strong class="source-inline">hello</strong>, the first thing we need to do is check to see if it ran successfully. We do this by checking the <strong class="source-inline">error</strong> value stored in <strong class="source-inline">err</strong>. If <strong class="source-inline">err</strong> is not equal to <strong class="source-inline">nil</strong>, then we know we have an error. Then, we call <strong class="source-inline">log.Fatal,</strong> which writes out a logging message and kills our app. Once the app's been killed, no more code runs:</p>
			<p class="source-code">  // Print our message to the console</p>
			<p class="source-code">  fmt.Println(msg)</p>
			<p>If there is no error, then we know that <strong class="source-inline">hello</strong> ran successfully and that the value of <strong class="source-inline">msg</strong> can be trusted to hold a valid value. The final thing we need to do is print the message to the screen via the Terminal.</p>
			<p>Here's how that looks:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B14177_01_02.jpg" alt="Figure 1.02: Output displaying valid values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.02: Output displaying valid values</p>
			<p>In this simple Go program, we've been able to cover a lot of key concepts that we'll explore in full in the coming chapters. </p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor021"/>Exercise 1.01: Using Variables, Packages, and Functions to Print Stars </h2>
			<p>In this exercise, we'll use some of what we learned about in the preceding example to print a random number, between 1 and 5, of stars (<strong class="source-inline">*</strong>) to the console. This exercise will give you a feel of what working with Go is like and some practice with using the features of Go we'll need going forward. Let's get started:</p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of the file:<p class="source-code">package main</p></li>
				<li>Now, add the imports we'll use in this file:<p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "math/rand"</p><p class="source-code">  "strings"</p><p class="source-code">  "time"</p><p class="source-code">)</p></li>
				<li>Create a <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Seed the random number generator:<p class="source-code">  rand.Seed(time.Now().UnixNano())</p></li>
				<li>Generate a random number between 0 and then add 1 to get a number between 1 and 5:<p class="source-code">  r := rand.Intn(5) + 1</p></li>
				<li>Use the string repeater to create a string with the number of stars we need:<p class="source-code">  stars := strings.Repeat("*", r)</p></li>
				<li>Print the string with the stars to the console with a new line character at the end and close the <strong class="source-inline">main()</strong> function:<p class="source-code">  fmt.Println(stars)</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the new folder, run the following:<p class="source-code">go run .</p></li>
			</ol>
			<p>The following is the output:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B14177_01_03.jpg" alt="Figure 1.03: Output displaying stars&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.03: Output displaying stars</p>
			<p>In this exercise, we created a runnable Go program by defining the <strong class="source-inline">main</strong> package with a <strong class="source-inline">main()</strong> function in it. We used the standard library by adding imports to packages. Those packages helped us generate a random number, repeat strings, and write to the console.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor022"/>Activity 1.01 Defining and Printing</h2>
			<p>In this activity, we are going to create a medical form for a doctor's office to capture a patient's name, age, and whether they have a peanut allergy: </p>
			<ol>
				<li value="1">Create a variable for the following:<ul><li>First name as a string</li><li>Family name as a string</li><li>Age as an <strong class="source-inline">int</strong></li><li>Peanut allergy as a <strong class="source-inline">bool</strong></li></ul></li>
				<li>Ensure they have an initial value.</li>
				<li>Print the values to the console.</li>
			</ol>
			<p>The following is the expected output:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B14177_01_04.jpg" alt="Figure 1.04: Expected output after assigning the variables&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.04: Expected output after assigning the variables</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 684</p>
			<p>Next, we'll start going into detail about what we've covered so far, so don't worry if you are confused or have a question about what you've seen so far.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor023"/>Declaring Variables</h2>
			<p>Now that you've had an overview of Go and completed your first exercise, we're going to dive deep. Our first stop on the journey is variables.</p>
			<p>A variable holds data for you temporarily so you can work with it. When you declare a variable, it needs four things: a statement that you are declaring a variable, a name for the variable, the type of data it can hold, and an initial value for it. Fortunately, some of the parts are optional, but that also means there's more than one way of defining a variable.</p>
			<p>We'll now cover all the ways you can declare a variable.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor024"/>Declaring a Variable Using var</h2>
			<p>Using <strong class="source-inline">var</strong> is the foundational way to declare a variable. Every other way we'll cover is a variation of this approach, typically by omitting parts of this definition. A full <strong class="source-inline">var</strong> definition with everything in place looks like this:</p>
			<p class="source-code">var foo string = "bar"</p>
			<p>The key parts are <strong class="source-inline">var</strong>, <strong class="source-inline">foo</strong>, <strong class="source-inline">string</strong>, and <strong class="source-inline">= "bar"</strong>:</p>
			<ul>
				<li> <strong class="source-inline">var</strong> is our declaration that we are defining a variable. </li>
				<li><strong class="source-inline">foo</strong> is the name of the variable. </li>
				<li><strong class="source-inline">string</strong> is the type of the variable. </li>
				<li><strong class="source-inline">= "bar"</strong> is its initial value.</li>
			</ul>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor025"/>Exercise 1.02: Declaring a Variable Using var</h2>
			<p>In this exercise, we'll declare two variables using the full <strong class="source-inline">var</strong> notation. Then, we'll print them to the console. You'll see that you can use the var notation anywhere in your code, which isn't true for all variable declaration notations. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file to it:</li>
				<li>In <strong class="source-inline">main.go</strong>, add the main package name to the top of the file:<p class="source-code">package main</p></li>
				<li>Add the imports:<p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">)</p></li>
				<li>Declare a variable at the package-level scope. We'll cover what scopes are in detail later:<p class="source-code">var foo string = "bar"</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Declare another variable using <strong class="source-inline">var</strong> in our function:<p class="source-code">  var baz string = "qux"</p></li>
				<li>Print both variables to the console:<p class="source-code">  fmt.Println(foo, baz)</p></li>
				<li>Close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p></li>
				<li>Save the file. Then, in the new folder, run the following:<p class="source-code">go run .</p><p>The following is the output:</p><p class="source-code">bar qux</p></li>
			</ol>
			<p>In this example, <strong class="source-inline">foo</strong> is declared at the package level while <strong class="source-inline">baz</strong> is declared at the function level. Where a variable is declared is important because where you declare a variable also limits what notation you can use to declare it.</p>
			<p>Next, we'll look at another way to use the <strong class="source-inline">var</strong> notation.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor026"/>Declaring Multiple Variables at Once with var</h2>
			<p>We can use a single <strong class="source-inline">var</strong> declaration to define more than one variable. Using this method is common when declaring package-level variables. The variables don't need to be of the same type, and they can all have their own initial values. The notation looks like this:</p>
			<p class="source-code">Var (</p>
			<p class="source-code">  &lt;name1&gt; &lt;type1&gt; = &lt;value1&gt;</p>
			<p class="source-code">  &lt;name2&gt; &lt;type2&gt; = &lt;value2&gt;</p>
			<p class="source-code">…</p>
			<p class="source-code">  &lt;nameN&gt; &lt;typeN&gt; = &lt;valueN&gt;</p>
			<p class="source-code">)</p>
			<p>You can have multiple of these types of declaration, which is a nice way to group related variables, thereby making your code more readable. You can use this notation in functions, but it's rare to see it used there. </p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor027"/>Exercise 1.03: Declaring Multiple Variables at Once with var</h2>
			<p>In this exercise, we'll declare multiple variables using one var statement, each with a different type and initial value. Then, we'll print the value of each variable to the console. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of the file:<p class="source-code">package main</p></li>
				<li> Add the imports:<p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "time"</p><p class="source-code">)</p></li>
				<li>Start the <strong class="source-inline">var</strong> declaration:<p class="source-code">var (</p></li>
				<li>Define three variables:<p class="source-code">  Debug     bool    = false</p><p class="source-code">  LogLevel  string  = "info"</p><p class="source-code">  startUpTime time.Time = time.Now()</p></li>
				<li>Close the <strong class="source-inline">var</strong> declaration:<p class="source-code">)</p></li>
				<li> In the <strong class="source-inline">main()</strong> function, print each variable to the console:<p class="source-code">func main() {</p><p class="source-code">  fmt.Println(Debug, LogLevel, startUpTime)</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the new folder, run the following:<p class="source-code">go run .</p><p>The following is the output:</p></li>
			</ol>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B14177_01_05.jpg" alt="Figure 1.05: Output displaying three variable values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.05: Output displaying three variable values</p>
			<p>In this exercise, we declared three variables using a single var statement. Your output looks different for the <strong class="source-inline">time.Time</strong> variable, but that's correct. The format is the same, but the time itself is different. </p>
			<p>Using the var notation like this is a good way to keep your code well organized and to save you some typing.</p>
			<p>Next, we'll start removing some of the optional parts of the var notation.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor028"/>Skipping the Type or Value When Declaring Variables</h2>
			<p>In real-world code, it's not common to use the full var notation. There are a few cases where you need to define a package-level variable with an initial value and tightly control its type. In those cases, you need the full notation. It'll be obvious when this is needed as you'll have a type mismatch of some kind, so don't worry too much about this for now. The rest of the time, you'll remove an optional part or use the short variable declaration.</p>
			<p>You don't need to include both the type and the initial value when declaring a variable. You can use just one or the other; Go works out the rest. If you have a type in the declaration but no initial value, Go uses the zero value for the type you picked. We'll talk more about what a zero value is in a later chapter. On the other hand, if you have an initial value and no type, Go has a ruleset for how to infer the types that are needed from the literal value you use. </p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor029"/>Exercise 1.04: Skipping the Type or Value When Declaring Variables</h2>
			<p>In this exercise, we'll update our previous exercise to skip the optional initial values or type declarations from our variable declaration. Then, we'll print the values to the console, as we did previously, to show that the result is the same. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of the file:<p class="source-code">package main</p></li>
				<li>Import the packages we'll need:<p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "time"</p><p class="source-code">)</p></li>
				<li>Start the multi-variable declaration:<p class="source-code">var (</p></li>
				<li>The <strong class="source-inline">bool</strong> in the first exercise has an initial value of false. That's a <strong class="source-inline">bool</strong>'s zero value, so we'll drop the initial value from its declaration:<p class="source-code">  Debug     bool</p></li>
				<li>The next two variables both have a non-zero value for their type, so we'll drop their type declaration:<p class="source-code">  LogLevel  = "info"</p><p class="source-code">  startUpTime = time.Now()</p></li>
				<li>Close the var declaration:<p class="source-code">)</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, print out each variable:<p class="source-code">func main() {</p><p class="source-code">  fmt.Println(Debug, LogLevel, startUpTime)</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the new folder, run the following:<p class="source-code">go run .</p><p>The following is the output:</p></li>
			</ol>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B14177_01_06.jpg" alt="Figure 1.06: Output displaying variable values despite not mentioning &#13;&#10;the type while declaring the variables&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.06: Output displaying variable values despite not mentioning the type while declaring the variables</p>
			<p>In this exercise, we were able to update the previous code to use a much more compact variable declaration. Declaring variables is something you'll have to do a lot, and not having to use the notation makes for a better experience when writing code.</p>
			<p>Next, we'll look at a situation where you can't skip any of the parts.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor030"/>Type Inference Gone Wrong</h2>
			<p>There are times when you'll need to use all the parts of the declaration, for example, when Go isn't able to guess the correct type you need. Let's take a look at an example of this:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "math/rand"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  var seed = 1234456789</p>
			<p class="source-code">  rand.Seed(seed)</p>
			<p class="source-code">}</p>
			<p>The following is the output:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B14177_01_07.jpg" alt="Figure 1.07: Output showing an error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.07: Output showing an error</p>
			<p>The issue here is that <strong class="source-inline">rand.Seed</strong> requires a variable of the <strong class="source-inline">int64</strong> type. Go's type inference rules interoperate a whole number, such as the one we used as an <strong class="source-inline">int</strong>. We'll look at the difference between them in more detail in a later chapter. To resolve this, we will add <strong class="source-inline">int64</strong> to the declaration. Here's how that looks:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "math/rand"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  var seed int64 = 1234456789</p>
			<p class="source-code">  rand.Seed(seed)</p>
			<p class="source-code">}</p>
			<p>Next, we'll look at an even quicker way to declare variables.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor031"/>Short Variable Declaration</h2>
			<p>When declaring variables in functions and functions only, we can use the <strong class="source-inline">:=</strong> shorthand. This shorthand allows us to make our declarations even shorter. It does this by allowing us to not have to use the <strong class="source-inline">var</strong> keyword and by always inferring the type from a required initial value. </p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor032"/>Exercise 1.05: Implementing Short Variable Declaration</h2>
			<p>In this exercise, we'll update our previous exercise to use a short variable declaration. Since you can only use a short variable declaration in a function, we'll move our variable out of the package scope. Where before <strong class="source-inline">Debug</strong> had a type but no initial value, we'll switch it back so that it has an initial value since that's required when using a short variable declaration. Finally, we'll print it to the console. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of the file:<p class="source-code">package main</p></li>
				<li>Import the packages we'll need:<p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "time"</p><p class="source-code">)</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Declare each variable using the short variable declaration notation:<p class="source-code">  Debug := false</p><p class="source-code">  LogLevel := "info"</p><p class="source-code">  startUpTime := time.Now()</p></li>
				<li>Print the variables to the console:<p class="source-code">  fmt.Println(Debug, LogLevel, startUpTime)</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the new folder, run the following:<p class="source-code">go run .</p></li>
			</ol>
			<p>The following is the output:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B14177_01_08.jpg" alt="Figure 1.08: Output displaying the variable values that were printed after &#13;&#10;using short variable declaration notation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.08: Output displaying the variable values that were printed after using short variable declaration notation</p>
			<p>In this exercise, we updated our previous code to use a very compact way to declare variables when we have an initial value to use.</p>
			<p>The <strong class="source-inline">:=</strong> shorthand is very popular with Go developers and the most common way in which variables get defined in real-world Go code. Developers like how it makes their code concise and compact while still being clear as to what's happening. </p>
			<p>Another shortcut is declaring multiple variables on the same line.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor033"/>Declaring Multiple Variables with a Short Variable Declaration</h2>
			<p>It's possible to declare multiple variables at the same time using a short variable declaration. They must all be on the same line, and each variable must have a corresponding initial value. The notation looks like <strong class="source-inline">&lt;var1&gt;, &lt;var2&gt;, …, &lt;varN&gt; := &lt;val1&gt;, &lt;val2&gt;, …, &lt;valN&gt;</strong>. The variable names are on the left-hand side of the <strong class="source-inline">:=</strong>, separated by a <strong class="source-inline">,</strong>. The initial values are on the right-hand side of the <strong class="source-inline">:=</strong> again, each separated by a <strong class="source-inline">,</strong>. The leftmost variable name gets the leftmost value. There must be an equal number of names and values. </p>
			<p>Here is an example that uses our previous exercise's code:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "time"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  Debug, LogLevel, startUpTime := false, "info", time.Now()</p>
			<p class="source-code">  fmt.Println(Debug, LogLevel, startUpTime)</p>
			<p class="source-code">}</p>
			<p>The following is the output:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B14177_01_09.jpg" alt="Figure 1.09: Example output displaying the variable values for the program &#13;&#10;with a variable declaring function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.09: Example output displaying the variable values for the program with a variable declaring function</p>
			<p>Sometimes, you do see real-word code like this. It's a little hard to read, so it's not common to see it in terms of literal values. This doesn't mean this isn't common since it's very common when calling functions that return multiple values. We'll cover this in detail when we look at functions in a later chapter.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor034"/>Exercise 1.06: Declaring Multiple Variables from a Function</h2>
			<p>In this exercise, we'll call a function that returns multiple values, and we'll assign each value to a new variable. Then, we'll print the values to the console. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of the file:<p class="source-code">package main</p></li>
				<li>Import the packages we'll need:<p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "time"</p><p class="source-code">)</p></li>
				<li>Create a function that returns three values:<p class="source-code">func getConfig() (bool, string, time.Time) {</p></li>
				<li>In the function, return three lital values, each separated by a <strong class="source-inline">,</strong>:<p class="source-code">  return false, "info", time.Now()</p></li>
				<li>Close the function:<p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Using a short variable declaration, capture the values returned from the function's three new variables:<p class="source-code">  Debug, LogLevel, startUpTime := getConfig()</p></li>
				<li>Print the three variables to the console:<p class="source-code">  fmt.Println(Debug, LogLevel, startUpTime)</p></li>
				<li>Close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p></li>
				<li>Save the file. Then, in the new folder, run the following:<p class="source-code">go run .</p><p>The following is the output:</p><div id="_idContainer019" class="IMG---Figure"><img src="image/B14177_01_10.jpg" alt="Figure 1.10: Output displaying the variable values for the program with the variable declaring function&#13;&#10;"/></div></li>
			</ol>
			<p> </p>
			<p class="figure-caption">Figure 1.10: Output displaying the variable values for the program with the variable declaring function</p>
			<p>In this exercise, we were able to call a function that returned multiple values and capture them using a short variable declaration in one line. If we used the <strong class="source-inline">var</strong> notation, it would look like this:</p>
			<p class="source-code">var (</p>
			<p class="source-code">  Debug bool</p>
			<p class="source-code">  LogLevel string</p>
			<p class="source-code">  startUpTime time.Time</p>
			<p class="source-code">)</p>
			<p class="source-code">Debug, LogLevel, startUpTime = getConfig()</p>
			<p>Short variable notation is a big part of how Go has the feel of a dynamic language.</p>
			<p>We're not quite done with <strong class="source-inline">var</strong> yet, though. It still has a useful trick up its sleeve.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor035"/>Using var to Declare Multiple Variables in One Line </h2>
			<p>While it's more common to use a short variable declaration, you can use var to define multiple variables on a single line. One limitation of this is that, when declaring the type, all the values must have the same type. If you use an initial value, then each value infers its type from the literal value so that they can differ. Here's an example:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "time"</p>
			<p class="source-code">)</p>
			<p class="source-code">func getConfig() (bool, string, time.Time) {</p>
			<p class="source-code">  return false, "info", time.Now()</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  // Type only</p>
			<p class="source-code">  var start, middle, end float32</p>
			<p class="source-code">  fmt.Println(start, middle, end)</p>
			<p class="source-code">  // Initial value mixed type</p>
			<p class="source-code">  var name, left, right, top, bottom = "one", 1, 1.5, 2, 2.5</p>
			<p class="source-code">  fmt.Println(name, left, right, top, bottom)</p>
			<p class="source-code">  // works with functions also</p>
			<p class="source-code">  var Debug, LogLevel, startUpTime = getConfig()</p>
			<p class="source-code">  fmt.Println(Debug, LogLevel, startUpTime)</p>
			<p class="source-code">}</p>
			<p>The following is the output:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B14177_01_11.jpg" alt="Figure 1.11: Output displaying variable values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.11: Output displaying variable values</p>
			<p>Most of these are more compact when using a short variable declaration. This fact means they don't come up in real-world code much. The exception is the type-only example. This notation can be useful when you need many variables of the same type, and you need to control that type carefully.</p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor036"/>Non-English Variable Names</h2>
			<p>Go is a UTF-8 compliant language, which means you can define variables' names using alphabets other than the Latin alphabet that, for example, English uses. There are some limitations regarding what the name of a variable can be. The first character of the name must be a letter or <strong class="source-inline">_</strong>. The rest can be a mixture of letters, numbers, and <strong class="source-inline">_</strong>. Let's have a look at what this looks like:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "time"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  デバッグ := false</p>
			<p class="source-code">  日志级别 := "info"</p>
			<p class="source-code">  ይጀምሩ := time.Now()</p>
			<p class="source-code">  _A1_Μείγμα := "</p>
			<p class="source-code">"</p>
			<p class="source-code">  fmt.Println(デバッグ, 日志级别, ይጀምሩ, _A1_Μείγμα)</p>
			<p class="source-code">}</p>
			<p>The following is the output:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B14177_01_12.jpg" alt="Figure 1.12: Output showing variable values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.12: Output showing variable values</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="bold">Languages and Language</strong>: Not all programming languages allow you to use UTF-8 characters as variables and function names. This feature could be one of the reasons why Go has become so popular in Asian countries, particularly in China.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor037"/>Changing the Value of a Variable</h2>
			<p>Now that we've defined our variables, let's see what we can do with them. First, let's change the value from its initial value. To do that, we use similar notation to when we set an initial value. This looks like <strong class="source-inline">&lt;variable&gt; = &lt;value&gt;</strong>.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor038"/>Exercise 1.07: Changing the Value of a Variable</h2>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of the file:<p class="source-code">package main</p></li>
				<li>Import the packages we'll need:<p class="source-code">import "fmt"</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Declare a variable:<p class="source-code">  offset := 5</p></li>
				<li>Print the variable to the console:<p class="source-code">  fmt.Println(offset)</p></li>
				<li>Change the value of the variable:<p class="source-code">  offset = 10</p></li>
				<li>Print it to the console again and close the <strong class="source-inline">main()</strong> function:<p class="source-code">  fmt.Println(offset)</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the new folder, run the following:<p class="source-code">go run .</p></li>
			</ol>
			<p>The following is the output before changing the variable's value:</p>
			<p class="source-code">5</p>
			<p class="source-code">10</p>
			<p>In this example, we've changed the value of offset from its initial value of <strong class="source-inline">5</strong> to <strong class="source-inline">10</strong>. Anywhere you use a raw value, such as <strong class="source-inline">5</strong> and <strong class="source-inline">10</strong> in our example, you can use a variable. Here's how that looks:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"var defaultOffset = 10 func main() {</p>
			<p class="source-code">  offset := defaultOffset</p>
			<p class="source-code">  fmt.Println(offset)</p>
			<p class="source-code">  offset = offset + defaultOffset</p>
			<p class="source-code">  fmt.Println(offset)</p>
			<p class="source-code">}</p>
			<p>The following is the output after changing the variable's value:</p>
			<p class="source-code">10</p>
			<p class="source-code">20</p>
			<p>Next, we'll look at how we can change multiple variables in a one-line statement.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor039"/>Changing Multiple Values at Once</h2>
			<p>In the same way that you can declare multiple variables in one line, you can also change the value of more than one variable at a time. The syntax is similar, too; it looks like <strong class="source-inline">&lt;var1&gt;, &lt;var2&gt;, …, &lt;varN&gt; = &lt;val1&gt;, &lt;val2&gt;, …, &lt;valN&gt;</strong>.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor040"/>Exercise 1.08: Changing Multiple Values at Once</h2>
			<p>In this exercise, we'll define some variables and use a one-line statement to change their values. Then, we'll print their new values to the console. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of the file:<p class="source-code">package main</p></li>
				<li>Import the packages we'll need:<p class="source-code">import "fmt"</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Declare our variables with an initial value:<p class="source-code">  query, limit, offset := "bat", 10, 0</p></li>
				<li>Change each variable's values using a one-line statement:<p class="source-code">  query, limit, offset = "ball", offset, 20</p></li>
				<li>Print the values to the console and close the <strong class="source-inline">main()</strong> function:<p class="source-code">  fmt.Println(query, limit, offset)</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the new folder, run the following:<p class="source-code">go run .</p></li>
			</ol>
			<p>The following is the output showing the changed variable values using a single statement:</p>
			<p class="source-code">ball 0 20</p>
			<p>In this exercise, we were able to change multiple variables in a single line. This approach would also work when calling functions, just as it does with a variable declaration. You need to be careful with a feature like this to ensure that, first and foremost, your code is easy to read and understand. If using a one-line statement like this makes it hard to know what the code is doing, then it's better to take up more lines to write the code.</p>
			<p>Next, we'll look at what operators are and how they can be used to change your variables in interesting ways.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor041"/>Operators</h2>
			<p>While variables hold the data for your application, they become truly useful when you start using them to build the logic of your software. Operators are the tools you use to work with your software's data. With operators, you can compare data to other data. For example, you can check whether a price is too low or too high in a trading application. You can also use operators to manipulate data. For example, you can use operators to add the costs of all the items in a shopping cart to get the total price. </p>
			<p>The following list mentions groups of operators:</p>
			<ul>
				<li>Arithmetic operators<p>Used for math-related tasks such as addition, subtraction, and multiplication.</p></li>
				<li>Comparison operators<p>Used to compare two values; for example, are they are equal, not equal, less than, or greater than each other.</p></li>
				<li>Logical operators<p>Used with Boolean values to see whether they are both true, only one is true, or whether a <strong class="source-inline">bool</strong> is false.</p></li>
				<li>Address operators<p>We'll cover these in detail soon when we look at pointers. These are used to work with them.</p></li>
				<li>Receive operators<p>Used when working with Go channels, which we'll cover in a later chapter.</p></li>
			</ul>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor042"/>Exercise 1.09 Using Operators with Numbers</h2>
			<p>In this exercise, we are going to simulate a restaurant bill. To build our simulation, we'll need to use mathematic and comparison operators. We'll start by exploring all the major uses for operators.</p>
			<p>In our simulation, we'll sum everything together and work out the tip based on a percentage. Then, we'll use a comparison operator to see whether the customer gets a reward. Let's get started:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We have considered US Dollar as the currency for this exercise. You may consider any currency of your choice; the main focus here is the operations.</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file to it:</li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of the file:<p class="source-code">package main</p></li>
				<li> Import the packages you'll need:<p class="source-code">import "fmt"</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Create a variable to hold the total. For this item on the bill, the customer purchased 2 items that cost 13 USD. We use  <strong class="source-inline">*</strong> to do the multiplication. Then, we print a subtotal:<p class="source-code">  // Main course</p><p class="source-code">  var total float64 = 2 <strong class="bold">*</strong> 13</p><p class="source-code">  fmt.Println("Sub  :", total)</p></li>
				<li>Here, they purchased 4 items that cost 2.25 USD. We use multiplication to get the total of these items and then use <strong class="source-inline">+</strong> to add it to the previous total value and then assign that back to the total:<p class="source-code">  // Drinks</p><p class="source-code">  total = total <strong class="bold">+</strong> (4 <strong class="bold">*</strong> 2.25)</p><p class="source-code">  fmt.Println("Sub  :", total)</p></li>
				<li>This customer is getting a discount of 5 USD. Here, we use the <strong class="source-inline">–</strong> to subtract 5 USD from the total:<p class="source-code">  // Discount</p><p class="source-code">  total = total <strong class="bold">-</strong> 5</p><p class="source-code">  fmt.Println("Sub  :", total)</p></li>
				<li>Then, we use multiplication to calculate a 10% tip:<p class="source-code">  // 10% Tip</p><p class="source-code">  tip := total * 0.1</p><p class="source-code">  fmt.Println("Tip  :", tip)</p></li>
				<li>Finally, we add the tip to the total:<p class="source-code">  total = total + tip</p><p class="source-code">  fmt.Println("Total:", total)</p></li>
				<li>The bill will be split between two people. Use <strong class="source-inline">/</strong> to divide the total into two parts:<p class="source-code">  // Split bill</p><p class="source-code">  split := total <strong class="bold">/</strong> 2</p><p class="source-code">  fmt.Println("Split:", split)</p></li>
				<li>Here, we'll calculate whether the customer gets a reward. First, we'll set the <strong class="source-inline">visitCount</strong> and then add 1 USD to this visit:<p class="source-code">  // Reward every 5th visit</p><p class="source-code">  visitCount := 24</p><p class="source-code">  visitCount = visitCount + 1</p></li>
				<li>Then, we'll use <strong class="source-inline">%</strong> to give us any remainder after dividing the <strong class="source-inline">visitCount</strong> by 5 USD:<p class="source-code">  remainder := visitCount <strong class="bold">%</strong> 5</p></li>
				<li>The customer gets a reward on every fifth visit. If the remainder is 0, then this is one of those visits. Use the <strong class="source-inline">==</strong> operator to check whether the remainder is 0:<p class="source-code">  if remainder <strong class="bold">==</strong> 0 {</p></li>
				<li>If it is, print a message that they get a reward:<p class="source-code">    fmt.Println("With this visit, you've earned a reward.")</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the new folder, run the following:<p class="source-code">go run .</p></li>
			</ol>
			<p>The following is the output:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B14177_01_13.jpg" alt="Figure 1.13: Output of operators used with numbers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.13: Output of operators used with numbers</p>
			<p>In this exercise, we used the math and comparison operators with numbers. They allowed us to model a complex situation – calculating a restaurant bill. There are lots of operators and which ones you can use vary with the different types of values. For example, as well as there being an addition operator for numbers, you can use the <strong class="source-inline">+</strong> symbol to join strings together. Here's this in action:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  givenName := "John"</p>
			<p class="source-code">  familyName := "Smith"</p>
			<p class="source-code">  fullName := givenName + " " + familyName</p>
			<p class="source-code">  fmt.Println("Hello,", fullName)</p>
			<p class="source-code">}</p>
			<p>The following is the output:</p>
			<p class="source-code">Hello, John Smith</p>
			<p>For some situations, there are some shortcuts we can make with operators. We'll go over this in the next section.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="bold">Bitwise Operators: </strong>Go has all the familiar bitwise operators you'd find in programming languages. If you know what bitwise operators are, then there will be no surprises here for you. If you don't know what bitwise operators are, don't worry – they aren't common in real-world code.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor043"/>Shorthand Operator</h2>
			<p>There are a few shorthand assignment operators when you want to perform operations to an existing value with its own value. For example:</p>
			<ul>
				<li>--: Reduce a number by 1</li>
				<li>++: Increase a number by 1</li>
				<li>+=: Add and assign</li>
				<li>-=: Subtract and assign</li>
			</ul>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor044"/>Exercise 1.10: Implementing Shorthand Operators</h2>
			<p>In this exercise, we'll use some examples of operator shorthand to show how they can make your code more compact and easier to write. We'll create some variables then use shorthand to change them, printing them out as we go. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of the file:<p class="source-code">package main</p></li>
				<li> Import the packages we'll need:<p class="source-code">import "fmt"</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Create a variable with an initial value:<p class="source-code">  count := 5</p></li>
				<li>We'll add to it and then assign the result back to itself. Then, we'll print it out:<p class="source-code">  count += 5</p><p class="source-code">  fmt.Println(count)</p></li>
				<li>Increment the value by 1 and then print it out:<p class="source-code">  count++</p><p class="source-code">  fmt.Println(count)</p></li>
				<li>Decrement it by 1 and then print it out:<p class="source-code">  count--</p><p class="source-code">  fmt.Println(count)</p></li>
				<li>Subtract and assign the result back to itself. Print out the new value:<p class="source-code">  count -= 5</p><p class="source-code">  fmt.Println(count)</p></li>
				<li>There is also a shorthand that works with strings. Define a string:<p class="source-code">  name := "John"</p></li>
				<li>Next, we'll append another string to the end of it and then print it out:<p class="source-code">  name += " Smith"</p><p class="source-code">  fmt.Println("Hello,", name)</p></li>
				<li>Close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p></li>
				<li>Save the file. Then, in the new folder, run the following:<p class="source-code">go run .</p></li>
			</ol>
			<p>The following is the output:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B14177_01_14.jpg" alt="Figure 1.14: Output using shorthand operators&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.14: Output using shorthand operators</p>
			<p>In this exercise, we used some shorthand operators. One set focused on modification and then assignment. This type of operation is common, and having these shortcuts makes coding more engaging. The other operators are increment and decrement. These are useful in loops when you need to step over data one at a time. These shortcuts make it clear what you're doing to anyone who reads your code.</p>
			<p>Next, we'll look at comparing values to each other in detail.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor045"/>Comparing Values</h2>
			<p>Logic in applications is a matter of having your code make a decision. These decisions get made by comparing the values of variables to the rules you define. These rules come in the form of comparisons. We use another set of operators to make these comparisons. The result of these comparisons is always true or false. You'll also often need to make multiples of these comparisons to make a single decision. To help with that, we have logical operators.</p>
			<p>These operators, for the most part, work with two values and always result in a Boolean value. You can only use logical operators with Boolean values. Let's take a look at comparison operators and logical operators in more detail:</p>
			<p><strong class="bold">Comparison Operators</strong></p>
			<ul>
				<li><strong class="source-inline">==</strong> True if two values are the same</li>
				<li><strong class="source-inline">!=</strong> True if two values are not the same</li>
				<li><strong class="source-inline">&lt;</strong> True if the left value is less than the right value</li>
				<li><strong class="source-inline">&lt;=</strong> True if the left value is less or equal to the right value</li>
				<li><strong class="source-inline">&gt;</strong> True if the left value is greater than the right value</li>
				<li><strong class="source-inline">&gt;=</strong> True if the left value is greater than or equal to the right value</li>
			</ul>
			<p><strong class="bold">Logical Operators</strong></p>
			<ul>
				<li><strong class="source-inline">&amp;&amp;</strong> True if the left and right values are both true</li>
				<li><strong class="source-inline">||</strong> True if one or both the left and right values are true</li>
				<li><strong class="source-inline">!</strong> This operator only works with a single value and results in true if the value is false</li>
			</ul>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor046"/>Exercise 1.11: Comparing Values</h2>
			<p>In this exercise, we'll use comparison and logical operators to see what Boolean results we get when testing different conditions. We are testing to see what level of membership a user has based on the number of visits they've had. </p>
			<p>Our membership levels are as follows:</p>
			<ul>
				<li>Sliver: Between 10 and 20 visits inclusively</li>
				<li>Gold: Between 21 and 30 visits inclusively</li>
				<li>Platinum: Over 30 visits</li>
			</ul>
			<p>Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of the file:<p class="source-code">package main</p></li>
				<li>Import the packages we'll need:<p class="source-code">import "fmt"</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Define our <strong class="source-inline">visits</strong> variable and initialize it with a value:<p class="source-code">  visits := 15</p></li>
				<li>Use the equals operator to see if this is their first visit. Then, print the result to the console:<p class="source-code">  fmt.Println("First visit   :", visits == 1)</p></li>
				<li>Use the not equal operator to see if they are a returning visitor:<p class="source-code">  fmt.Println("Return visit  :", visits != 1)</p></li>
				<li>Let's check whether they are a Silver member using the following code:<p class="source-code">  fmt.Println("Silver member   :", visits &gt;= 10 &amp;&amp; visits &lt; 21)</p></li>
				<li>Let's check whether they are a Gold member using the following code:<p class="source-code">  fmt.Println("Gold member   :", visits &gt; 20 &amp;&amp; visits &lt;= 30)</p></li>
				<li>Let's check whether they are a Platinum member using the following code:<p class="source-code">  fmt.Println("Platinum member :", visits &gt; 30)</p></li>
				<li>Close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p></li>
				<li>Save the file. Then, in the new folder, run the following:<p class="source-code">go run .</p></li>
			</ol>
			<p>The following is the output:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B14177_01_15.jpg" alt="Figure 1.15: Output displaying the comparison result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.15: Output displaying the comparison result</p>
			<p>In this exercise, we used comparison and logical operators to make decisions about data. You can combine these operators in an unlimited number of ways to express almost any type of logic your software needs to make.</p>
			<p>Next, we'll look at what happens when you don't give a variable an initial value.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor047"/>Zero Values</h2>
			<p>The zero value of a variable is the empty or default value for that variable's type. Go has a set of rules stating that the zero values are for all the core types. Let's take a look:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B14177_01_16.jpg" alt="Figure 1.16: Variable types and their zero values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.16: Variable types and their zero values</p>
			<p>There are other types, but they are all derived from these core types, so the same rules still apply.</p>
			<p>We'll look at the zero values of some types in the upcoming exercise. </p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor048"/>Exercise 1.12 Zero Values</h2>
			<p>In this example, we'll define some variables without an initial value. Then, we'll print out their values. We're using <strong class="source-inline">fmt.Printf </strong>to help us in this exercise as we can get more detail about a value's type. <strong class="source-inline">fmt.Printf</strong> uses a template language that allows us to transform passed values. The substitution we're using is <strong class="source-inline">%#v</strong>. This transformation is a useful tool for showing a variable's value and type. Some other common substitutions you can try are as follows:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B14177_01_17.jpg" alt="Figure 1.17: Table on substitutions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.17: Table on substitutions</p>
			<p>When using <strong class="source-inline">fmt.Printf</strong>, you need to add the new line symbol yourself, which you do by adding <strong class="source-inline">\n</strong> at the end of the string. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of the file:<p class="source-code">package main</p></li>
				<li>Import the packages we'll need:<p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "time"</p><p class="source-code">)</p></li>
				<li> Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Declare and print an integer:<p class="source-code">  var count int</p><p class="source-code">  fmt.Printf("Count  : %#v \n", count) </p></li>
				<li>Declare and print a <strong class="source-inline">float</strong>:<p class="source-code">  var discount float64</p><p class="source-code">  fmt.Printf("Discount : %#v \n", discount) </p></li>
				<li>Declare and print a Boolean:<p class="source-code">  var debug bool</p><p class="source-code">  fmt.Printf("Debug  : %#v \n", debug) </p></li>
				<li>Declare and print a <strong class="source-inline">string</strong>:<p class="source-code">  var message string</p><p class="source-code">  fmt.Printf("Message  : %#v \n", message) </p></li>
				<li>Declare and print a collection of strings:<p class="source-code">  var emails []string</p><p class="source-code">  fmt.Printf("Emails   : %#v \n", emails) </p></li>
				<li>Declare and print a struct (a type composed of other types; we will cover this in a later chapter):<p class="source-code">  var startTime time.Time</p><p class="source-code">  fmt.Printf("Start  : %#v \n", startTime)</p></li>
				<li>Close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p></li>
				<li>Save the file. Then, in the new folder, run the following:<p class="source-code">go run .</p></li>
			</ol>
			<p>The following is the output:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B14177_01_18.jpg" alt="Figure 1.18: Output displaying zero values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.18: Output displaying zero values</p>
			<p>In this exercise, we defined a variety of variable types without an initial value. Then, we printed them out using <strong class="source-inline">fmt.Printf</strong> to expose more detail about the values. Knowing what the zero values are and how Go controls them allows you to avoid bugs and write concise code.</p>
			<p>Next, we'll look are what pointers are and how they can enable you to write efficient software.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor049"/>Value versus Pointer</h2>
			<p>With values such as <strong class="source-inline">int</strong>, <strong class="source-inline">bool</strong>, and <strong class="source-inline">string</strong>, when you pass them to a function, Go makes a copy of the value, and it's the copy that's used in the function. This copying means that a change that's made to the value in the function doesn't affect the value that you used when calling the function. </p>
			<p>Passing values by copying tends to end up with code that has fewer bugs. With this method of passing values, Go can use its simple memory management system called the stack. The downside is that copying uses up more and more memory as values get passed from function to function. In real-world code, functions tend to be small, and values get passed to lots of functions, so copying by value can sometimes end up using much more memory than is needed.</p>
			<p>There is an alternative to copying that uses less memory. Instead of passing a value, we create something called a pointer and then pass that to functions. A pointer is not a value itself, and you can't do anything useful with a pointer other than getting a value using it. You can think of a pointer as directions to a value you want, and to get to the value, you must follow the directions. If you use a pointer, Go won't make a copy of the value when passing a pointer to a function.</p>
			<p>When creating a pointer to a value, Go can't manage the value's memory using the stack. This is because the stack relies on simple scope logic to know when it can reclaim the memory that's used by a value, and having a pointer to a variable means these rules don't work. Instead, Go puts the value on the heap. The heap allows the value to exist until no part of your software has a pointer to it anymore. Go reclaims these values in what it calls its garbage collection process. This garbage collection happens periodically in the background, and you don't need to worry about it.</p>
			<p>Having a pointer to a value means that a value is put on the heap, but that's not the only reason that happens. Working out whether a value needs to be put on the heap is called escape analysis. There are times when a value with no pointers is put on the heap, and it's not always clear why.</p>
			<p>You have no direct control over whether a value is put on the stack or the heap. Memory management is not part of Go's language specification. Memory management is considered an internal implementation detail. This means it could be changed at any time, and that what we've spoken about are only general guidelines and not fixed rules and could change at a later date.</p>
			<p>While the benefits of using a pointer over a value that gets passed to lots of functions are clear for memory usage, it's not so clear for CPU usage. When a value gets copied, Go needs CPU cycles to get that memory and then release it later. Using a pointer avoids this CPU usage when passing it to a function. On the other hand, having a value on the heap means that it then needs to be managed by the complex garbage collection process. This process can become a CPU bottleneck in certain situations, for example, if there are lots of values on the heap. When this happens, the garbage collector has to do lots of checking, which uses up CPU cycles. There is no correct answer here, and the best approach is the classic performance optimization one. First, don't prematurely optimize. When you do have a performance problem, measure before you make a change, and then measure after you've made a change.</p>
			<p>Beyond performance, you can use pointers to change your code's design. Sometimes, using pointers allows a cleaner interface and simplifies your code. For example, if you need to know whether a value is present or not, a non-pointer value always has at least its zero value, which could be valid in your logic. You can use a pointer to allow for an <strong class="source-inline">is not set</strong> state as well as holding a value. This is because pointers, as well as holding the address to a value, can also be <strong class="source-inline">nil</strong>, which means there is no value. In Go, <strong class="source-inline">nil</strong> is a special type that represents something not having a value.</p>
			<p>The ability for a pointer to be nil also means that it's possible to get the value of a pointer when it doesn't have a value associated with it, which means you'll get a runtime error. To prevent runtime errors, you can compare a pointer to nil before trying to get its value. This looks like <strong class="source-inline">&lt;pointer&gt; != nil</strong>. You can compare pointers with other pointers of the same type, but they only result in true if you are comparing a pointer to itself. No comparison of the associated values gets made.</p>
			<p>As a beginner in the language, I suggest avoiding pointers until they become necessary, either because you have a performance problem or because having a pointer makes your code cleaner.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor050"/>Getting a Pointer</h2>
			<p>To get a pointer, you have a few options. You can declare a variable as being a pointer type using a <strong class="source-inline">var</strong> statement. You can do this by adding an <strong class="source-inline">*</strong> at the front of most types. This notation looks like <strong class="source-inline">var &lt;name&gt; *&lt;type&gt;</strong>. The initial value of a variable that uses this method is <strong class="source-inline">nil</strong>. You can use the built-in <strong class="source-inline">new</strong> function for this. This function is intended to be used to get some memory for a type and return a pointer to that address. The notation looks like <strong class="source-inline">&lt;name&gt; := new(&lt;type&gt;).</strong> The <strong class="source-inline">new</strong> function can be used with <strong class="source-inline">var</strong> too. You can also get a pointer from an existing variable using <strong class="source-inline">&amp;</strong>. This looks like <strong class="source-inline">&lt;var1&gt; := &amp;&lt;var2&gt;.</strong></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor051"/>Exercise 1.13: Getting a Pointer</h2>
			<p>In this exercise, we'll use each of the methods we can use to get a pointer variable. Then, we'll print them to the console using <strong class="source-inline">fmt.Printf</strong> to see what their type and value is. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of the file:<p class="source-code">package main</p></li>
				<li> Import the packages we'll need:<p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "time"</p><p class="source-code">)</p></li>
				<li> Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Declare a pointer using a <strong class="source-inline">var</strong> statement:<p class="source-code">  var count1 *int</p></li>
				<li>Create a variable using <strong class="source-inline">new</strong>:<p class="source-code">  count2 := new(int)</p></li>
				<li>You can't take the address of a literal number. Create a temporary variable to hold a number:<p class="source-code">  countTemp := 5</p></li>
				<li>Using <strong class="source-inline">&amp;</strong>, create a pointer from the existing variable:<p class="source-code">  count3 := &amp;countTemp</p></li>
				<li>It's possible to create a pointer from some types without a temporary variable. Here, we're using our trusty <strong class="source-inline">time</strong> struct:<p class="source-code">  t := &amp;time.Time{}</p></li>
				<li>Print each out using <strong class="source-inline">fmt.Printf</strong>:<p class="source-code">  fmt.Printf("count1: %#v\n", count1)</p><p class="source-code">  fmt.Printf("count2: %#v\n", count2)</p><p class="source-code">  fmt.Printf("count3: %#v\n", count3)</p><p class="source-code">  fmt.Printf("time  : %#v\n", t)</p></li>
				<li>Close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p></li>
				<li>Save the file. Then, in the new folder, run the following:<p class="source-code">go run .</p></li>
			</ol>
			<p>The following is the output:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B14177_01_19.jpg" alt="Figure 1.19: Output after creating a pointer&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.19: Output after creating a pointer</p>
			<p>In this exercise, we looked at three different ways of creating a pointer. Each one is useful, depending on what your code needs. With the <strong class="source-inline">var</strong> statement, the pointer has a value of nil, while the others already have a value address associated with them. For the <strong class="source-inline">time</strong> variable, we can see the value, but we can tell it's a pointer because its output starts with an <strong class="source-inline">&amp;</strong>.</p>
			<p>Next, we'll see how we can get a value from a pointer.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor052"/>Getting a Value from a Pointer</h2>
			<p>In the previous exercise, when we printed out the pointer variables for the <strong class="source-inline">int</strong> pointers to the console, we either got nil or saw a memory address. To get to the value a pointer is associated with, you dereference the value using <strong class="source-inline">*</strong> in front of the variable name. This looks like <strong class="source-inline">fmt.Println(*&lt;val&gt;)</strong>.</p>
			<p>Dereferencing a zero or <strong class="source-inline">nil</strong> pointer is a common bug in Go software as the compiler can't warn you about it, and it happens when the app is running. Therefore, it's always best practice to check that a pointer is not <strong class="source-inline">nil</strong> before dereferencing it unless you are certain it's not <strong class="source-inline">nil</strong>.</p>
			<p>You don't always need to dereference; for example, when a property or function is on a struct. Don't worry too much about when you shouldn't be dereferencing as Go gives you clear errors regarding when you can and can't dereference a value.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor053"/>Exercise 1.14: Getting a Value from a Pointer</h2>
			<p>In this exercise, we'll update our previous exercise to dereference the values from the pointers. We'll also add <strong class="source-inline">nil</strong> checks to prevent us from getting any errors. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of the file:<p class="source-code">package main</p></li>
				<li>Import the packages we'll need:<p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "time"</p><p class="source-code">)</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Our pointers are declared in the same way as they were previously:<p class="source-code">  var count1 *int</p><p class="source-code">  count2 := new(int)</p><p class="source-code">  countTemp := 5</p><p class="source-code">  count3 := &amp;countTemp</p><p class="source-code">  t := &amp;time.Time{}</p></li>
				<li>For count 1, 2, and 3, we need to add a <strong class="source-inline">nil</strong> check and add <strong class="source-inline">*</strong> in front of the variable name:<p class="source-code">  if count1 != nil {</p><p class="source-code">  fmt.Printf("count1: %#v\n", *count1)</p><p class="source-code">  }</p><p class="source-code">  if count2 != nil {</p><p class="source-code">  fmt.Printf("count2: %#v\n", *count2)</p><p class="source-code">  }</p><p class="source-code">  if count3 != nil {</p><p class="source-code">  fmt.Printf("count3: %#v\n", *count3)</p><p class="source-code">  }</p></li>
				<li>We'll also add a <strong class="source-inline">nil</strong> check for our <strong class="source-inline">time</strong> variable:<p class="source-code">  if t != nil {</p></li>
				<li>We'll dereference the variable using <strong class="source-inline">*</strong>, just like we did with the <strong class="source-inline">count</strong> variables:<p class="source-code">  fmt.Printf("time  : %#v\n", *t)</p></li>
				<li>Here, we're calling a function on our <strong class="source-inline">time</strong> variable. This time, we don't need to dereference it:<p class="source-code">  fmt.Printf("time  : %#v\n", t.String())</p></li>
				<li>Close the <strong class="source-inline">nil</strong> check:<p class="source-code">  }</p></li>
				<li>Close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p></li>
				<li>Save the file. Then, in the new folder, run the following:<p class="source-code">go run .</p></li>
			</ol>
			<p>The following is the output:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B14177_01_20.jpg" alt="Figure 1.20: Output displaying the values that were obtained using pointers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.20: Output displaying the values that were obtained using pointers</p>
			<p>In this exercise, we used dereferencing to get the values from our pointers. We also used nil checks to prevent dereferencing errors. From the output of this exercise, we can see that <strong class="source-inline">count1</strong> was a nil value and that we'd have gotten an error if we tried to dereference. <strong class="source-inline">count2</strong> was created using <strong class="source-inline">new</strong>, and its value is a zero value for its type. <strong class="source-inline">count3</strong> also had a value that matches the value of the variable we got the pointer from. With our <strong class="source-inline">time</strong> variable, we were able to dereference the whole struct, which is why our output doesn't start with an <strong class="source-inline">&amp;</strong>.</p>
			<p>Next, we'll look at how using a pointer allows us to change the design of our code.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor054"/>Function Design with Pointers</h2>
			<p>We'll cover functions in more detail in a later chapter, but you know enough from what we've done so far to see how using a pointer can change how you use a function. A function must be coded to accept pointers, and it's not something that you can choose whether to do or not. If you have a pointer variable or have passed a pointer of a variable to a function, any changes that are made to the value of the variable in the function also affect the value of the variable outside of the function. </p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor055"/>Exercise 1.15: Function Design with Pointers</h2>
			<p>In this exercise, we'll create two functions: one that accepts a number by value, adds 5 to it, and then prints the number to the console; and another function that accepts a number as a pointer, adds 5 to it, and then prints the number out. We'll also print the number out after calling each function to assess what effect it has on the variable that was passed to the function. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of the file:<p class="source-code">package main</p></li>
				<li> Import the packages we'll need:<p class="source-code">import "fmt"</p></li>
				<li>Create a function that takes an <strong class="source-inline">int</strong> as an argument:<p class="source-code">func add5Value(count int) {</p></li>
				<li>Add <strong class="source-inline">5</strong> to the passed number:<p class="source-code">  count += 5</p></li>
				<li>Print the updated number to the console:<p class="source-code">  fmt.Println("add5Value   :", count)</p></li>
				<li>Close the function:<p class="source-code">}</p></li>
				<li>Create another function that takes an <strong class="source-inline">int</strong> pointer:<p class="source-code">func add5Point(count *int) {</p></li>
				<li>Dereference the value and add <strong class="source-inline">5</strong> to it:<p class="source-code">  *count += 5</p></li>
				<li>Print out the updated value of <strong class="source-inline">count</strong> and dereference it:<p class="source-code">  fmt.Println("add5Point   :", *count)</p></li>
				<li>Close the function:<p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Declare an <strong class="source-inline">int</strong> variable:<p class="source-code">  var count int</p></li>
				<li>Call the first function with the variable:<p class="source-code">  add5Value(count)</p></li>
				<li>Print the current value of the variable:<p class="source-code">  fmt.Println("add5Value post:", count)</p></li>
				<li>Call the second function. This time, you'll need to use <strong class="source-inline">&amp;</strong> to pass a pointer to the variable:<p class="source-code">  add5Point(&amp;count)</p></li>
				<li>Print the current value of the variable:<p class="source-code">  fmt.Println("add5Point post:", count)</p></li>
				<li>Close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p></li>
				<li>Save the file. Then, in the new folder, run the following:<p class="source-code">go run .</p></li>
			</ol>
			<p>The following is the output:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B14177_01_21.jpg" alt="Figure 1.21: Output displaying the current value of the variable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.21: Output displaying the current value of the variable</p>
			<p>In this exercise, we showed you how passing values by a pointer can affect the value variables that are passed to them. We saw that, when passing by value, the changes you make to the value in a function do not affect the value of the variable that's passed to the function, while passing a pointer to a value does change the value of the variable passed to the function. </p>
			<p>You can use this fact to overcome awkward design problems and sometimes simplify the design of your code. Passing values by a pointer has traditionally been shown to be more error-prone, so use this design sparingly. It's also common to use pointers in functions to create more efficient code, which Go's standard library does a lot.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor056"/>Activity 1.02: Pointer Value Swap</h2>
			<p>In this activity, your job is to finish some code a co-worker started. Here, we have some unfinished code for you to complete. Your task is to fill in the missing code, where the comments are to swap the values of <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>. The <strong class="source-inline">swap</strong> function only accepts pointers and doesn't return anything:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  a, b := 5, 10</p>
			<p class="source-code">  // call swap here</p>
			<p class="source-code">  fmt.Println(a == 10, b == 5)</p>
			<p class="source-code">}</p>
			<p class="source-code">func swap(a *int, b *int) {</p>
			<p class="source-code">  // swap the values here</p>
			<p class="source-code">}</p>
			<ol>
				<li value="1">Call the <strong class="source-inline">swap</strong> function, ensuring you are passing a pointer.</li>
				<li>In the <strong class="source-inline">swap</strong> function, assign the values to the other pointer, ensuring you dereference the values.<p>The following is the expected output:</p><p class="source-code">true true</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 685</p></li>
			</ol>
			<p>Next, we'll look at how we can create variables with a fixed value.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor057"/>Constants</h2>
			<p>Constants are like variables, but you can't change their initial value. These are useful for situations where the value of a constant doesn't need to or shouldn't change when your code is running. You could make the argument that you could hardcode those values into the code and it would have a similar effect. Experience has shown us that while these values don't need to change at runtime, they may need to change later. If that happens, it can be an arduous and error-prone task to track down and fix all the hardcoded values. Using a constant is a tiny amount of work now that can save you a great deal of effort later.</p>
			<p>Constant declarations are similar to <strong class="source-inline">var</strong> statements. With a constant, the initial value is required. Types are optional and inferred if left out. The initial value can be a literal or a simple statement and can use the values of other constants. Like <strong class="source-inline">var</strong>, you can declare multiple constants in one statement. Here are the notations:</p>
			<p class="source-code">constant &lt;name&gt; &lt;type&gt; = &lt;value&gt;</p>
			<p class="source-code">constant (</p>
			<p class="source-code">  &lt;name1&gt; &lt;type1&gt; = &lt;value1&gt;</p>
			<p class="source-code">  &lt;name2&gt; &lt;type2&gt; = &lt;value3&gt;</p>
			<p class="source-code">…</p>
			<p class="source-code">  &lt;nameN&gt; &lt;typeN&gt; = &lt;valueN&gt;</p>
			<p class="source-code">)</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor058"/>Exercise 1.16: Constants</h2>
			<p>In this exercise, we have a performance problem. Our database server is too slow. We are going to create a custom memory cache. We'll use Go's <strong class="source-inline">map</strong> collection type, which will act as the cache. There is a global limit on the number of items that can be in the cache. We'll use one <strong class="source-inline">map</strong> to help keep track of the number of items in the cache. We have two types of data we need to cache: books and CDs. Both use the ID, so we need a way to separate the two types of items in the shared cache. We need a way to set and get items from the cache.</p>
			<p>We're going to set the maximum number of items in the cache. We'll also use constants to add a prefix to differentiate between books and CDs. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of the file:<p class="source-code">package main</p></li>
				<li> Import the packages we'll need:<p class="source-code">import "fmt"</p></li>
				<li>Create a constant that's our global limit size:<p class="source-code">const GlobalLimit = 100</p></li>
				<li>Create a <strong class="source-inline">MaxCacheSize</strong> that is 10 times the global limit size:<p class="source-code">const MaxCacheSize int = 10 * GlobalLimit</p></li>
				<li>Create our cache prefixes:<p class="source-code">const (</p><p class="source-code">  CacheKeyBook = "book_"</p><p class="source-code">  CacheKeyCD   = "cd_"</p><p class="source-code">)</p></li>
				<li>Declare a <strong class="source-inline">map</strong> that has a <strong class="source-inline">string</strong> for a key and a <strong class="source-inline">string</strong> for its values as our cache:<p class="source-code">var cache map[string]string</p></li>
				<li>Create a function to get items from the cache:<p class="source-code">func cacheGet(key string) string {</p><p class="source-code">  return cache[key]</p><p class="source-code">}</p></li>
				<li>Create a function that sets items in the cache:<p class="source-code">func cacheSet(key, val string) {</p></li>
				<li>In this function, check out the <strong class="source-inline">MaxCacheSize</strong> constant to stop the cache going over that size:<p class="source-code">  if len(cache)+1 &gt;= MaxCacheSize {</p><p class="source-code">    return</p><p class="source-code">  }</p><p class="source-code">  cache[key] = val</p><p class="source-code">}</p></li>
				<li>Create a function to get a book from the cache:<p class="source-code">func GetBook(isbn string) string {</p></li>
				<li>Use the book cache prefix to create a unique key:<p class="source-code">  return cacheGet(CacheKeyBook + isbn)</p><p class="source-code">}</p></li>
				<li>Create a function to add a book to the cache:<p class="source-code">func SetBook(isbn string, name string) {</p></li>
				<li>Use the book cache prefix to create a unique key:<p class="source-code">  cacheSet(CacheKeyBook+isbn, name)</p><p class="source-code">}</p></li>
				<li>Create a function to get CD data from the cache:<p class="source-code">func GetCD(sku string) string {</p></li>
				<li>Use the <strong class="source-inline">CD</strong> cache prefix to create a unique key:<p class="source-code">  return cacheGet(CacheKeyCD + sku)</p><p class="source-code">}</p></li>
				<li>Create a function to add CDs to the shared cache:<p class="source-code">func SetCD(sku string, title string) {</p></li>
				<li>Use the <strong class="source-inline">CD</strong> cache prefix constant to build a unique key for the shared cache:<p class="source-code">  cacheSet(CacheKeyCD+sku, title)</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Initialize our cache by creating a <strong class="source-inline">map</strong>:<p class="source-code">  cache = make(map[string]string)</p></li>
				<li>Add a book to the cache:<p class="source-code">  SetBook("1234-5678", "Get Ready To Go")</p></li>
				<li>Add a <strong class="source-inline">CD</strong> to the cache:<p class="source-code">  SetCD("1234-5678", "Get Ready To Go Audio Book")</p></li>
				<li>Get and print that <strong class="source-inline">Book</strong> from the cache:<p class="source-code">  fmt.Println("Book :", GetBook("1234-5678"))</p></li>
				<li>Get and print that <strong class="source-inline">CD</strong> from the cache:<p class="source-code">  fmt.Println("CD   :", GetCD("1234-5678"))</p></li>
				<li>Close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p></li>
				<li>Save the file. Then, in the new folder, run the following:<p class="source-code">go run .</p></li>
			</ol>
			<p>The following is the output:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B14177_01_22.jpg" alt="Figure 1.22: Output displaying the Book and CD caches&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.22: Output displaying the Book and CD caches</p>
			<p>In this exercise, we used constants to define values that don't need to change while the code is running. We declared then using a variety of notation options, some with the typeset and some without. We declared a single constant and multiple constants in a single statement.</p>
			<p>Next, we'll look at a variation of constants for values that are more closely related. </p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor059"/>Enums</h2>
			<p>Enums are a way of defining a fixed list of values that are all related. Go doesn't have a built-in type for enums, but it does provide tools such as <strong class="source-inline">iota</strong> to let you define your own using constants, which we'll explore now.</p>
			<p>For example, in the following code, we have the days of the week defined as constants. This code is a good candidate for Go's <strong class="source-inline">iota</strong> feature:</p>
			<p class="source-code">…</p>
			<p class="source-code">const (</p>
			<p class="source-code">  Sunday  = 0</p>
			<p class="source-code">  Monday  = 1</p>
			<p class="source-code">  Tuesday   = 2</p>
			<p class="source-code">  Wednesday = 3</p>
			<p class="source-code">  Thursday  = 4</p>
			<p class="source-code">  Friday  = 5</p>
			<p class="source-code">  Saturday  = 6</p>
			<p class="source-code">)</p>
			<p class="source-code">…</p>
			<p>With <strong class="source-inline">iota</strong>, Go helps us manage lists just like this. Using <strong class="source-inline">iota</strong>, the following code is equal to the preceding code:</p>
			<p class="source-code">…</p>
			<p class="source-code">const (</p>
			<p class="source-code">  Sunday = iota</p>
			<p class="source-code">  Monday</p>
			<p class="source-code">  Tuesday</p>
			<p class="source-code">  Wednesday</p>
			<p class="source-code">  Thursday</p>
			<p class="source-code">  Friday</p>
			<p class="source-code">  Saturday</p>
			<p class="source-code">)</p>
			<p class="source-code">…</p>
			<p>Now, we have <strong class="source-inline">iota</strong> assigning the numbers for us. Using <strong class="source-inline">iota</strong> makes enums easier to create and maintain, especially if you need to add a new value to the middle of the code later.</p>
			<p>Next, we'll take a detailed look at Go's variable scoping rules and how they affect how you write code.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor060"/>Scope</h2>
			<p>All the variables in Go live in a scope. The top-level scope is the package scope. A scope can have child scopes within it. There are a few ways a child scope gets defined; the easiest way to think about this is that when you see <strong class="source-inline">{</strong>, you are starting a new child scope, and that child scope ends when you get to a matching <strong class="source-inline">}</strong>. The parent-child relationship is defined when the code compiles, not when the code runs. When accessing a variable, Go looks at the scope the code was defined in. If it can't find a variable with that name, it looks in the parent scope, then the grandparent scope, all the way until it gets to the package scope. It stops looking once it finds a variable with a matching name or raises an error if it can't find a match.</p>
			<p>To put it another way, when your code uses a variable, Go needs to work out where that variable was defined. It starts its search in the scope of the code using the variable it's currently running in. If a variable definition using that name is in that scope, then it stops looking and uses the variable definition to complete its work. If it can't find a variable definition, then it starts walking up the stack of scopes, stopping as soon as it finds a variable with that name. This searching is all done based on a variable name. If a variable with that name is found but is of the wrong type, Go raises an error.</p>
			<p>In this example, we have four different scopes, but we define the <strong class="source-inline">level</strong> variable once. This fact means that no matter where you use <strong class="source-inline">level</strong>, the same variable is used:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">var level = "pkg"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  fmt.Println("Main start  :", level)</p>
			<p class="source-code">  if true {</p>
			<p class="source-code">    fmt.Println("Block start :", level)</p>
			<p class="source-code">    funcA()</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">func funcA() {</p>
			<p class="source-code">  fmt.Println("funcA start :", level)</p>
			<p class="source-code">}</p>
			<p>The following is the output displaying variables using level:</p>
			<p class="source-code">Main start  : pkg</p>
			<p class="source-code">Block start : pkg</p>
			<p class="source-code">funcA start : pkg</p>
			<p>In this example, we've shadowed the <strong class="source-inline">level</strong> variable. This new <strong class="source-inline">level</strong> variable is not related to the <strong class="source-inline">level</strong> variable in the package scope. When we print <strong class="source-inline">level</strong> in the block, the Go runtime stops looking for variables called <strong class="source-inline">level</strong> as soon as it finds the one defined in <strong class="source-inline">main</strong>. This logic results in a different value getting printed out once that new variable shadows the package variable. You can also see that it's a different variable because it's a different type, and a variable can't have its type changed in Go:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">var level = "pkg"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  fmt.Println("Main start  :", level)</p>
			<p class="source-code">  // Create a shadow variable</p>
			<p class="source-code">  level := 42</p>
			<p class="source-code">  if true {</p>
			<p class="source-code">    fmt.Println("Block start :", level)</p>
			<p class="source-code">    funcA()</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Println("Main end    :", level)</p>
			<p class="source-code">}</p>
			<p class="source-code">func funcA() {</p>
			<p class="source-code">  fmt.Println("funcA start :", level)</p>
			<p class="source-code">}</p>
			<p>The following is the output:</p>
			<p class="source-code">Main start  : pkg</p>
			<p class="source-code">Block start : 42</p>
			<p class="source-code">funcA start : pkg</p>
			<p class="source-code">Main end    : 42</p>
			<p>Go's static scope resolution comes into play when we call <strong class="source-inline">funcA</strong>. That's why, when <strong class="source-inline">funcA</strong> runs, it still sees the package scope <strong class="source-inline">level</strong> variable. The scope resolution doesn't pay attention to where <strong class="source-inline">funcA</strong> gets called.</p>
			<p>You can't access variables defined in a child scope:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  {</p>
			<p class="source-code">    level := "Nest 1"</p>
			<p class="source-code">    fmt.Println("Block end   :", level)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  // Error: undefined: level</p>
			<p class="source-code">  //fmt.Println("Main end  :", level)</p>
			<p class="source-code">}</p>
			<p>The following is the output:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B14177_01_23.jpg" alt="Figure 1.23: Output displaying an error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.23: Output displaying an error</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/>Activity 1.03: Message Bug</h2>
			<p>The following code doesn't work. The person who wrote it can't fix it, and they've asked you to help them. Can you get it to work?</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  count := 5</p>
			<p class="source-code">  if count &gt; 5 {</p>
			<p class="source-code">    message := "Greater than 5"</p>
			<p class="source-code">  } else {</p>
			<p class="source-code">    message := "Not greater than 5"</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Println(message)</p>
			<p class="source-code">}</p>
			<ol>
				<li value="1">Run the code and see what the output is.</li>
				<li>The problem is with the <strong class="source-inline">message</strong>; make a change to the code.</li>
				<li>Rerun the code and see what difference it makes.</li>
				<li>Repeat this process until you see the expected output.<p>The following is the expected output:</p><p class="source-code">Not greater than 5</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 685</p></li>
			</ol>
			<p>In this activity, we saw that where you define your variables has a big impact on the code. Always think about the scope you need your variables to be in when defining them. </p>
			<p>In the next activity, we are going to look at a similar problem that is a bit trickier.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor062"/>Activity 1.04: Bad Count Bug</h2>
			<p>Your friend is back, and they have another bug in their code. This code should print <strong class="source-inline">true</strong>, but it's printing <strong class="source-inline">false</strong>. Can you help them fix the bug?</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  count := 0</p>
			<p class="source-code">  if count &lt; 5 {</p>
			<p class="source-code">    count := 10</p>
			<p class="source-code">    count++</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Println(count == 11)</p>
			<p class="source-code">}</p>
			<ol>
				<li value="1">Run the code and see what the output is. </li>
				<li>The problem is with <strong class="source-inline">count</strong>; make a change to the code.</li>
				<li>Rerun the code and see what difference it makes.</li>
				<li>Repeat this process until you see the expected output.<p>The following is the expected output:</p><p class="source-code">True</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 686</p></li>
			</ol>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor063"/>Summary</h1>
			<p>In this chapter, we got into the nitty-gritty of variables, including how variables are declared, and all the different notations you can use to declare them. This variety of notation gives you a nice compact notation to use for 90% of your work, while still giving you the power to be very specific when you need to the other 10% of the time. We looked at how to change and update the value of variables after you've declared them. Again, Go gives you some great shorthand to help in the most common use cases to make your life easier. All your data ends up in some form of variable. Data is what makes code dynamic and responsive. Without data, your code could only ever do exactly one thing; data unleashes the true power of software.</p>
			<p>Now that your application has data, it needs to make choices based on that data. That's where variable comparison comes in. This helps us see whether something is true or false, bigger or smaller, and to make choices based on the results of those comparisons.</p>
			<p>We explored how Go decided to implement their variable system by looking at zero values, pointers, and scope logic. Now, we know that these are the details that can be the difference between delivering bug-free efficient software and not doing so.</p>
			<p>We also took a look at how we can declare immutable variables by using constants and how <strong class="source-inline">iota</strong> can help manage lists or related constants to work, such as enums.</p>
			<p>In the next chapter, we'll start to put our variables to work by defining logic and looping over collections of variables.</p>
		</div>
		<div>
			<div id="_idContainer034" class="Content">
			</div>
		</div>
	</body></html>