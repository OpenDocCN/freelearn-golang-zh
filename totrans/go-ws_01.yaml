- en: 1\. Variables and Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to features of Go and will gain a basic
    understanding of what Go code looks like. You will also be provided with a deep
    understanding of how variables work and will perform exercises and activities
    to get hands-on and get going.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to use variables, packages, and
    functions in Go. You will learn to change variable values in Go. Later in the
    chapter you will use operators with numbers and design functions using pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go (or golang as it's often called) is a programming language popular with developers
    because of how rewarding it is to use to develop software. It's also popular with
    companies because teams of all sizes can be productive with it. Go has also earned
    a reputation for consistently delivering software with exceptionally high performance.
  prefs: []
  type: TYPE_NORMAL
- en: Go has an impressive pedigree since it was created by a team from Google with
    a long history of building great programming languages and operating systems.
    They created a language that has the feel of a dynamic language such as JavaScript
    or PHP but with the performance and efficiency of strongly typed languages such
    as C++ and Java. They wanted a language that was engaging for the programmer but
    practical in projects with hundreds of developers.
  prefs: []
  type: TYPE_NORMAL
- en: Go is packed with interesting and unique features, such as being complied with
    memory safety and channel-based concurrency. We'll explore these features in this
    chapter. By doing so, you'll see that their unique implementation within Go is
    what makes Go truly special.
  prefs: []
  type: TYPE_NORMAL
- en: Go is written in text files that are then compiled down to machine code and
    packaged into a single, standalone executable file. The executable is self-contained,
    with nothing needed to be installed first to allow it to run. Having a single
    file makes deploying and distributing Go software hassle-free. When compiling,
    you can pick one of several target operating systems, including but not limited
    to Windows, Linux, macOS, and Android. With Go, you write your code once and run
    it anywhere. Complied languages fell out of favor because programmers hated long
    waits for their code to compile. The Go team knew this and built a lightning-fast
    compiler that remains fast as projects grow.
  prefs: []
  type: TYPE_NORMAL
- en: Go has a statically typed and type-safe memory model with a garbage collector.
    This combination protects developers from creating many of the most common bugs
    and security flaws found in software while still providing excellent performance
    and efficiency. Dynamically typed languages such as Ruby and Python have become
    popular in part because programmers felt they could be more productive if they
    didn't have to worry about types and memory. The downside of these languages is
    that they gave up performance and memory efficiency and can be more prone to type-mismatch
    bugs. Go has the same levels of productivity as dynamically typed languages while
    not giving up performance and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: A massive shift in computer performance has taken place. Going fast now means
    you need to be able to do as much work parallel or concurrently as possible. This
    change is due to the design of modern CPUs, which emphasize more cores over high
    clock speed. None of the currently popular programming languages have been designed
    to take advantage of this fact, which makes writing parallel and concurrent code
    in them error-prone. Go is designed to take advantage of multiple CPU cores, and
    it removes all the frustration and bug-filled code. Go is designed to allow any
    developer to easily and safely write parallel and concurrent code that enables
    them to take advantage of modern multicore CPUs and cloud computing `â€“` unlocking
    high-performance processing and massive scalability without the drama.
  prefs: []
  type: TYPE_NORMAL
- en: What Does Go Look Like?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take our first look at some Go code. This code randomly prints a message
    to the console from a pre-defined list of messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main()` function is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s consider the `hello()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's step through this code piece by piece.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of our script is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code is our package declaration. All Go files must start with one of these.
    If you want to run the code directly, you'll need to name it `main`. If you don't
    name it `main`, then you can use it as a library and import it into other Go code.
    When creating an importable package, you can give it any name. All Go files in
    the same directory are considered part of the same package, which means all the
    files must have the same package name.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we''re importing code from packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the packages are all from Go's standard library. Go's standard
    library is very high-quality and comprehensive. You are strongly recommended to
    maximize your use of it. You can tell if a package isn't from the standard library
    because it'll look like a URL, for example, `github.com/fatih/color`.
  prefs: []
  type: TYPE_NORMAL
- en: Go has a module system that makes using external packages easy. To use a new
    module, add it to your import path. Go will automatically download it for you
    the next time you build code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imports only apply to the file they''re declared in, which means you must declare
    the same imports over and over in the same package and project. Fear not, though
    you don''t need to do this by hand. There are many tools and Go editors that automatically
    add and remove the imports for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re declaring a global variable, which is a list of strings, and initializing
    it with data. The text or strings in Go support multi-byte UFT-8 encoding, making
    them safe for any language. The type of list we''re using here is called a slice.
    There are three types of lists in Go: slices, arrays, and maps. All three are
    collections of keys and values, where you use the key to get a value from the
    collection. Slice and array collections use a number as the key. The first key
    is always 0 in slices and arrays. Also, in slices and arrays, the numbers are
    contiguous, which means there is never a break in the sequence of numbers. With
    the `map` type, you get to choose the `key` type. You use this when you want to
    use some other data to look up the value in the map. For example, you could use
    a book''s ISBN to look up its title and author:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re declaring a function. A function is some code that runs when called.
    You can pass data in the form of one or more variables to a function and optionally
    receive one or more variables back from it. The `main()` function in Go is special.
    The `main()` function is the entry point of your Go code. When your code runs,
    Go automatically calls `main` to get things started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are generating a random number. The first thing we
    need to do is ensure it's a good random number, so to do that, we must "seed"
    the random number generator. We seed it using the current time formatted to a
    Unix timestamp with nanoseconds. To get the time, we call the `Now` function in
    the `time` package. The `Now` function returns a struct type variable. Structs
    are a collection of properties and functions, a little like objects in other languages.
    In this case, we are calling the `UnixNano` function on that struct straight away.
    The `UnixNano` function returns a variable of the `int64` type, which is a 64-bit
    integer or, more simply, a number. This number is passed into `rand.Seed`. The
    `rand.Seed` function accepts an `int64` variable as its input. Note that the type
    of the variable from `time.UnixNano` and `rand.Seed` must be the same. Now, we've
    successfully seeded the random number generator.
  prefs: []
  type: TYPE_NORMAL
- en: What we want is a number we can use to get a random message. We'll use `rand.Intn`
    for this job. This function gives us a random number between 0 and 1, minus the
    number you pass in. This may sound a bit strange, but it works out perfectly for
    what we're trying to do. This is because our list is a slice where the keys start
    from 0 and increment by 1 for each value. This means the last index is 1 less
    than the length of the slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show you what this means, here is some simple code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This code prints the length of the list and then uses that length to print
    the last element. To do that, we must subtract 1, otherwise, we''d get an error,
    which is what the last line causes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.01: Output displaying an error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.01: Output displaying an error'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve generated our random number, we assign it to a variable. We do
    this with the `:=` notation, which is a very popular shortcut in Go. It tells
    the compiler to go ahead and assign that value to my variable and select the appropriate
    type for that value. This shortcut is one of the many things that makes Go feel
    like a dynamically typed language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use that variable to call a function named `hello`. We''ll look at
    `hello` in just a moment. The important thing to note is that we''re receiving
    two values back from the function and we''re able to assign them to two new variables,
    `msg` and `err`, using the `:=` notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is the definition of the `hello` function; we''re not showing the
    body for now. A function acts as a unit of logic that''s called when and as often
    as is needed. When calling a function, the code that calls it stops running and
    waits for the function to finish running. Functions are a great tool for keeping
    your code organized and understandable. In the signature of `hello`, we''ve defined
    that it accepts a single `int` value and that it returns a `string` and an `error`
    value. Having an `error` as your last return value is a very common thing to have
    in Go. The code between the `{}` is the body of the function. The following code
    is what''s run when the function''s called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are inside the function; the first line of the body is an `if` statement.
    An `if` statement runs the code inside its `{}` if its Boolean expression is true.
    The Boolean expression is the logic between the `if` and the `{`. In this case,
    we're testing to see if the passed `index` variable is greater than 0 or less
    than the largest possible slice index key.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the Boolean expression were to be true, then our code would return an empty
    `string` and an `error`. At this point, the function would stop running, and the
    code that called the function would continue to run. If the Boolean expression
    were not true, its code would be skipped over, and our function would return a
    value from `helloList` and `nil`. In Go, `nil` represents something with no value
    and no type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After we''ve run `hello`, the first thing we need to do is check to see if
    it ran successfully. We do this by checking the `error` value stored in `err`.
    If `err` is not equal to `nil`, then we know we have an error. Then, we call `log.Fatal,`
    which writes out a logging message and kills our app. Once the app''s been killed,
    no more code runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If there is no error, then we know that `hello` ran successfully and that the
    value of `msg` can be trusted to hold a valid value. The final thing we need to
    do is print the message to the screen via the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.02: Output displaying valid values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.02: Output displaying valid values'
  prefs: []
  type: TYPE_NORMAL
- en: In this simple Go program, we've been able to cover a lot of key concepts that
    we'll explore in full in the coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.01: Using Variables, Packages, and Functions to Print Stars'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll use some of what we learned about in the preceding
    example to print a random number, between 1 and 5, of stars (`*`) to the console.
    This exercise will give you a feel of what working with Go is like and some practice
    with using the features of Go we''ll need going forward. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the imports we''ll use in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Seed the random number generator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate a random number between 0 and then add 1 to get a number between 1
    and 5:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the string repeater to create a string with the number of stars we need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the string with the stars to the console with a new line character at
    the end and close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.03: Output displaying stars'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.03: Output displaying stars'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we created a runnable Go program by defining the `main` package
    with a `main()` function in it. We used the standard library by adding imports
    to packages. Those packages helped us generate a random number, repeat strings,
    and write to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Activity 1.01 Defining and Printing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we are going to create a medical form for a doctor''s office
    to capture a patient''s name, age, and whether they have a peanut allergy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a variable for the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First name as a string
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Family name as a string
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Age as an `int`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Peanut allergy as a `bool`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure they have an initial value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the values to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.04: Expected output after assigning the variables'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.04: Expected output after assigning the variables'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 684
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll start going into detail about what we've covered so far, so don't
    worry if you are confused or have a question about what you've seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you've had an overview of Go and completed your first exercise, we're
    going to dive deep. Our first stop on the journey is variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable holds data for you temporarily so you can work with it. When you
    declare a variable, it needs four things: a statement that you are declaring a
    variable, a name for the variable, the type of data it can hold, and an initial
    value for it. Fortunately, some of the parts are optional, but that also means
    there''s more than one way of defining a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll now cover all the ways you can declare a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a Variable Using var
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `var` is the foundational way to declare a variable. Every other way
    we''ll cover is a variation of this approach, typically by omitting parts of this
    definition. A full `var` definition with everything in place looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The key parts are `var`, `foo`, `string`, and `= "bar"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var` is our declaration that we are defining a variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`foo` is the name of the variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string` is the type of the variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`= "bar"` is its initial value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 1.02: Declaring a Variable Using var'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll declare two variables using the full `var` notation.
    Then, we''ll print them to the console. You''ll see that you can use the var notation
    anywhere in your code, which isn''t true for all variable declaration notations.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder and add a `main.go` file to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the main package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a variable at the package-level scope. We''ll cover what scopes are
    in detail later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare another variable using `var` in our function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print both variables to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, `foo` is declared at the package level while `baz` is declared
    at the function level. Where a variable is declared is important because where
    you declare a variable also limits what notation you can use to declare it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at another way to use the `var` notation.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Multiple Variables at Once with var
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use a single `var` declaration to define more than one variable. Using
    this method is common when declaring package-level variables. The variables don''t
    need to be of the same type, and they can all have their own initial values. The
    notation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You can have multiple of these types of declaration, which is a nice way to
    group related variables, thereby making your code more readable. You can use this
    notation in functions, but it's rare to see it used there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.03: Declaring Multiple Variables at Once with var'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll declare multiple variables using one var statement,
    each with a different type and initial value. Then, we''ll print the value of
    each variable to the console. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the `var` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define three variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `var` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, print each variable to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.05: Output displaying three variable values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.05: Output displaying three variable values'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we declared three variables using a single var statement.
    Your output looks different for the `time.Time` variable, but that's correct.
    The format is the same, but the time itself is different.
  prefs: []
  type: TYPE_NORMAL
- en: Using the var notation like this is a good way to keep your code well organized
    and to save you some typing.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll start removing some of the optional parts of the var notation.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping the Type or Value When Declaring Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In real-world code, it's not common to use the full var notation. There are
    a few cases where you need to define a package-level variable with an initial
    value and tightly control its type. In those cases, you need the full notation.
    It'll be obvious when this is needed as you'll have a type mismatch of some kind,
    so don't worry too much about this for now. The rest of the time, you'll remove
    an optional part or use the short variable declaration.
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to include both the type and the initial value when declaring
    a variable. You can use just one or the other; Go works out the rest. If you have
    a type in the declaration but no initial value, Go uses the zero value for the
    type you picked. We'll talk more about what a zero value is in a later chapter.
    On the other hand, if you have an initial value and no type, Go has a ruleset
    for how to infer the types that are needed from the literal value you use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.04: Skipping the Type or Value When Declaring Variables'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll update our previous exercise to skip the optional
    initial values or type declarations from our variable declaration. Then, we''ll
    print the values to the console, as we did previously, to show that the result
    is the same. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the packages we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the multi-variable declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `bool` in the first exercise has an initial value of false. That''s a `bool`''s
    zero value, so we''ll drop the initial value from its declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next two variables both have a non-zero value for their type, so we''ll
    drop their type declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the var declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, print out each variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.06: Output displaying variable values despite not mentioning'
  prefs: []
  type: TYPE_NORMAL
- en: the type while declaring the variables
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.06: Output displaying variable values despite not mentioning the type
    while declaring the variables'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we were able to update the previous code to use a much more
    compact variable declaration. Declaring variables is something you'll have to
    do a lot, and not having to use the notation makes for a better experience when
    writing code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at a situation where you can't skip any of the parts.
  prefs: []
  type: TYPE_NORMAL
- en: Type Inference Gone Wrong
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are times when you''ll need to use all the parts of the declaration,
    for example, when Go isn''t able to guess the correct type you need. Let''s take
    a look at an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.07: Output showing an error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.07: Output showing an error'
  prefs: []
  type: TYPE_NORMAL
- en: 'The issue here is that `rand.Seed` requires a variable of the `int64` type.
    Go''s type inference rules interoperate a whole number, such as the one we used
    as an `int`. We''ll look at the difference between them in more detail in a later
    chapter. To resolve this, we will add `int64` to the declaration. Here''s how
    that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll look at an even quicker way to declare variables.
  prefs: []
  type: TYPE_NORMAL
- en: Short Variable Declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When declaring variables in functions and functions only, we can use the `:=`
    shorthand. This shorthand allows us to make our declarations even shorter. It
    does this by allowing us to not have to use the `var` keyword and by always inferring
    the type from a required initial value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.05: Implementing Short Variable Declaration'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll update our previous exercise to use a short variable
    declaration. Since you can only use a short variable declaration in a function,
    we''ll move our variable out of the package scope. Where before `Debug` had a
    type but no initial value, we''ll switch it back so that it has an initial value
    since that''s required when using a short variable declaration. Finally, we''ll
    print it to the console. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the packages we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare each variable using the short variable declaration notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the variables to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.08: Output displaying the variable values that were printed after'
  prefs: []
  type: TYPE_NORMAL
- en: using short variable declaration notation
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.08: Output displaying the variable values that were printed after
    using short variable declaration notation'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we updated our previous code to use a very compact way to
    declare variables when we have an initial value to use.
  prefs: []
  type: TYPE_NORMAL
- en: The `:=` shorthand is very popular with Go developers and the most common way
    in which variables get defined in real-world Go code. Developers like how it makes
    their code concise and compact while still being clear as to what's happening.
  prefs: []
  type: TYPE_NORMAL
- en: Another shortcut is declaring multiple variables on the same line.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Multiple Variables with a Short Variable Declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's possible to declare multiple variables at the same time using a short variable
    declaration. They must all be on the same line, and each variable must have a
    corresponding initial value. The notation looks like `<var1>, <var2>, â€¦, <varN>
    := <val1>, <val2>, â€¦, <valN>`. The variable names are on the left-hand side of
    the `:=`, separated by a `,`. The initial values are on the right-hand side of
    the `:=` again, each separated by a `,`. The leftmost variable name gets the leftmost
    value. There must be an equal number of names and values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that uses our previous exercise''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.09: Example output displaying the variable values for the program'
  prefs: []
  type: TYPE_NORMAL
- en: with a variable declaring function
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.09: Example output displaying the variable values for the program
    with a variable declaring function'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you do see real-word code like this. It's a little hard to read,
    so it's not common to see it in terms of literal values. This doesn't mean this
    isn't common since it's very common when calling functions that return multiple
    values. We'll cover this in detail when we look at functions in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.06: Declaring Multiple Variables from a Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll call a function that returns multiple values, and
    we''ll assign each value to a new variable. Then, we''ll print the values to the
    console. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the packages we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that returns three values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the function, return three lital values, each separated by a `,`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using a short variable declaration, capture the values returned from the function''s
    three new variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the three variables to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 1.10: Output displaying the variable values for the program with the
    variable declaring function'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14177_01_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 1.10: Output displaying the variable values for the program with the
    variable declaring function'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, we were able to call a function that returned multiple values
    and capture them using a short variable declaration in one line. If we used the
    `var` notation, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Short variable notation is a big part of how Go has the feel of a dynamic language.
  prefs: []
  type: TYPE_NORMAL
- en: We're not quite done with `var` yet, though. It still has a useful trick up
    its sleeve.
  prefs: []
  type: TYPE_NORMAL
- en: Using var to Declare Multiple Variables in One Line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While it''s more common to use a short variable declaration, you can use var
    to define multiple variables on a single line. One limitation of this is that,
    when declaring the type, all the values must have the same type. If you use an
    initial value, then each value infers its type from the literal value so that
    they can differ. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11: Output displaying variable values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.11: Output displaying variable values'
  prefs: []
  type: TYPE_NORMAL
- en: Most of these are more compact when using a short variable declaration. This
    fact means they don't come up in real-world code much. The exception is the type-only
    example. This notation can be useful when you need many variables of the same
    type, and you need to control that type carefully.
  prefs: []
  type: TYPE_NORMAL
- en: Non-English Variable Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go is a UTF-8 compliant language, which means you can define variables'' names
    using alphabets other than the Latin alphabet that, for example, English uses.
    There are some limitations regarding what the name of a variable can be. The first
    character of the name must be a letter or `_`. The rest can be a mixture of letters,
    numbers, and `_`. Let''s have a look at what this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12: Output showing variable values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.12: Output showing variable values'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**Languages and Language**: Not all programming languages allow you to use
    UTF-8 characters as variables and function names. This feature could be one of
    the reasons why Go has become so popular in Asian countries, particularly in China.'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the Value of a Variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've defined our variables, let's see what we can do with them. First,
    let's change the value from its initial value. To do that, we use similar notation
    to when we set an initial value. This looks like `<variable> = <value>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.07: Changing the Value of a Variable'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the packages we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the variable to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the value of the variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print it to the console again and close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output before changing the variable''s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we''ve changed the value of offset from its initial value
    of `5` to `10`. Anywhere you use a raw value, such as `5` and `10` in our example,
    you can use a variable. Here''s how that looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output after changing the variable''s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll look at how we can change multiple variables in a one-line statement.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Multiple Values at Once
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the same way that you can declare multiple variables in one line, you can
    also change the value of more than one variable at a time. The syntax is similar,
    too; it looks like `<var1>, <var2>, â€¦, <varN> = <val1>, <val2>, â€¦, <valN>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.08: Changing Multiple Values at Once'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll define some variables and use a one-line statement
    to change their values. Then, we''ll print their new values to the console. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the packages we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare our variables with an initial value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change each variable''s values using a one-line statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the values to the console and close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output showing the changed variable values using a single
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we were able to change multiple variables in a single line.
    This approach would also work when calling functions, just as it does with a variable
    declaration. You need to be careful with a feature like this to ensure that, first
    and foremost, your code is easy to read and understand. If using a one-line statement
    like this makes it hard to know what the code is doing, then it's better to take
    up more lines to write the code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at what operators are and how they can be used to change your
    variables in interesting ways.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While variables hold the data for your application, they become truly useful
    when you start using them to build the logic of your software. Operators are the
    tools you use to work with your software's data. With operators, you can compare
    data to other data. For example, you can check whether a price is too low or too
    high in a trading application. You can also use operators to manipulate data.
    For example, you can use operators to add the costs of all the items in a shopping
    cart to get the total price.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list mentions groups of operators:'
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used for math-related tasks such as addition, subtraction, and multiplication.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Comparison operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used to compare two values; for example, are they are equal, not equal, less
    than, or greater than each other.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used with Boolean values to see whether they are both true, only one is true,
    or whether a `bool` is false.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Address operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll cover these in detail soon when we look at pointers. These are used to
    work with them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Receive operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used when working with Go channels, which we'll cover in a later chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exercise 1.09 Using Operators with Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we are going to simulate a restaurant bill. To build our simulation,
    we'll need to use mathematic and comparison operators. We'll start by exploring
    all the major uses for operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our simulation, we''ll sum everything together and work out the tip based
    on a percentage. Then, we''ll use a comparison operator to see whether the customer
    gets a reward. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We have considered US Dollar as the currency for this exercise. You may consider
    any currency of your choice; the main focus here is the operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder and add a `main.go` file to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the packages you''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a variable to hold the total. For this item on the bill, the customer
    purchased 2 items that cost 13 USD. We use `*` to do the multiplication. Then,
    we print a subtotal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, they purchased 4 items that cost 2.25 USD. We use multiplication to get
    the total of these items and then use `+` to add it to the previous total value
    and then assign that back to the total:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This customer is getting a discount of 5 USD. Here, we use the `â€“` to subtract
    5 USD from the total:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we use multiplication to calculate a 10% tip:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the tip to the total:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The bill will be split between two people. Use `/` to divide the total into
    two parts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we''ll calculate whether the customer gets a reward. First, we''ll set
    the `visitCount` and then add 1 USD to this visit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we''ll use `%` to give us any remainder after dividing the `visitCount`
    by 5 USD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The customer gets a reward on every fifth visit. If the remainder is 0, then
    this is one of those visits. Use the `==` operator to check whether the remainder
    is 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If it is, print a message that they get a reward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13: Output of operators used with numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.13: Output of operators used with numbers'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, we used the math and comparison operators with numbers. They
    allowed us to model a complex situation â€“ calculating a restaurant bill. There
    are lots of operators and which ones you can use vary with the different types
    of values. For example, as well as there being an addition operator for numbers,
    you can use the `+` symbol to join strings together. Here''s this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: For some situations, there are some shortcuts we can make with operators. We'll
    go over this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**Bitwise Operators:** Go has all the familiar bitwise operators you''d find
    in programming languages. If you know what bitwise operators are, then there will
    be no surprises here for you. If you don''t know what bitwise operators are, don''t
    worry â€“ they aren''t common in real-world code.'
  prefs: []
  type: TYPE_NORMAL
- en: Shorthand Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few shorthand assignment operators when you want to perform operations
    to an existing value with its own value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '--: Reduce a number by 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '++: Increase a number by 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '+=: Add and assign'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '-=: Subtract and assign'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 1.10: Implementing Shorthand Operators'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll use some examples of operator shorthand to show how
    they can make your code more compact and easier to write. We''ll create some variables
    then use shorthand to change them, printing them out as we go. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the packages we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a variable with an initial value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll add to it and then assign the result back to itself. Then, we''ll print
    it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Increment the value by 1 and then print it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Decrement it by 1 and then print it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Subtract and assign the result back to itself. Print out the new value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is also a shorthand that works with strings. Define a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we''ll append another string to the end of it and then print it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14: Output using shorthand operators'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.14: Output using shorthand operators'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we used some shorthand operators. One set focused on modification
    and then assignment. This type of operation is common, and having these shortcuts
    makes coding more engaging. The other operators are increment and decrement. These
    are useful in loops when you need to step over data one at a time. These shortcuts
    make it clear what you're doing to anyone who reads your code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at comparing values to each other in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logic in applications is a matter of having your code make a decision. These
    decisions get made by comparing the values of variables to the rules you define.
    These rules come in the form of comparisons. We use another set of operators to
    make these comparisons. The result of these comparisons is always true or false.
    You'll also often need to make multiples of these comparisons to make a single
    decision. To help with that, we have logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'These operators, for the most part, work with two values and always result
    in a Boolean value. You can only use logical operators with Boolean values. Let''s
    take a look at comparison operators and logical operators in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Comparison Operators**'
  prefs: []
  type: TYPE_NORMAL
- en: '`==` True if two values are the same'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!=` True if two values are not the same'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<` True if the left value is less than the right value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<=` True if the left value is less or equal to the right value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>` True if the left value is greater than the right value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>=` True if the left value is greater than or equal to the right value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logical Operators**'
  prefs: []
  type: TYPE_NORMAL
- en: '`&&` True if the left and right values are both true'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`||` True if one or both the left and right values are true'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!` This operator only works with a single value and results in true if the
    value is false'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 1.11: Comparing Values'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we'll use comparison and logical operators to see what Boolean
    results we get when testing different conditions. We are testing to see what level
    of membership a user has based on the number of visits they've had.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our membership levels are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sliver: Between 10 and 20 visits inclusively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Gold: Between 21 and 30 visits inclusively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Platinum: Over 30 visits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the packages we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define our `visits` variable and initialize it with a value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the equals operator to see if this is their first visit. Then, print the
    result to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the not equal operator to see if they are a returning visitor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s check whether they are a Silver member using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s check whether they are a Gold member using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s check whether they are a Platinum member using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.15: Output displaying the comparison result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.15: Output displaying the comparison result'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we used comparison and logical operators to make decisions
    about data. You can combine these operators in an unlimited number of ways to
    express almost any type of logic your software needs to make.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at what happens when you don't give a variable an initial value.
  prefs: []
  type: TYPE_NORMAL
- en: Zero Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The zero value of a variable is the empty or default value for that variable''s
    type. Go has a set of rules stating that the zero values are for all the core
    types. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.16: Variable types and their zero values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.16: Variable types and their zero values'
  prefs: []
  type: TYPE_NORMAL
- en: There are other types, but they are all derived from these core types, so the
    same rules still apply.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at the zero values of some types in the upcoming exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1.12 Zero Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we''ll define some variables without an initial value. Then,
    we''ll print out their values. We''re using `fmt.Printf` to help us in this exercise
    as we can get more detail about a value''s type. `fmt.Printf` uses a template
    language that allows us to transform passed values. The substitution we''re using
    is `%#v`. This transformation is a useful tool for showing a variable''s value
    and type. Some other common substitutions you can try are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.17: Table on substitutions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.17: Table on substitutions'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `fmt.Printf`, you need to add the new line symbol yourself, which
    you do by adding `\n` at the end of the string. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the packages we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare and print an integer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare and print a `float`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare and print a Boolean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare and print a `string`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare and print a collection of strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare and print a struct (a type composed of other types; we will cover this
    in a later chapter):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.18: Output displaying zero values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.18: Output displaying zero values'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we defined a variety of variable types without an initial
    value. Then, we printed them out using `fmt.Printf` to expose more detail about
    the values. Knowing what the zero values are and how Go controls them allows you
    to avoid bugs and write concise code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look are what pointers are and how they can enable you to write
    efficient software.
  prefs: []
  type: TYPE_NORMAL
- en: Value versus Pointer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With values such as `int`, `bool`, and `string`, when you pass them to a function,
    Go makes a copy of the value, and it's the copy that's used in the function. This
    copying means that a change that's made to the value in the function doesn't affect
    the value that you used when calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: Passing values by copying tends to end up with code that has fewer bugs. With
    this method of passing values, Go can use its simple memory management system
    called the stack. The downside is that copying uses up more and more memory as
    values get passed from function to function. In real-world code, functions tend
    to be small, and values get passed to lots of functions, so copying by value can
    sometimes end up using much more memory than is needed.
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative to copying that uses less memory. Instead of passing
    a value, we create something called a pointer and then pass that to functions.
    A pointer is not a value itself, and you can't do anything useful with a pointer
    other than getting a value using it. You can think of a pointer as directions
    to a value you want, and to get to the value, you must follow the directions.
    If you use a pointer, Go won't make a copy of the value when passing a pointer
    to a function.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a pointer to a value, Go can't manage the value's memory using
    the stack. This is because the stack relies on simple scope logic to know when
    it can reclaim the memory that's used by a value, and having a pointer to a variable
    means these rules don't work. Instead, Go puts the value on the heap. The heap
    allows the value to exist until no part of your software has a pointer to it anymore.
    Go reclaims these values in what it calls its garbage collection process. This
    garbage collection happens periodically in the background, and you don't need
    to worry about it.
  prefs: []
  type: TYPE_NORMAL
- en: Having a pointer to a value means that a value is put on the heap, but that's
    not the only reason that happens. Working out whether a value needs to be put
    on the heap is called escape analysis. There are times when a value with no pointers
    is put on the heap, and it's not always clear why.
  prefs: []
  type: TYPE_NORMAL
- en: You have no direct control over whether a value is put on the stack or the heap.
    Memory management is not part of Go's language specification. Memory management
    is considered an internal implementation detail. This means it could be changed
    at any time, and that what we've spoken about are only general guidelines and
    not fixed rules and could change at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: While the benefits of using a pointer over a value that gets passed to lots
    of functions are clear for memory usage, it's not so clear for CPU usage. When
    a value gets copied, Go needs CPU cycles to get that memory and then release it
    later. Using a pointer avoids this CPU usage when passing it to a function. On
    the other hand, having a value on the heap means that it then needs to be managed
    by the complex garbage collection process. This process can become a CPU bottleneck
    in certain situations, for example, if there are lots of values on the heap. When
    this happens, the garbage collector has to do lots of checking, which uses up
    CPU cycles. There is no correct answer here, and the best approach is the classic
    performance optimization one. First, don't prematurely optimize. When you do have
    a performance problem, measure before you make a change, and then measure after
    you've made a change.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond performance, you can use pointers to change your code's design. Sometimes,
    using pointers allows a cleaner interface and simplifies your code. For example,
    if you need to know whether a value is present or not, a non-pointer value always
    has at least its zero value, which could be valid in your logic. You can use a
    pointer to allow for an `is not set` state as well as holding a value. This is
    because pointers, as well as holding the address to a value, can also be `nil`,
    which means there is no value. In Go, `nil` is a special type that represents
    something not having a value.
  prefs: []
  type: TYPE_NORMAL
- en: The ability for a pointer to be nil also means that it's possible to get the
    value of a pointer when it doesn't have a value associated with it, which means
    you'll get a runtime error. To prevent runtime errors, you can compare a pointer
    to nil before trying to get its value. This looks like `<pointer> != nil`. You
    can compare pointers with other pointers of the same type, but they only result
    in true if you are comparing a pointer to itself. No comparison of the associated
    values gets made.
  prefs: []
  type: TYPE_NORMAL
- en: As a beginner in the language, I suggest avoiding pointers until they become
    necessary, either because you have a performance problem or because having a pointer
    makes your code cleaner.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a Pointer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get a pointer, you have a few options. You can declare a variable as being
    a pointer type using a `var` statement. You can do this by adding an `*` at the
    front of most types. This notation looks like `var <name> *<type>`. The initial
    value of a variable that uses this method is `nil`. You can use the built-in `new`
    function for this. This function is intended to be used to get some memory for
    a type and return a pointer to that address. The notation looks like `<name> :=
    new(<type>).` The `new` function can be used with `var` too. You can also get
    a pointer from an existing variable using `&`. This looks like `<var1> := &<var2>.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.13: Getting a Pointer'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll use each of the methods we can use to get a pointer
    variable. Then, we''ll print them to the console using `fmt.Printf` to see what
    their type and value is. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the packages we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a pointer using a `var` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a variable using `new`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can''t take the address of a literal number. Create a temporary variable
    to hold a number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using `&`, create a pointer from the existing variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It''s possible to create a pointer from some types without a temporary variable.
    Here, we''re using our trusty `time` struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print each out using `fmt.Printf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.19: Output after creating a pointer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.19: Output after creating a pointer'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we looked at three different ways of creating a pointer. Each
    one is useful, depending on what your code needs. With the `var` statement, the
    pointer has a value of nil, while the others already have a value address associated
    with them. For the `time` variable, we can see the value, but we can tell it's
    a pointer because its output starts with an `&`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll see how we can get a value from a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a Value from a Pointer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercise, when we printed out the pointer variables for the
    `int` pointers to the console, we either got nil or saw a memory address. To get
    to the value a pointer is associated with, you dereference the value using `*`
    in front of the variable name. This looks like `fmt.Println(*<val>)`.
  prefs: []
  type: TYPE_NORMAL
- en: Dereferencing a zero or `nil` pointer is a common bug in Go software as the
    compiler can't warn you about it, and it happens when the app is running. Therefore,
    it's always best practice to check that a pointer is not `nil` before dereferencing
    it unless you are certain it's not `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: You don't always need to dereference; for example, when a property or function
    is on a struct. Don't worry too much about when you shouldn't be dereferencing
    as Go gives you clear errors regarding when you can and can't dereference a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.14: Getting a Value from a Pointer'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll update our previous exercise to dereference the values
    from the pointers. We''ll also add `nil` checks to prevent us from getting any
    errors. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the packages we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our pointers are declared in the same way as they were previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For count 1, 2, and 3, we need to add a `nil` check and add `*` in front of
    the variable name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll also add a `nil` check for our `time` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll dereference the variable using `*`, just like we did with the `count`
    variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we''re calling a function on our `time` variable. This time, we don''t
    need to dereference it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `nil` check:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.20: Output displaying the values that were obtained using pointers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.20: Output displaying the values that were obtained using pointers'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we used dereferencing to get the values from our pointers.
    We also used nil checks to prevent dereferencing errors. From the output of this
    exercise, we can see that `count1` was a nil value and that we'd have gotten an
    error if we tried to dereference. `count2` was created using `new`, and its value
    is a zero value for its type. `count3` also had a value that matches the value
    of the variable we got the pointer from. With our `time` variable, we were able
    to dereference the whole struct, which is why our output doesn't start with an
    `&`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at how using a pointer allows us to change the design of our
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Function Design with Pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll cover functions in more detail in a later chapter, but you know enough
    from what we've done so far to see how using a pointer can change how you use
    a function. A function must be coded to accept pointers, and it's not something
    that you can choose whether to do or not. If you have a pointer variable or have
    passed a pointer of a variable to a function, any changes that are made to the
    value of the variable in the function also affect the value of the variable outside
    of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1.15: Function Design with Pointers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll create two functions: one that accepts a number by
    value, adds 5 to it, and then prints the number to the console; and another function
    that accepts a number as a pointer, adds 5 to it, and then prints the number out.
    We''ll also print the number out after calling each function to assess what effect
    it has on the variable that was passed to the function. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the packages we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that takes an `int` as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `5` to the passed number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the updated number to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another function that takes an `int` pointer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Dereference the value and add `5` to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print out the updated value of `count` and dereference it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare an `int` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the first function with the variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the current value of the variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the second function. This time, you''ll need to use `&` to pass a pointer
    to the variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the current value of the variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.21: Output displaying the current value of the variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.21: Output displaying the current value of the variable'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we showed you how passing values by a pointer can affect the
    value variables that are passed to them. We saw that, when passing by value, the
    changes you make to the value in a function do not affect the value of the variable
    that's passed to the function, while passing a pointer to a value does change
    the value of the variable passed to the function.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this fact to overcome awkward design problems and sometimes simplify
    the design of your code. Passing values by a pointer has traditionally been shown
    to be more error-prone, so use this design sparingly. It's also common to use
    pointers in functions to create more efficient code, which Go's standard library
    does a lot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1.02: Pointer Value Swap'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, your job is to finish some code a co-worker started. Here,
    we have some unfinished code for you to complete. Your task is to fill in the
    missing code, where the comments are to swap the values of `a` and `b`. The `swap`
    function only accepts pointers and doesn''t return anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Call the `swap` function, ensuring you are passing a pointer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `swap` function, assign the values to the other pointer, ensuring you
    dereference the values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 685
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we'll look at how we can create variables with a fixed value.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constants are like variables, but you can't change their initial value. These
    are useful for situations where the value of a constant doesn't need to or shouldn't
    change when your code is running. You could make the argument that you could hardcode
    those values into the code and it would have a similar effect. Experience has
    shown us that while these values don't need to change at runtime, they may need
    to change later. If that happens, it can be an arduous and error-prone task to
    track down and fix all the hardcoded values. Using a constant is a tiny amount
    of work now that can save you a great deal of effort later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constant declarations are similar to `var` statements. With a constant, the
    initial value is required. Types are optional and inferred if left out. The initial
    value can be a literal or a simple statement and can use the values of other constants.
    Like `var`, you can declare multiple constants in one statement. Here are the
    notations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 1.16: Constants'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we have a performance problem. Our database server is too
    slow. We are going to create a custom memory cache. We''ll use Go''s `map` collection
    type, which will act as the cache. There is a global limit on the number of items
    that can be in the cache. We''ll use one `map` to help keep track of the number
    of items in the cache. We have two types of data we need to cache: books and CDs.
    Both use the ID, so we need a way to separate the two types of items in the shared
    cache. We need a way to set and get items from the cache.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to set the maximum number of items in the cache. We''ll also use
    constants to add a prefix to differentiate between books and CDs. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the packages we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a constant that''s our global limit size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `MaxCacheSize` that is 10 times the global limit size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create our cache prefixes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `map` that has a `string` for a key and a `string` for its values
    as our cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to get items from the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that sets items in the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this function, check out the `MaxCacheSize` constant to stop the cache going
    over that size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to get a book from the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the book cache prefix to create a unique key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to add a book to the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the book cache prefix to create a unique key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to get CD data from the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `CD` cache prefix to create a unique key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to add CDs to the shared cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `CD` cache prefix constant to build a unique key for the shared cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize our cache by creating a `map`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a book to the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `CD` to the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get and print that `Book` from the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get and print that `CD` from the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file. Then, in the new folder, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.22: Output displaying the Book and CD caches'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.22: Output displaying the Book and CD caches'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we used constants to define values that don't need to change
    while the code is running. We declared then using a variety of notation options,
    some with the typeset and some without. We declared a single constant and multiple
    constants in a single statement.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at a variation of constants for values that are more closely
    related.
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enums are a way of defining a fixed list of values that are all related. Go
    doesn't have a built-in type for enums, but it does provide tools such as `iota`
    to let you define your own using constants, which we'll explore now.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following code, we have the days of the week defined as
    constants. This code is a good candidate for Go''s `iota` feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'With `iota`, Go helps us manage lists just like this. Using `iota`, the following
    code is equal to the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have `iota` assigning the numbers for us. Using `iota` makes enums easier
    to create and maintain, especially if you need to add a new value to the middle
    of the code later.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll take a detailed look at Go's variable scoping rules and how they
    affect how you write code.
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the variables in Go live in a scope. The top-level scope is the package
    scope. A scope can have child scopes within it. There are a few ways a child scope
    gets defined; the easiest way to think about this is that when you see `{`, you
    are starting a new child scope, and that child scope ends when you get to a matching
    `}`. The parent-child relationship is defined when the code compiles, not when
    the code runs. When accessing a variable, Go looks at the scope the code was defined
    in. If it can't find a variable with that name, it looks in the parent scope,
    then the grandparent scope, all the way until it gets to the package scope. It
    stops looking once it finds a variable with a matching name or raises an error
    if it can't find a match.
  prefs: []
  type: TYPE_NORMAL
- en: To put it another way, when your code uses a variable, Go needs to work out
    where that variable was defined. It starts its search in the scope of the code
    using the variable it's currently running in. If a variable definition using that
    name is in that scope, then it stops looking and uses the variable definition
    to complete its work. If it can't find a variable definition, then it starts walking
    up the stack of scopes, stopping as soon as it finds a variable with that name.
    This searching is all done based on a variable name. If a variable with that name
    is found but is of the wrong type, Go raises an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have four different scopes, but we define the `level` variable
    once. This fact means that no matter where you use `level`, the same variable
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output displaying variables using level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we''ve shadowed the `level` variable. This new `level` variable
    is not related to the `level` variable in the package scope. When we print `level`
    in the block, the Go runtime stops looking for variables called `level` as soon
    as it finds the one defined in `main`. This logic results in a different value
    getting printed out once that new variable shadows the package variable. You can
    also see that it''s a different variable because it''s a different type, and a
    variable can''t have its type changed in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Go's static scope resolution comes into play when we call `funcA`. That's why,
    when `funcA` runs, it still sees the package scope `level` variable. The scope
    resolution doesn't pay attention to where `funcA` gets called.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can''t access variables defined in a child scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.23: Output displaying an error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_01_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.23: Output displaying an error'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1.03: Message Bug'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following code doesn't work. The person who wrote it can't fix it, and they've
    asked you to help them. Can you get it to work?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: Run the code and see what the output is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The problem is with the `message`; make a change to the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rerun the code and see what difference it makes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process until you see the expected output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 685
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this activity, we saw that where you define your variables has a big impact
    on the code. Always think about the scope you need your variables to be in when
    defining them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next activity, we are going to look at a similar problem that is a bit
    trickier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 1.04: Bad Count Bug'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your friend is back, and they have another bug in their code. This code should
    print `true`, but it's printing `false`. Can you help them fix the bug?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Run the code and see what the output is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The problem is with `count`; make a change to the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rerun the code and see what difference it makes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this process until you see the expected output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 686
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got into the nitty-gritty of variables, including how variables
    are declared, and all the different notations you can use to declare them. This
    variety of notation gives you a nice compact notation to use for 90% of your work,
    while still giving you the power to be very specific when you need to the other
    10% of the time. We looked at how to change and update the value of variables
    after you've declared them. Again, Go gives you some great shorthand to help in
    the most common use cases to make your life easier. All your data ends up in some
    form of variable. Data is what makes code dynamic and responsive. Without data,
    your code could only ever do exactly one thing; data unleashes the true power
    of software.
  prefs: []
  type: TYPE_NORMAL
- en: Now that your application has data, it needs to make choices based on that data.
    That's where variable comparison comes in. This helps us see whether something
    is true or false, bigger or smaller, and to make choices based on the results
    of those comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: We explored how Go decided to implement their variable system by looking at
    zero values, pointers, and scope logic. Now, we know that these are the details
    that can be the difference between delivering bug-free efficient software and
    not doing so.
  prefs: []
  type: TYPE_NORMAL
- en: We also took a look at how we can declare immutable variables by using constants
    and how `iota` can help manage lists or related constants to work, such as enums.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll start to put our variables to work by defining logic
    and looping over collections of variables.
  prefs: []
  type: TYPE_NORMAL
