- en: 1\. Variables and Operators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 变量和运算符
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will be introduced to features of Go and will gain a basic
    understanding of what Go code looks like. You will also be provided with a deep
    understanding of how variables work and will perform exercises and activities
    to get hands-on and get going.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解Go的特性，并基本了解Go代码的样子。你还将深入了解变量是如何工作的，并通过练习和活动来获得实践经验，以便开始动手操作。
- en: By the end of this chapter, you will be able to use variables, packages, and
    functions in Go. You will learn to change variable values in Go. Later in the
    chapter you will use operators with numbers and design functions using pointers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用Go中的变量、包和函数。你将学习如何在Go中更改变量的值。在本章的后面部分，你将使用数字与运算符一起使用，并使用指针设计函数。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Go (or golang as it's often called) is a programming language popular with developers
    because of how rewarding it is to use to develop software. It's also popular with
    companies because teams of all sizes can be productive with it. Go has also earned
    a reputation for consistently delivering software with exceptionally high performance.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Go（或通常称为golang）是一种深受开发者喜爱的编程语言，因为使用它开发软件非常有益。它也受到公司的青睐，因为所有规模的公司团队都可以使用它来提高生产力。Go还因其始终如一地提供性能极高的软件而赢得了声誉。
- en: Go has an impressive pedigree since it was created by a team from Google with
    a long history of building great programming languages and operating systems.
    They created a language that has the feel of a dynamic language such as JavaScript
    or PHP but with the performance and efficiency of strongly typed languages such
    as C++ and Java. They wanted a language that was engaging for the programmer but
    practical in projects with hundreds of developers.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Go有着令人印象深刻的血统，因为它是由一支来自Google的团队创造的，这支团队有着悠久的构建优秀的编程语言和操作系统的历史。他们创造了一种感觉上类似于JavaScript或PHP这样的动态语言的语言，但具有C++和Java这样的强类型语言的性能和效率。他们希望创造一种对程序员来说既吸引人又在拥有数百名开发者的项目中实用的语言。
- en: Go is packed with interesting and unique features, such as being complied with
    memory safety and channel-based concurrency. We'll explore these features in this
    chapter. By doing so, you'll see that their unique implementation within Go is
    what makes Go truly special.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言充满了有趣且独特的特性，例如内存安全和基于通道的并发。我们将在本章中探讨这些特性。通过这样做，你会发现它们在Go中的独特实现正是Go真正特殊的原因。
- en: Go is written in text files that are then compiled down to machine code and
    packaged into a single, standalone executable file. The executable is self-contained,
    with nothing needed to be installed first to allow it to run. Having a single
    file makes deploying and distributing Go software hassle-free. When compiling,
    you can pick one of several target operating systems, including but not limited
    to Windows, Linux, macOS, and Android. With Go, you write your code once and run
    it anywhere. Complied languages fell out of favor because programmers hated long
    waits for their code to compile. The Go team knew this and built a lightning-fast
    compiler that remains fast as projects grow.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Go是用文本文件编写的，然后编译成机器代码并打包成一个单一的独立可执行文件。这个可执行文件是自包含的，不需要先安装任何东西就可以运行。拥有一个单独的文件使得部署和分发Go软件变得无烦恼。在编译时，你可以选择几个目标操作系统之一，包括但不限于Windows、Linux、macOS和Android。使用Go，你只需编写一次代码，就可以在任何地方运行。编译型语言已经不再受欢迎，因为程序员讨厌等待代码编译的漫长过程。Go团队知道这一点，并构建了一个闪电般的编译器，即使项目规模扩大，编译速度仍然很快。
- en: Go has a statically typed and type-safe memory model with a garbage collector.
    This combination protects developers from creating many of the most common bugs
    and security flaws found in software while still providing excellent performance
    and efficiency. Dynamically typed languages such as Ruby and Python have become
    popular in part because programmers felt they could be more productive if they
    didn't have to worry about types and memory. The downside of these languages is
    that they gave up performance and memory efficiency and can be more prone to type-mismatch
    bugs. Go has the same levels of productivity as dynamically typed languages while
    not giving up performance and efficiency.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Go具有静态类型和类型安全的内存模型，并带有垃圾回收器。这种组合保护开发者免受在软件中发现的许多最常见错误和安全漏洞的影响，同时仍然提供出色的性能和效率。动态类型语言，如Ruby和Python，部分因为程序员觉得如果他们不必担心类型和内存，他们可以更有效率，因此变得流行。这些语言的缺点是它们放弃了性能和内存效率，并且更容易出现类型不匹配的错误。Go具有与动态类型语言相同的生产力水平，同时没有放弃性能和效率。
- en: A massive shift in computer performance has taken place. Going fast now means
    you need to be able to do as much work parallel or concurrently as possible. This
    change is due to the design of modern CPUs, which emphasize more cores over high
    clock speed. None of the currently popular programming languages have been designed
    to take advantage of this fact, which makes writing parallel and concurrent code
    in them error-prone. Go is designed to take advantage of multiple CPU cores, and
    it removes all the frustration and bug-filled code. Go is designed to allow any
    developer to easily and safely write parallel and concurrent code that enables
    them to take advantage of modern multicore CPUs and cloud computing `–` unlocking
    high-performance processing and massive scalability without the drama.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机性能发生了巨大的转变。现在要快速运行，你需要能够尽可能并行或并发地完成更多的工作。这种变化是由于现代 CPU 的设计所致，它强调的是核心数量而非时钟速度。目前流行的所有编程语言都没有被设计用来利用这一事实，这使得在这些语言中编写并行和并发代码容易出错。Go
    语言被设计用来利用多个 CPU 核心，它消除了所有挫折和充满错误的代码。Go 语言被设计成允许任何开发者轻松且安全地编写并行和并发代码，使他们能够利用现代的多核
    CPU 和云计算 `–` 无需戏剧性的事件即可解锁高性能处理和大规模可扩展性。
- en: What Does Go Look Like?
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 语言看起来是什么样子？
- en: 'Let''s take our first look at some Go code. This code randomly prints a message
    to the console from a pre-defined list of messages:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看一些 Go 代码。这段代码会从预定义的消息列表中随机打印一条消息到控制台：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `main()` function is defined as:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()` 函数被定义为：'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s consider the `hello()` function:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下 `hello()` 函数：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let's step through this code piece by piece.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们逐块分析这段代码。
- en: 'At the top of our script is the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的脚本顶部是以下内容：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code is our package declaration. All Go files must start with one of these.
    If you want to run the code directly, you'll need to name it `main`. If you don't
    name it `main`, then you can use it as a library and import it into other Go code.
    When creating an importable package, you can give it any name. All Go files in
    the same directory are considered part of the same package, which means all the
    files must have the same package name.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是我们的包声明。所有 Go 文件都必须以其中之一开始。如果你想直接运行代码，你需要将其命名为 `main`。如果你不命名为 `main`，那么你可以将其用作库，并将其导入到其他
    Go 代码中。在创建可导入的包时，你可以给它任何名称。同一目录下的所有 Go 文件都被视为同一包的一部分，这意味着所有文件都必须有相同的包名。
- en: 'In the following code, we''re importing code from packages:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们正在从包中导入代码：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the packages are all from Go's standard library. Go's standard
    library is very high-quality and comprehensive. You are strongly recommended to
    maximize your use of it. You can tell if a package isn't from the standard library
    because it'll look like a URL, for example, `github.com/fatih/color`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有包都来自 Go 的标准库。Go 的标准库质量很高且功能全面。强烈建议你最大限度地使用它。如果你发现一个包不是来自标准库，因为它看起来像
    URL，例如 `github.com/fatih/color`。
- en: Go has a module system that makes using external packages easy. To use a new
    module, add it to your import path. Go will automatically download it for you
    the next time you build code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言有一个模块系统，这使得使用外部包变得简单。要使用一个新的模块，只需将其添加到你的导入路径。Go 语言会在你下次构建代码时自动为你下载它。
- en: 'Imports only apply to the file they''re declared in, which means you must declare
    the same imports over and over in the same package and project. Fear not, though
    you don''t need to do this by hand. There are many tools and Go editors that automatically
    add and remove the imports for you:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 导入只适用于它们声明的文件，这意味着你必须在同一个包和项目中反复声明相同的导入。不过，无需担心，你不需要手动完成这项工作。有许多工具和 Go 编辑器可以自动为你添加和删除导入：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we''re declaring a global variable, which is a list of strings, and initializing
    it with data. The text or strings in Go support multi-byte UFT-8 encoding, making
    them safe for any language. The type of list we''re using here is called a slice.
    There are three types of lists in Go: slices, arrays, and maps. All three are
    collections of keys and values, where you use the key to get a value from the
    collection. Slice and array collections use a number as the key. The first key
    is always 0 in slices and arrays. Also, in slices and arrays, the numbers are
    contiguous, which means there is never a break in the sequence of numbers. With
    the `map` type, you get to choose the `key` type. You use this when you want to
    use some other data to look up the value in the map. For example, you could use
    a book''s ISBN to look up its title and author:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个全局变量，它是一个字符串列表，并用数据初始化它。Go中的文本或字符串支持多字节UTF-8编码，这使得它们对任何语言都是安全的。我们在这里使用的列表类型被称为切片。Go中有三种列表类型：切片、数组和映射。所有三种都是键和值的集合，您使用键从集合中获取值。切片和数组集合使用数字作为键。在切片和数组中，第一个键始终是0。此外，在切片和数组中，数字是连续的，这意味着数字序列中永远不会出现中断。对于`map`类型，您可以选择`key`的类型。当您想使用其他数据在映射中查找值时，您会使用它。例如，您可以使用一本书的ISBN来查找其标题和作者：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we''re declaring a function. A function is some code that runs when called.
    You can pass data in the form of one or more variables to a function and optionally
    receive one or more variables back from it. The `main()` function in Go is special.
    The `main()` function is the entry point of your Go code. When your code runs,
    Go automatically calls `main` to get things started:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了一个函数。函数是一段在调用时运行的代码。您可以将一个或多个变量作为数据传递给函数，并可选择从它接收一个或多个变量。Go中的`main()`函数是特殊的。`main()`函数是Go代码的入口点。当您的代码运行时，Go会自动调用`main`来开始执行：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we are generating a random number. The first thing we
    need to do is ensure it's a good random number, so to do that, we must "seed"
    the random number generator. We seed it using the current time formatted to a
    Unix timestamp with nanoseconds. To get the time, we call the `Now` function in
    the `time` package. The `Now` function returns a struct type variable. Structs
    are a collection of properties and functions, a little like objects in other languages.
    In this case, we are calling the `UnixNano` function on that struct straight away.
    The `UnixNano` function returns a variable of the `int64` type, which is a 64-bit
    integer or, more simply, a number. This number is passed into `rand.Seed`. The
    `rand.Seed` function accepts an `int64` variable as its input. Note that the type
    of the variable from `time.UnixNano` and `rand.Seed` must be the same. Now, we've
    successfully seeded the random number generator.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们正在生成一个随机数。我们首先需要确保它是一个好的随机数，因此为了做到这一点，我们必须“初始化”随机数生成器。我们使用当前时间格式化为Unix时间戳（包含纳秒）来初始化它。为了获取时间，我们调用`time`包中的`Now`函数。`Now`函数返回一个结构体类型的变量。结构体是一组属性和函数的集合，类似于其他语言中的对象。在这种情况下，我们立即在该结构体上调用`UnixNano`函数。`UnixNano`函数返回一个`int64`类型的变量，这是一个64位整数，或者更简单地说，是一个数字。这个数字被传递到`rand.Seed`中。`rand.Seed`函数接受一个`int64`变量作为其输入。请注意，来自`time.UnixNano`和`rand.Seed`的变量的类型必须相同。现在，我们已经成功初始化了随机数生成器。
- en: What we want is a number we can use to get a random message. We'll use `rand.Intn`
    for this job. This function gives us a random number between 0 and 1, minus the
    number you pass in. This may sound a bit strange, but it works out perfectly for
    what we're trying to do. This is because our list is a slice where the keys start
    from 0 and increment by 1 for each value. This means the last index is 1 less
    than the length of the slice.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的是一个可以用来获取随机消息的数字。我们将使用`rand.Intn`来完成这项工作。这个函数给我们一个介于0和1之间的随机数，减去您传递的数字。这听起来可能有点奇怪，但它对我们试图做的事情来说非常完美。这是因为我们的列表是一个从0开始，每个值递增1的切片。这意味着最后一个索引比切片的长度少1。
- en: 'To show you what this means, here is some simple code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向您展示这意味着什么，这里有一些简单的代码：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code prints the length of the list and then uses that length to print
    the last element. To do that, we must subtract 1, otherwise, we''d get an error,
    which is what the last line causes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打印出列表的长度，然后使用该长度来打印最后一个元素。为了做到这一点，我们必须减去1，否则我们会得到一个错误，这就是最后一行引起的问题：
- en: '![Figure 1.01: Output displaying an error'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.01：显示错误的输出'
- en: '](img/B14177_01_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_01_01.jpg)'
- en: 'Figure 1.01: Output displaying an error'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.01：显示错误的输出
- en: 'Once we''ve generated our random number, we assign it to a variable. We do
    this with the `:=` notation, which is a very popular shortcut in Go. It tells
    the compiler to go ahead and assign that value to my variable and select the appropriate
    type for that value. This shortcut is one of the many things that makes Go feel
    like a dynamically typed language:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们生成了我们的随机数，我们就将它分配给一个变量。我们使用 `:=` 符号来做这件事，这是 Go 中一个非常受欢迎的快捷方式。它告诉编译器继续将那个值分配给我的变量，并为那个值选择适当的数据类型。这个快捷方式是许多使
    Go 感觉像动态类型语言的事情之一：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then use that variable to call a function named `hello`. We''ll look at
    `hello` in just a moment. The important thing to note is that we''re receiving
    two values back from the function and we''re able to assign them to two new variables,
    `msg` and `err`, using the `:=` notation:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用那个变量来调用一个名为 `hello` 的函数。我们稍后会看看 `hello`。重要的是要注意，我们从函数中接收两个值，并且我们可以使用 `:=`
    符号将它们分配给两个新的变量，`msg` 和 `err`：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This code is the definition of the `hello` function; we''re not showing the
    body for now. A function acts as a unit of logic that''s called when and as often
    as is needed. When calling a function, the code that calls it stops running and
    waits for the function to finish running. Functions are a great tool for keeping
    your code organized and understandable. In the signature of `hello`, we''ve defined
    that it accepts a single `int` value and that it returns a `string` and an `error`
    value. Having an `error` as your last return value is a very common thing to have
    in Go. The code between the `{}` is the body of the function. The following code
    is what''s run when the function''s called:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是 `hello` 函数的定义；我们现在不展示函数体。函数作为一个逻辑单元，当需要时被调用。当调用函数时，调用它的代码会停止运行，等待函数运行完成。函数是保持你的代码有组织和可理解的伟大工具。在
    `hello` 的签名中，我们定义了它接受一个 `int` 类型的值，并且返回一个 `string` 和一个 `error` 类型的值。在 Go 中，将 `error`
    作为最后一个返回值是非常常见的事情。`{}` 之间的代码是函数体。以下是在调用函数时运行的代码：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we are inside the function; the first line of the body is an `if` statement.
    An `if` statement runs the code inside its `{}` if its Boolean expression is true.
    The Boolean expression is the logic between the `if` and the `{`. In this case,
    we're testing to see if the passed `index` variable is greater than 0 or less
    than the largest possible slice index key.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们处于函数内部；函数体的第一行是一个 `if` 语句。一个 `if` 语句在其布尔表达式为真时运行其 `{}` 内的代码。布尔表达式是 `if`
    和 `{}` 之间的逻辑。在这种情况下，我们正在测试传递的 `index` 变量是否大于 0 或小于可能的最大切片索引键。
- en: 'If the Boolean expression were to be true, then our code would return an empty
    `string` and an `error`. At this point, the function would stop running, and the
    code that called the function would continue to run. If the Boolean expression
    were not true, its code would be skipped over, and our function would return a
    value from `helloList` and `nil`. In Go, `nil` represents something with no value
    and no type:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果布尔表达式是真的，那么我们的代码将返回一个空的 `string` 和一个 `error`。在这个时候，函数将停止运行，调用函数的代码将继续运行。如果布尔表达式不是真的，它的代码将被跳过，我们的函数将从
    `helloList` 返回一个值和 `nil`。在 Go 中，`nil` 代表没有值和没有类型的东西：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After we''ve run `hello`, the first thing we need to do is check to see if
    it ran successfully. We do this by checking the `error` value stored in `err`.
    If `err` is not equal to `nil`, then we know we have an error. Then, we call `log.Fatal,`
    which writes out a logging message and kills our app. Once the app''s been killed,
    no more code runs:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行 `hello` 之后，我们首先需要做的是检查它是否成功运行。我们通过检查存储在 `err` 中的 `error` 值来做这件事。如果 `err`
    不等于 `nil`，那么我们知道我们有一个错误。然后，我们调用 `log.Fatal`，它将记录消息并杀死我们的应用程序。一旦应用程序被杀死，就没有更多的代码运行：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If there is no error, then we know that `hello` ran successfully and that the
    value of `msg` can be trusted to hold a valid value. The final thing we need to
    do is print the message to the screen via the Terminal.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，那么我们知道 `hello` 成功运行，并且 `msg` 的值可以信赖持有有效值。我们需要做的最后一件事是通过终端将消息打印到屏幕上。
- en: 'Here''s how that looks:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的样子：
- en: '![Figure 1.02: Output displaying valid values'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.02：显示有效值的输出]'
- en: '](img/B14177_01_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 B14177_01_02.jpg]'
- en: 'Figure 1.02: Output displaying valid values'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.02：显示有效值的输出]'
- en: In this simple Go program, we've been able to cover a lot of key concepts that
    we'll explore in full in the coming chapters.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的 Go 程序中，我们已经能够涵盖许多关键概念，我们将在接下来的章节中全面探讨。
- en: 'Exercise 1.01: Using Variables, Packages, and Functions to Print Stars'
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.01：使用变量、包和函数打印星星
- en: 'In this exercise, we''ll use some of what we learned about in the preceding
    example to print a random number, between 1 and 5, of stars (`*`) to the console.
    This exercise will give you a feel of what working with Go is like and some practice
    with using the features of Go we''ll need going forward. Let''s get started:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串重复器创建一个包含所需星星数量的字符串：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并将一个`main.go`文件添加到其中。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明变量
- en: '[PRE14]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, add the imports we''ll use in this file:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加我们将在此文件中使用的导入：
- en: '[PRE15]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a `main()` function:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '](img/B14177_01_03.jpg)'
- en: '[PRE16]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Seed the random number generator:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化随机数生成器：
- en: '[PRE17]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Generate a random number between 0 and then add 1 to get a number between 1
    and 5:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用在前面的例子中学到的一些知识来打印一个介于1到5之间的随机数（`*`）到控制台。这个练习将让你感受到使用Go的感觉，并练习我们将要使用的一些Go功能。让我们开始吧：
- en: '[PRE18]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Use the string repeater to create a string with the number of stars we need:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 活动一.01 定义和打印
- en: '[PRE19]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Print the string with the stars to the console with a new line character at
    the end and close the `main()` function:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图1.04：分配变量后的预期输出
- en: '[PRE20]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为以下内容创建一个变量：
- en: '[PRE21]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following is the output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个介于0和1之间的随机数，然后加1以得到一个介于1到5之间的数字：
- en: '![Figure 1.03: Output displaying stars'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.03：显示星星的输出'
- en: '](img/B14177_01_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出：
- en: 'Figure 1.03: Output displaying stars'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 名字作为一个字符串
- en: In this exercise, we created a runnable Go program by defining the `main` package
    with a `main()` function in it. We used the standard library by adding imports
    to packages. Those packages helped us generate a random number, repeat strings,
    and write to the console.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们通过在`main`包中定义一个`main()`函数来创建一个可运行的Go程序。我们通过添加到包的导入来使用标准库。这些包帮助我们生成随机数、重复字符串以及写入控制台。
- en: Activity 1.01 Defining and Printing
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来，我们将开始详细讲解到目前为止我们已经讨论的内容，所以如果你感到困惑或对之前看到的内容有疑问，请不要担心。
- en: 'In this activity, we are going to create a medical form for a doctor''s office
    to capture a patient''s name, age, and whether they have a peanut allergy:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台打印带有换行符的星星字符串，并关闭`main()`函数：
- en: 'Create a variable for the following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将`main`包名称添加到文件顶部：
- en: First name as a string
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意
- en: Family name as a string
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓氏作为字符串
- en: Age as an `int`
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年龄作为一个`int`
- en: Peanut allergy as a `bool`
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将创建一个用于医生办公室的医疗表格，以记录患者的姓名、年龄以及他们是否有花生过敏：
- en: Ensure they have an initial value.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保它们有一个初始值。
- en: Print the values to the console.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值打印到控制台。
- en: 'The following is the expected output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为预期的输出：
- en: '![Figure 1.04: Expected output after assigning the variables'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.04：分配变量后的预期输出'
- en: '](img/B14177_01_04.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_01_04.jpg)'
- en: 'Figure 1.04: Expected output after assigning the variables'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`main()`函数：
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_01_03.jpg)'
- en: The solution for this activity can be found on page 684
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可在第684页找到
- en: Next, we'll start going into detail about what we've covered so far, so don't
    worry if you are confused or have a question about what you've seen so far.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将介绍所有可以声明变量的方式。
- en: Declaring Variables
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`var`声明变量
- en: Now that you've had an overview of Go and completed your first exercise, we're
    going to dive deep. Our first stop on the journey is variables.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 花生过敏作为一个`bool`
- en: 'A variable holds data for you temporarily so you can work with it. When you
    declare a variable, it needs four things: a statement that you are declaring a
    variable, a name for the variable, the type of data it can hold, and an initial
    value for it. Fortunately, some of the parts are optional, but that also means
    there''s more than one way of defining a variable.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个变量暂时为你保存数据，以便你可以使用它。当你声明一个变量时，它需要四个要素：一个声明你正在声明变量的语句、变量的名称、它可以保存的数据类型以及它的初始值。幸运的是，其中一些部分是可选的，但这也意味着定义变量的方式不止一种。
- en: We'll now cover all the ways you can declare a variable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 关键部分是`var`、`foo`、`string`和`= "bar"`：
- en: Declaring a Variable Using var
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图1.03：显示星星的输出
- en: 'Using `var` is the foundational way to declare a variable. Every other way
    we''ll cover is a variation of this approach, typically by omitting parts of this
    definition. A full `var` definition with everything in place looks like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新的文件夹中，运行以下命令：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The key parts are `var`, `foo`, `string`, and `= "bar"`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`是声明变量的基础方法。我们将要讨论的其他所有方法都是这种方法的变体，通常是通过省略定义的一部分。一个完整的`var`定义，包含所有要素，看起来像这样：
- en: '`var` is our declaration that we are defining a variable.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var`是我们定义变量的声明。'
- en: '`foo` is the name of the variable.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`foo`是变量的名称。'
- en: '`string` is the type of the variable.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`是变量的类型。'
- en: '`= "bar"` is its initial value.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`= "bar"`是其初始值。'
- en: 'Exercise 1.02: Declaring a Variable Using var'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.02：使用var声明一个变量
- en: 'In this exercise, we''ll declare two variables using the full `var` notation.
    Then, we''ll print them to the console. You''ll see that you can use the var notation
    anywhere in your code, which isn''t true for all variable declaration notations.
    Let''s get started:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用完整的`var`表示法声明两个变量，然后我们将它们打印到控制台。你会看到你可以在代码的任何地方使用var表示法，这不是所有变量声明表示法的共性。让我们开始吧：
- en: 'Create a new folder and add a `main.go` file to it:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个`main.go`文件到其中：
- en: 'In `main.go`, add the main package name to the top of the file:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将主包名添加到文件顶部：
- en: '[PRE23]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the imports:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加导入：
- en: '[PRE24]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Declare a variable at the package-level scope. We''ll cover what scopes are
    in detail later:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包级别作用域中声明一个变量。我们将在稍后详细介绍作用域：
- en: '[PRE25]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create the `main()` function:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE26]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Declare another variable using `var` in our function:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的函数中使用`var`声明另一个变量：
- en: '[PRE27]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Print both variables to the console:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个变量都打印到控制台：
- en: '[PRE28]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Close the `main()` function:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main()`函数：
- en: '[PRE29]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新文件夹中运行以下命令：
- en: '[PRE30]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is the output:'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE31]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, `foo` is declared at the package level while `baz` is declared
    at the function level. Where a variable is declared is important because where
    you declare a variable also limits what notation you can use to declare it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`foo`是在包级别声明的，而`baz`是在函数级别声明的。变量的声明位置很重要，因为声明变量的位置也限制了你可以使用的表示法。
- en: Next, we'll look at another way to use the `var` notation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看另一种使用`var`表示法的方法。
- en: Declaring Multiple Variables at Once with var
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用var一次声明多个变量
- en: 'We can use a single `var` declaration to define more than one variable. Using
    this method is common when declaring package-level variables. The variables don''t
    need to be of the same type, and they can all have their own initial values. The
    notation looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用单个`var`声明来定义多个变量。当声明包级别变量时，这种方法很常见。变量不需要是同一类型，并且它们都可以有自己的初始值。这种表示法看起来是这样的：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can have multiple of these types of declaration, which is a nice way to
    group related variables, thereby making your code more readable. You can use this
    notation in functions, but it's rare to see it used there.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以有多个这种类型的声明，这是一种将相关变量分组的好方法，从而使你的代码更易于阅读。你可以在函数中使用这种表示法，但很少在那里看到它的使用。
- en: 'Exercise 1.03: Declaring Multiple Variables at Once with var'
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.03：使用var一次声明多个变量
- en: 'In this exercise, we''ll declare multiple variables using one var statement,
    each with a different type and initial value. Then, we''ll print the value of
    each variable to the console. Let''s get started:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用一个var语句声明多个变量，每个变量具有不同的类型和初始值。然后，我们将打印每个变量的值到控制台。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个`main.go`文件到其中。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将`main`包名添加到文件顶部：
- en: '[PRE33]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the imports:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加导入：
- en: '[PRE34]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Start the `var` declaration:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始`var`声明：
- en: '[PRE35]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Define three variables:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义三个变量：
- en: '[PRE36]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Close the `var` declaration:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`var`声明：
- en: '[PRE37]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the `main()` function, print each variable to the console:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，将每个变量打印到控制台：
- en: '[PRE38]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新文件夹中运行以下命令：
- en: '[PRE39]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following is the output:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Figure 1.05: Output displaying three variable values'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.05：显示三个变量值的输出'
- en: '](img/B14177_01_05.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_01_05.jpg)'
- en: 'Figure 1.05: Output displaying three variable values'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.05：显示三个变量值的输出
- en: In this exercise, we declared three variables using a single var statement.
    Your output looks different for the `time.Time` variable, but that's correct.
    The format is the same, but the time itself is different.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用单个var语句声明了三个变量。对于`time.Time`变量，你的输出看起来不同，但这是正确的。格式是相同的，但时间本身是不同的。
- en: Using the var notation like this is a good way to keep your code well organized
    and to save you some typing.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用var表示法是一种保持代码井然有序并节省你输入的好方法。
- en: Next, we'll start removing some of the optional parts of the var notation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始移除var表示法的一些可选部分。
- en: Skipping the Type or Value When Declaring Variables
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量时省略类型或值
- en: In real-world code, it's not common to use the full var notation. There are
    a few cases where you need to define a package-level variable with an initial
    value and tightly control its type. In those cases, you need the full notation.
    It'll be obvious when this is needed as you'll have a type mismatch of some kind,
    so don't worry too much about this for now. The rest of the time, you'll remove
    an optional part or use the short variable declaration.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的代码中，使用完整的变量表示法并不常见。有一些情况下，你需要定义一个具有初始值和严格类型控制的包级别变量。在这些情况下，你需要使用完整的表示法。当需要时，这将是显而易见的，因为你将会有某种类型不匹配，所以现在不必过于担心。其余时间，你会移除可选部分或使用简短的变量声明。
- en: You don't need to include both the type and the initial value when declaring
    a variable. You can use just one or the other; Go works out the rest. If you have
    a type in the declaration but no initial value, Go uses the zero value for the
    type you picked. We'll talk more about what a zero value is in a later chapter.
    On the other hand, if you have an initial value and no type, Go has a ruleset
    for how to infer the types that are needed from the literal value you use.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明变量时，你不需要同时包含类型和初始值。你可以只使用其中一个；Go会处理其余部分。如果你在声明中有类型但没有初始值，Go会使用你选择的类型的零值。我们将在后面的章节中更多地讨论零值是什么。另一方面，如果你有初始值但没有类型，Go有一套规则来推断从你使用的字面值中需要的类型。
- en: 'Exercise 1.04: Skipping the Type or Value When Declaring Variables'
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.04：在声明变量时省略类型或值
- en: 'In this exercise, we''ll update our previous exercise to skip the optional
    initial values or type declarations from our variable declaration. Then, we''ll
    print the values to the console, as we did previously, to show that the result
    is the same. Let''s get started:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将更新之前的练习，跳过变量声明中的可选初始值或类型声明。然后，我们将像之前一样将值打印到控制台，以显示结果相同。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个`main.go`文件。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将`main`包名添加到文件顶部：
- en: '[PRE40]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Import the packages we''ll need:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们需要的包：
- en: '[PRE41]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Start the multi-variable declaration:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始多变量声明：
- en: '[PRE42]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `bool` in the first exercise has an initial value of false. That''s a `bool`''s
    zero value, so we''ll drop the initial value from its declaration:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一项练习中的`bool`有一个初始值false。这是`bool`的零值，所以我们将从其声明中省略初始值：
- en: '[PRE43]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The next two variables both have a non-zero value for their type, so we''ll
    drop their type declaration:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下两个变量都有非零值的类型，所以我们将省略它们的类型声明：
- en: '[PRE44]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Close the var declaration:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭变量声明：
- en: '[PRE45]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `main()` function, print out each variable:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，打印出每个变量：
- en: '[PRE46]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新文件夹中，运行以下命令：
- en: '[PRE47]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following is the output:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为输出结果：
- en: '![Figure 1.06: Output displaying variable values despite not mentioning'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.06：输出显示变量值，尽管在声明变量时没有提及类型'
- en: the type while declaring the variables
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明变量时没有提及类型
- en: '](img/B14177_01_06.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_01_06.jpg)'
- en: 'Figure 1.06: Output displaying variable values despite not mentioning the type
    while declaring the variables'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.06：输出显示变量值，尽管在声明变量时没有提及类型
- en: In this exercise, we were able to update the previous code to use a much more
    compact variable declaration. Declaring variables is something you'll have to
    do a lot, and not having to use the notation makes for a better experience when
    writing code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们能够更新之前的代码，使用更紧凑的变量声明。声明变量是你必须经常做的事情，而且不需要使用表示法会使编写代码时的体验更好。
- en: Next, we'll look at a situation where you can't skip any of the parts.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看一个你不能省略任何部分的情况。
- en: Type Inference Gone Wrong
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型推断错误
- en: 'There are times when you''ll need to use all the parts of the declaration,
    for example, when Go isn''t able to guess the correct type you need. Let''s take
    a look at an example of this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要使用声明中的所有部分，例如，当Go无法猜测你需要的正确类型时。让我们看看这个例子：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following is the output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出结果：
- en: '![Figure 1.07: Output showing an error'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.07：输出显示错误'
- en: '](img/B14177_01_07.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_01_07.jpg)'
- en: 'Figure 1.07: Output showing an error'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.07：输出显示错误
- en: 'The issue here is that `rand.Seed` requires a variable of the `int64` type.
    Go''s type inference rules interoperate a whole number, such as the one we used
    as an `int`. We''ll look at the difference between them in more detail in a later
    chapter. To resolve this, we will add `int64` to the declaration. Here''s how
    that looks:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是`rand.Seed`需要一个`int64`类型的变量。Go的类型推断规则将整数（如我们用作`int`的整数）视为一个整体。我们将在后面的章节中更详细地探讨它们之间的区别。为了解决这个问题，我们将向声明中添加`int64`。以下是这样做的外观：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Next, we'll look at an even quicker way to declare variables.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨一种更快的方式来声明变量。
- en: Short Variable Declaration
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简短变量声明
- en: When declaring variables in functions and functions only, we can use the `:=`
    shorthand. This shorthand allows us to make our declarations even shorter. It
    does this by allowing us to not have to use the `var` keyword and by always inferring
    the type from a required initial value.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当在函数和函数中声明变量时，我们可以使用`:=`简写。这个简写允许我们使我们的声明更加简短。它是通过允许我们不必使用`var`关键字，并且始终从所需的初始值推断类型来实现的。
- en: 'Exercise 1.05: Implementing Short Variable Declaration'
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.05：实现简短变量声明
- en: 'In this exercise, we''ll update our previous exercise to use a short variable
    declaration. Since you can only use a short variable declaration in a function,
    we''ll move our variable out of the package scope. Where before `Debug` had a
    type but no initial value, we''ll switch it back so that it has an initial value
    since that''s required when using a short variable declaration. Finally, we''ll
    print it to the console. Let''s get started:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将更新我们的先前练习以使用简短变量声明。由于你只能在函数中使用简短变量声明，因此我们将把变量移出包作用域。在此之前，`Debug`有一个类型但没有初始值，我们将将其切换回具有初始值，因为使用简短变量声明时需要初始值。最后，我们将将其打印到控制台。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个`main.go`文件。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将`main`包名添加到文件顶部：
- en: '[PRE50]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Import the packages we''ll need:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们需要的包：
- en: '[PRE51]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Create the `main()` function:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE52]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Declare each variable using the short variable declaration notation:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用简短变量声明符号声明每个变量：
- en: '[PRE53]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Print the variables to the console:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将变量打印到控制台：
- en: '[PRE54]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新文件夹中运行以下命令：
- en: '[PRE55]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The following is the output:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出结果：
- en: '![Figure 1.08: Output displaying the variable values that were printed after'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.08：使用简短变量声明符号后打印的变量值'
- en: using short variable declaration notation
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简短的变量声明符号
- en: '](img/B14177_01_08.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_01_08.jpg)'
- en: 'Figure 1.08: Output displaying the variable values that were printed after
    using short variable declaration notation'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.08：使用简短变量声明符号后打印的变量值
- en: In this exercise, we updated our previous code to use a very compact way to
    declare variables when we have an initial value to use.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将我们的先前代码更新为当我们有一个初始值可以使用时，使用一种非常紧凑的方式来声明变量。
- en: The `:=` shorthand is very popular with Go developers and the most common way
    in which variables get defined in real-world Go code. Developers like how it makes
    their code concise and compact while still being clear as to what's happening.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`:=`简写是Go开发者中非常受欢迎的，并且在现实世界的Go代码中定义变量的最常见方式。开发者喜欢它使他们的代码简洁紧凑，同时仍然清楚地表明正在发生什么。'
- en: Another shortcut is declaring multiple variables on the same line.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个快捷方式是在同一行声明多个变量。
- en: Declaring Multiple Variables with a Short Variable Declaration
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用简短变量声明声明多个变量
- en: It's possible to declare multiple variables at the same time using a short variable
    declaration. They must all be on the same line, and each variable must have a
    corresponding initial value. The notation looks like `<var1>, <var2>, …, <varN>
    := <val1>, <val2>, …, <valN>`. The variable names are on the left-hand side of
    the `:=`, separated by a `,`. The initial values are on the right-hand side of
    the `:=` again, each separated by a `,`. The leftmost variable name gets the leftmost
    value. There must be an equal number of names and values.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简短变量声明可以同时声明多个变量。它们必须在同一行上，并且每个变量都必须有一个相应的初始值。符号看起来像`<var1>, <var2>, …, <varN>
    := <val1>, <val2>, …, <valN>`。变量名位于`:=`的左侧，由逗号分隔。初始值再次位于`:=`的右侧，每个值由逗号分隔。最左侧的变量名获得最左侧的值。必须具有相同数量的名称和值。
- en: 'Here is an example that uses our previous exercise''s code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用我们先前练习代码的示例：
- en: '[PRE56]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The following is the output:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出结果：
- en: '![Figure 1.09: Example output displaying the variable values for the program'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.09：显示程序变量值的示例输出'
- en: with a variable declaring function
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量声明函数
- en: '](img/B14177_01_09.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_01_09.jpg)'
- en: 'Figure 1.09: Example output displaying the variable values for the program
    with a variable declaring function'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.09：显示具有变量声明函数的程序变量值的示例输出
- en: Sometimes, you do see real-word code like this. It's a little hard to read,
    so it's not common to see it in terms of literal values. This doesn't mean this
    isn't common since it's very common when calling functions that return multiple
    values. We'll cover this in detail when we look at functions in a later chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你确实会看到这样的真实世界代码。它读起来有点困难，所以在直接值方面并不常见。但这并不意味着它不常见，因为在调用返回多个值的函数时，这种情况非常普遍。我们将在稍后的章节中详细讨论这一点。
- en: 'Exercise 1.06: Declaring Multiple Variables from a Function'
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.06：从函数声明多个变量
- en: 'In this exercise, we''ll call a function that returns multiple values, and
    we''ll assign each value to a new variable. Then, we''ll print the values to the
    console. Let''s get started:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将调用一个返回多个值的函数，并将每个值分配给一个新的变量。然后，我们将打印这些值到控制台。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个`main.go`文件。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`文件中，将`main`包名添加到文件顶部：
- en: '[PRE57]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Import the packages we''ll need:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们需要的包：
- en: '[PRE58]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create a function that returns three values:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个返回三个值的函数：
- en: '[PRE59]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In the function, return three lital values, each separated by a `,`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数中，返回三个字面值，每个值之间用逗号分隔：
- en: '[PRE60]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Close the function:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭函数：
- en: '[PRE61]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create the `main()` function:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE62]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Using a short variable declaration, capture the values returned from the function''s
    three new variables:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用简短的变量声明，捕获函数返回的三个新变量的值：
- en: '[PRE63]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Print the three variables to the console:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三个变量打印到控制台：
- en: '[PRE64]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Close the `main()` function:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main()`函数：
- en: '[PRE65]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新文件夹中运行以下命令：
- en: '[PRE66]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following is the output:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为输出结果：
- en: '![Figure 1.10: Output displaying the variable values for the program with the
    variable declaring function'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图1.10：显示具有变量声明函数的程序变量值的输出'
- en: '](img/B14177_01_10.jpg)'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14177_01_10.jpg)'
- en: 'Figure 1.10: Output displaying the variable values for the program with the
    variable declaring function'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10：显示具有变量声明函数的程序变量值的输出
- en: 'In this exercise, we were able to call a function that returned multiple values
    and capture them using a short variable declaration in one line. If we used the
    `var` notation, it would look like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们能够调用一个返回多个值的函数，并使用一行简短的变量声明来捕获它们。如果我们使用`var`表示法，它将看起来像这样：
- en: '[PRE67]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Short variable notation is a big part of how Go has the feel of a dynamic language.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 短变量表示法是Go语言具有动态语言感觉的一个重要部分。
- en: We're not quite done with `var` yet, though. It still has a useful trick up
    its sleeve.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们对`var`还没有完全了解，但它仍然有一个有用的技巧。
- en: Using var to Declare Multiple Variables in One Line
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`var`在一行中声明多个变量
- en: 'While it''s more common to use a short variable declaration, you can use var
    to define multiple variables on a single line. One limitation of this is that,
    when declaring the type, all the values must have the same type. If you use an
    initial value, then each value infers its type from the literal value so that
    they can differ. Here''s an example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用简短的变量声明更为常见，但你也可以使用`var`在一行中定义多个变量。这种方法的局限性在于，当声明类型时，所有值必须具有相同的类型。如果你使用初始值，那么每个值将根据字面值推断其类型，这样它们就可以不同。以下是一个示例：
- en: '[PRE68]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The following is the output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出结果：
- en: '![Figure 1.11: Output displaying variable values'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.11：显示变量值的输出'
- en: '](img/B14177_01_11.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_01_11.jpg)'
- en: 'Figure 1.11: Output displaying variable values'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.11：显示变量值的输出
- en: Most of these are more compact when using a short variable declaration. This
    fact means they don't come up in real-world code much. The exception is the type-only
    example. This notation can be useful when you need many variables of the same
    type, and you need to control that type carefully.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用简短的变量声明时，大多数这些代码更加紧凑。这个事实意味着它们在现实世界的代码中并不常见。例外的是仅类型示例。当需要许多相同类型的变量，并且需要仔细控制该类型时，这种表示法可能很有用。
- en: Non-English Variable Names
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非英语变量名
- en: 'Go is a UTF-8 compliant language, which means you can define variables'' names
    using alphabets other than the Latin alphabet that, for example, English uses.
    There are some limitations regarding what the name of a variable can be. The first
    character of the name must be a letter or `_`. The rest can be a mixture of letters,
    numbers, and `_`. Let''s have a look at what this looks like:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是一个 UTF-8 兼容的语言，这意味着你可以使用除拉丁字母以外的字母来定义变量名，例如英语使用的字母。关于变量名可以是什么有一些限制。变量名的第一个字符必须是字母或下划线
    `_`。其余部分可以是字母、数字和下划线的组合。让我们看看它是什么样子：
- en: '[PRE69]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The following is the output:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Figure 1.12: Output showing variable values'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.12：显示变量值的输出'
- en: '](img/B14177_01_12.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 B14177_01_12.jpg](img/B14177_01_12.jpg)'
- en: 'Figure 1.12: Output showing variable values'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12：显示变量值的输出
- en: Note
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Languages and Language**: Not all programming languages allow you to use
    UTF-8 characters as variables and function names. This feature could be one of
    the reasons why Go has become so popular in Asian countries, particularly in China.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**语言和语言**：并非所有编程语言都允许你使用 UTF-8 字符作为变量和函数名。这个特性可能是 Go 在亚洲国家，尤其是在中国如此受欢迎的原因之一。'
- en: Changing the Value of a Variable
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变变量的值
- en: Now that we've defined our variables, let's see what we can do with them. First,
    let's change the value from its initial value. To do that, we use similar notation
    to when we set an initial value. This looks like `<variable> = <value>`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的变量，让我们看看我们可以用它们做什么。首先，让我们将值从其初始值改变。要做到这一点，我们使用与设置初始值时相似的符号。这看起来像
    `<variable> = <value>`。
- en: 'Exercise 1.07: Changing the Value of a Variable'
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.07：改变变量的值
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并将 `main.go` 文件添加到其中。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中，将 `main` 包名添加到文件顶部：
- en: '[PRE70]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Import the packages we''ll need:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们需要的包：
- en: '[PRE71]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Create the `main()` function:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main()` 函数：
- en: '[PRE72]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Declare a variable:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个变量：
- en: '[PRE73]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Print the variable to the console:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印变量到控制台：
- en: '[PRE74]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Change the value of the variable:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变变量的值：
- en: '[PRE75]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Print it to the console again and close the `main()` function:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次将其打印到控制台并关闭 `main()` 函数：
- en: '[PRE76]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新文件夹中，运行以下命令：
- en: '[PRE77]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The following is the output before changing the variable''s value:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是改变变量值之前的输出：
- en: '[PRE78]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In this example, we''ve changed the value of offset from its initial value
    of `5` to `10`. Anywhere you use a raw value, such as `5` and `10` in our example,
    you can use a variable. Here''s how that looks:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将偏移量的值从其初始值 `5` 改变为 `10`。在任何使用原始值的地方，例如我们例子中的 `5` 和 `10`，你都可以使用变量。这看起来是这样的：
- en: '[PRE79]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The following is the output after changing the variable''s value:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是改变变量值后的输出：
- en: '[PRE80]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Next, we'll look at how we can change multiple variables in a one-line statement.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何在单行语句中改变多个变量。
- en: Changing Multiple Values at Once
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一次性改变多个值
- en: In the same way that you can declare multiple variables in one line, you can
    also change the value of more than one variable at a time. The syntax is similar,
    too; it looks like `<var1>, <var2>, …, <varN> = <val1>, <val2>, …, <valN>`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以在一行中声明多个变量一样，你也可以一次性改变多个变量的值。语法也类似；看起来像 `<var1>, <var2>, …, <varN> = <val1>,
    <val2>, …, <valN>`。
- en: 'Exercise 1.08: Changing Multiple Values at Once'
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.08：一次性改变多个值
- en: 'In this exercise, we''ll define some variables and use a one-line statement
    to change their values. Then, we''ll print their new values to the console. Let''s
    get started:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一些变量，并使用单行语句来改变它们的值。然后，我们将打印它们的新值到控制台。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并将 `main.go` 文件添加到其中。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中，将 `main` 包名添加到文件顶部：
- en: '[PRE81]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Import the packages we''ll need:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们需要的包：
- en: '[PRE82]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Create the `main()` function:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main()` 函数：
- en: '[PRE83]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Declare our variables with an initial value:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用初始值声明我们的变量：
- en: '[PRE84]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Change each variable''s values using a one-line statement:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用单行语句改变每个变量的值：
- en: '[PRE85]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Print the values to the console and close the `main()` function:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值打印到控制台并关闭 `main()` 函数：
- en: '[PRE86]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新文件夹中，运行以下命令：
- en: '[PRE87]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The following is the output showing the changed variable values using a single
    statement:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用单行语句显示改变后的变量值的输出：
- en: '[PRE88]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In this exercise, we were able to change multiple variables in a single line.
    This approach would also work when calling functions, just as it does with a variable
    declaration. You need to be careful with a feature like this to ensure that, first
    and foremost, your code is easy to read and understand. If using a one-line statement
    like this makes it hard to know what the code is doing, then it's better to take
    up more lines to write the code.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们能够在单行中更改多个变量。这种方法在调用函数时也同样适用，就像变量声明一样。你需要小心使用这种特性，确保首先你的代码易于阅读和理解。如果使用这种单行语句使得代码难以理解，那么最好占用更多行来编写代码。
- en: Next, we'll look at what operators are and how they can be used to change your
    variables in interesting ways.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看运算符是什么以及它们如何以有趣的方式改变你的变量。
- en: Operators
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符
- en: While variables hold the data for your application, they become truly useful
    when you start using them to build the logic of your software. Operators are the
    tools you use to work with your software's data. With operators, you can compare
    data to other data. For example, you can check whether a price is too low or too
    high in a trading application. You can also use operators to manipulate data.
    For example, you can use operators to add the costs of all the items in a shopping
    cart to get the total price.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量保存你的应用程序数据时，当你开始使用它们来构建软件逻辑时，它们才真正有用。运算符是你用来处理软件数据的工具。有了运算符，你可以比较数据与其他数据。例如，你可以在交易应用程序中检查价格是否过低或过高。你还可以使用运算符来操纵数据。例如，你可以使用运算符将购物车中所有商品的成本相加以获得总价。
- en: 'The following list mentions groups of operators:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表提到了运算符的组：
- en: Arithmetic operators
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术运算符
- en: Used for math-related tasks such as addition, subtraction, and multiplication.
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于数学相关的任务，如加法、减法和乘法。
- en: Comparison operators
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较运算符
- en: Used to compare two values; for example, are they are equal, not equal, less
    than, or greater than each other.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用于比较两个值；例如，它们是否相等，不相等，小于还是大于对方。
- en: Logical operators
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: Used with Boolean values to see whether they are both true, only one is true,
    or whether a `bool` is false.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与布尔值一起使用，以查看它们是否都为真，只有一个为真，或者布尔值是否为假。
- en: Address operators
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址运算符
- en: We'll cover these in detail soon when we look at pointers. These are used to
    work with them.
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在查看指针时详细讲解这些。这些用于与它们一起使用。
- en: Receive operators
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收运算符
- en: Used when working with Go channels, which we'll cover in a later chapter.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当与Go通道一起使用时使用，我们将在后面的章节中介绍。
- en: Exercise 1.09 Using Operators with Numbers
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.09 使用运算符进行数字运算
- en: In this exercise, we are going to simulate a restaurant bill. To build our simulation,
    we'll need to use mathematic and comparison operators. We'll start by exploring
    all the major uses for operators.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将模拟餐厅账单。为了构建我们的模拟，我们需要使用数学和比较运算符。我们将首先探索运算符的所有主要用途。
- en: 'In our simulation, we''ll sum everything together and work out the tip based
    on a percentage. Then, we''ll use a comparison operator to see whether the customer
    gets a reward. Let''s get started:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模拟中，我们将把所有东西加起来，并根据百分比计算出小费。然后，我们将使用比较运算符来查看顾客是否获得奖励。让我们开始吧：
- en: Note
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We have considered US Dollar as the currency for this exercise. You may consider
    any currency of your choice; the main focus here is the operations.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将美元作为本练习的货币。你可以考虑任何你喜欢的货币；这里的主要重点是操作。
- en: 'Create a new folder and add a `main.go` file to it:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中创建一个`main.go`文件：
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将`main`包名添加到文件顶部：
- en: '[PRE89]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Import the packages you''ll need:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入你需要的包：
- en: '[PRE90]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Create the `main()` function:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE91]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Create a variable to hold the total. For this item on the bill, the customer
    purchased 2 items that cost 13 USD. We use `*` to do the multiplication. Then,
    we print a subtotal:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来保存总和。对于账单上的这一项，顾客购买了2件价值13美元的商品。我们使用`*`来进行乘法运算。然后，我们打印出小计：
- en: '[PRE92]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Here, they purchased 4 items that cost 2.25 USD. We use multiplication to get
    the total of these items and then use `+` to add it to the previous total value
    and then assign that back to the total:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，他们购买了4件价值2.25美元的商品。我们使用乘法来计算这些商品的总价，然后使用`+`将其加到之前总价值上，然后再将其赋值回总和：
- en: '[PRE93]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This customer is getting a discount of 5 USD. Here, we use the `–` to subtract
    5 USD from the total:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个顾客将获得5美元的折扣。在这里，我们使用`–`从总金额中减去5美元：
- en: '[PRE94]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Then, we use multiplication to calculate a 10% tip:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用乘法来计算10%的小费：
- en: '[PRE95]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Finally, we add the tip to the total:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将小费加到总额上：
- en: '[PRE96]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The bill will be split between two people. Use `/` to divide the total into
    two parts:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 账单将分给两个人。使用`/`将总额分成两部分：
- en: '[PRE97]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Here, we''ll calculate whether the customer gets a reward. First, we''ll set
    the `visitCount` and then add 1 USD to this visit:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们将计算客户是否获得奖励。首先，我们将设置`visitCount`，然后向这次访问添加1美元：
- en: '[PRE98]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Then, we''ll use `%` to give us any remainder after dividing the `visitCount`
    by 5 USD:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用`%`来获取`visitCount`除以5美元后的任何余数：
- en: '[PRE99]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The customer gets a reward on every fifth visit. If the remainder is 0, then
    this is one of those visits. Use the `==` operator to check whether the remainder
    is 0:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户在每次第五次访问时都会获得奖励。如果余数是0，那么这就是其中一次访问。使用`==`运算符检查余数是否为0：
- en: '[PRE100]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'If it is, print a message that they get a reward:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，打印一条消息，说明他们获得了奖励：
- en: '[PRE101]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后在新的文件夹中，运行以下命令：
- en: '[PRE102]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The following is the output:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将显示的输出：
- en: '![Figure 1.13: Output of operators used with numbers'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.13：使用数字的运算符输出'
- en: '](img/B14177_01_13.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_01_13.jpg)'
- en: 'Figure 1.13: Output of operators used with numbers'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13：使用数字的运算符输出
- en: 'In this exercise, we used the math and comparison operators with numbers. They
    allowed us to model a complex situation – calculating a restaurant bill. There
    are lots of operators and which ones you can use vary with the different types
    of values. For example, as well as there being an addition operator for numbers,
    you can use the `+` symbol to join strings together. Here''s this in action:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了数学和比较运算符与数字。它们使我们能够模拟一个复杂的情况——计算餐厅账单。有很多运算符，你可以使用哪些取决于不同类型的值。例如，除了有数字的加法运算符外，你还可以使用`+`符号将字符串连接起来。下面是它的实际应用：
- en: '[PRE103]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The following is the output:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将显示的输出：
- en: '[PRE104]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: For some situations, there are some shortcuts we can make with operators. We'll
    go over this in the next section.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些情况，我们可以使用运算符来简化操作。我们将在下一节中介绍这一点。
- en: Note
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '**Bitwise Operators:** Go has all the familiar bitwise operators you''d find
    in programming languages. If you know what bitwise operators are, then there will
    be no surprises here for you. If you don''t know what bitwise operators are, don''t
    worry – they aren''t common in real-world code.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**位运算符**：Go语言拥有所有你在编程语言中都能找到的熟悉的位运算符。如果你知道位运算符是什么，那么这里对你来说不会有惊喜。如果你不知道位运算符是什么，不用担心——它们在现实世界的代码中并不常见。'
- en: Shorthand Operator
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简写运算符
- en: 'There are a few shorthand assignment operators when you want to perform operations
    to an existing value with its own value. For example:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想对一个现有值执行操作时，有一些简写赋值运算符。例如：
- en: '--: Reduce a number by 1'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: --：将数字减1
- en: '++: Increase a number by 1'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ++：将数字增加1
- en: '+=: Add and assign'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: +=：加并赋值
- en: '-=: Subtract and assign'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: -=：减并赋值
- en: 'Exercise 1.10: Implementing Shorthand Operators'
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.10：实现简写运算符
- en: 'In this exercise, we''ll use some examples of operator shorthand to show how
    they can make your code more compact and easier to write. We''ll create some variables
    then use shorthand to change them, printing them out as we go. Let''s get started:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用一些运算符简写的例子来展示它们如何使你的代码更加紧凑且易于编写。我们将创建一些变量，然后使用简写来改变它们，在过程中打印它们。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个`main.go`文件。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将`main`包名添加到文件顶部：
- en: '[PRE105]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Import the packages we''ll need:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们需要的包：
- en: '[PRE106]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Create the `main()` function:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE107]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Create a variable with an initial value:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有初始值的变量：
- en: '[PRE108]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'We''ll add to it and then assign the result back to itself. Then, we''ll print
    it out:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将向其添加内容，然后将结果赋值回自身。然后，我们将打印出来：
- en: '[PRE109]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Increment the value by 1 and then print it out:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值增加1然后打印出来：
- en: '[PRE110]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Decrement it by 1 and then print it out:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 减去1然后打印出来：
- en: '[PRE111]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Subtract and assign the result back to itself. Print out the new value:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从自身减去并赋值给自身。打印出新的值：
- en: '[PRE112]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'There is also a shorthand that works with strings. Define a string:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，还有一个与字符串一起工作的简写。定义一个字符串：
- en: '[PRE113]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Next, we''ll append another string to the end of it and then print it out:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向其末尾追加另一个字符串，然后打印出来：
- en: '[PRE114]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Close the `main()` function:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main()`函数：
- en: '[PRE115]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后在新的文件夹中，运行以下命令：
- en: '[PRE116]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The following is the output:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将显示的输出：
- en: '![Figure 1.14: Output using shorthand operators'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.14：使用简写运算符的输出'
- en: '](img/B14177_01_14.jpg)'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_01_14.jpg)'
- en: 'Figure 1.14: Output using shorthand operators'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14：使用简写运算符的输出
- en: In this exercise, we used some shorthand operators. One set focused on modification
    and then assignment. This type of operation is common, and having these shortcuts
    makes coding more engaging. The other operators are increment and decrement. These
    are useful in loops when you need to step over data one at a time. These shortcuts
    make it clear what you're doing to anyone who reads your code.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了一些简写运算符。一组专注于修改和赋值。这种操作很常见，并且有这些快捷方式可以使编码更加有趣。其他运算符是递增和递减。这些在需要逐个遍历数据时在循环中很有用。这些快捷方式使任何阅读你代码的人都能清楚地知道你在做什么。
- en: Next, we'll look at comparing values to each other in detail.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将详细探讨比较值。
- en: Comparing Values
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较值
- en: Logic in applications is a matter of having your code make a decision. These
    decisions get made by comparing the values of variables to the rules you define.
    These rules come in the form of comparisons. We use another set of operators to
    make these comparisons. The result of these comparisons is always true or false.
    You'll also often need to make multiples of these comparisons to make a single
    decision. To help with that, we have logical operators.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序中的逻辑是一个让你的代码做出决定的问题。这些决定是通过比较变量的值与您定义的规则来做出的。这些规则以比较的形式出现。我们使用另一组运算符来进行这些比较。这些比较的结果总是真或假。你通常还需要进行多次这些比较才能做出一个决定。为了帮助做到这一点，我们有逻辑运算符。
- en: 'These operators, for the most part, work with two values and always result
    in a Boolean value. You can only use logical operators with Boolean values. Let''s
    take a look at comparison operators and logical operators in more detail:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符大部分与两个值一起工作，并且总是产生布尔值。你只能使用逻辑运算符与布尔值一起使用。让我们更详细地看看比较运算符和逻辑运算符：
- en: '**Comparison Operators**'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**比较运算符**'
- en: '`==` True if two values are the same'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==` 如果两个值相同，则为真'
- en: '`!=` True if two values are not the same'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!=` 如果两个值不相同，则为真'
- en: '`<` True if the left value is less than the right value'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<` 如果左边的值小于右边的值，则为真'
- en: '`<=` True if the left value is less or equal to the right value'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<=` 如果左边的值小于或等于右边的值，则为真'
- en: '`>` True if the left value is greater than the right value'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>` 如果左边的值大于右边的值，则为真'
- en: '`>=` True if the left value is greater than or equal to the right value'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>=` 如果左边的值大于或等于右边的值，则为真'
- en: '**Logical Operators**'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**逻辑运算符**'
- en: '`&&` True if the left and right values are both true'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&&` 如果左边的值和右边的值都为真，则为真'
- en: '`||` True if one or both the left and right values are true'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`||` 如果左边的值或两个值中的任何一个为真，则为真'
- en: '`!` This operator only works with a single value and results in true if the
    value is false'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!` 此运算符仅与单个值一起使用，如果值为假，则结果为真'
- en: 'Exercise 1.11: Comparing Values'
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.11：比较值
- en: In this exercise, we'll use comparison and logical operators to see what Boolean
    results we get when testing different conditions. We are testing to see what level
    of membership a user has based on the number of visits they've had.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用比较和逻辑运算符来查看在测试不同条件时我们得到什么布尔结果。我们正在测试根据他们已访问的次数来确定用户的会员等级。
- en: 'Our membership levels are as follows:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的会员等级如下：
- en: 'Sliver: Between 10 and 20 visits inclusively'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 银级：包含10到20次访问
- en: 'Gold: Between 21 and 30 visits inclusively'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金级：包含21到30次访问
- en: 'Platinum: Over 30 visits'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白金级：超过30次访问
- en: 'Let''s get started:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个`main.go`文件。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将`main`包名添加到文件顶部：
- en: '[PRE117]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Import the packages we''ll need:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们将需要的包：
- en: '[PRE118]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Create the `main()` function:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE119]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Define our `visits` variable and initialize it with a value:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们的`visits`变量并将其初始化为值：
- en: '[PRE120]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Use the equals operator to see if this is their first visit. Then, print the
    result to the console:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用等于运算符来查看这是否是他们的第一次访问。然后，将结果打印到控制台：
- en: '[PRE121]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Use the not equal operator to see if they are a returning visitor:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用不等运算符来查看他们是否是回头客：
- en: '[PRE122]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Let''s check whether they are a Silver member using the following code:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下代码检查他们是否是银级会员：
- en: '[PRE123]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Let''s check whether they are a Gold member using the following code:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下代码检查他们是否是金级会员：
- en: '[PRE124]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Let''s check whether they are a Platinum member using the following code:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下代码检查他们是否是白金级会员：
- en: '[PRE125]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Close the `main()` function:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main()`函数：
- en: '[PRE126]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新文件夹中运行以下命令：
- en: '[PRE127]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The following is the output:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![Figure 1.15: Output displaying the comparison result'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.15：显示比较结果的输出]'
- en: '](img/B14177_01_15.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_01_15.jpg)'
- en: 'Figure 1.15: Output displaying the comparison result'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15：显示比较结果的输出
- en: In this exercise, we used comparison and logical operators to make decisions
    about data. You can combine these operators in an unlimited number of ways to
    express almost any type of logic your software needs to make.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了比较和逻辑运算符来对数据进行决策。你可以以无限多种方式组合这些运算符，以表达软件需要执行的几乎任何类型的逻辑。
- en: Next, we'll look at what happens when you don't give a variable an initial value.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看当你没有为变量提供一个初始值时会发生什么。
- en: Zero Values
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 零值
- en: 'The zero value of a variable is the empty or default value for that variable''s
    type. Go has a set of rules stating that the zero values are for all the core
    types. Let''s take a look:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的零值是该变量类型的空或默认值。Go有一套规则说明零值适用于所有核心类型。让我们看看：
- en: '![Figure 1.16: Variable types and their zero values'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.16：变量类型及其零值]'
- en: '](img/B14177_01_16.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_01_16.jpg]'
- en: 'Figure 1.16: Variable types and their zero values'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.16：变量类型及其零值
- en: There are other types, but they are all derived from these core types, so the
    same rules still apply.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他类型，但它们都是基于这些核心类型派生出来的，所以相同的规则仍然适用。
- en: We'll look at the zero values of some types in the upcoming exercise.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的练习中查看一些类型的零值。
- en: Exercise 1.12 Zero Values
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.12 零值
- en: 'In this example, we''ll define some variables without an initial value. Then,
    we''ll print out their values. We''re using `fmt.Printf` to help us in this exercise
    as we can get more detail about a value''s type. `fmt.Printf` uses a template
    language that allows us to transform passed values. The substitution we''re using
    is `%#v`. This transformation is a useful tool for showing a variable''s value
    and type. Some other common substitutions you can try are as follows:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将定义一些没有初始值的变量。然后，我们将打印出它们的值。我们在这个练习中使用`fmt.Printf`来帮助我们，因为我们可以得到关于值类型的更多细节。`fmt.Printf`使用一种模板语言，允许我们转换传递的值。我们使用的替换是`%#v`。这种转换是显示变量值和类型的有用工具。以下是一些你可以尝试的其他常见替换：
- en: '![Figure 1.17: Table on substitutions'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.17：替换表]'
- en: '](img/B14177_01_17.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_01_17.jpg]'
- en: 'Figure 1.17: Table on substitutions'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.17：替换表
- en: 'When using `fmt.Printf`, you need to add the new line symbol yourself, which
    you do by adding `\n` at the end of the string. Let''s get started:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`fmt.Printf`时，你需要自己添加换行符号，这可以通过在字符串末尾添加`\n`来实现。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中创建一个`main.go`文件：
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将`main`包名添加到文件顶部：
- en: '[PRE128]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Import the packages we''ll need:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们需要的包：
- en: '[PRE129]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Create the `main()` function:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE130]'
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Declare and print an integer:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并打印一个整数：
- en: '[PRE131]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Declare and print a `float`:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并打印一个`float`：
- en: '[PRE132]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Declare and print a Boolean:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并打印一个布尔值：
- en: '[PRE133]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Declare and print a `string`:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并打印一个`string`：
- en: '[PRE134]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Declare and print a collection of strings:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并打印一个字符串集合：
- en: '[PRE135]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Declare and print a struct (a type composed of other types; we will cover this
    in a later chapter):'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并打印一个结构体（由其他类型组成的一种类型；我们将在以后的章节中介绍）：
- en: '[PRE136]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Close the `main()` function:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main()`函数：
- en: '[PRE137]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新文件夹中运行以下命令：
- en: '[PRE138]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The following is the output:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出结果：
- en: '![Figure 1.18: Output displaying zero values'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.18：显示零值的输出]'
- en: '](img/B14177_01_18.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_01_18.jpg]'
- en: 'Figure 1.18: Output displaying zero values'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.18：显示零值的输出
- en: In this exercise, we defined a variety of variable types without an initial
    value. Then, we printed them out using `fmt.Printf` to expose more detail about
    the values. Knowing what the zero values are and how Go controls them allows you
    to avoid bugs and write concise code.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们定义了各种没有初始值的变量类型。然后，我们使用`fmt.Printf`打印它们，以暴露更多关于值的细节。了解零值是什么以及Go如何控制它们，可以帮助你避免错误并编写简洁的代码。
- en: Next, we'll look are what pointers are and how they can enable you to write
    efficient software.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看指针是什么以及它们如何帮助你编写高效的软件。
- en: Value versus Pointer
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值与指针
- en: With values such as `int`, `bool`, and `string`, when you pass them to a function,
    Go makes a copy of the value, and it's the copy that's used in the function. This
    copying means that a change that's made to the value in the function doesn't affect
    the value that you used when calling the function.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像`int`、`bool`和`string`这样的值，当你将它们传递给函数时，Go会复制这个值，并且函数中使用的是这个副本。这种复制意味着在函数中对值的更改不会影响你在调用函数时使用的值。
- en: Passing values by copying tends to end up with code that has fewer bugs. With
    this method of passing values, Go can use its simple memory management system
    called the stack. The downside is that copying uses up more and more memory as
    values get passed from function to function. In real-world code, functions tend
    to be small, and values get passed to lots of functions, so copying by value can
    sometimes end up using much more memory than is needed.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 通过复制传递值往往会导致代码中错误更少。使用这种传递值的方法，Go可以使用其简单的内存管理系统，即栈。缺点是随着值从函数传递到函数，复制会消耗越来越多的内存。在实际代码中，函数往往很小，值会被传递到很多函数中，所以按值复制有时可能会使用比所需更多的内存。
- en: There is an alternative to copying that uses less memory. Instead of passing
    a value, we create something called a pointer and then pass that to functions.
    A pointer is not a value itself, and you can't do anything useful with a pointer
    other than getting a value using it. You can think of a pointer as directions
    to a value you want, and to get to the value, you must follow the directions.
    If you use a pointer, Go won't make a copy of the value when passing a pointer
    to a function.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种使用更少内存的复制替代方案。我们不是传递一个值，而是创建一个称为指针的东西，然后将它传递给函数。指针本身不是一个值，你不能用指针做任何有用的事情，除了用它来获取一个值。你可以把指针想象成指向你想要的价值的方向，要到达这个值，你必须遵循这些方向。如果你使用指针，Go在将指针传递给函数时不会复制该值。
- en: When creating a pointer to a value, Go can't manage the value's memory using
    the stack. This is because the stack relies on simple scope logic to know when
    it can reclaim the memory that's used by a value, and having a pointer to a variable
    means these rules don't work. Instead, Go puts the value on the heap. The heap
    allows the value to exist until no part of your software has a pointer to it anymore.
    Go reclaims these values in what it calls its garbage collection process. This
    garbage collection happens periodically in the background, and you don't need
    to worry about it.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个指向值的指针时，Go无法使用栈来管理该值的内存。这是因为栈依赖于简单的范围逻辑来知道何时可以回收由值使用的内存，而拥有一个变量的指针意味着这些规则不起作用。相反，Go将值放在堆上。堆允许值存在，直到你的软件的任何部分都没有指向它的指针为止。Go通过其所谓的垃圾回收过程回收这些值。这种垃圾回收在后台定期发生，你不需要担心它。
- en: Having a pointer to a value means that a value is put on the heap, but that's
    not the only reason that happens. Working out whether a value needs to be put
    on the heap is called escape analysis. There are times when a value with no pointers
    is put on the heap, and it's not always clear why.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个指向值的指针意味着该值被放在堆上，但这不是唯一的原因。确定一个值是否需要放在堆上被称为逃逸分析。有时即使没有指针的值也会被放在堆上，而且原因并不总是很清楚。
- en: You have no direct control over whether a value is put on the stack or the heap.
    Memory management is not part of Go's language specification. Memory management
    is considered an internal implementation detail. This means it could be changed
    at any time, and that what we've spoken about are only general guidelines and
    not fixed rules and could change at a later date.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法直接控制一个值是放在栈上还是堆上。内存管理不是Go语言规范的一部分。内存管理被视为内部实现细节。这意味着它可以在任何时候更改，而我们之前讨论的只是一些一般性指南，而不是固定规则，并且可能在以后发生变化。
- en: While the benefits of using a pointer over a value that gets passed to lots
    of functions are clear for memory usage, it's not so clear for CPU usage. When
    a value gets copied, Go needs CPU cycles to get that memory and then release it
    later. Using a pointer avoids this CPU usage when passing it to a function. On
    the other hand, having a value on the heap means that it then needs to be managed
    by the complex garbage collection process. This process can become a CPU bottleneck
    in certain situations, for example, if there are lots of values on the heap. When
    this happens, the garbage collector has to do lots of checking, which uses up
    CPU cycles. There is no correct answer here, and the best approach is the classic
    performance optimization one. First, don't prematurely optimize. When you do have
    a performance problem, measure before you make a change, and then measure after
    you've made a change.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用指针而不是传递给许多函数的值在内存使用上的好处是明显的，但在CPU使用上则不太明显。当一个值被复制时，Go需要CPU周期来获取该内存并在稍后释放它。使用指针在传递给函数时可以避免这种CPU使用。另一方面，堆上的值意味着它需要通过复杂的垃圾回收过程来管理。这个过程在某些情况下可能成为CPU瓶颈，例如，如果堆上有许多值。当这种情况发生时，垃圾收集器需要进行大量的检查，这会消耗CPU周期。这里没有正确答案，最佳方法是经典的性能优化方法。首先，不要过早优化。当你确实遇到性能问题时，在做出更改之前进行测量，然后在更改之后再次进行测量。
- en: Beyond performance, you can use pointers to change your code's design. Sometimes,
    using pointers allows a cleaner interface and simplifies your code. For example,
    if you need to know whether a value is present or not, a non-pointer value always
    has at least its zero value, which could be valid in your logic. You can use a
    pointer to allow for an `is not set` state as well as holding a value. This is
    because pointers, as well as holding the address to a value, can also be `nil`,
    which means there is no value. In Go, `nil` is a special type that represents
    something not having a value.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 除了性能之外，你还可以使用指针来改变你的代码设计。有时，使用指针可以使接口更清晰，并简化你的代码。例如，如果你需要知道一个值是否存在，非指针值总是至少有它的零值，这在你的逻辑中可能是有效的。你可以使用指针来允许`is
    not set`状态以及持有值。这是因为指针，除了持有值的地址外，还可以是`nil`，这意味着没有值。在Go中，`nil`是一个特殊类型，表示没有值。
- en: The ability for a pointer to be nil also means that it's possible to get the
    value of a pointer when it doesn't have a value associated with it, which means
    you'll get a runtime error. To prevent runtime errors, you can compare a pointer
    to nil before trying to get its value. This looks like `<pointer> != nil`. You
    can compare pointers with other pointers of the same type, but they only result
    in true if you are comparing a pointer to itself. No comparison of the associated
    values gets made.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 指针可以为nil的能力还意味着，当它没有与之关联的值时，你可以获取指针的值，这意味着你将得到运行时错误。为了防止运行时错误，在尝试获取其值之前，你可以将指针与nil进行比较。这看起来像`<pointer>
    != nil`。你可以将指针与相同类型的其他指针进行比较，但只有在比较的是指针自身时，它们才会返回true。不会比较关联的值。
- en: As a beginner in the language, I suggest avoiding pointers until they become
    necessary, either because you have a performance problem or because having a pointer
    makes your code cleaner.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 作为该语言的初学者，我建议在它们成为必要之前避免使用指针，无论是由于你有性能问题，还是因为使用指针可以使你的代码更清晰。
- en: Getting a Pointer
  id: totrans-532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取指针
- en: To get a pointer, you have a few options. You can declare a variable as being
    a pointer type using a `var` statement. You can do this by adding an `*` at the
    front of most types. This notation looks like `var <name> *<type>`. The initial
    value of a variable that uses this method is `nil`. You can use the built-in `new`
    function for this. This function is intended to be used to get some memory for
    a type and return a pointer to that address. The notation looks like `<name> :=
    new(<type>).` The `new` function can be used with `var` too. You can also get
    a pointer from an existing variable using `&`. This looks like `<var1> := &<var2>.`
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取指针，你有几种选择。你可以使用`var`语句将变量声明为指针类型。你可以通过在大多数类型的前面添加一个`*`来实现这一点。这种表示法看起来像`var
    <name> *<type>`。使用此方法声明的变量的初始值是`nil`。你可以使用内置的`new`函数来做到这一点。此函数旨在用于为类型获取内存并返回对该地址的指针。表示法看起来像`<name>
    := new(<type>).` `new`函数也可以与`var`一起使用。你还可以使用`&`从现有变量中获取指针。这看起来像`<var1> := &<var2>.`
- en: 'Exercise 1.13: Getting a Pointer'
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.13：获取指针
- en: 'In this exercise, we''ll use each of the methods we can use to get a pointer
    variable. Then, we''ll print them to the console using `fmt.Printf` to see what
    their type and value is. Let''s get started:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用我们可以使用的方法来获取指针变量。然后，我们将使用 `fmt.Printf` 将它们打印到控制台，以查看它们的类型和值。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个 `main.go` 文件。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 文件中，将 `main` 包名添加到文件顶部：
- en: '[PRE139]'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Import the packages we''ll need:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们需要的包：
- en: '[PRE140]'
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Create the `main()` function:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main()` 函数：
- en: '[PRE141]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Declare a pointer using a `var` statement:'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `var` 语句声明一个指针：
- en: '[PRE142]'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Create a variable using `new`:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `new` 创建一个变量：
- en: '[PRE143]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'You can''t take the address of a literal number. Create a temporary variable
    to hold a number:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你不能取一个字面量的地址。创建一个临时变量来保存一个数字：
- en: '[PRE144]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Using `&`, create a pointer from the existing variable:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `&` 从现有变量创建一个指针：
- en: '[PRE145]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'It''s possible to create a pointer from some types without a temporary variable.
    Here, we''re using our trusty `time` struct:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在某些类型中，可以不使用临时变量就创建一个指针。这里，我们使用我们信任的 `time` 结构体：
- en: '[PRE146]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Print each out using `fmt.Printf`:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `fmt.Printf` 打印每个变量：
- en: '[PRE147]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Close the `main()` function:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 `main()` 函数：
- en: '[PRE148]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新文件夹中运行以下命令：
- en: '[PRE149]'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The following is the output:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出结果：
- en: '![Figure 1.19: Output after creating a pointer'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.19：创建指针后的输出'
- en: '](img/B14177_01_19.jpg)'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.19：创建指针后的输出'
- en: 'Figure 1.19: Output after creating a pointer'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.19：创建指针后的输出
- en: In this exercise, we looked at three different ways of creating a pointer. Each
    one is useful, depending on what your code needs. With the `var` statement, the
    pointer has a value of nil, while the others already have a value address associated
    with them. For the `time` variable, we can see the value, but we can tell it's
    a pointer because its output starts with an `&`.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们探讨了创建指针的三种不同方法。每一种方法都有用，取决于你的代码需要什么。使用 `var` 语句时，指针的值为 `nil`，而其他指针已经与它们关联了值地址。对于
    `time` 变量，我们可以看到其值，但我们可以判断它是一个指针，因为其输出以 `&` 开头。
- en: Next, we'll see how we can get a value from a pointer.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何从一个指针中获取一个值。
- en: Getting a Value from a Pointer
  id: totrans-565
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从指针获取值
- en: In the previous exercise, when we printed out the pointer variables for the
    `int` pointers to the console, we either got nil or saw a memory address. To get
    to the value a pointer is associated with, you dereference the value using `*`
    in front of the variable name. This looks like `fmt.Println(*<val>)`.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，当我们打印出指向 `int` 指针的指针变量到控制台时，我们要么得到 `nil`，要么看到内存地址。要获取指针关联的值，你需要使用变量名前的
    `*` 来解引用该值。这看起来像 `fmt.Println(*<val>)`。
- en: Dereferencing a zero or `nil` pointer is a common bug in Go software as the
    compiler can't warn you about it, and it happens when the app is running. Therefore,
    it's always best practice to check that a pointer is not `nil` before dereferencing
    it unless you are certain it's not `nil`.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 软件中，解引用零或 `nil` 指针是一个常见的错误，因为编译器无法警告你，这发生在应用程序运行时。因此，在解引用之前始终检查指针不是 `nil`
    是最好的实践，除非你确定它不是 `nil`。
- en: You don't always need to dereference; for example, when a property or function
    is on a struct. Don't worry too much about when you shouldn't be dereferencing
    as Go gives you clear errors regarding when you can and can't dereference a value.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不总是需要解引用；例如，当属性或函数位于结构体上时。不用担心太多你不应该解引用的情况，因为 Go 会给你清晰的错误信息，告诉你何时可以和不可以解引用一个值。
- en: 'Exercise 1.14: Getting a Value from a Pointer'
  id: totrans-569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.14：从指针获取值
- en: 'In this exercise, we''ll update our previous exercise to dereference the values
    from the pointers. We''ll also add `nil` checks to prevent us from getting any
    errors. Let''s get started:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将更新我们之前的练习，以从指针解引用值。我们还将添加 `nil` 检查以防止我们得到任何错误。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个 `main.go` 文件。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 文件中，将 `main` 包名添加到文件顶部：
- en: '[PRE150]'
  id: totrans-573
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Import the packages we''ll need:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们需要的包：
- en: '[PRE151]'
  id: totrans-575
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Create the `main()` function:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main()` 函数：
- en: '[PRE152]'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Our pointers are declared in the same way as they were previously:'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明的指针与之前的方式相同：
- en: '[PRE153]'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'For count 1, 2, and 3, we need to add a `nil` check and add `*` in front of
    the variable name:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于计数 1、2 和 3，我们需要添加一个 `nil` 检查，并在变量名前添加 `*`：
- en: '[PRE154]'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'We''ll also add a `nil` check for our `time` variable:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将为 `time` 变量添加 `nil` 检查：
- en: '[PRE155]'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'We''ll dereference the variable using `*`, just like we did with the `count`
    variables:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `*` 解引用变量，就像我们之前对 `count` 变量所做的那样：
- en: '[PRE156]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Here, we''re calling a function on our `time` variable. This time, we don''t
    need to dereference it:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们正在对`time`变量调用一个函数。这次，我们不需要解引用它：
- en: '[PRE157]'
  id: totrans-587
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Close the `nil` check:'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`nil`检查：
- en: '[PRE158]'
  id: totrans-589
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Close the `main()` function:'
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main()`函数：
- en: '[PRE159]'
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-592
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新文件夹中运行以下命令：
- en: '[PRE160]'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The following is the output:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对输出：
- en: '![Figure 1.20: Output displaying the values that were obtained using pointers'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.20：使用指针获取的值的输出]'
- en: '](img/B14177_01_20.jpg)'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_01_20.jpg]'
- en: 'Figure 1.20: Output displaying the values that were obtained using pointers'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.20：使用指针获取的值的输出
- en: In this exercise, we used dereferencing to get the values from our pointers.
    We also used nil checks to prevent dereferencing errors. From the output of this
    exercise, we can see that `count1` was a nil value and that we'd have gotten an
    error if we tried to dereference. `count2` was created using `new`, and its value
    is a zero value for its type. `count3` also had a value that matches the value
    of the variable we got the pointer from. With our `time` variable, we were able
    to dereference the whole struct, which is why our output doesn't start with an
    `&`.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用解引用从我们的指针中获取值。我们还使用了nil检查来防止解引用错误。从这个练习的输出中，我们可以看到`count1`是一个nil值，如果我们尝试解引用，我们会得到一个错误。`count2`是使用`new`创建的，它的值是其类型的零值。`count3`也有一个与从其获取指针的变量的值匹配的值。对于我们的`time`变量，我们能够解引用整个结构体，这就是为什么我们的输出不以`&`开头。
- en: Next, we'll look at how using a pointer allows us to change the design of our
    code.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看使用指针如何允许我们改变代码的设计。
- en: Function Design with Pointers
  id: totrans-600
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针设计函数
- en: We'll cover functions in more detail in a later chapter, but you know enough
    from what we've done so far to see how using a pointer can change how you use
    a function. A function must be coded to accept pointers, and it's not something
    that you can choose whether to do or not. If you have a pointer variable or have
    passed a pointer of a variable to a function, any changes that are made to the
    value of the variable in the function also affect the value of the variable outside
    of the function.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中更详细地介绍函数，但你知道到目前为止我们所做的一切，足以看到使用指针如何改变你使用函数的方式。一个函数必须被编码为接受指针，这不是你可以选择是否要做的事情。如果你有一个指针变量或者将变量的指针传递给函数，函数中对变量值的任何更改也会影响函数外部的变量值。
- en: 'Exercise 1.15: Function Design with Pointers'
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.15：指针设计函数
- en: 'In this exercise, we''ll create two functions: one that accepts a number by
    value, adds 5 to it, and then prints the number to the console; and another function
    that accepts a number as a pointer, adds 5 to it, and then prints the number out.
    We''ll also print the number out after calling each function to assess what effect
    it has on the variable that was passed to the function. Let''s get started:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建两个函数：一个函数通过值接受一个数字，将其加5，然后将其打印到控制台；另一个函数接受一个数字作为指针，将其加5，然后将其打印出来。我们还会在调用每个函数后打印出数字，以评估它对传递给函数的变量的影响。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个`main.go`文件。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将`main`包名添加到文件顶部：
- en: '[PRE161]'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Import the packages we''ll need:'
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们需要的包：
- en: '[PRE162]'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Create a function that takes an `int` as an argument:'
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个接受`int`作为参数的函数：
- en: '[PRE163]'
  id: totrans-610
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Add `5` to the passed number:'
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`5`加到传递的数字上：
- en: '[PRE164]'
  id: totrans-612
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Print the updated number to the console:'
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更新的数字打印到控制台：
- en: '[PRE165]'
  id: totrans-614
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Close the function:'
  id: totrans-615
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭函数：
- en: '[PRE166]'
  id: totrans-616
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Create another function that takes an `int` pointer:'
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个接受`int`指针的函数：
- en: '[PRE167]'
  id: totrans-618
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Dereference the value and add `5` to it:'
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解引用值并加`5`：
- en: '[PRE168]'
  id: totrans-620
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Print out the updated value of `count` and dereference it:'
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出更新后的`count`值并解引用它：
- en: '[PRE169]'
  id: totrans-622
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Close the function:'
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭函数：
- en: '[PRE170]'
  id: totrans-624
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Create the `main()` function:'
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE171]'
  id: totrans-626
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Declare an `int` variable:'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`int`变量：
- en: '[PRE172]'
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Call the first function with the variable:'
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用变量调用第一个函数：
- en: '[PRE173]'
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Print the current value of the variable:'
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印变量的当前值：
- en: '[PRE174]'
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Call the second function. This time, you''ll need to use `&` to pass a pointer
    to the variable:'
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用第二个函数。这次，你需要使用`&`来传递变量的指针：
- en: '[PRE175]'
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Print the current value of the variable:'
  id: totrans-635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印变量的当前值：
- en: '[PRE176]'
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Close the `main()` function:'
  id: totrans-637
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main()`函数：
- en: '[PRE177]'
  id: totrans-638
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新文件夹中运行以下命令：
- en: '[PRE178]'
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'The following is the output:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对输出：
- en: '![Figure 1.21: Output displaying the current value of the variable'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.21：显示变量当前值的输出]'
- en: '](img/B14177_01_21.jpg)'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_01_21.jpg]'
- en: 'Figure 1.21: Output displaying the current value of the variable'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.21：显示变量当前值的输出
- en: In this exercise, we showed you how passing values by a pointer can affect the
    value variables that are passed to them. We saw that, when passing by value, the
    changes you make to the value in a function do not affect the value of the variable
    that's passed to the function, while passing a pointer to a value does change
    the value of the variable passed to the function.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们向你展示了通过指针传递值如何影响传递给函数的变量值。我们看到，在按值传递时，你在函数中对值所做的更改不会影响传递给函数的变量值，而传递值的指针会改变传递给函数的变量值。
- en: You can use this fact to overcome awkward design problems and sometimes simplify
    the design of your code. Passing values by a pointer has traditionally been shown
    to be more error-prone, so use this design sparingly. It's also common to use
    pointers in functions to create more efficient code, which Go's standard library
    does a lot.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用这个事实来解决尴尬的设计问题，有时还可以简化你代码的设计。通过指针传递值传统上被认为更容易出错，因此请谨慎使用这种设计。在函数中使用指针以创建更高效的代码也是常见的，Go的标准库就做了很多这方面的工作。
- en: 'Activity 1.02: Pointer Value Swap'
  id: totrans-647
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1.02：指针值交换
- en: 'In this activity, your job is to finish some code a co-worker started. Here,
    we have some unfinished code for you to complete. Your task is to fill in the
    missing code, where the comments are to swap the values of `a` and `b`. The `swap`
    function only accepts pointers and doesn''t return anything:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你的任务是完成一位同事开始的一些代码。在这里，我们有一些未完成的代码需要你完成。你的任务是填写缺失的代码，其中注释指示交换`a`和`b`的值。`swap`函数只接受指针，并且不返回任何内容：
- en: '[PRE179]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Call the `swap` function, ensuring you are passing a pointer.
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`swap`函数时，确保你传递的是指针。
- en: In the `swap` function, assign the values to the other pointer, ensuring you
    dereference the values.
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`swap`函数中，将值赋给另一个指针，确保你解引用了这些值。
- en: 'The following is the expected output:'
  id: totrans-652
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是我们预期的输出：
- en: '[PRE180]'
  id: totrans-653
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Note
  id: totrans-654
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 685
  id: totrans-655
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第685页找到
- en: Next, we'll look at how we can create variables with a fixed value.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何创建具有固定值的变量。
- en: Constants
  id: totrans-657
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: Constants are like variables, but you can't change their initial value. These
    are useful for situations where the value of a constant doesn't need to or shouldn't
    change when your code is running. You could make the argument that you could hardcode
    those values into the code and it would have a similar effect. Experience has
    shown us that while these values don't need to change at runtime, they may need
    to change later. If that happens, it can be an arduous and error-prone task to
    track down and fix all the hardcoded values. Using a constant is a tiny amount
    of work now that can save you a great deal of effort later.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 常量就像变量，但你不能更改它们的初始值。这些在代码运行时常量的值不需要或不应更改的情况下非常有用。你可以认为你可以将这些值硬编码到代码中，它会产生类似的效果。经验表明，虽然这些值在运行时不需要更改，但它们可能需要在以后更改。如果发生这种情况，追踪和修复所有硬编码的值可能是一项艰巨且容易出错的任务。使用常量现在只需做一点工作，但可以在以后节省你大量的精力。
- en: 'Constant declarations are similar to `var` statements. With a constant, the
    initial value is required. Types are optional and inferred if left out. The initial
    value can be a literal or a simple statement and can use the values of other constants.
    Like `var`, you can declare multiple constants in one statement. Here are the
    notations:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 常量声明与`var`语句类似。常量需要提供一个初始值。类型是可选的，如果省略则自动推断。初始值可以是字面量或简单的语句，并且可以使用其他常量的值。像`var`一样，你可以在一个语句中声明多个常量。以下是一些表示法：
- en: '[PRE181]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Exercise 1.16: Constants'
  id: totrans-661
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.16：常量
- en: 'In this exercise, we have a performance problem. Our database server is too
    slow. We are going to create a custom memory cache. We''ll use Go''s `map` collection
    type, which will act as the cache. There is a global limit on the number of items
    that can be in the cache. We''ll use one `map` to help keep track of the number
    of items in the cache. We have two types of data we need to cache: books and CDs.
    Both use the ID, so we need a way to separate the two types of items in the shared
    cache. We need a way to set and get items from the cache.'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们遇到了性能问题。我们的数据库服务器运行得太慢。我们将创建一个自定义内存缓存。我们将使用Go的`map`集合类型，它将充当缓存。缓存中可以存储的项目数量有一个全局限制。我们将使用一个`map`来帮助跟踪缓存中项目的数量。我们需要缓存两种类型的数据：书籍和CD。两者都使用ID，因此我们需要一种方法在共享缓存中区分这两种类型的项目。我们需要一种方法来设置和获取缓存中的项目。
- en: 'We''re going to set the maximum number of items in the cache. We''ll also use
    constants to add a prefix to differentiate between books and CDs. Let''s get started:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置缓存中项的最大数量。我们还将使用常量来添加前缀，以区分书籍和CD。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并将`main.go`文件添加到其中。
- en: 'In `main.go`, add the `main` package name to the top of the file:'
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将`main`包名添加到文件顶部：
- en: '[PRE182]'
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'Import the packages we''ll need:'
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们将需要的包：
- en: '[PRE183]'
  id: totrans-668
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Create a constant that''s our global limit size:'
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个代表全局限制大小的常量：
- en: '[PRE184]'
  id: totrans-670
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Create a `MaxCacheSize` that is 10 times the global limit size:'
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`MaxCacheSize`，它是全局限制大小的10倍：
- en: '[PRE185]'
  id: totrans-672
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Create our cache prefixes:'
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的缓存前缀：
- en: '[PRE186]'
  id: totrans-674
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Declare a `map` that has a `string` for a key and a `string` for its values
    as our cache:'
  id: totrans-675
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个具有`string`键和`string`值的`map`作为我们的缓存：
- en: '[PRE187]'
  id: totrans-676
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Create a function to get items from the cache:'
  id: totrans-677
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从缓存中获取项的函数：
- en: '[PRE188]'
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Create a function that sets items in the cache:'
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个设置缓存中项的函数：
- en: '[PRE189]'
  id: totrans-680
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'In this function, check out the `MaxCacheSize` constant to stop the cache going
    over that size:'
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数中，查看`MaxCacheSize`常量以防止缓存超过该大小：
- en: '[PRE190]'
  id: totrans-682
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Create a function to get a book from the cache:'
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从缓存中获取书籍的函数：
- en: '[PRE191]'
  id: totrans-684
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Use the book cache prefix to create a unique key:'
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用书缓存前缀来创建一个唯一的键：
- en: '[PRE192]'
  id: totrans-686
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Create a function to add a book to the cache:'
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个向缓存中添加书的函数：
- en: '[PRE193]'
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Use the book cache prefix to create a unique key:'
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用书缓存前缀来创建一个唯一的键：
- en: '[PRE194]'
  id: totrans-690
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Create a function to get CD data from the cache:'
  id: totrans-691
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从缓存中获取CD数据的函数：
- en: '[PRE195]'
  id: totrans-692
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Use the `CD` cache prefix to create a unique key:'
  id: totrans-693
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CD`缓存前缀来创建一个唯一的键：
- en: '[PRE196]'
  id: totrans-694
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Create a function to add CDs to the shared cache:'
  id: totrans-695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个向共享缓存添加CD的函数：
- en: '[PRE197]'
  id: totrans-696
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'Use the `CD` cache prefix constant to build a unique key for the shared cache:'
  id: totrans-697
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`CD`缓存前缀常量来为共享缓存构建一个唯一的键：
- en: '[PRE198]'
  id: totrans-698
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Create the `main()` function:'
  id: totrans-699
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE199]'
  id: totrans-700
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'Initialize our cache by creating a `map`:'
  id: totrans-701
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建`map`来初始化我们的缓存：
- en: '[PRE200]'
  id: totrans-702
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Add a book to the cache:'
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向缓存中添加一本书：
- en: '[PRE201]'
  id: totrans-704
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Add a `CD` to the cache:'
  id: totrans-705
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向缓存中添加一个`CD`：
- en: '[PRE202]'
  id: totrans-706
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Get and print that `Book` from the cache:'
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从缓存中获取并打印那个`Book`：
- en: '[PRE203]'
  id: totrans-708
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Get and print that `CD` from the cache:'
  id: totrans-709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从缓存中获取并打印那个`CD`：
- en: '[PRE204]'
  id: totrans-710
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Close the `main()` function:'
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main()`函数：
- en: '[PRE205]'
  id: totrans-712
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后在新的文件夹中，运行以下命令：
- en: '[PRE206]'
  id: totrans-714
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'The following is the output:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![Figure 1.22: Output displaying the Book and CD caches'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.22：显示书籍和CD缓存的输出'
- en: '](img/B14177_01_22.jpg)'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_01_22.jpg)'
- en: 'Figure 1.22: Output displaying the Book and CD caches'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.22：显示书籍和CD缓存的输出
- en: In this exercise, we used constants to define values that don't need to change
    while the code is running. We declared then using a variety of notation options,
    some with the typeset and some without. We declared a single constant and multiple
    constants in a single statement.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用常量来定义在代码运行期间不需要更改的值。我们使用各种表示法声明了它们，一些带有类型设置，一些没有。我们声明了一个单个常量，并在一个语句中声明了多个常量。
- en: Next, we'll look at a variation of constants for values that are more closely
    related.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨与值更紧密相关的常量的变体。
- en: Enums
  id: totrans-721
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: Enums are a way of defining a fixed list of values that are all related. Go
    doesn't have a built-in type for enums, but it does provide tools such as `iota`
    to let you define your own using constants, which we'll explore now.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举是定义一组相关值的固定列表的方式。Go没有内置的枚举类型，但它提供了如`iota`之类的工具，让你可以使用常量定义自己的枚举，我们现在将探讨这一点。
- en: 'For example, in the following code, we have the days of the week defined as
    constants. This code is a good candidate for Go''s `iota` feature:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下代码中，我们将一周中的日子定义为常量。这段代码是Go的`iota`功能的良好候选：
- en: '[PRE207]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'With `iota`, Go helps us manage lists just like this. Using `iota`, the following
    code is equal to the preceding code:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`iota`，Go帮助我们像这样管理列表。使用`iota`，以下代码等同于前面的代码：
- en: '[PRE208]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: Now, we have `iota` assigning the numbers for us. Using `iota` makes enums easier
    to create and maintain, especially if you need to add a new value to the middle
    of the code later.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有`iota`为我们分配数字。使用`iota`使得枚举更容易创建和维护，尤其是当你需要在代码的中间添加新值时。
- en: Next, we'll take a detailed look at Go's variable scoping rules and how they
    affect how you write code.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将详细探讨Go的变量作用域规则以及它们如何影响你编写代码的方式。
- en: Scope
  id: totrans-729
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域
- en: All the variables in Go live in a scope. The top-level scope is the package
    scope. A scope can have child scopes within it. There are a few ways a child scope
    gets defined; the easiest way to think about this is that when you see `{`, you
    are starting a new child scope, and that child scope ends when you get to a matching
    `}`. The parent-child relationship is defined when the code compiles, not when
    the code runs. When accessing a variable, Go looks at the scope the code was defined
    in. If it can't find a variable with that name, it looks in the parent scope,
    then the grandparent scope, all the way until it gets to the package scope. It
    stops looking once it finds a variable with a matching name or raises an error
    if it can't find a match.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的所有变量都存在于作用域中。顶级作用域是包作用域。作用域可以包含其内部的作用域。定义子作用域有几种方式；最容易想到的是，当你看到 `{` 时，你开始了一个新的子作用域，并且这个子作用域在遇到匹配的
    `}` 时结束。父-子关系是在代码编译时定义的，而不是在代码运行时。当访问一个变量时，Go 会查看代码定义的作用域。如果它找不到具有该名称的变量，它会查看父作用域，然后是祖父作用域，一直到最后到达包作用域。一旦找到匹配名称的变量，它就会停止搜索；如果找不到匹配项，则会引发错误。
- en: To put it another way, when your code uses a variable, Go needs to work out
    where that variable was defined. It starts its search in the scope of the code
    using the variable it's currently running in. If a variable definition using that
    name is in that scope, then it stops looking and uses the variable definition
    to complete its work. If it can't find a variable definition, then it starts walking
    up the stack of scopes, stopping as soon as it finds a variable with that name.
    This searching is all done based on a variable name. If a variable with that name
    is found but is of the wrong type, Go raises an error.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当你的代码使用一个变量时，Go 需要确定该变量是在哪里定义的。它从当前正在运行的代码的作用域开始搜索。如果在那个作用域中有一个使用该名称的变量定义，那么它就会停止搜索并使用该变量定义来完成其工作。如果它找不到变量定义，那么它就会开始沿着作用域栈向上搜索，一旦找到具有该名称的变量就停止搜索。这种搜索完全是基于变量名称进行的。如果在找到该名称的变量但类型不正确时，Go
    会引发错误。
- en: 'In this example, we have four different scopes, but we define the `level` variable
    once. This fact means that no matter where you use `level`, the same variable
    is used:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们有四个不同的作用域，但我们只定义了 `level` 变量一次。这个事实意味着无论你在哪里使用 `level`，都使用的是同一个变量：
- en: '[PRE209]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'The following is the output displaying variables using level:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为使用级别显示变量的输出：
- en: '[PRE210]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'In this example, we''ve shadowed the `level` variable. This new `level` variable
    is not related to the `level` variable in the package scope. When we print `level`
    in the block, the Go runtime stops looking for variables called `level` as soon
    as it finds the one defined in `main`. This logic results in a different value
    getting printed out once that new variable shadows the package variable. You can
    also see that it''s a different variable because it''s a different type, and a
    variable can''t have its type changed in Go:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们已隐藏了 `level` 变量。这个新的 `level` 变量与包作用域中的 `level` 变量无关。当我们在这个代码块中打印 `level`
    时，Go 运行时会立即停止寻找名为 `level` 的变量，因为它已经找到了在 `main` 中定义的那个。这种逻辑导致一旦新变量遮蔽了包变量，就会打印出不同的值。您也可以看到它是一个不同的变量，因为它是一个不同的类型，而在
    Go 中变量类型不能改变：
- en: '[PRE211]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'The following is the output:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出：
- en: '[PRE212]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Go's static scope resolution comes into play when we call `funcA`. That's why,
    when `funcA` runs, it still sees the package scope `level` variable. The scope
    resolution doesn't pay attention to where `funcA` gets called.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `funcA` 时，Go 的静态作用域解析开始发挥作用。这就是为什么当 `funcA` 运行时，它仍然可以看到包作用域中的 `level`
    变量。作用域解析不会关注 `funcA` 是在哪里被调用的。
- en: 'You can''t access variables defined in a child scope:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能访问在子作用域中定义的变量：
- en: '[PRE213]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'The following is the output:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为输出：
- en: '![Figure 1.23: Output displaying an error'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.23：显示错误的输出'
- en: '](img/B14177_01_23.jpg)'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_01_23.jpg](img/B14177_01_23.jpg)'
- en: 'Figure 1.23: Output displaying an error'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.23：显示错误的输出
- en: 'Activity 1.03: Message Bug'
  id: totrans-747
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 1.03：消息错误
- en: The following code doesn't work. The person who wrote it can't fix it, and they've
    asked you to help them. Can you get it to work?
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码无法工作。编写此代码的人无法修复它，他们已经要求你帮助他们。你能让它工作吗？
- en: '[PRE214]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: Run the code and see what the output is.
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看输出结果。
- en: The problem is with the `message`; make a change to the code.
  id: totrans-751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题出在 `message` 上；对代码进行修改。
- en: Rerun the code and see what difference it makes.
  id: totrans-752
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行代码并查看它有什么不同。
- en: Repeat this process until you see the expected output.
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此过程，直到看到预期输出。
- en: 'The following is the expected output:'
  id: totrans-754
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为预期输出：
- en: '[PRE215]'
  id: totrans-755
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: Note
  id: totrans-756
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 685
  id: totrans-757
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可在第685页找到
- en: In this activity, we saw that where you define your variables has a big impact
    on the code. Always think about the scope you need your variables to be in when
    defining them.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们看到了你定义变量的位置对代码有很大的影响。在定义变量时，始终要考虑你需要变量处于哪个作用域。
- en: In the next activity, we are going to look at a similar problem that is a bit
    trickier.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，我们将研究一个类似但稍微复杂一点的问题。
- en: 'Activity 1.04: Bad Count Bug'
  id: totrans-760
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动一.04：错误计数问题
- en: Your friend is back, and they have another bug in their code. This code should
    print `true`, but it's printing `false`. Can you help them fix the bug?
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 你的朋友又回来了，他们代码中又有了一个bug。这段代码应该打印`true`，但它打印的是`false`。你能帮助他们修复这个bug吗？
- en: '[PRE216]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: Run the code and see what the output is.
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并查看输出结果。
- en: The problem is with `count`; make a change to the code.
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 问题出在`count`上；对代码进行修改。
- en: Rerun the code and see what difference it makes.
  id: totrans-765
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新运行代码，看看它有什么不同。
- en: Repeat this process until you see the expected output.
  id: totrans-766
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此过程，直到你看到预期的输出。
- en: 'The following is the expected output:'
  id: totrans-767
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为预期的输出：
- en: '[PRE217]'
  id: totrans-768
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: Note
  id: totrans-769
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 686
  id: totrans-770
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可在第686页找到
- en: Summary
  id: totrans-771
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we got into the nitty-gritty of variables, including how variables
    are declared, and all the different notations you can use to declare them. This
    variety of notation gives you a nice compact notation to use for 90% of your work,
    while still giving you the power to be very specific when you need to the other
    10% of the time. We looked at how to change and update the value of variables
    after you've declared them. Again, Go gives you some great shorthand to help in
    the most common use cases to make your life easier. All your data ends up in some
    form of variable. Data is what makes code dynamic and responsive. Without data,
    your code could only ever do exactly one thing; data unleashes the true power
    of software.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了变量的细节，包括如何声明变量以及你可以用来声明变量的所有不同符号。这种符号的多样性为你提供了90%工作中使用的简洁符号，同时仍然在你需要时提供非常具体的10%的能力。我们探讨了在声明变量后如何更改和更新变量的值。同样，Go为你提供了一些简写，以帮助在最常见的用例中使你的生活更轻松。所有你的数据最终都以某种形式存储在变量中。数据使代码变得动态和响应。没有数据，你的代码只能永远做一件事；数据释放了软件的真正力量。
- en: Now that your application has data, it needs to make choices based on that data.
    That's where variable comparison comes in. This helps us see whether something
    is true or false, bigger or smaller, and to make choices based on the results
    of those comparisons.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的应用程序有了数据，它需要根据这些数据做出选择。这就是变量比较发挥作用的地方。这有助于我们判断某事是真是假，是更大还是更小，并基于这些比较的结果做出选择。
- en: We explored how Go decided to implement their variable system by looking at
    zero values, pointers, and scope logic. Now, we know that these are the details
    that can be the difference between delivering bug-free efficient software and
    not doing so.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看零值、指针和作用域逻辑，我们研究了Go如何实现其变量系统。现在，我们知道这些细节是交付无bug高效软件和未能做到之间的区别。
- en: We also took a look at how we can declare immutable variables by using constants
    and how `iota` can help manage lists or related constants to work, such as enums.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如何通过使用常量来声明不可变变量，以及`iota`如何帮助管理列表或相关常量，例如枚举。
- en: In the next chapter, we'll start to put our variables to work by defining logic
    and looping over collections of variables.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始通过定义逻辑和遍历变量集合来使用我们的变量。
