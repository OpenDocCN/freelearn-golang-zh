<html><head></head><body>
		<div>
			<div id="_idContainer041" class="Content">
			</div>
		</div>
		<div id="_idContainer042" class="Content">
			<h1 id="_idParaDest-88"><a id="_idTextAnchor091"/>3. Core Types</h1>
		</div>
		<div id="_idContainer057" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter aims to show you how to use Go's basic core types to design your software's data. We'll work through each type to show what they are useful for and how to use them in your software. Understanding these core types provides you with the foundation required to learn how to create complex data designs.</p>
			<p class="callout">By the end of this chapter, you will be able to create variables of different types for Go programs and assign values to variables of different types. You will learn to identify and pick a suitable type for any programming situation. You will also write a program to measure password complexity and implement empty value types.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor092"/>Introduction</h1>
			<p>In the previous chapter, we learned how to use <strong class="source-inline">if</strong>, <strong class="source-inline">if</strong>-<strong class="source-inline">else</strong>, <strong class="source-inline">switch</strong>, <strong class="source-inline">continue</strong>, and <strong class="source-inline">break</strong> in Go.</p>
			<p>Go is a strongly typed language, and all data is assigned a type. That type is fixed and can't be changed. What you can and can't do with your data is constrained by the types you assign. Understanding exactly what defines every one of Go's core types is critical to success with the Go language. </p>
			<p>In later chapters, we'll talk about Go's more complex types, but those types are built on the core types defined in this chapter.</p>
			<p>Go's core types are well-thought-out and easy to understand once you understand the details. Having to understand the details means Go's type system is not always intuitive. For example, Go's most common number type, <strong class="source-inline">int</strong>, may be either 32 bits or 64 bits in size depending on the computer used to compile the code.</p>
			<p>Types are needed to make data easier for humans to work with. Computers only think about data in binary. Binary is hard for people to work with. By adding a layer of abstraction to binary data and labeling it as a number or some text, humans have an easier time reasoning about it. Reducing the cognitive load allows people to build more complex software because they're not overwhelmed by managing the details of the binary data.</p>
			<p>Programming languages need to define what a number is or what a text is for. A programming language defines what you can call a number, and it defines what operations you can use on a number. For example, can a whole number such as 10 and a floating-point number such as 3.14 both be stored as the same type? While it seems obvious that you can multiply numbers, can you multiply text? As we progress through this chapter, we'll clearly define what the rules are for each type and what operations you can use with each of them.</p>
			<p>The way data is stored is also a large part of what defines a <strong class="source-inline">type</strong>. To allow for the building of efficient software, Go places limits on how large some of its types can be. For example, the largest amount of storage for a number in Go's core types is 64 bits of memory. This allows for any number up to 18,446,744,073,709,551,615. Understanding these type limitations is critical in building bug-free code.</p>
			<p>The things that define a type are:</p>
			<ul>
				<li>The kind of data that you can store in it</li>
				<li>What operations you can use with it</li>
				<li>What those operations do to it</li>
				<li>How much memory it can use</li>
			</ul>
			<p>This chapter gives you the knowledge and confidence to use Go's types system correctly in your code.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor093"/>True and False</h1>
			<p>True and false logic is represented using the Boolean type, <strong class="source-inline">bool</strong>. Use this type when you need an on/off switch in your code. The value of a <strong class="source-inline">bool</strong> can only ever be <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. The zero value of a <strong class="source-inline">bool</strong> is <strong class="source-inline">false</strong>.</p>
			<p>When using a comparison operator such as <strong class="source-inline">==</strong> or <strong class="source-inline">&gt;</strong>, the result of that comparison is a <strong class="source-inline">bool</strong> value.  </p>
			<p>In this code example, we use comparison operators on two numbers. You'll see that the result is a <strong class="source-inline">bool</strong>:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  fmt.Println(10 &gt; 5)</p>
			<p class="source-code">  fmt.Println(10 == 5)</p>
			<p class="source-code">}</p>
			<p>Running the preceding code shows the following output:</p>
			<p class="source-code">true</p>
			<p class="source-code">false</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor094"/>Exercise 3.01: Program to Measure Password Complexity</h2>
			<p>An online portal creates user accounts for its users and accepts passwords that are only 8-15 characters long. In this exercise, we write a program for the portal to display whether the password entered meets the character requirements. The character requirements are as follows:</p>
			<ul>
				<li>Have a lowercase letter</li>
				<li>Have an uppercase letter</li>
				<li>Have a number</li>
				<li>Have a symbol</li>
				<li>Be 8 or more characters long</li>
			</ul>
			<p>To do this exercise, we're going to use a few new features. Don't worry if you don't quite understand what they are doing; we'll cover them in detail in the next chapter. Consider this a sneak peek. We'll explain what everything is as we go, but your main focus should be on the Boolean logic:</p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the main package name to the top of the file:<p class="source-code">package main</p></li>
				<li>Now add the imports we'll use in this file:<p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "unicode"</p><p class="source-code">)</p></li>
				<li>Create a function that takes a string argument and returns a <strong class="source-inline">bool</strong>:<p class="source-code">func passwordChecker(pw string) bool {</p></li>
				<li>Convert the password string into <strong class="source-inline">rune</strong>, which is a type that is safe for multi-byte (UTF-8) characters:<p class="source-code">  pwR := []rune(pw)</p><p>We'll talk more about rune later in this chapter.</p></li>
				<li>Count the number of multi-byte characters using <strong class="source-inline">len</strong>. This code results in a <strong class="source-inline">bool</strong> result that can be used in the <strong class="source-inline">if</strong> statement:<p class="source-code">  if len(pwR) &lt; 8 {</p><p class="source-code">    return false</p><p class="source-code">  }</p></li>
				<li>Define some <strong class="source-inline">bool</strong> variables. We'll check these at the end:<p class="source-code">  hasUpper := false</p><p class="source-code">  hasLower := false</p><p class="source-code">  hasNumber := false</p><p class="source-code">  hasSymbol := false</p></li>
				<li>Loop over the multi-byte characters one at a time:<p class="source-code">  for _, v := range pwR {</p></li>
				<li>Using the <strong class="source-inline">unicode</strong> package, check whether this character is uppercase. This function returns a <strong class="source-inline">bool</strong> that we can use directly in the <strong class="source-inline">if</strong> statement:<p class="source-code">  if unicode.IsUpper(v) {</p></li>
				<li>If it is, we'll set the <strong class="source-inline">hasUpper</strong> <strong class="source-inline">bool</strong> variable to <strong class="source-inline">true</strong>:<p class="source-code">    hasUpper = true</p><p class="source-code">  }</p></li>
				<li>Do the same thing for lowercase letters:<p class="source-code">  if unicode.IsLower(v) {</p><p class="source-code">    hasLower = true</p><p class="source-code">  }</p></li>
				<li>Also do it for numbers:<p class="source-code">  if unicode.IsNumber(v) {</p><p class="source-code">    hasNumber = true</p><p class="source-code">  }</p></li>
				<li>For symbols, we'll also accept punctuation. Use the <strong class="source-inline">or</strong> operator, which works with <strong class="source-inline">Booleans</strong>, to result in <strong class="source-inline">true</strong> if either of these functions returns <strong class="source-inline">true</strong>:<p class="source-code">  if unicode.IsPunct(v) || unicode.IsSymbol(v)  {</p><p class="source-code">    hasSymbol = true</p><p class="source-code">  }</p><p class="source-code">  }</p></li>
				<li>To pass all our checks, all our variables must be <strong class="source-inline">true</strong>. Here, we combine multiple <strong class="source-inline">and</strong> operators to create a one-line statement that checks all four variables:<p class="source-code">  return hasUpper &amp;&amp; hasLower &amp;&amp; hasNumber &amp;&amp; hasSymbol</p></li>
				<li>Close the function:<p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Call the <strong class="source-inline">passwordChecker()</strong> function with an invalid password. As this returns a <strong class="source-inline">bool</strong>, it can be used directly in an <strong class="source-inline">if</strong> statement:<p class="source-code">  if passwordChecker("") {</p><p class="source-code">  fmt.Println("password good")</p><p class="source-code">  } else {</p><p class="source-code">  fmt.Println("password bad")</p><p class="source-code">  }</p></li>
				<li>Now, call the function with a valid password:<p class="source-code">  if passwordChecker("This!I5A") {</p><p class="source-code">  fmt.Println("password good")</p><p class="source-code">  } else {</p><p class="source-code">  fmt.Println("password bad")</p><p class="source-code">  }</p></li>
				<li>Close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p></li>
				<li>Save the file and in the new folder and then run the following:<p class="source-code">go run main.go</p><p>Running the preceding code shows the following output:</p></li>
			</ol>
			<p class="source-code">password bad</p>
			<p class="source-code">password good</p>
			<p>In this exercise, we highlighted a variety of ways that <strong class="source-inline">bool</strong> values manifest themselves in the code. <strong class="source-inline">Bool</strong> values are critical to giving your code the ability to make a choice and be dynamic and responsive. Without <strong class="source-inline">bool</strong>, your code would have a hard time doing anything.</p>
			<p>Next, we'll take a look at numbers and how Go categorizes them. </p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor095"/>Numbers</h1>
			<p>Go has two distinct number types: integers, also known as whole numbers, and floating-point numbers. A floating-point number allows a number with whole numbers and fractions of a whole number. </p>
			<p>1, 54, and 5,436 are examples of whole numbers. 1.5, 52.25, 33.333, and 64,567.00001 are all examples of floating-point numbers.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The default and empty values for all number types is 0.</p>
			<p>Next, we'll start our number journey by looking at integers.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor096"/>Integer</h2>
			<p>Integer types are classified in two ways, based on the following conditions:</p>
			<ul>
				<li>Whether or not they can store negative numbers</li>
				<li>The smallest and largest numbers they can store</li>
			</ul>
			<p>Types that can store negative numbers are called signed integers. Types that can't store negative numbers are called unsigned integers. How big and small a number each type can store is expressed by how many bytes of internal storage they have.</p>
			<p>Here is an excerpt from the Go language specification with all the relevant integer types:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B14177_03_01.jpg" alt="Figure 3.01: Go language specification with relevant integer types&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.01: Go language specification with relevant integer types</p>
			<p>There are also special integer types as follows:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B14177_03_02.jpg" alt="Figure 3.02: Special integer types&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.02: Special integer types</p>
			<p><strong class="source-inline">uint</strong> and <strong class="source-inline">int</strong> are either 32 or 64 bits depending on whether you compile your code for a 32-bit system or a 64-bit system. It's rare nowadays to run applications on a 32-bit system, systems so most of the time they are 64 bits.</p>
			<p>An <strong class="source-inline">int</strong> on a 64-bit system is not an <strong class="source-inline">int64</strong>. While these two types are identical, they are not the same integer type, and you can't use them together. If Go did allow this, there would be problems when the same code gets compiled for a 32-bit machine, so keeping them separate ensures that the code is reliable. </p>
			<p>This incompatibility is not just an <strong class="source-inline">int</strong> thing; you can't use any of the integer types together. </p>
			<p>Picking the correct integer type to use when defining a variable is easy: use <strong class="source-inline">int</strong>. When writing code for an application, <strong class="source-inline">int</strong> does the job the majority of the time. Only think about using the other types when an <strong class="source-inline">int</strong> is causing a problem. The sorts of problems you see with <strong class="source-inline">int</strong> tend to be related to memory usage.</p>
			<p>For example, let's say you have an app that's running out of memory. The app uses a massive number of integers, but these integers are never negative and won't go over 255. One possible fix is to switch from using <strong class="source-inline">int</strong> to using <strong class="source-inline">uint8</strong>. Doing this cuts its memory usage from 64 bits (8 bytes) per number to 8 bits (1 byte) per number.</p>
			<p>We can show this by creating a collection of both kinds of type then asking Go how much heap memory it is using. The output may vary on your computer, but the effect should be similar. This code creates a collection of <strong class="source-inline">int</strong> or <strong class="source-inline">int8</strong>. It then adds 10 million values to the collection. Once that's done, it uses the runtime package to give us a reading of how much heap memory is being used. We convert that reading to MB and then print it out:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "runtime"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  var list []int</p>
			<p class="source-code">  //var list []int8</p>
			<p class="source-code">  for i := 0; i &lt; 10000000; i++ {</p>
			<p class="source-code">    list = append(list, 100)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  var m runtime.MemStats</p>
			<p class="source-code">  runtime.ReadMemStats(&amp;m)</p>
			<p class="source-code">  fmt.Printf("TotalAlloc (Heap) = %v MiB\n", m.TotalAlloc/1024/1024)</p>
			<p class="source-code">}</p>
			<p>Here's the output using <strong class="source-inline">int</strong>:</p>
			<p class="source-code">TotalAlloc (Heap) = 403 MiB </p>
			<p>And here's the output using <strong class="source-inline">int8</strong>:</p>
			<p class="source-code">TotalAlloc (Heap) = 54 MiB </p>
			<p>We saved a good amount of memory here, but we need 10 million variables to make it worthwhile. Hopefully, now you are convinced that it's okay to start with <strong class="source-inline">int</strong> and only worry about performance when it's a problem, not before.</p>
			<p>Next, we'll look at floating-point numbers.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor097"/>Floating Point</h2>
			<p>Go has two floating-point number types, <strong class="source-inline">float32</strong> and <strong class="source-inline">float64</strong>. The bigger <strong class="source-inline">float64</strong> allows for more precision in the numbers. <strong class="source-inline">float32</strong> has 32 bits of storage and <strong class="source-inline">float64</strong> has 64 bits of storage. Floats split their storage between whole numbers (everything to the left of the decimal point) and decimal numbers (everything to the right of the decimal point). How much space is used for the whole number or the decimal numbers, varies by the number being stored. For example, 9,999.9 would use more storage for the whole numbers while 9.9999 would use more storage for the decimal numbers. With <strong class="source-inline">float64</strong>'s bigger space for storage, it can store more whole numbers and/or more decimal numbers than <strong class="source-inline">float32</strong> can.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor098"/>Exercise 3.02: Floating-Point Number Accuracy</h2>
			<p>In this exercise, we're going to compare what happens when we do some divisions on numbers that don't divide equally. We'll be dividing 100 by 3. One way of representing the result is 33 ⅓. Computers, for the most part, can't compute fractions like this. Instead, they use a decimal representation, which is 33.3 recurring, where the 3 after the decimal point repeats forever. If we let the computer do that it uses up all the memory, which is not very helpful. </p>
			<p>Luckily for us, we don't need to worry about this happening as the floating-point types have storage limits. The downside is that this leads to a number that doesn't reflect the true result; the result has a certain amount of inaccuracy. Your tolerance for inaccuracy needs and how much storage space you want to give to your floating-point numbers must be balanced out:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the main package name to the top of the file:<p class="source-code">package main</p></li>
				<li>Now add the imports we'll use in this file:<p class="source-code">import "fmt"</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Declare an <strong class="source-inline">int</strong> and initialize it with a value of 100:<p class="source-code">  var a int = 100</p></li>
				<li>Declare a <strong class="source-inline">float32</strong> and initialize it with a value of 100:<p class="source-code">  var b float32 = 100</p></li>
				<li>Declare a <strong class="source-inline">float64</strong> and initialize it with a value of 100:<p class="source-code">  var c float64 = 100</p></li>
				<li>Divide each variable by 3 and print the result to the console:<p class="source-code">  fmt.Println(a / 3)</p><p class="source-code">  fmt.Println(b / 3)</p><p class="source-code">  fmt.Println(c / 3)</p><p class="source-code">}</p></li>
				<li>Save the file and in the new folder run the following:<p class="source-code">go run main.go</p><p>Running the preceding code shows the following output displaying <strong class="source-inline">int</strong>, <strong class="source-inline">float32</strong>, and <strong class="source-inline">float64</strong> values:</p><p class="source-code">33</p><p class="source-code">33.333332</p><p class="source-code">33.333333333333336</p></li>
			</ol>
			<p>In this exercise, we can see that the computer is not able to give perfect answers to this sort of division. You can also see that when doing this sort of math on integers, you don't get an error. Go ignores any fractional part of the number, which is usually not what you want. We can also see that the <strong class="source-inline">float64</strong> gives a much more accurate answer than <strong class="source-inline">float32</strong>.</p>
			<p>While this limit seems like it would lead to problems with inaccuracy, for real-world business work, it does get the job done well enough the vast majority of the time.</p>
			<p>Let's see what happens if we try to get our number back to 100 by multiplying it by 3:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  var a int = 100</p>
			<p class="source-code">  var b float32 = 100</p>
			<p class="source-code">  var c float64 = 100</p>
			<p class="source-code">  fmt.Println((a / 3) * 3)</p>
			<p class="source-code">  fmt.Println((b / 3) * 3)</p>
			<p class="source-code">  fmt.Println((c / 3) * 3)</p>
			<p class="source-code">}</p>
			<p>Running the preceding code shows the following output:</p>
			<p class="source-code">99</p>
			<p class="source-code">100</p>
			<p class="source-code">100</p>
			<p>In this example, we saw that the accuracy is not as impacted as much as you'd expect. At first glance, floating-point math can seem simple, but it gets complicated quickly. When defining your floating-point variables, typically <strong class="source-inline">float64</strong> should be your first choice unless you need to be more memory efficient. </p>
			<p>Next, we'll look at what happens when you go beyond the limits of a number type.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor099"/>Overflow and Wraparound</h2>
			<p>When you try to initialize a number with a value that's too big for the type we are using, you get an overflow error. The highest number you can have in an <strong class="source-inline">int8</strong> is 127. In the following code, we'll try to initialize it with 128 and see what happens:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  var a int8 = 128</p>
			<p class="source-code">  fmt.Println(a)</p>
			<p class="source-code">}</p>
			<p>Running the preceding code gives the following output:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B14177_03_03.jpg" alt="Figure 3.03: Output after initializing with 128&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.03: Output after initializing with 128</p>
			<p>This error is easy to fix and can't cause any hidden problems. The real problem is when the compiler can't catch it. When this happens, the number will ".wraparound". Wraparound means the number goes from its highest possible value to its smallest possible value. Wraparound can be easy to miss when developing your code and can cause significant problems to your users.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor100"/>Exercise 3.03: Triggering Number Wraparound</h2>
			<p>In this exercise, we'll declare two small integer types: <strong class="source-inline">int8</strong> and <strong class="source-inline">uint8</strong>. We'll initialize them near their highest possible value. Then we'll use a loop statement to increment them by 1 per loop then print their value to the console. We'll be able to see exactly when they wraparound. </p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file.</li>
				<li>In <strong class="source-inline">main.go</strong> add the main package name to the top of the file:<p class="source-code">package main</p></li>
				<li>Now add the imports we'll use in this file:<p class="source-code">import "fmt"</p></li>
				<li>Create the main function:<p class="source-code">func main() {</p></li>
				<li>Declare an <strong class="source-inline">int8</strong> variable with an initial value of 125:<p class="source-code">  var a int8 = 125</p></li>
				<li>Declare an <strong class="source-inline">uint8</strong> variable with an initial value of 253:<p class="source-code">  var b uint8 = 253</p></li>
				<li>Create a <strong class="source-inline">for i</strong> loop that runs five times:<p class="source-code">  for i := 0; i &lt; 5; i++ {</p></li>
				<li>Increment the two variables by 1:<p class="source-code">    a++</p><p class="source-code">    b++</p></li>
				<li>Print the variables' values to the console:<p class="source-code">    fmt.Println(i, ")", "int8", a, "uint8", b)</p></li>
				<li>Close the loop:<p class="source-code">  }</p></li>
				<li>Close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p></li>
				<li>Save the file, and in the new folder run the following:<p class="source-code">go run main.go</p><p>Running the preceding code shows the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/B14177_03_04.jpg" alt="Figure 3.04: Output after wraparound&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.04: Output after wraparound</p>
			<p>In this exercise, we saw that, for signed integers, you'd end up with a negative number and for unsigned integers, it wraps around to 0. You must always consider the maximum possible number for your variable and be sure to have the appropriate type to support that number.</p>
			<p>Next, we'll look at what you can do when you need a number that's bigger than the core types can give you.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor101"/>Big Numbers</h2>
			<p>If you need a number higher or lower than <strong class="source-inline">int64</strong> or <strong class="source-inline">uint64</strong> can give, you can use the <strong class="source-inline">math/big</strong> package. This package feels a little awkward to use compared to dealing with integer types, but you'll be able to do everything you can generally do with integers using its API.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor102"/>Exercise 3.04: Big Numbers</h2>
			<p>In this exercise, we're going to create a number that's larger than what is possible with Go's core number types. To show that, we'll use an addition operation. We'll also do the same to an <strong class="source-inline">int</strong> to show the difference. Then, we'll print the result to the console:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the main package name to the top of the file:<p class="source-code">package main</p></li>
				<li>Now add the imports we'll use in this file:<p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "math"</p><p class="source-code">  "math/big"</p><p class="source-code">)</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() { </p></li>
				<li>Declare an <strong class="source-inline">int</strong> and initialize with <strong class="source-inline">math.MaxInt64</strong>, which is the highest possible value for an <strong class="source-inline">int64</strong> in Go, which is defined as a constant:<p class="source-code">  intA := math.MaxInt64</p></li>
				<li>Add 1 to the <strong class="source-inline">int</strong>:<p class="source-code">  intA = intA + 1</p></li>
				<li>Now we'll create a <strong class="source-inline">big</strong> <strong class="source-inline">int</strong>. This is a custom type and is not based on Go's <strong class="source-inline">int</strong> type. We'll also initialize it with Go's highest possible number value:<p class="source-code">  bigA := big.NewInt(math.MaxInt64)</p></li>
				<li>We'll add 1 to our <strong class="source-inline">big</strong> <strong class="source-inline">int</strong>. You can see that this feels clumsy:<p class="source-code">  bigA.Add(bigA, big.NewInt(1))</p></li>
				<li> Print out the max <strong class="source-inline">int</strong> size and the values for our Go <strong class="source-inline">int</strong> and our <strong class="source-inline">big</strong> <strong class="source-inline">int</strong>:<p class="source-code">  fmt.Println("MaxInt64: ", math.MaxInt64)</p><p class="source-code">  fmt.Println("Int   :", intA)</p><p class="source-code">  fmt.Println("Big Int : ", bigA.String())</p></li>
				<li>Close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p></li>
				<li>Save the file, and in the new folder run the following:<p class="source-code">go run main.go</p><p>Running the preceding code shows the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/B14177_03_05.jpg" alt="Figure 3.5: Output displaying large numbers with Go's number types&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5: Output displaying large numbers with Go's number types</p>
			<p>In this exercise, we saw that while <strong class="source-inline">int</strong> has wrapped around, <strong class="source-inline">big.Int</strong> has added the number correctly. </p>
			<p>If you have a situation where you have a number whose value is higher than Go can manage, then the <strong class="source-inline">big</strong> package from the standard library is what you need. Next, we'll look at a special Go number type used to represent raw data.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor103"/>Byte</h1>
			<p>The <strong class="source-inline">byte</strong> type in Go is just an alias for <strong class="source-inline">uint8</strong>, which is a number that has 8 bits of storage. In reality, <strong class="source-inline">byte</strong> is a significant type, and you'll see it in lots of places. A bit is a single binary value, a single on/off switch. Grouping bits into groups of 8 was a common standard in early computing and became a near-universal way to encode data. 8 bits have 256 possible combinations of "off" and "on," <strong class="source-inline">uint8</strong> has 256 possible integer values from 0 to 255. All combinations of on and off can are represented with this type.</p>
			<p>You'll see <strong class="source-inline">byte</strong> used when reading and writing data to and from a network connection and when reading and writing data to files.</p>
			<p>With this, we're all done with numbers. Now, let's look at how Go stores and manages text.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor104"/>Text</h1>
			<p>Go has a single type to represent some text, <strong class="source-inline">string</strong>.</p>
			<p>When you are writing some text for a <strong class="source-inline">string</strong>, it's called a string literal. There are two kinds of string literals in Go:</p>
			<ul>
				<li>Raw – defined by wrapping text in a pair of <strong class="source-inline">`</strong></li>
				<li>Interpreted – defined by surrounding the text in a pair of <strong class="source-inline">"</strong></li>
			</ul>
			<p>With raw, what ends up in your variable is precisely the text that you see on the screen. With interpreted, Go scans what you've written and then applies transformations based on its own set of rules.</p>
			<p>Here's what that looks like:</p>
			<p class="source-code">package main</p>
			<p class="source-code"> </p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code"> </p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  comment1 := `This is the BEST</p>
			<p class="source-code">thing ever!`</p>
			<p class="source-code">  comment2 := `This is the BEST\nthing ever!`</p>
			<p class="source-code">  comment3 := "This is the BEST\nthing ever!"</p>
			<p class="source-code"> </p>
			<p class="source-code">  fmt.Print(comment1, "\n\n")</p>
			<p class="source-code">  fmt.Print(comment2, "\n\n")</p>
			<p class="source-code">  fmt.Print(comment3, "\n")</p>
			<p class="source-code">}</p>
			<p>Running the preceding code gives the following output:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/B14177_03_06.jpg" alt="Figure 3.6: Output printing texts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6: Output printing texts</p>
			<p>In an interpreted string, <strong class="source-inline">\n</strong> represented a new line. In our raw string, <strong class="source-inline">\n</strong> doesn't do anything. To get a new line in the raw string, we must add an actual new line in our code. The interpreted string must use <strong class="source-inline">\n</strong> to get a new line as having a real new line in an interpreted string is not allowed.</p>
			<p>While there are a lot of things you can do with an interpreted string literal, in real-world code, the two you'll see more commonly are <strong class="source-inline">\n</strong> for a new line and occasionally <strong class="source-inline">\t</strong> for a tab.</p>
			<p>Interpreted string literals are the most common kind in real-world code, but raw literals have their place. If you wanted to copy and paste some text that contains a lot of new lines, <strong class="source-inline">"</strong> or <strong class="source-inline">\</strong>, in it, it's easier to use <strong class="bold">raw</strong>. </p>
			<p>In the following example, you can see how using raw makes the code more readable:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  comment1 := `In "Windows" the user directory is "C:\Users\"`</p>
			<p class="source-code">  comment2 := "In \"Windows\" the user directory is \"C:\\Users\\\""</p>
			<p class="source-code">  fmt.Println(comment1)</p>
			<p class="source-code">  fmt.Println(comment2)</p>
			<p class="source-code">}</p>
			<p>Running the preceding code shows the following output:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/B14177_03_07.jpg" alt="Figure 3.7: Output for more readable code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7: Output for more readable code</p>
			<p>One thing you can't have in a raw literal is a <strong class="source-inline">`</strong>. If you need a literal with a <strong class="source-inline">`</strong> in it, you must use an interpreted string literal.</p>
			<p>String literals are just ways of getting some text into a <strong class="source-inline">string</strong> type variable. Once you have the value in the variable, there are no differences.</p>
			<p>Next, we'll look at how to work safely with multi-byte strings.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor105"/>Rune</h2>
			<p>A <strong class="source-inline">rune</strong> is a type with enough storage to store a single UTF-8 multi-byte character. String literals are encoded using UTF-8. UTF-8 is a massively popular and common multi-byte text encoding standard. The <strong class="source-inline">string</strong> type itself is not limited to UTF-8 as Go needs to also support text encoding types other than UTF-8. <strong class="source-inline">string</strong> not being limited to UTF-8 means there is often an extra step you need to take when working with your strings to prevent bugs.</p>
			<p>The different encodings use a different number of bytes to encode text. Legacy standards use one byte to encode a single character. UTF-8 uses up to four bytes to encode a single character. When text is in the <strong class="source-inline">string</strong> type, to allow for this variability, Go stores all strings as a <strong class="source-inline">byte</strong> collection. To be able to safely perform operations with text of any kind of encoding, single- or multi-byte, it should be converted from a <strong class="source-inline">byte</strong> collection to a <strong class="source-inline">rune</strong> collection.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you don't know the encoding of the text, it's usually safe to convert it to UTF-8. Also, UTF-8 is backward-compatible with single-byte encoded text.</p>
			<p>Go makes it easy to access the individual bytes of a string, as shown in the following example:</p>
			<ol>
				<li value="1">First, we define the package, import our needed libraries, and create the <strong class="source-inline">main()</strong> function:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">func main() {</p></li>
				<li>We'll create a string that contains a multi-byte character:<p class="source-code">  username := "Sir_King_Über"</p></li>
				<li> We are going to use a <strong class="source-inline">for i</strong> loop to print out each byte of our string:<p class="source-code">  for i := 0; i &lt; len(username); i++ {</p><p class="source-code">    fmt.Print(username[i], " ")</p><p class="source-code">  }</p></li>
				<li>Then we will close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p></li>
			</ol>
			<p>Running the preceding code gives the following output:</p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/B14177_03_08.jpg" alt="Figure 3.8: Output displaying bytes with respect to input length&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8: Output displaying bytes with respect to input length</p>
			<p>The numbers printed out are the byte values of the string. There are only 13 letters in our string. However, it contained a multi-byte character, so we printed out 14 byte values.</p>
			<p>Let's convert our bytes back to strings. This conversion uses type conversion, which we'll cover in detail soon:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  username := "Sir_King_Über"</p>
			<p class="source-code">  for i := 0; i &lt; len(username); i++ {</p>
			<p class="source-code">    fmt.Print(string(username[i]), " ")</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Running the preceding code gives the following output:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/B14177_03_09.jpg" alt="Figure 3.9: Output displaying bytes converted as strings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9: Output displaying bytes converted as strings</p>
			<p>The output is as expected until we get to the "Ü." That's because the "Ü" was encoded using more than one byte, and each byte on its own no longer makes sense.</p>
			<p>To safely work with interindividual characters of a multi-byte string, you first must convert the strings slice of <strong class="source-inline">byte</strong> types to a slice of <strong class="source-inline">rune</strong> types.</p>
			<p>Consider the following example: </p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  username := "Sir_King_Über"</p>
			<p class="source-code">  runes := []rune(username)</p>
			<p class="source-code">  for i := 0; i &lt; len(runes); i++ {</p>
			<p class="source-code">    fmt.Print(string(runes[i]), " ")</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Running the preceding code gives the following output:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/B14177_03_10.jpg" alt="Figure 3.10: Output displaying strings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10: Output displaying strings</p>
			<p>If we do wish to work with each character in a loop like this, then using a <strong class="source-inline">range</strong> would be a better choice. When using <strong class="source-inline">range</strong>, instead of going one <strong class="source-inline">byte</strong> at a time, it moves along the string one <strong class="source-inline">rune</strong> at a time. The index is the byte offset, and the value is a <strong class="source-inline">rune</strong>.</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor106"/>Exercise 3.05: Safely Looping over a String</h2>
			<p>In this exercise, we'll declare a string and initialize it with a multi-byte string value. We'll then loop over the string using <strong class="source-inline">range</strong> to give us each character, one at a time. We'll then print out the byte index and the character to the console:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the main package name to the top of the file:<p class="source-code">package main</p></li>
				<li>Now add the imports we'll use in this file:<p class="source-code">import "fmt"</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Declare the string with a multi-byte string value:<p class="source-code">  logLevel := "デバッグ"</p></li>
				<li>Create a <strong class="source-inline">range</strong> loop that loops over the string, then capture the <strong class="source-inline">index</strong> and <strong class="source-inline">rune</strong> in variables:<p class="source-code">  for index, runeVal := range logLevel {</p></li>
				<li>Print the <strong class="source-inline">index</strong> and <strong class="source-inline">rune</strong> to the console, casting the rune to a string:<p class="source-code">    fmt.Println(index, string(runeVal))</p></li>
				<li>Close the loop:<p class="source-code">  }</p></li>
				<li>Close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p></li>
				<li>Save the file and in the new folder run the following:<p class="source-code">go run main.go</p></li>
			</ol>
			<p>Running the preceding code gives the following output:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B14177_03_11.jpg" alt="Figure 3.11: Output after safely looping over a string&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11: Output after safely looping over a string</p>
			<p>In this exercise, we demonstrated that looping over a string in a multi-byte safe way is baked right into the language. Using this method prevents you from getting invalid string data.</p>
			<p>Another common way to find bugs is to check how many characters a string has by using <strong class="source-inline">len</strong> directly on it. Here is an example of some common ways multi-byte strings can get mishandled:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  username := "Sir_King_Über"</p>
			<p class="source-code">  // Length of a string</p>
			<p class="source-code">  fmt.Println("Bytes:", len(username))</p>
			<p class="source-code">  fmt.Println("Runes:", len([]rune(username)))</p>
			<p class="source-code">  // Limit to 10 characters</p>
			<p class="source-code">  fmt.Println(string(username[:10]))</p>
			<p class="source-code">  fmt.Println(string([]rune(username)[:10]))</p>
			<p class="source-code">}</p>
			<p>Running the preceding code gives the following output:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/B14177_03_12.jpg" alt="Figure 3.12: Output displaying bugs after using the len function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12: Output displaying bugs after using the len function</p>
			<p>You can see that when using <strong class="source-inline">len</strong> directly on a string, you get the wrong answer. Checking the length of data input using <strong class="source-inline">len</strong> in this way would end up with invalid data. For example, if we needed the input to be exactly 8 characters long and somebody entered a multi-byte character, using <strong class="source-inline">len</strong> directly on that input would allow them to enter less than 8 characters.</p>
			<p>When working with strings, be sure to check the <strong class="source-inline">strings</strong> package first. It's filled with useful tools that may already do what you need.</p>
			<p>Next, let's take a close look at Go's special <strong class="source-inline">nil</strong> value.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor107"/>The nil Value</h1>
			<p><strong class="source-inline">nil</strong> is not a type but a special value in Go. It represents an empty value of no type. When working with pointers, maps, and interfaces (we'll cover these in the next chapter), you need to be sure they are not <strong class="source-inline">nil</strong>. If you try to interact with a <strong class="source-inline">nil</strong> value, your code will crash. </p>
			<p>If you can't be sure whether a value is <strong class="source-inline">nil</strong> or not, you can check it like this:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  var message *string</p>
			<p class="source-code">  if message == nil {</p>
			<p class="source-code">    fmt.Println("error, unexpected nil value")</p>
			<p class="source-code">    return</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Println(&amp;message)</p>
			<p class="source-code">}</p>
			<p>Running the preceding code shows the following output:</p>
			<p class="source-code">error, unexpected nil value</p>
			<h2 id="_idParaDest-105">Activity 3<a id="_idTextAnchor108"/>.01: Sales Tax Calculator</h2>
			<p>In this activity, we create a shopping cart application, where sales tax must be added to calculate the total: </p>
			<ol>
				<li value="1">Create a calculator that calculates the sales tax for a single item. </li>
				<li>The calculator must take the items cost and its sales tax rate. </li>
				<li>Sum the sales tax and print the total amount of sales tax required for the following items: </li>
			</ol>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B14177_03_13.jpg" alt="Figure 3.13:List of items with the sales tax rates&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13:List of items with the sales tax rates</p>
			<p>Your output should look like this:</p>
			<p class="source-code">Sales Tax Total:  0.1329</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 691.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor109"/>Activity 3.02: Loan Calculator</h2>
			<p>In this activity, we must create a loan calculator for an online financial advisor platform. Our calculator should have the following rules:</p>
			<ol>
				<li value="1">A good credit score is a score of 450 or above.</li>
				<li>For a good credit score, your interest rate is 15%.</li>
				<li>For a less than good score, your interest rate is 20%.</li>
				<li>For a good credit score, your monthly payment must be no more than 20% of your monthly income.</li>
				<li>For a less than good credit score, your monthly payment must be no more than 10% of your monthly income.</li>
				<li>If a credit score, monthly income, loan amount, or loan term is less than 0, return an error.</li>
				<li>If the term of the loan if not divisible by 12 months, return an error.</li>
				<li>The interest payment will be a simple calculation of loan amount * interest rate * loan term.</li>
				<li>After doing these calculations, display the following details to the user:<p class="source-code">Applicant X</p><p class="source-code">-----------</p><p class="source-code">Credit Score    : X</p><p class="source-code">Income          : X</p><p class="source-code">Loan Amount     : X</p><p class="source-code">Loan Term       : X</p><p class="source-code">Monthly Payment : X</p><p class="source-code">Rate            : X</p><p class="source-code">Total Cost      : X</p><p class="source-code">Approved        : X</p></li>
			</ol>
			<p>This is the expected output:</p>
			<div>
				<div id="_idContainer056" class="IMG---Figure">
					<img src="image/B14177_03_14.jpg" alt="Figure 3.14: Output of loan calculator&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14:<a id="_idTextAnchor110"/> Output of loan calculator</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 692.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor111"/>Summary</h1>
			<p>In this chapter, we took a big step in working with Go's type system. We took the time to define what types are and why they are needed. We then explored each of the core types in Go. We started with the simple <strong class="source-inline">bool</strong> type, and we were able to show how critical it is to everything we do in our code. We then moved on to the number types. Go has lots of types for numbers, reflecting the control that Go likes to give developers when it comes to memory usage and accuracy. After numbers, we looked at how strings work and how they are closely related to the rune type. With the advent of multi-byte characters, it's easy to make a mess of your text data. Go has provided power built-in features to help you get it right. Lastly, we looked at <strong class="source-inline">nil</strong> and how you use it within Go.</p>
			<p>The concepts you've learned in this chapter have armed you with the knowledge needed to tackle Go's more complex types, such as collections and structs. We'll be looking at these complex types in the next chapter.</p>
		</div>
		<div>
			<div id="_idContainer058" class="Content">
			</div>
		</div>
	</body></html>