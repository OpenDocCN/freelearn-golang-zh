- en: 3\. Core Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 核心类型
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter aims to show you how to use Go's basic core types to design your
    software's data. We'll work through each type to show what they are useful for
    and how to use them in your software. Understanding these core types provides
    you with the foundation required to learn how to create complex data designs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在向你展示如何使用 Go 的基本核心类型来设计你的软件数据。我们将逐一研究每种类型，以展示它们有什么用以及如何在你的软件中使用它们。理解这些核心类型为你提供了学习如何创建复杂数据设计所需的基础。
- en: By the end of this chapter, you will be able to create variables of different
    types for Go programs and assign values to variables of different types. You will
    learn to identify and pick a suitable type for any programming situation. You
    will also write a program to measure password complexity and implement empty value
    types.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够为 Go 程序创建不同类型的变量，并将值分配给不同类型的变量。你将学会识别并选择任何编程情况下的合适类型。你还将编写一个程序来测量密码复杂度并实现空值类型。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we learned how to use `if`, `if`-`else`, `switch`,
    `continue`, and `break` in Go.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何在 Go 中使用 `if`、`if-else`、`switch`、`continue` 和 `break`。
- en: Go is a strongly typed language, and all data is assigned a type. That type
    is fixed and can't be changed. What you can and can't do with your data is constrained
    by the types you assign. Understanding exactly what defines every one of Go's
    core types is critical to success with the Go language.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是一种强类型语言，所有数据都被分配了一个类型。这个类型是固定的，不能更改。你可以和不能对你的数据做的事情受到你分配的类型所限制。准确理解定义 Go
    每个核心类型的因素对于成功使用 Go 语言至关重要。
- en: In later chapters, we'll talk about Go's more complex types, but those types
    are built on the core types defined in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将讨论 Go 的更复杂类型，但这些类型是基于本章定义的核心类型构建的。
- en: Go's core types are well-thought-out and easy to understand once you understand
    the details. Having to understand the details means Go's type system is not always
    intuitive. For example, Go's most common number type, `int`, may be either 32
    bits or 64 bits in size depending on the computer used to compile the code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的核心类型经过深思熟虑，一旦你了解了细节，它们就很容易理解。需要理解细节意味着 Go 的类型系统并不总是直观的。例如，Go 最常见的数字类型 `int`
    的大小可能是 32 位或 64 位，这取决于编译代码所使用的计算机。
- en: Types are needed to make data easier for humans to work with. Computers only
    think about data in binary. Binary is hard for people to work with. By adding
    a layer of abstraction to binary data and labeling it as a number or some text,
    humans have an easier time reasoning about it. Reducing the cognitive load allows
    people to build more complex software because they're not overwhelmed by managing
    the details of the binary data.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是使数据对人类更容易处理所必需的。计算机只考虑二进制数据。二进制对人类来说很难处理。通过在二进制数据上添加一层抽象并将其标记为数字或某些文本，人类更容易对其进行分析。减少认知负担使得人们能够构建更复杂的软件，因为他们不会被管理二进制数据细节所淹没。
- en: Programming languages need to define what a number is or what a text is for.
    A programming language defines what you can call a number, and it defines what
    operations you can use on a number. For example, can a whole number such as 10
    and a floating-point number such as 3.14 both be stored as the same type? While
    it seems obvious that you can multiply numbers, can you multiply text? As we progress
    through this chapter, we'll clearly define what the rules are for each type and
    what operations you can use with each of them.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言需要定义数字或文本是什么。编程语言定义了你可以称为数字的内容，并定义了你可以在数字上使用的操作。例如，整数 10 和浮点数 3.14 是否都可以存储为同一类型？虽然显然你可以乘以数字，但你能否乘以文本？随着我们进入本章，我们将明确定义每种类型的规则以及你可以与它们一起使用的操作。
- en: The way data is stored is also a large part of what defines a `type`. To allow
    for the building of efficient software, Go places limits on how large some of
    its types can be. For example, the largest amount of storage for a number in Go's
    core types is 64 bits of memory. This allows for any number up to 18,446,744,073,709,551,615\.
    Understanding these type limitations is critical in building bug-free code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的存储方式也是定义 `type` 的重要组成部分。为了允许构建高效的软件，Go 对其某些类型的大小施加了限制。例如，Go 核心类型中数字的最大存储量是
    64 位内存。这允许存储任何高达 18,446,744,073,709,551,615 的数字。理解这些类型限制对于构建无错误的代码至关重要。
- en: 'The things that define a type are:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类型的因素包括：
- en: The kind of data that you can store in it
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在其中存储的数据类型
- en: What operations you can use with it
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用哪些操作
- en: What those operations do to it
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些操作对其有何影响
- en: How much memory it can use
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它能使用多少内存
- en: This chapter gives you the knowledge and confidence to use Go's types system
    correctly in your code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为你提供使用Go类型系统正确编写代码的知识和信心。
- en: True and False
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 真和假
- en: True and false logic is represented using the Boolean type, `bool`. Use this
    type when you need an on/off switch in your code. The value of a `bool` can only
    ever be `true` or `false`. The zero value of a `bool` is `false`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布尔类型`bool`表示真和假逻辑。当你在代码中需要一个开/关切换时使用此类型。`bool`的值只能是`true`或`false`。`bool`的零值是`false`。
- en: When using a comparison operator such as `==` or `>`, the result of that comparison
    is a `bool` value.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用比较运算符如`==`或`>`时，该比较的结果是一个`bool`值。
- en: 'In this code example, we use comparison operators on two numbers. You''ll see
    that the result is a `bool`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码示例中，我们在两个数字上使用比较运算符。你会看到结果是`bool`：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running the preceding code shows the following output:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将显示以下输出：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Exercise 3.01: Program to Measure Password Complexity'
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.01：测量密码复杂性的程序
- en: 'An online portal creates user accounts for its users and accepts passwords
    that are only 8-15 characters long. In this exercise, we write a program for the
    portal to display whether the password entered meets the character requirements.
    The character requirements are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在此练习中，我们将编写一个程序，用于创建用户账户并接受长度为8-15个字符的密码。该门户的密码要求如下：
- en: Have a lowercase letter
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个小写字母
- en: Have an uppercase letter
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个大写字母
- en: Have a number
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个数字
- en: Have a symbol
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含一个符号
- en: Be 8 or more characters long
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少8个字符长
- en: 'To do this exercise, we''re going to use a few new features. Don''t worry if
    you don''t quite understand what they are doing; we''ll cover them in detail in
    the next chapter. Consider this a sneak peek. We''ll explain what everything is
    as we go, but your main focus should be on the Boolean logic:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成此练习，我们将使用一些新功能。如果你不完全理解它们的作用，不要担心；我们将在下一章中详细讲解。这只是一个预览。我们将随着解释逐步解释每一件事，但你的主要焦点应该是布尔逻辑：
- en: Create a new folder and add a `main.go` file.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个`main.go`文件。
- en: 'In `main.go`, add the main package name to the top of the file:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中，将主包名添加到文件顶部：
- en: '[PRE2]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now add the imports we''ll use in this file:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加我们将在此文件中使用的导入：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a function that takes a string argument and returns a `bool`:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个接受字符串参数并返回`bool`的函数：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Convert the password string into `rune`, which is a type that is safe for multi-byte
    (UTF-8) characters:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将密码字符串转换为`rune`，这是一个适用于多字节（UTF-8）字符的安全类型：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We'll talk more about rune later in this chapter.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在本章后面更详细地讨论`rune`。
- en: 'Count the number of multi-byte characters using `len`. This code results in
    a `bool` result that can be used in the `if` statement:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`len`计算多字节字符的数量。此代码产生一个可用于`if`语句的`bool`结果：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Define some `bool` variables. We''ll check these at the end:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一些`bool`变量。我们将在最后检查这些变量：
- en: '[PRE7]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Loop over the multi-byte characters one at a time:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐个遍历多字节字符：
- en: '[PRE8]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using the `unicode` package, check whether this character is uppercase. This
    function returns a `bool` that we can use directly in the `if` statement:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`unicode`包检查该字符是否为大写。此函数返回一个`bool`，我们可以在`if`语句中直接使用：
- en: '[PRE9]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If it is, we''ll set the `hasUpper` `bool` variable to `true`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是，我们将设置`hasUpper` `bool`变量为`true`：
- en: '[PRE10]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Do the same thing for lowercase letters:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于小写字母也做同样的事情：
- en: '[PRE11]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Also do it for numbers:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样也应用于数字：
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For symbols, we''ll also accept punctuation. Use the `or` operator, which works
    with `Booleans`, to result in `true` if either of these functions returns `true`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于符号，我们还将接受标点符号。使用`or`运算符，它与`Booleans`一起工作，如果这些函数中的任何一个返回`true`，则结果为`true`：
- en: '[PRE13]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To pass all our checks, all our variables must be `true`. Here, we combine
    multiple `and` operators to create a one-line statement that checks all four variables:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了通过所有检查，所有变量都必须是`true`。在这里，我们使用多个`and`运算符创建一个检查所有四个变量的单行语句：
- en: '[PRE14]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Close the function:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭函数：
- en: '[PRE15]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create the `main()` function:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE16]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Call the `passwordChecker()` function with an invalid password. As this returns
    a `bool`, it can be used directly in an `if` statement:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用无效密码调用`passwordChecker()`函数。由于它返回一个`bool`，可以直接在`if`语句中使用：
- en: '[PRE17]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, call the function with a valid password:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用有效密码调用该函数：
- en: '[PRE18]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Close the `main()` function:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main()`函数：
- en: '[PRE19]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Save the file and in the new folder and then run the following:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在新文件夹中运行以下命令：
- en: '[PRE20]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Running the preceding code shows the following output:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码会显示以下输出：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this exercise, we highlighted a variety of ways that `bool` values manifest
    themselves in the code. `Bool` values are critical to giving your code the ability
    to make a choice and be dynamic and responsive. Without `bool`, your code would
    have a hard time doing anything.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们强调了`bool`值在代码中表现出的各种方式。`Bool`值对于赋予你的代码选择能力和动态响应能力至关重要。没有`bool`，你的代码将很难做任何事情。
- en: Next, we'll take a look at numbers and how Go categorizes them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看数字以及Go如何对它们进行分类。
- en: Numbers
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: 'Go has two distinct number types: integers, also known as whole numbers, and
    floating-point numbers. A floating-point number allows a number with whole numbers
    and fractions of a whole number.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Go有两种不同的数字类型：整数，也称为整数，和浮点数。浮点数允许一个数既有整数部分也有分数部分。
- en: 1, 54, and 5,436 are examples of whole numbers. 1.5, 52.25, 33.333, and 64,567.00001
    are all examples of floating-point numbers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 1、54和5,436是整数示例。1.5、52.25、33.333和64,567.00001都是浮点数示例。
- en: Note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: The default and empty values for all number types is 0.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数字类型的默认值和空值都是0。
- en: Next, we'll start our number journey by looking at integers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从查看整数开始我们的数字之旅。
- en: Integer
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数
- en: 'Integer types are classified in two ways, based on the following conditions:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 整数类型根据以下条件分为两种：
- en: Whether or not they can store negative numbers
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否可以存储负数
- en: The smallest and largest numbers they can store
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们能存储的最小和最大数字
- en: Types that can store negative numbers are called signed integers. Types that
    can't store negative numbers are called unsigned integers. How big and small a
    number each type can store is expressed by how many bytes of internal storage
    they have.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可以存储负数的类型称为有符号整数。不能存储负数的类型称为无符号整数。每种类型可以存储的数字大小通过它们内部存储的字节数来表示。
- en: 'Here is an excerpt from the Go language specification with all the relevant
    integer types:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是Go语言规范中所有相关整数类型的一段摘录：
- en: '![Figure 3.01: Go language specification with relevant integer types'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.01：Go 语言规范及相关整数类型'
- en: '](img/B14177_03_01.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_03_01.jpg)'
- en: 'Figure 3.01: Go language specification with relevant integer types'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.01：Go 语言规范及相关整数类型
- en: 'There are also special integer types as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些特殊的整数类型：
- en: '![Figure 3.02: Special integer types'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.02：特殊整数类型'
- en: '](img/B14177_03_02.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_03_02.jpg)'
- en: 'Figure 3.02: Special integer types'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.02：特殊整数类型
- en: '`uint` and `int` are either 32 or 64 bits depending on whether you compile
    your code for a 32-bit system or a 64-bit system. It''s rare nowadays to run applications
    on a 32-bit system, systems so most of the time they are 64 bits.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`uint`和`int`的位数取决于你是否为32位系统或64位系统编译代码。现在在32位系统上运行应用程序的情况很少见，因此大多数时候它们是64位的。'
- en: An `int` on a 64-bit system is not an `int64`. While these two types are identical,
    they are not the same integer type, and you can't use them together. If Go did
    allow this, there would be problems when the same code gets compiled for a 32-bit
    machine, so keeping them separate ensures that the code is reliable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在64位系统上的`int`不是`int64`。虽然这两种类型是相同的，但它们不是同一整数类型，你不能将它们一起使用。如果Go允许这样做，当相同的代码在32位机器上编译时会出现问题，因此将它们分开可以确保代码的可靠性。
- en: This incompatibility is not just an `int` thing; you can't use any of the integer
    types together.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不兼容性不仅仅是`int`的问题；你不能将任何整数类型一起使用。
- en: 'Picking the correct integer type to use when defining a variable is easy: use
    `int`. When writing code for an application, `int` does the job the majority of
    the time. Only think about using the other types when an `int` is causing a problem.
    The sorts of problems you see with `int` tend to be related to memory usage.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义变量时选择正确的整数类型很容易：使用`int`。在编写应用程序代码时，`int`大多数时候都能完成任务。只有当`int`导致问题时才考虑使用其他类型。你看到的与`int`相关的问题通常与内存使用有关。
- en: For example, let's say you have an app that's running out of memory. The app
    uses a massive number of integers, but these integers are never negative and won't
    go over 255\. One possible fix is to switch from using `int` to using `uint8`.
    Doing this cuts its memory usage from 64 bits (8 bytes) per number to 8 bits (1
    byte) per number.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个内存即将耗尽的程序。该程序使用大量的整数，但这些整数永远不会是负数，并且不会超过255。一个可能的解决方案是将`int`的使用切换到`uint8`。这样做可以将每个数字的内存使用从64位（8字节）减少到8位（1字节）。
- en: 'We can show this by creating a collection of both kinds of type then asking
    Go how much heap memory it is using. The output may vary on your computer, but
    the effect should be similar. This code creates a collection of `int` or `int8`.
    It then adds 10 million values to the collection. Once that''s done, it uses the
    runtime package to give us a reading of how much heap memory is being used. We
    convert that reading to MB and then print it out:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建这两种类型的集合然后询问 Go 语言它正在使用多少堆内存来展示这一点。输出可能会因您的计算机而异，但效果应该是相似的。此代码创建了一个
    `int` 或 `int8` 类型的集合。然后它向集合中添加了 1000 万个值。一旦完成，它使用运行时包来给我们一个正在使用的堆内存的读数。我们将该读数转换为
    MB 并打印出来：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here''s the output using `int`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `int` 的输出：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And here''s the output using `int8`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `int8` 的输出：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We saved a good amount of memory here, but we need 10 million variables to make
    it worthwhile. Hopefully, now you are convinced that it's okay to start with `int`
    and only worry about performance when it's a problem, not before.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里节省了相当多的内存，但我们需要 1000 万个变量才能使其变得值得。希望现在您已经相信，从 `int` 类型开始是完全可以的，只有在有问题时才关注性能，而不是在之前。
- en: Next, we'll look at floating-point numbers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看浮点数。
- en: Floating Point
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数
- en: Go has two floating-point number types, `float32` and `float64`. The bigger
    `float64` allows for more precision in the numbers. `float32` has 32 bits of storage
    and `float64` has 64 bits of storage. Floats split their storage between whole
    numbers (everything to the left of the decimal point) and decimal numbers (everything
    to the right of the decimal point). How much space is used for the whole number
    or the decimal numbers, varies by the number being stored. For example, 9,999.9
    would use more storage for the whole numbers while 9.9999 would use more storage
    for the decimal numbers. With `float64`'s bigger space for storage, it can store
    more whole numbers and/or more decimal numbers than `float32` can.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言有两种浮点数类型，`float32` 和 `float64`。较大的 `float64` 类型允许在数字上提供更高的精度。`float32`
    类型有 32 位存储空间，而 `float64` 类型有 64 位存储空间。浮点数将它们的存储空间分配给整数部分（小数点左侧的所有内容）和小数部分（小数点右侧的所有内容）。用于整数部分或小数部分的存储空间量因存储的数字而异。例如，9,999.9
    会为整数部分使用更多的存储空间，而 9.9999 会为小数部分使用更多的存储空间。由于 `float64` 类型有更大的存储空间，它可以存储比 `float32`
    类型更多的整数和/或小数。
- en: 'Exercise 3.02: Floating-Point Number Accuracy'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3.02：浮点数精度
- en: In this exercise, we're going to compare what happens when we do some divisions
    on numbers that don't divide equally. We'll be dividing 100 by 3\. One way of
    representing the result is 33 ⅓. Computers, for the most part, can't compute fractions
    like this. Instead, they use a decimal representation, which is 33.3 recurring,
    where the 3 after the decimal point repeats forever. If we let the computer do
    that it uses up all the memory, which is not very helpful.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将比较当我们对不能整除的数字进行除法运算时会发生什么。我们将用 100 除以 3。表示结果的一种方式是 33 ⅓。大多数计算机无法计算这样的分数。相反，它们使用十进制表示法，即
    33.3 重复，小数点后的 3 永远重复。如果我们让计算机这样做，它会耗尽所有内存，这并不很有帮助。
- en: 'Luckily for us, we don''t need to worry about this happening as the floating-point
    types have storage limits. The downside is that this leads to a number that doesn''t
    reflect the true result; the result has a certain amount of inaccuracy. Your tolerance
    for inaccuracy needs and how much storage space you want to give to your floating-point
    numbers must be balanced out:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要担心这种情况发生，因为浮点数类型有存储限制。缺点是这会导致一个不反映真实结果的数字；结果有一定的误差。您对误差的容忍度和您想要为浮点数提供的存储空间量必须得到平衡：
- en: Create a new folder and add a `main.go` file.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个 `main.go` 文件。
- en: 'In `main.go`, add the main package name to the top of the file:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 文件中，将主包名添加到文件顶部：
- en: '[PRE25]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now add the imports we''ll use in this file:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加我们将在此文件中使用的导入：
- en: '[PRE26]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create the `main()` function:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main()` 函数：
- en: '[PRE27]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Declare an `int` and initialize it with a value of 100:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `int` 类型并初始化它为 100：
- en: '[PRE28]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Declare a `float32` and initialize it with a value of 100:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `float32` 类型并初始化它为 100：
- en: '[PRE29]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Declare a `float64` and initialize it with a value of 100:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个 `float64` 类型并初始化它为 100：
- en: '[PRE30]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Divide each variable by 3 and print the result to the console:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个变量除以 3 并将结果打印到控制台：
- en: '[PRE31]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Save the file and in the new folder run the following:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在新文件夹中运行以下命令：
- en: '[PRE32]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Running the preceding code shows the following output displaying `int`, `float32`,
    and `float64` values:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码会显示以下输出，显示 `int`、`float32` 和 `float64` 的值：
- en: '[PRE33]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this exercise, we can see that the computer is not able to give perfect answers
    to this sort of division. You can also see that when doing this sort of math on
    integers, you don't get an error. Go ignores any fractional part of the number,
    which is usually not what you want. We can also see that the `float64` gives a
    much more accurate answer than `float32`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们可以看到计算机不能给出这种类型除法的完美答案。你还可以看到，在进行这种整数数学运算时，你不会得到错误。Go会忽略数字的任何分数部分，这通常不是你想要的。我们还可以看到`float64`比`float32`给出了更精确的答案。
- en: While this limit seems like it would lead to problems with inaccuracy, for real-world
    business work, it does get the job done well enough the vast majority of the time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个限制看起来可能会导致精度问题，但在现实世界的商业工作中，它大多数时候都能很好地完成任务。
- en: 'Let''s see what happens if we try to get our number back to 100 by multiplying
    it by 3:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们尝试通过乘以3将数字恢复到100会发生什么：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Running the preceding code shows the following output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会显示以下输出：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this example, we saw that the accuracy is not as impacted as much as you'd
    expect. At first glance, floating-point math can seem simple, but it gets complicated
    quickly. When defining your floating-point variables, typically `float64` should
    be your first choice unless you need to be more memory efficient.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到精度的影响并没有像你预期的那样大。乍一看，浮点数学可能看起来很简单，但它很快就会变得复杂。当定义你的浮点变量时，通常`float64`应该是你的首选，除非你需要更高效的内存使用。
- en: Next, we'll look at what happens when you go beyond the limits of a number type.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看当你超出数字类型的限制时会发生什么。
- en: Overflow and Wraparound
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 溢出和环绕
- en: 'When you try to initialize a number with a value that''s too big for the type
    we are using, you get an overflow error. The highest number you can have in an
    `int8` is 127\. In the following code, we''ll try to initialize it with 128 and
    see what happens:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试用一个超出我们使用的类型值的数字初始化时，你会得到一个溢出错误。`int8`中可以有的最大数字是127。在下面的代码中，我们将尝试用128初始化它并看看会发生什么：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Running the preceding code gives the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会得到以下输出：
- en: '![Figure 3.03: Output after initializing with 128'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.03：初始化为128后的输出'
- en: '](img/B14177_03_03.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_03_03.jpg)'
- en: 'Figure 3.03: Output after initializing with 128'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.03：初始化为128后的输出
- en: This error is easy to fix and can't cause any hidden problems. The real problem
    is when the compiler can't catch it. When this happens, the number will ".wraparound".
    Wraparound means the number goes from its highest possible value to its smallest
    possible value. Wraparound can be easy to miss when developing your code and can
    cause significant problems to your users.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误很容易修复，不会引起任何隐藏的问题。真正的问题是当编译器无法捕获它时。当这种情况发生时，数字将".环绕"。环绕意味着数字从它的可能最大值变为可能的最小值。在开发你的代码时，环绕可能很容易被忽略，并可能对你的用户造成重大问题。
- en: 'Exercise 3.03: Triggering Number Wraparound'
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.03：触发数字环绕
- en: 'In this exercise, we''ll declare two small integer types: `int8` and `uint8`.
    We''ll initialize them near their highest possible value. Then we''ll use a loop
    statement to increment them by 1 per loop then print their value to the console.
    We''ll be able to see exactly when they wraparound.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将声明两个小的整数类型：`int8`和`uint8`。我们将它们初始化在它们可能的最大值附近。然后我们将使用循环语句每次循环增加1，然后将它们的值打印到控制台。我们将能够看到它们何时环绕。
- en: Create a new folder and add a `main.go` file.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个`main.go`文件。
- en: 'In `main.go` add the main package name to the top of the file:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`文件顶部添加主包名：
- en: '[PRE37]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now add the imports we''ll use in this file:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加我们将在这个文件中使用的导入：
- en: '[PRE38]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Create the main function:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建主函数：
- en: '[PRE39]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Declare an `int8` variable with an initial value of 125:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个初始值为125的`int8`变量：
- en: '[PRE40]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Declare an `uint8` variable with an initial value of 253:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个初始值为253的`uint8`变量：
- en: '[PRE41]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a `for i` loop that runs five times:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个运行五次的`for i`循环：
- en: '[PRE42]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Increment the two variables by 1:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个变量增加1：
- en: '[PRE43]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Print the variables'' values to the console:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将变量的值打印到控制台：
- en: '[PRE44]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Close the loop:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭循环：
- en: '[PRE45]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Close the `main()` function:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main()`函数：
- en: '[PRE46]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Save the file, and in the new folder run the following:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并在新文件夹中运行以下命令：
- en: '[PRE47]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Running the preceding code shows the following output:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码会显示以下输出：
- en: '![Figure 3.04: Output after wraparound'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.04：环绕后的输出'
- en: '](img/B14177_03_04.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_03_04.jpg)'
- en: 'Figure 3.04: Output after wraparound'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.04：环绕后的输出
- en: In this exercise, we saw that, for signed integers, you'd end up with a negative
    number and for unsigned integers, it wraps around to 0\. You must always consider
    the maximum possible number for your variable and be sure to have the appropriate
    type to support that number.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到，对于有符号整数，你最终会得到一个负数，而对于无符号整数，它会回绕到0。你必须始终考虑变量的最大可能数值，并确保有适当的数据类型来支持该数值。
- en: Next, we'll look at what you can do when you need a number that's bigger than
    the core types can give you.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看当你需要一个比核心类型能提供的数值更大的数值时，你可以做什么。
- en: Big Numbers
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大数
- en: If you need a number higher or lower than `int64` or `uint64` can give, you
    can use the `math/big` package. This package feels a little awkward to use compared
    to dealing with integer types, but you'll be able to do everything you can generally
    do with integers using its API.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要一个比`int64`或`uint64`能提供的数值更高或更低的数值，你可以使用`math/big`包。与处理整数类型相比，这个包使用起来可能有些别扭，但你可以使用它的API完成所有通常可以用整数完成的事情。
- en: 'Exercise 3.04: Big Numbers'
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.04：大数
- en: 'In this exercise, we''re going to create a number that''s larger than what
    is possible with Go''s core number types. To show that, we''ll use an addition
    operation. We''ll also do the same to an `int` to show the difference. Then, we''ll
    print the result to the console:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个比Go语言核心数字类型所能提供的更大的数值。为了展示这一点，我们将使用加法操作。我们还将对`int`做同样的操作以展示差异。然后，我们将打印结果到控制台：
- en: Create a new folder and add a `main.go` file.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个`main.go`文件。
- en: 'In `main.go`, add the main package name to the top of the file:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`文件中，将主包名添加到文件顶部：
- en: '[PRE48]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now add the imports we''ll use in this file:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加我们将在这个文件中使用的导入：
- en: '[PRE49]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create the `main()` function:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE50]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Declare an `int` and initialize with `math.MaxInt64`, which is the highest
    possible value for an `int64` in Go, which is defined as a constant:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`int`类型变量并将其初始化为`math.MaxInt64`，这是Go语言中`int64`类型可能的最大值，它被定义为常量：
- en: '[PRE51]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add 1 to the `int`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将1加到`int`上：
- en: '[PRE52]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now we''ll create a `big` `int`. This is a custom type and is not based on
    Go''s `int` type. We''ll also initialize it with Go''s highest possible number
    value:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个`big`类型的`int`。这是一个自定义类型，它不是基于Go语言的`int`类型。我们还将使用Go语言的最大数值来初始化它：
- en: '[PRE53]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We''ll add 1 to our `big` `int`. You can see that this feels clumsy:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将给我们的`big`类型的`int`加1。你可以看到这感觉有些笨拙：
- en: '[PRE54]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Print out the max `int` size and the values for our Go `int` and our `big`
    `int`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出最大`int`大小以及我们的Go `int`和`big` `int`的值：
- en: '[PRE55]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Close the `main()` function:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭`main()`函数：
- en: '[PRE56]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Save the file, and in the new folder run the following:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并在新文件夹中运行以下命令：
- en: '[PRE57]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Running the preceding code shows the following output:'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码将显示以下输出：
- en: '![Figure 3.5: Output displaying large numbers with Go''s number types'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.5：使用Go的数字类型显示大数的输出'
- en: '](img/B14177_03_05.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_03_05.jpg)'
- en: 'Figure 3.5: Output displaying large numbers with Go''s number types'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：使用Go的数字类型显示大数的输出
- en: In this exercise, we saw that while `int` has wrapped around, `big.Int` has
    added the number correctly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到`int`已经溢出，而`big.Int`正确地添加了数值。
- en: If you have a situation where you have a number whose value is higher than Go
    can manage, then the `big` package from the standard library is what you need.
    Next, we'll look at a special Go number type used to represent raw data.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个数值高于Go能够处理的数值的情况，那么你需要使用标准库中的`big`包。接下来，我们将查看一个用于表示原始数据的特殊Go语言数字类型。
- en: Byte
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字节
- en: The `byte` type in Go is just an alias for `uint8`, which is a number that has
    8 bits of storage. In reality, `byte` is a significant type, and you'll see it
    in lots of places. A bit is a single binary value, a single on/off switch. Grouping
    bits into groups of 8 was a common standard in early computing and became a near-universal
    way to encode data. 8 bits have 256 possible combinations of "off" and "on," `uint8`
    has 256 possible integer values from 0 to 255\. All combinations of on and off
    can are represented with this type.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的`byte`类型只是`uint8`的别名，它是一个有8位存储空间的数值。实际上，`byte`是一个重要的类型，你会在很多地方看到它。位是一个单一的二进制值，一个单一的开关。将位分组为8位是早期计算中的常见标准，并成为几乎通用的数据编码方式。8位有256种“关闭”和“开启”的组合，`uint8`有从0到255的256个可能的整数值。所有开启和关闭的组合都可以用这种类型表示。
- en: You'll see `byte` used when reading and writing data to and from a network connection
    and when reading and writing data to files.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在读取和写入网络连接以及读取和写入文件时看到`byte`的使用。
- en: With this, we're all done with numbers. Now, let's look at how Go stores and
    manages text.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，我们关于数字的部分就结束了。现在，让我们看看 Go 如何存储和管理文本。
- en: Text
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文本
- en: Go has a single type to represent some text, `string`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Go 有一个单一的类型来表示一些文本，即 `string`。
- en: 'When you are writing some text for a `string`, it''s called a string literal.
    There are two kinds of string literals in Go:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为 `string` 写一些文本时，它被称为字符串字面量。在 Go 中有两种字符串字面量：
- en: Raw – defined by wrapping text in a pair of `` ` ``
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始 – 通过将文本包裹在一对 `` ` ``
- en: Interpreted – defined by surrounding the text in a pair of `"`
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释过的 – 通过将文本包裹在一对 `"`
- en: With raw, what ends up in your variable is precisely the text that you see on
    the screen. With interpreted, Go scans what you've written and then applies transformations
    based on its own set of rules.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原始字符串，最终出现在你的变量中的正是你在屏幕上看到的文本。使用解释过的字符串，Go 会扫描你所写的文本，然后根据它自己的规则集应用转换。
- en: 'Here''s what that looks like:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来是这样的：
- en: '[PRE58]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Running the preceding code gives the following output:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会得到以下输出：
- en: '![Figure 3.6: Output printing texts'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.6：输出打印文本'
- en: '](img/B14177_03_06.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_03_06.jpg)'
- en: 'Figure 3.6: Output printing texts'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：输出打印文本
- en: In an interpreted string, `\n` represented a new line. In our raw string, `\n`
    doesn't do anything. To get a new line in the raw string, we must add an actual
    new line in our code. The interpreted string must use `\n` to get a new line as
    having a real new line in an interpreted string is not allowed.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释过的字符串中，`\n` 表示换行。在我们的原始字符串中，`\n` 不会做任何事情。要在原始字符串中获得换行，我们必须在我们的代码中添加一个实际的新行。解释过的字符串必须使用
    `\n` 来获得换行，因为在解释过的字符串中不允许有实际的换行。
- en: While there are a lot of things you can do with an interpreted string literal,
    in real-world code, the two you'll see more commonly are `\n` for a new line and
    occasionally `\t` for a tab.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以用解释过的字符串字面量做很多事情，但在实际代码中，你更常见的是 `\n` 用于换行，偶尔 `\t` 用于制表符。
- en: Interpreted string literals are the most common kind in real-world code, but
    raw literals have their place. If you wanted to copy and paste some text that
    contains a lot of new lines, `"` or `\`, in it, it's easier to use **raw**.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 解释过的字符串字面量在现实世界的代码中是最常见的，但原始字面量也有其位置。如果你需要复制和粘贴包含大量换行符、`"` 或 `\` 的文本，使用 **原始**
    更容易。
- en: 'In the following example, you can see how using raw makes the code more readable:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，你可以看到使用原始字符串如何使代码更易读：
- en: '[PRE59]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Running the preceding code shows the following output:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会显示以下输出：
- en: '![Figure 3.7: Output for more readable code'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 3.7：更易读的代码输出'
- en: '](img/B14177_03_07.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_03_07.jpg)'
- en: 'Figure 3.7: Output for more readable code'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：更易读的代码输出
- en: One thing you can't have in a raw literal is a `` ` ``. If you need a literal
    with a `` ` `` in it, you must use an interpreted string literal.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在原始字面量中你不能有 `` ` ``。如果你需要一个包含 `` ` `` 的字面量，你必须使用解释过的字符串字面量。
- en: String literals are just ways of getting some text into a `string` type variable.
    Once you have the value in the variable, there are no differences.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串字面量只是将一些文本放入 `string` 类型变量的方式。一旦你有了变量的值，就没有区别了。
- en: Next, we'll look at how to work safely with multi-byte strings.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何安全地处理多字节字符串。
- en: Rune
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rune
- en: A `rune` is a type with enough storage to store a single UTF-8 multi-byte character.
    String literals are encoded using UTF-8\. UTF-8 is a massively popular and common
    multi-byte text encoding standard. The `string` type itself is not limited to
    UTF-8 as Go needs to also support text encoding types other than UTF-8\. `string`
    not being limited to UTF-8 means there is often an extra step you need to take
    when working with your strings to prevent bugs.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`rune` 是一种类型，它有足够的存储空间来存储单个 UTF-8 多字节字符。字符串字面量使用 UTF-8 编码。UTF-8 是一种非常流行和常见的多字节文本编码标准。`string`
    类型本身并不限于 UTF-8，因为 Go 需要支持除了 UTF-8 以外的其他文本编码类型。`string` 不限于 UTF-8 意味着在处理字符串时，你通常需要额外的一步来防止错误。'
- en: The different encodings use a different number of bytes to encode text. Legacy
    standards use one byte to encode a single character. UTF-8 uses up to four bytes
    to encode a single character. When text is in the `string` type, to allow for
    this variability, Go stores all strings as a `byte` collection. To be able to
    safely perform operations with text of any kind of encoding, single- or multi-byte,
    it should be converted from a `byte` collection to a `rune` collection.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的编码使用不同数量的字节来编码文本。旧标准使用一个字节来编码一个字符。UTF-8最多使用四个字节来编码一个字符。当文本在`string`类型中时，为了允许这种可变性，Go将所有字符串存储为`byte`集合。为了能够安全地对任何类型的文本执行操作，无论是单字节还是多字节编码，它应该从`byte`集合转换为`rune`集合。
- en: Note
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you don't know the encoding of the text, it's usually safe to convert it
    to UTF-8\. Also, UTF-8 is backward-compatible with single-byte encoded text.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道文本的编码，通常将其转换为UTF-8是安全的。此外，UTF-8与单字节编码的文本向后兼容。
- en: 'Go makes it easy to access the individual bytes of a string, as shown in the
    following example:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Go使得访问字符串的各个字节变得容易，如下面的示例所示：
- en: 'First, we define the package, import our needed libraries, and create the `main()`
    function:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义包，导入所需的库，并创建`main()`函数：
- en: '[PRE60]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We''ll create a string that contains a multi-byte character:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个包含多字节字符的字符串：
- en: '[PRE61]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We are going to use a `for i` loop to print out each byte of our string:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个`for i`循环来打印字符串中的每个字节：
- en: '[PRE62]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then we will close the `main()` function:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将关闭`main()`函数：
- en: '[PRE63]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Running the preceding code gives the following output:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会得到以下输出：
- en: '![Figure 3.8: Output displaying bytes with respect to input length'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8：根据输入长度显示字节的输出]'
- en: '](img/B14177_03_08.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_03_08.jpg]'
- en: 'Figure 3.8: Output displaying bytes with respect to input length'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.8：根据输入长度显示字节的输出]'
- en: The numbers printed out are the byte values of the string. There are only 13
    letters in our string. However, it contained a multi-byte character, so we printed
    out 14 byte values.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 打印出的数字是字符串的字节值。我们的字符串中只有13个字母。然而，它包含一个多字节字符，所以我们打印出了14个字节值。
- en: 'Let''s convert our bytes back to strings. This conversion uses type conversion,
    which we''ll cover in detail soon:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将字节转换回字符串。这种转换使用类型转换，我们将在后面详细讲解：
- en: '[PRE64]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Running the preceding code gives the following output:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会得到以下输出：
- en: '![Figure 3.9: Output displaying bytes converted as strings'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9：根据字符串显示转换后的字节]'
- en: '](img/B14177_03_09.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_03_09.jpg]'
- en: 'Figure 3.9: Output displaying bytes converted as strings'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.9：根据字符串显示转换后的字节]'
- en: The output is as expected until we get to the "Ü." That's because the "Ü" was
    encoded using more than one byte, and each byte on its own no longer makes sense.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与预期相符，直到我们到达“Ü”字符。这是因为“Ü”字符使用了多个字节进行编码，单独的字节本身不再有意义。
- en: To safely work with interindividual characters of a multi-byte string, you first
    must convert the strings slice of `byte` types to a slice of `rune` types.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全地处理多字节字符串的个体字符，你首先必须将`byte`类型的字符串切片转换为`rune`类型的切片。
- en: 'Consider the following example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE65]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Running the preceding code gives the following output:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会得到以下输出：
- en: '![Figure 3.10: Output displaying strings'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10：根据字符串显示的输出]'
- en: '](img/B14177_03_10.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_03_10.jpg]'
- en: 'Figure 3.10: Output displaying strings'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3.10：根据字符串显示的输出]'
- en: If we do wish to work with each character in a loop like this, then using a
    `range` would be a better choice. When using `range`, instead of going one `byte`
    at a time, it moves along the string one `rune` at a time. The index is the byte
    offset, and the value is a `rune`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确实希望像这样在循环中处理每个字符，那么使用`range`会是一个更好的选择。当使用`range`时，它不是一次移动一个`byte`，而是每次移动字符串中的一个`rune`。索引是字节偏移量，值是一个`rune`。
- en: 'Exercise 3.05: Safely Looping over a String'
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习3.05：安全地遍历字符串
- en: 'In this exercise, we''ll declare a string and initialize it with a multi-byte
    string value. We''ll then loop over the string using `range` to give us each character,
    one at a time. We''ll then print out the byte index and the character to the console:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将声明一个字符串，并用多字节字符串值初始化它。然后，我们将使用`range`遍历字符串，一次提供一个字符。然后，我们将打印出字节索引和字符到控制台：
- en: Create a new folder and add a `main.go` file.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并添加一个`main.go`文件。
- en: 'In `main.go`, add the main package name to the top of the file:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`文件中，将主包名添加到文件顶部：
- en: '[PRE66]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now add the imports we''ll use in this file:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加我们将在此文件中使用的导入：
- en: '[PRE67]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create the `main()` function:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`main()`函数：
- en: '[PRE68]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Declare the string with a multi-byte string value:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个具有多字节字符串值的字符串：
- en: '[PRE69]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create a `range` loop that loops over the string, then capture the `index`
    and `rune` in variables:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Print the `index` and `rune` to the console, casting the rune to a string:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Close the loop:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Close the `main()` function:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Save the file and in the new folder run the following:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Running the preceding code gives the following output:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11: Output after safely looping over a string'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_11.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.11: Output after safely looping over a string'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we demonstrated that looping over a string in a multi-byte
    safe way is baked right into the language. Using this method prevents you from
    getting invalid string data.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common way to find bugs is to check how many characters a string has
    by using `len` directly on it. Here is an example of some common ways multi-byte
    strings can get mishandled:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Running the preceding code gives the following output:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12: Output displaying bugs after using the len function'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_12.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.12: Output displaying bugs after using the len function'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: You can see that when using `len` directly on a string, you get the wrong answer.
    Checking the length of data input using `len` in this way would end up with invalid
    data. For example, if we needed the input to be exactly 8 characters long and
    somebody entered a multi-byte character, using `len` directly on that input would
    allow them to enter less than 8 characters.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: When working with strings, be sure to check the `strings` package first. It's
    filled with useful tools that may already do what you need.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take a close look at Go's special `nil` value.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The nil Value
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`nil` is not a type but a special value in Go. It represents an empty value
    of no type. When working with pointers, maps, and interfaces (we''ll cover these
    in the next chapter), you need to be sure they are not `nil`. If you try to interact
    with a `nil` value, your code will crash.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can''t be sure whether a value is `nil` or not, you can check it like
    this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Running the preceding code shows the following output:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Activity 3.01: Sales Tax Calculator'
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we create a shopping cart application, where sales tax must
    be added to calculate the total:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Create a calculator that calculates the sales tax for a single item.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The calculator must take the items cost and its sales tax rate.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sum the sales tax and print the total amount of sales tax required for the
    following items:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.13:List of items with the sales tax rates'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_13.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13:List of items with the sales tax rates
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Your output should look like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 691.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3.02: Loan Calculator'
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we must create a loan calculator for an online financial
    advisor platform. Our calculator should have the following rules:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: A good credit score is a score of 450 or above.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a good credit score, your interest rate is 15%.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a less than good score, your interest rate is 20%.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a good credit score, your monthly payment must be no more than 20% of your
    monthly income.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a less than good credit score, your monthly payment must be no more than
    10% of your monthly income.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a credit score, monthly income, loan amount, or loan term is less than 0,
    return an error.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the term of the loan if not divisible by 12 months, return an error.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The interest payment will be a simple calculation of loan amount * interest
    rate * loan term.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After doing these calculations, display the following details to the user:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This is the expected output:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14: Output of loan calculator'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_14.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.14: Output of loan calculator'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 692.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a big step in working with Go's type system. We took
    the time to define what types are and why they are needed. We then explored each
    of the core types in Go. We started with the simple `bool` type, and we were able
    to show how critical it is to everything we do in our code. We then moved on to
    the number types. Go has lots of types for numbers, reflecting the control that
    Go likes to give developers when it comes to memory usage and accuracy. After
    numbers, we looked at how strings work and how they are closely related to the
    rune type. With the advent of multi-byte characters, it's easy to make a mess
    of your text data. Go has provided power built-in features to help you get it
    right. Lastly, we looked at `nil` and how you use it within Go.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: The concepts you've learned in this chapter have armed you with the knowledge
    needed to tackle Go's more complex types, such as collections and structs. We'll
    be looking at these complex types in the next chapter.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
