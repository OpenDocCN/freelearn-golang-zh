- en: 3\. Core Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter aims to show you how to use Go's basic core types to design your
    software's data. We'll work through each type to show what they are useful for
    and how to use them in your software. Understanding these core types provides
    you with the foundation required to learn how to create complex data designs.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to create variables of different
    types for Go programs and assign values to variables of different types. You will
    learn to identify and pick a suitable type for any programming situation. You
    will also write a program to measure password complexity and implement empty value
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to use `if`, `if`-`else`, `switch`,
    `continue`, and `break` in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Go is a strongly typed language, and all data is assigned a type. That type
    is fixed and can't be changed. What you can and can't do with your data is constrained
    by the types you assign. Understanding exactly what defines every one of Go's
    core types is critical to success with the Go language.
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters, we'll talk about Go's more complex types, but those types
    are built on the core types defined in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Go's core types are well-thought-out and easy to understand once you understand
    the details. Having to understand the details means Go's type system is not always
    intuitive. For example, Go's most common number type, `int`, may be either 32
    bits or 64 bits in size depending on the computer used to compile the code.
  prefs: []
  type: TYPE_NORMAL
- en: Types are needed to make data easier for humans to work with. Computers only
    think about data in binary. Binary is hard for people to work with. By adding
    a layer of abstraction to binary data and labeling it as a number or some text,
    humans have an easier time reasoning about it. Reducing the cognitive load allows
    people to build more complex software because they're not overwhelmed by managing
    the details of the binary data.
  prefs: []
  type: TYPE_NORMAL
- en: Programming languages need to define what a number is or what a text is for.
    A programming language defines what you can call a number, and it defines what
    operations you can use on a number. For example, can a whole number such as 10
    and a floating-point number such as 3.14 both be stored as the same type? While
    it seems obvious that you can multiply numbers, can you multiply text? As we progress
    through this chapter, we'll clearly define what the rules are for each type and
    what operations you can use with each of them.
  prefs: []
  type: TYPE_NORMAL
- en: The way data is stored is also a large part of what defines a `type`. To allow
    for the building of efficient software, Go places limits on how large some of
    its types can be. For example, the largest amount of storage for a number in Go's
    core types is 64 bits of memory. This allows for any number up to 18,446,744,073,709,551,615\.
    Understanding these type limitations is critical in building bug-free code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The things that define a type are:'
  prefs: []
  type: TYPE_NORMAL
- en: The kind of data that you can store in it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What operations you can use with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What those operations do to it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How much memory it can use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter gives you the knowledge and confidence to use Go's types system
    correctly in your code.
  prefs: []
  type: TYPE_NORMAL
- en: True and False
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: True and false logic is represented using the Boolean type, `bool`. Use this
    type when you need an on/off switch in your code. The value of a `bool` can only
    ever be `true` or `false`. The zero value of a `bool` is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: When using a comparison operator such as `==` or `>`, the result of that comparison
    is a `bool` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code example, we use comparison operators on two numbers. You''ll see
    that the result is a `bool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code shows the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 3.01: Program to Measure Password Complexity'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An online portal creates user accounts for its users and accepts passwords
    that are only 8-15 characters long. In this exercise, we write a program for the
    portal to display whether the password entered meets the character requirements.
    The character requirements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Have a lowercase letter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have an uppercase letter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a symbol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be 8 or more characters long
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To do this exercise, we''re going to use a few new features. Don''t worry if
    you don''t quite understand what they are doing; we''ll cover them in detail in
    the next chapter. Consider this a sneak peek. We''ll explain what everything is
    as we go, but your main focus should be on the Boolean logic:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the main package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the imports we''ll use in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that takes a string argument and returns a `bool`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert the password string into `rune`, which is a type that is safe for multi-byte
    (UTF-8) characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll talk more about rune later in this chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Count the number of multi-byte characters using `len`. This code results in
    a `bool` result that can be used in the `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define some `bool` variables. We''ll check these at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Loop over the multi-byte characters one at a time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the `unicode` package, check whether this character is uppercase. This
    function returns a `bool` that we can use directly in the `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If it is, we''ll set the `hasUpper` `bool` variable to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Do the same thing for lowercase letters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also do it for numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For symbols, we''ll also accept punctuation. Use the `or` operator, which works
    with `Booleans`, to result in `true` if either of these functions returns `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To pass all our checks, all our variables must be `true`. Here, we combine
    multiple `and` operators to create a one-line statement that checks all four variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `passwordChecker()` function with an invalid password. As this returns
    a `bool`, it can be used directly in an `if` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, call the function with a valid password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file and in the new folder and then run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code shows the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we highlighted a variety of ways that `bool` values manifest
    themselves in the code. `Bool` values are critical to giving your code the ability
    to make a choice and be dynamic and responsive. Without `bool`, your code would
    have a hard time doing anything.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll take a look at numbers and how Go categorizes them.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go has two distinct number types: integers, also known as whole numbers, and
    floating-point numbers. A floating-point number allows a number with whole numbers
    and fractions of a whole number.'
  prefs: []
  type: TYPE_NORMAL
- en: 1, 54, and 5,436 are examples of whole numbers. 1.5, 52.25, 33.333, and 64,567.00001
    are all examples of floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The default and empty values for all number types is 0.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll start our number journey by looking at integers.
  prefs: []
  type: TYPE_NORMAL
- en: Integer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Integer types are classified in two ways, based on the following conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not they can store negative numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The smallest and largest numbers they can store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types that can store negative numbers are called signed integers. Types that
    can't store negative numbers are called unsigned integers. How big and small a
    number each type can store is expressed by how many bytes of internal storage
    they have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an excerpt from the Go language specification with all the relevant
    integer types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.01: Go language specification with relevant integer types'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.01: Go language specification with relevant integer types'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also special integer types as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.02: Special integer types'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.02: Special integer types'
  prefs: []
  type: TYPE_NORMAL
- en: '`uint` and `int` are either 32 or 64 bits depending on whether you compile
    your code for a 32-bit system or a 64-bit system. It''s rare nowadays to run applications
    on a 32-bit system, systems so most of the time they are 64 bits.'
  prefs: []
  type: TYPE_NORMAL
- en: An `int` on a 64-bit system is not an `int64`. While these two types are identical,
    they are not the same integer type, and you can't use them together. If Go did
    allow this, there would be problems when the same code gets compiled for a 32-bit
    machine, so keeping them separate ensures that the code is reliable.
  prefs: []
  type: TYPE_NORMAL
- en: This incompatibility is not just an `int` thing; you can't use any of the integer
    types together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Picking the correct integer type to use when defining a variable is easy: use
    `int`. When writing code for an application, `int` does the job the majority of
    the time. Only think about using the other types when an `int` is causing a problem.
    The sorts of problems you see with `int` tend to be related to memory usage.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say you have an app that's running out of memory. The app
    uses a massive number of integers, but these integers are never negative and won't
    go over 255\. One possible fix is to switch from using `int` to using `uint8`.
    Doing this cuts its memory usage from 64 bits (8 bytes) per number to 8 bits (1
    byte) per number.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can show this by creating a collection of both kinds of type then asking
    Go how much heap memory it is using. The output may vary on your computer, but
    the effect should be similar. This code creates a collection of `int` or `int8`.
    It then adds 10 million values to the collection. Once that''s done, it uses the
    runtime package to give us a reading of how much heap memory is being used. We
    convert that reading to MB and then print it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output using `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s the output using `int8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We saved a good amount of memory here, but we need 10 million variables to make
    it worthwhile. Hopefully, now you are convinced that it's okay to start with `int`
    and only worry about performance when it's a problem, not before.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at floating-point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Floating Point
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go has two floating-point number types, `float32` and `float64`. The bigger
    `float64` allows for more precision in the numbers. `float32` has 32 bits of storage
    and `float64` has 64 bits of storage. Floats split their storage between whole
    numbers (everything to the left of the decimal point) and decimal numbers (everything
    to the right of the decimal point). How much space is used for the whole number
    or the decimal numbers, varies by the number being stored. For example, 9,999.9
    would use more storage for the whole numbers while 9.9999 would use more storage
    for the decimal numbers. With `float64`'s bigger space for storage, it can store
    more whole numbers and/or more decimal numbers than `float32` can.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.02: Floating-Point Number Accuracy'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we're going to compare what happens when we do some divisions
    on numbers that don't divide equally. We'll be dividing 100 by 3\. One way of
    representing the result is 33 ⅓. Computers, for the most part, can't compute fractions
    like this. Instead, they use a decimal representation, which is 33.3 recurring,
    where the 3 after the decimal point repeats forever. If we let the computer do
    that it uses up all the memory, which is not very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily for us, we don''t need to worry about this happening as the floating-point
    types have storage limits. The downside is that this leads to a number that doesn''t
    reflect the true result; the result has a certain amount of inaccuracy. Your tolerance
    for inaccuracy needs and how much storage space you want to give to your floating-point
    numbers must be balanced out:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the main package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the imports we''ll use in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare an `int` and initialize it with a value of 100:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `float32` and initialize it with a value of 100:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a `float64` and initialize it with a value of 100:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Divide each variable by 3 and print the result to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file and in the new folder run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code shows the following output displaying `int`, `float32`,
    and `float64` values:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we can see that the computer is not able to give perfect answers
    to this sort of division. You can also see that when doing this sort of math on
    integers, you don't get an error. Go ignores any fractional part of the number,
    which is usually not what you want. We can also see that the `float64` gives a
    much more accurate answer than `float32`.
  prefs: []
  type: TYPE_NORMAL
- en: While this limit seems like it would lead to problems with inaccuracy, for real-world
    business work, it does get the job done well enough the vast majority of the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens if we try to get our number back to 100 by multiplying
    it by 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code shows the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we saw that the accuracy is not as impacted as much as you'd
    expect. At first glance, floating-point math can seem simple, but it gets complicated
    quickly. When defining your floating-point variables, typically `float64` should
    be your first choice unless you need to be more memory efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at what happens when you go beyond the limits of a number type.
  prefs: []
  type: TYPE_NORMAL
- en: Overflow and Wraparound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you try to initialize a number with a value that''s too big for the type
    we are using, you get an overflow error. The highest number you can have in an
    `int8` is 127\. In the following code, we''ll try to initialize it with 128 and
    see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.03: Output after initializing with 128'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.03: Output after initializing with 128'
  prefs: []
  type: TYPE_NORMAL
- en: This error is easy to fix and can't cause any hidden problems. The real problem
    is when the compiler can't catch it. When this happens, the number will ".wraparound".
    Wraparound means the number goes from its highest possible value to its smallest
    possible value. Wraparound can be easy to miss when developing your code and can
    cause significant problems to your users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.03: Triggering Number Wraparound'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll declare two small integer types: `int8` and `uint8`.
    We''ll initialize them near their highest possible value. Then we''ll use a loop
    statement to increment them by 1 per loop then print their value to the console.
    We''ll be able to see exactly when they wraparound.'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go` add the main package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the imports we''ll use in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the main function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare an `int8` variable with an initial value of 125:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare an `uint8` variable with an initial value of 253:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `for i` loop that runs five times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Increment the two variables by 1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the variables'' values to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file, and in the new folder run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code shows the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.04: Output after wraparound'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.04: Output after wraparound'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw that, for signed integers, you'd end up with a negative
    number and for unsigned integers, it wraps around to 0\. You must always consider
    the maximum possible number for your variable and be sure to have the appropriate
    type to support that number.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at what you can do when you need a number that's bigger than
    the core types can give you.
  prefs: []
  type: TYPE_NORMAL
- en: Big Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need a number higher or lower than `int64` or `uint64` can give, you
    can use the `math/big` package. This package feels a little awkward to use compared
    to dealing with integer types, but you'll be able to do everything you can generally
    do with integers using its API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.04: Big Numbers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''re going to create a number that''s larger than what
    is possible with Go''s core number types. To show that, we''ll use an addition
    operation. We''ll also do the same to an `int` to show the difference. Then, we''ll
    print the result to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the main package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the imports we''ll use in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare an `int` and initialize with `math.MaxInt64`, which is the highest
    possible value for an `int64` in Go, which is defined as a constant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add 1 to the `int`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we''ll create a `big` `int`. This is a custom type and is not based on
    Go''s `int` type. We''ll also initialize it with Go''s highest possible number
    value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll add 1 to our `big` `int`. You can see that this feels clumsy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print out the max `int` size and the values for our Go `int` and our `big`
    `int`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file, and in the new folder run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code shows the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.5: Output displaying large numbers with Go''s number types'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.5: Output displaying large numbers with Go''s number types'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw that while `int` has wrapped around, `big.Int` has
    added the number correctly.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a situation where you have a number whose value is higher than Go
    can manage, then the `big` package from the standard library is what you need.
    Next, we'll look at a special Go number type used to represent raw data.
  prefs: []
  type: TYPE_NORMAL
- en: Byte
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `byte` type in Go is just an alias for `uint8`, which is a number that has
    8 bits of storage. In reality, `byte` is a significant type, and you'll see it
    in lots of places. A bit is a single binary value, a single on/off switch. Grouping
    bits into groups of 8 was a common standard in early computing and became a near-universal
    way to encode data. 8 bits have 256 possible combinations of "off" and "on," `uint8`
    has 256 possible integer values from 0 to 255\. All combinations of on and off
    can are represented with this type.
  prefs: []
  type: TYPE_NORMAL
- en: You'll see `byte` used when reading and writing data to and from a network connection
    and when reading and writing data to files.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we're all done with numbers. Now, let's look at how Go stores and
    manages text.
  prefs: []
  type: TYPE_NORMAL
- en: Text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go has a single type to represent some text, `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are writing some text for a `string`, it''s called a string literal.
    There are two kinds of string literals in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: Raw – defined by wrapping text in a pair of `` ` ``
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreted – defined by surrounding the text in a pair of `"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With raw, what ends up in your variable is precisely the text that you see on
    the screen. With interpreted, Go scans what you've written and then applies transformations
    based on its own set of rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6: Output printing texts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.6: Output printing texts'
  prefs: []
  type: TYPE_NORMAL
- en: In an interpreted string, `\n` represented a new line. In our raw string, `\n`
    doesn't do anything. To get a new line in the raw string, we must add an actual
    new line in our code. The interpreted string must use `\n` to get a new line as
    having a real new line in an interpreted string is not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: While there are a lot of things you can do with an interpreted string literal,
    in real-world code, the two you'll see more commonly are `\n` for a new line and
    occasionally `\t` for a tab.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreted string literals are the most common kind in real-world code, but
    raw literals have their place. If you wanted to copy and paste some text that
    contains a lot of new lines, `"` or `\`, in it, it's easier to use **raw**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, you can see how using raw makes the code more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code shows the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: Output for more readable code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.7: Output for more readable code'
  prefs: []
  type: TYPE_NORMAL
- en: One thing you can't have in a raw literal is a `` ` ``. If you need a literal
    with a `` ` `` in it, you must use an interpreted string literal.
  prefs: []
  type: TYPE_NORMAL
- en: String literals are just ways of getting some text into a `string` type variable.
    Once you have the value in the variable, there are no differences.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at how to work safely with multi-byte strings.
  prefs: []
  type: TYPE_NORMAL
- en: Rune
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `rune` is a type with enough storage to store a single UTF-8 multi-byte character.
    String literals are encoded using UTF-8\. UTF-8 is a massively popular and common
    multi-byte text encoding standard. The `string` type itself is not limited to
    UTF-8 as Go needs to also support text encoding types other than UTF-8\. `string`
    not being limited to UTF-8 means there is often an extra step you need to take
    when working with your strings to prevent bugs.
  prefs: []
  type: TYPE_NORMAL
- en: The different encodings use a different number of bytes to encode text. Legacy
    standards use one byte to encode a single character. UTF-8 uses up to four bytes
    to encode a single character. When text is in the `string` type, to allow for
    this variability, Go stores all strings as a `byte` collection. To be able to
    safely perform operations with text of any kind of encoding, single- or multi-byte,
    it should be converted from a `byte` collection to a `rune` collection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you don't know the encoding of the text, it's usually safe to convert it
    to UTF-8\. Also, UTF-8 is backward-compatible with single-byte encoded text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go makes it easy to access the individual bytes of a string, as shown in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the package, import our needed libraries, and create the `main()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll create a string that contains a multi-byte character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are going to use a `for i` loop to print out each byte of our string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we will close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8: Output displaying bytes with respect to input length'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.8: Output displaying bytes with respect to input length'
  prefs: []
  type: TYPE_NORMAL
- en: The numbers printed out are the byte values of the string. There are only 13
    letters in our string. However, it contained a multi-byte character, so we printed
    out 14 byte values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s convert our bytes back to strings. This conversion uses type conversion,
    which we''ll cover in detail soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9: Output displaying bytes converted as strings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.9: Output displaying bytes converted as strings'
  prefs: []
  type: TYPE_NORMAL
- en: The output is as expected until we get to the "Ü." That's because the "Ü" was
    encoded using more than one byte, and each byte on its own no longer makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: To safely work with interindividual characters of a multi-byte string, you first
    must convert the strings slice of `byte` types to a slice of `rune` types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10: Output displaying strings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.10: Output displaying strings'
  prefs: []
  type: TYPE_NORMAL
- en: If we do wish to work with each character in a loop like this, then using a
    `range` would be a better choice. When using `range`, instead of going one `byte`
    at a time, it moves along the string one `rune` at a time. The index is the byte
    offset, and the value is a `rune`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3.05: Safely Looping over a String'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll declare a string and initialize it with a multi-byte
    string value. We''ll then loop over the string using `range` to give us each character,
    one at a time. We''ll then print out the byte index and the character to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the main package name to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now add the imports we''ll use in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the string with a multi-byte string value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `range` loop that loops over the string, then capture the `index`
    and `rune` in variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the `index` and `rune` to the console, casting the rune to a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file and in the new folder run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11: Output after safely looping over a string'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.11: Output after safely looping over a string'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we demonstrated that looping over a string in a multi-byte
    safe way is baked right into the language. Using this method prevents you from
    getting invalid string data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common way to find bugs is to check how many characters a string has
    by using `len` directly on it. Here is an example of some common ways multi-byte
    strings can get mishandled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12: Output displaying bugs after using the len function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.12: Output displaying bugs after using the len function'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that when using `len` directly on a string, you get the wrong answer.
    Checking the length of data input using `len` in this way would end up with invalid
    data. For example, if we needed the input to be exactly 8 characters long and
    somebody entered a multi-byte character, using `len` directly on that input would
    allow them to enter less than 8 characters.
  prefs: []
  type: TYPE_NORMAL
- en: When working with strings, be sure to check the `strings` package first. It's
    filled with useful tools that may already do what you need.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take a close look at Go's special `nil` value.
  prefs: []
  type: TYPE_NORMAL
- en: The nil Value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`nil` is not a type but a special value in Go. It represents an empty value
    of no type. When working with pointers, maps, and interfaces (we''ll cover these
    in the next chapter), you need to be sure they are not `nil`. If you try to interact
    with a `nil` value, your code will crash.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can''t be sure whether a value is `nil` or not, you can check it like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code shows the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Activity 3.01: Sales Tax Calculator'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we create a shopping cart application, where sales tax must
    be added to calculate the total:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a calculator that calculates the sales tax for a single item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The calculator must take the items cost and its sales tax rate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sum the sales tax and print the total amount of sales tax required for the
    following items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.13:List of items with the sales tax rates'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13:List of items with the sales tax rates
  prefs: []
  type: TYPE_NORMAL
- en: 'Your output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 691.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3.02: Loan Calculator'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we must create a loan calculator for an online financial
    advisor platform. Our calculator should have the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: A good credit score is a score of 450 or above.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a good credit score, your interest rate is 15%.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a less than good score, your interest rate is 20%.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a good credit score, your monthly payment must be no more than 20% of your
    monthly income.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a less than good credit score, your monthly payment must be no more than
    10% of your monthly income.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a credit score, monthly income, loan amount, or loan term is less than 0,
    return an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the term of the loan if not divisible by 12 months, return an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The interest payment will be a simple calculation of loan amount * interest
    rate * loan term.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After doing these calculations, display the following details to the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14: Output of loan calculator'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_03_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.14: Output of loan calculator'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 692.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a big step in working with Go's type system. We took
    the time to define what types are and why they are needed. We then explored each
    of the core types in Go. We started with the simple `bool` type, and we were able
    to show how critical it is to everything we do in our code. We then moved on to
    the number types. Go has lots of types for numbers, reflecting the control that
    Go likes to give developers when it comes to memory usage and accuracy. After
    numbers, we looked at how strings work and how they are closely related to the
    rune type. With the advent of multi-byte characters, it's easy to make a mess
    of your text data. Go has provided power built-in features to help you get it
    right. Lastly, we looked at `nil` and how you use it within Go.
  prefs: []
  type: TYPE_NORMAL
- en: The concepts you've learned in this chapter have armed you with the knowledge
    needed to tackle Go's more complex types, such as collections and structs. We'll
    be looking at these complex types in the next chapter.
  prefs: []
  type: TYPE_NORMAL
