<html><head></head><body>
		<div>
			<div id="_idContainer059" class="Content">
			</div>
		</div>
		<div id="_idContainer060" class="Content">
			<h1 id="_idParaDest-108"><a id="_idTextAnchor112"/>4. Complex Types</h1>
		</div>
		<div id="_idContainer077" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces Go's more complex types. This will build on what we learned in the previous chapter regarding Go's core types. These complex types are indispensable when you build more complex software as they allow you to logically group related data together. This ability to group data makes your code easier to understand, maintain, and fix.</p>
			<p class="callout">By the end of this chapter, you will be able to use arrays, slices, and maps to group data together. You will learn to create custom types based on the core types. You will also learn to use structs to create structures composed of named fields of any other types and explain the importance of <strong class="source-inline">interface{}</strong>.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor113"/>Introduction</h1>
			<p>In the previous chapter, we covered Go's core types. These types are critical to everything you'll do in Go, but it can be challenging to model more complex data. In modern computer software, we want to be able to group data and logic where possible. We also want to be able to make our logic reflect the real-world solutions we're building.</p>
			<p>If you were building software for cars, you would ideally want a custom type that embodies a car. This type should be named "car" and it should have properties that can store things about what kind of car it is. The logic that affects the car, such as starting and stopping, should be associated with the car type. If we had to manage more than one car, we need to be able to group all the cars.</p>
			<p>In this chapter, we'll learn about the features in Go that allow us to model the data part of this challenge. Then, in the next chapter, we'll solve the behavior part. By using custom types, you can extend Go's core types, and using structs allows you to compose a type made of other types and associate logic with them. Collections let you group data together and allow you to loop over and perform operations on them.</p>
			<p>As the complexity of your tasks increase, Go's complex types help you keep your code easy to understand and maintain. Collections such as <strong class="source-inline">arrays</strong>, <strong class="source-inline">slices</strong>, and <strong class="source-inline">maps</strong> allow you to keep related data grouped together. Go's <strong class="source-inline">struct</strong> type allows you to create a single type that's made up of other strings, numbers, and Booleans, giving you the power to build models of complex real-world concepts. Structs also allow you to attach logic to them; this allows you to have the logic that controls your models closely tied together.</p>
			<p>When things get complicated with types, we need to know how to use type conversions and assertions to manage type mismatches correctly. We'll also be looking at Go's <strong class="source-inline">interface{}</strong> type. This type is almost magical in that it allows you to overcome Go's struct typing system but in a way that's still type-safe.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor114"/>Collection Types</h1>
			<p>If you were dealing with a single email address, you would define a string variable to hold that value for you. Now, think about how you would structure your code if you needed to deal with between 0 and 100 email addresses. You could define a separate variable for each email address, but Go has something else we can use.</p>
			<p>When dealing with lots of similar data, we put it in a collection. Go's collection types are array, slice, and map. Go's collection types are strongly typed and are easy to loop over, but they each have unique qualities that mean they are each better suited to different use cases.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor115"/>Arrays</h1>
			<p>Go's most basic collection is an array. When you define an array, you must specify what type of data it may contain and how big the array is in the following form: <strong class="source-inline">[&lt;size&gt;]&lt;type&gt;</strong>. For example, <strong class="source-inline">[10]int</strong> is an array of size 10 that contains ints, while <strong class="source-inline">[5]string</strong> is an array of size 5 that contains strings. </p>
			<p>The key to making this an array is specifying the size. If your definition didn't have the size, it would seem like it works, but it would not be an array – it'd be a slice. A slice is a different, more flexible, type of collection that we'll look at after arrays. You can set the element values to be any type, including pointers and arrays.</p>
			<p>You can initialize arrays with data using the following form: <strong class="source-inline">[&lt;size&gt;]&lt;type&gt;{&lt;value1&gt;,&lt;value2&gt;,…&lt;valueN&gt;}</strong>. For example, <strong class="source-inline">[5]string{1}</strong> would initialize the array with the first value as 1, while <strong class="source-inline">[5]string{9,9,9,9,9}</strong> would fill the array with the value 9 for each element. When initializing with data, you can have Go set the size of the array based on the number of elements you initialize it with. You can take advantage of this by replacing the length number with <strong class="source-inline">...</strong>. For example, <strong class="source-inline">[...]string{9,9,9,9,9}</strong> would create an array of length 5 because we initialized it with 5 elements. Just like all arrays, the length's set at compile time and is not changeable at runtime.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor116"/>Exercise 4.01: Defining an Array</h2>
			<p>In this exercise, we're going to define a simple array of size 10 that takes integers. Then, we'll print out the contents. Let's get started:</p>
			<ol>
				<li>Create a new folder and add a <strong class="source-inline">main.go</strong> file to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create a function that defines an array and then return it:<p class="source-code">func defineArray() [10]int {</p><p class="source-code">  var arr [10]int</p><p class="source-code">  return arr</p><p class="source-code">}</p></li>
				<li>Define <strong class="source-inline">main()</strong>, call the function, and print the result. We'll use <strong class="source-inline">fmt.Printf</strong> with <strong class="source-inline">%#v</strong> to get extra details about the value, including its type:<p class="source-code">func main() {</p><p class="source-code">  fmt.Printf("%#v\n", defineArray())</p><p class="source-code">}</p></li>
				<li>Save this. Then, from within the new folder, run the following:<p class="source-code">go run .</p><p>Running the preceding code provides us with the following output:</p><p class="source-code">[10]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 0}</p></li>
			</ol>
			<p>In this exercise, we've defined an array but haven't filled it with any data. Since all arrays have a fixed size, when the array was printed out, it contained 10 values. These values are the empty values for whatever type the array accepts.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor117"/>Comparing Arrays</h2>
			<p>The array's length is part of its type definition. If you have two arrays that accept the same type but they're different sizes, they are not compatible and aren't comparable with each other. Arrays of different lengths that are not the same type can can't be compared with each other. </p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor118"/>Exercise 4.02: Comparing Arrays</h2>
			<p>In this exercise, we'll compare arrays. First, we'll define some arrays; some are comparable, while some are not. Then, we'll run the code and fix any problems that come up. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create a function that defines four arrays:<p class="source-code">func compArrays() (bool, bool, bool) {</p><p class="source-code">  var arr1 [5]int</p><p class="source-code">  arr2 := [5]int{0}</p><p class="source-code">  arr3 := [...]int{0, 0, 0, 0, 0}</p><p class="source-code">  arr4 := [9]int{0, 0, 0, 0, 9}</p></li>
				<li>Compare the arrays and return the result of the comparison. This closes off this function:<p class="source-code">  return arr1 == arr2, arr1 == arr3, arr1 == arr4</p><p class="source-code">}</p></li>
				<li>Define <strong class="source-inline">main</strong> so that it prints out the results:<p class="source-code">func main() {</p><p class="source-code">  comp1, comp2, comp3 := compArrays()</p><p class="source-code">  fmt.Println("[5]int == [5]int{0}        :", comp1)</p><p class="source-code">  fmt.Println("[5]int == [...]int{0, 0, 0, 0, 0}:", comp2)</p><p class="source-code">  fmt.Println("[5]int == [9]int{0, 0, 0, 0, 9}  :", comp3)</p><p class="source-code">}</p></li>
				<li>Save and run the code:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p><div id="_idContainer061" class="IMG---Figure"><img src="image/B14177_04_01.jpg" alt="Figure 4.1: Array type mismatch error&#13;&#10;"/></div><p class="figure-caption">Figure 4.1: Array type mismatch error</p><p>You should see an error. This error is telling you that <strong class="source-inline">arr1</strong>, which is a <strong class="source-inline">[5] int</strong>, and <strong class="source-inline">arr4</strong>, which is a <strong class="source-inline">[9] int</strong>, are not the same type and aren't compatible. Let's fix that.</p></li>
				<li>Here, we have the following:<p class="source-code">  arr4 := [9]int{0, 0, 0, 0, 9}</p><p>We need to replace this with the following:</p><p class="source-code">  arr4 := [9]int{0, 0, 0, 0, 9}</p></li>
				<li>We also have the following code:<p class="source-code">  fmt.Println("[5]int == [9]int{0, 0, 0, 0, 9}  :", comp3)</p><p>We need to replace this with the following:</p><p class="source-code">  fmt.Println("[5]int == [5]int{0, 0, 0, 0, 9}  :", comp3)</p></li>
				<li>Save and run the code again using the following command:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/B14177_04_02.jpg" alt="Figure 4.2: Output without error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2: Output without error</p>
			<p>In our exercise, we defined some arrays, and they were all defined in slightly different ways. At first, we had an error because we tried to compare arrays of different lengths, which, in Go, means they are different types. We fixed that and ran the code again. Then, we could see that even though the first three arrays were defined using different methods, they ended up being the same or equal to each other. The last array, now with its type fixed, had different data contained in it, so it's not the same or equal to the other arrays. The other collection types, that is, slice and map, are not comparable in this way. With map and slice, you must loop over the contents of the two collections you're comparing and compare them manually. This ability gives arrays an advantage if comparing data in collections is a hot path in your code.</p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor119"/>Initializing Arrays Using Keys</h2>
			<p>So far, when we've initialized our arrays with data, we've let Go choose the keys for us. Go allows you to pick the key you want for your data if you want using <strong class="source-inline">[&lt;size&gt;]&lt;type&gt;{&lt;key1&gt;:&lt;value1&gt;,…&lt;keyN&gt;:&lt;valueN&gt;}</strong>. Go is flexible and lets you set the keys with gaps and in any order. This ability to set values with a key is helpful if you've defined an array where the numeric keys have a specific meaning and you want to set a value for a specific key but don't need to set any of the other values. </p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor120"/>Exercise 4.03: Initializing an Array Using Keys</h2>
			<p>In this exercise, we'll initialize a few arrays using some keys to set specific values. Then, we'll compare them to each other. After, we'll print out one of the arrays and look at its contents. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create a function that defines three arrays:<p class="source-code">func compArrays() (bool, bool, [10]int) {</p><p class="source-code">  var arr1 [10]int</p><p class="source-code">  arr2 := [...]int{9: 0}</p><p class="source-code">  arr3 := [10]int{1, 9: 10, 4: 5}</p></li>
				<li>Compare the arrays and return the last one so that we can print it out later:<p class="source-code">  return arr1 == arr2, arr1 == arr3, arr3</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">main</strong> function and call <strong class="source-inline">compArrays</strong>. Then, print out the results:<p class="source-code">func main() {</p><p class="source-code">  comp1, comp2, arr3 := compArrays()</p><p class="source-code">  fmt.Println("[10]int == [...]{9:0}        :", comp1)</p><p class="source-code">  fmt.Println("[10]int == [10]int{1, 9: 10, 4: 5}}:", comp2)</p><p class="source-code">  fmt.Println("arr3                 :", arr3)</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the new folder, run the following:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/B14177_04_03.jpg" alt="Figure 4.3: Array initialized using keys&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.3: Array initialized using keys</p>
			<p>In this exercise, we used keys when initializing the data for an array. For <strong class="source-inline">arr2</strong>, we combined the <strong class="source-inline">...</strong> shortcut with setting a key to make the array length directly relate to the key we set. With <strong class="source-inline">arr3</strong>, we mixed it using keys and without using keys, and we also used the keys out of order. Go's flexibility when using keys is strong and makes using arrays in this way pleasant.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor121"/>Reading from an Array</h2>
			<p>So far, we've defined an array and initialized it with some data. Now, let's read that data out. It's possible to access a single element of the array using <strong class="source-inline">&lt;array&gt;[&lt;index&gt;]</strong>. For example, this accesses the first element of an array, <strong class="source-inline">arr[0]</strong>. I know 0 is the first element of the array because arrays always use a zero-indexed integer key. The zero index means the first index for an array is always 0 and the last index is always the array's length minus 1.</p>
			<p>The order of the items in an array is guaranteed to be stable. Order stability means that an item placed at index 0 is always the first item in the array.</p>
			<p>Being able to access specific parts of an array can be helpful in a few ways. It's often necessary to validate the data in an array by checking either the first and/or last elements. Sometimes, the position of the data in an array is important so that you know you can get, for example, a product's name from the third index. This positional significance is common when reading <strong class="bold">comma-separated value</strong> (<strong class="bold">CSV</strong>) files or other similar delimiter separated value files. CSV is still in common use as it is a popular choice for exporting data from spreadsheet documents.</p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor122"/>Exercise 4.04: Reading a Single Item from an Array</h2>
			<p>In this exercise, we'll define an array and initialize it with some words. Then, we'll read the words out in the form of a message and print it. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create a function that defines an array with our words. The order of the words is important:<p class="source-code">func message() string {</p><p class="source-code">  arr := [...]string{</p><p class="source-code">  "ready",</p><p class="source-code">  "Get",</p><p class="source-code">  "Go",</p><p class="source-code">  "to",</p><p class="source-code">  }</p></li>
				<li>Now, create a message by joining the words in a specific order and returning it. We're using the <strong class="source-inline">fmt.Sprintln</strong> function here since it allows us to capture the formatted text before it's printed:<p class="source-code">  return fmt.Sprintln(arr[1], arr[0], arr[3], arr[2])</p><p class="source-code">}</p></li>
				<li>Create our <strong class="source-inline">main()</strong> function, call the <strong class="source-inline">message</strong> function, and print it to the console:<p class="source-code">func main() {</p><p class="source-code">  fmt.Print(message())</p><p class="source-code">}</p></li>
				<li>Save and run the code:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p><p class="source-code">Get ready to Go</p></li>
			</ol>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor123"/>Writing to an Array</h2>
			<p>Once an array is defined, you're able to make changes to individual elements using their index using <strong class="source-inline">&lt;array&gt;[&lt;index&gt;] = &lt;value&gt;</strong>. This assignment works the same as it does for core type variables.</p>
			<p>In real-world code, you often need to modify the data in your collections after it has been defined based on inputs or logic.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor124"/>Exercise 4.05: Writing to an Array</h2>
			<p>In this exercise, we'll define an array and initialize it with some words. Then, we'll make some changes to the words. Finally, we'll read the words out to form a message and print it. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create a function that defines an array with our words. The order of the words is important:<p class="source-code">func message() string {</p><p class="source-code">  arr := [4]string{"ready", "Get", "Go", "to"}</p></li>
				<li>We'll change some of the words in the array by assigning new values using an array index. The order this is done in doesn't matter:<p class="source-code">  arr[1] = "It's"</p><p class="source-code">  arr[0] = "time"</p></li>
				<li>Now, create a message by joining the words in a specific order and return it:<p class="source-code">  return fmt.Sprintln(arr[1], arr[0], arr[3], arr[2])</p><p class="source-code">}</p></li>
				<li>Create our <strong class="source-inline">main()</strong> function, call the <strong class="source-inline">message</strong> function, and print it to the console:<p class="source-code">func main() {</p><p class="source-code">  fmt.Print(message())</p><p class="source-code">}</p></li>
				<li>Save and run the code:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p><p class="source-code">It's time to Go</p></li>
			</ol>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor125"/>Looping an Array </h2>
			<p>The most common way you'll work with arrays is by using them in loops. Due to the way array's indexes works, they are easy to loop over. The index always starts at 0, there are no gaps, and the last element is the array's length, minus 1.</p>
			<p>Because of this, it's also common to use a loop where we create a variable to represent the index and increment it manually. This type of loop is often called a <strong class="source-inline">for i</strong> loop since <strong class="source-inline">i</strong> is the name that's given to the index variable.</p>
			<p>As you'll remember from the previous chapter, the <strong class="source-inline">for</strong> loop has three possible parts: the logic that can run before the loop, the logic that runs on each loop interaction to check whether the loop should continue, and the logic that runs at the end of each loop iteration. A <strong class="source-inline">for i</strong> loop looks like <strong class="source-inline">i := 0; i &lt; len(arr); i++ {</strong>. What happens is that we define <strong class="source-inline">i</strong> to be zero, which also means <strong class="source-inline">i</strong> only exists in the scope of the loop. Then, <strong class="source-inline">i</strong> is checked on the loop's iteration to ensure it's less than the length of the array. We check that it's less than the length of the array since the length is always 1 more than the last index key. Lastly, we increment <strong class="source-inline">i</strong> by 1 on each loop to let us step over each element in the array, one by one.</p>
			<p>When it comes to the length of an array, it can be tempting to hardcode the value of the last index instead of using <strong class="source-inline">len</strong> since you know the length of your array is always the same. Hardcoding length is a bad idea. Hardcoding would make your code harder to maintain. It's common for your data to change and evolve. If you ever need to come back and change the size of an array, having hardcoded array lengths introduces hard-to-find bugs and even runtime panics.</p>
			<p>Using loops with arrays allows you to repeat the same logic for every element, that is, validating the data, modifying the data, or outputting the data without having to duplicate the same code for multiple variables.</p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor126"/>Exercise 4.06: Looping Over an Array Using a "for i" Loop </h2>
			<p>In this exercise, we'll define an array and initialize it with some numbers. We'll loop over the numbers and do an operation on each one, putting the result in a message. Then, we'll return the message and print it. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create a function. We'll define the array with the data and a <strong class="source-inline">m</strong> variable before the loop:<p class="source-code">func message() string {</p><p class="source-code">  m := ""</p><p class="source-code">  arr := [4]int{1,2,3,4}</p></li>
				<li>Define the start of the loop. This manages the index and the loop:<p class="source-code">  <strong class="bold">for i</strong> := 0; i &lt; len(arr); i++ {</p></li>
				<li>Then, write the body of the loop, which does an operation on each element of the array and adds it to the message:<p class="source-code">  arr[i] = arr[i] * arr[i]</p><p class="source-code">  m += fmt.Sprintf("%v: %v\n", i, arr[i])</p></li>
				<li>Now, close the loop, return the message, and close the function:<p class="source-code">  }</p><p class="source-code">  return m</p><p class="source-code">}</p></li>
				<li>Create our <strong class="source-inline">main</strong> function, call the <strong class="source-inline">message</strong> function, and print it to the console:<p class="source-code">func main() {</p><p class="source-code">  fmt.Print(message())</p><p class="source-code">}</p></li>
				<li>Save this code. Then, from the new folder, run the code:<p class="source-code">go run .</p><p>Running the preceding code produces the following output after looping over the array using the <strong class="source-inline">for i</strong> loop:</p><p class="source-code">0: 1</p><p class="source-code">1: 4</p><p class="source-code">2: 9</p><p class="source-code">3: 16</p></li>
			</ol>
			<p>The <strong class="source-inline">for i</strong> loop is very common, so pay close attention to <em class="italic">step 4</em>, where we defined the loop, and be sure to understand what each of the three parts is doing.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="bold">Using len in a loop</strong>: In other languages, it's not efficient to count the number of elements on each iteration of a loop. In Go, it's okay. The Go runtime tracks the length of the array internally, so it doesn't count the items when you call <strong class="source-inline">len</strong>. This feature is also true for the other collection types, that is, slice and map.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor127"/>Modifying the Contents of an Array in a Loop</h2>
			<p>In addition to reading from an array in a loop, you can also change the contents of the array in a loop. Working with the data in each element works like working with variables. You use the same <strong class="source-inline">for i</strong> loops too. </p>
			<p>Just like reading data from arrays, being able to change data in collections reduces the amount of code you need to write if each element was a standalone variable.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor128"/>Exercise 4.07: Modifying the Contents of an Array in a Loop</h2>
			<p>In this exercise, we're going to define an empty array, fill it with data, and then modify that data. Finally, we'll print the filled and modified array to the console. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create a function that fills an array with numbers from 1 to 10:<p class="source-code">func fillArray(arr [10]int) [10]int {</p><p class="source-code">  for i := 0; i &lt; len(arr); i++ {</p><p class="source-code">  arr[i] = i + 1</p><p class="source-code">  }</p><p class="source-code">  return arr</p><p class="source-code">}</p></li>
				<li>Create a function that multiples the number from an array by itself and then sets the result back to the array:<p class="source-code">func opArray(arr [10]int) [10]int {</p><p class="source-code">  for i := 0; i &lt; len(arr); i++ {</p><p class="source-code">    arr[i] = arr[i] * arr[i]</p><p class="source-code">  }</p><p class="source-code">  return arr</p><p class="source-code">}</p></li>
				<li>In our <strong class="source-inline">main()</strong> function, we need to define our empty array, fill it, modify it, and then print its contents to the console:<p class="source-code">func main() {</p><p class="source-code">  var arr [10]int</p><p class="source-code">  arr = fillArray(arr)</p><p class="source-code">  arr = opArray(arr)</p><p class="source-code">  fmt.Println(arr)</p><p class="source-code">}</p></li>
				<li>Save this code. Then, from the new folder, run the code:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p><p class="source-code">[1 4 9 16 25 36 49 64 81 100]</p></li>
			</ol>
			<p>Working with data in arrays is simple once you've understood how to use them in a <strong class="source-inline">for i</strong> array. One nice thing about working with arrays over the other collections if their fixed length. With arrays, it's not possible to accidentally change the size of the array and end up in an infinite loop, which is a loop that can't end and results in software that runs forever while using lots of resources. </p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor129"/>Activity 4.01: Filling an Array</h2>
			<p>In this activity, we're going to define an array and fill it using a for-i loop. The following are the steps for this activity:</p>
			<ol>
				<li value="1">Create a new Go app.</li>
				<li>Define an array with 10 elements.</li>
				<li>Use a for-i loop to fill that array with the numbers 1 through 10.</li>
				<li>Use <strong class="source-inline">fmt.Println</strong> to print the array to the console.<p>The expected output is as follows:</p><p class="source-code">[1 2 3 4 5 6 7 8 9 10]</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 696</p></li>
			</ol>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor130"/>Slice</h1>
			<p>Arrays are great, but their rigidity around size can cause issues. If you wanted to create a function that accepted an array and sorted the data in it, it could only work for one size of array. That requires you to create a function for each size of array. This strictness around size makes working with arrays feel like a hassle and unengaging. The flip side of arrays is that they are an efficient way of managing sorted collections of data. Wouldn't it be great if there were a way to get the efficiency of arrays but with more flexibility? Go gives you this in the form of slices.</p>
			<p>A slice is a thin layer around arrays that let you have a sorted numeric indexed collection without you having to worry about the size. Underneath the thin layer is still a Go array, but Go manages all the details, such as how big an array to use, for you. You use a slice just like you would an array; it only holds values of one type, you can read and write to each element using <strong class="source-inline">[</strong> and <strong class="source-inline">]</strong>, and they are easy to loop overusing <strong class="source-inline">for i</strong> loops. </p>
			<p>The other thing a slice can do is be easily expanded using the built-in <strong class="source-inline">append</strong> function. This function accepts your slice and the values you'd like to add and returns a new slice with everything merged. It's common to start with an empty slice and expand it as needed.</p>
			<p>Since a slice is a thin layer around an array, this means it's not a true type like an array. You need to understand how Go uses the hidden array behind the slice. If you don't, it'll lead to subtle and difficult-to-debug errors.</p>
			<p>In real-world code, you should be using slices as your go-to for all sorted collections. You'll be more productive because you won't need to write as much code as you would with an array. Most code you'll see in real-world projects use lots of slices and rarely use arrays. Arrays are only used when the size needs to be exactly a certain length, and even then, slices get used most of the time as they can be passed around the code more easily.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor131"/>Exercise 4.08: Working with Slices</h2>
			<p>In this exercise, we'll show you how flexible slices are by reading some data from a slice, passing a slice to a function, looping over a slice, reading values from a slice, and appending values to the end of a slice. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "os"</p><p class="source-code">)</p></li>
				<li>Create a function that takes an <strong class="source-inline">int</strong> argument and returns a string slice:<p class="source-code">func getPassedArgs(minArgs int) []string {</p></li>
				<li>In the function's body, check if we have the correct number of arguments being passed in through the command line. If not, we exit the program with an error. All the arguments that are passed to Go are placed in <strong class="source-inline">os.Args</strong>, which is a slice of strings:<p class="source-code">  if len(os.Args) &lt; minArgs {</p><p class="source-code">    fmt.Printf("At least %v arguments are needed\n", minArgs)</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>The first element of the slice is how the code is called and not an argument, so we'll remove that:<p class="source-code">  var args []string</p><p class="source-code">  for i := 1; i &lt; len(os.Args); i++ {</p><p class="source-code">    args = append(args, os.Args[i])</p><p class="source-code">  }</p></li>
				<li>Then, we'll return the arguments:<p class="source-code">  return args</p><p class="source-code">}</p></li>
				<li>Now, create a function that loops over a slice and finds the longest string. When two words are of the same length, the first word is returned:<p class="source-code">func findLongest(args []string) string {</p><p class="source-code">  var longest string</p><p class="source-code">  for i := 0; i &lt; len(args); i++ {</p><p class="source-code">    if len(args[i]) &gt; len(longest) {</p><p class="source-code">      longest = args[i]</p><p class="source-code">  }</p><p class="source-code">  }</p><p class="source-code">  return longest</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, we call the functions and check for errors:<p class="source-code">func main() {</p><p class="source-code">  if longest := findLongest(getPassedArgs(3)); len(longest) &gt; 0 {</p><p class="source-code">    fmt.Println("The longest word passed was:", longest)</p><p class="source-code">  } else {</p><p class="source-code">    fmt.Println("There was an error")</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder it's saved in, run the code using the following command:<p class="source-code">go run . Get ready to Go</p><p>Running the preceding code produces the following output:</p><p class="source-code">The longest word passed was: ready</p></li>
			</ol>
			<p>In this exercise, we were able to see how flexible slices are and, at the same time, how they work just like arrays. This way of working with slices is another reason why Go has the feel of a dynamic language.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor132"/>Activity 4.02: Printing a User's Name Based on User Input</h2>
			<p>It's now your turn to work with maps. We're going to define a map and create logic to print the data in the map based on the key that's passed to your app. The following are the steps for this activity:</p>
			<ol>
				<li value="1">Create a new Go app.</li>
				<li>Define a <strong class="source-inline">map</strong> with the following key-value pairs:<p>Key: 305, Value: Sue</p><p>Key: 204, Value: Bob</p><p>Key: 631, Value: Jake</p><p>Key: 073, Value: Tracy</p></li>
				<li>Using <strong class="source-inline">os.Args</strong>, read a key that's been passed in and print the corresponding name; for instance, <strong class="source-inline">go run . 073</strong>.</li>
				<li>Correctly handle when no argument gets passed or if the passed argument doesn't match a value in the <strong class="source-inline">map</strong>.</li>
				<li>Print a message to the user with the name in the value.<p>The expected output is as follows:</p><p class="source-code">Hi, Tracy</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 697</p></li>
			</ol>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor133"/>Appending Multiple Items to a Slice</h2>
			<p>The built-in <strong class="source-inline">append</strong> function can add more than one value to a slice. You can add as many parameters to <strong class="source-inline">append</strong> as you need since the last parameter is variadic. Since it's variadic, this means that you can also use the <strong class="source-inline">...</strong> notation to use a slice as the variadic parameter, allowing you to pass a dynamic number of parameters to <strong class="source-inline">append</strong>.</p>
			<p>Being able to pass more than one parameter to <strong class="source-inline">append</strong> comes up all the time in real-world code, and having it keeps Go code compact by not requiring multiple calls or loops to add multiple values. </p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor134"/>Exercise 4.09: Appending Multiple Items to a Slice</h2>
			<p>In this exercise, we'll use the variadic parameter of <strong class="source-inline">append</strong> to add multiple values in the form of predefined data to a slice. Then, we'll add a dynamic amount of data based on user input to the same slice. Let's get started: </p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "os"</p><p class="source-code">)</p></li>
				<li>Create a function to safely grab user input:<p class="source-code">func getPassedArgs() []string {</p><p class="source-code">  var args []string</p><p class="source-code">  for i := 1; i &lt; len(os.Args); i++ {</p><p class="source-code">    args = append(args, os.Args[i])</p><p class="source-code">  }</p><p class="source-code">  return args</p><p class="source-code">}</p></li>
				<li>Create a function that accepts a slice of strings as a parameter and returns a slice of strings. Then, define a slice of strings variable:<p class="source-code">func getLocals(extraLocals []string) []string {</p><p class="source-code">  var locales []string</p></li>
				<li>Add multiple strings to the slice using <strong class="source-inline">append</strong>:<p class="source-code">  locales = append(locales, "en_US", "fr_FR")</p></li>
				<li>Add more data from the parameter:<p class="source-code">  locales = append(locales, extraLocals...)</p></li>
				<li>Return the variable and close the function definition:<p class="source-code">  return locales</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, get the user input, pass it to our function, and then print the result:<p class="source-code">func main() {</p><p class="source-code">  locales := getLocals(getPassedArgs())</p><p class="source-code">  fmt.Println("Locales to use:", locales)</p><p class="source-code">}</p></li>
				<li> Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run . fr_CN en_AU</p><p>Running the preceding code produces the following output:</p><p class="source-code">Locales to use: [en_US fr_FR fr_CN en_AU]</p></li>
			</ol>
			<p>In this exercise, we used two methods of adding multiple values to a slice. You would also use this technique if you needed to join two slices together.</p>
			<p>While exploding a slice like this to add it to another slice may seem inefficient, the Go runtime can spot when you're doing an explode in an append and optimizes the call in the background to ensure no resources get wasted.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor135"/>Activity 4.03: Creating a Locale Checker</h2>
			<p>In this activity, we're going to create a locale validator. A locale is an internationalization and localization concept that is a combination of both a language and a country or region. We'll create a struct that represents a locale. After, we're going to define a list of locales our code supports. Then, we'll read in some locale code from the command line and print out whether our code accepts that locale or not.</p>
			<p>Here are the steps for this activity:</p>
			<ol>
				<li value="1">Create a new Go app.</li>
				<li>Define a struct with a field for language and a separate field for country or region.</li>
				<li>Create a collection to hold the local definitions for at least five locales, for instance, "en_US", "en_CN", "fr_CN", "fr_FR", and "ru_RU".</li>
				<li>Read in the local from the command line, for example, using <strong class="source-inline">os.Args</strong>. Be sure to have error checking and validation working.</li>
				<li>Load the passed locale string into a new locale struct.</li>
				<li>Use that struct to check whether the passed struct is supported.</li>
				<li>Print a message to the console stating whether the locale is supported or not.<p>The expected output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/B14177_04_04.jpg" alt="Figure 4.4: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.4: Expected output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 698</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor136"/>Creating Slices from Slices and Arrays</h2>
			<p>By using a similar notation to accessing a single element in an array or slice, you can create new slices derived from the contents of arrays and slices. The most common notation is <strong class="source-inline">[&lt;low&gt;:&lt;high&gt;]</strong>. This notation tells Go to create a new slice with the same value type as the source slice or array and to populate the new slice with values by starting at the low index and then going up to but not including the high index. Low and high are optional. If you omitted low, then Go defaults to the first element in the source. If you omit high, then it goes all the way to the last value. It's possible to skip both, and if you do, then the new slice has all the values from the source.</p>
			<p>When you create new slices this way, Go doesn't copy the values. If the source is an array, then that source array is the hidden array for the new slice. If the source is a slice, then the hidden array for the new slice is the same hidden array the source slice uses. </p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor137"/>Exercise 4.10: Creating Slices from a Slice</h2>
			<p>In this exercise, we'll use the slice range notation to create slices with a variety of initial values. Commonly, in real-world code, you need to work with only a small part of a slice or array. The <strong class="source-inline">range</strong> notation is a quick and straightforward way of getting only the data you need. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create a function and define a slice with nine <strong class="source-inline">int</strong> values:<p class="source-code">func message() string {</p><p class="source-code">  s := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}</p></li>
				<li>We'll extract the first value, first directly as an int, then as a slice using both low and high, and finally using just high and skipping low. We'll write the values to a message string:<p class="source-code">  m := fmt.Sprintln("First   :", s[0], s[0:1], s[:1])</p></li>
				<li>Now, we'll get the last element. To get the int, we'll use the length and subtract 1 from the index. We use that same logic when setting the low for the range notation. For high, we can use the length of the slice. Finally, we can see we can skip high and get the same result:<p class="source-code">  m += fmt.Sprintln("Last  :", s[len(s)-1], s[len(s)-1:len(s)], s[len(s)-1:])</p></li>
				<li>Now, let's get the first five values and add them to the message:<p class="source-code">  m += fmt.Sprintln("First 5 :", s[:5])</p></li>
				<li>Next, we'll get the last four values and add them to the message as well:<p class="source-code">  m += fmt.Sprintln("Last 4  :", s[5:])</p></li>
				<li>Finally, we'll extract five values from the middle of the slice and get them in the message too:<p class="source-code">  m += fmt.Sprintln("Middle 5:", s[2:7])</p></li>
				<li>Then, we'll return the message and close the function:<p class="source-code">  return m</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">main</strong>, we'll print the message out:<p class="source-code">func main() {</p><p class="source-code">  fmt.Print(message())</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B14177_04_05.jpg" alt="Figure 4.5: Output after creating slices from a slice&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.5: Output after creating slices from a slice</p>
			<p>In this exercise, we tried out a few ways to create slices from another slice. You can also use these same techniques on an array as the source. We saw that both the start and stop indexes are optional. If you don't have a start index, it'll start at the beginning of the source slice or array. If you don't have the stop index, then it'll stop at the end of the array. If you skip both the start and stop indexes, it'll make a copy of the slice or array. This trick is useful for turning an array into a slice but not helpful for copying slices because the two slices share the same hidden array.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor138"/>Understanding Slice Internals</h2>
			<p>Slices are great and should be your go-to when you need an ordered list, but if you don't know how they work under the hood, they cause hard-to-spot bugs.</p>
			<p>An array is a value type that's similar to a string or an <strong class="source-inline">int</strong>. Value types can be copied and compared to themselves. These value types, once copied, are not connected to their source values. Slices don't work like value types; they work more like pointers, but they are also not pointers.</p>
			<p>The key to staying safe with a slice is to understand that there is a hidden array that stores the values and that making changes to the slice may or may not require that hidden array to be replaced with a bigger one. The fact that the management of the hidden array happens in the background is what makes it hard to reason well about what's going on with your slices.</p>
			<p>Slices have three hidden properties: length, a pointer to the hidden array, and where in the hidden array its starting point is. When you append to a slice, one or all of these properties get updated. Which properties get updated depends on whether the hidden array is full or not.</p>
			<p>The size of the hidden array and the size of the slice are not always the same. The size of the slice is its length, which we can find out by using the <strong class="source-inline">len</strong> built-in function. The size of the hidden array is the capacity of the slice. There is also a built-in function that tells you the capacity of a slice, that is, <strong class="source-inline">cap</strong>. When you add a new value to a slice using <strong class="source-inline">append</strong>, one of two things happens: if the slice has extra capacity, that is, the hidden array is not full yet, it adds the value to the hidden array and then updates the slices length property. If the hidden array is full, Go creates a new, larger, array. Go then copies all the values from the old array into the new array and adds the new value too. Then, Go updates the slice from pointing to the old array to the new array and updates the length of the slice and possibly its starting point.</p>
			<p>The starting point only comes into play if the slice is a subset of values from an array or a slice not starting at the first element, for example, in our example where we got the last five elements of a slice. The rest of the time, it'll be the first element in the hidden array.</p>
			<p>It's possible to control the size of the hidden array when you define a slice. Go's built-in <strong class="source-inline">make</strong> function allows you to set the length and capacity of a slice when creating it. The syntax looks like <strong class="source-inline">make(&lt;sliceType&gt;, &lt;length&gt;, &lt;capacity&gt;)</strong>. When creating a slice using <strong class="source-inline">make</strong>, the capacity is optional, but length is required.</p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor139"/>Exercise 4.11: Using make to Control the Capacity of a Slice</h2>
			<p>In this exercise, using the <strong class="source-inline">make</strong> function, we'll create some slices and display their length and capacity. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create a function that returns three <strong class="source-inline">int</strong> slices:<p class="source-code">func genSlices() ([]int, []int, []int) {</p></li>
				<li>Define a slice using the <strong class="source-inline">var</strong> notation:<p class="source-code">  var s1 []int</p></li>
				<li>Define a slice using make and set only the length:<p class="source-code">  s2 := make([]int, 10)</p></li>
				<li>Define a slice that uses both the length and capacity of the slices:<p class="source-code">  s3 := make([]int, 10, 50)</p><p>Return the three slices and close the function definition:</p><p class="source-code">  return s1, s2, s3</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, call the function we created and capture the returned values. For each slice, print its length and capacity to the console:<p class="source-code">func main() {</p><p class="source-code">  s1, s2, s3 := genSlices()</p><p class="source-code">  fmt.Printf("s1: len = %v cap = %v\n", len(s1), cap(s1))</p><p class="source-code">  fmt.Printf("s2: len = %v cap = %v\n", len(s2), cap(s2))</p><p class="source-code">  fmt.Printf("s3: len = %v cap = %v\n", len(s3), cap(s3))</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B14177_04_06.jpg" alt="Figure 4.6: Output displaying slices&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.6: Output displaying slices</p>
			<p>In this exercise, we used <strong class="source-inline">make</strong>, <strong class="source-inline">len</strong>, and <strong class="source-inline">cap</strong> to control and display the length and capacity of a slice when defining one. </p>
			<p>If you know how big a slice is, you'll typically need for an operation for setting the capacity, which can be a performance boost as Go has to do less work managing the hidden array.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor140"/>Background Behavior of Slices</h2>
			<p>Due to the complexity of what a slice is and how it works, you can't compare slices to one another. If you try, Go gives you an error. You can compare a slice to nil, but that's it. </p>
			<p>A slice is not a value, and it's not a pointer, so what is it? A slice is a special construct in Go. A slice doesn't store its own values directly. In the background, it's using an array that you can't access directly. What a slice does store is a pointer to that hidden array, its own starting point in that array, how long the slice is, and what the capacity of the slice is. These values provide slices with a window for the hidden array. The window can be the whole hidden array or just a smaller portion of it. The pointer to the hidden array can be shared by more than one slice. This pointer sharing can result in multiple slices that can share the same hidden array, even though not all the slides contain the same data. This means that one of the slices can have more of the data than the other slices.</p>
			<p>When a slice needs to grow beyond its hidden array, it creates a new bigger array and copies the contents from the old array to the new one and points the slice at the new array. This array swap is why our preceding slices became disconnected. At first, they were pointing to the same hidden array, but when we grow the first slice, the array it's pointing to changes. This change means that changes to the grown slice no longer affect the other slices since they are still pointing to the old, smaller, array.</p>
			<p>If you need to make a copy of a slice and need to be sure they are not connected, you have a few choices. You can use <strong class="source-inline">append</strong> to copy the contents of the source slice into another array or use the built-in <strong class="source-inline">copy</strong> function. When using <strong class="source-inline">copy</strong>, Go won't change the size of the destination slice, so be sure it has enough room for all the elements you want to copy. </p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor141"/>Exercise 4.12: Controlling Internal Slice Behavior </h2>
			<p>In this exercise, we're going to explore five different ways to copy data from slice to slice and how that has an impact on a slice's internal behavior. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create a function that returns three ints:<p class="source-code">func linked() (int, int, int) {</p></li>
				<li>Define an int slice, initialized with some data:<p class="source-code">  s1 := []int{1, 2, 3, 4, 5}</p></li>
				<li>Then, we'll make a simple variable copy of that slice:<p class="source-code">  s2 := s1</p></li>
				<li>Create a new slice by copying all the values from the first slice as part of a slice range operation:<p class="source-code">  s3 := s1[:]</p></li>
				<li>Change some data in the first slice. Later, we'll see how this affects the second and third slice:<p class="source-code">  s1[3] = 99</p></li>
				<li>Return the same index for each slice and close the function definition:<p class="source-code">  return s1[3], s2[3], s3[3]</p><p class="source-code">}</p></li>
				<li>Create a function that will return two ints:<p class="source-code">func noLink() (int, int) {</p></li>
				<li>Define a slice with some data and do a simple copy again:<p class="source-code">  s1 := []int{1, 2, 3, 4, 5}</p><p class="source-code">  s2 := s1</p></li>
				<li>This time, we'll append to the first slice before we do anything else. This operation changes the length and capacity of the slice:<p class="source-code">  s1 = append(s1, 6)</p></li>
				<li>Then, we'll change the first slice, return the same indexes from the two slices, and close the function:<p class="source-code">  s1[3] = 99</p><p class="source-code">  return s1[3], s2[3]</p><p class="source-code">}</p></li>
				<li>In our next function, we'll be returning two ints:<p class="source-code">func capLinked() (int, int) {</p></li>
				<li>We'll define our first slice using make this time. When doing this, we'll be setting a capacity that's larger than its length:<p class="source-code">  s1 := make([]int, 5, 10)</p></li>
				<li>Let's fill the first array with the same data as before:<p class="source-code">  s1[0], s1[1], s1[2], s1[3], s1[4] = 1, 2, 3, 4, 5</p></li>
				<li>Now, we'll create a new slice by copying the first slice, like we did previously:<p class="source-code">  s2 := s1</p></li>
				<li>We'll append a new value to the first slice, which changes its length but not its capacity:<p class="source-code">  s1 = append(s1, 6)</p></li>
				<li>Then, we'll change the first slice, return the same indexes from the two slices, and close the function:<p class="source-code">  s1[3] = 99</p><p class="source-code">  return s1[3], s2[3]</p><p class="source-code">}</p></li>
				<li>In this function, we'll use make again to set a capacity, but we'll use <strong class="source-inline">append</strong> to add elements that will go beyond that capacity:<p class="source-code">func capNoLink() (int, int) {</p><p class="source-code">  s1 := make([]int, 5, 10)</p><p class="source-code">  s1[0], s1[1], s1[2], s1[3], s1[4] = 1, 2, 3, 4, 5</p><p class="source-code">  s2 := s1</p><p class="source-code">  s1 = append(s1, []int{10: 11}...)</p><p class="source-code">  s1[3] = 99</p><p class="source-code">  return s1[3], s2[3]</p><p class="source-code">}</p></li>
				<li>In the next function, we'll use <strong class="source-inline">copy</strong> to copy the elements from the first slice to the second slice. Copy returns how many elements were copied from one slice to another, so we'll return that too:<p class="source-code">func copyNoLink() (int, int, int) {</p><p class="source-code">  s1 := []int{1, 2, 3, 4, 5}</p><p class="source-code">  s2 := make([]int, len(s1))</p><p class="source-code">  copied := copy(s2, s1)</p><p class="source-code">  s1[3] = 99</p><p class="source-code">  return s1[3], s2[3], copied</p><p class="source-code">}</p></li>
				<li>In the final function, we'll use <strong class="source-inline">append</strong> to copy the value into the second slice. Using <strong class="source-inline">append</strong> in this way results in the values being copied into a new hidden array:<p class="source-code">func appendNoLink() (int, int) {</p><p class="source-code">  s1 := []int{1, 2, 3, 4, 5}</p><p class="source-code">  s2 := append([]int{}, s1...)</p><p class="source-code">  s1[3] = 99</p><p class="source-code">  return s1[3], s2[3]</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">main</strong>, we'll print out all the data we returned and print it to the console:<p class="source-code">func main() {</p><p class="source-code">  l1, l2, l3 := linked()</p><p class="source-code">  fmt.Println("Linked    :", l1, l2, l3)</p><p class="source-code">  nl1, nl2 := noLink()</p><p class="source-code">  fmt.Println("No Link   :", nl1, nl2)</p><p class="source-code">  cl1, cl2 := capLinked()</p><p class="source-code">  fmt.Println("Cap Link  :", cl1, cl2)</p><p class="source-code">  cnl1, cnl2 := capNoLink()</p><p class="source-code">  fmt.Println("Cap No Link :", cnl1, cnl2)</p><p class="source-code">  copy1, copy2, copied := copyNoLink()</p><p class="source-code">  fmt.Print("Copy No Link: ", copy1, copy2)</p><p class="source-code">  fmt.Printf(" (Number of elements copied %v)\n", copied)</p><p class="source-code">  a1, a2 := appendNoLink()</p><p class="source-code">  fmt.Println("Append No Link:", a1, a2)</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B14177_04_07.jpg" alt="Figure 4.7: Output displaying data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.7: Output displaying data</p>
			<p>In this exercise, we stepped through five different scenarios where we made copies of slice data. In the <strong class="source-inline">Linked</strong> scenario, we made a simple copy of the first slice and then a range copy of it. While the slices themselves are distinct and are no longer the same slices, in reality, it doesn't make a difference to the data they hold. Each of the slices pointed to the same hidden array, so when we made a change to the first slice, it affected all of the slices.</p>
			<p>In the <strong class="source-inline">No Link</strong> scenario, the setup was the same for the first and second slice, but before we made a change to the first slice, we appended a value to it. When we appended this value to it, in the background, Go needed to create a new array to hold the now large number of values. Since we were appending to the first slice, its pointer was to look at the new, bigger slice. The second slice doesn't get its pointer updates. That's why, when the first slice had its value change, the second slice wasn't affected. The second slice isn't pointing to the same hidden array anymore, meaning they are not linked.</p>
			<p>For the <strong class="source-inline">Cap Link</strong> scenario, the first slice was defined using make and with an oversized capacity. This extra capacity meant that when the first slice had a value appended to it, there was already extra room in the hidden array. This extra capacity means there's no need to replace the hidden array. The effect was that when we updated the value on the first slice, it and the second slice were still pointing to the same hidden array, meaning the change affects both.</p>
			<p>In the <strong class="source-inline">Cap No Link</strong> scenario, the setup was the same as the previous scenario, but when we appended values, we appended more values than there was available capacity. Even though there was extra capacity, there was not enough, and the hidden array in the first slice got replaced. The result was that the link between the two slices broke.</p>
			<p>In <strong class="source-inline">Copy No Link</strong>, we used the built-in <strong class="source-inline">copy</strong> function to copy the value for us. While this does copy the values into a new hidden array, copy won't change the length of the slice. This fact means that the destination slice must be the correct length before you do the copy. You don't see copy much in real-world code; this could be because it's easy to misuse it.</p>
			<p>Lastly, with <strong class="source-inline">Append No Link</strong>, we use <strong class="source-inline">append</strong> to do something similar to <strong class="source-inline">copy</strong> but without having to worry about the length. This method is the most commonly seen in real-world code when you need to ensure you get a copy of the values that are not linked to the source. This is easy to understand since append gets used a lot and it's a one-line solution. There is one slightly more efficient solution that avoids the extra memory allocation of the empty slice in the first argument of append. You can reuse the first slice by creating a 0-capacity range copy of it. This alternative looks as follows:</p>
			<p class="source-code">  s1 := []int{1, 2, 3, 4, 5}</p>
			<p class="source-code">  s2 := append(s1[:0:0], s1...)</p>
			<p>Can you see something new here? This uses the seldom-used slice range notation of <strong class="source-inline">&lt;slice&gt;[&lt;low&gt;:&lt;high&gt;:&lt;capacity&gt;]</strong>. With the current Go compiler, this is the most memory-efficient way to copy a slice.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor142"/>Map Fundamentals</h2>
			<p>While arrays and slices are similar and can sometimes be interchangeable, Go's other collection type, map, is quite different and is not interchangeable with array and slice. Go's map type serves a different purpose.</p>
			<p>Go's map is a hashmap in computer science terms. The main difference between a map and the other collections types relates to its key. In an array or slice, the key is a placeholder, and it has no meaning of its own. It's only there to act as a counter and has no direct relationship with the value.</p>
			<p>With a map, the key is data – data that has a real relationship with the value. For example, you could have a collection of user account records in a map. The key would be the users' employee ID. An employee ID is real data and not just an arbitrary placeholder. If someone were to give you their employee ID, you'd be able to look up their account records without needing to loop over the data to find it. With a map, you can set, get, and delete data quickly.</p>
			<p>You can access the individual elements of a map in the same way as you do with a slice or array: using <strong class="source-inline">[</strong> and <strong class="source-inline">]</strong>. Maps can have any type that is directly comparable as a key, such as an int or a string. You can't compare slices, so they can't be keys. A map's value can be of any type, including pointers, slices, and maps.</p>
			<p>You shouldn't use a map as an ordered list. Even if you were to use an int for a map's keys, maps are not guaranteed to always start at index 0, and they are not guaranteed to not have any gaps in the keys. This feature could be an advantage, even if you did want int keys. If you had sparsely populated data, that is, values with gaps between keys, in a slice or array, it would contain lots of zero data. In a map, it would only contain the data you set.</p>
			<p>To define a map, you use the following notation: <strong class="source-inline">map[&lt;key_type&gt;]&lt;value_type&gt;</strong>. You can use <strong class="source-inline">make</strong> to create maps, but the arguments for <strong class="source-inline">make</strong> are different when using <strong class="source-inline">make</strong> to create a map. Go can't create keys for a map, so it's not possible to create a map of an arbitrary length like you can with a slice. You can suggest a capacity for the compiler to use for your map. Suggesting the capacity for a map is optional, and map can't be used with <strong class="source-inline">cap</strong> to check what its capacity is.</p>
			<p>Maps are like slices in that they are not a value and not a pointer. A map is a special construct in Go. You'll need to take the same care when copying the variable or the values. Since you can't control or check the capacity of a map, they are even more challenging when you want to know what's going to happen when you add elements.</p>
			<p>Since Go does not help you manage your keys with maps, this means you must specify keys when initializing a map with data. It's the same notation as the other collections, that is, <strong class="source-inline">map[&lt;key_type&gt;]&lt;value_type&gt;{&lt;key1&gt;: &lt;value&gt;, … &lt;keyN&gt;:, &lt;valueN&gt;}</strong>.</p>
			<p>Once defined, you can set values without needing to worry about the length of the map like you do with arrays and slices. Setting a value is just like the other collections, that is, <strong class="source-inline">&lt;map&gt;[&lt;key&gt;] = &lt;value&gt;</strong>. Something that you do need to do before setting the value of a map is to make sure you've initialized it first. If you try to set a value of an uninitialized map, it causes a runtime panic. To avoid this, it's good practice to avoid defining a map using <strong class="source-inline">var</strong>.  If you initialize the map with data or use <strong class="source-inline">make</strong> to create your maps, you won't have this problem. </p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor143"/>Exercise 4.13: Creating, Reading, and Writing a Map </h2>
			<p>In this exercise, we're going to define a map with some data and then add a new element to it. Finally, we'll print the map to the console. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create a function that returns a <strong class="source-inline">map</strong> with string keys and string values:<p class="source-code">func getUsers() map[string]string {</p></li>
				<li>Define a <strong class="source-inline">map</strong> with string keys and string values and then initialize it with some elements:<p class="source-code">  users := map[string]string{</p><p class="source-code">    "305": "Sue",</p><p class="source-code">    "204": "Bob",</p><p class="source-code">    "631": "Jake",</p><p class="source-code">  }</p></li>
				<li>Next, we'll add a new element to the <strong class="source-inline">map</strong>:<p class="source-code">  users["073"] = "Tracy"</p></li>
				<li>Return the <strong class="source-inline">map</strong> and close the function:<p class="source-code">  return users</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">main</strong> function, print the <strong class="source-inline">map</strong> to the console:<p class="source-code">func main() {</p><p class="source-code">  fmt.Println("Users:", getUsers())</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p><p class="source-code">Users: map[073:Tracy 204:Bob 305:Sue 631:Jake]</p></li>
			</ol>
			<p>In this exercise, we created a map, initialized it with data, and then added a new element. This exercise shows that working with maps is similar to working with arrays and slices. When you should use a map comes down to the kinds of data you'll store in it and if your access pattern needs access to individual items rather than a list of items. </p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor144"/>Reading from Maps</h2>
			<p>You won't always know whether a key exists in a map before needing to use it to get a value. When you're getting a value for a key that doesn't exist in a map, Go returns the zero value for the map's value type. Having logic that works with zero values is a valid way to program in Go, but that's not always possible. If you can't use zero value logic, maps can return an extra return value when you need it. The notation looks like <strong class="source-inline">&lt;value&gt;, &lt;exists_value&gt; := &lt;map&gt;[&lt;key&gt;]</strong>. Here, <strong class="source-inline">exists</strong> is a Boolean value that is true if a key exists in the map; otherwise, it's false. When looping over a map, you should use the <strong class="source-inline">range</strong> keyword. When looping over a map, never rely on the order of the items in it. Go doesn't guarantee the order of items in a map. To make sure no one replies on the order of the elements, Go purposely randomizes the order of them when you range over a map. If you did need to loop over the elements of your map in a specific order, you'd need to use an array or slice to assist you with that.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor145"/>Exercise 4.14: Reading from a Map</h2>
			<p>In this exercise, we're going to read from a map using direct access and a loop. We'll also check to see if a key exists in the map. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "os"</p><p class="source-code">)</p></li>
				<li>Create a function that returns a <strong class="source-inline">map</strong> with a string key and a string value:<p class="source-code">func getUsers() map[string]string {</p></li>
				<li>Define a <strong class="source-inline">map</strong> and initialize it with data. Then, return the <strong class="source-inline">map</strong> and close the function:<p class="source-code">  return map[string]string{</p><p class="source-code">  "305": "Sue",</p><p class="source-code">  "204": "Bob",</p><p class="source-code">  "631": "Jake",</p><p class="source-code">  "073": "Tracy",</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>In this function, we'll accept a string as input. The function will also return a string and a Boolean:<p class="source-code">func getUser(id string) (string, bool) {</p></li>
				<li>Get a copy of the <strong class="source-inline">users</strong> map from our earlier function:<p class="source-code">  users := getUsers()</p></li>
				<li>Get a value from the <strong class="source-inline">users</strong> maps using the passed in ID as the key. Capture both the value and the <strong class="source-inline">exists</strong> value:<p class="source-code">  user, exists := users[id]</p></li>
				<li>Return both values and close the function:<p class="source-code">  return user, exists</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">main</strong> function:<p class="source-code">func main() {</p></li>
				<li>Check that at least one argument gets passed in. If not, exit:<p class="source-code">  if len(os.Args) &lt; 2 {</p><p class="source-code">    fmt.Println("User ID not passed")</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>Capture the passed argument and call the get user function:<p class="source-code">  userID := os.Args[1]</p><p class="source-code">  name, exists := getUser(userID)</p></li>
				<li>If the key is not found, print a message, and then print all the users using a <strong class="source-inline">range</strong> loop. After that, exit:<p class="source-code">  if !exists {</p><p class="source-code">    fmt.Printf("Passed user ID (%v) not found.\nUsers:\n", userID)</p><p class="source-code">    for key, value := range getUsers() {</p><p class="source-code">      fmt.Println("  ID:", key, "Name:", value)</p><p class="source-code">    }</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>If everything is okay, print the name we found:<p class="source-code">  fmt.Println("Name:", name)</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run . 123</p></li>
				<li>Then, run the following command:<p class="source-code">go run . 305</p><p>Running the preceding code produces the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B14177_04_08.jpg" alt="Figure 4.8: Output displaying all the users and the name that was found&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.8: Output displaying all the users and the name that was found</p>
			<p>In this exercise, we learned how we can check to see if a key exists in a map. It may look a little strange coming from other languages that require you check for the existence of a key before getting the value, not after. This way of doing things does mean there is much less chance of runtime errors. If a zero value is not possible in your domain logic, then you can use that fact to check if a key exists.</p>
			<p>We used a <strong class="source-inline">range</strong> loop to print all the users in our map nicely. Your output is probably in a different order to the output shown in the preceding screenshot, which is due to Go randomizing the order of the elements in a map when you use <strong class="source-inline">range</strong>.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor146"/>Activity 4.04: Slicing the Week</h2>
			<p>In this activity, we're going to create a slice and initialize it with some data. Then, we're going to modify that slice using what we've learned about sub-slices. The following are the steps for this activity:</p>
			<ol>
				<li value="1">Create a new Go app.</li>
				<li>Create a slice and initialize it with the all the days of the week, starting on Monday and ending on Sunday.</li>
				<li>Change the slice using slice ranges and append it so that the week now starts on Sunday and ends on Saturday.</li>
				<li>Print the slice to the console.<p>The expected output is as follows:</p><p class="source-code">[Sunday Monday Tuesday Wednesday Thursday Friday Saturday]</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 700</p></li>
			</ol>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor147"/>Deleting Elements from a Map</h2>
			<p>If you need to remove an element from a map, you'll need to do something different than you would with an array or slice. In an array, you can't remove elements since the length's fixed; the best you can do is zero out the value. With a slice, you can zero out, but it's also possible to use a combination of a slice range and append to cut out one or more elements. With a map, you could zero the value out, but the element still exists, so it causes problems if you're checking whether a key exists in your logic. You can't use slice ranges on a map to cut elements out either.</p>
			<p>To remove an element, we need to use the built-in <strong class="source-inline">delete</strong> function. The function signature for <strong class="source-inline">delete</strong>, when used with maps, is <strong class="source-inline">delete(&lt;map&gt;, &lt;key&gt;)</strong>. The <strong class="source-inline">delete</strong> function doesn't return anything and if a key doesn't exist, nothing happens. </p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor148"/>Exercise 4.15: Deleting an Element from a Map</h2>
			<p>In this exercise, we'll define a map and then delete an element from it using user input. Then, we'll print the now possibly smaller map to the console. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "os"</p><p class="source-code">)</p></li>
				<li>We're going to define our <strong class="source-inline">users</strong> map in the package scope:<p class="source-code">var users = map[string]string{</p><p class="source-code">  "305": "Sue",</p><p class="source-code">  "204": "Bob",</p><p class="source-code">  "631": "Jake",</p><p class="source-code">  "073": "Tracy",</p><p class="source-code">}</p></li>
				<li>Create a function that deletes from the <strong class="source-inline">users</strong> map using a passed in string as the key:<p class="source-code">func deleteUser(id string){</p><p class="source-code">  delete(users, id)</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">main</strong>, we'll grab the passed in <strong class="source-inline">userID</strong> and print the <strong class="source-inline">users</strong> map to the console:<p class="source-code">func main() {</p><p class="source-code">  if len(os.Args) &lt; 2 {</p><p class="source-code">    fmt.Println("User ID not passed")</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p><p class="source-code">  userID := os.Args[1]</p><p class="source-code">  deleteUser(userID)</p><p class="source-code">  fmt.Println("Users:", users)</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run . 305</p><p>Running the preceding code produces the following output:</p><p class="source-code">Users: map[073:Tracy 204:Bob 631:Jake]</p></li>
			</ol>
			<p>In this exercise, we used the built-in <strong class="source-inline">delete</strong> function to totally remove an element from a map. This requirement is unique for maps; you can't use <strong class="source-inline">delete</strong> on arrays or slices. </p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor149"/>Activity 4.05: Removing an Element from a Slice</h2>
			<p>Go doesn't have anything built in to remove elements from a slice, but it's possible with the techniques you've learned. In this activity, we're going to set up a slice with some data and with one element to remove. Then, you need to work out how to do this. There are many ways to get this done, but can you work out the most compact way?</p>
			<p>Here are the steps for this activity:</p>
			<ol>
				<li value="1">Create a new Go app.</li>
				<li>Create a slice with the following elements in the following order:<p>Good</p><p>Good</p><p>Bad</p><p>Good</p><p>Good</p></li>
				<li>Write the code to remove the "Bad" element from the slice.</li>
				<li>Print the result to the console.<p>The following is the expected output:</p><p class="source-code">[Good Good Good Good]</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 701</p></li>
			</ol>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor150"/>Simple Custom Types</h1>
			<p>You can create custom types using Go's simple types as a starting point. The notation is <strong class="source-inline">type &lt;name&gt; &lt;type&gt;</strong>. If we were to create an ID type based on a string, this would look like <strong class="source-inline">type id string</strong>. The custom type acts the same as the type you based it on, including getting the same zero value and having the same abilities to compare with other values of the same type. A custom type is not compatible with its base type, but you can convert your custom type back into the type it's based on to allow for interaction.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor151"/>Exercise 4.16: Creating a Simple Custom Type</h2>
			<p>In this exercise, we'll define a map and then delete an element from it using user input. Then, we'll print the now possibly smaller map to the console. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Define a custom type called <strong class="source-inline">id</strong> based on the string type:<p class="source-code">type id string</p></li>
				<li>Create a function that returns three ids:<p class="source-code">func getIDs() (id, id, id) {</p></li>
				<li>For <strong class="source-inline">id1</strong>, we'll initialize it and leave at its zero value:<p class="source-code">  var id1 id</p></li>
				<li>For <strong class="source-inline">id2</strong>, we'll initialize it using a string literal:<p class="source-code">  var id2 id = "1234-5678"</p></li>
				<li>Finally, for <strong class="source-inline">id3</strong>, we'll initialize it to zero and then set a value separately:<p class="source-code">  var id3 id</p><p class="source-code">  id3 = "1234-5678"</p></li>
				<li>Now, return the ids and close the function:<p class="source-code">  return id1, id2, id3</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">main</strong>, call our function and do some comparisons:<p class="source-code">func main() {</p><p class="source-code">  id1, id2, id3 := getIDs()</p><p class="source-code">  fmt.Println("id1 == id2    :", id1 == id2)</p><p class="source-code">  fmt.Println("id2 == id3    :", id2 == id3)</p></li>
				<li>For this preceding comparison, we'll convert the id back into a string:<p class="source-code">  fmt.Println("id2 == \"1234-5678\":", string(id2) == "1234-5678")</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B14177_04_09.jpg" alt="Figure 4.9: Output after comparison&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.9: Output after comparison</p>
			<p>In this exercise, we created a custom type, set data on it, and then compared it with values of the same type and with its base type.</p>
			<p>Simple custom types are a foundation part of modeling the data problems you'll see in the real world. Having types designed to reflect the data you need to work with closely helps keep your code easy to understand and maintain.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor152"/>Structs</h1>
			<p>Collections are perfect for grouping values of the same type and purpose together. There is another way of grouping data together in Go for a different purpose. Often, a simple string, number, or Boolean doesn't fully capture the essence of the data you'll have. </p>
			<p>For example, for our user map, a user was represented by their unique ID and their first name. That is rarely going to be enough details to be able to work with user records. The data you could capture about a person is almost infinite, such as their given, middle, and family names. Their preferred prefix and suffix, their date of birth, their height, weight, or where they work can also be captured. It would be possible to store this data in multiple maps, all with the same key, but that is hard to work with and maintain. </p>
			<p>The ideal thing to do is collect all these different bits of data into a single data structure that you can design and control. That's what Go's struct type is: it's a custom type that you can name and specify the field properties and their types.</p>
			<p>The notation for structs looks as follows:</p>
			<p class="source-code">type &lt;name&gt; struct {</p>
			<p class="source-code">  &lt;fieldName1&gt; &lt;type&gt;</p>
			<p class="source-code">  &lt;fieldName2&gt; &lt;type&gt;</p>
			<p class="source-code">  …</p>
			<p class="source-code">  &lt;fieldNameN&gt; &lt;type&gt;</p>
			<p class="source-code">}</p>
			<p>Field names must be unique within a struct. You can use any type for a field, including pointers, collections, and other structs. </p>
			<p>You can access a field on a struct using the following notation: <strong class="source-inline">&lt;structValue&gt;.&lt;fieldName&gt;</strong>. To set a value, you use this notation: <strong class="source-inline">&lt;structValue&gt;.&lt;fieldName&gt; = &lt;value&gt;</strong>. To read a value you use the following notation: <strong class="source-inline">value = &lt;structValue&gt;.&lt;fieldName&gt;</strong>. </p>
			<p>Structs are the closest thing that Go has to what are called classes in other languages, but structs have purposely been kept stripped down by Go's designers. A key difference is that structs don't have any form of inheritance. The designers of Go feel that inheritance causes more problems than it solves in real-world code. </p>
			<p>Once you've defined your custom struct type, you can use it to create a value. You have several ways to create values from struct types. Let's take a look at them now.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor153"/>Exercise 4.17: Creating Struct Types and Values</h2>
			<p>In this exercise, we're going to define a user struct. We'll define some fields of different types. Then, we'll create some struct values using a few different methods. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>The first thing we'll do is define our struct type. You generally do this in the package scope. We need to give it a name that's unique at the package-level scope:<p class="source-code">type user struct {</p></li>
				<li>We'll add some fields of different types and then close the struct definition:<p class="source-code">  name  string</p><p class="source-code">  age   int</p><p class="source-code">  balance float64</p><p class="source-code">  member  bool</p><p class="source-code">}</p></li>
				<li>We'll create a function that returns a slice of our newly defined struct type:<p class="source-code">func getUsers() []user {</p></li>
				<li>Our first user is initialized using this key-value notation. This notation is the most common form to use when initializing structs:<p class="source-code">  u1 := user{</p><p class="source-code">  name:  "Tracy",</p><p class="source-code">  age:   51,</p><p class="source-code">  balance: 98.43,</p><p class="source-code">  member:  true,</p><p class="source-code">  }</p></li>
				<li>When using the key-value notation, the order of the fields doesn't matter and any you leave out will get a zero value for their type:<p class="source-code">  u2 := user{</p><p class="source-code">  age:  19,</p><p class="source-code">  name: "Nick",</p><p class="source-code">  }</p></li>
				<li>It's possible to initialize a struct with values only. If you do this, all the fields must be present, and their order must match how you defined them in the struct:<p class="source-code">  u3 := user{</p><p class="source-code">  "Bob",</p><p class="source-code">  25,</p><p class="source-code">  0,</p><p class="source-code">  false,</p><p class="source-code">  }</p></li>
				<li>This <strong class="source-inline">var</strong> notation will create a struct where all the fields have zero values:<p class="source-code">  var u4 user</p></li>
				<li>Now, we can set values on the fields using <strong class="source-inline">.</strong> and the field name:<p class="source-code">  u4.name = "Sue"</p><p class="source-code">  u4.age = 31</p><p class="source-code">  u4.member = true</p><p class="source-code">  u4.balance = 17.09</p></li>
				<li>Now, we will return the values wrapped in a slice and close the function:<p class="source-code">  return []user{u1, u2, u3, u4}</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">main</strong>, we'll get the slice of <strong class="source-inline">users</strong>, loop over it, and print it to the console:<p class="source-code">func main() {</p><p class="source-code">  users := getUsers()</p><p class="source-code">  for i := 0; i &lt; len(users); i++ {</p><p class="source-code">  fmt.Printf("%v: %#v\n", i, users[i])</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B14177_04_10.jpg" alt="Figure 4.10: Output as per the new struct&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.10: Output as per the new struct</p>
			<p>In this exercise, you defined a custom struct type that contained multiple fields, each of a different type. Then, we created values from that struct using a few different methods. Each of these methods is valid and is useful in different contexts.</p>
			<p>We defined the struct at the package scope, and while it's not typical, you can define struct types in the function scope too. If you do define a struct type in a function, it'll only be valid for use in that function. When defining a type at the package level, it's available for use throughout the package. </p>
			<p>It's also possible to define and initialize a struct at the same time. If you do this, you can't reuse the type, but it's still a useful technique. The notation looks as follows:</p>
			<p class="source-code">type &lt;name&gt; struct {</p>
			<p class="source-code">  &lt;fieldName1&gt; &lt;type&gt;</p>
			<p class="source-code">  &lt;fieldName2&gt; &lt;type&gt;</p>
			<p class="source-code">  …</p>
			<p class="source-code">  &lt;fieldNameN&gt; &lt;type&gt;</p>
			<p class="source-code">}{</p>
			<p class="source-code">  &lt;value1&gt;,</p>
			<p class="source-code">  &lt;value2&gt;,</p>
			<p class="source-code">  …</p>
			<p class="source-code">  &lt;valueN&gt;,</p>
			<p class="source-code">}</p>
			<p>You can also initialize using the key-value notation, but initializing with only the values is the most common when this is done. </p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor154"/>Comparing Structs to Each Other</h2>
			<p>If all of a struct's fields are comparable types, then the struct as a whole is also comparable. So, if your struct is made up of strings and ints, then you can compare whole structs to one another. If your struct has a slice in it, then you can't. Go is strongly typed, so you can only compare values of the same type, but with structs, there is a little bit of flexibility. If the struct was defined anonymously and it has the same structure as a named struct, then Go allows the comparison.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor155"/>Exercise 4.18: Comparing Structs to Each Other</h2>
			<p>In this exercise, we'll define a comparable struct and create a value with it. We'll also define and create values with anonymous structs that have the same structure as our named struct. Finally, we'll compare them and print the results to the console. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it:</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Let's define a simple, comparable struct:<p class="source-code">type point struct {</p><p class="source-code">  x int</p><p class="source-code">  y int</p><p class="source-code">}</p></li>
				<li>Now, we'll create a function that returns two Booleans:<p class="source-code">func compare() (bool, bool) {</p></li>
				<li>Create our first anonymous struct:<p class="source-code">  point1 := struct {</p><p class="source-code">    x int</p><p class="source-code">    y int</p><p class="source-code">  }{</p><p class="source-code">    10,</p><p class="source-code">    10,</p><p class="source-code">  }</p></li>
				<li>With the second anonymous struct, we're initializing it to zero and then changing the value after initialization:<p class="source-code">  point2 := struct {</p><p class="source-code">    x int</p><p class="source-code">    y int</p><p class="source-code">  }{}</p><p class="source-code">  point2.x = 10</p><p class="source-code">  point2.y = 5</p></li>
				<li>The final struct to create uses the named struct type we created previously:<p class="source-code">  point3 := point{10, 10}</p></li>
				<li>Compare them. Then, return and close the function:<p class="source-code">  return point1 == point2, point1 == point3</p><p class="source-code">}</p></li>
				<li>In main, we'll call our function and print the results:<p class="source-code">func main() {</p><p class="source-code">  a, b := compare()</p><p class="source-code">  fmt.Println("point1 == point2:", a)</p><p class="source-code">  fmt.Println("point1 == point3:", b)</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B14177_04_11.jpg" alt="Figure 4.11: Output comparing structs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.11: Output comparing structs</p>
			<p>In this exercise, we saw that we can work with anonymous struct values in the same way as named struct types, including comparing them. With named types, you can only compare structs of the same type. When you compare types in Go, Go compares all the fields to check for a match. Go is allowing a comparison of these anonymous structs to be made because the field names and types match. Go is a little flexible with comparing structs like this. </p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor156"/>Struct Composition Using Embedding</h2>
			<p>While inheritance is not possible with Go structs, the designers of Go did include an exciting alternative. The alternative is to embed types in struct types. Using embedding, you can add fields to a struct from other structs. This composition feature has the effect of letting you add to a struct using other structs as components. Embedding is different than having a field that is a struct type. When you embed, the fields from the embedded struct get promoted. Once promoted, a field acts as if it's defined on the target struct.</p>
			<p>To embed a struct, you add it like you would a field, but you don't specify a name. To do this, you add a struct type name to another struct without giving it a field name, which looks like this:</p>
			<p class="source-code">type &lt;name&gt; struct {</p>
			<p class="source-code">  &lt;Type&gt;</p>
			<p class="source-code">}</p>
			<p>Though not common, you can embed any other type into structs. There is nothing to promote, so to access the embedded type, you access it using the type's name, for example, <strong class="source-inline">&lt;structValue&gt;.&lt;type&gt;</strong>. This way of accessing the embedded types by their type name is also true for structs. This means there is two valid ways to work with an embedded struct's fields: <strong class="source-inline">&lt;structValue&gt;.&lt;fieldName&gt;</strong> or <strong class="source-inline">&lt;structValue&gt;.&lt;type&gt;.&lt;fieldName&gt;</strong>. This ability to access the type by its name also means that the type's names must be unique between the embedded types and the root field names. When embedding pointer types, the type's name is the type without the pointer notation, so the name <strong class="source-inline">*&lt;type&gt;</strong> becomes <strong class="source-inline">&lt;type&gt;</strong>. The field is still a pointer, and only the name is different.</p>
			<p>When it comes to promotion, if you were to have any overlap with your struct's field names, Go allows you to embed, but the promotion of the overlapping field doesn't happen. You can still access the field by going through the type name path.</p>
			<p>You can't use promotion when initializing structs with embedded types. To initialize the data, you must use the embedded types name.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor157"/>Exercise 4.19: Struct Embedding and Initialization </h2>
			<p>In this exercise, we'll define some structs and custom types. We'll embed those types into a struct. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create a custom string type called name:<p class="source-code">type name string</p></li>
				<li>Create a struct called location with two int fields, that is, <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>:<p class="source-code">type location struct {</p><p class="source-code">  x int</p><p class="source-code">  y int</p><p class="source-code">}</p></li>
				<li>Create a size struct with two int fields, that is, <strong class="source-inline">width</strong> and <strong class="source-inline">height</strong>:<p class="source-code">type size struct {</p><p class="source-code">  width  int</p><p class="source-code">  height int</p><p class="source-code">}</p></li>
				<li>Create a struct named <strong class="source-inline">dot</strong>. This embeds each of the preceding structs in it:<p class="source-code">type dot struct {</p><p class="source-code">  name</p><p class="source-code">  location</p><p class="source-code">  size</p><p class="source-code">}</p></li>
				<li>Create a function that returns a slice of dots:<p class="source-code">func getDots() []dot {</p></li>
				<li>Our first <strong class="source-inline">dot</strong> uses the <strong class="source-inline">var</strong> notation. This will result in all the fields having a zero value:<p class="source-code">  var dot1 dot</p></li>
				<li>With <strong class="source-inline">dot2</strong>, we're also initializing with zero values:<p class="source-code">  dot2 := dot{}</p></li>
				<li>To set the name, we use the type's name as if it were a field:<p class="source-code">  dot2.name = "A"</p></li>
				<li>For size and location, we'll use the promoted fields to set their value:<p class="source-code">  dot2.x = 5</p><p class="source-code">  dot2.y = 6</p><p class="source-code">  dot2.width = 10</p><p class="source-code">  dot2.height = 20</p></li>
				<li>When initializing embedded types, you can't use promotion. For name, the result is the same but for location and size, you need to put more work into this:<p class="source-code">  dot3 := dot{</p><p class="source-code">  name: "B",</p><p class="source-code">  location: location{</p><p class="source-code">    x: 13,</p><p class="source-code">    y: 27,</p><p class="source-code">  },</p><p class="source-code">  size: size{</p><p class="source-code">    width:  5,</p><p class="source-code">    height: 7,</p><p class="source-code">  },</p><p class="source-code">  }</p></li>
				<li>For <strong class="source-inline">dot4</strong>, we'll use the type names to set data:<p class="source-code">  dot4 := dot{}</p><p class="source-code">  dot4.name = "C"</p><p class="source-code">  dot4.location.x = 101</p><p class="source-code">  dot4.location.y = 209</p><p class="source-code">  dot4.size.width = 87</p><p class="source-code">  dot4.size.height = 43</p></li>
				<li>Return all the dots in a slice and then close the function:<p class="source-code">  return []dot{dot1, dot2, dot3, dot4}</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">main</strong>, call the function. Then, loop over the slice and print it to the console:<p class="source-code">func main() {</p><p class="source-code">  dots := getDots()</p><p class="source-code">  for i := 0; i &lt; len(dots); i++ {</p><p class="source-code">    fmt.Printf("dot%v: %#v\n", i+1, dots[i])</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B14177_04_12.jpg" alt="Figure 4.12: Output after struct embedding and initialization&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.12: Output after struct embedding and initialization</p>
			<p>In this exercise, we were able to define a complex struct by embedding other types into it. Embedding allows you to reuse common structures by reducing the duplicated code but still giving your struct a flat API. </p>
			<p>We won't see much embedding in real-world Go code. It does come up, but the complexity and exception mean that Go developers prefer to have the other structs as named fields.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor158"/>Type Conversions</h2>
			<p>There are times when your types won't match up, and with Go's strict type system, if types are not the same, they can't interact with one another. In these cases, you have two options. If the two types are compatible, you can do type conversion – that is, you can create a new value by changing one type to another. The notation to do this is <strong class="source-inline">&lt;value&gt;.(&lt;type&gt;)</strong>. When working with strings, we used this notation to cast a string to a slice of runes or bytes and back again. This works because a string is a special type that stores the string's data as a slice of bytes. </p>
			<p>The string type conversion is losses, but that's not true of all type conversions. When working with numeric type conversion, the numbers can change from their original value. If you convert from a large <strong class="source-inline">int</strong> type, for example, <strong class="source-inline">int64</strong>, into a smaller <strong class="source-inline">int</strong> type, for example, <strong class="source-inline">int8</strong>, it causes the number to overflow. If you were to convert from an unsigned int, for example, uint64, into a signed int, for example, <strong class="source-inline">int64</strong>, this overflow happens because unsigned ints can store a higher number than a signed <strong class="source-inline">int</strong>. This overflowing is the same when converting an <strong class="source-inline">int</strong> into a <strong class="source-inline">float</strong> since the <strong class="source-inline">float</strong> splits its storage space between whole numbers and decimals. When converting from a <strong class="source-inline">float</strong> to an <strong class="source-inline">int</strong>, the decimal part is truncated.</p>
			<p>It's still perfectly reasonable to do these types of lossy conversions, and they happen all the time in real-world code. If you know that the data you're dealing with doesn't cross these thresholds, then there's no need to worry.</p>
			<p>Go does its best to guess at the types that need conversion. This is called implicit type conversion. For example, <strong class="source-inline">math.MaxInt8</strong> is an <strong class="source-inline">int</strong>, and if you try to assign it to a number other than an <strong class="source-inline">int</strong>, Go does an implicit type conversion for you.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor159"/>Exercise 4.20: Numeric Type Conversion</h2>
			<p>In this exercise, we'll do some numeric type conversion and intentionally cause some data issues. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "math"</p><p class="source-code">)</p></li>
				<li>Create a function that returns a string:<p class="source-code">func convert() string{</p></li>
				<li>Define some variables to do our work. Go is doing an implicit conversion of the int <strong class="source-inline">math.MaxInt8</strong> into an <strong class="source-inline">int8</strong>:<p class="source-code">  var i8 int8 = math.MaxInt8</p><p class="source-code">  i := 128</p><p class="source-code">  f64 := 3.14</p></li>
				<li>Here, we'll convert from a smaller <strong class="source-inline">int</strong> type into a larger <strong class="source-inline">int</strong> type. This is always a safe operation:<p class="source-code">  m := fmt.Sprintf("int8  = %v  &gt; in64  = %v\n", i8, int64(i8))</p></li>
				<li>Now, we'll convert from an <strong class="source-inline">int</strong> that's 1 above <strong class="source-inline">int8</strong>'s maximum size. This will cause an overflow to <strong class="source-inline">int8</strong>'s minimum size:<p class="source-code">  m += fmt.Sprintf("int   = %v  &gt; in8   = %v\n", i, int8(i))</p></li>
				<li>Next, we'll convert out <strong class="source-inline">int8</strong> into a <strong class="source-inline">float64</strong>. This doesn't cause an overflow and the data is unchanged:<p class="source-code">  m += fmt.Sprintf("int8  = %v  &gt; float32 = %v\n", i8, float64(i8))</p></li>
				<li>Here, we'll convert a float into an <strong class="source-inline">int</strong>. All the decimal data is lost but the whole number is kept as is:<p class="source-code">  m += fmt.Sprintf("float64 = %v &gt; int   = %v\n", f64, int(f64))</p></li>
				<li>Return the message and then close the function:<p class="source-code">  return m</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, call the function and print it to the console:<p class="source-code">func main() {</p><p class="source-code">  fmt.Print(convert())</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B14177_04_13.jpg" alt="Figure 4.13: Output after conversion&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.13: Output after conversion</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor160"/>Type Assertions and interface{}</h2>
			<p>We've used <strong class="source-inline">fmt.Print</strong> and its siblings a great deal for writing our code, but how does a function such as <strong class="source-inline">fmt.Print</strong> take any type of value when Go is a strongly typed language? Let's take a look at the actual Go standard library code for <strong class="source-inline">fmt.Print</strong>:</p>
			<p class="source-code">// Print formats using the default formats for its operands and writes to standard output.</p>
			<p class="source-code">// Spaces are added between operands when neither is a string.</p>
			<p class="source-code">// It returns the number of bytes written and any write error encountered.</p>
			<p class="source-code">func Print(a ...interface{}) (n int, err error) {</p>
			<p class="source-code">  return Fprint(os.Stdout, a...)</p>
			<p class="source-code">}</p>
			<p>I hope you can see that looking at Go's source code is not scary – it's a great way to see how you should do things and I recommend looking at it whenever you are curious about how they do something. </p>
			<p>By looking at this code, we can see that <strong class="source-inline">fmt.Print</strong> has a variadic of the <strong class="source-inline">interface{}</strong> type. We'll cover interfaces in more detail later, but for now, what you need to know is that an interface in Go describes what functions a type must have to conform to that interface. Interfaces in Go don't describe fields and don't describe a type's core value, such as being a string or a number. In Go, any type can have functions, including strings and numbers. What <strong class="source-inline">interface{}</strong> is describing is a type with no functions. What use is a value with no function, no fields, and no core value? None, but it's still a value, and it can still be passed around. This interface is not setting the type of the value but controlling what values it will allow for a variable with that interface. What types in Go conform to <strong class="source-inline">interface{}</strong>? All of them! Any of Go's types or any custom type you create conform to <strong class="source-inline">interface{}</strong>, and this is how <strong class="source-inline">fmt.Print</strong> can accept any type. You can also use <strong class="source-inline">interface{}</strong> in your code to achieve the same result.</p>
			<p>Once you have your variable that conforms to <strong class="source-inline">interface{}</strong>, what can you do with it? Even if the underlying value of your <strong class="source-inline">interface{}</strong> variable has functions, fields, or a core value, you can't use them because Go is enforcing the interface's contract, which is why this is still all type safe.</p>
			<p>To unlock the capabilities of the value masked by <strong class="source-inline">interface{}</strong>, we need to use type assertion. The notation for type assertion is <strong class="source-inline">&lt;value&gt;.(&lt;type&gt;)</strong>. Type assertion results in a value of the type that was requested and optionally a bool regarding whether it was successful or not. This looks like <strong class="source-inline">&lt;value&gt; := &lt;value&gt;.(&lt;type&gt;)</strong> or <strong class="source-inline">&lt;value&gt;, &lt;ok&gt; := &lt;value&gt;.(type)</strong>. If you leave the Boolean value out and type assertion fails, Go raises a panic.</p>
			<p>Go doesn't remove anything from a value when you place it in an <strong class="source-inline">interface{}</strong> variable. What happens is the Go compiler prevents you from using it because it's not able to perform its type-safety checks at compile time. Using type assertion is your instruction to Go that you want to unlock the value. When you do type assertion, Go performs the type-safety checks it would have done at compile time at runtime, and those checks may fail. It's then your responsibility to deal with the type-safety checks failing. Type assertions is a feature that causes runtime errors and panics, which means you must be extra careful around them.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor161"/>Exercise 4.21: Type Assertion</h2>
			<p>In this exercise, we will perform some type assertions and ensure that all the safety checks are in place when we do so. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "errors"</p><p class="source-code">  "fmt"</p><p class="source-code">)</p></li>
				<li>Create a function that accepts an <strong class="source-inline">interface{}</strong> and returns a string and an error:<p class="source-code">func doubler(v interface{}) (string, error) {</p></li>
				<li>First, we'll check to see if our argument is an int, and if it is, we'll multiply it by <strong class="source-inline">2</strong> and return it:<p class="source-code">  if i, ok := v.(int); ok {</p><p class="source-code">    return fmt.Sprint(i * 2), nil</p><p class="source-code">  }</p></li>
				<li>Here, we'll check if it's a string and if it is, we'll concatenate it to itself and return it:<p class="source-code">  if s, ok := v.(string); ok {</p><p class="source-code">    return s + s, nil</p><p class="source-code">  }</p></li>
				<li>If we don't get any matches, return an error. Then, close the function:<p class="source-code">  return "", errors.New("unsupported type passed")</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">main</strong>, call <strong class="source-inline">doubler</strong> with a variety of data and print the results to the console:<p class="source-code">func main() {</p><p class="source-code">  res, _ := doubler(5)</p><p class="source-code">  fmt.Println("5   :", res)</p><p class="source-code">  res, _ = doubler("yum")</p><p class="source-code">  fmt.Println("yum :", res)</p><p class="source-code">  _, err := doubler(true)</p><p class="source-code">  fmt.Println("true:", err)</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B14177_04_14.jpg" alt="Figure 4.14: Output showing matches&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.14: Output showing matches</p>
			<p>The combination of <strong class="source-inline">interface{}</strong> and type assertions allows you to overcome Go's strict type controls, in turn allowing you to create functions that can work with any type of variable. The challenge is that you lose the protection that Go gives you at compile time for type safety. It's still possible to be safe, but the responsibility is yours now – do it wrong, and you'll get a nasty runtime error.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor162"/>Type Switch</h2>
			<p>If we wanted to expand our <strong class="source-inline">doubler</strong> function to include all <strong class="source-inline">int</strong> types, we'd end up with a lot of duplicated logic. Go has an excellent way of dealing with more complex type assertions situations, known as the type switch. Here's what it looks like:</p>
			<p class="source-code">switch &lt;value&gt; := &lt;value&gt;.(type) {</p>
			<p class="source-code">case &lt;type&gt;:</p>
			<p class="source-code">  &lt;statement&gt;</p>
			<p class="source-code">case &lt;type&gt;, &lt;type&gt;:</p>
			<p class="source-code">  &lt;statement&gt;</p>
			<p class="source-code">default:</p>
			<p class="source-code">  &lt;statement&gt;</p>
			<p class="source-code">}</p>
			<p>The type switch only runs your logic if it matches the type you're looking for, and it sets the value to that type. You can match on more than one type in a case, but Go can't change the type of the value for you, so you'll still need to do type assertion. One of the things that makes this a type switch and not an expression switch is the <strong class="source-inline">&lt;value&gt;.(type)</strong> notation. You can only use that as part of a type switch. Something else that's unique to type switches is that you can't use the <strong class="source-inline">fallthrough</strong> statement.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor163"/>Exercise 4.22: Type Switch</h2>
			<p>In this exercise, we'll update our <strong class="source-inline">doubler</strong> function to use a type switch and expand its abilities to deal with more types. Let's get started:</p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "errors"</p><p class="source-code">  "fmt"</p><p class="source-code">)</p></li>
				<li>Create our function, which takes a single <strong class="source-inline">inferface{}</strong> argument and returns a string and an error:<p class="source-code">func doubler(v interface{}) (string, error) {</p></li>
				<li>Create a type switch using our argument:<p class="source-code">  switch t := v.(type) {</p></li>
				<li>For <strong class="source-inline">string</strong> and <strong class="source-inline">bool</strong>, since we're only matching on one type, we don't need to do any extra safety checks and can work with the value directly:<p class="source-code">  case string:</p><p class="source-code">  return t + t, nil</p><p class="source-code">  case bool:</p><p class="source-code">  if t {</p><p class="source-code">    return "truetrue", nil</p><p class="source-code">  }</p><p class="source-code">  return "falsefalse", nil</p></li>
				<li>For the floats, we're matching on more than one type. This means we need to do type assertion to be able to work with the value:<p class="source-code">  case float32, float64:</p><p class="source-code">  if f, ok := t.(float64); ok {</p><p class="source-code">    return fmt.Sprint(f * 2), nil</p><p class="source-code">  }</p></li>
				<li>If this type assertion were to fail, we'd get a panic, but we can rely on the logic that only <strong class="source-inline">float32</strong> can work directly with the result of type assertion:<p class="source-code">  return fmt.Sprint(t.(float32) * 2), nil</p></li>
				<li>Match all of the <strong class="source-inline">int</strong> and <strong class="source-inline">uint</strong> types. We've been able to remove lots of code here by not needing to do the type-safety checks ourselves:<p class="source-code">  case int:</p><p class="source-code">  return fmt.Sprint(t * 2), nil</p><p class="source-code">  case int8:</p><p class="source-code">  return fmt.Sprint(t * 2), nil</p><p class="source-code">  case int16:</p><p class="source-code">  return fmt.Sprint(t * 2), nil</p><p class="source-code">  case int32:</p><p class="source-code">  return fmt.Sprint(t * 2), nil</p><p class="source-code">  case int64:</p><p class="source-code">  return fmt.Sprint(t * 2), nil</p><p class="source-code">  case uint:</p><p class="source-code">  return fmt.Sprint(t * 2), nil</p><p class="source-code">  case uint8:</p><p class="source-code">  return fmt.Sprint(t * 2), nil</p><p class="source-code">  case uint16:</p><p class="source-code">  return fmt.Sprint(t * 2), nil</p><p class="source-code">  case uint32:</p><p class="source-code">  return fmt.Sprint(t * 2), nil</p><p class="source-code">  case uint64:</p><p class="source-code">  return fmt.Sprint(t * 2), nil</p></li>
				<li>We'll use the default to return an error. Then, we'll close the switch statement and function:<p class="source-code">  default:</p><p class="source-code">  return "", errors.New("unsupported type passed")</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, call our function with even more data and print the results to the console:<p class="source-code">func main() {</p><p class="source-code">  res, _ := doubler(-5)</p><p class="source-code">  fmt.Println("-5  :", res)</p><p class="source-code">  res, _ = doubler(5)</p><p class="source-code">  fmt.Println("5   :", res)</p><p class="source-code">  res, _ = doubler("yum")</p><p class="source-code">  fmt.Println("yum :", res)</p><p class="source-code">  res, _ = doubler(true)</p><p class="source-code">  fmt.Println("true:", res)</p><p class="source-code">  res, _ = doubler(float32(3.14))</p><p class="source-code">  fmt.Println("3.14:", res)</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B14177_04_15.jpg" alt="Figure 4.15: Output after calling functions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.15: Output after calling functions</p>
			<p>In this exercise, we used a type switch to build a complex type assertion scenario. Using the type switch still gives us full control of the type assertions but also lets us simplify the type-safety logic when we don't need that level of control.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor164"/>Activity 4.06: Type Checker</h2>
			<p>In this activity, you're going to write some logic that has a slice or different types of data. These data types are as follows:</p>
			<ul>
				<li>An int</li>
				<li>A float</li>
				<li>A string</li>
				<li>A bool</li>
				<li>A struct</li>
			</ul>
			<p>Create a function that accepts a value of any type. The function returns a string with the name of the type:</p>
			<ul>
				<li>For int, int32, and int64, it returns <strong class="source-inline">int</strong>.</li>
				<li>For all floats, it returns <strong class="source-inline">float</strong>.</li>
				<li>For a string, it returns <strong class="source-inline">string</strong>.</li>
				<li>For a bool, it returns <strong class="source-inline">bool</strong>.</li>
				<li>For anything else, it returns <strong class="source-inline">unknown</strong>.</li>
				<li>Loop all the data by passing each one to your function. </li>
				<li>Then, print the data and its type name to the console. <p>The expected output is as follows:</p></li>
			</ul>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B14177_04_16.jpg" alt="Figure 4.16: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.16: Expected output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 702</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor165"/>Summary</h1>
			<p>In this chapter, we got into the advanced uses of variables and types in Go. Real-world code gets complicated quickly because the real world is complicated. Being able to model the data accurately and keep that data logically organized in your code helps reduce the complexity of your code to a minimum.</p>
			<p>You now know how to group similar data, either in a fixed-length ordered list using an array, in a dynamic length ordered list using a slice, or in a key-value hash using a map.</p>
			<p>We learned to go beyond Go's core types and start to create custom types based either directly on the core types or by creating a struct, which is a collection of other types held in a single type and value. </p>
			<p>There are times when you'll have type mismatches, so Go gives us the ability to convert compatible types so that they can interact in a type-safe way.</p>
			<p>Go also lets us break free of its type safety rules and gives us full control. By using type assertions, we can accept any type using the magic of <strong class="source-inline">interface{}</strong> and then get those types back.</p>
			<p>In the next chapter, we'll explore how to group our logic into reusable components and attach them to our custom types to make our code more straightforward and easier to maintain. </p>
		</div>
		<div>
			<div id="_idContainer078" class="Content">
			</div>
		</div>
	</body></html>