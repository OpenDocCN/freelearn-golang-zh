- en: 4\. Complex Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4. 复杂类型
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces Go's more complex types. This will build on what we
    learned in the previous chapter regarding Go's core types. These complex types
    are indispensable when you build more complex software as they allow you to logically
    group related data together. This ability to group data makes your code easier
    to understand, maintain, and fix.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Go语言中更复杂的类型。这将基于我们在上一章中学到的关于Go核心类型的知识。当构建更复杂的软件时，这些复杂类型是必不可少的，因为它们允许你逻辑上分组相关数据。这种分组数据的能力使得你的代码更容易理解、维护和修复。
- en: By the end of this chapter, you will be able to use arrays, slices, and maps
    to group data together. You will learn to create custom types based on the core
    types. You will also learn to use structs to create structures composed of named
    fields of any other types and explain the importance of `interface{}`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用数组、切片和映射来分组数据。你将学习根据核心类型创建自定义类型。你还将学习使用结构体来创建由任何其他类型的命名字段组成的结构，并解释`interface{}`的重要性。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we covered Go's core types. These types are critical
    to everything you'll do in Go, but it can be challenging to model more complex
    data. In modern computer software, we want to be able to group data and logic
    where possible. We also want to be able to make our logic reflect the real-world
    solutions we're building.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了Go的核心类型。这些类型对于你在Go中做的所有事情都是至关重要的，但建模更复杂的数据可能具有挑战性。在现代计算机软件中，我们希望能够尽可能地将数据和逻辑分组在一起。我们还希望我们的逻辑能够反映我们正在构建的现实世界解决方案。
- en: If you were building software for cars, you would ideally want a custom type
    that embodies a car. This type should be named "car" and it should have properties
    that can store things about what kind of car it is. The logic that affects the
    car, such as starting and stopping, should be associated with the car type. If
    we had to manage more than one car, we need to be able to group all the cars.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在为汽车编写软件，你理想情况下想要一个体现汽车的定制类型。这个类型应该命名为"car"，并且它应该有可以存储关于汽车类型信息的属性。影响汽车的逻辑，如启动和停止，应该与汽车类型相关联。如果我们需要管理多辆汽车，我们需要能够将所有汽车分组在一起。
- en: In this chapter, we'll learn about the features in Go that allow us to model
    the data part of this challenge. Then, in the next chapter, we'll solve the behavior
    part. By using custom types, you can extend Go's core types, and using structs
    allows you to compose a type made of other types and associate logic with them.
    Collections let you group data together and allow you to loop over and perform
    operations on them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Go语言中允许我们建模此挑战数据部分的特性。然后，在下一章中，我们将解决行为部分。通过使用自定义类型，你可以扩展Go的核心类型，而使用结构体则允许你组合由其他类型组成的类型，并将逻辑与它们关联。集合让你可以将数据分组在一起，并允许你遍历并对其执行操作。
- en: As the complexity of your tasks increase, Go's complex types help you keep your
    code easy to understand and maintain. Collections such as `arrays`, `slices`,
    and `maps` allow you to keep related data grouped together. Go's `struct` type
    allows you to create a single type that's made up of other strings, numbers, and
    Booleans, giving you the power to build models of complex real-world concepts.
    Structs also allow you to attach logic to them; this allows you to have the logic
    that controls your models closely tied together.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 随着任务复杂性的增加，Go的复杂类型帮助你保持代码易于理解和维护。如`arrays`、`slices`和`maps`之类的集合允许你将相关数据分组在一起。Go的`struct`类型允许你创建由其他字符串、数字和布尔值组成的单一类型，这让你能够构建复杂现实世界概念的模型。结构体还允许你将逻辑附加到它们上；这允许你将控制模型的逻辑紧密地联系在一起。
- en: When things get complicated with types, we need to know how to use type conversions
    and assertions to manage type mismatches correctly. We'll also be looking at Go's
    `interface{}` type. This type is almost magical in that it allows you to overcome
    Go's struct typing system but in a way that's still type-safe.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型变得复杂时，我们需要知道如何使用类型转换和断言来正确地管理类型不匹配。我们还将探讨Go的`interface{}`类型。这种类型几乎是神奇的，因为它允许你克服Go的结构类型系统，但以一种仍然类型安全的方式。
- en: Collection Types
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合类型
- en: If you were dealing with a single email address, you would define a string variable
    to hold that value for you. Now, think about how you would structure your code
    if you needed to deal with between 0 and 100 email addresses. You could define
    a separate variable for each email address, but Go has something else we can use.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只处理一个电子邮件地址，你会定义一个字符串变量来为你保存该值。现在，考虑如果你需要处理 0 到 100 个电子邮件地址，你的代码应该如何结构。你可以为每个电子邮件地址定义一个单独的变量，但
    Go 有其他我们可以使用的东西。
- en: When dealing with lots of similar data, we put it in a collection. Go's collection
    types are array, slice, and map. Go's collection types are strongly typed and
    are easy to loop over, but they each have unique qualities that mean they are
    each better suited to different use cases.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大量相似数据时，我们将它们放入集合中。Go 的集合类型是数组、切片和映射。Go 的集合类型是强类型的，并且易于遍历，但它们各自都有独特的特性，意味着它们更适合不同的用例。
- en: Arrays
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Go''s most basic collection is an array. When you define an array, you must
    specify what type of data it may contain and how big the array is in the following
    form: `[<size>]<type>`. For example, `[10]int` is an array of size 10 that contains
    ints, while `[5]string` is an array of size 5 that contains strings.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言中最基本的集合类型是数组。当你定义一个数组时，你必须指定它可以包含的数据类型以及数组的大小，以下形式：`[<size>]<type>`。例如，`[10]int`
    是一个大小为 10 的包含整数的数组，而 `[5]string` 是一个大小为 5 的包含字符串的数组。
- en: The key to making this an array is specifying the size. If your definition didn't
    have the size, it would seem like it works, but it would not be an array – it'd
    be a slice. A slice is a different, more flexible, type of collection that we'll
    look at after arrays. You can set the element values to be any type, including
    pointers and arrays.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使其成为数组的关键是指定大小。如果你的定义没有大小，它看起来可能像它工作，但它不会是一个数组——它将是一个切片。切片是不同、更灵活的集合类型，我们将在数组之后讨论。你可以设置元素值为任何类型，包括指针和数组。
- en: 'You can initialize arrays with data using the following form: `[<size>]<type>{<value1>,<value2>,…<valueN>}`.
    For example, `[5]string{1}` would initialize the array with the first value as
    1, while `[5]string{9,9,9,9,9}` would fill the array with the value 9 for each
    element. When initializing with data, you can have Go set the size of the array
    based on the number of elements you initialize it with. You can take advantage
    of this by replacing the length number with `...`. For example, `[...]string{9,9,9,9,9}`
    would create an array of length 5 because we initialized it with 5 elements. Just
    like all arrays, the length''s set at compile time and is not changeable at runtime.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下形式使用数据初始化数组：`[<size>]<type>{<value1>,<value2>,…<valueN>}`。例如，`[5]string{1}`
    会将数组初始化为第一个值为 1，而 `[5]string{9,9,9,9,9}` 会将每个元素填充为值 9。当使用数据初始化时，你可以让 Go 根据你初始化时使用的元素数量来设置数组的大小。你可以通过将长度数字替换为
    `...` 来利用这一点。例如，`[...]string{9,9,9,9,9}` 会创建一个长度为 5 的数组，因为我们用 5 个元素初始化了它。就像所有数组一样，长度在编译时设置，在运行时不可更改。
- en: 'Exercise 4.01: Defining an Array'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.01：定义数组
- en: 'In this exercise, we''re going to define a simple array of size 10 that takes
    integers. Then, we''ll print out the contents. Let''s get started:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个大小为 10 的简单整数数组，然后打印其内容。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中创建一个名为 `main.go` 的文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中添加包和导入：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a function that defines an array and then return it:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，该函数定义一个数组然后返回它：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Define `main()`, call the function, and print the result. We''ll use `fmt.Printf`
    with `%#v` to get extra details about the value, including its type:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main()` 函数，调用该函数并打印结果。我们将使用 `fmt.Printf` 与 `%#v` 来获取关于值的额外详细信息，包括其类型：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Save this. Then, from within the new folder, run the following:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新的文件夹内，运行以下命令：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running the preceding code provides us with the following output:'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码会给我们以下输出：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this exercise, we've defined an array but haven't filled it with any data.
    Since all arrays have a fixed size, when the array was printed out, it contained
    10 values. These values are the empty values for whatever type the array accepts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们定义了一个数组，但没有向其中填充任何数据。由于所有数组都有固定的大小，当数组被打印出来时，它包含 10 个值。这些值是数组接受类型为空的值。
- en: Comparing Arrays
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较数组
- en: The array's length is part of its type definition. If you have two arrays that
    accept the same type but they're different sizes, they are not compatible and
    aren't comparable with each other. Arrays of different lengths that are not the
    same type can can't be compared with each other.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的长度是其类型定义的一部分。如果你有两个接受相同类型的数组，但它们的大小不同，它们是不兼容的，并且不能相互比较。不同长度的不同类型的数组不能相互比较。
- en: 'Exercise 4.02: Comparing Arrays'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.02：比较数组
- en: 'In this exercise, we''ll compare arrays. First, we''ll define some arrays;
    some are comparable, while some are not. Then, we''ll run the code and fix any
    problems that come up. Let''s get started:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将比较数组。首先，我们将定义一些数组；一些是可比较的，而另一些则不是。然后，我们将运行代码并修复出现的任何问题。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中创建一个 `main.go` 文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中，添加包和导入：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a function that defines four arrays:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，定义四个数组：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Compare the arrays and return the result of the comparison. This closes off
    this function:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较数组并返回比较的结果。这完成了这个函数：
- en: '[PRE7]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Define `main` so that it prints out the results:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `main` 以打印出结果：
- en: '[PRE8]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Save and run the code:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行代码：
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码产生以下输出：
- en: '![Figure 4.1: Array type mismatch error'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 4.1：数组类型不匹配错误](img/B14177_04_01.jpg)'
- en: '](img/B14177_04_01.jpg)'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14177_04_02.jpg)'
- en: 'Figure 4.1: Array type mismatch error'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 4.1：数组类型不匹配错误
- en: You should see an error. This error is telling you that `arr1`, which is a `[5]
    int`, and `arr4`, which is a `[9] int`, are not the same type and aren't compatible.
    Let's fix that.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到一个错误。这个错误告诉你，`arr1`，它是一个 `[5] int` 类型的数组，和 `arr4`，它是一个 `[9] int` 类型的数组，不是同一类型，也不兼容。让我们来修复这个问题。
- en: 'Here, we have the following:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里，我们有以下内容：
- en: '[PRE10]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We need to replace this with the following:'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要将其替换为以下内容：
- en: '[PRE11]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We also have the following code:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还有以下代码：
- en: '[PRE12]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We need to replace this with the following:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要将其替换为以下内容：
- en: '[PRE13]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Save and run the code again using the following command:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并再次使用以下命令运行代码：
- en: '[PRE14]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码产生以下输出：
- en: '![Figure 4.2: Output without error'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.2：无错误输出](img/B14177_04_01.jpg)'
- en: '](img/B14177_04_02.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_04_02.jpg)'
- en: 'Figure 4.2: Output without error'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：无错误输出
- en: In our exercise, we defined some arrays, and they were all defined in slightly
    different ways. At first, we had an error because we tried to compare arrays of
    different lengths, which, in Go, means they are different types. We fixed that
    and ran the code again. Then, we could see that even though the first three arrays
    were defined using different methods, they ended up being the same or equal to
    each other. The last array, now with its type fixed, had different data contained
    in it, so it's not the same or equal to the other arrays. The other collection
    types, that is, slice and map, are not comparable in this way. With map and slice,
    you must loop over the contents of the two collections you're comparing and compare
    them manually. This ability gives arrays an advantage if comparing data in collections
    is a hot path in your code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的练习中，我们定义了一些数组，并且它们都是用稍微不同的方式定义的。起初，我们有一个错误，因为我们试图比较不同长度的数组，在 Go 中这意味着它们是不同类型的。我们修复了这个问题，并再次运行了代码。然后，我们可以看到，尽管前三个数组是用不同的方法定义的，但它们最终是相同的或相等的。最后一个数组，现在类型已修复，包含不同的数据，所以它不与其它数组相同或相等。其他集合类型，即切片和映射，不能以这种方式比较。在使用映射和切片时，你必须遍历你要比较的两个集合的内容，并手动进行比较。这种能力给数组带来了优势，如果你的代码中比较集合数据是一个热点路径。
- en: Initializing Arrays Using Keys
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用键初始化数组
- en: So far, when we've initialized our arrays with data, we've let Go choose the
    keys for us. Go allows you to pick the key you want for your data if you want
    using `[<size>]<type>{<key1>:<value1>,…<keyN>:<valueN>}`. Go is flexible and lets
    you set the keys with gaps and in any order. This ability to set values with a
    key is helpful if you've defined an array where the numeric keys have a specific
    meaning and you want to set a value for a specific key but don't need to set any
    of the other values.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当我们用数据初始化数组时，我们让 Go 为我们选择键。如果你想要使用 `[<大小>]<类型>{<键1>:<值1>,…<键N>:<值N>}`
    来选择你想要的数据键，Go 允许你这样做。Go 是灵活的，允许你设置带有间隔的键，并且可以按任何顺序设置。如果你定义了一个数组，其中数字键具有特定的含义，并且你想为特定的键设置值，但不需要设置其他任何值，这种用键设置值的能力是有帮助的。
- en: 'Exercise 4.03: Initializing an Array Using Keys'
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.03：使用键初始化数组
- en: 'In this exercise, we''ll initialize a few arrays using some keys to set specific
    values. Then, we''ll compare them to each other. After, we''ll print out one of
    the arrays and look at its contents. Let''s get started:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用一些键初始化几个数组，并将它们相互比较。然后，我们将打印出一个数组并查看其内容。让我们开始吧：
- en: Create a new folder and add a `main.go` file to it.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中创建一个名为`main.go`的文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中添加包和导入：
- en: '[PRE15]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a function that defines three arrays:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，该函数定义了三个数组：
- en: '[PRE16]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Compare the arrays and return the last one so that we can print it out later:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较数组并返回最后一个，这样我们就可以稍后打印它：
- en: '[PRE17]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a `main` function and call `compArrays`. Then, print out the results:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main`函数并调用`compArrays`。然后，打印出结果：
- en: '[PRE18]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Save the file. Then, in the new folder, run the following:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在新文件夹中运行以下命令：
- en: '[PRE19]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '![Figure 4.3: Array initialized using keys'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3：使用键初始化的数组'
- en: '](img/B14177_04_03.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_04_03.jpg)'
- en: 'Figure 4.3: Array initialized using keys'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：使用键初始化的数组
- en: In this exercise, we used keys when initializing the data for an array. For
    `arr2`, we combined the `...` shortcut with setting a key to make the array length
    directly relate to the key we set. With `arr3`, we mixed it using keys and without
    using keys, and we also used the keys out of order. Go's flexibility when using
    keys is strong and makes using arrays in this way pleasant.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们初始化数组数据时使用了键。对于`arr2`，我们结合了`...`快捷键和设置键，使数组长度直接与设置的键相关联。对于`arr3`，我们混合了使用键和不使用键的情况，并且我们还使用了顺序不正确的键。Go在使用键时的灵活性很强，这使得以这种方式使用数组变得愉快。
- en: Reading from an Array
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数组中读取
- en: So far, we've defined an array and initialized it with some data. Now, let's
    read that data out. It's possible to access a single element of the array using
    `<array>[<index>]`. For example, this accesses the first element of an array,
    `arr[0]`. I know 0 is the first element of the array because arrays always use
    a zero-indexed integer key. The zero index means the first index for an array
    is always 0 and the last index is always the array's length minus 1.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经定义了一个数组并用一些数据初始化了它。现在，让我们读取这些数据。可以使用`<array>[<index>]`来访问数组的单个元素。例如，这访问了数组的第一个元素，`arr[0]`。我知道0是数组的第一个元素，因为数组始终使用零索引的整数键。零索引意味着数组的第一个索引始终是0，最后一个索引始终是数组的长度减1。
- en: The order of the items in an array is guaranteed to be stable. Order stability
    means that an item placed at index 0 is always the first item in the array.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中项目的顺序是有保证的。顺序稳定性意味着放置在索引0处的项目始终是数组中的第一个项目。
- en: Being able to access specific parts of an array can be helpful in a few ways.
    It's often necessary to validate the data in an array by checking either the first
    and/or last elements. Sometimes, the position of the data in an array is important
    so that you know you can get, for example, a product's name from the third index.
    This positional significance is common when reading **comma-separated value**
    (**CSV**) files or other similar delimiter separated value files. CSV is still
    in common use as it is a popular choice for exporting data from spreadsheet documents.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 能够访问数组的具体部分在几种情况下可能会有所帮助。通常需要通过检查数组的第一个和/或最后一个元素来验证数组中的数据。有时，数据在数组中的位置很重要，这样你就可以知道你可以从第三个索引获取，例如，一个产品的名称。这种位置的重要性在读取**逗号分隔值**（**CSV**）文件或其他类似分隔符分隔的值文件时很常见。CSV仍然被广泛使用，因为它是从电子表格文档导出数据的一个流行选择。
- en: 'Exercise 4.04: Reading a Single Item from an Array'
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.04：从数组中读取单个项目
- en: 'In this exercise, we''ll define an array and initialize it with some words.
    Then, we''ll read the words out in the form of a message and print it. Let''s
    get started:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个数组并用一些单词初始化它。然后，我们将以消息的形式读取这些单词并打印它们。让我们开始吧：
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中创建一个名为`main.go`的文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中添加包和导入：
- en: '[PRE20]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a function that defines an array with our words. The order of the words
    is important:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，该函数定义了一个包含我们的单词的数组。单词的顺序很重要：
- en: '[PRE21]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, create a message by joining the words in a specific order and returning
    it. We''re using the `fmt.Sprintln` function here since it allows us to capture
    the formatted text before it''s printed:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过按特定顺序连接单词并返回它来创建一条消息。我们在这里使用`fmt.Sprintln`函数，因为它允许我们在打印之前捕获格式化的文本：
- en: '[PRE22]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create our `main()` function, call the `message` function, and print it to
    the console:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的`main()`函数，调用`message()`函数，并将其打印到控制台：
- en: '[PRE23]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Save and run the code:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行代码：
- en: '[PRE24]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '[PRE25]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Writing to an Array
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向数组中写入
- en: Once an array is defined, you're able to make changes to individual elements
    using their index using `<array>[<index>] = <value>`. This assignment works the
    same as it does for core type variables.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了数组，你就可以使用它们的索引来更改单个元素，格式为`<array>[<index>] = <value>`。这种赋值方式与核心类型变量相同。
- en: In real-world code, you often need to modify the data in your collections after
    it has been defined based on inputs or logic.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的代码中，你通常需要在定义了集合后根据输入或逻辑修改数据。
- en: 'Exercise 4.05: Writing to an Array'
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.05：向数组中写入
- en: 'In this exercise, we''ll define an array and initialize it with some words.
    Then, we''ll make some changes to the words. Finally, we''ll read the words out
    to form a message and print it. Let''s get started:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个数组并用一些单词初始化它。然后，我们将对单词进行一些更改。最后，我们将读取单词以形成消息并打印它。让我们开始吧：
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个名为`main.go`的文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中添加包和导入：
- en: '[PRE26]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a function that defines an array with our words. The order of the words
    is important:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，定义一个包含我们的单词的数组。单词的顺序很重要：
- en: '[PRE27]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We''ll change some of the words in the array by assigning new values using
    an array index. The order this is done in doesn''t matter:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过使用数组索引分配新值来更改数组中的某些单词。这种操作的顺序并不重要：
- en: '[PRE28]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, create a message by joining the words in a specific order and return it:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过按特定顺序连接单词来创建一个消息并返回它：
- en: '[PRE29]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Create our `main()` function, call the `message` function, and print it to
    the console:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的`main()`函数，调用`message()`函数，并将其打印到控制台：
- en: '[PRE30]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Save and run the code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行代码：
- en: '[PRE31]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '[PRE32]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Looping an Array
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环遍历数组
- en: The most common way you'll work with arrays is by using them in loops. Due to
    the way array's indexes works, they are easy to loop over. The index always starts
    at 0, there are no gaps, and the last element is the array's length, minus 1.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你最常使用数组的方式是通过在循环中使用它们。由于数组索引的工作方式，它们很容易进行循环遍历。索引总是从0开始，没有间隔，最后一个元素是数组的长度减1。
- en: Because of this, it's also common to use a loop where we create a variable to
    represent the index and increment it manually. This type of loop is often called
    a `for i` loop since `i` is the name that's given to the index variable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，使用循环创建一个变量来表示索引并手动递增也是常见的。这种类型的循环通常被称为`for i`循环，因为`i`是分配给索引变量的名称。
- en: 'As you''ll remember from the previous chapter, the `for` loop has three possible
    parts: the logic that can run before the loop, the logic that runs on each loop
    interaction to check whether the loop should continue, and the logic that runs
    at the end of each loop iteration. A `for i` loop looks like `i := 0; i < len(arr);
    i++ {`. What happens is that we define `i` to be zero, which also means `i` only
    exists in the scope of the loop. Then, `i` is checked on the loop''s iteration
    to ensure it''s less than the length of the array. We check that it''s less than
    the length of the array since the length is always 1 more than the last index
    key. Lastly, we increment `i` by 1 on each loop to let us step over each element
    in the array, one by one.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从上一章所记得，`for`循环有三个可能的部分：循环前可以运行的逻辑、每次循环交互时运行的逻辑以检查循环是否应该继续，以及每次循环迭代结束时运行的逻辑。一个`for
    i`循环看起来像`i := 0; i < len(arr); i++ {`。发生的事情是我们将`i`定义为零，这也意味着`i`只存在于循环的作用域内。然后，在循环的每次迭代中检查`i`以确保它小于数组的长度。我们检查它是否小于数组的长度，因为长度总是比最后一个索引键多1。最后，我们在每次循环中递增`i`，这样我们就可以逐个遍历数组中的每个元素。
- en: When it comes to the length of an array, it can be tempting to hardcode the
    value of the last index instead of using `len` since you know the length of your
    array is always the same. Hardcoding length is a bad idea. Hardcoding would make
    your code harder to maintain. It's common for your data to change and evolve.
    If you ever need to come back and change the size of an array, having hardcoded
    array lengths introduces hard-to-find bugs and even runtime panics.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到数组的长度时，可能会诱使你直接硬编码最后一个索引的值，而不是使用`len`，因为你知道数组的长度始终相同。硬编码长度是一个糟糕的想法。硬编码会使你的代码更难维护。数据的变化和演变是很常见的。如果你需要回来更改数组的尺寸，硬编码的数组长度会引入难以发现的错误，甚至可能导致运行时崩溃。
- en: Using loops with arrays allows you to repeat the same logic for every element,
    that is, validating the data, modifying the data, or outputting the data without
    having to duplicate the same code for multiple variables.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环与数组一起使用，允许你对每个元素重复相同的逻辑，即验证数据、修改数据或输出数据，而无需为多个变量重复相同的代码。
- en: 'Exercise 4.06: Looping Over an Array Using a "for i" Loop'
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.06：使用“for i”循环遍历数组
- en: 'In this exercise, we''ll define an array and initialize it with some numbers.
    We''ll loop over the numbers and do an operation on each one, putting the result
    in a message. Then, we''ll return the message and print it. Let''s get started:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个数组，并用一些数字初始化它。我们将遍历这些数字，对每个数字执行一个操作，并将结果放入消息中。然后，我们将返回消息并打印它。让我们开始吧：
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个名为`main.go`的文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中添加包和导入：
- en: '[PRE33]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a function. We''ll define the array with the data and a `m` variable
    before the loop:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数。在循环之前，我们将使用数据定义数组和一个`m`变量：
- en: '[PRE34]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Define the start of the loop. This manages the index and the loop:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义循环的开始。这管理索引和循环：
- en: '[PRE35]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, write the body of the loop, which does an operation on each element of
    the array and adds it to the message:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，编写循环体，它对数组的每个元素执行一个操作，并将其添加到消息中：
- en: '[PRE36]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, close the loop, return the message, and close the function:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，关闭循环，返回消息，并关闭函数：
- en: '[PRE37]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Create our `main` function, call the `message` function, and print it to the
    console:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的`main`函数，调用`message`函数，并将其打印到控制台：
- en: '[PRE38]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Save this code. Then, from the new folder, run the code:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存此代码。然后，从新文件夹中运行代码：
- en: '[PRE39]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Running the preceding code produces the following output after looping over
    the array using the `for i` loop:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码，使用`for i`循环遍历数组后，会得到以下输出：
- en: '[PRE40]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `for i` loop is very common, so pay close attention to *step 4*, where we
    defined the loop, and be sure to understand what each of the three parts is doing.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`for i`循环非常常见，所以请特别注意第4步，即我们定义循环的地方，并确保理解三个部分各自的作用。'
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`len`. This feature is also true for the other collection types, that is, slice
    and map.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`len`。这个特性也适用于其他集合类型，即切片和映射。'
- en: Modifying the Contents of an Array in a Loop
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在循环中修改数组的元素
- en: In addition to reading from an array in a loop, you can also change the contents
    of the array in a loop. Working with the data in each element works like working
    with variables. You use the same `for i` loops too.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在循环中从数组中读取数据外，你还可以在循环中更改数组的元素。处理每个元素中的数据就像处理变量一样。你也会使用相同的`for i`循环。
- en: Just like reading data from arrays, being able to change data in collections
    reduces the amount of code you need to write if each element was a standalone
    variable.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 就像从数组中读取数据一样，能够更改集合中的数据可以减少你需要编写的代码量，如果每个元素都是一个独立的变量。
- en: 'Exercise 4.07: Modifying the Contents of an Array in a Loop'
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.07：在循环中修改数组的元素
- en: 'In this exercise, we''re going to define an empty array, fill it with data,
    and then modify that data. Finally, we''ll print the filled and modified array
    to the console. Let''s get started:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个空数组，填充数据，然后修改这些数据。最后，我们将打印填充和修改后的数组到控制台。让我们开始吧：
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个名为`main.go`的文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中添加包和导入：
- en: '[PRE41]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a function that fills an array with numbers from 1 to 10:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，用于将数字从1到10填充到数组中：
- en: '[PRE42]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a function that multiples the number from an array by itself and then
    sets the result back to the array:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，该函数将数组中的数字自乘，然后将结果设置回数组：
- en: '[PRE43]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In our `main()` function, we need to define our empty array, fill it, modify
    it, and then print its contents to the console:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`main()`函数中，我们需要定义我们的空数组，填充它，修改它，然后将其内容打印到控制台：
- en: '[PRE44]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Save this code. Then, from the new folder, run the code:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存此代码。然后，从新文件夹中运行代码：
- en: '[PRE45]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '[PRE46]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Working with data in arrays is simple once you've understood how to use them
    in a `for i` array. One nice thing about working with arrays over the other collections
    if their fixed length. With arrays, it's not possible to accidentally change the
    size of the array and end up in an infinite loop, which is a loop that can't end
    and results in software that runs forever while using lots of resources.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你了解了如何在`for i`循环中使用数组，处理数组中的数据就变得简单了。与处理其他集合相比，数组的一个优点是它们的长度是固定的。使用数组时，不可能意外地改变数组的大小，从而导致无限循环，这是一种无法结束的循环，会导致软件无限期地运行并消耗大量资源。
- en: 'Activity 4.01: Filling an Array'
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动四.01：填充数组
- en: 'In this activity, we''re going to define an array and fill it using a for-i
    loop. The following are the steps for this activity:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将定义一个数组，并使用for-i循环填充它。以下是本活动的步骤：
- en: Create a new Go app.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Go应用程序。
- en: Define an array with 10 elements.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含10个元素的数组。
- en: Use a for-i loop to fill that array with the numbers 1 through 10.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用for-i循环用数字1到10填充该数组。
- en: Use `fmt.Println` to print the array to the console.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fmt.Println`将数组打印到控制台。
- en: 'The expected output is as follows:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '[PRE47]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 696
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可在第696页找到
- en: Slice
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切片
- en: Arrays are great, but their rigidity around size can cause issues. If you wanted
    to create a function that accepted an array and sorted the data in it, it could
    only work for one size of array. That requires you to create a function for each
    size of array. This strictness around size makes working with arrays feel like
    a hassle and unengaging. The flip side of arrays is that they are an efficient
    way of managing sorted collections of data. Wouldn't it be great if there were
    a way to get the efficiency of arrays but with more flexibility? Go gives you
    this in the form of slices.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 数组很棒，但它们在大小上的僵化可能会引起问题。如果你想要创建一个接受数组并对其中的数据进行排序的函数，它只能适用于一种数组大小。这需要你为每种数组大小创建一个函数。这种对大小的严格性使得使用数组感觉像是一种麻烦和不吸引人的体验。数组的另一面是，它们是管理排序数据集合的高效方式。如果有一种方法可以同时获得数组的效率和更多的灵活性，那岂不是很好？Go通过切片的形式为你提供了这种功能。
- en: A slice is a thin layer around arrays that let you have a sorted numeric indexed
    collection without you having to worry about the size. Underneath the thin layer
    is still a Go array, but Go manages all the details, such as how big an array
    to use, for you. You use a slice just like you would an array; it only holds values
    of one type, you can read and write to each element using `[` and `]`, and they
    are easy to loop overusing `for i` loops.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是围绕数组的一层薄薄的外壳，让你拥有一个排序的数值索引集合，而无需担心大小。在薄薄的外壳下面仍然是Go数组，但Go为你管理所有细节，例如使用多大的数组。你使用切片的方式就像使用数组一样；它只包含一个类型的值，你可以使用`[`和`]`读取和写入每个元素，并且它们使用`for
    i`循环进行循环时很容易。
- en: The other thing a slice can do is be easily expanded using the built-in `append`
    function. This function accepts your slice and the values you'd like to add and
    returns a new slice with everything merged. It's common to start with an empty
    slice and expand it as needed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 切片还能做的另一件事是使用内置的`append`函数轻松扩展。这个函数接受你的切片和你要添加的值，并返回一个包含所有内容的新切片。通常，我们会从一个空切片开始，并根据需要扩展它。
- en: Since a slice is a thin layer around an array, this means it's not a true type
    like an array. You need to understand how Go uses the hidden array behind the
    slice. If you don't, it'll lead to subtle and difficult-to-debug errors.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于切片是围绕数组的一层薄薄的外壳，这意味着它不是一个真正的类型，就像数组一样。你需要了解Go如何使用切片后面的隐藏数组。如果你不了解这一点，可能会导致微妙且难以调试的错误。
- en: In real-world code, you should be using slices as your go-to for all sorted
    collections. You'll be more productive because you won't need to write as much
    code as you would with an array. Most code you'll see in real-world projects use
    lots of slices and rarely use arrays. Arrays are only used when the size needs
    to be exactly a certain length, and even then, slices get used most of the time
    as they can be passed around the code more easily.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的代码中，你应该使用切片作为所有排序集合的首选。这将使你更加高效，因为你不需要像使用数组那样编写那么多代码。在现实世界的项目中，你将看到的代码大多数都使用了大量的切片，而很少使用数组。数组仅在需要确切长度时使用，即使在这种情况下，切片也通常被使用，因为它们可以更容易地在代码中传递。
- en: 'Exercise 4.08: Working with Slices'
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.08：处理切片
- en: 'In this exercise, we''ll show you how flexible slices are by reading some data
    from a slice, passing a slice to a function, looping over a slice, reading values
    from a slice, and appending values to the end of a slice. Let''s get started:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过从切片中读取一些数据、将切片传递给函数、遍历切片、从切片中读取值以及向切片末尾添加值来展示切片的灵活性。让我们开始吧：
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个名为`main.go`的文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中添加包和导入：
- en: '[PRE48]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create a function that takes an `int` argument and returns a string slice:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，它接受一个`int`类型的参数并返回一个字符串切片：
- en: '[PRE49]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the function''s body, check if we have the correct number of arguments being
    passed in through the command line. If not, we exit the program with an error.
    All the arguments that are passed to Go are placed in `os.Args`, which is a slice
    of strings:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数体中，检查是否通过命令行传递了正确的参数数量。如果没有，我们以错误退出程序。传递给Go的所有参数都放在`os.Args`中，它是一个字符串切片：
- en: '[PRE50]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The first element of the slice is how the code is called and not an argument,
    so we''ll remove that:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切片的第一个元素是代码的调用方式，而不是一个参数，所以我们将移除它：
- en: '[PRE51]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, we''ll return the arguments:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将返回这些参数：
- en: '[PRE52]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, create a function that loops over a slice and finds the longest string.
    When two words are of the same length, the first word is returned:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个函数，它遍历一个切片并找到最长的字符串。当两个单词长度相同时，返回第一个单词：
- en: '[PRE53]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the `main()` function, we call the functions and check for errors:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们调用函数并检查错误：
- en: '[PRE54]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Save the file. Then, in the folder it''s saved in, run the code using the following
    command:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在保存文件的文件夹中，使用以下命令运行代码：
- en: '[PRE55]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '[PRE56]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this exercise, we were able to see how flexible slices are and, at the same
    time, how they work just like arrays. This way of working with slices is another
    reason why Go has the feel of a dynamic language.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们能够看到切片的灵活性以及它们如何像数组一样工作。这种使用切片的方式是Go感觉像是一种动态语言的原因之一。
- en: 'Activity 4.02: Printing a User''s Name Based on User Input'
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 4.02：根据用户输入打印用户姓名
- en: 'It''s now your turn to work with maps. We''re going to define a map and create
    logic to print the data in the map based on the key that''s passed to your app.
    The following are the steps for this activity:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在轮到你了，开始使用地图。我们将定义一个地图，并创建逻辑来根据传递给应用程序的键打印地图中的数据。以下是这个活动的步骤：
- en: Create a new Go app.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Go应用程序。
- en: 'Define a `map` with the following key-value pairs:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含以下键值对的`map`：
- en: 'Key: 305, Value: Sue'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 键：305，值：Sue
- en: 'Key: 204, Value: Bob'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 键：204，值：Bob
- en: 'Key: 631, Value: Jake'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 键：631，值：Jake
- en: 'Key: 073, Value: Tracy'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 键：073，值：Tracy
- en: Using `os.Args`, read a key that's been passed in and print the corresponding
    name; for instance, `go run . 073`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`os.Args`读取传递进来的键并打印相应的名字；例如，`go run . 073`。
- en: Correctly handle when no argument gets passed or if the passed argument doesn't
    match a value in the `map`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确处理没有传递参数或传递的参数不匹配`map`中的值的情况。
- en: Print a message to the user with the name in the value.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向用户打印包含在值中的名字的消息。
- en: 'The expected output is as follows:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE57]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 697
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第697页找到
- en: Appending Multiple Items to a Slice
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向切片中添加多个项目
- en: The built-in `append` function can add more than one value to a slice. You can
    add as many parameters to `append` as you need since the last parameter is variadic.
    Since it's variadic, this means that you can also use the `...` notation to use
    a slice as the variadic parameter, allowing you to pass a dynamic number of parameters
    to `append`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`append`函数可以向切片添加多个值。你可以向`append`添加任意多的参数，因为最后一个参数是可变参数。由于它是可变参数，这意味着你也可以使用`...`表示法将切片用作可变参数，允许你向`append`传递动态数量的参数。
- en: Being able to pass more than one parameter to `append` comes up all the time
    in real-world code, and having it keeps Go code compact by not requiring multiple
    calls or loops to add multiple values.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的代码中，经常需要向`append`传递多个参数，并且拥有它可以使Go代码紧凑，因为它不需要多次调用或循环来添加多个值。
- en: 'Exercise 4.09: Appending Multiple Items to a Slice'
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.09：向切片中添加多个项目
- en: 'In this exercise, we''ll use the variadic parameter of `append` to add multiple
    values in the form of predefined data to a slice. Then, we''ll add a dynamic amount
    of data based on user input to the same slice. Let''s get started:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `append` 的可变参数来向切片中添加以预定义数据形式存在的多个值。然后，我们将根据用户输入向同一个切片中添加动态数量的数据。让我们开始吧：
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个名为 `main.go` 的文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中添加包和导入：
- en: '[PRE58]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Create a function to safely grab user input:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个安全获取用户输入的函数：
- en: '[PRE59]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Create a function that accepts a slice of strings as a parameter and returns
    a slice of strings. Then, define a slice of strings variable:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个接受字符串切片作为参数并返回字符串切片的函数。然后，定义一个字符串切片变量：
- en: '[PRE60]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Add multiple strings to the slice using `append`:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `append` 方法向切片中添加多个字符串：
- en: '[PRE61]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Add more data from the parameter:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从参数中添加更多数据：
- en: '[PRE62]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Return the variable and close the function definition:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回变量并关闭函数定义：
- en: '[PRE63]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In the `main()` function, get the user input, pass it to our function, and
    then print the result:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，获取用户输入，将其传递给我们的函数，然后打印结果：
- en: '[PRE64]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在步骤 1 中创建的文件夹中，使用以下命令运行代码：
- en: '[PRE65]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '[PRE66]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In this exercise, we used two methods of adding multiple values to a slice.
    You would also use this technique if you needed to join two slices together.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了两种向切片添加多个值的方法。如果你需要将两个切片合并在一起，你也会使用这种技术。
- en: While exploding a slice like this to add it to another slice may seem inefficient,
    the Go runtime can spot when you're doing an explode in an append and optimizes
    the call in the background to ensure no resources get wasted.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将切片像这样展开以添加到另一个切片可能看起来效率不高，但 Go 运行时可以检测到你正在执行 append 操作，并在后台优化调用以确保不浪费资源。
- en: 'Activity 4.03: Creating a Locale Checker'
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 4.03：创建区域检查器
- en: In this activity, we're going to create a locale validator. A locale is an internationalization
    and localization concept that is a combination of both a language and a country
    or region. We'll create a struct that represents a locale. After, we're going
    to define a list of locales our code supports. Then, we'll read in some locale
    code from the command line and print out whether our code accepts that locale
    or not.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将创建一个区域验证器。区域是一个国际化本地化概念，它是语言和国家的组合。我们将创建一个表示区域的结构。之后，我们将定义代码支持的区域列表。然后，我们将从命令行读取一些区域代码，并打印出我们的代码是否接受该区域。
- en: 'Here are the steps for this activity:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个活动的步骤：
- en: Create a new Go app.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Go 应用程序。
- en: Define a struct with a field for language and a separate field for country or
    region.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个具有语言字段和单独的国家或地区字段的结构。
- en: Create a collection to hold the local definitions for at least five locales,
    for instance, "en_US", "en_CN", "fr_CN", "fr_FR", and "ru_RU".
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个集合来存储至少五个区域的本地定义，例如，"en_US"、"en_CN"、"fr_CN"、"fr_FR" 和 "ru_RU"。
- en: Read in the local from the command line, for example, using `os.Args`. Be sure
    to have error checking and validation working.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `os.Args` 等方法从命令行读取本地，确保有错误检查和验证。
- en: Load the passed locale string into a new locale struct.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将传递的区域字符串加载到一个新的区域结构中。
- en: Use that struct to check whether the passed struct is supported.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用该结构来检查传递的结构是否受支持。
- en: Print a message to the console stating whether the locale is supported or not.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制台打印一条消息，说明是否支持该区域。
- en: 'The expected output is as follows:'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '![Figure 4.4: Expected output'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.4：预期输出](img/B14177_04_04.jpg)'
- en: '](img/B14177_04_04.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_04_04.jpg](img/B14177_04_04.jpg)'
- en: 'Figure 4.4: Expected output'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：预期输出
- en: Note
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 698
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 698 页找到。
- en: Creating Slices from Slices and Arrays
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从切片和数组创建切片
- en: By using a similar notation to accessing a single element in an array or slice,
    you can create new slices derived from the contents of arrays and slices. The
    most common notation is `[<low>:<high>]`. This notation tells Go to create a new
    slice with the same value type as the source slice or array and to populate the
    new slice with values by starting at the low index and then going up to but not
    including the high index. Low and high are optional. If you omitted low, then
    Go defaults to the first element in the source. If you omit high, then it goes
    all the way to the last value. It's possible to skip both, and if you do, then
    the new slice has all the values from the source.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用与访问数组或切片中单个元素类似的符号，你可以创建从数组或切片内容派生的新切片。最常用的符号是 `[<low>:<high>]`。这个符号告诉 Go
    创建一个新的切片，其值类型与源切片或数组相同，并通过从低索引开始填充新切片，直到但不包括高索引的值。低和高是可选的。如果你省略了低，那么 Go 默认为源中的第一个元素。如果你省略了高，那么它将一直到最后一个值。你可以同时省略两者，如果你这样做，那么新切片将包含源中的所有值。
- en: When you create new slices this way, Go doesn't copy the values. If the source
    is an array, then that source array is the hidden array for the new slice. If
    the source is a slice, then the hidden array for the new slice is the same hidden
    array the source slice uses.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以这种方式创建新的切片时，Go 不会复制值。如果源是数组，那么该源数组是新切片的隐藏数组。如果源是切片，那么新切片的隐藏数组与源切片使用的相同隐藏数组。
- en: 'Exercise 4.10: Creating Slices from a Slice'
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.10：从切片创建切片
- en: 'In this exercise, we''ll use the slice range notation to create slices with
    a variety of initial values. Commonly, in real-world code, you need to work with
    only a small part of a slice or array. The `range` notation is a quick and straightforward
    way of getting only the data you need. Let''s get started:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用切片范围符号创建具有各种初始值的切片。通常，在实际代码中，你需要处理切片或数组的一小部分。`range` 符号是一种快速直接的方法，可以只获取你需要的数据。让我们开始吧：
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹并添加一个名为 `main.go` 的文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中添加包和导入：
- en: '[PRE67]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create a function and define a slice with nine `int` values:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数并定义一个包含九个 `int` 值的切片：
- en: '[PRE68]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We''ll extract the first value, first directly as an int, then as a slice using
    both low and high, and finally using just high and skipping low. We''ll write
    the values to a message string:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将提取第一个值，首先直接作为一个 int，然后作为一个使用低和高，最后只使用高并省略低切片。我们将值写入消息字符串：
- en: '[PRE69]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we''ll get the last element. To get the int, we''ll use the length and
    subtract 1 from the index. We use that same logic when setting the low for the
    range notation. For high, we can use the length of the slice. Finally, we can
    see we can skip high and get the same result:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将获取最后一个元素。为了获取 int，我们将使用长度并从索引中减去 1。我们使用相同的逻辑来设置范围符号的低。对于高，我们可以使用切片的长度。最后，我们可以省略高并得到相同的结果：
- en: '[PRE70]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, let''s get the first five values and add them to the message:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们获取前五个值并将它们添加到消息中：
- en: '[PRE71]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, we''ll get the last four values and add them to the message as well:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将获取最后四个值并将它们也添加到消息中：
- en: '[PRE72]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Finally, we''ll extract five values from the middle of the slice and get them
    in the message too:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将从切片的中间提取五个值并将它们也放入消息中：
- en: '[PRE73]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, we''ll return the message and close the function:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将返回消息并关闭函数：
- en: '[PRE74]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In `main`, we''ll print the message out:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 中，我们将打印消息：
- en: '[PRE75]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在你在 *步骤 1* 中创建的文件夹中，使用以下命令运行代码：
- en: '[PRE76]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '![Figure 4.5: Output after creating slices from a slice'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.5：从切片创建切片后的输出'
- en: '](img/B14177_04_05.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_04_05.jpg)'
- en: 'Figure 4.5: Output after creating slices from a slice'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：从切片创建切片后的输出
- en: In this exercise, we tried out a few ways to create slices from another slice.
    You can also use these same techniques on an array as the source. We saw that
    both the start and stop indexes are optional. If you don't have a start index,
    it'll start at the beginning of the source slice or array. If you don't have the
    stop index, then it'll stop at the end of the array. If you skip both the start
    and stop indexes, it'll make a copy of the slice or array. This trick is useful
    for turning an array into a slice but not helpful for copying slices because the
    two slices share the same hidden array.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们尝试了几种从另一个切片创建切片的方法。你也可以将这些相同的技巧用于数组作为源。我们注意到起始索引和停止索引都是可选的。如果你没有起始索引，它将从源切片或数组的开始处开始。如果你没有停止索引，那么它将在数组的末尾停止。如果你跳过了起始索引和停止索引，它将复制切片或数组。这个技巧对于将数组转换为切片很有用，但对于复制切片没有帮助，因为两个切片共享同一个隐藏数组。
- en: Understanding Slice Internals
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解切片内部机制
- en: Slices are great and should be your go-to when you need an ordered list, but
    if you don't know how they work under the hood, they cause hard-to-spot bugs.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 切片很棒，当你需要有序列表时应该首选使用，但如果你不知道它们在底层是如何工作的，它们会导致难以发现的错误。
- en: An array is a value type that's similar to a string or an `int`. Value types
    can be copied and compared to themselves. These value types, once copied, are
    not connected to their source values. Slices don't work like value types; they
    work more like pointers, but they are also not pointers.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一种类似于字符串或`int`的值类型。值类型可以被复制并与其自身进行比较。这些值类型一旦被复制，就不再与它们的源值连接。切片不像值类型那样工作；它们更像指针，但它们也不是指针。
- en: The key to staying safe with a slice is to understand that there is a hidden
    array that stores the values and that making changes to the slice may or may not
    require that hidden array to be replaced with a bigger one. The fact that the
    management of the hidden array happens in the background is what makes it hard
    to reason well about what's going on with your slices.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切片保持安全的关键在于理解存在一个隐藏数组来存储值，并且对切片的更改可能需要或不要求用更大的一个替换隐藏数组。隐藏数组的管理在后台发生的事实使得很难很好地推理切片中正在发生的事情。
- en: 'Slices have three hidden properties: length, a pointer to the hidden array,
    and where in the hidden array its starting point is. When you append to a slice,
    one or all of these properties get updated. Which properties get updated depends
    on whether the hidden array is full or not.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 切片有三个隐藏属性：长度、指向隐藏数组的指针以及它在隐藏数组中的起始位置。当你向切片添加内容时，这些属性之一或全部会更新。哪些属性会更新取决于隐藏数组是否已满。
- en: 'The size of the hidden array and the size of the slice are not always the same.
    The size of the slice is its length, which we can find out by using the `len`
    built-in function. The size of the hidden array is the capacity of the slice.
    There is also a built-in function that tells you the capacity of a slice, that
    is, `cap`. When you add a new value to a slice using `append`, one of two things
    happens: if the slice has extra capacity, that is, the hidden array is not full
    yet, it adds the value to the hidden array and then updates the slices length
    property. If the hidden array is full, Go creates a new, larger, array. Go then
    copies all the values from the old array into the new array and adds the new value
    too. Then, Go updates the slice from pointing to the old array to the new array
    and updates the length of the slice and possibly its starting point.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏数组的尺寸和切片的尺寸并不总是相同的。切片的尺寸是其长度，我们可以通过使用`len`内置函数来找出它。隐藏数组的尺寸是切片的容量。还有一个内置函数可以告诉你切片的容量，即`cap`。当你使用`append`向切片添加新值时，会发生两件事之一：如果切片有额外的容量，即隐藏数组还没有满，它将值添加到隐藏数组中，然后更新切片的长度属性。如果隐藏数组已满，Go将创建一个新的更大的数组。然后，Go将所有值从旧数组复制到新数组中，并添加新值。然后，Go更新切片，使其指向新数组，并更新切片的长度以及可能的位置。
- en: The starting point only comes into play if the slice is a subset of values from
    an array or a slice not starting at the first element, for example, in our example
    where we got the last five elements of a slice. The rest of the time, it'll be
    the first element in the hidden array.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 起始点仅在切片是数组或从第一个元素开始不是的切片的值子集时才会发挥作用，例如，在我们获取切片最后五个元素的例子中。其余时间，它将是隐藏数组中的第一个元素。
- en: It's possible to control the size of the hidden array when you define a slice.
    Go's built-in `make` function allows you to set the length and capacity of a slice
    when creating it. The syntax looks like `make(<sliceType>, <length>, <capacity>)`.
    When creating a slice using `make`, the capacity is optional, but length is required.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 当您定义一个切片时，可以控制隐藏数组的尺寸。Go 的内置 `make` 函数允许您在创建切片时设置其长度和容量。语法看起来像 `make(<sliceType>,
    <length>, <capacity>)`。当使用 `make` 创建切片时，容量是可选的，但长度是必需的。
- en: 'Exercise 4.11: Using make to Control the Capacity of a Slice'
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.11：使用 `make` 控制切片的容量
- en: 'In this exercise, using the `make` function, we''ll create some slices and
    display their length and capacity. Let''s get started:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，使用 `make` 函数，我们将创建一些切片并显示它们的长度和容量。让我们开始吧：
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中创建一个名为 `main.go` 的文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中添加包和导入：
- en: '[PRE77]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Create a function that returns three `int` slices:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个返回三个 `int` 切片的函数：
- en: '[PRE78]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Define a slice using the `var` notation:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `var` 语法定义一个切片：
- en: '[PRE79]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Define a slice using make and set only the length:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `make` 定义一个切片并仅设置长度：
- en: '[PRE80]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Define a slice that uses both the length and capacity of the slices:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个同时使用切片长度和容量的切片：
- en: '[PRE81]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Return the three slices and close the function definition:'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回三个切片并关闭函数定义：
- en: '[PRE82]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In the `main()` function, call the function we created and capture the returned
    values. For each slice, print its length and capacity to the console:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，调用我们创建的函数并捕获返回的值。对于每个切片，将其长度和容量打印到控制台：
- en: '[PRE83]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在您创建的 *步骤 1* 中的文件夹中，使用以下命令运行代码：
- en: '[PRE84]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '![Figure 4.6: Output displaying slices'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 4.6：显示切片的输出'
- en: '](img/B14177_04_06.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_04_06.jpg)'
- en: 'Figure 4.6: Output displaying slices'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：显示切片的输出
- en: In this exercise, we used `make`, `len`, and `cap` to control and display the
    length and capacity of a slice when defining one.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了 `make`、`len` 和 `cap` 来在定义切片时控制和显示其长度和容量。
- en: If you know how big a slice is, you'll typically need for an operation for setting
    the capacity, which can be a performance boost as Go has to do less work managing
    the hidden array.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道切片的大小，通常需要为设置容量进行操作，这可以提高性能，因为 Go 需要管理隐藏数组的工作更少。
- en: Background Behavior of Slices
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片的后台行为
- en: Due to the complexity of what a slice is and how it works, you can't compare
    slices to one another. If you try, Go gives you an error. You can compare a slice
    to nil, but that's it.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 由于切片是什么以及它是如何工作的复杂性，您不能相互比较切片。如果您尝试这样做，Go 会给您一个错误。您可以比较一个切片与 nil，但仅此而已。
- en: A slice is not a value, and it's not a pointer, so what is it? A slice is a
    special construct in Go. A slice doesn't store its own values directly. In the
    background, it's using an array that you can't access directly. What a slice does
    store is a pointer to that hidden array, its own starting point in that array,
    how long the slice is, and what the capacity of the slice is. These values provide
    slices with a window for the hidden array. The window can be the whole hidden
    array or just a smaller portion of it. The pointer to the hidden array can be
    shared by more than one slice. This pointer sharing can result in multiple slices
    that can share the same hidden array, even though not all the slides contain the
    same data. This means that one of the slices can have more of the data than the
    other slices.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 切片不是一个值，也不是一个指针，那么它是什么？切片是 Go 中的一个特殊构造。切片不会直接存储其自己的值。在后台，它使用一个您无法直接访问的数组。切片存储的是指向那个隐藏数组的指针、在该数组中的起始点、切片的长度以及切片的容量。这些值为切片提供了一个查看隐藏数组的窗口。这个窗口可以是整个隐藏数组，也可以是它的一部分。隐藏数组的指针可以被多个切片共享。这种指针共享可以导致多个切片可以共享同一个隐藏数组，即使不是所有的切片都包含相同的数据。这意味着其中一个切片可能包含比其他切片更多的数据。
- en: When a slice needs to grow beyond its hidden array, it creates a new bigger
    array and copies the contents from the old array to the new one and points the
    slice at the new array. This array swap is why our preceding slices became disconnected.
    At first, they were pointing to the same hidden array, but when we grow the first
    slice, the array it's pointing to changes. This change means that changes to the
    grown slice no longer affect the other slices since they are still pointing to
    the old, smaller, array.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个切片需要超出其隐藏数组时，它会创建一个新的更大的数组，并将旧数组的内容复制到新数组中，并将切片指向新数组。这种数组交换是我们之前切片断开连接的原因。最初，它们都指向同一个隐藏数组，但当我们扩展第一个切片时，它所指向的数组发生了变化。这种变化意味着扩展的切片的更改不再影响其他切片，因为它们仍然指向旧的、较小的数组。
- en: If you need to make a copy of a slice and need to be sure they are not connected,
    you have a few choices. You can use `append` to copy the contents of the source
    slice into another array or use the built-in `copy` function. When using `copy`,
    Go won't change the size of the destination slice, so be sure it has enough room
    for all the elements you want to copy.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要复制一个切片并确保它们不连接，你有几种选择。你可以使用 `append` 将源切片的内容复制到另一个数组中，或者使用内置的 `copy` 函数。当使用
    `copy` 时，Go 不会改变目标切片的大小，所以请确保它有足够的空间来存放你想要复制的所有元素。
- en: 'Exercise 4.12: Controlling Internal Slice Behavior'
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.12：控制内部切片行为
- en: 'In this exercise, we''re going to explore five different ways to copy data
    from slice to slice and how that has an impact on a slice''s internal behavior.
    Let''s get started:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将探索五种不同的从切片到切片复制数据的方法以及这对切片的内部行为有何影响。让我们开始吧：
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并向其中添加一个名为 `main.go` 的文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 文件中，添加包和导入：
- en: '[PRE85]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Create a function that returns three ints:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个返回三个整数的函数：
- en: '[PRE86]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Define an int slice, initialized with some data:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个初始化了一些数据的整数切片：
- en: '[PRE87]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Then, we''ll make a simple variable copy of that slice:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建该切片的一个简单变量副本：
- en: '[PRE88]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Create a new slice by copying all the values from the first slice as part of
    a slice range operation:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过复制第一个切片的所有值作为切片范围操作的一部分创建一个新的切片：
- en: '[PRE89]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Change some data in the first slice. Later, we''ll see how this affects the
    second and third slice:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改第一个切片中的某些数据。稍后，我们将看到这如何影响第二个和第三个切片：
- en: '[PRE90]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Return the same index for each slice and close the function definition:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个切片返回相同的索引并关闭函数定义：
- en: '[PRE91]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Create a function that will return two ints:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将返回两个整数的函数：
- en: '[PRE92]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Define a slice with some data and do a simple copy again:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含一些数据的切片，并再次进行简单的复制：
- en: '[PRE93]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This time, we''ll append to the first slice before we do anything else. This
    operation changes the length and capacity of the slice:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，在执行其他任何操作之前，我们将向第一个切片中追加数据。这个操作会改变切片的长度和容量：
- en: '[PRE94]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Then, we''ll change the first slice, return the same indexes from the two slices,
    and close the function:'
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将更改第一个切片，从两个切片中返回相同的索引，并关闭函数：
- en: '[PRE95]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In our next function, we''ll be returning two ints:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的下一个函数中，我们将返回两个整数：
- en: '[PRE96]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'We''ll define our first slice using make this time. When doing this, we''ll
    be setting a capacity that''s larger than its length:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次我们将使用 `make` 定义我们的第一个切片。在这样做的时候，我们将设置一个比其长度更大的容量：
- en: '[PRE97]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Let''s fill the first array with the same data as before:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们用之前相同的数据填充第一个数组：
- en: '[PRE98]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now, we''ll create a new slice by copying the first slice, like we did previously:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个新的切片，就像我们之前做的那样，通过复制第一个切片：
- en: '[PRE99]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We''ll append a new value to the first slice, which changes its length but
    not its capacity:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将向第一个切片中追加一个新值，这会改变其长度但不会改变其容量：
- en: '[PRE100]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Then, we''ll change the first slice, return the same indexes from the two slices,
    and close the function:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将更改第一个切片，从两个切片中返回相同的索引，并关闭函数：
- en: '[PRE101]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In this function, we''ll use make again to set a capacity, but we''ll use `append`
    to add elements that will go beyond that capacity:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数中，我们将再次使用 `make` 来设置容量，但我们将使用 `append` 来添加超出该容量的元素：
- en: '[PRE102]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'In the next function, we''ll use `copy` to copy the elements from the first
    slice to the second slice. Copy returns how many elements were copied from one
    slice to another, so we''ll return that too:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个函数中，我们将使用 `copy` 来将第一个切片的元素复制到第二个切片。`copy` 返回从一个切片复制到另一个切片的元素数量，因此我们也将返回这个值：
- en: '[PRE103]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In the final function, we''ll use `append` to copy the value into the second
    slice. Using `append` in this way results in the values being copied into a new
    hidden array:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一个函数中，我们将使用 `append` 将值复制到第二个切片。以这种方式使用 `append` 会导致值被复制到一个新的隐藏数组中：
- en: '[PRE104]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'In `main`, we''ll print out all the data we returned and print it to the console:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数中，我们将打印出我们返回的所有数据，并将其打印到控制台：
- en: '[PRE105]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在您在*步骤1*中创建的文件夹中，使用以下命令运行代码：
- en: '[PRE106]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '![Figure 4.7: Output displaying data'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7：显示数据的输出'
- en: '](img/B14177_04_07.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7：显示数据的输出](img/B14177_04_07.jpg)'
- en: 'Figure 4.7: Output displaying data'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：显示数据的输出
- en: In this exercise, we stepped through five different scenarios where we made
    copies of slice data. In the `Linked` scenario, we made a simple copy of the first
    slice and then a range copy of it. While the slices themselves are distinct and
    are no longer the same slices, in reality, it doesn't make a difference to the
    data they hold. Each of the slices pointed to the same hidden array, so when we
    made a change to the first slice, it affected all of the slices.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们逐步分析了五种不同的场景，在这些场景中我们复制了切片数据。在`链接`场景中，我们对第一个切片进行了简单的复制，然后对其进行了范围复制。虽然切片本身是不同的，不再是同一个切片，但在现实中，它们所持有的数据并没有区别。每个切片都指向同一个隐藏数组，所以当我们对第一个切片进行更改时，它会影响所有切片。
- en: In the `No Link` scenario, the setup was the same for the first and second slice,
    but before we made a change to the first slice, we appended a value to it. When
    we appended this value to it, in the background, Go needed to create a new array
    to hold the now large number of values. Since we were appending to the first slice,
    its pointer was to look at the new, bigger slice. The second slice doesn't get
    its pointer updates. That's why, when the first slice had its value change, the
    second slice wasn't affected. The second slice isn't pointing to the same hidden
    array anymore, meaning they are not linked.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在`无链接`场景中，第一和第二个切片的设置相同，但在我们对第一个切片进行更改之前，我们向其中添加了一个值。当我们向其中添加这个值时，在后台，Go需要创建一个新的数组来存储现在的大量值。由于我们是在向第一个切片追加，其指针指向了新的、更大的切片。第二个切片没有更新其指针。这就是为什么当第一个切片的值发生变化时，第二个切片没有受到影响。第二个切片不再指向同一个隐藏数组，这意味着它们不再链接。
- en: For the `Cap Link` scenario, the first slice was defined using make and with
    an oversized capacity. This extra capacity meant that when the first slice had
    a value appended to it, there was already extra room in the hidden array. This
    extra capacity means there's no need to replace the hidden array. The effect was
    that when we updated the value on the first slice, it and the second slice were
    still pointing to the same hidden array, meaning the change affects both.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`带链接`场景，第一个切片是使用`make`和过大的容量定义的。这个额外的容量意味着当第一个切片被追加一个值时，隐藏数组中已经有了额外的空间。这个额外的容量意味着不需要替换隐藏数组。结果是，当我们更新第一个切片上的值时，它和第二个切片仍然指向同一个隐藏数组，这意味着更改会影响两者。
- en: In the `Cap No Link` scenario, the setup was the same as the previous scenario,
    but when we appended values, we appended more values than there was available
    capacity. Even though there was extra capacity, there was not enough, and the
    hidden array in the first slice got replaced. The result was that the link between
    the two slices broke.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在`无链接`场景中，设置与上一个场景相同，但在我们追加值时，我们追加的值超过了可用的容量。尽管有额外的容量，但仍然不够，第一个切片中的隐藏数组被替换。结果是，两个切片之间的链接断裂。
- en: In `Copy No Link`, we used the built-in `copy` function to copy the value for
    us. While this does copy the values into a new hidden array, copy won't change
    the length of the slice. This fact means that the destination slice must be the
    correct length before you do the copy. You don't see copy much in real-world code;
    this could be because it's easy to misuse it.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在`无链接`中，我们使用了内置的`copy`函数来为我们复制值。虽然这会将值复制到一个新的隐藏数组中，但`copy`不会改变切片的长度。这个事实意味着在您进行复制之前，目标切片必须具有正确的长度。在现实世界的代码中您很少看到`copy`的使用；这可能是由于它很容易被误用。
- en: 'Lastly, with `Append No Link`, we use `append` to do something similar to `copy`
    but without having to worry about the length. This method is the most commonly
    seen in real-world code when you need to ensure you get a copy of the values that
    are not linked to the source. This is easy to understand since append gets used
    a lot and it''s a one-line solution. There is one slightly more efficient solution
    that avoids the extra memory allocation of the empty slice in the first argument
    of append. You can reuse the first slice by creating a 0-capacity range copy of
    it. This alternative looks as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `Append No Link`，我们使用 `append` 来执行类似于 `copy` 的操作，但无需担心长度。这种方法在现实世界的代码中最为常见，当你需要确保获取到与源不链接的值的副本时。这很容易理解，因为
    `append` 被广泛使用，并且它是一个单行解决方案。还有一个稍微高效一些的解决方案，可以避免在 `append` 的第一个参数中分配空切片的额外内存。你可以通过创建一个
    0 容量的范围副本来重用第一个切片。这个替代方案如下：
- en: '[PRE107]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Can you see something new here? This uses the seldom-used slice range notation
    of `<slice>[<low>:<high>:<capacity>]`. With the current Go compiler, this is the
    most memory-efficient way to copy a slice.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里看到了什么新东西吗？这里使用了很少使用的切片范围表示法 `<slice>[<low>:<high>:<capacity>]`。在当前的 Go 编译器中，这是复制切片最节省内存的方法。
- en: Map Fundamentals
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Map 基础知识
- en: While arrays and slices are similar and can sometimes be interchangeable, Go's
    other collection type, map, is quite different and is not interchangeable with
    array and slice. Go's map type serves a different purpose.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 数组和切片 相似，有时可以互换使用，但 Go 的其他集合类型 map 则相当不同，不能与数组和切片互换。Go 的 map 类型服务于不同的目的。
- en: Go's map is a hashmap in computer science terms. The main difference between
    a map and the other collections types relates to its key. In an array or slice,
    the key is a placeholder, and it has no meaning of its own. It's only there to
    act as a counter and has no direct relationship with the value.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的 map 在计算机科学术语中是一个哈希表。map 与其他集合类型的区别主要在于其键。在数组或切片中，键是一个占位符，它本身没有意义。它仅仅作为计数器存在，与值没有直接关系。
- en: With a map, the key is data – data that has a real relationship with the value.
    For example, you could have a collection of user account records in a map. The
    key would be the users' employee ID. An employee ID is real data and not just
    an arbitrary placeholder. If someone were to give you their employee ID, you'd
    be able to look up their account records without needing to loop over the data
    to find it. With a map, you can set, get, and delete data quickly.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在 map 中，键是数据——与值有真实关系的数据。例如，你可以在 map 中有一个用户账户记录的集合。键将是用户的员工 ID。员工 ID 是真实数据，而不仅仅是一个任意的占位符。如果有人给你他们的员工
    ID，你就能查找到他们的账户记录，而无需遍历数据来找到它。使用 map，你可以快速地设置、获取和删除数据。
- en: 'You can access the individual elements of a map in the same way as you do with
    a slice or array: using `[` and `]`. Maps can have any type that is directly comparable
    as a key, such as an int or a string. You can''t compare slices, so they can''t
    be keys. A map''s value can be of any type, including pointers, slices, and maps.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像访问切片或数组中的单个元素一样访问 map 的单个元素：使用 `[` 和 `]`。map 的键可以是任何可以直接比较的类型，如 int 或 string。你不能比较切片，因此它们不能作为键。map
    的值可以是任何类型，包括指针、切片和 map。
- en: You shouldn't use a map as an ordered list. Even if you were to use an int for
    a map's keys, maps are not guaranteed to always start at index 0, and they are
    not guaranteed to not have any gaps in the keys. This feature could be an advantage,
    even if you did want int keys. If you had sparsely populated data, that is, values
    with gaps between keys, in a slice or array, it would contain lots of zero data.
    In a map, it would only contain the data you set.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该将 map 用作有序列表。即使你打算使用 int 作为 map 的键，map 也不保证始终从索引 0 开始，也不保证键之间没有空隙。即使你想要
    int 键，这个特性也可能是一个优势。如果你有稀疏填充的数据，即在切片或数组中键之间有间隙的值，它将包含大量零数据。在 map 中，它只会包含你设置的数据。
- en: 'To define a map, you use the following notation: `map[<key_type>]<value_type>`.
    You can use `make` to create maps, but the arguments for `make` are different
    when using `make` to create a map. Go can''t create keys for a map, so it''s not
    possible to create a map of an arbitrary length like you can with a slice. You
    can suggest a capacity for the compiler to use for your map. Suggesting the capacity
    for a map is optional, and map can''t be used with `cap` to check what its capacity
    is.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个地图，你使用以下表示法：`map[<key_type>]<value_type>`。你可以使用 `make` 来创建地图，但使用 `make`
    创建地图时的参数是不同的。Go 不能为地图创建键，因此你不能像使用切片那样创建任意长度的地图。你可以建议一个容量，编译器可以使用这个容量来创建你的地图。为地图建议容量是可选的，并且不能使用
    `cap` 来检查其容量。
- en: Maps are like slices in that they are not a value and not a pointer. A map is
    a special construct in Go. You'll need to take the same care when copying the
    variable or the values. Since you can't control or check the capacity of a map,
    they are even more challenging when you want to know what's going to happen when
    you add elements.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 地图就像切片一样，它们既不是值也不是指针。地图是 Go 中的一个特殊构造。在复制变量或值时，你需要采取相同的谨慎。由于你不能控制或检查地图的容量，因此当你想知道添加元素时会发生什么时，它们更具挑战性。
- en: 'Since Go does not help you manage your keys with maps, this means you must
    specify keys when initializing a map with data. It''s the same notation as the
    other collections, that is, `map[<key_type>]<value_type>{<key1>: <value>, … <keyN>:,
    <valueN>}`.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '由于 Go 不使用地图帮助你管理键，这意味着你必须指定键来初始化包含数据的地图。它的表示法与其他集合相同，即 `map[<key_type>]<value_type>{<key1>:
    <value>, … <keyN>: <valueN>}`。'
- en: Once defined, you can set values without needing to worry about the length of
    the map like you do with arrays and slices. Setting a value is just like the other
    collections, that is, `<map>[<key>] = <value>`. Something that you do need to
    do before setting the value of a map is to make sure you've initialized it first.
    If you try to set a value of an uninitialized map, it causes a runtime panic.
    To avoid this, it's good practice to avoid defining a map using `var`. If you
    initialize the map with data or use `make` to create your maps, you won't have
    this problem.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义，你就可以设置值，而无需担心地图的长度，就像你处理数组和切片时那样。设置值就像其他集合一样，即 `<map>[<key>] = <value>`。在设置地图的值之前，你需要确保已经初始化了它。如果你尝试设置未初始化地图的值，会导致运行时恐慌。为了避免这种情况，一个好的做法是避免使用
    `var` 来定义地图。如果你用数据初始化地图或使用 `make` 来创建你的地图，你就不会遇到这个问题。
- en: 'Exercise 4.13: Creating, Reading, and Writing a Map'
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 4.13：创建、读取和写入地图
- en: 'In this exercise, we''re going to define a map with some data and then add
    a new element to it. Finally, we''ll print the map to the console. Let''s get
    started:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个包含一些数据的地图，然后向其中添加一个新元素。最后，我们将打印地图到控制台。让我们开始吧：
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件夹，并向其中添加一个名为 `main.go` 的文件。
- en: 'In `main.go`, add the package and imports:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中，添加包和导入：
- en: '[PRE108]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Create a function that returns a `map` with string keys and string values:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个返回具有字符串键和字符串值的 `map` 的函数：
- en: '[PRE109]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Define a `map` with string keys and string values and then initialize it with
    some elements:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个具有字符串键和字符串值的 `map` 并用一些元素初始化它：
- en: '[PRE110]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Next, we''ll add a new element to the `map`:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向 `map` 中添加一个新元素：
- en: '[PRE111]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Return the `map` and close the function:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 `map` 并关闭函数：
- en: '[PRE112]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'In the `main` function, print the `map` to the console:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，将 `map` 打印到控制台：
- en: '[PRE113]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。然后，在你在 *步骤 1* 中创建的文件夹中，使用以下命令运行代码：
- en: '[PRE114]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '[PRE115]'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: In this exercise, we created a map, initialized it with data, and then added
    a new element. This exercise shows that working with maps is similar to working
    with arrays and slices. When you should use a map comes down to the kinds of data
    you'll store in it and if your access pattern needs access to individual items
    rather than a list of items.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建了一个地图，用数据初始化它，然后添加了一个新元素。这个练习表明，使用地图与使用数组切片类似。当你应该使用地图时，这取决于你将存储在其中的数据类型，以及你的访问模式是否需要访问单个项目而不是项目列表。
- en: Reading from Maps
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从地图中读取
- en: You won't always know whether a key exists in a map before needing to use it
    to get a value. When you're getting a value for a key that doesn't exist in a
    map, Go returns the zero value for the map's value type. Having logic that works
    with zero values is a valid way to program in Go, but that's not always possible.
    If you can't use zero value logic, maps can return an extra return value when
    you need it. The notation looks like `<value>, <exists_value> := <map>[<key>]`.
    Here, `exists` is a Boolean value that is true if a key exists in the map; otherwise,
    it's false. When looping over a map, you should use the `range` keyword. When
    looping over a map, never rely on the order of the items in it. Go doesn't guarantee
    the order of items in a map. To make sure no one replies on the order of the elements,
    Go purposely randomizes the order of them when you range over a map. If you did
    need to loop over the elements of your map in a specific order, you'd need to
    use an array or slice to assist you with that.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.14: Reading from a Map'
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''re going to read from a map using direct access and a
    loop. We''ll also check to see if a key exists in the map. Let''s get started:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Create a function that returns a `map` with a string key and a string value:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Define a `map` and initialize it with data. Then, return the `map` and close
    the function:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'In this function, we''ll accept a string as input. The function will also return
    a string and a Boolean:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Get a copy of the `users` map from our earlier function:'
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Get a value from the `users` maps using the passed in ID as the key. Capture
    both the value and the `exists` value:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Return both values and close the function:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Create the `main` function:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Check that at least one argument gets passed in. If not, exit:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Capture the passed argument and call the get user function:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'If the key is not found, print a message, and then print all the users using
    a `range` loop. After that, exit:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'If everything is okay, print the name we found:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Then, run the following command:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.8: Output displaying all the users and the name that was found'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_04_08.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.8: Output displaying all the users and the name that was found'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned how we can check to see if a key exists in a map.
    It may look a little strange coming from other languages that require you check
    for the existence of a key before getting the value, not after. This way of doing
    things does mean there is much less chance of runtime errors. If a zero value
    is not possible in your domain logic, then you can use that fact to check if a
    key exists.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: We used a `range` loop to print all the users in our map nicely. Your output
    is probably in a different order to the output shown in the preceding screenshot,
    which is due to Go randomizing the order of the elements in a map when you use
    `range`.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 4.04: Slicing the Week'
  id: totrans-464
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we''re going to create a slice and initialize it with some
    data. Then, we''re going to modify that slice using what we''ve learned about
    sub-slices. The following are the steps for this activity:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Go app.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a slice and initialize it with the all the days of the week, starting
    on Monday and ending on Sunday.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the slice using slice ranges and append it so that the week now starts
    on Sunday and ends on Saturday.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the slice to the console.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Note
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 700
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Deleting Elements from a Map
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to remove an element from a map, you'll need to do something different
    than you would with an array or slice. In an array, you can't remove elements
    since the length's fixed; the best you can do is zero out the value. With a slice,
    you can zero out, but it's also possible to use a combination of a slice range
    and append to cut out one or more elements. With a map, you could zero the value
    out, but the element still exists, so it causes problems if you're checking whether
    a key exists in your logic. You can't use slice ranges on a map to cut elements
    out either.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: To remove an element, we need to use the built-in `delete` function. The function
    signature for `delete`, when used with maps, is `delete(<map>, <key>)`. The `delete`
    function doesn't return anything and if a key doesn't exist, nothing happens.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.15: Deleting an Element from a Map'
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll define a map and then delete an element from it using
    user input. Then, we''ll print the now possibly smaller map to the console. Let''s
    get started:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-481
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'We''re going to define our `users` map in the package scope:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Create a function that deletes from the `users` map using a passed in string
    as the key:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'In `main`, we''ll grab the passed in `userID` and print the `users` map to
    the console:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: In this exercise, we used the built-in `delete` function to totally remove an
    element from a map. This requirement is unique for maps; you can't use `delete`
    on arrays or slices.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 4.05: Removing an Element from a Slice'
  id: totrans-493
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go doesn't have anything built in to remove elements from a slice, but it's
    possible with the techniques you've learned. In this activity, we're going to
    set up a slice with some data and with one element to remove. Then, you need to
    work out how to do this. There are many ways to get this done, but can you work
    out the most compact way?
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps for this activity:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Go app.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a slice with the following elements in the following order:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Good
  id: totrans-498
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Good
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Bad
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Good
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Good
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write the code to remove the "Bad" element from the slice.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the result to the console.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  id: totrans-505
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Note
  id: totrans-507
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 701
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Simple Custom Types
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can create custom types using Go's simple types as a starting point. The
    notation is `type <name> <type>`. If we were to create an ID type based on a string,
    this would look like `type id string`. The custom type acts the same as the type
    you based it on, including getting the same zero value and having the same abilities
    to compare with other values of the same type. A custom type is not compatible
    with its base type, but you can convert your custom type back into the type it's
    based on to allow for interaction.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.16: Creating a Simple Custom Type'
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll define a map and then delete an element from it using
    user input. Then, we''ll print the now possibly smaller map to the console. Let''s
    get started:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Define a custom type called `id` based on the string type:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Create a function that returns three ids:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'For `id1`, we''ll initialize it and leave at its zero value:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'For `id2`, we''ll initialize it using a string literal:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Finally, for `id3`, we''ll initialize it to zero and then set a value separately:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Now, return the ids and close the function:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'In `main`, call our function and do some comparisons:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'For this preceding comparison, we''ll convert the id back into a string:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-534
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.9: Output after comparison'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_04_09.jpg)'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.9: Output after comparison'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we created a custom type, set data on it, and then compared
    it with values of the same type and with its base type.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: Simple custom types are a foundation part of modeling the data problems you'll
    see in the real world. Having types designed to reflect the data you need to work
    with closely helps keep your code easy to understand and maintain.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: Structs
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collections are perfect for grouping values of the same type and purpose together.
    There is another way of grouping data together in Go for a different purpose.
    Often, a simple string, number, or Boolean doesn't fully capture the essence of
    the data you'll have.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: For example, for our user map, a user was represented by their unique ID and
    their first name. That is rarely going to be enough details to be able to work
    with user records. The data you could capture about a person is almost infinite,
    such as their given, middle, and family names. Their preferred prefix and suffix,
    their date of birth, their height, weight, or where they work can also be captured.
    It would be possible to store this data in multiple maps, all with the same key,
    but that is hard to work with and maintain.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'The ideal thing to do is collect all these different bits of data into a single
    data structure that you can design and control. That''s what Go''s struct type
    is: it''s a custom type that you can name and specify the field properties and
    their types.'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: 'The notation for structs looks as follows:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Field names must be unique within a struct. You can use any type for a field,
    including pointers, collections, and other structs.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access a field on a struct using the following notation: `<structValue>.<fieldName>`.
    To set a value, you use this notation: `<structValue>.<fieldName> = <value>`.
    To read a value you use the following notation: `value = <structValue>.<fieldName>`.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Structs are the closest thing that Go has to what are called classes in other
    languages, but structs have purposely been kept stripped down by Go's designers.
    A key difference is that structs don't have any form of inheritance. The designers
    of Go feel that inheritance causes more problems than it solves in real-world
    code.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: Once you've defined your custom struct type, you can use it to create a value.
    You have several ways to create values from struct types. Let's take a look at
    them now.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.17: Creating Struct Types and Values'
  id: totrans-550
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''re going to define a user struct. We''ll define some
    fields of different types. Then, we''ll create some struct values using a few
    different methods. Let''s get started:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The first thing we''ll do is define our struct type. You generally do this
    in the package scope. We need to give it a name that''s unique at the package-level
    scope:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'We''ll add some fields of different types and then close the struct definition:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-558
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'We''ll create a function that returns a slice of our newly defined struct type:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Our first user is initialized using this key-value notation. This notation
    is the most common form to use when initializing structs:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'When using the key-value notation, the order of the fields doesn''t matter
    and any you leave out will get a zero value for their type:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'It''s possible to initialize a struct with values only. If you do this, all
    the fields must be present, and their order must match how you defined them in
    the struct:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'This `var` notation will create a struct where all the fields have zero values:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Now, we can set values on the fields using `.` and the field name:'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Now, we will return the values wrapped in a slice and close the function:'
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'In `main`, we''ll get the slice of `users`, loop over it, and print it to the
    console:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.10: Output as per the new struct'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_04_10.jpg)'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.10: Output as per the new struct'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you defined a custom struct type that contained multiple fields,
    each of a different type. Then, we created values from that struct using a few
    different methods. Each of these methods is valid and is useful in different contexts.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: We defined the struct at the package scope, and while it's not typical, you
    can define struct types in the function scope too. If you do define a struct type
    in a function, it'll only be valid for use in that function. When defining a type
    at the package level, it's available for use throughout the package.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also possible to define and initialize a struct at the same time. If
    you do this, you can''t reuse the type, but it''s still a useful technique. The
    notation looks as follows:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: You can also initialize using the key-value notation, but initializing with
    only the values is the most common when this is done.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Structs to Each Other
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If all of a struct's fields are comparable types, then the struct as a whole
    is also comparable. So, if your struct is made up of strings and ints, then you
    can compare whole structs to one another. If your struct has a slice in it, then
    you can't. Go is strongly typed, so you can only compare values of the same type,
    but with structs, there is a little bit of flexibility. If the struct was defined
    anonymously and it has the same structure as a named struct, then Go allows the
    comparison.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.18: Comparing Structs to Each Other'
  id: totrans-588
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll define a comparable struct and create a value with
    it. We''ll also define and create values with anonymous structs that have the
    same structure as our named struct. Finally, we''ll compare them and print the
    results to the console. Let''s get started:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder and add a file named `main.go` to it:'
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Let''s define a simple, comparable struct:'
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Now, we''ll create a function that returns two Booleans:'
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-596
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Create our first anonymous struct:'
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-598
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'With the second anonymous struct, we''re initializing it to zero and then changing
    the value after initialization:'
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-600
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'The final struct to create uses the named struct type we created previously:'
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-602
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Compare them. Then, return and close the function:'
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-604
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'In main, we''ll call our function and print the results:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-608
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.11: Output comparing structs'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_04_11.jpg)'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.11: Output comparing structs'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw that we can work with anonymous struct values in the
    same way as named struct types, including comparing them. With named types, you
    can only compare structs of the same type. When you compare types in Go, Go compares
    all the fields to check for a match. Go is allowing a comparison of these anonymous
    structs to be made because the field names and types match. Go is a little flexible
    with comparing structs like this.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: Struct Composition Using Embedding
  id: totrans-614
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While inheritance is not possible with Go structs, the designers of Go did include
    an exciting alternative. The alternative is to embed types in struct types. Using
    embedding, you can add fields to a struct from other structs. This composition
    feature has the effect of letting you add to a struct using other structs as components.
    Embedding is different than having a field that is a struct type. When you embed,
    the fields from the embedded struct get promoted. Once promoted, a field acts
    as if it's defined on the target struct.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: 'To embed a struct, you add it like you would a field, but you don''t specify
    a name. To do this, you add a struct type name to another struct without giving
    it a field name, which looks like this:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Though not common, you can embed any other type into structs. There is nothing
    to promote, so to access the embedded type, you access it using the type''s name,
    for example, `<structValue>.<type>`. This way of accessing the embedded types
    by their type name is also true for structs. This means there is two valid ways
    to work with an embedded struct''s fields: `<structValue>.<fieldName>` or `<structValue>.<type>.<fieldName>`.
    This ability to access the type by its name also means that the type''s names
    must be unique between the embedded types and the root field names. When embedding
    pointer types, the type''s name is the type without the pointer notation, so the
    name `*<type>` becomes `<type>`. The field is still a pointer, and only the name
    is different.'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to promotion, if you were to have any overlap with your struct's
    field names, Go allows you to embed, but the promotion of the overlapping field
    doesn't happen. You can still access the field by going through the type name
    path.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: You can't use promotion when initializing structs with embedded types. To initialize
    the data, you must use the embedded types name.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.19: Struct Embedding and Initialization'
  id: totrans-621
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll define some structs and custom types. We''ll embed
    those types into a struct. Let''s get started:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Create a custom string type called name:'
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Create a struct called location with two int fields, that is, `x` and `y`:'
  id: totrans-628
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-629
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Create a size struct with two int fields, that is, `width` and `height`:'
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-631
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Create a struct named `dot`. This embeds each of the preceding structs in it:'
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-633
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Create a function that returns a slice of dots:'
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-635
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Our first `dot` uses the `var` notation. This will result in all the fields
    having a zero value:'
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-637
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'With `dot2`, we''re also initializing with zero values:'
  id: totrans-638
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-639
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'To set the name, we use the type''s name as if it were a field:'
  id: totrans-640
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-641
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'For size and location, we''ll use the promoted fields to set their value:'
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'When initializing embedded types, you can''t use promotion. For name, the result
    is the same but for location and size, you need to put more work into this:'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-645
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'For `dot4`, we''ll use the type names to set data:'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Return all the dots in a slice and then close the function:'
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-649
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'In `main`, call the function. Then, loop over the slice and print it to the
    console:'
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-651
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-653
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-654
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.12: Output after struct embedding and initialization'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_04_12.jpg)'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.12: Output after struct embedding and initialization'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we were able to define a complex struct by embedding other
    types into it. Embedding allows you to reuse common structures by reducing the
    duplicated code but still giving your struct a flat API.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: We won't see much embedding in real-world Go code. It does come up, but the
    complexity and exception mean that Go developers prefer to have the other structs
    as named fields.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: Type Conversions
  id: totrans-660
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times when your types won't match up, and with Go's strict type system,
    if types are not the same, they can't interact with one another. In these cases,
    you have two options. If the two types are compatible, you can do type conversion
    – that is, you can create a new value by changing one type to another. The notation
    to do this is `<value>.(<type>)`. When working with strings, we used this notation
    to cast a string to a slice of runes or bytes and back again. This works because
    a string is a special type that stores the string's data as a slice of bytes.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: The string type conversion is losses, but that's not true of all type conversions.
    When working with numeric type conversion, the numbers can change from their original
    value. If you convert from a large `int` type, for example, `int64`, into a smaller
    `int` type, for example, `int8`, it causes the number to overflow. If you were
    to convert from an unsigned int, for example, uint64, into a signed int, for example,
    `int64`, this overflow happens because unsigned ints can store a higher number
    than a signed `int`. This overflowing is the same when converting an `int` into
    a `float` since the `float` splits its storage space between whole numbers and
    decimals. When converting from a `float` to an `int`, the decimal part is truncated.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: It's still perfectly reasonable to do these types of lossy conversions, and
    they happen all the time in real-world code. If you know that the data you're
    dealing with doesn't cross these thresholds, then there's no need to worry.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: Go does its best to guess at the types that need conversion. This is called
    implicit type conversion. For example, `math.MaxInt8` is an `int`, and if you
    try to assign it to a number other than an `int`, Go does an implicit type conversion
    for you.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.20: Numeric Type Conversion'
  id: totrans-665
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll do some numeric type conversion and intentionally
    cause some data issues. Let''s get started:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-669
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Create a function that returns a string:'
  id: totrans-670
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-671
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'Define some variables to do our work. Go is doing an implicit conversion of
    the int `math.MaxInt8` into an `int8`:'
  id: totrans-672
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-673
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'Here, we''ll convert from a smaller `int` type into a larger `int` type. This
    is always a safe operation:'
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-675
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Now, we''ll convert from an `int` that''s 1 above `int8`''s maximum size. This
    will cause an overflow to `int8`''s minimum size:'
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-677
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Next, we''ll convert out `int8` into a `float64`. This doesn''t cause an overflow
    and the data is unchanged:'
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-679
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Here, we''ll convert a float into an `int`. All the decimal data is lost but
    the whole number is kept as is:'
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-681
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'Return the message and then close the function:'
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-683
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'In the `main()` function, call the function and print it to the console:'
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-685
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-687
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-688
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.13: Output after conversion'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_04_13.jpg)'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.13: Output after conversion'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: Type Assertions and interface{}
  id: totrans-692
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve used `fmt.Print` and its siblings a great deal for writing our code,
    but how does a function such as `fmt.Print` take any type of value when Go is
    a strongly typed language? Let''s take a look at the actual Go standard library
    code for `fmt.Print`:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: I hope you can see that looking at Go's source code is not scary – it's a great
    way to see how you should do things and I recommend looking at it whenever you
    are curious about how they do something.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: By looking at this code, we can see that `fmt.Print` has a variadic of the `interface{}`
    type. We'll cover interfaces in more detail later, but for now, what you need
    to know is that an interface in Go describes what functions a type must have to
    conform to that interface. Interfaces in Go don't describe fields and don't describe
    a type's core value, such as being a string or a number. In Go, any type can have
    functions, including strings and numbers. What `interface{}` is describing is
    a type with no functions. What use is a value with no function, no fields, and
    no core value? None, but it's still a value, and it can still be passed around.
    This interface is not setting the type of the value but controlling what values
    it will allow for a variable with that interface. What types in Go conform to
    `interface{}`? All of them! Any of Go's types or any custom type you create conform
    to `interface{}`, and this is how `fmt.Print` can accept any type. You can also
    use `interface{}` in your code to achieve the same result.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your variable that conforms to `interface{}`, what can you do
    with it? Even if the underlying value of your `interface{}` variable has functions,
    fields, or a core value, you can't use them because Go is enforcing the interface's
    contract, which is why this is still all type safe.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: To unlock the capabilities of the value masked by `interface{}`, we need to
    use type assertion. The notation for type assertion is `<value>.(<type>)`. Type
    assertion results in a value of the type that was requested and optionally a bool
    regarding whether it was successful or not. This looks like `<value> := <value>.(<type>)`
    or `<value>, <ok> := <value>.(type)`. If you leave the Boolean value out and type
    assertion fails, Go raises a panic.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: Go doesn't remove anything from a value when you place it in an `interface{}`
    variable. What happens is the Go compiler prevents you from using it because it's
    not able to perform its type-safety checks at compile time. Using type assertion
    is your instruction to Go that you want to unlock the value. When you do type
    assertion, Go performs the type-safety checks it would have done at compile time
    at runtime, and those checks may fail. It's then your responsibility to deal with
    the type-safety checks failing. Type assertions is a feature that causes runtime
    errors and panics, which means you must be extra careful around them.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.21: Type Assertion'
  id: totrans-700
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will perform some type assertions and ensure that all
    the safety checks are in place when we do so. Let''s get started:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-702
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-704
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Create a function that accepts an `interface{}` and returns a string and an
    error:'
  id: totrans-705
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-706
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'First, we''ll check to see if our argument is an int, and if it is, we''ll
    multiply it by `2` and return it:'
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-708
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Here, we''ll check if it''s a string and if it is, we''ll concatenate it to
    itself and return it:'
  id: totrans-709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-710
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'If we don''t get any matches, return an error. Then, close the function:'
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-712
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'In `main`, call `doubler` with a variety of data and print the results to the
    console:'
  id: totrans-713
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-714
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-715
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-716
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-717
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.14: Output showing matches'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_04_14.jpg)'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.14: Output showing matches'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: The combination of `interface{}` and type assertions allows you to overcome
    Go's strict type controls, in turn allowing you to create functions that can work
    with any type of variable. The challenge is that you lose the protection that
    Go gives you at compile time for type safety. It's still possible to be safe,
    but the responsibility is yours now – do it wrong, and you'll get a nasty runtime
    error.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: Type Switch
  id: totrans-722
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we wanted to expand our `doubler` function to include all `int` types, we''d
    end up with a lot of duplicated logic. Go has an excellent way of dealing with
    more complex type assertions situations, known as the type switch. Here''s what
    it looks like:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: The type switch only runs your logic if it matches the type you're looking for,
    and it sets the value to that type. You can match on more than one type in a case,
    but Go can't change the type of the value for you, so you'll still need to do
    type assertion. One of the things that makes this a type switch and not an expression
    switch is the `<value>.(type)` notation. You can only use that as part of a type
    switch. Something else that's unique to type switches is that you can't use the
    `fallthrough` statement.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.22: Type Switch'
  id: totrans-726
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll update our `doubler` function to use a type switch
    and expand its abilities to deal with more types. Let''s get started:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder and add a file named `main.go` to it.
  id: totrans-728
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.go`, add the package and imports:'
  id: totrans-729
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-730
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'Create our function, which takes a single `inferface{}` argument and returns
    a string and an error:'
  id: totrans-731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-732
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'Create a type switch using our argument:'
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-734
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'For `string` and `bool`, since we''re only matching on one type, we don''t
    need to do any extra safety checks and can work with the value directly:'
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'For the floats, we''re matching on more than one type. This means we need to
    do type assertion to be able to work with the value:'
  id: totrans-737
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-738
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'If this type assertion were to fail, we''d get a panic, but we can rely on
    the logic that only `float32` can work directly with the result of type assertion:'
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-740
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'Match all of the `int` and `uint` types. We''ve been able to remove lots of
    code here by not needing to do the type-safety checks ourselves:'
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-742
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'We''ll use the default to return an error. Then, we''ll close the switch statement
    and function:'
  id: totrans-743
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-744
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'In the `main()` function, call our function with even more data and print the
    results to the console:'
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-746
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'Save the file. Then, in the folder you created in *step 1*, run the code using
    the following command:'
  id: totrans-747
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-748
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-749
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.15: Output after calling functions'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_04_15.jpg)'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.15: Output after calling functions'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we used a type switch to build a complex type assertion scenario.
    Using the type switch still gives us full control of the type assertions but also
    lets us simplify the type-safety logic when we don't need that level of control.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 4.06: Type Checker'
  id: totrans-754
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, you''re going to write some logic that has a slice or different
    types of data. These data types are as follows:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: An int
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A float
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bool
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A struct
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a function that accepts a value of any type. The function returns a
    string with the name of the type:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: For int, int32, and int64, it returns `int`.
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all floats, it returns `float`.
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a string, it returns `string`.
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a bool, it returns `bool`.
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For anything else, it returns `unknown`.
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loop all the data by passing each one to your function.
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, print the data and its type name to the console.
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  id: totrans-769
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.16: Expected output'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_04_16.jpg)'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.16: Expected output'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 702
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-775
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got into the advanced uses of variables and types in Go.
    Real-world code gets complicated quickly because the real world is complicated.
    Being able to model the data accurately and keep that data logically organized
    in your code helps reduce the complexity of your code to a minimum.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to group similar data, either in a fixed-length ordered list
    using an array, in a dynamic length ordered list using a slice, or in a key-value
    hash using a map.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: We learned to go beyond Go's core types and start to create custom types based
    either directly on the core types or by creating a struct, which is a collection
    of other types held in a single type and value.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: There are times when you'll have type mismatches, so Go gives us the ability
    to convert compatible types so that they can interact in a type-safe way.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: Go also lets us break free of its type safety rules and gives us full control.
    By using type assertions, we can accept any type using the magic of `interface{}`
    and then get those types back.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll explore how to group our logic into reusable components
    and attach them to our custom types to make our code more straightforward and
    easier to maintain.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
