<html><head></head><body>
		<div>
			<div id="_idContainer079" class="Content">
			</div>
		</div>
		<div id="_idContainer080" class="Content">
			<h1 id="_idParaDest-162"><a id="_idTextAnchor166"/>5. Functions</h1>
		</div>
		<div id="_idContainer094" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter will describe the various parts of a function in detail, such as defining the function, function identifiers, parameter lists, return types, and the function body. We will also look at some best practices when designing our functions, such as a function performing a single task, how to reduce code, making your function small, and ensuring that functions are reusable.</p>
			<p class="callout">By the end of this chapter, you will be able to describe a function and the different parts that make up a function and evaluate the scope of variables with functions. You will learn to create and call a function; utilize variadic and anonymous functions and create closures for various constructs. You will also learn to use functions as parameters and return values; and use <strong class="source-inline">defer</strong> statements with functions.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor167"/>Introduction</h1>
			<p>Functions are a core part of many languages and Go is no exception. A function is a section of code that has been declared to perform a task. Go functions can have zero or more inputs and outputs. One feature that sets Go apart from other programming languages is the multiple return values; most programming languages are limited to one return value.</p>
			<p>In the following section, we will see some features of Go functions that differ from other languages, such as returning multiple types. We will also see that Go has support for first-class functions. This means that Go has the ability to assign a variable to a function, pass a function as an argument, and have a function as a return type for a function. We will show how functions can be used to break up complex parts into smaller parts.</p>
			<p>Functions in Go are considered first-class citizens and higher-order functions. First-class citizens are the functions that are assigned to a variable. Higher-order functions are functions that can take a function as an argument. The rich features of Go functions empower them to be used in various segments in the following ways:</p>
			<ul>
				<li>Functions to be passed as an argument to another function</li>
				<li>Return a function as a value from a function</li>
				<li>Functions as a type</li>
				<li>Closures</li>
				<li>Anonymous functions </li>
				<li>Functions assigned to a variable</li>
			</ul>
			<p>We will be looking at each of these features that are supported in Go.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor168"/>Functions</h1>
			<p>Functions are a critical part of Go and we should understand their place. Let's examine some of the reasons for using functions:</p>
			<ul>
				<li><strong class="bold">Breaking up a complex task</strong>: Functions are used to perform a task, but if that task is complicated, it should then be broken down into smaller tasks. Functions can be used for small tasks to solve a bigger problem. Smaller tasks are more manageable, and using a function to solve specific tasks will make the entire code base easier to maintain.</li>
				<li><strong class="bold">Reducing code</strong>: A good indication that you should use a function is when you see similar code repeating throughout your program. When you have duplicate code, it increases the difficulty of maintenance. If you have one change to make, you will have multiple instances where your code needs to change.</li>
				<li><strong class="bold">Reusability</strong>: Once you have defined your function, you can use it repeatedly. It can also be used by other programmers. This sharing of functions will also reduce lines of code and save time by allowing you to not have to reinvent the wheel. There are a couple of guidelines we should follow when we design functions:</li>
				<li><strong class="bold">Single responsibility</strong>: A function should perform one task. For example, a single function should not calculate the distance between two points and estimate the time to travel between those two points. There should be a function for each of those tasks. This allows for better testing of that function and easier maintenance. It is difficult to narrow a function to perform a single task, so do not get discouraged if you do not get it right the first time. Even seasoned programmers struggle with assigning a single responsibility to a function.</li>
				<li><strong class="bold">Small in size</strong>: Functions should not span over hundreds of lines of code. This is an indication that the code needs some refactoring. When we have large functions, it's more likely that the single responsibility principle will be violated. A good rule of thumb is trying to limit the function size to approximately 25 lines of code; however, that's not a hard-and-fast rule. The benefit of keeping the code concise is that it reduces the complexity of debugging a large function. It also makes writing unit tests with better code coverage easier.</li>
			</ul>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor169"/>Parts of a function</h2>
			<p>We will now be looking at the different components involved in defining a function. The following is the typical layout of a function:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B14177_05_01.jpg" alt="Figure 5.1: Different parts of a function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1: Different parts of a function</p>
			<p>The different parts of a function are described here:</p>
			<ul>
				<li><strong class="bold">func</strong>: In Go, the function declaration starts with the <strong class="source-inline">func</strong> keyword.</li>
				<li><strong class="bold">Identifier</strong>: This is also referred to as the function name. It is idiomatic in Go to use camelCase for the function name. camelCase is the practice of having the first letter of the function name in lowercase and the first letter of each word following in upper case. Examples of function names that follow this convention include <strong class="source-inline">calculateTax</strong>, <strong class="source-inline">totalSum</strong>, and <strong class="source-inline">fetchId</strong>.<p>The identifier should be something descriptive that makes the code easy to read and makes the purpose of the function easy to understand. The identifier is n<a id="_idTextAnchor170"/>ot required. You can have a function with no name; this is known as an anonymous function. Anonymous functions will be discussed in detail in a later part of the chapter.</p><p class="callout-heading">Note</p><p class="callout">When the first letter of the function name is in lowercase, then the function is not exportable outside of a package. This means they are private and cannot be called from outside the package. They can only be called within the package.</p><p class="callout">Keep this in mind when you use camelCase naming convention. If you want your function to be exportable, the first letter of the function name must be capitalized.</p></li>
				<li><strong class="bold">Parameter list</strong>: Parameters are input values to a function. A parameter is data that is required by the function to help solve the task of the function. Parameters are defined as follows: name, type. An example parameter list could be (<strong class="source-inline">name string</strong>, <strong class="source-inline">age int</strong>). Parameters are local variables to the function.<p>Parameters are optional for a function. It is possible to not have any parameters for a function. A function can have zero or more parameters.</p><p>When two or more parameters have the same type, you can use what is called shorthand parameter notation. This removes specifying the same type for each parameter. For instance, if your parameters are (<strong class="source-inline">firstName string</strong>, <strong class="source-inline">lastName string</strong>), they can be shortened to (<strong class="source-inline">firstName</strong>, <strong class="source-inline">lastName string</strong>). This reduces the verbosity of the parameter inputs and increases the readability of the function parameter list.</p></li>
				<li><strong class="bold">Return types</strong>: Return types are a list of data types, such as Boolean, string, map, or another function that can be returned.<p>In the context of declaring a function, we refer to these types as return types. However, in the context of calling a function, they are called return values.</p><p>Return types are the output of the function. Often, they are the result of the arguments provided to the function. They are optional. Most programming languages return a single type; in Go, you can return multiple types.</p></li>
				<li><strong class="bold">Function body</strong>: The function body is the coding statements between curly braces, <strong class="source-inline">{}</strong>.<p>The statements in the function are what determine what the function does. The function code is the code that is being used to perform the task that the function was created to accomplish.</p><p>If there were return types defined, then a <strong class="source-inline">return</strong> statement is required in the function body. The <strong class="source-inline">return</strong> statement causes the function to immediately stop and return the value types listed after the <strong class="source-inline">return</strong> statement. The types in the return type list and in the <strong class="source-inline">return</strong> statement must match.</p><p>In the function body, there can be multiple <strong class="source-inline">return</strong> statements.</p></li>
				<li><strong class="bold">Function signature</strong>: Though not listed in the preceding code snippet, a function signature is a term that references the input parameters combined with the return types. Both of those units make up a function signature.<p>Often, when you define the function signature when it is being used by others, you want to strive to not make changes to it as this can adversely impact your code and the code of others.</p></li>
			</ul>
			<p>We will be diving deep into each of the parts of a function as we progress through the chapter. These parts of a function will become easier to understand through the following discussion, so don't worry if you do not quite understand all the parts yet. It will become clearer as we go through the chapter.</p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor171"/>fizzBuzz</h1>
			<p>Now that we have looked at the different parts of the function, let's see how these parts work with various examples. Let's start with a classical programming game called <strong class="source-inline">fizzBuzz</strong>. The rules of <strong class="source-inline">fizzBuzz</strong> are straightforward. The <strong class="source-inline">fizzBuzz</strong> function prints out various messages based on some math results. The rules perform one of the actions based on the number given:</p>
			<ul>
				<li>If the number is divisible by <strong class="source-inline">3</strong>, print <strong class="source-inline">Fizz</strong>.</li>
				<li>If the number is divisible by <strong class="source-inline">5</strong>, print <strong class="source-inline">Buzz</strong>.</li>
				<li>If the number is divisible by <strong class="source-inline">15</strong>, print <strong class="source-inline">FizzBuzz</strong>.</li>
				<li>Else, print the number.</li>
			</ul>
			<p>The following is the code snippet to achieve this output:</p>
			<p class="source-code">func fizzBuzz() {</p>
			<p class="source-code">    for i := 1; i &lt;= 30; i++ {</p>
			<p class="source-code">        if i%15 == 0 {</p>
			<p class="source-code">            fmt.Println("FizzBuzz")</p>
			<p class="source-code">        } else if i%3 == 0 {</p>
			<p class="source-code">            fmt.Println("Fizz")</p>
			<p class="source-code">        } else if i%5 == 0 {</p>
			<p class="source-code">            fmt.Println("Buzz")</p>
			<p class="source-code">        } else {</p>
			<p class="source-code">            fmt.Println(i)</p>
			<p class="source-code">        }</p>
			<p class="source-code">    } </p>
			<p class="source-code">}</p>
			<p>Let's look at the code in sections now:</p>
			<p class="source-code">func fizzBuzz() {</p>
			<ul>
				<li><strong class="source-inline">func</strong>, as you may recall, is the keyword to declare a function. This informs Go that the following piece of code is going to be a function.</li>
				<li><strong class="source-inline">fizzBuzz</strong> is the name of our function. It is idiomatic in Go to use a camelCase name.</li>
				<li><strong class="source-inline">()</strong>, the parenthesis following the name of our function, is empty: our current implementation of the <strong class="source-inline">FizzBuzz</strong> game does not require any input parameters.</li>
				<li>The space between the parameter list, <strong class="source-inline">()</strong>, and the opening brace would be the return type. Our current implementation does not require a return type.</li>
				<li>Regarding <strong class="source-inline">{</strong>, unlike other programming languages that you may know, Go requires that the opening curly brace is on the same line as the function declaration. If the opening brace is not on the same line as the function signature when you attempt to run the program, you will get an error.<p class="source-code">for i := 1; i &lt;= 30; i++ {</p><p>The preceding line is a <strong class="source-inline">for</strong> loop that increments the <strong class="source-inline">i</strong> variable from <strong class="source-inline">1</strong> to <strong class="source-inline">30</strong>:</p><p class="source-code">if i<strong class="bold">%</strong>15 == 0 {</p></li>
				<li><strong class="source-inline">%</strong> is a modulus operator; it gives the remainder of the two integers being divided. Using our function, if <strong class="source-inline">i</strong> is <strong class="source-inline">15</strong>, then <strong class="source-inline">15%15</strong> will return zero. We use the modulus operator to determine whether <strong class="source-inline">i</strong> is evenly divisible by <strong class="source-inline">3</strong>, <strong class="source-inline">5</strong>, or <strong class="source-inline">15</strong>.<p class="callout-heading">Note</p><p class="callout">As we become more familiar with Go concepts and language syntax, the explanation of the code will exclude items that we would otherwise be going over multiple times.</p></li>
			</ul>
			<p>We have now defined our function. It has a specific task we want it to perform, but it doesn't do any good if we do not execute the function. So, how do we execute a function? We must call our function. When we call a function, we are telling our program to execute the function. We will be calling our function inside the <strong class="source-inline">main()</strong> function.</p>
			<p>Functions can call other functions. When this occurs, control is given to the function that was called. After the called function has returned data or reached the ending curly brace, <strong class="source-inline">}</strong>, control is given back to the caller. Let's see an example to understand this better:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  fmt.Println("Main is in control")</p>
			<p class="source-code">  fizzBuzz()</p>
			<p class="source-code">  fmt.Println("Back to main")</p>
			<p class="source-code">}</p>
			<ul>
				<li><strong class="source-inline">}fmt.Println("Main is in control")</strong>: This <strong class="source-inline">print</strong> statement is for demonstration purposes. It shows that we are in the <strong class="source-inline">main()</strong> function.</li>
				<li><strong class="source-inline">fizzBuzz()</strong>: We are now calling the function inside the <strong class="source-inline">main()</strong> function. Even though there are no parameters for our function the parentheses are still required, control of the program is given to the <strong class="source-inline">fizzBuzz()</strong> function. After the <strong class="source-inline">fizzBuzz()</strong> function completes, control is then given back to the <strong class="source-inline">main()</strong> function.</li>
				<li><strong class="source-inline">fmt.Println("Back to main")</strong>: The <strong class="source-inline">print</strong> statement is for demonstration purposes to show that control has been given back to the <strong class="source-inline">main()</strong> function.<p>The output will be as follows:</p></li>
			</ul>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B14177_05_02.jpg" alt="Figure 5.2: Output for fizzBuzz&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2: Output for fizzBuzz</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The parentheses following the <strong class="source-inline">fizzBuzz</strong> function are still required even though there are no input parameters. If they are omitted, the Go compiler will generate an error that states <strong class="source-inline">fizzBuzz</strong> evaluated but not used. This is a common error.</p>
			<p>Th<a id="_idTextAnchor172"/>e output will be as follows:</p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B14177_05_03.jpg" alt="Figure 5.3: Output for fizzBuzz without parentheses&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3: Output for fizzBuzz without parentheses</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor173"/>Exercise 5.01: Creating a Function to Print Salesperson Expectation Ratings from the Number of Items Sold</h2>
			<p>In this exercise, we will be creating a function that will not have any parameters or return types. The function will iterate over a map and print the name and number of items sold in the map. It will also print a statement based on how the salesperson performed based on their sales. The following steps will help you with the solution:</p>
			<ol>
				<li>Use the IDE of your choice.</li>
				<li>Create a new file and save it as <strong class="source-inline">main.go</strong>.</li>
				<li>Enter the following code in <strong class="source-inline">main.go</strong>. The first function that <strong class="source-inline">main</strong> will call on <strong class="source-inline">printAge()</strong>; it does not have any parameters and has no return values:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">)</p><p class="source-code">func main() {</p><p class="source-code">  itemsSold()</p><p class="source-code">}</p></li>
				<li>We will now define our function for printing the age and a message about the age of the person:<p class="source-code">func itemsSold() {</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">itemsSold()</strong> function, initialize a map that will have a key-value pair of <strong class="source-inline">string</strong>, <strong class="source-inline">int</strong>. The map will hold a <strong class="source-inline">name</strong>(<strong class="source-inline">string</strong>) and the number of <strong class="source-inline">items</strong>(<strong class="source-inline">int</strong>) sold. The name is the key for the map. We assign various names to number of items sold:<p class="source-code">  items := make(map[string]int)</p><p class="source-code">  items["John"] = 41</p><p class="source-code">  items["Celina"] = 109</p><p class="source-code">  items["Micah"] = 24</p></li>
				<li>We iterate over the <strong class="source-inline">items</strong> map and assign <strong class="source-inline">k</strong> to the <strong class="source-inline">key</strong>(<strong class="source-inline">name</strong>) and <strong class="source-inline">v</strong> to the <strong class="source-inline">value</strong>(<strong class="source-inline">items</strong>):<p class="source-code">  for k, v := range items{</p></li>
				<li>We print out the <strong class="source-inline">Name</strong> and the number of sold <strong class="source-inline">items</strong>:<p class="source-code">    fmt.Printf("%s sold %d items and ", k, v)</p></li>
				<li>Depending on the value of <strong class="source-inline">v</strong>(<strong class="source-inline">items</strong>), we will determine the statement we print:<p class="source-code">    if v &lt; 40 {</p><p class="source-code">      fmt.Println("is below expectations.")</p><p class="source-code">    } else if v &gt; 40 &amp;&amp; v &lt;= 100 {</p><p class="source-code">      fmt.Println("meets expectations.")</p><p class="source-code">    } else if v &gt; 100 {</p><p class="source-code">      fmt.Println("exceeded expectations.")</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Open your terminal and navigate to the code's directory.</li>
				<li>Run <strong class="source-inline">go build</strong> and then run the executable.<p>The expected output is as follows:</p><p class="source-code">John sold 41 items and meets expectations.</p><p class="source-code">Celina sold 109 items and exceeded expectations.</p><p class="source-code">Micah sold 24 items and is below expectations.</p></li>
			</ol>
			<p>In this exercise, we saw some of the fundamental parts of a function. We demonstrated how to declare a function using the <strong class="source-inline">func</strong> keyword, followed by how to give our function an identifier or name such as <strong class="source-inline">itemsSold()</strong>. We then proceed to add code to the function body. In the next topics, we will expand on these core parts of the function and learn how to pass data into a function using parameters.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is best to type the code into an IDE. The benefit is that if you type something incorrectly, you will see the error message and can perform some debugging to solve the problem.</p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor174"/>Parameters</h1>
			<p>Parameters define what arguments can be passed to our function. Functions can have zero or more parameters. Even though Go allows us to define multiple parameters, we should take care not to have a huge parameter list; that would make the code harder to read. It also may be an indication that the function is doing more than one specific task. If that is the case, we should refactor the function. Take, for example, the following code snippet:</p>
			<p class="source-code">func calculateSalary(lastName string, firstName string, age int, state string, country string, hoursWorked int, hourlyRate, isEmployee bool) {</p>
			<p class="source-code">// code</p>
			<p class="source-code">}</p>
			<p>The preceding code is an example of a function whose parameter list is bloated. The parameter list should pertain only to the single responsibility of the function. We should only define the parameters that are needed to solve the specific problem that the function is built for.</p>
			<p>Parameters are the input types that our function will use to perform its task. Function parameters are local to the function, meaning they are only available to that function. They are not available outside of the context of the function. Also, the order of the parameters must match the parameter types in the correct sequence.</p>
			<p><strong class="bold">Correct:</strong></p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  greeting("Cayden", 45)</p>
			<p class="source-code">}</p>
			<p class="source-code">func greeting(name string, age int) {</p>
			<p class="source-code">  fmt.Printf("%s is %d",name, age)</p>
			<p class="source-code">}</p>
			<p>The output when the correct parameter matches would be as follows:</p>
			<p class="source-code">Cayden is 45</p>
			<p><strong class="bold">Incorrect:</strong></p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  greeting(45,"Cayden")</p>
			<p class="source-code">  }</p>
			<p class="source-code">func greeting(name string, age int) {</p>
			<p class="source-code">  fmt.Printf("%s is %d",name, age)</p>
			<p class="source-code">}</p>
			<p>The output looks as follows:</p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B14177_05_04.jpg" alt="Figure 5.4: Output for incorrect parameter matching&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.4: Output for incorrect parameter matching</p>
			<p>In the incorrect version of the code, we are calling the <strong class="source-inline">greeting()</strong> function with the <strong class="source-inline">age</strong> argument of type <strong class="source-inline">integer</strong> when the parameter is of type <strong class="source-inline">string</strong>. The sequence of your arguments must match the sequence of the parameter input list.</p>
			<p>Additionally, users would want to have more control over the data the code iterates over. Going back to the <strong class="source-inline">fizzBuzz</strong> example, the current implementation only does <strong class="source-inline">1</strong> to <strong class="source-inline">100</strong>. Users may need to work on different number ranges and hence we need a way to decide the ending range of the loop. We can change our <strong class="source-inline">fizzBuzz</strong> function to accept an input parameter. This would meet the needs of our user:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  fizzBuzz(10)</p>
			<p class="source-code">}</p>
			<p class="source-code">func fizzBuzz(end int) {</p>
			<p class="source-code">  for i := 1; i &lt;= end; i++ {</p>
			<p class="source-code">    if i%15 == 0 {</p>
			<p class="source-code">      fmt.Println("FizzBuzz")</p>
			<p class="source-code">    } else if i%3 == 0 {</p>
			<p class="source-code">      fmt.Println("Fizz")</p>
			<p class="source-code">    } else if i%5 == 0 {</p>
			<p class="source-code">      fmt.Println("Buzz")</p>
			<p class="source-code">    } else {</p>
			<p class="source-code">      fmt.Println(i)</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The preceding code snippet can be explained as follows:</p>
			<ul>
				<li>For <strong class="source-inline">fizzBuzz(10)</strong> in the <strong class="source-inline">main()</strong> function, we pass <strong class="source-inline">10</strong> as an argument to our <strong class="source-inline">fizzBuzz</strong> function.</li>
				<li>For <strong class="source-inline">fizzBuzz(end int)</strong>, <strong class="source-inline">topEnd</strong> is the name of our parameter and it is of type <strong class="source-inline">int</strong>.</li>
				<li>Our function now will only iterate up to the value of our end parameter; in this example, it will iterate to <strong class="source-inline">10</strong>.</li>
			</ul>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor175"/>The Difference between an Argument and a Parameter</h2>
			<p>This is a good time to discuss the difference between an argument and a parameter. When you are defining your function, using our example, <strong class="source-inline">fizzBuzz</strong>(<strong class="source-inline">end int</strong>) is called a parameter. When you call a function, such as <strong class="source-inline">fizzBuzz(10)</strong>, 10 is called the argument. Also, the argument and parameter names do not need to match.</p>
			<p>Functions in Go also can have more than one parameter defined. We need to add another parameter to our <strong class="source-inline">fizzBuzz</strong> function to accommodate this enhancement:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  s:= 10</p>
			<p class="source-code">  e:= 20</p>
			<p class="source-code">fizzBuzz(s,e)</p>
			<p class="source-code">}</p>
			<p class="source-code">func fizzBuzz(start int, end int) {</p>
			<p class="source-code">  for i := start; i &lt;= end; i++ {</p>
			<p class="source-code">  // code omitted for brevity</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The preceding code snippet can be explained as follows:</p>
			<ul>
				<li>Regarding <strong class="source-inline">fizzBuzz(s,e)</strong>, we are now passing two arguments to the <strong class="source-inline">fizzBuzz</strong> function. When there are multiple arguments, they must be separated by a comma.</li>
				<li>Regarding <strong class="source-inline">func fizzBuzz</strong>(<strong class="source-inline">start int</strong>, <strong class="source-inline">end int</strong>), when multiple parameters are defined in a function, they are separated by commas, following the convention of name type, name type, name type, and so on.</li>
			</ul>
			<p>Our <strong class="source-inline">fizzBuzz</strong> parameters are more verbose than what is necessary. When we have multiple input parameters of the same type, you can separate the input name by a comma followed by the type. This is referred to as shorthand parameter notation. See the following example of using shorthand parameter notation:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  s,e := 10,20</p>
			<p class="source-code">  fizzBuzz(s,e)</p>
			<p class="source-code">}</p>
			<p class="source-code">func fizzBuzz(start,end int) {</p>
			<p class="source-code">  // code…</p>
			<p class="source-code">}</p>
			<p>The preceding code snippet can be explained as follows:</p>
			<ul>
				<li>There is no change to the caller when using shorthand parameter notation.</li>
				<li>Regarding <strong class="source-inline">fizzBuzz</strong>(<strong class="source-inline">start</strong>,<strong class="source-inline">end int</strong>), <strong class="source-inline">start</strong> and <strong class="source-inline">end</strong> are of type <strong class="source-inline">int</strong>. Nothing needs to change in the body of the function to accommodate the shorthand parameter notation.</li>
			</ul>
			<h2 id="_idParaDest-170">Exer<a id="_idTextAnchor176"/>cise 5.02: Mapping Index Values to Column Headers</h2>
			<p>The function that we are going to create will be taking a slice of column headers from a CSV file. It will print out a map of an index value of the headers we are interested in:</p>
			<ol>
				<li value="1">Open the IDE of your choice.</li>
				<li>Create a new file and save it <strong class="source-inline">main.go</strong>.</li>
				<li>Enter the following code in <strong class="source-inline">main.go</strong>: <p class="source-code">pack<a id="_idTextAnchor177"/>age main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "strings"</p><p class="source-code">)</p><p class="source-code">func main() {</p><p class="source-code">  hdr :=[]string{"empid","employee","address","hours worked","hourly rate",     "manager"}</p><p class="source-code">  csvHdrCol(hdr)</p><p class="source-code">  hdr2 :=[]string{"employee","empid","hours worked","address",     "manager","hourly rate"}</p><p class="source-code">  csvHdrCol(hdr2)</p><p class="source-code">}</p><p class="source-code">func csvHdrCol   (header []string) {</p><p class="source-code">        csvHeadersToColumnIndex:= make(map[int]string)</p><p>First, we assign a variable to a key-value pair of <strong class="source-inline">int</strong> and <strong class="source-inline">string</strong>. <strong class="source-inline">key</strong>(<strong class="source-inline">int</strong>) will be the index of our <strong class="source-inline">header</strong>(<strong class="source-inline">string</strong>) column. The index will map to a column header.</p></li>
				<li>We range over the <strong class="source-inline">header</strong> to process each string that is in the slice:<p class="source-code">for i, v := range header {</p></li>
				<li>For each string, remove any trailing spaces in front of and after the string. In general, we should always make the assumption that our data may have some erroneous characters:<p class="source-code"> v = strings.TrimSpace(v)</p></li>
				<li>In our <strong class="source-inline">switch</strong> statement, we lower all the casing for exact matches. As you may recall, Go is a case-sensitive language. We need to ensure that the casing is the same for matching purposes. When our code finds the header, it sets the index value for the header in the map:<p class="source-code">                switch strings.ToLower(v) {</p><p class="source-code">                case "employee":</p><p class="source-code">                        csvHeadersToColumnIndex[i] = v</p><p class="source-code">                case "hours worked":</p><p class="source-code">                        csvHeadersToColumnIndex[i] = v</p><p class="source-code">                case "hourly rate":</p><p class="source-code">                        csvHeadersToColumnIndex[i] = v</p><p class="source-code">      }</p><p class="source-code">  }</p></li>
				<li>Typically, we would not print out the results. We should return the <strong class="source-inline">csvHeadersToColumnIndex</strong>, but since we have not gone over how to return a value, we will print it for now:<p class="source-code">       fmt.Println(csvHeadersToColumnIndex)</p><p class="source-code">}</p></li>
				<li>Open your terminal and navigate to the code's directory.</li>
				<li>Run <strong class="source-inline">go build</strong> and run the executable.<p>The expected output is as follows:</p><p class="source-code">Map[1:employee 3:hours worked 4: hourly rate]</p><p class="source-code">Map[0:employee 2:hours worked 5: hourly rate]</p></li>
			</ol>
			<p>In this exercise, we saw how to accept data into a function, by defining a parameter for our function. The callers of our function were able to pass arguments to the function. We will continue to discover various abilities that functions in Go can provide. We have seen how to get data into our function. In the next section, we will see how to get data out of our function. </p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor178"/>Function Variable Scope</h2>
			<p>When designing functions, we need to consider the variable scope. The scope of a variable determines where the variable is accessible or visible to the different parts of the application. Variables declared inside the function are considered local variables. This means that they are only accessible to the code within the body of the function. You cannot access variables from outside of the function. The calling function does not have access to variables inside the called function. The input parameter's scope is the same as the local variable's scope to the function.</p>
			<p>Variables declared in the calling function are scoped to that function. This means that the variables are local to the function and those variables are not accessible outside of the function. Our function cannot reach into the calling function's variables. To get access to those variables, they must be passed into our function as input parameters:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  m:= "Uncle Bob"</p>
			<p class="source-code">  greeting()</p>
			<p class="source-code">}</p>
			<p class="source-code">func greeting() {</p>
			<p class="source-code">  fmt.Printf("Greeting %s", m)</p>
			<p class="source-code">}</p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B14177_05_05.jpg" alt="Figure 5.5: Error output for the m variable being undefined&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5: Error output for the m variable being undefined</p>
			<p>The previous code snippet will result in an error in <strong class="source-inline">func greeting()</strong> that states that <strong class="source-inline">m</strong> is undefined. That is because the <strong class="source-inline">m</strong> variable is declared inside <strong class="source-inline">main()</strong>. The <strong class="source-inline">greeting()</strong> function does not have access to the <strong class="source-inline">m</strong> variable. For it to have access to, the <strong class="source-inline">m</strong> variable must be passed to the <strong class="source-inline">greeting()</strong> function as an input parameter:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  m:= "Uncle Bob"</p>
			<p class="source-code">  greeting(m)</p>
			<p class="source-code">  fmt.Printf("Hi from main: %s", s)</p>
			<p class="source-code">}</p>
			<p class="source-code">func greeting(name string) {</p>
			<p class="source-code">  fmt.Printf("Greeting %s",name)</p>
			<p class="source-code">  s:= "Slacker"</p>
			<p class="source-code">  fmt.Printf("Greeting %s",s)</p>
			<p class="source-code">}</p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B14177_05_06.jpg" alt="Figure 5.6: Error output for the s variable being undefined&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.6: Error output for the s variable being undefined</p>
			<p>The previous code snippet will result in an error in <strong class="source-inline">func main()</strong>. The error will state that <strong class="source-inline">s</strong> is undefined. This is because the <strong class="source-inline">s</strong> variable is declared in the <strong class="source-inline">greeting()</strong> function. The <strong class="source-inline">main()</strong> function does not have access to the <strong class="source-inline">s</strong> variable. The <strong class="source-inline">s</strong> variable is only visible to code inside the function body of <strong class="source-inline">greeting()</strong>.</p>
			<p>These are just some considerations that we need to keep in mind when we are declaring and accessing variables. It is important to understand the scope of the variables inside a function in relation to the variables declared outside of a function. It can cause some confusion when you are trying to access variables but you are not scoped to the context that you are trying to access. The examples in this chapter should help you in understanding the scope of variables.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor179"/>Return Values</h2>
			<p>So far, the functions that we have created do not have any return values. Functions typically accept inputs, perform some action on those inputs, and then return the results of those inputs. Most programming languages return only one value. Go allows you to return multiple values from a function. This is one of the features of Go functions that distinguishes it from other programming languages.</p>
			<h2 id="_idParaDest-173">Exerci<a id="_idTextAnchor180"/>se 5.03: Creating a fizzBuzz Function with Return Values</h2>
			<p>We are going to make some enhancements to our <strong class="source-inline">fizzBuzz</strong> function. We are going to change it so that it accepts only an integer. We will leave the onus on the caller to perform the looping if they desire to do so. Also, we are going to have two returns. The first will be the number provided and the corresponding text of empty string, <strong class="source-inline">fizz</strong>, <strong class="source-inline">buzz</strong>, or <strong class="source-inline">fizzbuzz</strong>. The following steps will help you with the solution.</p>
			<ol>
				<li value="1">Open the IDE of your choice.</li>
				<li>Create a new file and save it at <strong class="source-inline">$GOPATH\functions\fizzBuzzreturn\main.go</strong>.</li>
				<li>In the <strong class="source-inline">main()</strong> function, assign variables to the return values of our function. The <strong class="source-inline">n,</strong> <strong class="source-inline">s</strong> variables correspond respectively to the values being returned from our function, <strong class="source-inline">int</strong>, <strong class="source-inline">string</strong>:<p class="source-code">func main() {</p><p class="source-code">  for i := 1; i &lt;= 15; i++ {</p><p class="source-code">    n, s := fizzBuzz(i)</p><p class="source-code">    fmt.Printf("Results:  %d %s\n", n, s)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">fizzBuzz</strong> function now returns two values; the first being an <strong class="source-inline">int</strong>, followed by a string.<p class="source-code">func fizzBuzz(i int) (int, string) {</p><p class="source-code">  switch {</p></li>
				<li>Simplify the <strong class="source-inline">if{}else{}</strong> statements by replacing them with a <strong class="source-inline">switch</strong> statement. As you are writing code, you should look for ways to simplify things and make the code more readable. <strong class="source-inline">case i%15 ==0</strong> is equivalent to our previous <strong class="source-inline">if i%15 == 0</strong> statements. Instead of our previous <strong class="source-inline">fmt</strong>. <strong class="source-inline">Println()</strong> statements, replace them with <strong class="source-inline">return</strong>. The <strong class="source-inline">return</strong> statement will immediately stop the execution of the function and return the results to the caller:<p class="source-code">  case i%15 == 0:</p><p class="source-code">    return i, "FizzBuzz"</p><p class="source-code">  case i%3 == 0:</p><p class="source-code">    return i, "Fizz"</p><p class="source-code">  case i%5 == 0:</p><p class="source-code">    return i, "Buzz"</p><p class="source-code">  }</p><p class="source-code">  return i, ""</p><p class="source-code">}</p><p>The expected output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B14177_05_07.jpg" alt="Figure 5.7: Output for the fizzBuzz function with return values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7: Output for the fizzBuzz function with return values</p>
			<p>In this exercise, we saw how we can return multiple values from a function. We were able to assign variables to the multiple return values from the function. We also noticed that the assigned variables to the function match the order of the return values. In the following section, we will learn that in the body of the function, we can perform naked returns, where we do not need to specify the variable being returned in our return statement.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor181"/>Activity 5.01: Calculating the Working Hours of Employees</h2>
			<p>In this activity, we shall be creating a function that will calculate the working hours of employees for a week, which shall be used to calculate the payable salary amount. The <strong class="source-inline">developer</strong> struct has a field called <strong class="source-inline">Individual</strong> that is of type <strong class="source-inline">Employee</strong>. The <strong class="source-inline">developer</strong> struct keeps track of the <strong class="source-inline">HourlyRate</strong> that they charge and how many hours they work each day. The following steps shall help you to reach the solution:</p>
			<ol>
				<li value="1">Create an <strong class="source-inline">Employee</strong> type that has the following fields: <strong class="source-inline">Id</strong> as <strong class="source-inline">int</strong>, <strong class="source-inline">FirstName</strong> as <strong class="source-inline">string</strong>, and <strong class="source-inline">LastName</strong> as <strong class="source-inline">string</strong>.</li>
				<li>Create a <strong class="source-inline">developer</strong> type that has the following fields: <strong class="source-inline">Individual Employee</strong>, <strong class="source-inline">HourlyRate</strong> <strong class="source-inline">int</strong>, and <strong class="source-inline">WorkWeek</strong> <strong class="source-inline">[7]int</strong>.</li>
				<li>Create an <strong class="source-inline">enum</strong> for the seven days of the week. This will be of type <strong class="source-inline">Weekday</strong> <strong class="source-inline">int</strong> with a constant declaration for each day of the week.</li>
				<li>Create a pointer receiver method called <strong class="source-inline">LogHours</strong> for <strong class="source-inline">Developer</strong> that will take the <strong class="source-inline">WeekDay</strong> type and <strong class="source-inline">int</strong> type as input. Assign the hours worked that day to the <strong class="source-inline">Developer</strong> workweek slice.</li>
				<li>Create a method that is a pointer receiver called <strong class="source-inline">HoursWorked()</strong>. This method will return the total hours that have been worked.</li>
				<li>In the <strong class="source-inline">main()</strong> function, initialize and create a variable of the <strong class="source-inline">Developer</strong> type.</li>
				<li>In the <strong class="source-inline">LogHours</strong> method, call the method for two days (such as Monday and Tuesday).</li>
				<li>Print the hours for the two days of the previous step.</li>
				<li>Next, print the results of the <strong class="source-inline">HoursWorked</strong> method.<p>The following is the expected output:</p><p class="source-code">Hours worked on Monday:  8</p><p class="source-code">Hours worked on Tuesday:  10</p><p class="source-code">Hours worked this week:  18</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 704.</p></li>
			</ol>
			<p>The aim of this activity is to demonstrate the ability to break problems down into manageable tasks to be implemented by functions, such that each of our functions has a single responsibility. <strong class="source-inline">LogHours</strong> is responsible for assigning the hours worked for each day. <strong class="source-inline">HoursWorked</strong> uses the values that were assigned in <strong class="source-inline">LogHours</strong> to display the hours worked each day. We have used return types from our functions to display the data. This exercise demonstrates utilizing functions correctly to provide a solution to a problem.</p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor182"/>Naked Returns</h1>
			<p class="callout-heading">Note</p>
			<p class="callout">Functions that have return values must have a <strong class="source-inline">return</strong> statement as the last statement in the function. If you omit the return statement, the Go compiler will give you the following error: "missing return at the end of function."</p>
			<p class="callout">Typically, when a function returns two types, the second type is of type <strong class="source-inline">error</strong>. We have not gone over errors yet so in these examples, we are not demonstrating them. It is good to know that it is idiomatic in Go for the second return type to be of type <strong class="source-inline">error</strong>.</p>
			<p>Go also allows the ability to ignore a variable being returned. For example, say we are not interested in the <strong class="source-inline">int</strong> value that is being returned from our <strong class="source-inline">fizzBuzz</strong> function. In Go, we can use what is called a blank identifier; it provides a way to ignore values in an assignment:</p>
			<p class="source-code">_, err<a id="_idTextAnchor183"/> := file.Read(bytes)</p>
			<p>For example, when reading a file, we might not be concerned about the number of bytes read. So, in that case, we can ignore the value being returned by using the blank identifier, "<strong class="source-inline">_</strong>". When there is extra data being returned from a function that does not provide any information that is needed by our program, such as the reading of a file, it is a good candidate for ignoring the return.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As you will discover later, many functions return an error as the second return value. You should not ignore return values from functions that are errors. Ignoring an error returned by a function could result in unexpected behavior. Error return values should be handled appropriately.</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  for i := 1; i &lt;= 15; i++ {</p>
			<p class="source-code">    _, s := fizzBuzz(i)</p>
			<p class="source-code">    fmt.Printf("Results: %s\n",s)</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>In the preceding example, we are using the blank identifier, <strong class="source-inline">_</strong>, to ignore the <strong class="source-inline">int</strong> value being returned:</p>
			<p class="source-code">    _, s := fizzBuzz(i)</p>
			<p>You must always have a placeholder for the values being returned when assigning values from a function. When performing an assignment, the placeholders must match the number of return values from the function. <strong class="source-inline">_</strong> and <strong class="source-inline">s</strong> are the placeholders for the return values of <strong class="source-inline">int</strong> and <strong class="source-inline">string</strong>.</p>
			<p>Go also has a feature that allows you to name your returns. If you use this feature, it can make your code more readable as well as self-documenting. If you name your return variables, they are under the same constraints as the local variables, as discussed in the previous topic. By naming your returns, you are creating local variables in the function. You can then assign values to those return variables, just as you do with input parameters:</p>
			<p class="source-code">func greeting() (name string, age int){</p>
			<p class="source-code">  name = "John"</p>
			<p class="source-code">  age = 21</p>
			<p class="source-code">  return name, age</p>
			<p class="source-code">}</p>
			<p>In the preceding code, (<strong class="source-inline">name string</strong>, <strong class="source-inline">age int</strong>) are named returns. They are now local variables to the function.</p>
			<p>Since <strong class="source-inline">name</strong> and <strong class="source-inline">age</strong> are local variables that were declared in the return list of the function, you can now assign values to them. They can be treated as local variables. In the <strong class="source-inline">return</strong> statement, specify the return values. If you do not specify the variable name in the return, it is called a <strong class="bold">naked return</strong>:</p>
			<p class="source-code">func greeting() (name string, age int){</p>
			<p class="source-code">  name = "John"</p>
			<p class="source-code">  age = 21</p>
			<p class="source-code">  return </p>
			<p class="source-code">}</p>
			<p>Consider the preceding code block. This code is the same as before with the exception that the return does not name the variables to return. The <strong class="source-inline">return</strong> statement will return the variables that are named in the return list.</p>
			<p>One of the disadvantages of naked returns is that it can cause confusion when reading code. To avoid confusion and the possibility of other issues, it is recommended that you avoid using the naked returns feature. It can make it difficult to follow the variable that is to be returned. There can also be issues with shadowing when using naked returns:</p>
			<p class="source-code">func message() (message string, err error) {</p>
			<p class="source-code">  message = "hi"</p>
			<p class="source-code">  if message == "hi"{</p>
			<p class="source-code">    err := fmt.Errorf("say bye\n")</p>
			<p class="source-code">    return</p>
			<p class="source-code">  }</p>
			<p class="source-code">  return</p>
			<p class="source-code">}</p>
			<p>The preceding code will result in the following error:</p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B14177_05_08.jpg" alt="Figure 5.8: Output for shadowing with naked returns&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.8: Output for shadowing with naked returns</p>
			<p>That is because the <strong class="source-inline">err</strong> variable is named in the <strong class="source-inline">return</strong> and is initialized in an <strong class="source-inline">if</strong> statement. Recall that variables that are initialized within curly braces, such as <strong class="source-inline">for</strong> loops, <strong class="source-inline">if</strong> statements, and <strong class="source-inline">switch</strong> statements, are scoped to that context, meaning that they are only visible and accessible within those curly braces.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor184"/>Exercise 5.04: Mapping a CSV Index to a Column Header with Return Values</h2>
			<p>In <em class="italic">Exercise 5.02</em>, <em class="italic">Mapping Index Values to Column Headers</em>, we only printed the results of the index to the column header. In this exercise, we are going to return the map as the result. The map being returned is the index-to-column header mapping. The following steps will help you with the solution:</p>
			<ol>
				<li value="1">Open the IDE of your choice.</li>
				<li>Open the file from the previous exercise: <strong class="source-inline">$GOPATH\functions\indxToColHdr\main.go</strong>.</li>
				<li>Enter the following code in <strong class="source-inline">main.go</strong>:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "strings"</p><p class="source-code">)</p></li>
				<li>Next, in the <strong class="source-inline">main()</strong> function, define the headers for the columns. First, we assign a variable to a key-value pair of <strong class="source-inline">int</strong> and <strong class="source-inline">string</strong>. <strong class="source-inline">key(int)</strong> will be the index of our <strong class="source-inline">header(string)</strong> column. The index will map to a column header:<p class="source-code">func main() {</p><p class="source-code">  hdr := []string{"empid", "employee", "address", "hours worked", "hourly     rate", "manager"}</p><p class="source-code">  result := csvHdrCol(hdr)</p><p class="source-code">  fmt.Println("Result:")</p><p class="source-code">  fmt.Println(result)</p><p class="source-code">  fmt.Println()</p><p class="source-code">  hdr2 := []string{"employee", "empid", "hours worked", "address",     "manager", "hourly rate"}</p><p class="source-code">  result2 := csvHdrCol(hdr2)</p><p class="source-code">  fmt.Println("Result2:")</p><p class="source-code">  fmt.Println(result2)</p><p class="source-code">  fmt.Println()</p><p class="source-code">}</p><p class="source-code">func csvHdrCol(hdr []string) map[int]string {</p><p class="source-code">  csvIdxToCol := make(map[int]string)</p></li>
				<li>We range over the <strong class="source-inline">header</strong> to process each string that is in the slice:<p class="source-code">for i, v := range hdr {</p></li>
				<li>For each string, we remove any trailing spaces in front of and after the string. In general, we should always make the assumption that our data may have some erroneous characters:<p class="source-code">v = strings.TrimSpace(v)</p></li>
				<li>In our <strong class="source-inline">switch</strong> statement, we lower all the casing for exact matches. As you may recall, Go is a case-sensitive language. We need to ensure the casing is the same for matching purposes. When our code finds the header, it sets the index value for the header in the map:<p class="source-code">switch strings.ToLower(v) {</p><p class="source-code">    case "employee":</p><p class="source-code">      csvIdxToCol[i] = v</p><p class="source-code">    case "hours worked":</p><p class="source-code">      csvIdxToCol[i] = v</p><p class="source-code">    case "hourly rate":</p><p class="source-code">      csvIdxToCol[i] = v</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">  return csvIdxToCol</p><p class="source-code">}</p></li>
				<li>Open up a terminal and navigate to the code's directory.</li>
				<li>Run <strong class="source-inline">go build</strong> and run the executable.<p>The expected output for return values is as follows:</p><p class="source-code">Result1:</p><p class="source-code">Map[1:employee 3:hours worked 4: hourly rate]</p><p class="source-code">Result2:</p><p class="source-code">Map[0:employee 2:hours worked 5: hourly rate]</p></li>
			</ol>
			<p>In this exercise, we saw a real-world example of mapping a CSV index to column headers. We used a function to solve this complex problem. We were able to have the function have a single return value of type <strong class="source-inline">map</strong>. In the next section, we are going to see how functions can accept a variable number of argument values within a single argument.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor185"/>Variadic Function</h2>
			<p>A variadic function is a function that accepts a variable number of argument values. It is good to use a variadic function when the number of arguments of a specified type is unknown.</p>
			<p class="source-code">func f(parameterName …Type)</p>
			<p>The preceding function is an example of what a variadic function looks like. The three dots (<strong class="source-inline">…</strong>) in front of the type is called a <strong class="bold">pack operator</strong>. The pack operator is what makes it a variadic function. It tells Go to store all the arguments of <strong class="source-inline">Type</strong> into <strong class="source-inline">parameterName</strong>. The variadic variable can accept zero or more variables as the argument:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  nums(99,100)</p>
			<p class="source-code">  nums(200)</p>
			<p class="source-code">  nums()</p>
			<p class="source-code">}</p>
			<p class="source-code">func nums(i ...int) {</p>
			<p class="source-code">  fmt.Println(i)</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">nums</strong> function is a variadic function that accepts a type of <strong class="source-inline">int</strong>. As stated before, you can pass zero or more arguments of the type. If there is more than one value, you separate them with a comma, as in <strong class="source-inline">nums(99,100)</strong>. If there is only one argument to pass, you only pass that argument, as in <strong class="source-inline">nums(200)</strong>. If there isn't an argument to pass, you can leave it empty, as in <strong class="source-inline">nums()</strong>.</p>
			<p>Variadic functions can have other parameters. However, if your function requires multiple parameters, the variadic parameter must be the last parameter in the function. Also, there can only be one variadic variable per function. The following function is incorrect and will result in an error at compile time.</p>
			<p><strong class="bold">Incorrect function:</strong></p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  nums(99, 100,"James")</p>
			<p class="source-code">}</p>
			<p class="source-code">func nums(i ...int,str person) {</p>
			<p class="source-code">  fmt.Println(str)</p>
			<p class="source-code">  fmt.Println(i)</p>
			<p class="source-code">}</p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B14177_05_09.jpg" alt="Figure 5.9: Variadic syntax error output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.9: Variadic syntax error output</p>
			<p><strong class="bold">Correct function:</strong></p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  nums("James",99, 100)</p>
			<p class="source-code">}</p>
			<p class="source-code">func nums(str string, i ...int) {</p>
			<p class="source-code">  fmt.Println(str)</p>
			<p class="source-code">  fmt.Println(i)</p>
			<p class="source-code">}</p>
			<p>The output would look as follows:</p>
			<p class="source-code">James</p>
			<p class="source-code">[99 100]</p>
			<p>You may have guessed by now that the actual type of <strong class="source-inline">Type</strong> inside the function is a slice. The function takes the arguments being passed in and converts them to the new slice being specified. For example, if the variadic type is <strong class="source-inline">int</strong>, then once you are inside the function, Go converts that variadic <strong class="source-inline">int</strong> to a slice of integers:</p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B14177_05_10.jpg" alt="Figure 5.10: Conversion of a variadic int into a slice of integers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.10: Conversion of a variadic int into a slice of integers</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  nums(99, 100)</p>
			<p class="source-code">}</p>
			<p class="source-code">func nums(i ...int) {</p>
			<p class="source-code">  fmt.Println(i)</p>
			<p class="source-code">  fmt.Printf("%T\n", i)</p>
			<p class="source-code">  fmt.Printf("Len: %d\n", len(i))</p>
			<p class="source-code">  fmt.Printf("Cap: %d\n", cap(i))</p>
			<p class="source-code">}</p>
			<p>The variadic function's output is as follows:</p>
			<p class="source-code">[99 100]</p>
			<p class="source-code">[] int</p>
			<p class="source-code">Len: 2</p>
			<p class="source-code">Cap: 2</p>
			<p>The <strong class="source-inline">nums()</strong> function is showing that the variadic type of <strong class="source-inline">i</strong> is a slice of integers. Once in the function, <strong class="source-inline">i</strong> will be a slice of integers. The variadic type has length and capacity, which is to be expected for a slice. In the next code snippet, we will try to pass a slice of integers to a variadic function, <strong class="source-inline">nums()</strong>:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  i := []int{5,10,15}</p>
			<p class="source-code">  nums(i)</p>
			<p class="source-code">}</p>
			<p class="source-code">func nums(i ...int) {</p>
			<p class="source-code">  fmt.Println(i)</p>
			<p class="source-code">}</p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B14177_05_11.jpg" alt="Figure 5.11: Variadic function error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.11: Variadic function error</p>
			<p>Why didn't this code snippet work? We just proved that the variadic variable inside the function is of type <strong class="source-inline">slice</strong>. The reason is that the function is expecting a list of arguments of type <strong class="source-inline">int</strong> to be converted to a slice. Variadic functions work by converting the arguments passed to a slice of the type being specified. However, Go has a mechanism for passing a slice to a variadic function. We need to use the unpack operator; it is three dots (<strong class="source-inline">…</strong>). When you call a variadic function and you want to pass a slice as an argument to a variadic parameter, you need to place the three dots before the variable:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  i := []int{5,10,15}</p>
			<p class="source-code">  nums(i…)</p>
			<p class="source-code">}</p>
			<p class="source-code">func nums(i ...int) {</p>
			<p class="source-code">  fmt.Println(i)</p>
			<p class="source-code">}</p>
			<p>The difference between this version of the function and the previous is the calling code to the function, <strong class="source-inline">nums</strong>. The three dots are put after the <strong class="source-inline">i</strong> variable is a slice of integers. This allows a slice to be passed to the variadic function.</p>
			<h2 id="_idParaDest-178">Exercise 5.<a id="_idTextAnchor186"/>05: Summing Numbers</h2>
			<p>In this exercise, we are going to sum up a variable number of arguments. We will pass the arguments as a list of arguments and as a slice. The return value will be an <strong class="source-inline">int</strong>, the sum of the values we passed to the function. The following steps will help you with the solution:</p>
			<ol>
				<li value="1">Open the IDE of your choice.</li>
				<li>Create a new file and save it at <strong class="source-inline">$GOPATH\functions\variadic\main.go</strong>.</li>
				<li>Enter the following code in <strong class="source-inline">main.go</strong>:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">)</p><p class="source-code">func main() {</p><p class="source-code">  i := []int{5, 10, 15}</p><p class="source-code">  fmt.Println(sum(5, 4))</p><p class="source-code">  fmt.Println(sum(i...))</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">sum</strong> function accepts a variadic argument of type <strong class="source-inline">int</strong>. Since it gets converted to a slice, we can range over the values and return the sum of all the values that get passed:<p class="source-code">func sum(nums ...int) int {</p><p class="source-code">  total := 0</p><p class="source-code">  for _, num := range nums {</p><p class="source-code">    total += num</p><p class="source-code">  }</p><p class="source-code">  return total</p><p class="source-code">}</p></li>
				<li>Open up a terminal and navigate to the code's directory.</li>
				<li>Run <strong class="source-inline">go build</strong> and run the executable.<p>The expected output for summing numbers is as follows:</p><p class="source-code">9</p><p class="source-code">30</p></li>
			</ol>
			<p>In this exercise, we saw that by using a variadic parameter, we can accept an unknown number of arguments. Our function allows us to sum up any number of integers. We can see that variadic parameters can be utilized to solve specific problems where the number of values of the same type being passed as an argument is unknown. In the next section, we are going to look at how to create a function without a name and assign a function to a variable.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor187"/>Anonymous Functions</h2>
			<p>So far, we have been using named functions. As you may recall, named functions are functions that have an identifier or a function name. Anonymous functions can be declared within another function.</p>
			<p>Anonymous functions, also referred to as function literals, are functions that do not have a function name, hence the name "anonymous functions." An anonymous function is declared in a similar way to how a named function is declared. The only difference with the declaration is that the name for the function is omitted. Anonymous functions can do basically whatever a normal function in Go does, including accepting arguments and returning values.</p>
			<p>In this section, we will be introducing the fundamentals of anonymous functions and some of their basic uses. Later, you will also see how anonymous functions can be fully utilized. Anonymous functions are used for and in conjunction with the following:</p>
			<ul>
				<li>Closure implementations</li>
				<li>defer statements</li>
				<li>Defining a code block to be used with a Goroutine</li>
				<li>Defining a function for one-time use</li>
				<li>Passing a function to another function<p>The following is a basic declaration for an anonymous function:</p><p class="source-code">func main() {</p><p class="source-code">  func() {</p><p class="source-code">    fmt.Println("Greeting")</p><p class="source-code">  }()</p><p class="source-code">}</p></li>
				<li>Notice that we are declaring a function inside another function. As with named functions, you must start with the <strong class="source-inline">func</strong> keyword to declare a function.</li>
				<li>Following the <strong class="source-inline">func</strong> keyword would normally be the name of the function, but with anonymous functions, there is no function name. Instead, there are empty parentheses.</li>
				<li>The empty parentheses following the <strong class="source-inline">func</strong> keyword is where the function's parameters would be defined for the function.</li>
				<li>Next is the open curly brace, <strong class="source-inline">{</strong>, which starts the function body.</li>
				<li>The function body is only a one-liner; it will print "<strong class="source-inline">Greeting</strong>".</li>
				<li>The closing curly brace, <strong class="source-inline">}</strong>, denotes the end of the function.</li>
				<li>The last set of parentheses are called the execution parentheses. These parentheses invoke the anonymous function. The function will execute immediately. Later, we will see how to execute an anonymous function at a later location within the function.<p>You can also pass arguments to an anonymous function. To be able to pass arguments to an anonymous function, they must be supplied in the execution parentheses:</p><p class="source-code">func main() {</p><p class="source-code">  message := "Greeting"</p><p class="source-code">  func(str string) {</p><p class="source-code">    fmt.Println(str)</p><p class="source-code">  }(message)</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">func (str string)</strong>: The anonymous function being declared has an input parameter of type <strong class="source-inline">string</strong>.</li>
				<li><strong class="source-inline">} (message)</strong>: The argument message being passed to the execution parentheses.</li>
			</ul>
			<p>We have currently been executing anonymous functions at the moment they are declared, but there are other ways to execute anonymous functions. You can also save the anonymous function to a variable. This leads to a different set of opportunities that we will look at in this chapter:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  f := func() {</p>
			<p class="source-code">    fmt.Println("Executing an anonymous function using a variable")</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Println("Line after anonymous function")</p>
			<p class="source-code">  f()</p>
			<p class="source-code">}</p>
			<ul>
				<li>We are assigning the <strong class="source-inline">f</strong> variable to our anonymous function.</li>
				<li><strong class="source-inline">f</strong> is now of type <strong class="source-inline">func()</strong>.</li>
				<li><strong class="source-inline">f</strong> now can be used to invoke the anonymous function, in a fashion similar to that for a named function. You must include the <strong class="source-inline">()</strong> after the <strong class="source-inline">f</strong> variable to execute the function.</li>
			</ul>
			<h2 id="_idParaDest-180">Exercise 5.<a id="_idTextAnchor188"/>06: Creating an Anonymous Function to Calculate the Square Root of a Number</h2>
			<p>Anonymous functions are great for small snippets of code that you want to execute within a function. Here, we are going to create an anonymous function that is going to have an argument passed to it. It will then calculate the square root. The following steps will help you with the solution:</p>
			<ol>
				<li value="1">Use the IDE of your choice.</li>
				<li>Create a new file and save it at <strong class="source-inline">$GOPATH\functions\anonymousfnc\main.go</strong>.</li>
				<li>Enter the following code in <strong class="source-inline">main.go</strong>. We are assigning our <strong class="source-inline">x</strong> variable to our anonymous function. Our anonymous function takes a parameter, (<strong class="source-inline">i int</strong>). It also returns a value of <strong class="source-inline">int</strong>:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">	"fmt"</p><p class="source-code">)</p><p class="source-code">func main() {</p><p class="source-code">  j := 9</p><p class="source-code">  x := func(i int)int {</p><p class="source-code">    return i * i</p><p class="source-code">  }</p></li>
				<li>Notice that the last curly brace does not have the <strong class="source-inline">()</strong> to execute the function. We call our anonymous function using <strong class="source-inline">x(j)</strong>:<p class="source-code">fmt.Printf("The square of %d is %d\n", j, x(j))</p><p class="source-code">}</p></li>
				<li>Open up a terminal and navigate to the code's directory.</li>
				<li>Run <strong class="source-inline">go build</strong> and run the executable.<p>The expected output is as follows:</p><p class="source-code">The square of 9 is 81</p></li>
			</ol>
			<p>In this exercise, we saw how to assign a variable to a function and later call that function by using the variable that was assigned to it. We saw that when we need a small function that might not be reusable in our program, we can create an anonymous function and assign it to a variable. In the next section, we are going to expand the use of anonymous functions into closures.</p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor189"/>Closures</h1>
			<p>We have introduced anonymous function syntax using some basic examples. Now that we have a fundamental understanding of how anonymous functions work, we will look at how we can use this powerful concept. Closures are a form of anonymous functions. Regular functions cannot reference variables outside of themselves; however, an anonymous function can reference variables external to their definition. A closure can use variables declared at the same level as the anonymous function's declared. These variables do not need to be passed as parameters. The anonymous function has access to these variables when it is called:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  i := 0</p>
			<p class="source-code">  incrementor := func() int {</p>
			<p class="source-code">    i +=1</p>
			<p class="source-code">    return i</p>
			<p class="source-code">    }</p>
			<p class="source-code">  fmt.Println(incrementor())</p>
			<p class="source-code">  fmt.Println(incrementor())</p>
			<p class="source-code">  i +=10</p>
			<p class="source-code">  fmt.Println(incrementor())</p>
			<p class="source-code">}</p>
			<p><strong class="bold">Code synopsis:</strong></p>
			<ol>
				<li value="1">We initialize a variable in the <strong class="source-inline">main()</strong> function called <strong class="source-inline">i</strong> and set it to <strong class="source-inline">0</strong>.</li>
				<li>We assign <strong class="source-inline">incrementor</strong> to our anonymous function.</li>
				<li>The anonymous function increments <strong class="source-inline">i</strong> and returns it. Notice that our function does not have any input parameters.</li>
				<li>We then print the results of <strong class="source-inline">incrementor</strong> twice and get <strong class="source-inline">1</strong> and <strong class="source-inline">2</strong>.</li>
				<li>Notice that outside our function we increment <strong class="source-inline">i</strong> by <strong class="source-inline">10</strong>. This is a problem. We want <strong class="source-inline">i</strong> to be isolated and for it not to change, as this is not the desired behavior. When we print the results of <strong class="source-inline">incrementor</strong> again, it will be <strong class="source-inline">12</strong>. We want it to be <strong class="source-inline">3</strong>. We will correct this in our next example.</li>
			</ol>
			<p>One problem with the previous example that we notice is that any code in the main function has access to <strong class="source-inline">i</strong>. As we saw in the example, <strong class="source-inline">i</strong> can be accessed and changed outside of our function. This is not the desired behavior; we want the incrementor to be the only one to change that value. In other words, we want <strong class="source-inline">i</strong> to be protected from other functions changing it. The only function that should be changing it is our anonymous function when we call it:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  increment := incrementor()</p>
			<p class="source-code">  fmt.Println(increment())</p>
			<p class="source-code">  fmt.Println(increment())</p>
			<p class="source-code">}</p>
			<p class="source-code">func incrementor() func() int {</p>
			<p class="source-code">  i :=0</p>
			<p class="source-code">  return func() int {</p>
			<p class="source-code">    i += 1</p>
			<p class="source-code">    return i</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p><strong class="bold">Code synopsis:</strong></p>
			<ol>
				<li value="1">We declared a function called <strong class="source-inline">incrementor()</strong>. This function has a return type of <strong class="source-inline">func()</strong> <strong class="source-inline">int</strong>. </li>
				<li><strong class="source-inline">i := 0</strong>: We initialize our variable at the level of the <strong class="source-inline">incrementor()</strong> function; this is similar to what we did in the previous example, except it was at the <strong class="source-inline">main()</strong> function level and anyone at that level had access to <strong class="source-inline">i</strong>. Only the <strong class="source-inline">incrementor()</strong> function has access to the <strong class="source-inline">i</strong> variable with this implementation.</li>
				<li>We are returning our anonymous function, <strong class="source-inline">func()</strong> <strong class="source-inline">int</strong>, which increments the <strong class="source-inline">i</strong> variable.</li>
				<li>In the <strong class="source-inline">main()</strong> function, <strong class="source-inline">increment:=incrementor()</strong> assigns a variable to the <strong class="source-inline">func()</strong> <strong class="source-inline">int</strong> that gets returned. It is important to note that <strong class="source-inline">incrementor()</strong> only gets executed once here. In our <strong class="source-inline">main()</strong> function, it is no longer being referenced or executed.</li>
				<li><strong class="source-inline">Increment()</strong> is of type <strong class="source-inline">func()</strong> <strong class="source-inline">int</strong>. Each call to <strong class="source-inline">increment()</strong> runs the anonymous function code. It is referencing the <strong class="source-inline">i</strong> variable, even after <strong class="source-inline">incrementor()</strong> has executed.</li>
			</ol>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor190"/>Exercise 5.07: Creating a Closure Function to Decrement a Counter</h2>
			<p>In this exercise, we are going to create a closure that decrements from a given starting value. We are combining what we have learned about passing an argument to an anonymous function and using that knowledge with a closure. The following steps will help you with the solution:</p>
			<ol>
				<li value="1">Open the IDE of your choice.</li>
				<li>Create a new file and save it at <strong class="source-inline">$GOPATH\closureFnc\variadic\main.go</strong>.</li>
				<li>Enter the following code in <strong class="source-inline">main.go</strong>:<p class="source-code">func main() {</p><p class="source-code">import "fmt"</p><p class="source-code">  counter := 4</p></li>
				<li>We will look at the <strong class="source-inline">decrement</strong> function first. It takes an argument of type <strong class="source-inline">int</strong> and has a return value of <strong class="source-inline">func()int</strong>. In previous examples, the variable was declared inside the function but before the anonymous function. In this exercise, we have it as an input parameter:<p class="source-code">x:= decrement(counter)</p><p class="source-code">  fmt.Println(x())</p><p class="source-code">  fmt.Println(x())</p><p class="source-code">  fmt.Println(x())</p><p class="source-code">  fmt.Println(x())</p><p class="source-code">}</p></li>
				<li>We decrement <strong class="source-inline">i</strong> by one inside the anonymous function:<p class="source-code">func decrement(i int) func() int {</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, we initialize a variable counter to be used as our starting integer to be decremented:<p class="source-code">return func() int {</p></li>
				<li><strong class="source-inline">x:= decrement(counter)</strong> : <strong class="source-inline">x</strong> is assigned to <strong class="source-inline">func()</strong> <strong class="source-inline">int</strong>. Each call to <strong class="source-inline">x()</strong> runs the anonymous function:<p class="source-code">    i --</p><p class="source-code">    return i</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Open up a terminal and navigate to the code's directory.</li>
				<li>Run <strong class="source-inline">go build</strong> and run the executable.<p>The expected output for the <strong class="source-inline">decrement</strong> counter is as follows:</p><p class="source-code">3</p><p class="source-code">2</p><p class="source-code">1</p><p class="source-code">0</p></li>
			</ol>
			<p>In this exercise, we saw that closures have access to variables that are external to them. This allowed our anonymous function to make changes to the variable that a normal function would not be able to make. In the next section, we are going to look at how functions can be passed as arguments to another function.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor191"/>Function Types</h2>
			<p>As we have seen so far, Go has rich feature support for functions. In Go, functions are types too, just like <strong class="source-inline">int</strong>, <strong class="source-inline">string</strong>, and <strong class="source-inline">bool</strong> are types. This means we can pass functions as arguments to other functions, functions can be returned from a function, and functions can be assigned to variables. We can even define our own function types. A function's type signature defines the types of its input parameters and return values. For a function to be of the type of another function, it must have the exact signature of the type function that is declared. Let's examine a few function types:</p>
			<p class="source-code">type message func()</p>
			<p>The preceding code snippet creates a new function type called message. It has no input parameters and does not have any return types.</p>
			<p>Let's examine another one:</p>
			<p class="source-code">type calc func(int, int) string</p>
			<p>The preceding code snippet creates a new function type called calc. It accepts two arguments of type int and its return value is of type string.</p>
			<p>Now that we have a fundamental understanding of function types, we can write some code to demonstrate their uses:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">type calc func(int, int) string</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  calculator(add, 5, 6)</p>
			<p class="source-code">}</p>
			<p class="source-code">func add(i, j int) string {</p>
			<p class="source-code">  result := i + j</p>
			<p class="source-code">  return fmt.Sprintf("Added %d + %d = %d", i, j, result)</p>
			<p class="source-code">}</p>
			<p class="source-code">func calculator(f calc, i, j int) {</p>
			<p class="source-code">  fmt.Println(f(i, j))</p>
			<p class="source-code">}</p>
			<p>Let's look at the code by the line:</p>
			<p class="source-code">type calc func(int, int) string</p>
			<p><strong class="source-inline">type calc</strong> declares <strong class="source-inline">calc</strong> to be of type <strong class="source-inline">func</strong>, determining that it takes two integers as arguments and returns a string:</p>
			<p class="source-code">func add(i, j int) string {</p>
			<p class="source-code">  result := i + j</p>
			<p class="source-code">  return fmt.Sprintf("Added %d + %d = %d", i, j, result)</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">func add(i,j int) string</strong> has the same signature as type <strong class="source-inline">calc</strong>. It takes two integers as arguments and returns a string stating "Adding <strong class="source-inline">i + j = result</strong>". Functions can be passed to other functions just like any other type in Go:</p>
			<p class="source-code">func calculator(f calc, i, j int) {</p>
			<p class="source-code">  fmt.Println(f(i, j))</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">func calculator(f calc, i, j int)</strong> accepts type <strong class="source-inline">calc</strong> as input. The <strong class="source-inline">calc</strong> type, as you may remember, is a function type that has input parameters of <strong class="source-inline">int</strong> and a return type of <strong class="source-inline">string</strong>. Anything that matches that signature can be passed to the function. The <strong class="source-inline">func calculator</strong> function returns the result of the function of type <strong class="source-inline">calc</strong>.</p>
			<p>In the <strong class="source-inline">main</strong> function, we call <strong class="source-inline">calculator</strong>(<strong class="source-inline">add</strong>,<strong class="source-inline">5</strong>,<strong class="source-inline">6</strong>). We are passing it the <strong class="source-inline">add</strong> function. <strong class="source-inline">add</strong> satisfies the signature of type <strong class="source-inline">calc func</strong>.</p>
			<p><em class="italic">Figure 5.12</em> summarizes each of the preceding functions and how they relate to each other. The figure shows how <strong class="source-inline">func add</strong> is of type <strong class="source-inline">func calc</strong>, which then allows it to be passed as an argument to <strong class="source-inline">func calculator</strong>:</p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B14177_05_12.jpg" alt="Figure 5.12: Function types and uses&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.12: Function types and uses</p>
			<p>We have just seen how to create a function type and pass it as an argument to a function. It is not that far of a stretch to pass a function as a parameter to another function. We will change our previous example slightly to reflect passing a function as a parameter:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  calculator(add,5,6)</p>
			<p class="source-code">  calculator(subtract,10,5)</p>
			<p class="source-code">}</p>
			<p class="source-code">func calculator(f func(int,int)int, i, j int) {</p>
			<p class="source-code">  fmt.Println(f(i, j))</p>
			<p class="source-code">}</p>
			<p class="source-code">func add(i, j int) int {</p>
			<p class="source-code">  return i + j</p>
			<p class="source-code">}</p>
			<p class="source-code">func subtract(i, j int) int {</p>
			<p class="source-code">  return i - j</p>
			<p class="source-code">}</p>
			<ul>
				<li>We modify the <strong class="source-inline">add</strong> function signature to return an <strong class="source-inline">int</strong> instead of a string.</li>
				<li>We added a second function called <strong class="source-inline">subtract</strong>. Note that its function signature is the same as that of the <strong class="source-inline">add</strong> function. The <strong class="source-inline">subtract</strong> function simply returns the result of subtracting two numbers:<p class="source-code">func calculator(f func(int,int)int, i, j int) {</p><p class="source-code">  fmt.Println(f(i, j))</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">calculator(f func(int,int)int,i,j int)</strong>: The <strong class="source-inline">calculator</strong> function now has an input parameter of type <strong class="source-inline">func</strong> The input parameter, <strong class="source-inline">f</strong>, is a function that accepts two integers and returns an <strong class="source-inline">int</strong>. Any function that satisfies the signature can be passed to the function.</li>
				<li>In the <strong class="source-inline">main()</strong> function, <strong class="source-inline">calculator</strong> is called twice: once with the <strong class="source-inline">add</strong> function and some integer values being passed and once with the <strong class="source-inline">subtract</strong> function being passed as an argument with some integer values.</li>
			</ul>
			<p>The ability to pass functions as a type is a very powerful feature that can pass different functions to other functions as long as their signatures match the passed-to function's input parameter. It is quite simple when you think about it. An integer type for a function can be any value as long as it is an integer. The same goes for passing functions: a function can be any value as long as it is the correct type.</p>
			<p>A function can also be returned from another function. We saw this when using anonymous functions combined with closures. Here, we will take a brief look since we have already seen this syntax in a previous section:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  v:= square(9)</p>
			<p class="source-code">  fmt.Println(v())</p>
			<p class="source-code">  fmt.Printf("Type of v:  %T",v)</p>
			<p class="source-code">}</p>
			<p class="source-code">func square(x int) func() int {</p>
			<p class="source-code">  f := func() int {</p>
			<p class="source-code">    return x * x</p>
			<p class="source-code">  }</p>
			<p class="source-code">  return f</p>
			<p class="source-code">}</p>
			<p>Returning a function looks as follows:</p>
			<p class="source-code">81</p>
			<p class="source-code">Type of v: func() int</p>
			<ul>
				<li><strong class="source-inline">square(x int) func() int</strong>: The <strong class="source-inline">square</strong> function accepts an <strong class="source-inline">int</strong> as an argument and returns a function type that returns an <strong class="source-inline">int</strong>:<p class="source-code">func square(x int) func() int {</p><p class="source-code">  f := func() int {</p><p class="source-code">    return x * x</p><p class="source-code">  }</p><p class="source-code">  return f</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">square</strong> body, we assign a variable, <strong class="source-inline">f</strong>, to an anonymous function that returns the square value of the input parameter, <strong class="source-inline">x</strong>.</li>
				<li>The <strong class="source-inline">return</strong> statement for the <strong class="source-inline">square</strong> function returns an anonymous function that is of type <strong class="source-inline">func()</strong> int.</li>
				<li><strong class="source-inline">v</strong> is assigned to the return of the <strong class="source-inline">square</strong> function. As you may recall, the return value is of type <strong class="source-inline">func()</strong> int.</li>
				<li><strong class="source-inline">v</strong> has been assigned type <strong class="source-inline">func ()int</strong>; however, it has not been invoked. We will invoke it inside the <strong class="source-inline">print</strong> statement.</li>
				<li><strong class="source-inline">fmt.Printf("Type of v:  %T",v)</strong>: This statement just prints out the type for <strong class="source-inline">v</strong>, which is <strong class="source-inline">func()int</strong>.</li>
			</ul>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor192"/>Exercise 5.08: Creating Various Functions to Calculate Salary</h2>
			<p>We are going to be creating several functions. We need the ability to calculate the salary of a developer and a manager. We want this solution to be extensible for the future possibilities of other salaries to be calculated. We will be creating functions to calculate the developer and manager salary. Then we will create another function that will take the previously mentioned function as input parameter. The following steps will help you with the solution:</p>
			<ol>
				<li value="1">Use the IDE of your choice.</li>
				<li>Create a new file and save it at <strong class="source-inline">$GOPATH\function\funcAsParam\main.go</strong>.</li>
				<li>Enter the following code in <strong class="source-inline">main.go</strong>:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">func main() {</p><p class="source-code">  devSalary := salary(50,2080, developerSalary)</p><p class="source-code">  bossSalary := salary(150000,25000,managerSalary)</p><p class="source-code">  fmt.Printf("Boss salary: %d\n",bossSalary)</p><p class="source-code">  fmt.Printf("Developer salary: %d\n",devSalary)</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">salary</strong> function accepts a function that accepts two integers as arguments and returns an int. So, any function that matches that signature can be passed as an argument to the <strong class="source-inline">salary</strong> function:<p class="source-code">func salary(x,y int, f func(int,int)int)int{</p></li>
				<li>In the body of the <strong class="source-inline">salary()</strong> function, <strong class="source-inline">pay</strong> is assigned the value that gets returned from the <strong class="source-inline">f</strong> function. It passes <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> parameters as parameters to the <strong class="source-inline">f</strong> parameter:<p class="source-code">  pay := f(x,y)</p><p class="source-code">  return pay</p><p class="source-code">}</p></li>
				<li>Notice that the <strong class="source-inline">managerSalary</strong> and <strong class="source-inline">developerSalary</strong> signatures are identical and they match the function <strong class="source-inline">f</strong> for <strong class="source-inline">salary</strong>. This means that both <strong class="source-inline">managerSalary</strong> and <strong class="source-inline">developerSalary</strong> can be passed as <strong class="source-inline">func(int,int) int</strong>:<p class="source-code">func managerSalary(baseSalary,bonus int) int {</p><p class="source-code">  return baseSalary + bonus</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">devSalary</strong> and <strong class="source-inline">bossSalary</strong> get assigned to the results of the <strong class="source-inline">salary</strong> function. Since <strong class="source-inline">developerSalary</strong> and <strong class="source-inline">managerSalary</strong> satisfy the signature of <strong class="source-inline">func(int,int) int</strong>, they each can be passed in as arguments:<p class="source-code">func developerSalary(hourlyRate,hoursWorked int) int {</p><p class="source-code">  return hourlyRate * hoursWorked</p><p class="source-code">}</p></li>
				<li>Open a terminal and navigate to the code's directory.</li>
				<li>Run <strong class="source-inline">go build</strong> and run the executable.<p>The expected output is as follows:</p><p class="source-code">Boss salary: 175000</p><p class="source-code">Developer salary: 104000</p></li>
			</ol>
			<p>In this exercise, we saw how a function type can be a parameter for another function. This allows a function to be an argument to another function. This exercise showed how our code can be simplified by having one <strong class="source-inline">salary</strong> function. If, in the future, we need to calculate the salary for a tester position, we would only need to create a function that matches the function type for <strong class="source-inline">salary</strong> and pass it as an argument. The flexibility that this gives is that we do not have to change our <strong class="source-inline">salary</strong> function's implementation. In the next section, we are going to see how we can change the execution flow of a function, specifically after the function returns.</p>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor193"/>defer</h1>
			<p>The defer statement defers the execution of a function until the surrounding function returns. Let's try to explain this a bit better. Inside a function, you have a <strong class="source-inline">defer</strong> in front of a function that you are calling. That function will execute essentially right before the function you are currently inside completes. Still confused? Perhaps an example will make this concept a little clearer:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  defer done()</p>
			<p class="source-code">  fmt.Println("Main:  Start")</p>
			<p class="source-code">  fmt.Println("Main:  End")</p>
			<p class="source-code">}</p>
			<p class="source-code">func done() {</p>
			<p class="source-code">  fmt.Println("Now I am done")</p>
			<p class="source-code">}</p>
			<p>The output for the <strong class="source-inline">defer</strong> example is as follows:</p>
			<p class="source-code">Main: Start</p>
			<p class="source-code">Main: End</p>
			<p class="source-code">Now I am done</p>
			<p>Inside the <strong class="source-inline">main()</strong> function, we have a deferred function, <strong class="source-inline">defer</strong> <strong class="source-inline">done()</strong>. Notice that the <strong class="source-inline">done()</strong> function has no new or special syntax. It just has a simple print to <strong class="source-inline">stdout</strong>.</p>
			<p>Next, we have two print statements. The results are interesting. The two <strong class="source-inline">print</strong> statements in the <strong class="source-inline">main()</strong> function print first. Even though the deferred function was first in <strong class="source-inline">main()</strong>, it printed last. Isn't that interesting? Its ordering in the <strong class="source-inline">main()</strong> function did not dictate its order of execution. </p>
			<p>The deferred functions are commonly used for performing "clean-up" activities. That would include the release of resources, the closing of files, the closing database connections, and the removal of configuration\temp files created by a program. The <strong class="source-inline">defer</strong> functions are also used to recover from a panic; this is discussed in a later chapter.</p>
			<p>Using the <strong class="source-inline">defer</strong> statement is not limited to just named functions. In fact, you can utilize the defer statement with anonymous functions. Taking our previous code snippet, let's turn it into deferred call with an anonymous function:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  defer func(){</p>
			<p class="source-code">    fmt.Println("Now I am done")</p>
			<p class="source-code">  }()</p>
			<p class="source-code">  fmt.Println("Main:  Start")</p>
			<p class="source-code">  fmt.Println("Main:  End")</p>
			<p class="source-code">}</p>
			<ul>
				<li>There is not much that has changed from the previous code. We took the code that was in the <strong class="source-inline">done</strong> function and created a deferred anonymous function.</li>
				<li>The <strong class="source-inline">defer</strong> statement is placed before the <strong class="source-inline">func()</strong> keyword. Our function has no function name. As you may recall, a function without a name is an anonymous function.</li>
				<li>The results are the same as those from the previous example. The readability, to a certain extent, is easier than having the deferred function declared as a named function, as in the previous example.</li>
			</ul>
			<p>It is also possible and common to have multiple <strong class="source-inline">defer</strong> statements in a function. However, they may not execute in the order that you expect. When using <strong class="source-inline">defer</strong> statements in front of functions, the execution follows the order of <strong class="bold">First In Last Out</strong> (<strong class="bold">FILO</strong>). Think of it as how you would stack plates. The first plate to start the stack will have a second plate placed on it, the second plate will have a third plate placed on it, and so on. The first plate to get taken off the stack is the last plate that was placed on the stack. The first plate that was placed to start the stack will be the last plate to come off the stack. Let's look at an example that declares multiple anonymous functions with the <strong class="source-inline">defer</strong> statement placed in front of them:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  defer func() {</p>
			<p class="source-code">    fmt.Println("I was declared first.")</p>
			<p class="source-code">  }()</p>
			<p class="source-code">  defer func() {</p>
			<p class="source-code">    fmt.Println("I was declared second.")</p>
			<p class="source-code">  }()</p>
			<p class="source-code">  defer func() {</p>
			<p class="source-code">    fmt.Println("I was declared third.")</p>
			<p class="source-code">  }()</p>
			<p class="source-code">  f1 := func() {</p>
			<p class="source-code">    fmt.Println("Main:  Start")</p>
			<p class="source-code">  }</p>
			<p class="source-code">  f2 := func() {</p>
			<p class="source-code">    fmt.Println("Main:  End")</p>
			<p class="source-code">  }</p>
			<p class="source-code">  f1()</p>
			<p class="source-code">  f2()</p>
			<p class="source-code">}</p>
			<p>The multiple <strong class="source-inline">defer</strong> output looks as follows:</p>
			<p class="source-code">Main: Start</p>
			<p class="source-code">Main: End</p>
			<p class="source-code">I was declared third.</p>
			<p class="source-code">I was declared second.</p>
			<p class="source-code">I was declared first.</p>
			<ul>
				<li>The first three anonymous functions are having their execution deferred.</li>
				<li>We declare <strong class="source-inline">f1</strong> and <strong class="source-inline">f2</strong> of type <strong class="source-inline">func()</strong>. These two functions are anonymous functions.</li>
				<li>As you can see, our <strong class="source-inline">f1()</strong> and <strong class="source-inline">f2()</strong> executed as expected, but the order of the multiple <strong class="source-inline">defer</strong> statements executed in the reverse order of how they were declared in the code. The first <strong class="source-inline">defer</strong> was the last to execute and the last <strong class="source-inline">defer</strong> was the first to execute.</li>
			</ul>
			<p>Careful consideration must be given when using <strong class="source-inline">defer</strong> statements. A situation that you should consider is when you use <strong class="source-inline">defer</strong> statements in conjunction with variables. When a variable is passed to a deferred function, the variable's value at that time is what will be used in the deferred function. If that variable is changed after the deferred function, it will not be reflected when the deferred function runs:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  age := 25</p>
			<p class="source-code">  name := "John"</p>
			<p class="source-code">  defer personAge(name,age)</p>
			<p class="source-code">  age *= 2</p>
			<p class="source-code">  fmt.Printf("Age double %d.\n",age)</p>
			<p class="source-code">}</p>
			<p class="source-code">func personAge(name string,i int) {</p>
			<p class="source-code">    fmt.Printf("%s is %d.\n", name,i)</p>
			<p class="source-code">}</p>
			<p>The output would be as follows:</p>
			<p class="source-code">Age double 50.</p>
			<p class="source-code">John is 25.</p>
			<ul>
				<li><strong class="source-inline">age</strong>:= <strong class="source-inline">25</strong>: We initialize the <strong class="source-inline">age</strong> variable to <strong class="source-inline">25</strong> before the <strong class="source-inline">defer</strong> function.</li>
				<li><strong class="source-inline">name:=</strong> <strong class="source-inline">"John"</strong>: We initialize the <strong class="source-inline">name</strong> variable to <strong class="source-inline">"John"</strong> before the <strong class="source-inline">defer</strong> function.</li>
				<li><strong class="source-inline">defer</strong> <strong class="source-inline">personAge</strong>(<strong class="source-inline">name</strong>,<strong class="source-inline">age</strong>): We state that the function is going to be deferred.</li>
				<li><strong class="source-inline">age*=2</strong>: We double the age after the deferred function. We then print the current value of <strong class="source-inline">age</strong> doubled.</li>
				<li><strong class="source-inline">personAge</strong>(<strong class="source-inline">name</strong> <strong class="source-inline">string</strong>, <strong class="source-inline">i</strong> <strong class="source-inline">int</strong>): This is the function that is deferred; it only prints out the person and age.</li>
				<li>The results show the value of <strong class="source-inline">age</strong> (<strong class="source-inline">25</strong>) after it has been doubled in the <strong class="source-inline">main</strong> function.</li>
				<li>When the execution of the program reaches the line that has <strong class="source-inline">defer</strong> <strong class="source-inline">personAge(name,age)</strong>, the value of <strong class="source-inline">age</strong> is <strong class="source-inline">25</strong>. Before the <strong class="source-inline">main()</strong> function completes, the deferred function runs and the value of <strong class="source-inline">age</strong> is still <strong class="source-inline">25</strong>. Variables used in the deferred function are the values before it was deferred, regardless of what happens after it.</li>
			</ul>
			<h2 id="_idParaDest-186">Activity 5.0<a id="_idTextAnchor194"/><a id="_idTextAnchor195"/>2: Calculating Payable Amount for Employees Based on Working Hours</h2>
			<p>This activity is based on the previous activity. We will keep the same functionality but we will be adding three additional features. In this version of the application, we would like to give the employee the ability to track their hours throughout the day without having logged them yet. This will allow the employees to keep better track of their hours before they log them at the end of the day. We are also enhancing the application to calculate the employee's pay. The application will calculate their pay for any overtime they worked. The application will also print out details of how many hours were worked each day:</p>
			<ol>
				<li value="1">Create a function called <strong class="source-inline">nonLoggedHours()</strong> <strong class="source-inline">func(int)</strong> <strong class="source-inline">int</strong>. Each time this function is called, it will calculate the hours of the employee that have not been logged. You will be using a closure inside the function.</li>
				<li>Create a method called <strong class="source-inline">PayDay()(int,bool)</strong>. This method will calculate the weekly pay. It needs to take into consideration overtime pay. The method will pay twice the hourly rate for hours greater than 40. The function will return <strong class="source-inline">int</strong> as the weekly pay and <strong class="source-inline">bool</strong> for if the pay is overtime pay. The Boolean will be true if the employee worked more than <strong class="source-inline">40</strong> hours and false if they worked less than <strong class="source-inline">40</strong> hours.</li>
				<li>Create a method called <strong class="source-inline">PayDetails()</strong>. This method will print each day and the hours worked that day by the employee. It will print the total hours for the week, the pay for the week, and if the pay contains overtime pay.</li>
				<li>Inside of the <strong class="source-inline">main</strong> function, initialize a variable of type <strong class="source-inline">Developer</strong>. Assign a variable to <strong class="source-inline">nonLoggedHours</strong>. Print the variable assigned to <strong class="source-inline">nonLoggedHours</strong> with values of <strong class="source-inline">2</strong>, <strong class="source-inline">3</strong>, and <strong class="source-inline">5</strong>.</li>
				<li>Also, in the <strong class="source-inline">main()</strong> function, log the hours for the following days: Monday 8, Tuesday 10, Wednesday 10, Thursday 10, Friday 6, and Saturday 8.</li>
				<li>Then run the <strong class="source-inline">PayDetails()</strong> method.<p>The following is the expected output:</p></li>
			</ol>
			<p> </p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B14177_05_13.jpg" alt="Figure 5.13: Output for payable amount activity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13: Output for payable amount activity</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 706.</p>
			<p>The aim of this activity is to go a step further than <em class="italic">Activity 5.01,</em> <em class="italic">Calculating the Working Hours of Employees</em>, by using some more advanced programming with Go's functions. In this activity, we will continue to use functions as we did previously; however, we will be returning multiple values and returning a function from a function. We also demonstrate the use of closures for calculating hours not logged by an employee.</p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor196"/>Summary</h1>
			<p>We have studied why and how functions are an essential part of the Go programming language. We also discussed various features of functions in Go that make Go stand apart from other programming languages. Go has features that allow us to solve a lot of real-world problems. Functions in Go serve many purposes, including enhancing the usage and readability of code. We learned how to create and call functions. We studied the various types of functions used in Go and discussed scenarios where each of the function types can be used. We also expounded the concept of closures. Closures are essentially a type of anonymous function that can use variables declared at the same level as that at which the anonymous function was declared. We also discussed various parameters and return types and studied <strong class="source-inline">defer</strong>.</p>
			<p>In the next chapter, we shall be exploring errors and error types and learning how to build custom errors, thus building a recovery mechanism to handle errors in Go.</p>
		</div>
	</body></html>