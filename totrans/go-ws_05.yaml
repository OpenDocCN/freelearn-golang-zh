- en: 5\. Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 函数
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will describe the various parts of a function in detail, such as
    defining the function, function identifiers, parameter lists, return types, and
    the function body. We will also look at some best practices when designing our
    functions, such as a function performing a single task, how to reduce code, making
    your function small, and ensuring that functions are reusable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细描述函数的各个部分，例如定义函数、函数标识符、参数列表、返回类型和函数体。我们还将探讨设计函数时的最佳实践，例如函数执行单一任务、如何减少代码、使函数小型化以及确保函数可重用。
- en: By the end of this chapter, you will be able to describe a function and the
    different parts that make up a function and evaluate the scope of variables with
    functions. You will learn to create and call a function; utilize variadic and
    anonymous functions and create closures for various constructs. You will also
    learn to use functions as parameters and return values; and use `defer` statements
    with functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够描述函数以及构成函数的不同部分，并评估函数的变量作用域。你将学会创建和调用函数；利用可变参数和匿名函数，并为各种结构创建闭包。你还将学会将函数用作参数和返回值；以及与函数一起使用`defer`语句。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Functions are a core part of many languages and Go is no exception. A function
    is a section of code that has been declared to perform a task. Go functions can
    have zero or more inputs and outputs. One feature that sets Go apart from other
    programming languages is the multiple return values; most programming languages
    are limited to one return value.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是许多语言的核心部分，Go语言也不例外。函数是一段被声明以执行任务的代码。Go函数可以有零个或多个输入和输出。将Go与其他编程语言区分开来的一个特性是它支持多个返回值；大多数编程语言都限制为只有一个返回值。
- en: In the following section, we will see some features of Go functions that differ
    from other languages, such as returning multiple types. We will also see that
    Go has support for first-class functions. This means that Go has the ability to
    assign a variable to a function, pass a function as an argument, and have a function
    as a return type for a function. We will show how functions can be used to break
    up complex parts into smaller parts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到Go函数的一些与其他语言不同的特性，例如返回多个类型。我们还将看到Go支持一等函数。这意味着Go有将变量分配给函数、将函数作为参数传递以及将函数作为函数的返回类型的能力。我们将展示如何使用函数将复杂部分分解成更小的部分。
- en: 'Functions in Go are considered first-class citizens and higher-order functions.
    First-class citizens are the functions that are assigned to a variable. Higher-order
    functions are functions that can take a function as an argument. The rich features
    of Go functions empower them to be used in various segments in the following ways:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的函数被视为一等公民和高级函数。一等公民是将函数分配给变量的函数。高级函数是可以接受函数作为参数的函数。Go函数的丰富特性使它们能够在以下方式中用于各种段：
- en: Functions to be passed as an argument to another function
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数作为参数传递给另一个函数
- en: Return a function as a value from a function
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从函数中返回一个函数值
- en: Functions as a type
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为一种类型
- en: Closures
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: Anonymous functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数
- en: Functions assigned to a variable
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数分配给变量
- en: We will be looking at each of these features that are supported in Go.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看Go支持的所有这些功能。
- en: Functions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions are a critical part of Go and we should understand their place. Let''s
    examine some of the reasons for using functions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是Go语言的关键部分，我们应该了解它们的位置。让我们考察一下使用函数的一些原因：
- en: '**Breaking up a complex task**: Functions are used to perform a task, but if
    that task is complicated, it should then be broken down into smaller tasks. Functions
    can be used for small tasks to solve a bigger problem. Smaller tasks are more
    manageable, and using a function to solve specific tasks will make the entire
    code base easier to maintain.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分解复杂任务**：函数用于执行任务，但如果任务很复杂，那么应该将其分解成更小的任务。函数可以用于解决更大的问题的小任务。小任务更容易管理，使用函数解决特定任务会使整个代码库更容易维护。'
- en: '**Reducing code**: A good indication that you should use a function is when
    you see similar code repeating throughout your program. When you have duplicate
    code, it increases the difficulty of maintenance. If you have one change to make,
    you will have multiple instances where your code needs to change.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少代码**：你应该使用函数的一个好迹象是在你的程序中看到相似的代码重复出现。当你有重复的代码时，它增加了维护的难度。如果你需要做一次更改，你将有多处代码需要更改。'
- en: '**Reusability**: Once you have defined your function, you can use it repeatedly.
    It can also be used by other programmers. This sharing of functions will also
    reduce lines of code and save time by allowing you to not have to reinvent the
    wheel. There are a couple of guidelines we should follow when we design functions:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：一旦你定义了你的函数，你可以重复使用它。它也可以被其他程序员使用。这种函数的共享将减少代码行数并节省时间，因为你不需要重新发明轮子。在设计函数时，我们应该遵循以下一些准则：'
- en: '**Single responsibility**: A function should perform one task. For example,
    a single function should not calculate the distance between two points and estimate
    the time to travel between those two points. There should be a function for each
    of those tasks. This allows for better testing of that function and easier maintenance.
    It is difficult to narrow a function to perform a single task, so do not get discouraged
    if you do not get it right the first time. Even seasoned programmers struggle
    with assigning a single responsibility to a function.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责**：一个函数应该执行一个任务。例如，一个函数不应该计算两点之间的距离并估计在这两点之间旅行的所需时间。应该为每个任务有一个函数。这允许更好地测试该函数并更容易维护。将函数缩小到执行单一任务是有难度的，所以如果你第一次没有做对，不要气馁。即使是经验丰富的程序员在为函数分配单一职责时也会遇到困难。'
- en: '**Small in size**: Functions should not span over hundreds of lines of code.
    This is an indication that the code needs some refactoring. When we have large
    functions, it''s more likely that the single responsibility principle will be
    violated. A good rule of thumb is trying to limit the function size to approximately
    25 lines of code; however, that''s not a hard-and-fast rule. The benefit of keeping
    the code concise is that it reduces the complexity of debugging a large function.
    It also makes writing unit tests with better code coverage easier.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**体积小**：函数不应该超过数百行代码。这是代码需要重构的迹象。当我们有大型函数时，更有可能违反单一职责原则。一个好的经验法则是尝试将函数大小限制在大约
    25 行代码；然而，这不是一个硬性规则。保持代码简洁的好处是它减少了调试大型函数的复杂性。它还使得编写具有更好代码覆盖率的单元测试更容易。'
- en: Parts of a function
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的部分
- en: 'We will now be looking at the different components involved in defining a function.
    The following is the typical layout of a function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨定义函数所涉及的不同组件。以下是一个函数的典型布局：
- en: '![Figure 5.1: Different parts of a function'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1：函数的不同部分'
- en: '](img/B14177_05_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图](img/B14177_05_01.jpg)'
- en: 'Figure 5.1: Different parts of a function'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：函数的不同部分
- en: 'The different parts of a function are described here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的不同部分在此处描述：
- en: '`func` keyword.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func` 关键字。'
- en: '`calculateTax`, `totalSum`, and `fetchId`.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateTax`、`totalSum` 和 `fetchId`。'
- en: The identifier should be something descriptive that makes the code easy to read
    and makes the purpose of the function easy to understand. The identifier is not
    required. You can have a function with no name; this is known as an anonymous
    function. Anonymous functions will be discussed in detail in a later part of the
    chapter.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标识符应该是描述性的，使得代码易于阅读，并使函数的目的易于理解。标识符不是必需的。你可以有一个没有名称的函数；这被称为匿名函数。匿名函数将在本章的后续部分详细讨论。
- en: Note
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: When the first letter of the function name is in lowercase, then the function
    is not exportable outside of a package. This means they are private and cannot
    be called from outside the package. They can only be called within the package.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当函数名的第一个字母是小写时，那么该函数在包外部不可导出。这意味着它们是私有的，不能从包外部调用。它们只能在包内部调用。
- en: Keep this in mind when you use camelCase naming convention. If you want your
    function to be exportable, the first letter of the function name must be capitalized.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用驼峰命名法时请记住这一点。如果你想使你的函数可导出，函数名的第一个字母必须大写。
- en: '`name string`, `age int`). Parameters are local variables to the function.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name string`, `age int`)。参数是函数的局部变量。'
- en: Parameters are optional for a function. It is possible to not have any parameters
    for a function. A function can have zero or more parameters.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数对于函数是可选的。一个函数可能没有任何参数。一个函数可以有零个或多个参数。
- en: When two or more parameters have the same type, you can use what is called shorthand
    parameter notation. This removes specifying the same type for each parameter.
    For instance, if your parameters are (`firstName string`, `lastName string`),
    they can be shortened to (`firstName`, `lastName string`). This reduces the verbosity
    of the parameter inputs and increases the readability of the function parameter
    list.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当两个或多个参数具有相同的类型时，你可以使用所谓的简写参数表示法。这消除了为每个参数指定相同类型的需要。例如，如果你的参数是(`firstName string`,
    `lastName string`)，它们可以缩短为(`firstName`, `lastName string`)。这减少了参数输入的冗长性，并增加了函数参数列表的可读性。
- en: '**Return types**: Return types are a list of data types, such as Boolean, string,
    map, or another function that can be returned.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回类型**：返回类型是一系列数据类型，如布尔值、字符串、映射或可以返回的另一个函数。'
- en: In the context of declaring a function, we refer to these types as return types.
    However, in the context of calling a function, they are called return values.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在声明函数的上下文中，我们把这些类型称为返回类型。然而，在调用函数的上下文中，它们被称为返回值。
- en: Return types are the output of the function. Often, they are the result of the
    arguments provided to the function. They are optional. Most programming languages
    return a single type; in Go, you can return multiple types.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回类型是函数的输出。通常，它们是提供给函数的参数的结果。它们是可选的。大多数编程语言返回单个类型；在Go语言中，你可以返回多个类型。
- en: '`{}`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{}`。'
- en: The statements in the function are what determine what the function does. The
    function code is the code that is being used to perform the task that the function
    was created to accomplish.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数中的语句决定了函数做什么。函数代码是执行函数被创建来完成的任务的代码。
- en: If there were return types defined, then a `return` statement is required in
    the function body. The `return` statement causes the function to immediately stop
    and return the value types listed after the `return` statement. The types in the
    return type list and in the `return` statement must match.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果定义了返回类型，那么函数体中需要有一个`return`语句。`return`语句使函数立即停止并返回`return`语句之后列出的值类型。返回类型列表和`return`语句中的类型必须匹配。
- en: In the function body, there can be multiple `return` statements.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在函数体中，可以有多个`return`语句。
- en: '**Function signature**: Though not listed in the preceding code snippet, a
    function signature is a term that references the input parameters combined with
    the return types. Both of those units make up a function signature.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数签名**：尽管在先前的代码片段中没有列出，但函数签名是一个术语，它指的是输入参数与返回类型的组合。这两个单元共同构成了函数签名。'
- en: Often, when you define the function signature when it is being used by others,
    you want to strive to not make changes to it as this can adversely impact your
    code and the code of others.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，当其他人使用函数时定义函数签名时，你想要努力不对其进行更改，因为这可能会对你的代码和别人的代码产生不利影响。
- en: We will be diving deep into each of the parts of a function as we progress through
    the chapter. These parts of a function will become easier to understand through
    the following discussion, so don't worry if you do not quite understand all the
    parts yet. It will become clearer as we go through the chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们通过本章的进展，我们将深入探讨函数的各个部分。通过以下讨论，这些函数部分将变得更容易理解，所以如果你现在还没有完全理解所有部分，请不要担心。随着我们继续阅读本章，一切将变得清晰。
- en: fizzBuzz
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fizzBuzz
- en: 'Now that we have looked at the different parts of the function, let''s see
    how these parts work with various examples. Let''s start with a classical programming
    game called `fizzBuzz`. The rules of `fizzBuzz` are straightforward. The `fizzBuzz`
    function prints out various messages based on some math results. The rules perform
    one of the actions based on the number given:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经研究了函数的不同部分，让我们看看这些部分如何通过各种示例来工作。让我们从一个经典的编程游戏`fizzBuzz`开始。`fizzBuzz`的规则很简单。`fizzBuzz`函数根据某些数学结果打印出各种消息。规则根据给定的数字执行以下操作之一：
- en: If the number is divisible by `3`, print `Fizz`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字能被`3`整除，则打印`Fizz`。
- en: If the number is divisible by `5`, print `Buzz`.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字能被`5`整除，则打印`Buzz`。
- en: If the number is divisible by `15`, print `FizzBuzz`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字能被`15`整除，则打印`FizzBuzz`。
- en: Else, print the number.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，打印数字。
- en: 'The following is the code snippet to achieve this output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现此输出的代码片段：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s look at the code in sections now:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来分部分查看代码：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`func`, as you may recall, is the keyword to declare a function. This informs
    Go that the following piece of code is going to be a function.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func`，如您所记得，是声明函数的关键字。这通知Go，以下代码块将是一个函数。'
- en: '`fizzBuzz` is the name of our function. It is idiomatic in Go to use a camelCase
    name.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fizzBuzz`是我们函数的名称。在Go语言中，使用驼峰式命名法是惯例。'
- en: '`()`, the parenthesis following the name of our function, is empty: our current
    implementation of the `FizzBuzz` game does not require any input parameters.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`()`，函数名称后面的括号是空的：我们当前实现的`FizzBuzz`游戏不需要任何输入参数。'
- en: The space between the parameter list, `()`, and the opening brace would be the
    return type. Our current implementation does not require a return type.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数列表`()`和开括号之间的空格将是返回类型。我们当前的实施并不需要返回类型。
- en: Regarding `{`, unlike other programming languages that you may know, Go requires
    that the opening curly brace is on the same line as the function declaration.
    If the opening brace is not on the same line as the function signature when you
    attempt to run the program, you will get an error.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`{`，与您可能了解的其他编程语言不同，Go要求开括号与函数声明在同一行上。如果您尝试运行程序时开括号不在函数签名同一行上，您将得到一个错误。
- en: '[PRE2]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding line is a `for` loop that increments the `i` variable from `1`
    to `30`:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前一行是一个`for`循环，它将`i`变量从`1`增加到`30`：
- en: '[PRE3]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`%` is a modulus operator; it gives the remainder of the two integers being
    divided. Using our function, if `i` is `15`, then `15%15` will return zero. We
    use the modulus operator to determine whether `i` is evenly divisible by `3`,
    `5`, or `15`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%`是取模运算符；它给出两个整数相除的余数。使用我们的函数，如果`i`是`15`，那么`15%15`将返回零。我们使用取模运算符来确定`i`是否能被`3`、`5`或`15`整除。'
- en: Note
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: As we become more familiar with Go concepts and language syntax, the explanation
    of the code will exclude items that we would otherwise be going over multiple
    times.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随着我们越来越熟悉Go的概念和语言语法，代码的解释将排除我们本会多次提到的项目。
- en: We have now defined our function. It has a specific task we want it to perform,
    but it doesn't do any good if we do not execute the function. So, how do we execute
    a function? We must call our function. When we call a function, we are telling
    our program to execute the function. We will be calling our function inside the
    `main()` function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经定义了我们的函数。它有一个特定的任务我们希望它执行，但如果我们不执行该函数，那就没有好处。那么，我们如何执行一个函数呢？我们必须调用我们的函数。当我们调用一个函数时，我们是在告诉我们的程序执行该函数。我们将在`main()`函数内部调用我们的函数。
- en: 'Functions can call other functions. When this occurs, control is given to the
    function that was called. After the called function has returned data or reached
    the ending curly brace, `}`, control is given back to the caller. Let''s see an
    example to understand this better:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以调用其他函数。当这种情况发生时，控制权交给了被调用的函数。在被调用的函数返回数据或达到结束括号`}`后，控制权交还给调用者。让我们通过一个例子来更好地理解这一点：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`}fmt.Println("Main is in control")`: This `print` statement is for demonstration
    purposes. It shows that we are in the `main()` function.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`}fmt.Println("Main is in control")`: 这条打印语句用于演示目的。它显示我们处于`main()`函数中。'
- en: '`fizzBuzz()`: We are now calling the function inside the `main()` function.
    Even though there are no parameters for our function the parentheses are still
    required, control of the program is given to the `fizzBuzz()` function. After
    the `fizzBuzz()` function completes, control is then given back to the `main()`
    function.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fizzBuzz()`: 我们现在在`main()`函数内部调用该函数。尽管我们的函数没有参数，但括号仍然是必需的，程序的控制权交给了`fizzBuzz()`函数。在`fizzBuzz()`函数完成后，控制权随后交还给`main()`函数。'
- en: '`fmt.Println("Back to main")`: The `print` statement is for demonstration purposes
    to show that control has been given back to the `main()` function.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmt.Println("Back to main")`: 这条打印语句用于演示目的，以显示控制权已交还给`main()`函数。'
- en: 'The output will be as follows:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 5.2: Output for fizzBuzz'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2：fizzBuzz的输出'
- en: '](img/B14177_05_02.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_05_02.jpg)'
- en: 'Figure 5.2: Output for fizzBuzz'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：fizzBuzz的输出
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The parentheses following the `fizzBuzz` function are still required even though
    there are no input parameters. If they are omitted, the Go compiler will generate
    an error that states `fizzBuzz` evaluated but not used. This is a common error.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有输入参数，`fizzBuzz`函数后面的括号也是必需的。如果省略了它们，Go编译器将生成一个错误，指出`fizzBuzz`已评估但未使用。这是一个常见的错误。
- en: 'The output will be as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 5.3: Output for fizzBuzz without parentheses'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3：没有括号的fizzBuzz输出'
- en: '](img/B14177_05_03.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3：没有括号的fizzBuzz输出](img/B14177_05_03.jpg)'
- en: 'Figure 5.3: Output for fizzBuzz without parentheses'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：没有括号的fizzBuzz输出
- en: 'Exercise 5.01: Creating a Function to Print Salesperson Expectation Ratings
    from the Number of Items Sold'
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.01：创建一个函数以打印销售人员的期望评分
- en: 'In this exercise, we will be creating a function that will not have any parameters
    or return types. The function will iterate over a map and print the name and number
    of items sold in the map. It will also print a statement based on how the salesperson
    performed based on their sales. The following steps will help you with the solution:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个没有参数或返回类型的函数。该函数将遍历一个映射并打印映射中销售的商品名称和数量。它还将根据销售人员的销售情况打印一条声明。以下步骤将帮助您找到解决方案：
- en: Use the IDE of your choice.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的IDE。
- en: Create a new file and save it as `main.go`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，并将其保存为`main.go`。
- en: 'Enter the following code in `main.go`. The first function that `main` will
    call on `printAge()`; it does not have any parameters and has no return values:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中输入以下代码。`main`将首先调用`printAge()`函数；它没有参数，也没有返回值：
- en: '[PRE5]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will now define our function for printing the age and a message about the
    age of the person:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将定义一个打印年龄及其消息的函数：
- en: '[PRE6]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `itemsSold()` function, initialize a map that will have a key-value
    pair of `string`, `int`. The map will hold a `name`(`string`) and the number of
    `items`(`int`) sold. The name is the key for the map. We assign various names
    to number of items sold:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`itemsSold()`函数中，初始化一个将包含`string`到`int`键值对的映射。该映射将包含`名称`（`string`）和销售的商品数量（`int`）。名称是映射的键。我们为销售的商品数量分配了各种名称：
- en: '[PRE7]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We iterate over the `items` map and assign `k` to the `key`(`name`) and `v`
    to the `value`(`items`):'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历`items`映射，将`k`分配给`key`（`名称`）和`v`分配给`value`（`商品`）：
- en: '[PRE8]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We print out the `Name` and the number of sold `items`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打印出`名称`和销售的商品数量：
- en: '[PRE9]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Depending on the value of `v`(`items`), we will determine the statement we
    print:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据值`v`（`商品`），我们将确定打印的声明：
- en: '[PRE10]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Open your terminal and navigate to the code's directory.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的终端并导航到代码目录。
- en: Run `go build` and then run the executable.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go build`然后运行可执行文件。
- en: 'The expected output is as follows:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE11]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this exercise, we saw some of the fundamental parts of a function. We demonstrated
    how to declare a function using the `func` keyword, followed by how to give our
    function an identifier or name such as `itemsSold()`. We then proceed to add code
    to the function body. In the next topics, we will expand on these core parts of
    the function and learn how to pass data into a function using parameters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了函数的一些基本部分。我们展示了如何使用`func`关键字声明函数，然后是如何给我们的函数一个标识符或名称，例如`itemsSold()`。然后我们继续向函数体中添加代码。在下一个主题中，我们将扩展函数的核心部分，并学习如何使用参数将数据传递到函数中。
- en: Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is best to type the code into an IDE. The benefit is that if you type something
    incorrectly, you will see the error message and can perform some debugging to
    solve the problem.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最好在集成开发环境（IDE）中输入代码。好处是如果您输入错误，您将看到错误消息，并可以进行一些调试以解决问题。
- en: Parameters
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数
- en: 'Parameters define what arguments can be passed to our function. Functions can
    have zero or more parameters. Even though Go allows us to define multiple parameters,
    we should take care not to have a huge parameter list; that would make the code
    harder to read. It also may be an indication that the function is doing more than
    one specific task. If that is the case, we should refactor the function. Take,
    for example, the following code snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 参数定义了可以传递给我们的函数的参数。函数可以有零个或多个参数。尽管Go允许我们定义多个参数，但我们应小心不要有一个很长的参数列表；这会使代码更难阅读。这也可能表明函数正在执行多个特定任务。如果是这种情况，我们应该重构函数。以下是一个代码片段的例子：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code is an example of a function whose parameter list is bloated.
    The parameter list should pertain only to the single responsibility of the function.
    We should only define the parameters that are needed to solve the specific problem
    that the function is built for.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个参数列表膨胀的函数示例。参数列表应仅与函数的单个职责相关。我们应仅定义解决函数构建的特定问题的所需参数。
- en: Parameters are the input types that our function will use to perform its task.
    Function parameters are local to the function, meaning they are only available
    to that function. They are not available outside of the context of the function.
    Also, the order of the parameters must match the parameter types in the correct
    sequence.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是我们函数将用于执行其任务的输入类型。函数参数是局部于函数的，这意味着它们只对那个函数可用。它们在函数的上下文之外不可用。此外，参数的顺序必须与参数类型的正确顺序匹配。
- en: '**Correct:**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**正确：**'
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output when the correct parameter matches would be as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正确参数匹配时的输出如下所示：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Incorrect:**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误：**'
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output looks as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 5.4: Output for incorrect parameter matching'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4：不正确的参数匹配输出]'
- en: '](img/B14177_05_04.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4：不正确的参数匹配输出](img/B14177_05_04.jpg)'
- en: 'Figure 5.4: Output for incorrect parameter matching'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：不正确的参数匹配输出
- en: In the incorrect version of the code, we are calling the `greeting()` function
    with the `age` argument of type `integer` when the parameter is of type `string`.
    The sequence of your arguments must match the sequence of the parameter input
    list.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的不正确版本中，我们用 `age` 参数调用 `greeting()` 函数，而该参数的类型为 `integer`，而参数的类型为 `string`。你的参数序列必须与参数输入列表的序列匹配。
- en: 'Additionally, users would want to have more control over the data the code
    iterates over. Going back to the `fizzBuzz` example, the current implementation
    only does `1` to `100`. Users may need to work on different number ranges and
    hence we need a way to decide the ending range of the loop. We can change our
    `fizzBuzz` function to accept an input parameter. This would meet the needs of
    our user:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，用户可能希望对代码迭代的 数据有更多的控制。回到 `fizzBuzz` 例子，当前的实现只做 `1` 到 `100`。用户可能需要处理不同的数字范围，因此我们需要一种方法来决定循环的结束范围。我们可以将
    `fizzBuzz` 函数更改为接受输入参数。这将满足用户的需求：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code snippet can be explained as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段可以这样解释：
- en: For `fizzBuzz(10)` in the `main()` function, we pass `10` as an argument to
    our `fizzBuzz` function.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，对于 `fizzBuzz(10)`，我们将 `10` 作为参数传递给我们的 `fizzBuzz` 函数。
- en: For `fizzBuzz(end int)`, `topEnd` is the name of our parameter and it is of
    type `int`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `fizzBuzz(end int)`，`topEnd` 是我们的参数名，它属于 `int` 类型。
- en: Our function now will only iterate up to the value of our end parameter; in
    this example, it will iterate to `10`.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在的函数将只迭代到我们的结束参数的值；在这个例子中，它将迭代到 `10`。
- en: The Difference between an Argument and a Parameter
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数与参数的区别
- en: This is a good time to discuss the difference between an argument and a parameter.
    When you are defining your function, using our example, `fizzBuzz`(`end int`)
    is called a parameter. When you call a function, such as `fizzBuzz(10)`, 10 is
    called the argument. Also, the argument and parameter names do not need to match.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个讨论参数与参数区别的好时机。当你定义你的函数时，以我们的例子 `fizzBuzz(end int)` 为例，它被称为参数。当你调用一个函数，如 `fizzBuzz(10)`，10
    被称为参数。此外，参数和参数的名称不需要匹配。
- en: 'Functions in Go also can have more than one parameter defined. We need to add
    another parameter to our `fizzBuzz` function to accommodate this enhancement:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的函数也可以定义多个参数。我们需要向我们的 `fizzBuzz` 函数添加另一个参数以适应这个增强：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code snippet can be explained as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段可以这样解释：
- en: Regarding `fizzBuzz(s,e)`, we are now passing two arguments to the `fizzBuzz`
    function. When there are multiple arguments, they must be separated by a comma.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 `fizzBuzz(s,e)`，我们现在向 `fizzBuzz` 函数传递了两个参数。当有多个参数时，它们必须通过逗号分隔。
- en: Regarding `func fizzBuzz`(`start int`, `end int`), when multiple parameters
    are defined in a function, they are separated by commas, following the convention
    of name type, name type, name type, and so on.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 `func fizzBuzz(start int, end int)`，当在函数中定义多个参数时，它们通过逗号分隔，遵循名称类型、名称类型、名称类型等顺序。
- en: 'Our `fizzBuzz` parameters are more verbose than what is necessary. When we
    have multiple input parameters of the same type, you can separate the input name
    by a comma followed by the type. This is referred to as shorthand parameter notation.
    See the following example of using shorthand parameter notation:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `fizzBuzz` 参数比必要的更冗长。当我们有多个相同类型的输入参数时，可以通过逗号后跟类型来分隔输入名称。这被称为简写参数表示法。请看以下使用简写参数表示法的示例：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code snippet can be explained as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段可以这样解释：
- en: There is no change to the caller when using shorthand parameter notation.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简写参数表示法时，调用者没有变化。
- en: Regarding `fizzBuzz`(`start`,`end int`), `start` and `end` are of type `int`.
    Nothing needs to change in the body of the function to accommodate the shorthand
    parameter notation.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 5.02: Mapping Index Values to Column Headers'
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function that we are going to create will be taking a slice of column headers
    from a CSV file. It will print out a map of an index value of the headers we are
    interested in:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Open the IDE of your choice.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file and save it `main.go`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, we assign a variable to a key-value pair of `int` and `string`. `key`(`int`)
    will be the index of our `header`(`string`) column. The index will map to a column
    header.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We range over the `header` to process each string that is in the slice:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For each string, remove any trailing spaces in front of and after the string.
    In general, we should always make the assumption that our data may have some erroneous
    characters:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In our `switch` statement, we lower all the casing for exact matches. As you
    may recall, Go is a case-sensitive language. We need to ensure that the casing
    is the same for matching purposes. When our code finds the header, it sets the
    index value for the header in the map:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Typically, we would not print out the results. We should return the `csvHeadersToColumnIndex`,
    but since we have not gone over how to return a value, we will print it for now:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Open your terminal and navigate to the code's directory.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this exercise, we saw how to accept data into a function, by defining a parameter
    for our function. The callers of our function were able to pass arguments to the
    function. We will continue to discover various abilities that functions in Go
    can provide. We have seen how to get data into our function. In the next section,
    we will see how to get data out of our function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Function Variable Scope
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When designing functions, we need to consider the variable scope. The scope
    of a variable determines where the variable is accessible or visible to the different
    parts of the application. Variables declared inside the function are considered
    local variables. This means that they are only accessible to the code within the
    body of the function. You cannot access variables from outside of the function.
    The calling function does not have access to variables inside the called function.
    The input parameter's scope is the same as the local variable's scope to the function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables declared in the calling function are scoped to that function. This
    means that the variables are local to the function and those variables are not
    accessible outside of the function. Our function cannot reach into the calling
    function''s variables. To get access to those variables, they must be passed into
    our function as input parameters:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Figure 5.5: Error output for the m variable being undefined'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_05.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.5: Error output for the m variable being undefined'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code snippet will result in an error in `func greeting()` that
    states that `m` is undefined. That is because the `m` variable is declared inside
    `main()`. The `greeting()` function does not have access to the `m` variable.
    For it to have access to, the `m` variable must be passed to the `greeting()`
    function as an input parameter:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段将在`func greeting()`中导致错误，指出`m`未定义。这是因为`m`变量是在`main()`内部声明的。`greeting()`函数无法访问`m`变量。为了使其能够访问，必须将`m`变量作为输入参数传递给`greeting()`函数：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![Figure 5.6: Error output for the s variable being undefined'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6：s变量未定义时的错误输出'
- en: '](img/B14177_05_06.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_05_06.jpg)'
- en: 'Figure 5.6: Error output for the s variable being undefined'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：s变量未定义时的错误输出
- en: The previous code snippet will result in an error in `func main()`. The error
    will state that `s` is undefined. This is because the `s` variable is declared
    in the `greeting()` function. The `main()` function does not have access to the
    `s` variable. The `s` variable is only visible to code inside the function body
    of `greeting()`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段将在`func main()`中导致错误。错误将指出`s`未定义。这是因为`s`变量是在`greeting()`函数中声明的。`main()`函数无法访问`s`变量。`s`变量仅在`greeting()`函数体内部的代码中可见。
- en: These are just some considerations that we need to keep in mind when we are
    declaring and accessing variables. It is important to understand the scope of
    the variables inside a function in relation to the variables declared outside
    of a function. It can cause some confusion when you are trying to access variables
    but you are not scoped to the context that you are trying to access. The examples
    in this chapter should help you in understanding the scope of variables.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是我们在声明和访问变量时需要考虑的一些因素。了解函数内部变量与函数外部声明的变量的作用域关系非常重要。当您尝试访问变量但未处于您尝试访问的上下文的作用域时，可能会造成一些混淆。本章中的示例应有助于您理解变量的作用域。
- en: Return Values
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回值
- en: So far, the functions that we have created do not have any return values. Functions
    typically accept inputs, perform some action on those inputs, and then return
    the results of those inputs. Most programming languages return only one value.
    Go allows you to return multiple values from a function. This is one of the features
    of Go functions that distinguishes it from other programming languages.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的函数没有任何返回值。函数通常接受输入，对这些输入执行一些操作，然后返回这些输入的结果。大多数编程语言只返回一个值。Go允许您从函数中返回多个值。这是Go函数的一个特性，使其与其他编程语言区分开来。
- en: 'Exercise 5.03: Creating a fizzBuzz Function with Return Values'
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.03：创建具有返回值的fizzBuzz函数
- en: We are going to make some enhancements to our `fizzBuzz` function. We are going
    to change it so that it accepts only an integer. We will leave the onus on the
    caller to perform the looping if they desire to do so. Also, we are going to have
    two returns. The first will be the number provided and the corresponding text
    of empty string, `fizz`, `buzz`, or `fizzbuzz`. The following steps will help
    you with the solution.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对我们的`fizzBuzz`函数进行一些增强。我们将将其修改为只接受一个整数。如果调用者希望这样做，我们将把执行循环的责任留给调用者。此外，我们将有两个返回值。第一个将是提供的数字和相应的文本，空字符串、`fizz`、`buzz`或`fizzbuzz`。以下步骤将帮助您找到解决方案。
- en: Open the IDE of your choice.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您选择的IDE。
- en: Create a new file and save it at `$GOPATH\functions\fizzBuzzreturn\main.go`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，并将其保存到`$GOPATH\functions\fizzBuzzreturn\main.go`。
- en: 'In the `main()` function, assign variables to the return values of our function.
    The `n,` `s` variables correspond respectively to the values being returned from
    our function, `int`, `string`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`main()`函数中，将变量分配给我们的函数的返回值。`n,` `s`变量分别对应从我们的函数返回的值，`int`, `string`:'
- en: '[PRE27]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `fizzBuzz` function now returns two values; the first being an `int`, followed
    by a string.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fizzBuzz`函数现在返回两个值；第一个是`int`，后面跟着一个字符串。'
- en: '[PRE28]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Simplify the `if{}else{}` statements by replacing them with a `switch` statement.
    As you are writing code, you should look for ways to simplify things and make
    the code more readable. `case i%15 ==0` is equivalent to our previous `if i%15
    == 0` statements. Instead of our previous `fmt`. `Println()` statements, replace
    them with `return`. The `return` statement will immediately stop the execution
    of the function and return the results to the caller:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 `if{}else{}` 语句替换为 `switch` 语句来简化 `if{}else{}` 语句。在编写代码时，您应该寻找简化事物和使代码更易读的方法。`case
    i%15 ==0` 等同于我们之前的 `if i%15 == 0` 语句。用我们之前的 `fmt`。`Println()` 语句替换它们，用 `return`
    语句替换。`return` 语句将立即停止函数的执行并将结果返回给调用者：
- en: '[PRE29]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The expected output is as follows:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 5.7: Output for the fizzBuzz function with return values'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7：fizzBuzz 函数的返回值输出'
- en: '](img/B14177_05_07.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_05_07.jpg)'
- en: 'Figure 5.7: Output for the fizzBuzz function with return values'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：fizzBuzz 函数的返回值输出
- en: In this exercise, we saw how we can return multiple values from a function.
    We were able to assign variables to the multiple return values from the function.
    We also noticed that the assigned variables to the function match the order of
    the return values. In the following section, we will learn that in the body of
    the function, we can perform naked returns, where we do not need to specify the
    variable being returned in our return statement.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何从函数中返回多个值。我们能够将变量分配给函数的多个返回值。我们还注意到分配给函数的变量与返回值的顺序相匹配。在下一节中，我们将学习在函数体中，我们可以执行裸返回，其中我们不需要在我们的返回语句中指定要返回的变量。
- en: 'Activity 5.01: Calculating the Working Hours of Employees'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动五.01：计算员工的工时
- en: 'In this activity, we shall be creating a function that will calculate the working
    hours of employees for a week, which shall be used to calculate the payable salary
    amount. The `developer` struct has a field called `Individual` that is of type
    `Employee`. The `developer` struct keeps track of the `HourlyRate` that they charge
    and how many hours they work each day. The following steps shall help you to reach
    the solution:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将创建一个函数来计算员工一周的工作时间，这将用于计算应支付的工资金额。`developer` 结构体有一个名为 `Individual`
    的字段，其类型为 `Employee`。`developer` 结构体跟踪他们收取的小时费率和每天工作的小时数。以下步骤将帮助您找到解决方案：
- en: 'Create an `Employee` type that has the following fields: `Id` as `int`, `FirstName`
    as `string`, and `LastName` as `string`.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Employee` 类型，包含以下字段：`Id` 为 `int`，`FirstName` 为 `string`，和 `LastName` 为
    `string`。
- en: 'Create a `developer` type that has the following fields: `Individual Employee`,
    `HourlyRate` `int`, and `WorkWeek` `[7]int`.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `developer` 类型，包含以下字段：`Individual Employee`，`HourlyRate` `int`，和 `WorkWeek`
    `[7]int`。
- en: Create an `enum` for the seven days of the week. This will be of type `Weekday`
    `int` with a constant declaration for each day of the week.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为一周的七天创建一个 `enum`。这将是一个 `Weekday` `int` 类型的枚举，并为每周的每一天声明一个常量。
- en: Create a pointer receiver method called `LogHours` for `Developer` that will
    take the `WeekDay` type and `int` type as input. Assign the hours worked that
    day to the `Developer` workweek slice.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Developer` 创建一个名为 `LogHours` 的指针接收器方法，该方法将 `WeekDay` 类型和 `int` 类型作为输入。将当天工作的小时数分配给
    `Developer` 工作周切片。
- en: Create a method that is a pointer receiver called `HoursWorked()`. This method
    will return the total hours that have been worked.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `HoursWorked()` 的方法，这是一个指针接收器。该方法将返回已工作的总小时数。
- en: In the `main()` function, initialize and create a variable of the `Developer`
    type.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，初始化并创建一个 `Developer` 类型的变量。
- en: In the `LogHours` method, call the method for two days (such as Monday and Tuesday).
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LogHours` 方法中，调用两天的方法（例如周一和周二）。
- en: Print the hours for the two days of the previous step.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印上一步中两天的工作时间。
- en: Next, print the results of the `HoursWorked` method.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打印 `HoursWorked` 方法的输出结果。
- en: 'The following is the expected output:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为预期输出：
- en: '[PRE30]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 704.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 704 页找到。
- en: The aim of this activity is to demonstrate the ability to break problems down
    into manageable tasks to be implemented by functions, such that each of our functions
    has a single responsibility. `LogHours` is responsible for assigning the hours
    worked for each day. `HoursWorked` uses the values that were assigned in `LogHours`
    to display the hours worked each day. We have used return types from our functions
    to display the data. This exercise demonstrates utilizing functions correctly
    to provide a solution to a problem.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Naked Returns
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions that have return values must have a `return` statement as the last
    statement in the function. If you omit the return statement, the Go compiler will
    give you the following error: "missing return at the end of function."'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Typically, when a function returns two types, the second type is of type `error`.
    We have not gone over errors yet so in these examples, we are not demonstrating
    them. It is good to know that it is idiomatic in Go for the second return type
    to be of type `error`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Go also allows the ability to ignore a variable being returned. For example,
    say we are not interested in the `int` value that is being returned from our `fizzBuzz`
    function. In Go, we can use what is called a blank identifier; it provides a way
    to ignore values in an assignment:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For example, when reading a file, we might not be concerned about the number
    of bytes read. So, in that case, we can ignore the value being returned by using
    the blank identifier, "`_`". When there is extra data being returned from a function
    that does not provide any information that is needed by our program, such as the
    reading of a file, it is a good candidate for ignoring the return.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: As you will discover later, many functions return an error as the second return
    value. You should not ignore return values from functions that are errors. Ignoring
    an error returned by a function could result in unexpected behavior. Error return
    values should be handled appropriately.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding example, we are using the blank identifier, `_`, to ignore
    the `int` value being returned:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You must always have a placeholder for the values being returned when assigning
    values from a function. When performing an assignment, the placeholders must match
    the number of return values from the function. `_` and `s` are the placeholders
    for the return values of `int` and `string`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Go also has a feature that allows you to name your returns. If you use this
    feature, it can make your code more readable as well as self-documenting. If you
    name your return variables, they are under the same constraints as the local variables,
    as discussed in the previous topic. By naming your returns, you are creating local
    variables in the function. You can then assign values to those return variables,
    just as you do with input parameters:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code, (`name string`, `age int`) are named returns. They are
    now local variables to the function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `name` and `age` are local variables that were declared in the return
    list of the function, you can now assign values to them. They can be treated as
    local variables. In the `return` statement, specify the return values. If you
    do not specify the variable name in the return, it is called a **naked return**:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Consider the preceding code block. This code is the same as before with the
    exception that the return does not name the variables to return. The `return`
    statement will return the variables that are named in the return list.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the disadvantages of naked returns is that it can cause confusion when
    reading code. To avoid confusion and the possibility of other issues, it is recommended
    that you avoid using the naked returns feature. It can make it difficult to follow
    the variable that is to be returned. There can also be issues with shadowing when
    using naked returns:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding code will result in the following error:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: Output for shadowing with naked returns'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_08.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.8: Output for shadowing with naked returns'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: That is because the `err` variable is named in the `return` and is initialized
    in an `if` statement. Recall that variables that are initialized within curly
    braces, such as `for` loops, `if` statements, and `switch` statements, are scoped
    to that context, meaning that they are only visible and accessible within those
    curly braces.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.04: Mapping a CSV Index to a Column Header with Return Values'
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Exercise 5.02*, *Mapping Index Values to Column Headers*, we only printed
    the results of the index to the column header. In this exercise, we are going
    to return the map as the result. The map being returned is the index-to-column
    header mapping. The following steps will help you with the solution:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Open the IDE of your choice.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the file from the previous exercise: `$GOPATH\functions\indxToColHdr\main.go`.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, in the `main()` function, define the headers for the columns. First,
    we assign a variable to a key-value pair of `int` and `string`. `key(int)` will
    be the index of our `header(string)` column. The index will map to a column header:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We range over the `header` to process each string that is in the slice:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For each string, we remove any trailing spaces in front of and after the string.
    In general, we should always make the assumption that our data may have some erroneous
    characters:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In our `switch` statement, we lower all the casing for exact matches. As you
    may recall, Go is a case-sensitive language. We need to ensure the casing is the
    same for matching purposes. When our code finds the header, it sets the index
    value for the header in the map:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Open up a terminal and navigate to the code's directory.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output for return values is as follows:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this exercise, we saw a real-world example of mapping a CSV index to column
    headers. We used a function to solve this complex problem. We were able to have
    the function have a single return value of type `map`. In the next section, we
    are going to see how functions can accept a variable number of argument values
    within a single argument.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Variadic Function
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A variadic function is a function that accepts a variable number of argument
    values. It is good to use a variadic function when the number of arguments of
    a specified type is unknown.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding function is an example of what a variadic function looks like.
    The three dots (`…`) in front of the type is called a `Type` into `parameterName`.
    The variadic variable can accept zero or more variables as the argument:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `nums` function is a variadic function that accepts a type of `int`. As
    stated before, you can pass zero or more arguments of the type. If there is more
    than one value, you separate them with a comma, as in `nums(99,100)`. If there
    is only one argument to pass, you only pass that argument, as in `nums(200)`.
    If there isn't an argument to pass, you can leave it empty, as in `nums()`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Variadic functions can have other parameters. However, if your function requires
    multiple parameters, the variadic parameter must be the last parameter in the
    function. Also, there can only be one variadic variable per function. The following
    function is incorrect and will result in an error at compile time.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '**Incorrect function:**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![Figure 5.9: Variadic syntax error output'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_09.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.9: Variadic syntax error output'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '**Correct function:**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output would look as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You may have guessed by now that the actual type of `Type` inside the function
    is a slice. The function takes the arguments being passed in and converts them
    to the new slice being specified. For example, if the variadic type is `int`,
    then once you are inside the function, Go converts that variadic `int` to a slice
    of integers:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: Conversion of a variadic int into a slice of integers'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_10.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.10: Conversion of a variadic int into a slice of integers'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The variadic function''s output is as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `nums()` function is showing that the variadic type of `i` is a slice of
    integers. Once in the function, `i` will be a slice of integers. The variadic
    type has length and capacity, which is to be expected for a slice. In the next
    code snippet, we will try to pass a slice of integers to a variadic function,
    `nums()`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![Figure 5.11: Variadic function error'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_11.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.11: Variadic function error'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Why didn''t this code snippet work? We just proved that the variadic variable
    inside the function is of type `slice`. The reason is that the function is expecting
    a list of arguments of type `int` to be converted to a slice. Variadic functions
    work by converting the arguments passed to a slice of the type being specified.
    However, Go has a mechanism for passing a slice to a variadic function. We need
    to use the unpack operator; it is three dots (`…`). When you call a variadic function
    and you want to pass a slice as an argument to a variadic parameter, you need
    to place the three dots before the variable:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The difference between this version of the function and the previous is the
    calling code to the function, `nums`. The three dots are put after the `i` variable
    is a slice of integers. This allows a slice to be passed to the variadic function.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.05: Summing Numbers'
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to sum up a variable number of arguments. We
    will pass the arguments as a list of arguments and as a slice. The return value
    will be an `int`, the sum of the values we passed to the function. The following
    steps will help you with the solution:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Open the IDE of your choice.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file and save it at `$GOPATH\functions\variadic\main.go`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `sum` function accepts a variadic argument of type `int`. Since it gets
    converted to a slice, we can range over the values and return the sum of all the
    values that get passed:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Open up a terminal and navigate to the code's directory.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output for summing numbers is as follows:'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this exercise, we saw that by using a variadic parameter, we can accept an
    unknown number of arguments. Our function allows us to sum up any number of integers.
    We can see that variadic parameters can be utilized to solve specific problems
    where the number of values of the same type being passed as an argument is unknown.
    In the next section, we are going to look at how to create a function without
    a name and assign a function to a variable.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Functions
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have been using named functions. As you may recall, named functions
    are functions that have an identifier or a function name. Anonymous functions
    can be declared within another function.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions, also referred to as function literals, are functions that
    do not have a function name, hence the name "anonymous functions." An anonymous
    function is declared in a similar way to how a named function is declared. The
    only difference with the declaration is that the name for the function is omitted.
    Anonymous functions can do basically whatever a normal function in Go does, including
    accepting arguments and returning values.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will be introducing the fundamentals of anonymous functions
    and some of their basic uses. Later, you will also see how anonymous functions
    can be fully utilized. Anonymous functions are used for and in conjunction with
    the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Closure implementations
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: defer statements
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a code block to be used with a Goroutine
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a function for one-time use
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a function to another function
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a basic declaration for an anonymous function:'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Notice that we are declaring a function inside another function. As with named
    functions, you must start with the `func` keyword to declare a function.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the `func` keyword would normally be the name of the function, but
    with anonymous functions, there is no function name. Instead, there are empty
    parentheses.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The empty parentheses following the `func` keyword is where the function's parameters
    would be defined for the function.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is the open curly brace, `{`, which starts the function body.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function body is only a one-liner; it will print "`Greeting`".
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The closing curly brace, `}`, denotes the end of the function.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last set of parentheses are called the execution parentheses. These parentheses
    invoke the anonymous function. The function will execute immediately. Later, we
    will see how to execute an anonymous function at a later location within the function.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also pass arguments to an anonymous function. To be able to pass arguments
    to an anonymous function, they must be supplied in the execution parentheses:'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`func (str string)`: The anonymous function being declared has an input parameter
    of type `string`.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`} (message)`: The argument message being passed to the execution parentheses.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have currently been executing anonymous functions at the moment they are
    declared, but there are other ways to execute anonymous functions. You can also
    save the anonymous function to a variable. This leads to a different set of opportunities
    that we will look at in this chapter:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We are assigning the `f` variable to our anonymous function.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` is now of type `func()`.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` now can be used to invoke the anonymous function, in a fashion similar
    to that for a named function. You must include the `()` after the `f` variable
    to execute the function.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 5.06: Creating an Anonymous Function to Calculate the Square Root
    of a Number'
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Anonymous functions are great for small snippets of code that you want to execute
    within a function. Here, we are going to create an anonymous function that is
    going to have an argument passed to it. It will then calculate the square root.
    The following steps will help you with the solution:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Use the IDE of your choice.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file and save it at `$GOPATH\functions\anonymousfnc\main.go`.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`. We are assigning our `x` variable to
    our anonymous function. Our anonymous function takes a parameter, (`i int`). It
    also returns a value of `int`:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Notice that the last curly brace does not have the `()` to execute the function.
    We call our anonymous function using `x(j)`:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Open up a terminal and navigate to the code's directory.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this exercise, we saw how to assign a variable to a function and later call
    that function by using the variable that was assigned to it. We saw that when
    we need a small function that might not be reusable in our program, we can create
    an anonymous function and assign it to a variable. In the next section, we are
    going to expand the use of anonymous functions into closures.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have introduced anonymous function syntax using some basic examples. Now
    that we have a fundamental understanding of how anonymous functions work, we will
    look at how we can use this powerful concept. Closures are a form of anonymous
    functions. Regular functions cannot reference variables outside of themselves;
    however, an anonymous function can reference variables external to their definition.
    A closure can use variables declared at the same level as the anonymous function''s
    declared. These variables do not need to be passed as parameters. The anonymous
    function has access to these variables when it is called:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**Code synopsis:**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: We initialize a variable in the `main()` function called `i` and set it to `0`.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We assign `incrementor` to our anonymous function.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The anonymous function increments `i` and returns it. Notice that our function
    does not have any input parameters.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then print the results of `incrementor` twice and get `1` and `2`.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that outside our function we increment `i` by `10`. This is a problem.
    We want `i` to be isolated and for it not to change, as this is not the desired
    behavior. When we print the results of `incrementor` again, it will be `12`. We
    want it to be `3`. We will correct this in our next example.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One problem with the previous example that we notice is that any code in the
    main function has access to `i`. As we saw in the example, `i` can be accessed
    and changed outside of our function. This is not the desired behavior; we want
    the incrementor to be the only one to change that value. In other words, we want
    `i` to be protected from other functions changing it. The only function that should
    be changing it is our anonymous function when we call it:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**Code synopsis:**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: We declared a function called `incrementor()`. This function has a return type
    of `func()` `int`.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`i := 0`: We initialize our variable at the level of the `incrementor()` function;
    this is similar to what we did in the previous example, except it was at the `main()`
    function level and anyone at that level had access to `i`. Only the `incrementor()`
    function has access to the `i` variable with this implementation.'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are returning our anonymous function, `func()` `int`, which increments the
    `i` variable.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main()` function, `increment:=incrementor()` assigns a variable to the
    `func()` `int` that gets returned. It is important to note that `incrementor()`
    only gets executed once here. In our `main()` function, it is no longer being
    referenced or executed.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Increment()` is of type `func()` `int`. Each call to `increment()` runs the
    anonymous function code. It is referencing the `i` variable, even after `incrementor()`
    has executed.'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exercise 5.07: Creating a Closure Function to Decrement a Counter'
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to create a closure that decrements from a given
    starting value. We are combining what we have learned about passing an argument
    to an anonymous function and using that knowledge with a closure. The following
    steps will help you with the solution:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Open the IDE of your choice.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file and save it at `$GOPATH\closureFnc\variadic\main.go`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We will look at the `decrement` function first. It takes an argument of type
    `int` and has a return value of `func()int`. In previous examples, the variable
    was declared inside the function but before the anonymous function. In this exercise,
    we have it as an input parameter:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We decrement `i` by one inside the anonymous function:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the `main()` function, we initialize a variable counter to be used as our
    starting integer to be decremented:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`x:= decrement(counter)` : `x` is assigned to `func()` `int`. Each call to
    `x()` runs the anonymous function:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Open up a terminal and navigate to the code's directory.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output for the `decrement` counter is as follows:'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In this exercise, we saw that closures have access to variables that are external
    to them. This allowed our anonymous function to make changes to the variable that
    a normal function would not be able to make. In the next section, we are going
    to look at how functions can be passed as arguments to another function.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Function Types
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have seen so far, Go has rich feature support for functions. In Go, functions
    are types too, just like `int`, `string`, and `bool` are types. This means we
    can pass functions as arguments to other functions, functions can be returned
    from a function, and functions can be assigned to variables. We can even define
    our own function types. A function''s type signature defines the types of its
    input parameters and return values. For a function to be of the type of another
    function, it must have the exact signature of the type function that is declared.
    Let''s examine a few function types:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The preceding code snippet creates a new function type called message. It has
    no input parameters and does not have any return types.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine another one:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The preceding code snippet creates a new function type called calc. It accepts
    two arguments of type int and its return value is of type string.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a fundamental understanding of function types, we can write
    some code to demonstrate their uses:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let''s look at the code by the line:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`type calc` declares `calc` to be of type `func`, determining that it takes
    two integers as arguments and returns a string:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`func add(i,j int) string` has the same signature as type `calc`. It takes
    two integers as arguments and returns a string stating "Adding `i + j = result`".
    Functions can be passed to other functions just like any other type in Go:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`func calculator(f calc, i, j int)` accepts type `calc` as input. The `calc`
    type, as you may remember, is a function type that has input parameters of `int`
    and a return type of `string`. Anything that matches that signature can be passed
    to the function. The `func calculator` function returns the result of the function
    of type `calc`.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, we call `calculator`(`add`,`5`,`6`). We are passing
    it the `add` function. `add` satisfies the signature of type `calc func`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.12* summarizes each of the preceding functions and how they relate
    to each other. The figure shows how `func add` is of type `func calc`, which then
    allows it to be passed as an argument to `func calculator`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Function types and uses'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_12.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.12: Function types and uses'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'We have just seen how to create a function type and pass it as an argument
    to a function. It is not that far of a stretch to pass a function as a parameter
    to another function. We will change our previous example slightly to reflect passing
    a function as a parameter:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We modify the `add` function signature to return an `int` instead of a string.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We added a second function called `subtract`. Note that its function signature
    is the same as that of the `add` function. The `subtract` function simply returns
    the result of subtracting two numbers:'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`calculator(f func(int,int)int,i,j int)`: The `calculator` function now has
    an input parameter of type `func` The input parameter, `f`, is a function that
    accepts two integers and returns an `int`. Any function that satisfies the signature
    can be passed to the function.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `main()` function, `calculator` is called twice: once with the `add`
    function and some integer values being passed and once with the `subtract` function
    being passed as an argument with some integer values.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ability to pass functions as a type is a very powerful feature that can
    pass different functions to other functions as long as their signatures match
    the passed-to function''s input parameter. It is quite simple when you think about
    it. An integer type for a function can be any value as long as it is an integer.
    The same goes for passing functions: a function can be any value as long as it
    is the correct type.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'A function can also be returned from another function. We saw this when using
    anonymous functions combined with closures. Here, we will take a brief look since
    we have already seen this syntax in a previous section:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Returning a function looks as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`square(x int) func() int`: The `square` function accepts an `int` as an argument
    and returns a function type that returns an `int`:'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In the `square` body, we assign a variable, `f`, to an anonymous function that
    returns the square value of the input parameter, `x`.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `return` statement for the `square` function returns an anonymous function
    that is of type `func()` int.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v` is assigned to the return of the `square` function. As you may recall,
    the return value is of type `func()` int.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v` has been assigned type `func ()int`; however, it has not been invoked.
    We will invoke it inside the `print` statement.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fmt.Printf("Type of v: %T",v)`: This statement just prints out the type for
    `v`, which is `func()int`.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 5.08: Creating Various Functions to Calculate Salary'
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to be creating several functions. We need the ability to calculate
    the salary of a developer and a manager. We want this solution to be extensible
    for the future possibilities of other salaries to be calculated. We will be creating
    functions to calculate the developer and manager salary. Then we will create another
    function that will take the previously mentioned function as input parameter.
    The following steps will help you with the solution:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Use the IDE of your choice.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file and save it at `$GOPATH\function\funcAsParam\main.go`.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `salary` function accepts a function that accepts two integers as arguments
    and returns an int. So, any function that matches that signature can be passed
    as an argument to the `salary` function:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In the body of the `salary()` function, `pay` is assigned the value that gets
    returned from the `f` function. It passes `x` and `y` parameters as parameters
    to the `f` parameter:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Notice that the `managerSalary` and `developerSalary` signatures are identical
    and they match the function `f` for `salary`. This means that both `managerSalary`
    and `developerSalary` can be passed as `func(int,int) int`:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`devSalary` and `bossSalary` get assigned to the results of the `salary` function.
    Since `developerSalary` and `managerSalary` satisfy the signature of `func(int,int)
    int`, they each can be passed in as arguments:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Open a terminal and navigate to the code's directory.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In this exercise, we saw how a function type can be a parameter for another
    function. This allows a function to be an argument to another function. This exercise
    showed how our code can be simplified by having one `salary` function. If, in
    the future, we need to calculate the salary for a tester position, we would only
    need to create a function that matches the function type for `salary` and pass
    it as an argument. The flexibility that this gives is that we do not have to change
    our `salary` function's implementation. In the next section, we are going to see
    how we can change the execution flow of a function, specifically after the function
    returns.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: defer
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The defer statement defers the execution of a function until the surrounding
    function returns. Let''s try to explain this a bit better. Inside a function,
    you have a `defer` in front of a function that you are calling. That function
    will execute essentially right before the function you are currently inside completes.
    Still confused? Perhaps an example will make this concept a little clearer:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The output for the `defer` example is as follows:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Inside the `main()` function, we have a deferred function, `defer` `done()`.
    Notice that the `done()` function has no new or special syntax. It just has a
    simple print to `stdout`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have two print statements. The results are interesting. The two `print`
    statements in the `main()` function print first. Even though the deferred function
    was first in `main()`, it printed last. Isn't that interesting? Its ordering in
    the `main()` function did not dictate its order of execution.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: The deferred functions are commonly used for performing "clean-up" activities.
    That would include the release of resources, the closing of files, the closing
    database connections, and the removal of configuration\temp files created by a
    program. The `defer` functions are also used to recover from a panic; this is
    discussed in a later chapter.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `defer` statement is not limited to just named functions. In fact,
    you can utilize the defer statement with anonymous functions. Taking our previous
    code snippet, let''s turn it into deferred call with an anonymous function:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: There is not much that has changed from the previous code. We took the code
    that was in the `done` function and created a deferred anonymous function.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `defer` statement is placed before the `func()` keyword. Our function has
    no function name. As you may recall, a function without a name is an anonymous
    function.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results are the same as those from the previous example. The readability,
    to a certain extent, is easier than having the deferred function declared as a
    named function, as in the previous example.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also possible and common to have multiple `defer` statements in a function.
    However, they may not execute in the order that you expect. When using `defer`
    statements in front of functions, the execution follows the order of `defer` statement
    placed in front of them:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The multiple `defer` output looks as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The first three anonymous functions are having their execution deferred.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We declare `f1` and `f2` of type `func()`. These two functions are anonymous
    functions.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, our `f1()` and `f2()` executed as expected, but the order of
    the multiple `defer` statements executed in the reverse order of how they were
    declared in the code. The first `defer` was the last to execute and the last `defer`
    was the first to execute.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Careful consideration must be given when using `defer` statements. A situation
    that you should consider is when you use `defer` statements in conjunction with
    variables. When a variable is passed to a deferred function, the variable''s value
    at that time is what will be used in the deferred function. If that variable is
    changed after the deferred function, it will not be reflected when the deferred
    function runs:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output would be as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '`age`:= `25`: We initialize the `age` variable to `25` before the `defer` function.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name:=` `"John"`: We initialize the `name` variable to `"John"` before the
    `defer` function.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defer` `personAge`(`name`,`age`): We state that the function is going to be
    deferred.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`age*=2`: We double the age after the deferred function. We then print the
    current value of `age` doubled.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`personAge`(`name` `string`, `i` `int`): This is the function that is deferred;
    it only prints out the person and age.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results show the value of `age` (`25`) after it has been doubled in the
    `main` function.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the execution of the program reaches the line that has `defer` `personAge(name,age)`,
    the value of `age` is `25`. Before the `main()` function completes, the deferred
    function runs and the value of `age` is still `25`. Variables used in the deferred
    function are the values before it was deferred, regardless of what happens after
    it.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Activity 5.02: Calculating Payable Amount for Employees Based on Working Hours'
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This activity is based on the previous activity. We will keep the same functionality
    but we will be adding three additional features. In this version of the application,
    we would like to give the employee the ability to track their hours throughout
    the day without having logged them yet. This will allow the employees to keep
    better track of their hours before they log them at the end of the day. We are
    also enhancing the application to calculate the employee''s pay. The application
    will calculate their pay for any overtime they worked. The application will also
    print out details of how many hours were worked each day:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Create a function called `nonLoggedHours()` `func(int)` `int`. Each time this
    function is called, it will calculate the hours of the employee that have not
    been logged. You will be using a closure inside the function.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method called `PayDay()(int,bool)`. This method will calculate the
    weekly pay. It needs to take into consideration overtime pay. The method will
    pay twice the hourly rate for hours greater than 40\. The function will return
    `int` as the weekly pay and `bool` for if the pay is overtime pay. The Boolean
    will be true if the employee worked more than `40` hours and false if they worked
    less than `40` hours.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method called `PayDetails()`. This method will print each day and the
    hours worked that day by the employee. It will print the total hours for the week,
    the pay for the week, and if the pay contains overtime pay.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside of the `main` function, initialize a variable of type `Developer`. Assign
    a variable to `nonLoggedHours`. Print the variable assigned to `nonLoggedHours`
    with values of `2`, `3`, and `5`.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, in the `main()` function, log the hours for the following days: Monday
    8, Tuesday 10, Wednesday 10, Thursday 10, Friday 6, and Saturday 8.'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then run the `PayDetails()` method.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.13: Output for payable amount activity'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_13.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.13: Output for payable amount activity'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 706.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to go a step further than *Activity 5.01,* *Calculating
    the Working Hours of Employees*, by using some more advanced programming with
    Go's functions. In this activity, we will continue to use functions as we did
    previously; however, we will be returning multiple values and returning a function
    from a function. We also demonstrate the use of closures for calculating hours
    not logged by an employee.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have studied why and how functions are an essential part of the Go programming
    language. We also discussed various features of functions in Go that make Go stand
    apart from other programming languages. Go has features that allow us to solve
    a lot of real-world problems. Functions in Go serve many purposes, including enhancing
    the usage and readability of code. We learned how to create and call functions.
    We studied the various types of functions used in Go and discussed scenarios where
    each of the function types can be used. We also expounded the concept of closures.
    Closures are essentially a type of anonymous function that can use variables declared
    at the same level as that at which the anonymous function was declared. We also
    discussed various parameters and return types and studied `defer`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we shall be exploring errors and error types and learning
    how to build custom errors, thus building a recovery mechanism to handle errors
    in Go.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
