- en: 5\. Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will describe the various parts of a function in detail, such as
    defining the function, function identifiers, parameter lists, return types, and
    the function body. We will also look at some best practices when designing our
    functions, such as a function performing a single task, how to reduce code, making
    your function small, and ensuring that functions are reusable.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to describe a function and the
    different parts that make up a function and evaluate the scope of variables with
    functions. You will learn to create and call a function; utilize variadic and
    anonymous functions and create closures for various constructs. You will also
    learn to use functions as parameters and return values; and use `defer` statements
    with functions.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions are a core part of many languages and Go is no exception. A function
    is a section of code that has been declared to perform a task. Go functions can
    have zero or more inputs and outputs. One feature that sets Go apart from other
    programming languages is the multiple return values; most programming languages
    are limited to one return value.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will see some features of Go functions that differ
    from other languages, such as returning multiple types. We will also see that
    Go has support for first-class functions. This means that Go has the ability to
    assign a variable to a function, pass a function as an argument, and have a function
    as a return type for a function. We will show how functions can be used to break
    up complex parts into smaller parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions in Go are considered first-class citizens and higher-order functions.
    First-class citizens are the functions that are assigned to a variable. Higher-order
    functions are functions that can take a function as an argument. The rich features
    of Go functions empower them to be used in various segments in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions to be passed as an argument to another function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a function as a value from a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions as a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymous functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions assigned to a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be looking at each of these features that are supported in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are a critical part of Go and we should understand their place. Let''s
    examine some of the reasons for using functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Breaking up a complex task**: Functions are used to perform a task, but if
    that task is complicated, it should then be broken down into smaller tasks. Functions
    can be used for small tasks to solve a bigger problem. Smaller tasks are more
    manageable, and using a function to solve specific tasks will make the entire
    code base easier to maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reducing code**: A good indication that you should use a function is when
    you see similar code repeating throughout your program. When you have duplicate
    code, it increases the difficulty of maintenance. If you have one change to make,
    you will have multiple instances where your code needs to change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability**: Once you have defined your function, you can use it repeatedly.
    It can also be used by other programmers. This sharing of functions will also
    reduce lines of code and save time by allowing you to not have to reinvent the
    wheel. There are a couple of guidelines we should follow when we design functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single responsibility**: A function should perform one task. For example,
    a single function should not calculate the distance between two points and estimate
    the time to travel between those two points. There should be a function for each
    of those tasks. This allows for better testing of that function and easier maintenance.
    It is difficult to narrow a function to perform a single task, so do not get discouraged
    if you do not get it right the first time. Even seasoned programmers struggle
    with assigning a single responsibility to a function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Small in size**: Functions should not span over hundreds of lines of code.
    This is an indication that the code needs some refactoring. When we have large
    functions, it''s more likely that the single responsibility principle will be
    violated. A good rule of thumb is trying to limit the function size to approximately
    25 lines of code; however, that''s not a hard-and-fast rule. The benefit of keeping
    the code concise is that it reduces the complexity of debugging a large function.
    It also makes writing unit tests with better code coverage easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parts of a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now be looking at the different components involved in defining a function.
    The following is the typical layout of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Different parts of a function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.1: Different parts of a function'
  prefs: []
  type: TYPE_NORMAL
- en: 'The different parts of a function are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func` keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calculateTax`, `totalSum`, and `fetchId`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The identifier should be something descriptive that makes the code easy to read
    and makes the purpose of the function easy to understand. The identifier is not
    required. You can have a function with no name; this is known as an anonymous
    function. Anonymous functions will be discussed in detail in a later part of the
    chapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When the first letter of the function name is in lowercase, then the function
    is not exportable outside of a package. This means they are private and cannot
    be called from outside the package. They can only be called within the package.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Keep this in mind when you use camelCase naming convention. If you want your
    function to be exportable, the first letter of the function name must be capitalized.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name string`, `age int`). Parameters are local variables to the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters are optional for a function. It is possible to not have any parameters
    for a function. A function can have zero or more parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When two or more parameters have the same type, you can use what is called shorthand
    parameter notation. This removes specifying the same type for each parameter.
    For instance, if your parameters are (`firstName string`, `lastName string`),
    they can be shortened to (`firstName`, `lastName string`). This reduces the verbosity
    of the parameter inputs and increases the readability of the function parameter
    list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Return types**: Return types are a list of data types, such as Boolean, string,
    map, or another function that can be returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the context of declaring a function, we refer to these types as return types.
    However, in the context of calling a function, they are called return values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Return types are the output of the function. Often, they are the result of the
    arguments provided to the function. They are optional. Most programming languages
    return a single type; in Go, you can return multiple types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`{}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The statements in the function are what determine what the function does. The
    function code is the code that is being used to perform the task that the function
    was created to accomplish.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If there were return types defined, then a `return` statement is required in
    the function body. The `return` statement causes the function to immediately stop
    and return the value types listed after the `return` statement. The types in the
    return type list and in the `return` statement must match.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the function body, there can be multiple `return` statements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Function signature**: Though not listed in the preceding code snippet, a
    function signature is a term that references the input parameters combined with
    the return types. Both of those units make up a function signature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, when you define the function signature when it is being used by others,
    you want to strive to not make changes to it as this can adversely impact your
    code and the code of others.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will be diving deep into each of the parts of a function as we progress through
    the chapter. These parts of a function will become easier to understand through
    the following discussion, so don't worry if you do not quite understand all the
    parts yet. It will become clearer as we go through the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: fizzBuzz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have looked at the different parts of the function, let''s see
    how these parts work with various examples. Let''s start with a classical programming
    game called `fizzBuzz`. The rules of `fizzBuzz` are straightforward. The `fizzBuzz`
    function prints out various messages based on some math results. The rules perform
    one of the actions based on the number given:'
  prefs: []
  type: TYPE_NORMAL
- en: If the number is divisible by `3`, print `Fizz`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the number is divisible by `5`, print `Buzz`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the number is divisible by `15`, print `FizzBuzz`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Else, print the number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the code snippet to achieve this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the code in sections now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`func`, as you may recall, is the keyword to declare a function. This informs
    Go that the following piece of code is going to be a function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fizzBuzz` is the name of our function. It is idiomatic in Go to use a camelCase
    name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`()`, the parenthesis following the name of our function, is empty: our current
    implementation of the `FizzBuzz` game does not require any input parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The space between the parameter list, `()`, and the opening brace would be the
    return type. Our current implementation does not require a return type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding `{`, unlike other programming languages that you may know, Go requires
    that the opening curly brace is on the same line as the function declaration.
    If the opening brace is not on the same line as the function signature when you
    attempt to run the program, you will get an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding line is a `for` loop that increments the `i` variable from `1`
    to `30`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`%` is a modulus operator; it gives the remainder of the two integers being
    divided. Using our function, if `i` is `15`, then `15%15` will return zero. We
    use the modulus operator to determine whether `i` is evenly divisible by `3`,
    `5`, or `15`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we become more familiar with Go concepts and language syntax, the explanation
    of the code will exclude items that we would otherwise be going over multiple
    times.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We have now defined our function. It has a specific task we want it to perform,
    but it doesn't do any good if we do not execute the function. So, how do we execute
    a function? We must call our function. When we call a function, we are telling
    our program to execute the function. We will be calling our function inside the
    `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions can call other functions. When this occurs, control is given to the
    function that was called. After the called function has returned data or reached
    the ending curly brace, `}`, control is given back to the caller. Let''s see an
    example to understand this better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`}fmt.Println("Main is in control")`: This `print` statement is for demonstration
    purposes. It shows that we are in the `main()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fizzBuzz()`: We are now calling the function inside the `main()` function.
    Even though there are no parameters for our function the parentheses are still
    required, control of the program is given to the `fizzBuzz()` function. After
    the `fizzBuzz()` function completes, control is then given back to the `main()`
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fmt.Println("Back to main")`: The `print` statement is for demonstration purposes
    to show that control has been given back to the `main()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.2: Output for fizzBuzz'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.2: Output for fizzBuzz'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The parentheses following the `fizzBuzz` function are still required even though
    there are no input parameters. If they are omitted, the Go compiler will generate
    an error that states `fizzBuzz` evaluated but not used. This is a common error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: Output for fizzBuzz without parentheses'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.3: Output for fizzBuzz without parentheses'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.01: Creating a Function to Print Salesperson Expectation Ratings
    from the Number of Items Sold'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will be creating a function that will not have any parameters
    or return types. The function will iterate over a map and print the name and number
    of items sold in the map. It will also print a statement based on how the salesperson
    performed based on their sales. The following steps will help you with the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file and save it as `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`. The first function that `main` will
    call on `printAge()`; it does not have any parameters and has no return values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now define our function for printing the age and a message about the
    age of the person:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `itemsSold()` function, initialize a map that will have a key-value
    pair of `string`, `int`. The map will hold a `name`(`string`) and the number of
    `items`(`int`) sold. The name is the key for the map. We assign various names
    to number of items sold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We iterate over the `items` map and assign `k` to the `key`(`name`) and `v`
    to the `value`(`items`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We print out the `Name` and the number of sold `items`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Depending on the value of `v`(`items`), we will determine the statement we
    print:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open your terminal and navigate to the code's directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and then run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we saw some of the fundamental parts of a function. We demonstrated
    how to declare a function using the `func` keyword, followed by how to give our
    function an identifier or name such as `itemsSold()`. We then proceed to add code
    to the function body. In the next topics, we will expand on these core parts of
    the function and learn how to pass data into a function using parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is best to type the code into an IDE. The benefit is that if you type something
    incorrectly, you will see the error message and can perform some debugging to
    solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Parameters define what arguments can be passed to our function. Functions can
    have zero or more parameters. Even though Go allows us to define multiple parameters,
    we should take care not to have a huge parameter list; that would make the code
    harder to read. It also may be an indication that the function is doing more than
    one specific task. If that is the case, we should refactor the function. Take,
    for example, the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is an example of a function whose parameter list is bloated.
    The parameter list should pertain only to the single responsibility of the function.
    We should only define the parameters that are needed to solve the specific problem
    that the function is built for.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters are the input types that our function will use to perform its task.
    Function parameters are local to the function, meaning they are only available
    to that function. They are not available outside of the context of the function.
    Also, the order of the parameters must match the parameter types in the correct
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Correct:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output when the correct parameter matches would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Incorrect:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Output for incorrect parameter matching'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.4: Output for incorrect parameter matching'
  prefs: []
  type: TYPE_NORMAL
- en: In the incorrect version of the code, we are calling the `greeting()` function
    with the `age` argument of type `integer` when the parameter is of type `string`.
    The sequence of your arguments must match the sequence of the parameter input
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, users would want to have more control over the data the code
    iterates over. Going back to the `fizzBuzz` example, the current implementation
    only does `1` to `100`. Users may need to work on different number ranges and
    hence we need a way to decide the ending range of the loop. We can change our
    `fizzBuzz` function to accept an input parameter. This would meet the needs of
    our user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For `fizzBuzz(10)` in the `main()` function, we pass `10` as an argument to
    our `fizzBuzz` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `fizzBuzz(end int)`, `topEnd` is the name of our parameter and it is of
    type `int`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our function now will only iterate up to the value of our end parameter; in
    this example, it will iterate to `10`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Difference between an Argument and a Parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a good time to discuss the difference between an argument and a parameter.
    When you are defining your function, using our example, `fizzBuzz`(`end int`)
    is called a parameter. When you call a function, such as `fizzBuzz(10)`, 10 is
    called the argument. Also, the argument and parameter names do not need to match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions in Go also can have more than one parameter defined. We need to add
    another parameter to our `fizzBuzz` function to accommodate this enhancement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Regarding `fizzBuzz(s,e)`, we are now passing two arguments to the `fizzBuzz`
    function. When there are multiple arguments, they must be separated by a comma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding `func fizzBuzz`(`start int`, `end int`), when multiple parameters
    are defined in a function, they are separated by commas, following the convention
    of name type, name type, name type, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `fizzBuzz` parameters are more verbose than what is necessary. When we
    have multiple input parameters of the same type, you can separate the input name
    by a comma followed by the type. This is referred to as shorthand parameter notation.
    See the following example of using shorthand parameter notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: There is no change to the caller when using shorthand parameter notation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regarding `fizzBuzz`(`start`,`end int`), `start` and `end` are of type `int`.
    Nothing needs to change in the body of the function to accommodate the shorthand
    parameter notation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 5.02: Mapping Index Values to Column Headers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The function that we are going to create will be taking a slice of column headers
    from a CSV file. It will print out a map of an index value of the headers we are
    interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file and save it `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we assign a variable to a key-value pair of `int` and `string`. `key`(`int`)
    will be the index of our `header`(`string`) column. The index will map to a column
    header.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We range over the `header` to process each string that is in the slice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each string, remove any trailing spaces in front of and after the string.
    In general, we should always make the assumption that our data may have some erroneous
    characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our `switch` statement, we lower all the casing for exact matches. As you
    may recall, Go is a case-sensitive language. We need to ensure that the casing
    is the same for matching purposes. When our code finds the header, it sets the
    index value for the header in the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Typically, we would not print out the results. We should return the `csvHeadersToColumnIndex`,
    but since we have not gone over how to return a value, we will print it for now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open your terminal and navigate to the code's directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we saw how to accept data into a function, by defining a parameter
    for our function. The callers of our function were able to pass arguments to the
    function. We will continue to discover various abilities that functions in Go
    can provide. We have seen how to get data into our function. In the next section,
    we will see how to get data out of our function.
  prefs: []
  type: TYPE_NORMAL
- en: Function Variable Scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When designing functions, we need to consider the variable scope. The scope
    of a variable determines where the variable is accessible or visible to the different
    parts of the application. Variables declared inside the function are considered
    local variables. This means that they are only accessible to the code within the
    body of the function. You cannot access variables from outside of the function.
    The calling function does not have access to variables inside the called function.
    The input parameter's scope is the same as the local variable's scope to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables declared in the calling function are scoped to that function. This
    means that the variables are local to the function and those variables are not
    accessible outside of the function. Our function cannot reach into the calling
    function''s variables. To get access to those variables, they must be passed into
    our function as input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 5.5: Error output for the m variable being undefined'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.5: Error output for the m variable being undefined'
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code snippet will result in an error in `func greeting()` that
    states that `m` is undefined. That is because the `m` variable is declared inside
    `main()`. The `greeting()` function does not have access to the `m` variable.
    For it to have access to, the `m` variable must be passed to the `greeting()`
    function as an input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 5.6: Error output for the s variable being undefined'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.6: Error output for the s variable being undefined'
  prefs: []
  type: TYPE_NORMAL
- en: The previous code snippet will result in an error in `func main()`. The error
    will state that `s` is undefined. This is because the `s` variable is declared
    in the `greeting()` function. The `main()` function does not have access to the
    `s` variable. The `s` variable is only visible to code inside the function body
    of `greeting()`.
  prefs: []
  type: TYPE_NORMAL
- en: These are just some considerations that we need to keep in mind when we are
    declaring and accessing variables. It is important to understand the scope of
    the variables inside a function in relation to the variables declared outside
    of a function. It can cause some confusion when you are trying to access variables
    but you are not scoped to the context that you are trying to access. The examples
    in this chapter should help you in understanding the scope of variables.
  prefs: []
  type: TYPE_NORMAL
- en: Return Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, the functions that we have created do not have any return values. Functions
    typically accept inputs, perform some action on those inputs, and then return
    the results of those inputs. Most programming languages return only one value.
    Go allows you to return multiple values from a function. This is one of the features
    of Go functions that distinguishes it from other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.03: Creating a fizzBuzz Function with Return Values'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to make some enhancements to our `fizzBuzz` function. We are going
    to change it so that it accepts only an integer. We will leave the onus on the
    caller to perform the looping if they desire to do so. Also, we are going to have
    two returns. The first will be the number provided and the corresponding text
    of empty string, `fizz`, `buzz`, or `fizzbuzz`. The following steps will help
    you with the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Open the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file and save it at `$GOPATH\functions\fizzBuzzreturn\main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `main()` function, assign variables to the return values of our function.
    The `n,` `s` variables correspond respectively to the values being returned from
    our function, `int`, `string`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `fizzBuzz` function now returns two values; the first being an `int`, followed
    by a string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Simplify the `if{}else{}` statements by replacing them with a `switch` statement.
    As you are writing code, you should look for ways to simplify things and make
    the code more readable. `case i%15 ==0` is equivalent to our previous `if i%15
    == 0` statements. Instead of our previous `fmt`. `Println()` statements, replace
    them with `return`. The `return` statement will immediately stop the execution
    of the function and return the results to the caller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The expected output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.7: Output for the fizzBuzz function with return values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.7: Output for the fizzBuzz function with return values'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw how we can return multiple values from a function.
    We were able to assign variables to the multiple return values from the function.
    We also noticed that the assigned variables to the function match the order of
    the return values. In the following section, we will learn that in the body of
    the function, we can perform naked returns, where we do not need to specify the
    variable being returned in our return statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5.01: Calculating the Working Hours of Employees'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we shall be creating a function that will calculate the working
    hours of employees for a week, which shall be used to calculate the payable salary
    amount. The `developer` struct has a field called `Individual` that is of type
    `Employee`. The `developer` struct keeps track of the `HourlyRate` that they charge
    and how many hours they work each day. The following steps shall help you to reach
    the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `Employee` type that has the following fields: `Id` as `int`, `FirstName`
    as `string`, and `LastName` as `string`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `developer` type that has the following fields: `Individual Employee`,
    `HourlyRate` `int`, and `WorkWeek` `[7]int`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `enum` for the seven days of the week. This will be of type `Weekday`
    `int` with a constant declaration for each day of the week.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a pointer receiver method called `LogHours` for `Developer` that will
    take the `WeekDay` type and `int` type as input. Assign the hours worked that
    day to the `Developer` workweek slice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method that is a pointer receiver called `HoursWorked()`. This method
    will return the total hours that have been worked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main()` function, initialize and create a variable of the `Developer`
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `LogHours` method, call the method for two days (such as Monday and Tuesday).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the hours for the two days of the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, print the results of the `HoursWorked` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 704.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The aim of this activity is to demonstrate the ability to break problems down
    into manageable tasks to be implemented by functions, such that each of our functions
    has a single responsibility. `LogHours` is responsible for assigning the hours
    worked for each day. `HoursWorked` uses the values that were assigned in `LogHours`
    to display the hours worked each day. We have used return types from our functions
    to display the data. This exercise demonstrates utilizing functions correctly
    to provide a solution to a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Naked Returns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions that have return values must have a `return` statement as the last
    statement in the function. If you omit the return statement, the Go compiler will
    give you the following error: "missing return at the end of function."'
  prefs: []
  type: TYPE_NORMAL
- en: Typically, when a function returns two types, the second type is of type `error`.
    We have not gone over errors yet so in these examples, we are not demonstrating
    them. It is good to know that it is idiomatic in Go for the second return type
    to be of type `error`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go also allows the ability to ignore a variable being returned. For example,
    say we are not interested in the `int` value that is being returned from our `fizzBuzz`
    function. In Go, we can use what is called a blank identifier; it provides a way
    to ignore values in an assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: For example, when reading a file, we might not be concerned about the number
    of bytes read. So, in that case, we can ignore the value being returned by using
    the blank identifier, "`_`". When there is extra data being returned from a function
    that does not provide any information that is needed by our program, such as the
    reading of a file, it is a good candidate for ignoring the return.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As you will discover later, many functions return an error as the second return
    value. You should not ignore return values from functions that are errors. Ignoring
    an error returned by a function could result in unexpected behavior. Error return
    values should be handled appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we are using the blank identifier, `_`, to ignore
    the `int` value being returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You must always have a placeholder for the values being returned when assigning
    values from a function. When performing an assignment, the placeholders must match
    the number of return values from the function. `_` and `s` are the placeholders
    for the return values of `int` and `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go also has a feature that allows you to name your returns. If you use this
    feature, it can make your code more readable as well as self-documenting. If you
    name your return variables, they are under the same constraints as the local variables,
    as discussed in the previous topic. By naming your returns, you are creating local
    variables in the function. You can then assign values to those return variables,
    just as you do with input parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, (`name string`, `age int`) are named returns. They are
    now local variables to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `name` and `age` are local variables that were declared in the return
    list of the function, you can now assign values to them. They can be treated as
    local variables. In the `return` statement, specify the return values. If you
    do not specify the variable name in the return, it is called a **naked return**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Consider the preceding code block. This code is the same as before with the
    exception that the return does not name the variables to return. The `return`
    statement will return the variables that are named in the return list.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the disadvantages of naked returns is that it can cause confusion when
    reading code. To avoid confusion and the possibility of other issues, it is recommended
    that you avoid using the naked returns feature. It can make it difficult to follow
    the variable that is to be returned. There can also be issues with shadowing when
    using naked returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will result in the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: Output for shadowing with naked returns'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.8: Output for shadowing with naked returns'
  prefs: []
  type: TYPE_NORMAL
- en: That is because the `err` variable is named in the `return` and is initialized
    in an `if` statement. Recall that variables that are initialized within curly
    braces, such as `for` loops, `if` statements, and `switch` statements, are scoped
    to that context, meaning that they are only visible and accessible within those
    curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.04: Mapping a CSV Index to a Column Header with Return Values'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Exercise 5.02*, *Mapping Index Values to Column Headers*, we only printed
    the results of the index to the column header. In this exercise, we are going
    to return the map as the result. The map being returned is the index-to-column
    header mapping. The following steps will help you with the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the file from the previous exercise: `$GOPATH\functions\indxToColHdr\main.go`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, in the `main()` function, define the headers for the columns. First,
    we assign a variable to a key-value pair of `int` and `string`. `key(int)` will
    be the index of our `header(string)` column. The index will map to a column header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We range over the `header` to process each string that is in the slice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each string, we remove any trailing spaces in front of and after the string.
    In general, we should always make the assumption that our data may have some erroneous
    characters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our `switch` statement, we lower all the casing for exact matches. As you
    may recall, Go is a case-sensitive language. We need to ensure the casing is the
    same for matching purposes. When our code finds the header, it sets the index
    value for the header in the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open up a terminal and navigate to the code's directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output for return values is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we saw a real-world example of mapping a CSV index to column
    headers. We used a function to solve this complex problem. We were able to have
    the function have a single return value of type `map`. In the next section, we
    are going to see how functions can accept a variable number of argument values
    within a single argument.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A variadic function is a function that accepts a variable number of argument
    values. It is good to use a variadic function when the number of arguments of
    a specified type is unknown.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding function is an example of what a variadic function looks like.
    The three dots (`…`) in front of the type is called a `Type` into `parameterName`.
    The variadic variable can accept zero or more variables as the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `nums` function is a variadic function that accepts a type of `int`. As
    stated before, you can pass zero or more arguments of the type. If there is more
    than one value, you separate them with a comma, as in `nums(99,100)`. If there
    is only one argument to pass, you only pass that argument, as in `nums(200)`.
    If there isn't an argument to pass, you can leave it empty, as in `nums()`.
  prefs: []
  type: TYPE_NORMAL
- en: Variadic functions can have other parameters. However, if your function requires
    multiple parameters, the variadic parameter must be the last parameter in the
    function. Also, there can only be one variadic variable per function. The following
    function is incorrect and will result in an error at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Incorrect function:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 5.9: Variadic syntax error output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.9: Variadic syntax error output'
  prefs: []
  type: TYPE_NORMAL
- en: '**Correct function:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have guessed by now that the actual type of `Type` inside the function
    is a slice. The function takes the arguments being passed in and converts them
    to the new slice being specified. For example, if the variadic type is `int`,
    then once you are inside the function, Go converts that variadic `int` to a slice
    of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: Conversion of a variadic int into a slice of integers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.10: Conversion of a variadic int into a slice of integers'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The variadic function''s output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `nums()` function is showing that the variadic type of `i` is a slice of
    integers. Once in the function, `i` will be a slice of integers. The variadic
    type has length and capacity, which is to be expected for a slice. In the next
    code snippet, we will try to pass a slice of integers to a variadic function,
    `nums()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 5.11: Variadic function error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.11: Variadic function error'
  prefs: []
  type: TYPE_NORMAL
- en: 'Why didn''t this code snippet work? We just proved that the variadic variable
    inside the function is of type `slice`. The reason is that the function is expecting
    a list of arguments of type `int` to be converted to a slice. Variadic functions
    work by converting the arguments passed to a slice of the type being specified.
    However, Go has a mechanism for passing a slice to a variadic function. We need
    to use the unpack operator; it is three dots (`…`). When you call a variadic function
    and you want to pass a slice as an argument to a variadic parameter, you need
    to place the three dots before the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The difference between this version of the function and the previous is the
    calling code to the function, `nums`. The three dots are put after the `i` variable
    is a slice of integers. This allows a slice to be passed to the variadic function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.05: Summing Numbers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to sum up a variable number of arguments. We
    will pass the arguments as a list of arguments and as a slice. The return value
    will be an `int`, the sum of the values we passed to the function. The following
    steps will help you with the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file and save it at `$GOPATH\functions\variadic\main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `sum` function accepts a variadic argument of type `int`. Since it gets
    converted to a slice, we can range over the values and return the sum of all the
    values that get passed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open up a terminal and navigate to the code's directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output for summing numbers is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we saw that by using a variadic parameter, we can accept an
    unknown number of arguments. Our function allows us to sum up any number of integers.
    We can see that variadic parameters can be utilized to solve specific problems
    where the number of values of the same type being passed as an argument is unknown.
    In the next section, we are going to look at how to create a function without
    a name and assign a function to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have been using named functions. As you may recall, named functions
    are functions that have an identifier or a function name. Anonymous functions
    can be declared within another function.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions, also referred to as function literals, are functions that
    do not have a function name, hence the name "anonymous functions." An anonymous
    function is declared in a similar way to how a named function is declared. The
    only difference with the declaration is that the name for the function is omitted.
    Anonymous functions can do basically whatever a normal function in Go does, including
    accepting arguments and returning values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will be introducing the fundamentals of anonymous functions
    and some of their basic uses. Later, you will also see how anonymous functions
    can be fully utilized. Anonymous functions are used for and in conjunction with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Closure implementations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: defer statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a code block to be used with a Goroutine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a function for one-time use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a function to another function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a basic declaration for an anonymous function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that we are declaring a function inside another function. As with named
    functions, you must start with the `func` keyword to declare a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following the `func` keyword would normally be the name of the function, but
    with anonymous functions, there is no function name. Instead, there are empty
    parentheses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The empty parentheses following the `func` keyword is where the function's parameters
    would be defined for the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is the open curly brace, `{`, which starts the function body.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function body is only a one-liner; it will print "`Greeting`".
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The closing curly brace, `}`, denotes the end of the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last set of parentheses are called the execution parentheses. These parentheses
    invoke the anonymous function. The function will execute immediately. Later, we
    will see how to execute an anonymous function at a later location within the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also pass arguments to an anonymous function. To be able to pass arguments
    to an anonymous function, they must be supplied in the execution parentheses:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`func (str string)`: The anonymous function being declared has an input parameter
    of type `string`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`} (message)`: The argument message being passed to the execution parentheses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have currently been executing anonymous functions at the moment they are
    declared, but there are other ways to execute anonymous functions. You can also
    save the anonymous function to a variable. This leads to a different set of opportunities
    that we will look at in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We are assigning the `f` variable to our anonymous function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` is now of type `func()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f` now can be used to invoke the anonymous function, in a fashion similar
    to that for a named function. You must include the `()` after the `f` variable
    to execute the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 5.06: Creating an Anonymous Function to Calculate the Square Root
    of a Number'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Anonymous functions are great for small snippets of code that you want to execute
    within a function. Here, we are going to create an anonymous function that is
    going to have an argument passed to it. It will then calculate the square root.
    The following steps will help you with the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file and save it at `$GOPATH\functions\anonymousfnc\main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`. We are assigning our `x` variable to
    our anonymous function. Our anonymous function takes a parameter, (`i int`). It
    also returns a value of `int`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that the last curly brace does not have the `()` to execute the function.
    We call our anonymous function using `x(j)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open up a terminal and navigate to the code's directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we saw how to assign a variable to a function and later call
    that function by using the variable that was assigned to it. We saw that when
    we need a small function that might not be reusable in our program, we can create
    an anonymous function and assign it to a variable. In the next section, we are
    going to expand the use of anonymous functions into closures.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have introduced anonymous function syntax using some basic examples. Now
    that we have a fundamental understanding of how anonymous functions work, we will
    look at how we can use this powerful concept. Closures are a form of anonymous
    functions. Regular functions cannot reference variables outside of themselves;
    however, an anonymous function can reference variables external to their definition.
    A closure can use variables declared at the same level as the anonymous function''s
    declared. These variables do not need to be passed as parameters. The anonymous
    function has access to these variables when it is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '**Code synopsis:**'
  prefs: []
  type: TYPE_NORMAL
- en: We initialize a variable in the `main()` function called `i` and set it to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We assign `incrementor` to our anonymous function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The anonymous function increments `i` and returns it. Notice that our function
    does not have any input parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then print the results of `incrementor` twice and get `1` and `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that outside our function we increment `i` by `10`. This is a problem.
    We want `i` to be isolated and for it not to change, as this is not the desired
    behavior. When we print the results of `incrementor` again, it will be `12`. We
    want it to be `3`. We will correct this in our next example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One problem with the previous example that we notice is that any code in the
    main function has access to `i`. As we saw in the example, `i` can be accessed
    and changed outside of our function. This is not the desired behavior; we want
    the incrementor to be the only one to change that value. In other words, we want
    `i` to be protected from other functions changing it. The only function that should
    be changing it is our anonymous function when we call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '**Code synopsis:**'
  prefs: []
  type: TYPE_NORMAL
- en: We declared a function called `incrementor()`. This function has a return type
    of `func()` `int`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`i := 0`: We initialize our variable at the level of the `incrementor()` function;
    this is similar to what we did in the previous example, except it was at the `main()`
    function level and anyone at that level had access to `i`. Only the `incrementor()`
    function has access to the `i` variable with this implementation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are returning our anonymous function, `func()` `int`, which increments the
    `i` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main()` function, `increment:=incrementor()` assigns a variable to the
    `func()` `int` that gets returned. It is important to note that `incrementor()`
    only gets executed once here. In our `main()` function, it is no longer being
    referenced or executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Increment()` is of type `func()` `int`. Each call to `increment()` runs the
    anonymous function code. It is referencing the `i` variable, even after `incrementor()`
    has executed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Exercise 5.07: Creating a Closure Function to Decrement a Counter'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to create a closure that decrements from a given
    starting value. We are combining what we have learned about passing an argument
    to an anonymous function and using that knowledge with a closure. The following
    steps will help you with the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file and save it at `$GOPATH\closureFnc\variadic\main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will look at the `decrement` function first. It takes an argument of type
    `int` and has a return value of `func()int`. In previous examples, the variable
    was declared inside the function but before the anonymous function. In this exercise,
    we have it as an input parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We decrement `i` by one inside the anonymous function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, we initialize a variable counter to be used as our
    starting integer to be decremented:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`x:= decrement(counter)` : `x` is assigned to `func()` `int`. Each call to
    `x()` runs the anonymous function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open up a terminal and navigate to the code's directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output for the `decrement` counter is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we saw that closures have access to variables that are external
    to them. This allowed our anonymous function to make changes to the variable that
    a normal function would not be able to make. In the next section, we are going
    to look at how functions can be passed as arguments to another function.
  prefs: []
  type: TYPE_NORMAL
- en: Function Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have seen so far, Go has rich feature support for functions. In Go, functions
    are types too, just like `int`, `string`, and `bool` are types. This means we
    can pass functions as arguments to other functions, functions can be returned
    from a function, and functions can be assigned to variables. We can even define
    our own function types. A function''s type signature defines the types of its
    input parameters and return values. For a function to be of the type of another
    function, it must have the exact signature of the type function that is declared.
    Let''s examine a few function types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet creates a new function type called message. It has
    no input parameters and does not have any return types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine another one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet creates a new function type called calc. It accepts
    two arguments of type int and its return value is of type string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a fundamental understanding of function types, we can write
    some code to demonstrate their uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the code by the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '`type calc` declares `calc` to be of type `func`, determining that it takes
    two integers as arguments and returns a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '`func add(i,j int) string` has the same signature as type `calc`. It takes
    two integers as arguments and returns a string stating "Adding `i + j = result`".
    Functions can be passed to other functions just like any other type in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '`func calculator(f calc, i, j int)` accepts type `calc` as input. The `calc`
    type, as you may remember, is a function type that has input parameters of `int`
    and a return type of `string`. Anything that matches that signature can be passed
    to the function. The `func calculator` function returns the result of the function
    of type `calc`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, we call `calculator`(`add`,`5`,`6`). We are passing
    it the `add` function. `add` satisfies the signature of type `calc func`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5.12* summarizes each of the preceding functions and how they relate
    to each other. The figure shows how `func add` is of type `func calc`, which then
    allows it to be passed as an argument to `func calculator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Function types and uses'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.12: Function types and uses'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have just seen how to create a function type and pass it as an argument
    to a function. It is not that far of a stretch to pass a function as a parameter
    to another function. We will change our previous example slightly to reflect passing
    a function as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We modify the `add` function signature to return an `int` instead of a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We added a second function called `subtract`. Note that its function signature
    is the same as that of the `add` function. The `subtract` function simply returns
    the result of subtracting two numbers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`calculator(f func(int,int)int,i,j int)`: The `calculator` function now has
    an input parameter of type `func` The input parameter, `f`, is a function that
    accepts two integers and returns an `int`. Any function that satisfies the signature
    can be passed to the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `main()` function, `calculator` is called twice: once with the `add`
    function and some integer values being passed and once with the `subtract` function
    being passed as an argument with some integer values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The ability to pass functions as a type is a very powerful feature that can
    pass different functions to other functions as long as their signatures match
    the passed-to function''s input parameter. It is quite simple when you think about
    it. An integer type for a function can be any value as long as it is an integer.
    The same goes for passing functions: a function can be any value as long as it
    is the correct type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function can also be returned from another function. We saw this when using
    anonymous functions combined with closures. Here, we will take a brief look since
    we have already seen this syntax in a previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Returning a function looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '`square(x int) func() int`: The `square` function accepts an `int` as an argument
    and returns a function type that returns an `int`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `square` body, we assign a variable, `f`, to an anonymous function that
    returns the square value of the input parameter, `x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `return` statement for the `square` function returns an anonymous function
    that is of type `func()` int.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v` is assigned to the return of the `square` function. As you may recall,
    the return value is of type `func()` int.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v` has been assigned type `func ()int`; however, it has not been invoked.
    We will invoke it inside the `print` statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fmt.Printf("Type of v: %T",v)`: This statement just prints out the type for
    `v`, which is `func()int`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 5.08: Creating Various Functions to Calculate Salary'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to be creating several functions. We need the ability to calculate
    the salary of a developer and a manager. We want this solution to be extensible
    for the future possibilities of other salaries to be calculated. We will be creating
    functions to calculate the developer and manager salary. Then we will create another
    function that will take the previously mentioned function as input parameter.
    The following steps will help you with the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the IDE of your choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file and save it at `$GOPATH\function\funcAsParam\main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `salary` function accepts a function that accepts two integers as arguments
    and returns an int. So, any function that matches that signature can be passed
    as an argument to the `salary` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the body of the `salary()` function, `pay` is assigned the value that gets
    returned from the `f` function. It passes `x` and `y` parameters as parameters
    to the `f` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that the `managerSalary` and `developerSalary` signatures are identical
    and they match the function `f` for `salary`. This means that both `managerSalary`
    and `developerSalary` can be passed as `func(int,int) int`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`devSalary` and `bossSalary` get assigned to the results of the `salary` function.
    Since `developerSalary` and `managerSalary` satisfy the signature of `func(int,int)
    int`, they each can be passed in as arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open a terminal and navigate to the code's directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `go build` and run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we saw how a function type can be a parameter for another
    function. This allows a function to be an argument to another function. This exercise
    showed how our code can be simplified by having one `salary` function. If, in
    the future, we need to calculate the salary for a tester position, we would only
    need to create a function that matches the function type for `salary` and pass
    it as an argument. The flexibility that this gives is that we do not have to change
    our `salary` function's implementation. In the next section, we are going to see
    how we can change the execution flow of a function, specifically after the function
    returns.
  prefs: []
  type: TYPE_NORMAL
- en: defer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The defer statement defers the execution of a function until the surrounding
    function returns. Let''s try to explain this a bit better. Inside a function,
    you have a `defer` in front of a function that you are calling. That function
    will execute essentially right before the function you are currently inside completes.
    Still confused? Perhaps an example will make this concept a little clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the `defer` example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `main()` function, we have a deferred function, `defer` `done()`.
    Notice that the `done()` function has no new or special syntax. It just has a
    simple print to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have two print statements. The results are interesting. The two `print`
    statements in the `main()` function print first. Even though the deferred function
    was first in `main()`, it printed last. Isn't that interesting? Its ordering in
    the `main()` function did not dictate its order of execution.
  prefs: []
  type: TYPE_NORMAL
- en: The deferred functions are commonly used for performing "clean-up" activities.
    That would include the release of resources, the closing of files, the closing
    database connections, and the removal of configuration\temp files created by a
    program. The `defer` functions are also used to recover from a panic; this is
    discussed in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `defer` statement is not limited to just named functions. In fact,
    you can utilize the defer statement with anonymous functions. Taking our previous
    code snippet, let''s turn it into deferred call with an anonymous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: There is not much that has changed from the previous code. We took the code
    that was in the `done` function and created a deferred anonymous function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `defer` statement is placed before the `func()` keyword. Our function has
    no function name. As you may recall, a function without a name is an anonymous
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results are the same as those from the previous example. The readability,
    to a certain extent, is easier than having the deferred function declared as a
    named function, as in the previous example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also possible and common to have multiple `defer` statements in a function.
    However, they may not execute in the order that you expect. When using `defer`
    statements in front of functions, the execution follows the order of `defer` statement
    placed in front of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The multiple `defer` output looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The first three anonymous functions are having their execution deferred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We declare `f1` and `f2` of type `func()`. These two functions are anonymous
    functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, our `f1()` and `f2()` executed as expected, but the order of
    the multiple `defer` statements executed in the reverse order of how they were
    declared in the code. The first `defer` was the last to execute and the last `defer`
    was the first to execute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Careful consideration must be given when using `defer` statements. A situation
    that you should consider is when you use `defer` statements in conjunction with
    variables. When a variable is passed to a deferred function, the variable''s value
    at that time is what will be used in the deferred function. If that variable is
    changed after the deferred function, it will not be reflected when the deferred
    function runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '`age`:= `25`: We initialize the `age` variable to `25` before the `defer` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name:=` `"John"`: We initialize the `name` variable to `"John"` before the
    `defer` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defer` `personAge`(`name`,`age`): We state that the function is going to be
    deferred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`age*=2`: We double the age after the deferred function. We then print the
    current value of `age` doubled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`personAge`(`name` `string`, `i` `int`): This is the function that is deferred;
    it only prints out the person and age.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results show the value of `age` (`25`) after it has been doubled in the
    `main` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the execution of the program reaches the line that has `defer` `personAge(name,age)`,
    the value of `age` is `25`. Before the `main()` function completes, the deferred
    function runs and the value of `age` is still `25`. Variables used in the deferred
    function are the values before it was deferred, regardless of what happens after
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Activity 5.02: Calculating Payable Amount for Employees Based on Working Hours'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This activity is based on the previous activity. We will keep the same functionality
    but we will be adding three additional features. In this version of the application,
    we would like to give the employee the ability to track their hours throughout
    the day without having logged them yet. This will allow the employees to keep
    better track of their hours before they log them at the end of the day. We are
    also enhancing the application to calculate the employee''s pay. The application
    will calculate their pay for any overtime they worked. The application will also
    print out details of how many hours were worked each day:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function called `nonLoggedHours()` `func(int)` `int`. Each time this
    function is called, it will calculate the hours of the employee that have not
    been logged. You will be using a closure inside the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method called `PayDay()(int,bool)`. This method will calculate the
    weekly pay. It needs to take into consideration overtime pay. The method will
    pay twice the hourly rate for hours greater than 40\. The function will return
    `int` as the weekly pay and `bool` for if the pay is overtime pay. The Boolean
    will be true if the employee worked more than `40` hours and false if they worked
    less than `40` hours.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method called `PayDetails()`. This method will print each day and the
    hours worked that day by the employee. It will print the total hours for the week,
    the pay for the week, and if the pay contains overtime pay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside of the `main` function, initialize a variable of type `Developer`. Assign
    a variable to `nonLoggedHours`. Print the variable assigned to `nonLoggedHours`
    with values of `2`, `3`, and `5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Also, in the `main()` function, log the hours for the following days: Monday
    8, Tuesday 10, Wednesday 10, Thursday 10, Friday 6, and Saturday 8.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then run the `PayDetails()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.13: Output for payable amount activity'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_05_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.13: Output for payable amount activity'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 706.
  prefs: []
  type: TYPE_NORMAL
- en: The aim of this activity is to go a step further than *Activity 5.01,* *Calculating
    the Working Hours of Employees*, by using some more advanced programming with
    Go's functions. In this activity, we will continue to use functions as we did
    previously; however, we will be returning multiple values and returning a function
    from a function. We also demonstrate the use of closures for calculating hours
    not logged by an employee.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have studied why and how functions are an essential part of the Go programming
    language. We also discussed various features of functions in Go that make Go stand
    apart from other programming languages. Go has features that allow us to solve
    a lot of real-world problems. Functions in Go serve many purposes, including enhancing
    the usage and readability of code. We learned how to create and call functions.
    We studied the various types of functions used in Go and discussed scenarios where
    each of the function types can be used. We also expounded the concept of closures.
    Closures are essentially a type of anonymous function that can use variables declared
    at the same level as that at which the anonymous function was declared. We also
    discussed various parameters and return types and studied `defer`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we shall be exploring errors and error types and learning
    how to build custom errors, thus building a recovery mechanism to handle errors
    in Go.
  prefs: []
  type: TYPE_NORMAL
