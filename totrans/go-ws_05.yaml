- en: 5\. Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 函数
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter will describe the various parts of a function in detail, such as
    defining the function, function identifiers, parameter lists, return types, and
    the function body. We will also look at some best practices when designing our
    functions, such as a function performing a single task, how to reduce code, making
    your function small, and ensuring that functions are reusable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细描述函数的各个部分，例如定义函数、函数标识符、参数列表、返回类型和函数体。我们还将探讨设计函数时的最佳实践，例如函数执行单一任务、如何减少代码、使函数小型化以及确保函数可重用。
- en: By the end of this chapter, you will be able to describe a function and the
    different parts that make up a function and evaluate the scope of variables with
    functions. You will learn to create and call a function; utilize variadic and
    anonymous functions and create closures for various constructs. You will also
    learn to use functions as parameters and return values; and use `defer` statements
    with functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够描述函数以及构成函数的不同部分，并评估函数的变量作用域。你将学会创建和调用函数；利用可变参数和匿名函数，并为各种结构创建闭包。你还将学会将函数用作参数和返回值；以及与函数一起使用`defer`语句。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Functions are a core part of many languages and Go is no exception. A function
    is a section of code that has been declared to perform a task. Go functions can
    have zero or more inputs and outputs. One feature that sets Go apart from other
    programming languages is the multiple return values; most programming languages
    are limited to one return value.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是许多语言的核心部分，Go语言也不例外。函数是一段被声明以执行任务的代码。Go函数可以有零个或多个输入和输出。将Go与其他编程语言区分开来的一个特性是它支持多个返回值；大多数编程语言都限制为只有一个返回值。
- en: In the following section, we will see some features of Go functions that differ
    from other languages, such as returning multiple types. We will also see that
    Go has support for first-class functions. This means that Go has the ability to
    assign a variable to a function, pass a function as an argument, and have a function
    as a return type for a function. We will show how functions can be used to break
    up complex parts into smaller parts.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到Go函数的一些与其他语言不同的特性，例如返回多个类型。我们还将看到Go支持一等函数。这意味着Go有将变量分配给函数、将函数作为参数传递以及将函数作为函数的返回类型的能力。我们将展示如何使用函数将复杂部分分解成更小的部分。
- en: 'Functions in Go are considered first-class citizens and higher-order functions.
    First-class citizens are the functions that are assigned to a variable. Higher-order
    functions are functions that can take a function as an argument. The rich features
    of Go functions empower them to be used in various segments in the following ways:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言中的函数被视为一等公民和高级函数。一等公民是将函数分配给变量的函数。高级函数是可以接受函数作为参数的函数。Go函数的丰富特性使它们能够在以下方式中用于各种段：
- en: Functions to be passed as an argument to another function
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数作为参数传递给另一个函数
- en: Return a function as a value from a function
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从函数中返回一个函数值
- en: Functions as a type
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为一种类型
- en: Closures
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: Anonymous functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名函数
- en: Functions assigned to a variable
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数分配给变量
- en: We will be looking at each of these features that are supported in Go.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看Go支持的所有这些功能。
- en: Functions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions are a critical part of Go and we should understand their place. Let''s
    examine some of the reasons for using functions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是Go语言的关键部分，我们应该了解它们的位置。让我们考察一下使用函数的一些原因：
- en: '**Breaking up a complex task**: Functions are used to perform a task, but if
    that task is complicated, it should then be broken down into smaller tasks. Functions
    can be used for small tasks to solve a bigger problem. Smaller tasks are more
    manageable, and using a function to solve specific tasks will make the entire
    code base easier to maintain.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分解复杂任务**：函数用于执行任务，但如果任务很复杂，那么应该将其分解成更小的任务。函数可以用于解决更大的问题的小任务。小任务更容易管理，使用函数解决特定任务会使整个代码库更容易维护。'
- en: '**Reducing code**: A good indication that you should use a function is when
    you see similar code repeating throughout your program. When you have duplicate
    code, it increases the difficulty of maintenance. If you have one change to make,
    you will have multiple instances where your code needs to change.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少代码**：你应该使用函数的一个好迹象是在你的程序中看到相似的代码重复出现。当你有重复的代码时，它增加了维护的难度。如果你需要做一次更改，你将有多处代码需要更改。'
- en: '**Reusability**: Once you have defined your function, you can use it repeatedly.
    It can also be used by other programmers. This sharing of functions will also
    reduce lines of code and save time by allowing you to not have to reinvent the
    wheel. There are a couple of guidelines we should follow when we design functions:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：一旦你定义了你的函数，你可以重复使用它。它也可以被其他程序员使用。这种函数的共享将减少代码行数并节省时间，因为你不需要重新发明轮子。在设计函数时，我们应该遵循以下一些准则：'
- en: '**Single responsibility**: A function should perform one task. For example,
    a single function should not calculate the distance between two points and estimate
    the time to travel between those two points. There should be a function for each
    of those tasks. This allows for better testing of that function and easier maintenance.
    It is difficult to narrow a function to perform a single task, so do not get discouraged
    if you do not get it right the first time. Even seasoned programmers struggle
    with assigning a single responsibility to a function.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单一职责**：一个函数应该执行一个任务。例如，一个函数不应该计算两点之间的距离并估计在这两点之间旅行的所需时间。应该为每个任务有一个函数。这允许更好地测试该函数并更容易维护。将函数缩小到执行单一任务是有难度的，所以如果你第一次没有做对，不要气馁。即使是经验丰富的程序员在为函数分配单一职责时也会遇到困难。'
- en: '**Small in size**: Functions should not span over hundreds of lines of code.
    This is an indication that the code needs some refactoring. When we have large
    functions, it''s more likely that the single responsibility principle will be
    violated. A good rule of thumb is trying to limit the function size to approximately
    25 lines of code; however, that''s not a hard-and-fast rule. The benefit of keeping
    the code concise is that it reduces the complexity of debugging a large function.
    It also makes writing unit tests with better code coverage easier.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**体积小**：函数不应该超过数百行代码。这是代码需要重构的迹象。当我们有大型函数时，更有可能违反单一职责原则。一个好的经验法则是尝试将函数大小限制在大约
    25 行代码；然而，这不是一个硬性规则。保持代码简洁的好处是它减少了调试大型函数的复杂性。它还使得编写具有更好代码覆盖率的单元测试更容易。'
- en: Parts of a function
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数的部分
- en: 'We will now be looking at the different components involved in defining a function.
    The following is the typical layout of a function:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将探讨定义函数所涉及的不同组件。以下是一个函数的典型布局：
- en: '![Figure 5.1: Different parts of a function'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.1：函数的不同部分'
- en: '](img/B14177_05_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图](img/B14177_05_01.jpg)'
- en: 'Figure 5.1: Different parts of a function'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1：函数的不同部分
- en: 'The different parts of a function are described here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的不同部分在此处描述：
- en: '`func` keyword.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func` 关键字。'
- en: '`calculateTax`, `totalSum`, and `fetchId`.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculateTax`、`totalSum` 和 `fetchId`。'
- en: The identifier should be something descriptive that makes the code easy to read
    and makes the purpose of the function easy to understand. The identifier is not
    required. You can have a function with no name; this is known as an anonymous
    function. Anonymous functions will be discussed in detail in a later part of the
    chapter.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标识符应该是描述性的，使得代码易于阅读，并使函数的目的易于理解。标识符不是必需的。你可以有一个没有名称的函数；这被称为匿名函数。匿名函数将在本章的后续部分详细讨论。
- en: Note
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: When the first letter of the function name is in lowercase, then the function
    is not exportable outside of a package. This means they are private and cannot
    be called from outside the package. They can only be called within the package.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当函数名的第一个字母是小写时，那么该函数在包外部不可导出。这意味着它们是私有的，不能从包外部调用。它们只能在包内部调用。
- en: Keep this in mind when you use camelCase naming convention. If you want your
    function to be exportable, the first letter of the function name must be capitalized.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用驼峰命名法时请记住这一点。如果你想使你的函数可导出，函数名的第一个字母必须大写。
- en: '`name string`, `age int`). Parameters are local variables to the function.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name string`, `age int`)。参数是函数的局部变量。'
- en: Parameters are optional for a function. It is possible to not have any parameters
    for a function. A function can have zero or more parameters.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数对于函数是可选的。一个函数可能没有任何参数。一个函数可以有零个或多个参数。
- en: When two or more parameters have the same type, you can use what is called shorthand
    parameter notation. This removes specifying the same type for each parameter.
    For instance, if your parameters are (`firstName string`, `lastName string`),
    they can be shortened to (`firstName`, `lastName string`). This reduces the verbosity
    of the parameter inputs and increases the readability of the function parameter
    list.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当两个或多个参数具有相同的类型时，你可以使用所谓的简写参数表示法。这消除了为每个参数指定相同类型的需要。例如，如果你的参数是(`firstName string`,
    `lastName string`)，它们可以缩短为(`firstName`, `lastName string`)。这减少了参数输入的冗长性，并增加了函数参数列表的可读性。
- en: '**Return types**: Return types are a list of data types, such as Boolean, string,
    map, or another function that can be returned.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回类型**：返回类型是一系列数据类型，如布尔值、字符串、映射或可以返回的另一个函数。'
- en: In the context of declaring a function, we refer to these types as return types.
    However, in the context of calling a function, they are called return values.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在声明函数的上下文中，我们把这些类型称为返回类型。然而，在调用函数的上下文中，它们被称为返回值。
- en: Return types are the output of the function. Often, they are the result of the
    arguments provided to the function. They are optional. Most programming languages
    return a single type; in Go, you can return multiple types.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回类型是函数的输出。通常，它们是提供给函数的参数的结果。它们是可选的。大多数编程语言返回单个类型；在Go语言中，你可以返回多个类型。
- en: '`{}`.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{}`。'
- en: The statements in the function are what determine what the function does. The
    function code is the code that is being used to perform the task that the function
    was created to accomplish.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数中的语句决定了函数做什么。函数代码是执行函数被创建来完成的任务的代码。
- en: If there were return types defined, then a `return` statement is required in
    the function body. The `return` statement causes the function to immediately stop
    and return the value types listed after the `return` statement. The types in the
    return type list and in the `return` statement must match.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果定义了返回类型，那么函数体中需要有一个`return`语句。`return`语句使函数立即停止并返回`return`语句之后列出的值类型。返回类型列表和`return`语句中的类型必须匹配。
- en: In the function body, there can be multiple `return` statements.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在函数体中，可以有多个`return`语句。
- en: '**Function signature**: Though not listed in the preceding code snippet, a
    function signature is a term that references the input parameters combined with
    the return types. Both of those units make up a function signature.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数签名**：尽管在先前的代码片段中没有列出，但函数签名是一个术语，它指的是输入参数与返回类型的组合。这两个单元共同构成了函数签名。'
- en: Often, when you define the function signature when it is being used by others,
    you want to strive to not make changes to it as this can adversely impact your
    code and the code of others.
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，当其他人使用函数时定义函数签名时，你想要努力不对其进行更改，因为这可能会对你的代码和别人的代码产生不利影响。
- en: We will be diving deep into each of the parts of a function as we progress through
    the chapter. These parts of a function will become easier to understand through
    the following discussion, so don't worry if you do not quite understand all the
    parts yet. It will become clearer as we go through the chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们通过本章的进展，我们将深入探讨函数的各个部分。通过以下讨论，这些函数部分将变得更容易理解，所以如果你现在还没有完全理解所有部分，请不要担心。随着我们继续阅读本章，一切将变得清晰。
- en: fizzBuzz
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fizzBuzz
- en: 'Now that we have looked at the different parts of the function, let''s see
    how these parts work with various examples. Let''s start with a classical programming
    game called `fizzBuzz`. The rules of `fizzBuzz` are straightforward. The `fizzBuzz`
    function prints out various messages based on some math results. The rules perform
    one of the actions based on the number given:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经研究了函数的不同部分，让我们看看这些部分如何通过各种示例来工作。让我们从一个经典的编程游戏`fizzBuzz`开始。`fizzBuzz`的规则很简单。`fizzBuzz`函数根据某些数学结果打印出各种消息。规则根据给定的数字执行以下操作之一：
- en: If the number is divisible by `3`, print `Fizz`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字能被`3`整除，则打印`Fizz`。
- en: If the number is divisible by `5`, print `Buzz`.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字能被`5`整除，则打印`Buzz`。
- en: If the number is divisible by `15`, print `FizzBuzz`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字能被`15`整除，则打印`FizzBuzz`。
- en: Else, print the number.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，打印数字。
- en: 'The following is the code snippet to achieve this output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现此输出的代码片段：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s look at the code in sections now:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来分部分查看代码：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`func`, as you may recall, is the keyword to declare a function. This informs
    Go that the following piece of code is going to be a function.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func`，如您所记得，是声明函数的关键字。这通知Go，以下代码块将是一个函数。'
- en: '`fizzBuzz` is the name of our function. It is idiomatic in Go to use a camelCase
    name.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fizzBuzz`是我们函数的名称。在Go语言中，使用驼峰式命名法是惯例。'
- en: '`()`, the parenthesis following the name of our function, is empty: our current
    implementation of the `FizzBuzz` game does not require any input parameters.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`()`，函数名称后面的括号是空的：我们当前实现的`FizzBuzz`游戏不需要任何输入参数。'
- en: The space between the parameter list, `()`, and the opening brace would be the
    return type. Our current implementation does not require a return type.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数列表`()`和开括号之间的空格将是返回类型。我们当前的实施并不需要返回类型。
- en: Regarding `{`, unlike other programming languages that you may know, Go requires
    that the opening curly brace is on the same line as the function declaration.
    If the opening brace is not on the same line as the function signature when you
    attempt to run the program, you will get an error.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`{`，与您可能了解的其他编程语言不同，Go要求开括号与函数声明在同一行上。如果您尝试运行程序时开括号不在函数签名同一行上，您将得到一个错误。
- en: '[PRE2]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding line is a `for` loop that increments the `i` variable from `1`
    to `30`:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前一行是一个`for`循环，它将`i`变量从`1`增加到`30`：
- en: '[PRE3]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`%` is a modulus operator; it gives the remainder of the two integers being
    divided. Using our function, if `i` is `15`, then `15%15` will return zero. We
    use the modulus operator to determine whether `i` is evenly divisible by `3`,
    `5`, or `15`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%`是取模运算符；它给出两个整数相除的余数。使用我们的函数，如果`i`是`15`，那么`15%15`将返回零。我们使用取模运算符来确定`i`是否能被`3`、`5`或`15`整除。'
- en: Note
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: As we become more familiar with Go concepts and language syntax, the explanation
    of the code will exclude items that we would otherwise be going over multiple
    times.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随着我们越来越熟悉Go的概念和语言语法，代码的解释将排除我们本会多次提到的项目。
- en: We have now defined our function. It has a specific task we want it to perform,
    but it doesn't do any good if we do not execute the function. So, how do we execute
    a function? We must call our function. When we call a function, we are telling
    our program to execute the function. We will be calling our function inside the
    `main()` function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经定义了我们的函数。它有一个特定的任务我们希望它执行，但如果我们不执行该函数，那就没有好处。那么，我们如何执行一个函数呢？我们必须调用我们的函数。当我们调用一个函数时，我们是在告诉我们的程序执行该函数。我们将在`main()`函数内部调用我们的函数。
- en: 'Functions can call other functions. When this occurs, control is given to the
    function that was called. After the called function has returned data or reached
    the ending curly brace, `}`, control is given back to the caller. Let''s see an
    example to understand this better:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以调用其他函数。当这种情况发生时，控制权交给了被调用的函数。在被调用的函数返回数据或达到结束括号`}`后，控制权交还给调用者。让我们通过一个例子来更好地理解这一点：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`}fmt.Println("Main is in control")`: This `print` statement is for demonstration
    purposes. It shows that we are in the `main()` function.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`}fmt.Println("Main is in control")`: 这条打印语句用于演示目的。它显示我们处于`main()`函数中。'
- en: '`fizzBuzz()`: We are now calling the function inside the `main()` function.
    Even though there are no parameters for our function the parentheses are still
    required, control of the program is given to the `fizzBuzz()` function. After
    the `fizzBuzz()` function completes, control is then given back to the `main()`
    function.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fizzBuzz()`: 我们现在在`main()`函数内部调用该函数。尽管我们的函数没有参数，但括号仍然是必需的，程序的控制权交给了`fizzBuzz()`函数。在`fizzBuzz()`函数完成后，控制权随后交还给`main()`函数。'
- en: '`fmt.Println("Back to main")`: The `print` statement is for demonstration purposes
    to show that control has been given back to the `main()` function.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmt.Println("Back to main")`: 这条打印语句用于演示目的，以显示控制权已交还给`main()`函数。'
- en: 'The output will be as follows:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 5.2: Output for fizzBuzz'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2：fizzBuzz的输出'
- en: '](img/B14177_05_02.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_05_02.jpg)'
- en: 'Figure 5.2: Output for fizzBuzz'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：fizzBuzz的输出
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The parentheses following the `fizzBuzz` function are still required even though
    there are no input parameters. If they are omitted, the Go compiler will generate
    an error that states `fizzBuzz` evaluated but not used. This is a common error.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有输入参数，`fizzBuzz`函数后面的括号也是必需的。如果省略了它们，Go编译器将生成一个错误，指出`fizzBuzz`已评估但未使用。这是一个常见的错误。
- en: 'The output will be as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![Figure 5.3: Output for fizzBuzz without parentheses'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3：没有括号的fizzBuzz输出'
- en: '](img/B14177_05_03.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.3：没有括号的fizzBuzz输出](img/B14177_05_03.jpg)'
- en: 'Figure 5.3: Output for fizzBuzz without parentheses'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3：没有括号的fizzBuzz输出
- en: 'Exercise 5.01: Creating a Function to Print Salesperson Expectation Ratings
    from the Number of Items Sold'
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.01：创建一个函数以打印销售人员的期望评分
- en: 'In this exercise, we will be creating a function that will not have any parameters
    or return types. The function will iterate over a map and print the name and number
    of items sold in the map. It will also print a statement based on how the salesperson
    performed based on their sales. The following steps will help you with the solution:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个没有参数或返回类型的函数。该函数将遍历一个映射并打印映射中销售的商品名称和数量。它还将根据销售人员的销售情况打印一条声明。以下步骤将帮助您找到解决方案：
- en: Use the IDE of your choice.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的IDE。
- en: Create a new file and save it as `main.go`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，并将其保存为`main.go`。
- en: 'Enter the following code in `main.go`. The first function that `main` will
    call on `printAge()`; it does not have any parameters and has no return values:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中输入以下代码。`main`将首先调用`printAge()`函数；它没有参数，也没有返回值：
- en: '[PRE5]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will now define our function for printing the age and a message about the
    age of the person:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将定义一个打印年龄及其消息的函数：
- en: '[PRE6]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `itemsSold()` function, initialize a map that will have a key-value
    pair of `string`, `int`. The map will hold a `name`(`string`) and the number of
    `items`(`int`) sold. The name is the key for the map. We assign various names
    to number of items sold:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`itemsSold()`函数中，初始化一个将包含`string`到`int`键值对的映射。该映射将包含`名称`（`string`）和销售的商品数量（`int`）。名称是映射的键。我们为销售的商品数量分配了各种名称：
- en: '[PRE7]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We iterate over the `items` map and assign `k` to the `key`(`name`) and `v`
    to the `value`(`items`):'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历`items`映射，将`k`分配给`key`（`名称`）和`v`分配给`value`（`商品`）：
- en: '[PRE8]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We print out the `Name` and the number of sold `items`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打印出`名称`和销售的商品数量：
- en: '[PRE9]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Depending on the value of `v`(`items`), we will determine the statement we
    print:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据值`v`（`商品`），我们将确定打印的声明：
- en: '[PRE10]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Open your terminal and navigate to the code's directory.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的终端并导航到代码目录。
- en: Run `go build` and then run the executable.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go build`然后运行可执行文件。
- en: 'The expected output is as follows:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE11]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this exercise, we saw some of the fundamental parts of a function. We demonstrated
    how to declare a function using the `func` keyword, followed by how to give our
    function an identifier or name such as `itemsSold()`. We then proceed to add code
    to the function body. In the next topics, we will expand on these core parts of
    the function and learn how to pass data into a function using parameters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了函数的一些基本部分。我们展示了如何使用`func`关键字声明函数，然后是如何给我们的函数一个标识符或名称，例如`itemsSold()`。然后我们继续向函数体中添加代码。在下一个主题中，我们将扩展函数的核心部分，并学习如何使用参数将数据传递到函数中。
- en: Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is best to type the code into an IDE. The benefit is that if you type something
    incorrectly, you will see the error message and can perform some debugging to
    solve the problem.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最好在集成开发环境（IDE）中输入代码。好处是如果您输入错误，您将看到错误消息，并可以进行一些调试以解决问题。
- en: Parameters
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数
- en: 'Parameters define what arguments can be passed to our function. Functions can
    have zero or more parameters. Even though Go allows us to define multiple parameters,
    we should take care not to have a huge parameter list; that would make the code
    harder to read. It also may be an indication that the function is doing more than
    one specific task. If that is the case, we should refactor the function. Take,
    for example, the following code snippet:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 参数定义了可以传递给我们的函数的参数。函数可以有零个或多个参数。尽管Go允许我们定义多个参数，但我们应小心不要有一个很长的参数列表；这会使代码更难阅读。这也可能表明函数正在执行多个特定任务。如果是这种情况，我们应该重构函数。以下是一个代码片段的例子：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code is an example of a function whose parameter list is bloated.
    The parameter list should pertain only to the single responsibility of the function.
    We should only define the parameters that are needed to solve the specific problem
    that the function is built for.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个参数列表膨胀的函数示例。参数列表应仅与函数的单个职责相关。我们应仅定义解决函数构建的特定问题的所需参数。
- en: Parameters are the input types that our function will use to perform its task.
    Function parameters are local to the function, meaning they are only available
    to that function. They are not available outside of the context of the function.
    Also, the order of the parameters must match the parameter types in the correct
    sequence.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是我们函数将用于执行其任务的输入类型。函数参数是局部于函数的，这意味着它们只对那个函数可用。它们在函数的上下文之外不可用。此外，参数的顺序必须与参数类型的正确顺序匹配。
- en: '**Correct:**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**正确：**'
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output when the correct parameter matches would be as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正确参数匹配时的输出如下所示：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Incorrect:**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误：**'
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output looks as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Figure 5.4: Output for incorrect parameter matching'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4：不正确的参数匹配输出]'
- en: '](img/B14177_05_04.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4：不正确的参数匹配输出](img/B14177_05_04.jpg)'
- en: 'Figure 5.4: Output for incorrect parameter matching'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：不正确的参数匹配输出
- en: In the incorrect version of the code, we are calling the `greeting()` function
    with the `age` argument of type `integer` when the parameter is of type `string`.
    The sequence of your arguments must match the sequence of the parameter input
    list.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的不正确版本中，我们用 `age` 参数调用 `greeting()` 函数，而该参数的类型为 `integer`，而参数的类型为 `string`。你的参数序列必须与参数输入列表的序列匹配。
- en: 'Additionally, users would want to have more control over the data the code
    iterates over. Going back to the `fizzBuzz` example, the current implementation
    only does `1` to `100`. Users may need to work on different number ranges and
    hence we need a way to decide the ending range of the loop. We can change our
    `fizzBuzz` function to accept an input parameter. This would meet the needs of
    our user:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，用户可能希望对代码迭代的 数据有更多的控制。回到 `fizzBuzz` 例子，当前的实现只做 `1` 到 `100`。用户可能需要处理不同的数字范围，因此我们需要一种方法来决定循环的结束范围。我们可以将
    `fizzBuzz` 函数更改为接受输入参数。这将满足用户的需求：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code snippet can be explained as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段可以这样解释：
- en: For `fizzBuzz(10)` in the `main()` function, we pass `10` as an argument to
    our `fizzBuzz` function.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，对于 `fizzBuzz(10)`，我们将 `10` 作为参数传递给我们的 `fizzBuzz` 函数。
- en: For `fizzBuzz(end int)`, `topEnd` is the name of our parameter and it is of
    type `int`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `fizzBuzz(end int)`，`topEnd` 是我们的参数名，它属于 `int` 类型。
- en: Our function now will only iterate up to the value of our end parameter; in
    this example, it will iterate to `10`.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在的函数将只迭代到我们的结束参数的值；在这个例子中，它将迭代到 `10`。
- en: The Difference between an Argument and a Parameter
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数与参数的区别
- en: This is a good time to discuss the difference between an argument and a parameter.
    When you are defining your function, using our example, `fizzBuzz`(`end int`)
    is called a parameter. When you call a function, such as `fizzBuzz(10)`, 10 is
    called the argument. Also, the argument and parameter names do not need to match.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个讨论参数与参数区别的好时机。当你定义你的函数时，以我们的例子 `fizzBuzz(end int)` 为例，它被称为参数。当你调用一个函数，如 `fizzBuzz(10)`，10
    被称为参数。此外，参数和参数的名称不需要匹配。
- en: 'Functions in Go also can have more than one parameter defined. We need to add
    another parameter to our `fizzBuzz` function to accommodate this enhancement:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的函数也可以定义多个参数。我们需要向我们的 `fizzBuzz` 函数添加另一个参数以适应这个增强：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code snippet can be explained as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段可以这样解释：
- en: Regarding `fizzBuzz(s,e)`, we are now passing two arguments to the `fizzBuzz`
    function. When there are multiple arguments, they must be separated by a comma.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 `fizzBuzz(s,e)`，我们现在向 `fizzBuzz` 函数传递了两个参数。当有多个参数时，它们必须通过逗号分隔。
- en: Regarding `func fizzBuzz`(`start int`, `end int`), when multiple parameters
    are defined in a function, they are separated by commas, following the convention
    of name type, name type, name type, and so on.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 `func fizzBuzz(start int, end int)`，当在函数中定义多个参数时，它们通过逗号分隔，遵循名称类型、名称类型、名称类型等顺序。
- en: 'Our `fizzBuzz` parameters are more verbose than what is necessary. When we
    have multiple input parameters of the same type, you can separate the input name
    by a comma followed by the type. This is referred to as shorthand parameter notation.
    See the following example of using shorthand parameter notation:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `fizzBuzz` 参数比必要的更冗长。当我们有多个相同类型的输入参数时，可以通过逗号后跟类型来分隔输入名称。这被称为简写参数表示法。请看以下使用简写参数表示法的示例：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code snippet can be explained as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段可以这样解释：
- en: There is no change to the caller when using shorthand parameter notation.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简写参数表示法时，调用者没有变化。
- en: Regarding `fizzBuzz`(`start`,`end int`), `start` and `end` are of type `int`.
    Nothing needs to change in the body of the function to accommodate the shorthand
    parameter notation.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 `fizzBuzz`（`start`, `end int`），`start` 和 `end` 是 `int` 类型。为了适应简写参数表示法，函数体中不需要做任何更改。
- en: 'Exercise 5.02: Mapping Index Values to Column Headers'
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.02：将索引值映射到列标题
- en: 'The function that we are going to create will be taking a slice of column headers
    from a CSV file. It will print out a map of an index value of the headers we are
    interested in:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的函数将接受一个从 CSV 文件中获取的列标题切片。它将打印出我们感兴趣的标题的索引值映射：
- en: Open the IDE of your choice.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您选择的 IDE。
- en: Create a new file and save it `main.go`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件并保存为 `main.go`。
- en: 'Enter the following code in `main.go`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中输入以下代码：
- en: '[PRE19]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First, we assign a variable to a key-value pair of `int` and `string`. `key`(`int`)
    will be the index of our `header`(`string`) column. The index will map to a column
    header.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们将一个变量赋值给 `int` 和 `string` 的键值对。`key`（`int`）将是我们的 `header`（`string`）列的索引。索引将映射到列标题。
- en: 'We range over the `header` to process each string that is in the slice:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历`header`以处理切片中的每个字符串：
- en: '[PRE20]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For each string, remove any trailing spaces in front of and after the string.
    In general, we should always make the assumption that our data may have some erroneous
    characters:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个字符串，移除字符串前后任何多余的空格。一般来说，我们应该始终假设我们的数据可能包含一些错误字符：
- en: '[PRE21]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In our `switch` statement, we lower all the casing for exact matches. As you
    may recall, Go is a case-sensitive language. We need to ensure that the casing
    is the same for matching purposes. When our code finds the header, it sets the
    index value for the header in the map:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `switch` 语句中，我们将所有匹配项的字母大小写转换为小写。如您所知，Go 是一种区分大小写的语言。我们需要确保匹配时的大小写相同。当我们的代码找到标题时，它会在映射中设置标题的索引值：
- en: '[PRE22]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Typically, we would not print out the results. We should return the `csvHeadersToColumnIndex`,
    but since we have not gone over how to return a value, we will print it for now:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，我们不会打印出结果。我们应该返回 `csvHeadersToColumnIndex`，但由于我们还没有讲解如何返回值，所以我们现在将其打印出来：
- en: '[PRE23]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Open your terminal and navigate to the code's directory.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的终端并导航到代码目录。
- en: Run `go build` and run the executable.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go build` 并运行可执行文件。
- en: 'The expected output is as follows:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE24]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this exercise, we saw how to accept data into a function, by defining a parameter
    for our function. The callers of our function were able to pass arguments to the
    function. We will continue to discover various abilities that functions in Go
    can provide. We have seen how to get data into our function. In the next section,
    we will see how to get data out of our function.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何通过为我们的函数定义一个参数来接受数据，我们的函数调用者能够向函数传递参数。我们将继续发现 Go 中函数可以提供的各种能力。我们已经看到了如何将数据放入我们的函数中。在下一节中，我们将看到如何从我们的函数中获取数据。
- en: Function Variable Scope
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数变量作用域
- en: When designing functions, we need to consider the variable scope. The scope
    of a variable determines where the variable is accessible or visible to the different
    parts of the application. Variables declared inside the function are considered
    local variables. This means that they are only accessible to the code within the
    body of the function. You cannot access variables from outside of the function.
    The calling function does not have access to variables inside the called function.
    The input parameter's scope is the same as the local variable's scope to the function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计函数时，我们需要考虑变量作用域。变量的作用域决定了变量在应用程序的不同部分中可访问或可见的位置。在函数内部声明的变量被认为是局部变量。这意味着它们只能被函数体内的代码访问。您无法访问函数外部的变量。调用函数无法访问被调用函数内部的变量。输入参数的作用域与函数的局部变量作用域相同。
- en: 'Variables declared in the calling function are scoped to that function. This
    means that the variables are local to the function and those variables are not
    accessible outside of the function. Our function cannot reach into the calling
    function''s variables. To get access to those variables, they must be passed into
    our function as input parameters:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数中声明的变量作用域限定在该函数内。这意味着这些变量是函数的局部变量，且这些变量在函数外部不可访问。我们的函数无法访问调用函数的变量。要访问这些变量，它们必须作为输入参数传递给我们的函数：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Figure 5.5: Error output for the m variable being undefined'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5：m 变量未定义的错误输出]'
- en: '](img/B14177_05_05.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5：m 变量未定义的错误输出](img/B14177_05_05.jpg)'
- en: 'Figure 5.5: Error output for the m variable being undefined'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5：m 变量未定义的错误输出]'
- en: 'The previous code snippet will result in an error in `func greeting()` that
    states that `m` is undefined. That is because the `m` variable is declared inside
    `main()`. The `greeting()` function does not have access to the `m` variable.
    For it to have access to, the `m` variable must be passed to the `greeting()`
    function as an input parameter:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段将在`func greeting()`中导致错误，指出`m`未定义。这是因为`m`变量是在`main()`内部声明的。`greeting()`函数无法访问`m`变量。为了使其能够访问，必须将`m`变量作为输入参数传递给`greeting()`函数：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![Figure 5.6: Error output for the s variable being undefined'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6：s变量未定义时的错误输出'
- en: '](img/B14177_05_06.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_05_06.jpg)'
- en: 'Figure 5.6: Error output for the s variable being undefined'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：s变量未定义时的错误输出
- en: The previous code snippet will result in an error in `func main()`. The error
    will state that `s` is undefined. This is because the `s` variable is declared
    in the `greeting()` function. The `main()` function does not have access to the
    `s` variable. The `s` variable is only visible to code inside the function body
    of `greeting()`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段将在`func main()`中导致错误。错误将指出`s`未定义。这是因为`s`变量是在`greeting()`函数中声明的。`main()`函数无法访问`s`变量。`s`变量仅在`greeting()`函数体内部的代码中可见。
- en: These are just some considerations that we need to keep in mind when we are
    declaring and accessing variables. It is important to understand the scope of
    the variables inside a function in relation to the variables declared outside
    of a function. It can cause some confusion when you are trying to access variables
    but you are not scoped to the context that you are trying to access. The examples
    in this chapter should help you in understanding the scope of variables.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是我们在声明和访问变量时需要考虑的一些因素。了解函数内部变量与函数外部声明的变量的作用域关系非常重要。当您尝试访问变量但未处于您尝试访问的上下文的作用域时，可能会造成一些混淆。本章中的示例应有助于您理解变量的作用域。
- en: Return Values
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回值
- en: So far, the functions that we have created do not have any return values. Functions
    typically accept inputs, perform some action on those inputs, and then return
    the results of those inputs. Most programming languages return only one value.
    Go allows you to return multiple values from a function. This is one of the features
    of Go functions that distinguishes it from other programming languages.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的函数没有任何返回值。函数通常接受输入，对这些输入执行一些操作，然后返回这些输入的结果。大多数编程语言只返回一个值。Go允许您从函数中返回多个值。这是Go函数的一个特性，使其与其他编程语言区分开来。
- en: 'Exercise 5.03: Creating a fizzBuzz Function with Return Values'
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.03：创建具有返回值的fizzBuzz函数
- en: We are going to make some enhancements to our `fizzBuzz` function. We are going
    to change it so that it accepts only an integer. We will leave the onus on the
    caller to perform the looping if they desire to do so. Also, we are going to have
    two returns. The first will be the number provided and the corresponding text
    of empty string, `fizz`, `buzz`, or `fizzbuzz`. The following steps will help
    you with the solution.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对我们的`fizzBuzz`函数进行一些增强。我们将将其修改为只接受一个整数。如果调用者希望这样做，我们将把执行循环的责任留给调用者。此外，我们将有两个返回值。第一个将是提供的数字和相应的文本，空字符串、`fizz`、`buzz`或`fizzbuzz`。以下步骤将帮助您找到解决方案。
- en: Open the IDE of your choice.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您选择的IDE。
- en: Create a new file and save it at `$GOPATH\functions\fizzBuzzreturn\main.go`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，并将其保存到`$GOPATH\functions\fizzBuzzreturn\main.go`。
- en: 'In the `main()` function, assign variables to the return values of our function.
    The `n,` `s` variables correspond respectively to the values being returned from
    our function, `int`, `string`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在`main()`函数中，将变量分配给我们的函数的返回值。`n,` `s`变量分别对应从我们的函数返回的值，`int`, `string`:'
- en: '[PRE27]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `fizzBuzz` function now returns two values; the first being an `int`, followed
    by a string.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fizzBuzz`函数现在返回两个值；第一个是`int`，后面跟着一个字符串。'
- en: '[PRE28]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Simplify the `if{}else{}` statements by replacing them with a `switch` statement.
    As you are writing code, you should look for ways to simplify things and make
    the code more readable. `case i%15 ==0` is equivalent to our previous `if i%15
    == 0` statements. Instead of our previous `fmt`. `Println()` statements, replace
    them with `return`. The `return` statement will immediately stop the execution
    of the function and return the results to the caller:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 `if{}else{}` 语句替换为 `switch` 语句来简化 `if{}else{}` 语句。在编写代码时，您应该寻找简化事物和使代码更易读的方法。`case
    i%15 ==0` 等同于我们之前的 `if i%15 == 0` 语句。用我们之前的 `fmt`。`Println()` 语句替换它们，用 `return`
    语句替换。`return` 语句将立即停止函数的执行并将结果返回给调用者：
- en: '[PRE29]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The expected output is as follows:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 5.7: Output for the fizzBuzz function with return values'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7：fizzBuzz 函数的返回值输出'
- en: '](img/B14177_05_07.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_05_07.jpg)'
- en: 'Figure 5.7: Output for the fizzBuzz function with return values'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7：fizzBuzz 函数的返回值输出
- en: In this exercise, we saw how we can return multiple values from a function.
    We were able to assign variables to the multiple return values from the function.
    We also noticed that the assigned variables to the function match the order of
    the return values. In the following section, we will learn that in the body of
    the function, we can perform naked returns, where we do not need to specify the
    variable being returned in our return statement.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何从函数中返回多个值。我们能够将变量分配给函数的多个返回值。我们还注意到分配给函数的变量与返回值的顺序相匹配。在下一节中，我们将学习在函数体中，我们可以执行裸返回，其中我们不需要在我们的返回语句中指定要返回的变量。
- en: 'Activity 5.01: Calculating the Working Hours of Employees'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动五.01：计算员工的工时
- en: 'In this activity, we shall be creating a function that will calculate the working
    hours of employees for a week, which shall be used to calculate the payable salary
    amount. The `developer` struct has a field called `Individual` that is of type
    `Employee`. The `developer` struct keeps track of the `HourlyRate` that they charge
    and how many hours they work each day. The following steps shall help you to reach
    the solution:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将创建一个函数来计算员工一周的工作时间，这将用于计算应支付的工资金额。`developer` 结构体有一个名为 `Individual`
    的字段，其类型为 `Employee`。`developer` 结构体跟踪他们收取的小时费率和每天工作的小时数。以下步骤将帮助您找到解决方案：
- en: 'Create an `Employee` type that has the following fields: `Id` as `int`, `FirstName`
    as `string`, and `LastName` as `string`.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Employee` 类型，包含以下字段：`Id` 为 `int`，`FirstName` 为 `string`，和 `LastName` 为
    `string`。
- en: 'Create a `developer` type that has the following fields: `Individual Employee`,
    `HourlyRate` `int`, and `WorkWeek` `[7]int`.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `developer` 类型，包含以下字段：`Individual Employee`，`HourlyRate` `int`，和 `WorkWeek`
    `[7]int`。
- en: Create an `enum` for the seven days of the week. This will be of type `Weekday`
    `int` with a constant declaration for each day of the week.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为一周的七天创建一个 `enum`。这将是一个 `Weekday` `int` 类型的枚举，并为每周的每一天声明一个常量。
- en: Create a pointer receiver method called `LogHours` for `Developer` that will
    take the `WeekDay` type and `int` type as input. Assign the hours worked that
    day to the `Developer` workweek slice.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Developer` 创建一个名为 `LogHours` 的指针接收器方法，该方法将 `WeekDay` 类型和 `int` 类型作为输入。将当天工作的小时数分配给
    `Developer` 工作周切片。
- en: Create a method that is a pointer receiver called `HoursWorked()`. This method
    will return the total hours that have been worked.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `HoursWorked()` 的方法，这是一个指针接收器。该方法将返回已工作的总小时数。
- en: In the `main()` function, initialize and create a variable of the `Developer`
    type.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，初始化并创建一个 `Developer` 类型的变量。
- en: In the `LogHours` method, call the method for two days (such as Monday and Tuesday).
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LogHours` 方法中，调用两天的方法（例如周一和周二）。
- en: Print the hours for the two days of the previous step.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印上一步中两天的工作时间。
- en: Next, print the results of the `HoursWorked` method.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打印 `HoursWorked` 方法的输出结果。
- en: 'The following is the expected output:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为预期输出：
- en: '[PRE30]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 704.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 704 页找到。
- en: The aim of this activity is to demonstrate the ability to break problems down
    into manageable tasks to be implemented by functions, such that each of our functions
    has a single responsibility. `LogHours` is responsible for assigning the hours
    worked for each day. `HoursWorked` uses the values that were assigned in `LogHours`
    to display the hours worked each day. We have used return types from our functions
    to display the data. This exercise demonstrates utilizing functions correctly
    to provide a solution to a problem.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的目的是展示将问题分解为可管理的任务以供函数实现的能力，以便我们的每个函数都有一个单一的责任。`LogHours`负责分配每天的工作时间。`HoursWorked`使用在`LogHours`中分配的值来显示每天的工作时间。我们使用了函数的返回类型来显示数据。这个练习展示了正确使用函数来解决问题。
- en: Naked Returns
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 裸返回
- en: Note
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Functions that have return values must have a `return` statement as the last
    statement in the function. If you omit the return statement, the Go compiler will
    give you the following error: "missing return at the end of function."'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值的函数必须将`return`语句作为函数中的最后一个语句。如果你省略了`return`语句，Go 编译器会给你以下错误：“函数末尾缺少返回。”
- en: Typically, when a function returns two types, the second type is of type `error`.
    We have not gone over errors yet so in these examples, we are not demonstrating
    them. It is good to know that it is idiomatic in Go for the second return type
    to be of type `error`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当一个函数返回两种类型时，第二种类型是`error`类型。我们还没有讨论错误，所以在这些例子中，我们没有演示它们。了解在 Go 中，第二个返回类型通常是`error`类型是很好的。
- en: 'Go also allows the ability to ignore a variable being returned. For example,
    say we are not interested in the `int` value that is being returned from our `fizzBuzz`
    function. In Go, we can use what is called a blank identifier; it provides a way
    to ignore values in an assignment:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Go 还允许忽略返回的变量。例如，假设我们对从我们的`fizzBuzz`函数返回的`int`值不感兴趣。在 Go 中，我们可以使用所谓的空标识符；它提供了一种在赋值中忽略值的方法：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: For example, when reading a file, we might not be concerned about the number
    of bytes read. So, in that case, we can ignore the value being returned by using
    the blank identifier, "`_`". When there is extra data being returned from a function
    that does not provide any information that is needed by our program, such as the
    reading of a file, it is a good candidate for ignoring the return.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当读取文件时，我们可能不关心读取的字节数。在这种情况下，我们可以使用空标识符`_`来忽略返回的值。当函数返回了不需要我们程序中的额外数据时，比如读取文件，它是一个很好的忽略返回值的候选。
- en: Note
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As you will discover later, many functions return an error as the second return
    value. You should not ignore return values from functions that are errors. Ignoring
    an error returned by a function could result in unexpected behavior. Error return
    values should be handled appropriately.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现，许多函数将错误作为第二个返回值返回。你不应该忽略函数返回的错误。忽略函数返回的错误可能会导致意外的行为。错误返回值应该得到适当的处理。
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding example, we are using the blank identifier, `_`, to ignore
    the `int` value being returned:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用空标识符`_`来忽略返回的`int`值：
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You must always have a placeholder for the values being returned when assigning
    values from a function. When performing an assignment, the placeholders must match
    the number of return values from the function. `_` and `s` are the placeholders
    for the return values of `int` and `string`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当从函数中赋值时，你必须为返回的值提供一个占位符。在进行赋值时，占位符必须与函数的返回值数量相匹配。`_`和`s`是`int`和`string`返回值的占位符。
- en: 'Go also has a feature that allows you to name your returns. If you use this
    feature, it can make your code more readable as well as self-documenting. If you
    name your return variables, they are under the same constraints as the local variables,
    as discussed in the previous topic. By naming your returns, you are creating local
    variables in the function. You can then assign values to those return variables,
    just as you do with input parameters:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Go 还有一个功能允许你为返回值命名。如果你使用这个功能，它可以使得你的代码更易于阅读以及自文档化。如果你为返回变量命名，它们将受到与之前主题中讨论的局部变量相同的约束。通过命名返回值，你正在在函数中创建局部变量。然后你可以将这些返回变量的值赋值，就像你处理输入参数一样：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code, (`name string`, `age int`) are named returns. They are
    now local variables to the function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，（`name string`，`age int`）是命名的返回值。现在它们是函数的局部变量。
- en: 'Since `name` and `age` are local variables that were declared in the return
    list of the function, you can now assign values to them. They can be treated as
    local variables. In the `return` statement, specify the return values. If you
    do not specify the variable name in the return, it is called a **naked return**:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `name` 和 `age` 是在函数的返回列表中声明的局部变量，现在您可以给它们赋值。它们可以被视为局部变量。在 `return` 语句中指定返回值。如果您没有在返回中指定变量名，它被称为
    **裸返回**：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Consider the preceding code block. This code is the same as before with the
    exception that the return does not name the variables to return. The `return`
    statement will return the variables that are named in the return list.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑前面的代码块。这段代码与之前相同，只是返回没有命名要返回的变量。`return` 语句将返回返回列表中命名的变量。
- en: 'One of the disadvantages of naked returns is that it can cause confusion when
    reading code. To avoid confusion and the possibility of other issues, it is recommended
    that you avoid using the naked returns feature. It can make it difficult to follow
    the variable that is to be returned. There can also be issues with shadowing when
    using naked returns:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 裸返回的一个缺点是它可能在阅读代码时引起混淆。为了避免混淆和其他可能的问题，建议您避免使用裸返回功能。这可能会使跟踪要返回的变量变得困难。使用裸返回时也可能出现阴影问题：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding code will result in the following error:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将导致以下错误：
- en: '![Figure 5.8: Output for shadowing with naked returns'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8：使用裸返回值的阴影输出'
- en: '](img/B14177_05_08.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.8：使用裸返回值的阴影输出](img/B14177_05_08.jpg)'
- en: 'Figure 5.8: Output for shadowing with naked returns'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8：使用裸返回值的阴影输出
- en: That is because the `err` variable is named in the `return` and is initialized
    in an `if` statement. Recall that variables that are initialized within curly
    braces, such as `for` loops, `if` statements, and `switch` statements, are scoped
    to that context, meaning that they are only visible and accessible within those
    curly braces.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `err` 变量在 `return` 中命名并在 `if` 语句中初始化。回想一下，在花括号内初始化的变量，例如 `for` 循环、`if`
    语句和 `switch` 语句，其作用域仅限于该上下文，意味着它们只能在那些花括号内可见和访问。
- en: 'Exercise 5.04: Mapping a CSV Index to a Column Header with Return Values'
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.04：使用返回值将 CSV 索引映射到列标题
- en: 'In *Exercise 5.02*, *Mapping Index Values to Column Headers*, we only printed
    the results of the index to the column header. In this exercise, we are going
    to return the map as the result. The map being returned is the index-to-column
    header mapping. The following steps will help you with the solution:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *练习 5.02*，*将索引值映射到列标题* 中，我们只打印了索引到列标题的结果。在这个练习中，我们将返回映射作为结果。返回的映射是索引到列标题的映射。以下步骤将帮助您找到解决方案：
- en: Open the IDE of your choice.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您选择的 IDE。
- en: 'Open the file from the previous exercise: `$GOPATH\functions\indxToColHdr\main.go`.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开上一个练习中的文件：`$GOPATH\functions\indxToColHdr\main.go`。
- en: 'Enter the following code in `main.go`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中输入以下代码：
- en: '[PRE37]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, in the `main()` function, define the headers for the columns. First,
    we assign a variable to a key-value pair of `int` and `string`. `key(int)` will
    be the index of our `header(string)` column. The index will map to a column header:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在 `main()` 函数中，定义列的标题。首先，我们将一个变量赋值给 `int` 和 `string` 的键值对。`key(int)` 将是
    `header(string)` 列的索引。索引将映射到列标题：
- en: '[PRE38]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We range over the `header` to process each string that is in the slice:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历 `header` 来处理切片中的每个字符串：
- en: '[PRE39]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For each string, we remove any trailing spaces in front of and after the string.
    In general, we should always make the assumption that our data may have some erroneous
    characters:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个字符串，我们移除字符串前后任何多余的空格。一般来说，我们应该始终假设我们的数据可能包含一些错误字符：
- en: '[PRE40]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In our `switch` statement, we lower all the casing for exact matches. As you
    may recall, Go is a case-sensitive language. We need to ensure the casing is the
    same for matching purposes. When our code finds the header, it sets the index
    value for the header in the map:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 `switch` 语句中，我们将所有匹配项的字母大小写转换为小写。如您所回忆的，Go 是一种区分大小写的语言。我们需要确保匹配时的大小写相同。当我们的代码找到标题时，它将索引值设置为映射中的标题：
- en: '[PRE41]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Open up a terminal and navigate to the code's directory.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并导航到代码目录。
- en: Run `go build` and run the executable.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go build` 并运行可执行文件。
- en: 'The expected output for return values is as follows:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的返回值输出如下：
- en: '[PRE42]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this exercise, we saw a real-world example of mapping a CSV index to column
    headers. We used a function to solve this complex problem. We were able to have
    the function have a single return value of type `map`. In the next section, we
    are going to see how functions can accept a variable number of argument values
    within a single argument.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了一个将 CSV 索引映射到列标题的实际例子。我们使用一个函数来解决这个复杂问题。我们能够使函数返回一个类型为 `map` 的单一值。在下一节中，我们将看到函数如何接受单个参数中的可变数量的参数值。
- en: Variadic Function
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可变参数函数
- en: A variadic function is a function that accepts a variable number of argument
    values. It is good to use a variadic function when the number of arguments of
    a specified type is unknown.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数函数是一个接受可变数量参数值的函数。当指定类型的参数数量未知时，使用可变参数函数是很好的。
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding function is an example of what a variadic function looks like.
    The three dots (`…`) in front of the type is called a `Type` into `parameterName`.
    The variadic variable can accept zero or more variables as the argument:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数是一个可变参数函数的例子。在类型前面的三个点（`…`）被称为 `Type` 到 `parameterName`。可变变量可以接受零个或多个变量作为参数：
- en: '[PRE44]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `nums` function is a variadic function that accepts a type of `int`. As
    stated before, you can pass zero or more arguments of the type. If there is more
    than one value, you separate them with a comma, as in `nums(99,100)`. If there
    is only one argument to pass, you only pass that argument, as in `nums(200)`.
    If there isn't an argument to pass, you can leave it empty, as in `nums()`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`nums` 函数是一个接受类型为 `int` 的可变参数函数。如前所述，你可以传递零个或多个该类型的参数。如果有多个值，你用逗号分隔它们，如 `nums(99,100)`。如果只有一个参数要传递，你只需传递该参数，如
    `nums(200)`。如果没有参数要传递，你可以留空，如 `nums()`。'
- en: Variadic functions can have other parameters. However, if your function requires
    multiple parameters, the variadic parameter must be the last parameter in the
    function. Also, there can only be one variadic variable per function. The following
    function is incorrect and will result in an error at compile time.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数函数可以有其他参数。然而，如果你的函数需要多个参数，可变参数必须是函数中的最后一个参数。此外，每个函数只能有一个可变变量。以下函数是错误的，将在编译时产生错误。
- en: '**Incorrect function:**'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误函数：**'
- en: '[PRE45]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![Figure 5.9: Variadic syntax error output'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.9：可变参数语法错误输出'
- en: '](img/B14177_05_09.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_05_09.jpg](img/B14177_05_09.jpg)'
- en: 'Figure 5.9: Variadic syntax error output'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9：可变参数语法错误输出
- en: '**Correct function:**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**正确函数：**'
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output would look as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You may have guessed by now that the actual type of `Type` inside the function
    is a slice. The function takes the arguments being passed in and converts them
    to the new slice being specified. For example, if the variadic type is `int`,
    then once you are inside the function, Go converts that variadic `int` to a slice
    of integers:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经猜到了函数内部`Type`的实际类型是一个切片。该函数接收传入的参数并将它们转换为指定的新的切片。例如，如果可变参数类型是`int`，那么一旦你进入函数，Go会将该可变参数`int`转换为整数切片：
- en: '![Figure 5.10: Conversion of a variadic int into a slice of integers'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.10：将可变参数 int 转换为整数切片'
- en: '](img/B14177_05_10.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_05_10.jpg](img/B14177_05_10.jpg)'
- en: 'Figure 5.10: Conversion of a variadic int into a slice of integers'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10：将可变参数 int 转换为整数切片
- en: '[PRE48]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The variadic function''s output is as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 可变参数函数的输出如下：
- en: '[PRE49]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `nums()` function is showing that the variadic type of `i` is a slice of
    integers. Once in the function, `i` will be a slice of integers. The variadic
    type has length and capacity, which is to be expected for a slice. In the next
    code snippet, we will try to pass a slice of integers to a variadic function,
    `nums()`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`nums()` 函数表明 `i` 的可变类型是整数切片。一旦进入函数，`i` 将是一个整数切片。可变类型具有长度和容量，这对于切片来说是预期的。在下一个代码片段中，我们将尝试将整数切片传递给可变参数函数
    `nums()`：'
- en: '[PRE50]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![Figure 5.11: Variadic function error'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.11：可变参数函数错误'
- en: '](img/B14177_05_11.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_05_11.jpg](img/B14177_05_11.jpg)'
- en: 'Figure 5.11: Variadic function error'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11：可变参数函数错误
- en: 'Why didn''t this code snippet work? We just proved that the variadic variable
    inside the function is of type `slice`. The reason is that the function is expecting
    a list of arguments of type `int` to be converted to a slice. Variadic functions
    work by converting the arguments passed to a slice of the type being specified.
    However, Go has a mechanism for passing a slice to a variadic function. We need
    to use the unpack operator; it is three dots (`…`). When you call a variadic function
    and you want to pass a slice as an argument to a variadic parameter, you need
    to place the three dots before the variable:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个代码片段不起作用？我们刚刚证明了函数内的可变变量是`slice`类型。原因是函数期望一个类型为`int`的参数列表被转换为切片。可变函数通过将传递给函数的参数转换为指定类型的切片来工作。然而，Go有一个机制可以将切片传递给可变参数函数。我们需要使用解包运算符；它是三个点（`…`）。当你调用一个可变参数函数，并且你想将一个切片作为参数传递给可变参数时，你需要在变量之前放置三个点：
- en: '[PRE51]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The difference between this version of the function and the previous is the
    calling code to the function, `nums`. The three dots are put after the `i` variable
    is a slice of integers. This allows a slice to be passed to the variadic function.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数版本与之前的版本的区别在于对函数`nums`的调用代码。三个点放在`i`变量之后表示一个整数切片。这允许将切片传递给可变参数函数。
- en: 'Exercise 5.05: Summing Numbers'
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.05：求和数字
- en: 'In this exercise, we are going to sum up a variable number of arguments. We
    will pass the arguments as a list of arguments and as a slice. The return value
    will be an `int`, the sum of the values we passed to the function. The following
    steps will help you with the solution:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将总结一个可变数量的参数。我们将以参数列表和切片的形式传递参数。返回值将是一个`int`类型，即我们传递给函数的值的总和。以下步骤将帮助您找到解决方案：
- en: Open the IDE of your choice.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您选择的IDE。
- en: Create a new file and save it at `$GOPATH\functions\variadic\main.go`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件并将其保存到`$GOPATH\functions\variadic\main.go`。
- en: 'Enter the following code in `main.go`:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中输入以下代码：
- en: '[PRE52]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `sum` function accepts a variadic argument of type `int`. Since it gets
    converted to a slice, we can range over the values and return the sum of all the
    values that get passed:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sum`函数接受一个可变参数，参数类型为`int`。由于它被转换为切片，我们可以遍历这些值并返回所有传递值的总和：'
- en: '[PRE53]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Open up a terminal and navigate to the code's directory.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并导航到代码目录。
- en: Run `go build` and run the executable.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go build`并运行可执行文件。
- en: 'The expected output for summing numbers is as follows:'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 求和数字的预期输出如下：
- en: '[PRE54]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this exercise, we saw that by using a variadic parameter, we can accept an
    unknown number of arguments. Our function allows us to sum up any number of integers.
    We can see that variadic parameters can be utilized to solve specific problems
    where the number of values of the same type being passed as an argument is unknown.
    In the next section, we are going to look at how to create a function without
    a name and assign a function to a variable.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了通过使用可变参数，我们可以接受未知数量的参数。我们的函数允许我们求和任意数量的整数。我们可以看到，可变参数可以用于解决特定问题，其中作为参数传递的相同类型的值的数量是未知的。在下一节中，我们将探讨如何创建一个没有名称的函数并将函数赋给一个变量。
- en: Anonymous Functions
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: So far, we have been using named functions. As you may recall, named functions
    are functions that have an identifier or a function name. Anonymous functions
    can be declared within another function.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用命名函数。如您所回忆的那样，命名函数是有标识符或函数名的函数。匿名函数可以在另一个函数内声明。
- en: Anonymous functions, also referred to as function literals, are functions that
    do not have a function name, hence the name "anonymous functions." An anonymous
    function is declared in a similar way to how a named function is declared. The
    only difference with the declaration is that the name for the function is omitted.
    Anonymous functions can do basically whatever a normal function in Go does, including
    accepting arguments and returning values.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数，也称为函数字面量，是没有函数名的函数，因此得名“匿名函数”。匿名函数的声明方式与命名函数的声明方式类似。唯一的不同之处在于声明中省略了函数名。匿名函数基本上可以执行Go中正常函数所能做的任何事情，包括接受参数和返回值。
- en: 'In this section, we will be introducing the fundamentals of anonymous functions
    and some of their basic uses. Later, you will also see how anonymous functions
    can be fully utilized. Anonymous functions are used for and in conjunction with
    the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍匿名函数的基本原理及其一些基本用法。稍后，您还将看到如何充分利用匿名函数。匿名函数用于以下方面：
- en: Closure implementations
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包实现
- en: defer statements
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer`语句'
- en: Defining a code block to be used with a Goroutine
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义用于与Goroutine一起使用的代码块
- en: Defining a function for one-time use
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一次使用的函数
- en: Passing a function to another function
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数传递给另一个函数
- en: 'The following is a basic declaration for an anonymous function:'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个匿名函数的基本声明：
- en: '[PRE55]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Notice that we are declaring a function inside another function. As with named
    functions, you must start with the `func` keyword to declare a function.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，我们是在另一个函数内部声明函数。与命名函数一样，您必须以`func`关键字开始声明函数。
- en: Following the `func` keyword would normally be the name of the function, but
    with anonymous functions, there is no function name. Instead, there are empty
    parentheses.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`func`关键字之后通常是函数的名称，但匿名函数没有函数名。相反，是空括号。
- en: The empty parentheses following the `func` keyword is where the function's parameters
    would be defined for the function.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func`关键字后面的空括号是定义函数参数的地方。'
- en: Next is the open curly brace, `{`, which starts the function body.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是开括号，`{`，它标志着函数体的开始。
- en: The function body is only a one-liner; it will print "`Greeting`".
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数体仅有一行；它将打印"`Greeting`"。
- en: The closing curly brace, `}`, denotes the end of the function.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭括号，`}`，表示函数的结束。
- en: The last set of parentheses are called the execution parentheses. These parentheses
    invoke the anonymous function. The function will execute immediately. Later, we
    will see how to execute an anonymous function at a later location within the function.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的一组括号称为执行括号。这些括号调用匿名函数。函数将立即执行。稍后，我们将看到如何在函数的另一个位置执行匿名函数。
- en: 'You can also pass arguments to an anonymous function. To be able to pass arguments
    to an anonymous function, they must be supplied in the execution parentheses:'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以向匿名函数传递参数。要能够向匿名函数传递参数，它们必须在执行括号中提供：
- en: '[PRE56]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`func (str string)`: The anonymous function being declared has an input parameter
    of type `string`.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func (str string)`: 正在声明的匿名函数有一个类型为`string`的输入参数。'
- en: '`} (message)`: The argument message being passed to the execution parentheses.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`} (message)`: 被传递到执行括号中的参数`message`。'
- en: 'We have currently been executing anonymous functions at the moment they are
    declared, but there are other ways to execute anonymous functions. You can also
    save the anonymous function to a variable. This leads to a different set of opportunities
    that we will look at in this chapter:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前是在声明匿名函数时立即执行它们，但还有其他执行匿名函数的方法。您还可以将匿名函数保存到变量中。这导致了一系列不同的机会，我们将在本章中探讨：
- en: '[PRE57]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We are assigning the `f` variable to our anonymous function.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`f`变量赋值给我们的匿名函数。
- en: '`f` is now of type `func()`.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f`现在为`func()`类型。'
- en: '`f` now can be used to invoke the anonymous function, in a fashion similar
    to that for a named function. You must include the `()` after the `f` variable
    to execute the function.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f`现在可以用来调用匿名函数，方式与命名函数类似。您必须在`f`变量之后包含`()`来执行函数。'
- en: 'Exercise 5.06: Creating an Anonymous Function to Calculate the Square Root
    of a Number'
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.06：创建一个用于计算数字平方根的匿名函数
- en: 'Anonymous functions are great for small snippets of code that you want to execute
    within a function. Here, we are going to create an anonymous function that is
    going to have an argument passed to it. It will then calculate the square root.
    The following steps will help you with the solution:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数非常适合您想在函数内部执行的小段代码。在这里，我们将创建一个匿名函数，该函数将接受一个参数。然后它将计算平方根。以下步骤将帮助您找到解决方案：
- en: Use the IDE of your choice.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的IDE。
- en: Create a new file and save it at `$GOPATH\functions\anonymousfnc\main.go`.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，并将其保存到`$GOPATH\functions\anonymousfnc\main.go`。
- en: 'Enter the following code in `main.go`. We are assigning our `x` variable to
    our anonymous function. Our anonymous function takes a parameter, (`i int`). It
    also returns a value of `int`:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中输入以下代码。我们将我们的`x`变量赋值给匿名函数。我们的匿名函数接受一个参数（`i int`）。它还返回一个`int`类型的值：
- en: '[PRE58]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Notice that the last curly brace does not have the `()` to execute the function.
    We call our anonymous function using `x(j)`:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，最后一个花括号没有`()`来执行函数。我们使用`x(j)`来调用我们的匿名函数：
- en: '[PRE59]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Open up a terminal and navigate to the code's directory.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并导航到代码目录。
- en: Run `go build` and run the executable.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go build`并运行可执行文件。
- en: 'The expected output is as follows:'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE60]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this exercise, we saw how to assign a variable to a function and later call
    that function by using the variable that was assigned to it. We saw that when
    we need a small function that might not be reusable in our program, we can create
    an anonymous function and assign it to a variable. In the next section, we are
    going to expand the use of anonymous functions into closures.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何将变量分配给函数，然后通过使用分配给它的变量来调用该函数。我们看到了当我们需要一个可能在我们程序中不可重用的小型函数时，我们可以创建一个匿名函数并将其分配给一个变量。在下一节中，我们将扩展匿名函数的使用到闭包。
- en: Closures
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: 'We have introduced anonymous function syntax using some basic examples. Now
    that we have a fundamental understanding of how anonymous functions work, we will
    look at how we can use this powerful concept. Closures are a form of anonymous
    functions. Regular functions cannot reference variables outside of themselves;
    however, an anonymous function can reference variables external to their definition.
    A closure can use variables declared at the same level as the anonymous function''s
    declared. These variables do not need to be passed as parameters. The anonymous
    function has access to these variables when it is called:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过一些基本示例介绍了匿名函数的语法。现在，我们已经对匿名函数的工作原理有了基本理解，我们将探讨如何使用这个强大的概念。闭包是匿名函数的一种形式。常规函数不能引用自身之外的变量；然而，匿名函数可以引用其定义之外的变量。闭包可以使用与匿名函数声明在同一级别的变量。这些变量不需要作为参数传递。当匿名函数被调用时，它可以访问这些变量：
- en: '[PRE61]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**Code synopsis:**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码概要：**'
- en: We initialize a variable in the `main()` function called `i` and set it to `0`.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`main()`函数中初始化一个变量`i`并将其设置为`0`。
- en: We assign `incrementor` to our anonymous function.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`incrementor`赋值给我们的匿名函数。
- en: The anonymous function increments `i` and returns it. Notice that our function
    does not have any input parameters.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匿名函数增加`i`并返回它。注意，我们的函数没有任何输入参数。
- en: We then print the results of `incrementor` twice and get `1` and `2`.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们打印了两次`incrementor`的结果，得到`1`和`2`。
- en: Notice that outside our function we increment `i` by `10`. This is a problem.
    We want `i` to be isolated and for it not to change, as this is not the desired
    behavior. When we print the results of `incrementor` again, it will be `12`. We
    want it to be `3`. We will correct this in our next example.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，在我们的函数外部，我们通过`i`增加`10`。这是一个问题。我们希望`i`是隔离的，并且不改变，因为这不是我们想要的行为。当我们再次打印`incrementor`的结果时，它将是`12`。我们希望它是`3`。我们将在下一个示例中纠正这个问题。
- en: 'One problem with the previous example that we notice is that any code in the
    main function has access to `i`. As we saw in the example, `i` can be accessed
    and changed outside of our function. This is not the desired behavior; we want
    the incrementor to be the only one to change that value. In other words, we want
    `i` to be protected from other functions changing it. The only function that should
    be changing it is our anonymous function when we call it:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到前一个示例中的一个问题是，主函数中的任何代码都可以访问`i`。正如我们在示例中看到的，`i`可以在函数外部被访问和修改。这不是我们想要的行为；我们希望增量器是唯一可以改变该值的。换句话说，我们希望`i`被保护，防止其他函数修改它。唯一应该修改它的函数是我们调用匿名函数时：
- en: '[PRE62]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**Code synopsis:**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码概要：**'
- en: We declared a function called `incrementor()`. This function has a return type
    of `func()` `int`.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了一个名为`incrementor()`的函数。这个函数的返回类型是`func()` `int`。
- en: '`i := 0`: We initialize our variable at the level of the `incrementor()` function;
    this is similar to what we did in the previous example, except it was at the `main()`
    function level and anyone at that level had access to `i`. Only the `incrementor()`
    function has access to the `i` variable with this implementation.'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`i := 0`：我们在`incrementor()`函数的级别初始化我们的变量；这与我们在前一个示例中所做的是类似的，只是它是在`main()`函数级别，任何在那个级别的人都可以访问`i`。只有`incrementor()`函数可以访问这个实现中的`i`变量。'
- en: We are returning our anonymous function, `func()` `int`, which increments the
    `i` variable.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们返回我们的匿名函数`func()` `int`，该函数增加`i`变量。
- en: In the `main()` function, `increment:=incrementor()` assigns a variable to the
    `func()` `int` that gets returned. It is important to note that `incrementor()`
    only gets executed once here. In our `main()` function, it is no longer being
    referenced or executed.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，`increment:=incrementor()` 将一个变量赋值给返回 `func()` `int` 的函数。需要注意的是，`incrementor()`
    在这里只执行一次。在我们的 `main()` 函数中，它不再被引用或执行。
- en: '`Increment()` is of type `func()` `int`. Each call to `increment()` runs the
    anonymous function code. It is referencing the `i` variable, even after `incrementor()`
    has executed.'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Increment()` 是 `func()` `int` 类型。每次调用 `increment()` 都会运行匿名函数代码。即使在 `incrementor()`
    执行之后，它仍然引用 `i` 变量。'
- en: 'Exercise 5.07: Creating a Closure Function to Decrement a Counter'
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.07：创建一个用于递减计数器的闭包函数
- en: 'In this exercise, we are going to create a closure that decrements from a given
    starting value. We are combining what we have learned about passing an argument
    to an anonymous function and using that knowledge with a closure. The following
    steps will help you with the solution:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个从给定起始值递减的闭包。我们将结合向匿名函数传递参数和利用闭包的知识。以下步骤将帮助您找到解决方案：
- en: Open the IDE of your choice.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您选择的 IDE。
- en: Create a new file and save it at `$GOPATH\closureFnc\variadic\main.go`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `$GOPATH\closureFnc\variadic\main.go` 创建一个新文件并保存。
- en: 'Enter the following code in `main.go`:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中输入以下代码：
- en: '[PRE63]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We will look at the `decrement` function first. It takes an argument of type
    `int` and has a return value of `func()int`. In previous examples, the variable
    was declared inside the function but before the anonymous function. In this exercise,
    we have it as an input parameter:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先看看 `decrement` 函数。它接受一个 `int` 类型的参数，并有一个返回值 `func()int`。在之前的例子中，变量是在函数内部声明的，但在匿名函数之前。在这个练习中，我们将其作为输入参数：
- en: '[PRE64]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We decrement `i` by one inside the anonymous function:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在匿名函数内部递减 `i`：
- en: '[PRE65]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the `main()` function, we initialize a variable counter to be used as our
    starting integer to be decremented:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们初始化一个名为 counter 的变量，用作要递减的起始整数：
- en: '[PRE66]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`x:= decrement(counter)` : `x` is assigned to `func()` `int`. Each call to
    `x()` runs the anonymous function:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`x:= decrement(counter)` : `x` 被赋值为 `func()` `int`。每次调用 `x()` 都会运行匿名函数：'
- en: '[PRE67]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Open up a terminal and navigate to the code's directory.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并导航到代码目录。
- en: Run `go build` and run the executable.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go build` 并运行可执行文件。
- en: 'The expected output for the `decrement` counter is as follows:'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`decrement` 函数的预期输出如下：'
- en: '[PRE68]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: In this exercise, we saw that closures have access to variables that are external
    to them. This allowed our anonymous function to make changes to the variable that
    a normal function would not be able to make. In the next section, we are going
    to look at how functions can be passed as arguments to another function.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了闭包可以访问它们之外的变量。这使得我们的匿名函数能够修改一个普通函数无法修改的变量。在下一节中，我们将探讨函数如何作为参数传递给另一个函数。
- en: Function Types
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数类型
- en: 'As we have seen so far, Go has rich feature support for functions. In Go, functions
    are types too, just like `int`, `string`, and `bool` are types. This means we
    can pass functions as arguments to other functions, functions can be returned
    from a function, and functions can be assigned to variables. We can even define
    our own function types. A function''s type signature defines the types of its
    input parameters and return values. For a function to be of the type of another
    function, it must have the exact signature of the type function that is declared.
    Let''s examine a few function types:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Go 对函数的功能支持非常丰富。在 Go 中，函数也是类型，就像 `int`、`string` 和 `bool` 一样是类型。这意味着我们可以将函数作为参数传递给其他函数，函数可以从函数中返回，函数可以被赋值给变量。我们甚至可以定义自己的函数类型。函数的类型签名定义了其输入参数和返回值的类型。为了使一个函数成为另一个函数的类型，它必须具有声明的类型函数的确切签名。让我们考察一些函数类型：
- en: '[PRE69]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The preceding code snippet creates a new function type called message. It has
    no input parameters and does not have any return types.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段创建了一个名为 message 的新函数类型。它没有输入参数，也没有任何返回类型。
- en: 'Let''s examine another one:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看另一个例子：
- en: '[PRE70]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The preceding code snippet creates a new function type called calc. It accepts
    two arguments of type int and its return value is of type string.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段创建了一个名为 calc 的新函数类型。它接受两个整型参数，其返回值类型为字符串。
- en: 'Now that we have a fundamental understanding of function types, we can write
    some code to demonstrate their uses:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对函数类型有了基本理解，我们可以编写一些代码来演示它们的用法：
- en: '[PRE71]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Let''s look at the code by the line:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看代码：
- en: '[PRE72]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`type calc` declares `calc` to be of type `func`, determining that it takes
    two integers as arguments and returns a string:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`type calc` 声明 `calc` 为 `func` 类型，确定它接受两个整数作为参数并返回一个字符串：'
- en: '[PRE73]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`func add(i,j int) string` has the same signature as type `calc`. It takes
    two integers as arguments and returns a string stating "Adding `i + j = result`".
    Functions can be passed to other functions just like any other type in Go:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`func add(i,j int) string` 与类型 `calc` 具有相同的签名。它接受两个整数作为参数，并返回一个字符串，说明 "Adding
    `i + j = result`"。函数可以像 Go 中的任何其他类型一样传递给其他函数：'
- en: '[PRE74]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`func calculator(f calc, i, j int)` accepts type `calc` as input. The `calc`
    type, as you may remember, is a function type that has input parameters of `int`
    and a return type of `string`. Anything that matches that signature can be passed
    to the function. The `func calculator` function returns the result of the function
    of type `calc`.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`func calculator(f calc, i, j int)` 接受类型 `calc` 作为输入。你可能记得，`calc` 类型是一个函数类型，它接受两个
    `int` 类型的参数并返回一个 `string` 类型的值。任何匹配该签名的都可以传递给该函数。`func calculator` 函数返回类型为 `calc`
    的函数的结果。'
- en: In the `main` function, we call `calculator`(`add`,`5`,`6`). We are passing
    it the `add` function. `add` satisfies the signature of type `calc func`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们调用 `calculator(add,5,6)`。我们传递给它 `add` 函数。`add` 满足 `calc func`
    类型的签名。
- en: '*Figure 5.12* summarizes each of the preceding functions and how they relate
    to each other. The figure shows how `func add` is of type `func calc`, which then
    allows it to be passed as an argument to `func calculator`:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5.12* 总结了前面每个函数以及它们之间的关系。该图显示了 `func add` 是 `func calc` 类型，这允许它作为参数传递给 `func
    calculator`：'
- en: '![Figure 5.12: Function types and uses'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.12：函数类型和用法]'
- en: '](img/B14177_05_12.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_05_12.jpg]'
- en: 'Figure 5.12: Function types and uses'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12：函数类型和用法
- en: 'We have just seen how to create a function type and pass it as an argument
    to a function. It is not that far of a stretch to pass a function as a parameter
    to another function. We will change our previous example slightly to reflect passing
    a function as a parameter:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何创建一个函数类型并将其作为参数传递给函数。将函数作为参数传递给另一个函数并不是那么遥远。我们将稍微修改之前的示例以反映传递函数作为参数：
- en: '[PRE75]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We modify the `add` function signature to return an `int` instead of a string.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将 `add` 函数的签名修改为返回 `int` 而不是字符串。
- en: 'We added a second function called `subtract`. Note that its function signature
    is the same as that of the `add` function. The `subtract` function simply returns
    the result of subtracting two numbers:'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个名为 `subtract` 的第二个函数。请注意，它的函数签名与 `add` 函数相同。`subtract` 函数简单地返回两个数字相减的结果：
- en: '[PRE76]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`calculator(f func(int,int)int,i,j int)`: The `calculator` function now has
    an input parameter of type `func` The input parameter, `f`, is a function that
    accepts two integers and returns an `int`. Any function that satisfies the signature
    can be passed to the function.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calculator(f func(int,int)int,i,j int)`: `calculator` 函数现在有一个类型为 `func` 的输入参数。输入参数
    `f` 是一个接受两个整数并返回一个 `int` 的函数。任何满足该签名的函数都可以传递给该函数。'
- en: 'In the `main()` function, `calculator` is called twice: once with the `add`
    function and some integer values being passed and once with the `subtract` function
    being passed as an argument with some integer values.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，`calculator` 被调用了两次：一次是用 `add` 函数和一些整数值调用，另一次是将 `subtract` 函数作为参数传递，并带有一些整数值。
- en: 'The ability to pass functions as a type is a very powerful feature that can
    pass different functions to other functions as long as their signatures match
    the passed-to function''s input parameter. It is quite simple when you think about
    it. An integer type for a function can be any value as long as it is an integer.
    The same goes for passing functions: a function can be any value as long as it
    is the correct type.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数作为类型传递是一个非常强大的功能，只要它们的签名与传递给函数的输入参数匹配，就可以将不同的函数传递给其他函数。当你这么想的时候，这相当简单。一个函数的整数类型可以是任何整数值。同样，对于传递函数来说：只要它是正确的类型，函数可以是任何值。
- en: 'A function can also be returned from another function. We saw this when using
    anonymous functions combined with closures. Here, we will take a brief look since
    we have already seen this syntax in a previous section:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以从另一个函数返回。我们在使用匿名函数和闭包时看到了这一点。在这里，我们将简要地看一下，因为我们已经在之前的章节中看到了这种语法：
- en: '[PRE77]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Returning a function looks as follows:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 返回函数看起来如下：
- en: '[PRE78]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`square(x int) func() int`: The `square` function accepts an `int` as an argument
    and returns a function type that returns an `int`:'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`square(x int) func() int`: `square` 函数接受一个 `int` 类型的参数，并返回一个返回 `int` 的函数类型：'
- en: '[PRE79]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In the `square` body, we assign a variable, `f`, to an anonymous function that
    returns the square value of the input parameter, `x`.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `square` 函数体中，我们分配一个变量 `f` 给一个匿名函数，该匿名函数返回输入参数 `x` 的平方值。
- en: The `return` statement for the `square` function returns an anonymous function
    that is of type `func()` int.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`square` 函数的 `return` 语句返回一个匿名函数，该函数类型为 `func()` int。'
- en: '`v` is assigned to the return of the `square` function. As you may recall,
    the return value is of type `func()` int.'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v` 被分配给 `square` 函数的返回值。如您所回忆的，返回值是 `func() int` 类型。'
- en: '`v` has been assigned type `func ()int`; however, it has not been invoked.
    We will invoke it inside the `print` statement.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v` 已被分配为 `func ()int` 类型；然而，它尚未被调用。我们将在 `print` 语句中调用它。'
- en: '`fmt.Printf("Type of v: %T",v)`: This statement just prints out the type for
    `v`, which is `func()int`.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fmt.Printf("Type of v: %T",v)`: 这条语句只是打印出 `v` 的类型，它是 `func()int`。'
- en: 'Exercise 5.08: Creating Various Functions to Calculate Salary'
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 5.08：创建各种函数来计算薪水
- en: 'We are going to be creating several functions. We need the ability to calculate
    the salary of a developer and a manager. We want this solution to be extensible
    for the future possibilities of other salaries to be calculated. We will be creating
    functions to calculate the developer and manager salary. Then we will create another
    function that will take the previously mentioned function as input parameter.
    The following steps will help you with the solution:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建几个函数。我们需要计算开发人员和经理的薪水。我们希望这个解决方案能够扩展到未来计算其他薪水的可能性。我们将创建计算开发人员和经理薪水的函数。然后我们将创建另一个函数，该函数将接受前面提到的函数作为输入参数。以下步骤将帮助您找到解决方案：
- en: Use the IDE of your choice.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的 IDE。
- en: Create a new file and save it at `$GOPATH\function\funcAsParam\main.go`.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，并将其保存到 `$GOPATH\function\funcAsParam\main.go`。
- en: 'Enter the following code in `main.go`:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main.go` 中输入以下代码：
- en: '[PRE80]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `salary` function accepts a function that accepts two integers as arguments
    and returns an int. So, any function that matches that signature can be passed
    as an argument to the `salary` function:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`salary` 函数接受一个接受两个整数作为参数并返回整数的函数。因此，任何匹配该签名的函数都可以作为 `salary` 函数的参数传入：'
- en: '[PRE81]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In the body of the `salary()` function, `pay` is assigned the value that gets
    returned from the `f` function. It passes `x` and `y` parameters as parameters
    to the `f` parameter:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `salary()` 函数的主体中，`pay` 被分配给从 `f` 函数返回的值。它将 `x` 和 `y` 参数作为参数传递给 `f` 参数：
- en: '[PRE82]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Notice that the `managerSalary` and `developerSalary` signatures are identical
    and they match the function `f` for `salary`. This means that both `managerSalary`
    and `developerSalary` can be passed as `func(int,int) int`:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`managerSalary` 和 `developerSalary` 的签名相同，并且与 `salary` 函数的 `f` 相匹配。这意味着 `managerSalary`
    和 `developerSalary` 都可以作为 `func(int,int) int` 传入：
- en: '[PRE83]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`devSalary` and `bossSalary` get assigned to the results of the `salary` function.
    Since `developerSalary` and `managerSalary` satisfy the signature of `func(int,int)
    int`, they each can be passed in as arguments:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`devSalary` 和 `bossSalary` 被分配给 `salary` 函数的结果。由于 `developerSalary` 和 `managerSalary`
    满足 `func(int,int) int` 的签名，它们各自可以作为参数传入：'
- en: '[PRE84]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Open a terminal and navigate to the code's directory.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并导航到代码目录。
- en: Run `go build` and run the executable.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `go build` 并运行可执行文件。
- en: 'The expected output is as follows:'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '[PRE85]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In this exercise, we saw how a function type can be a parameter for another
    function. This allows a function to be an argument to another function. This exercise
    showed how our code can be simplified by having one `salary` function. If, in
    the future, we need to calculate the salary for a tester position, we would only
    need to create a function that matches the function type for `salary` and pass
    it as an argument. The flexibility that this gives is that we do not have to change
    our `salary` function's implementation. In the next section, we are going to see
    how we can change the execution flow of a function, specifically after the function
    returns.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了函数类型可以作为另一个函数的参数。这允许函数作为另一个函数的参数。这个练习展示了我们的代码可以通过拥有一个 `salary` 函数来简化。如果将来我们需要计算测试员的薪水，我们只需要创建一个与
    `salary` 函数类型匹配的函数，并将其作为参数传入。这种灵活性意味着我们不需要更改 `salary` 函数的实现。在下一节中，我们将看到如何改变函数的执行流程，特别是函数返回之后。
- en: defer
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟调用
- en: 'The defer statement defers the execution of a function until the surrounding
    function returns. Let''s try to explain this a bit better. Inside a function,
    you have a `defer` in front of a function that you are calling. That function
    will execute essentially right before the function you are currently inside completes.
    Still confused? Perhaps an example will make this concept a little clearer:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer`语句将函数的执行延迟到周围函数返回。让我们试着更好地解释一下。在一个函数内部，你有一个`defer`在你正在调用的函数之前。那个函数将基本上在你当前所在的函数完成之前执行。还是不明白？也许一个例子会使这个概念更清晰：'
- en: '[PRE86]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The output for the `defer` example is as follows:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer`例子的输出如下：'
- en: '[PRE87]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Inside the `main()` function, we have a deferred function, `defer` `done()`.
    Notice that the `done()` function has no new or special syntax. It just has a
    simple print to `stdout`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数内部，我们有一个延迟执行的函数，`defer done()`。请注意，`done()`函数没有新的或特殊的语法。它只是简单地打印到`stdout`。
- en: Next, we have two print statements. The results are interesting. The two `print`
    statements in the `main()` function print first. Even though the deferred function
    was first in `main()`, it printed last. Isn't that interesting? Its ordering in
    the `main()` function did not dictate its order of execution.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有两个打印语句。结果很有趣。`main()`函数中的两个`print`语句首先打印。尽管延迟函数在`main()`中是第一个，但它最后打印。这不是很有趣吗？它在`main()`函数中的顺序并没有决定它的执行顺序。
- en: The deferred functions are commonly used for performing "clean-up" activities.
    That would include the release of resources, the closing of files, the closing
    database connections, and the removal of configuration\temp files created by a
    program. The `defer` functions are also used to recover from a panic; this is
    discussed in a later chapter.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟执行的函数通常用于执行“清理”活动。这包括释放资源、关闭文件、关闭数据库连接以及删除程序创建的配置\临时文件。`defer`函数也用于从恐慌中恢复；这将在后面的章节中讨论。
- en: 'Using the `defer` statement is not limited to just named functions. In fact,
    you can utilize the defer statement with anonymous functions. Taking our previous
    code snippet, let''s turn it into deferred call with an anonymous function:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`defer`语句不仅限于命名函数。实际上，你可以利用`defer`语句与匿名函数一起使用。以我们之前的代码片段为例，让我们将其转换为使用匿名函数的延迟调用：
- en: '[PRE88]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: There is not much that has changed from the previous code. We took the code
    that was in the `done` function and created a deferred anonymous function.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与之前的代码相比，变化不大。我们将`done`函数中的代码提取出来，创建了一个延迟的匿名函数。
- en: The `defer` statement is placed before the `func()` keyword. Our function has
    no function name. As you may recall, a function without a name is an anonymous
    function.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer`语句放置在`func()`关键字之前。我们的函数没有函数名。如您所回忆的，没有名字的函数是匿名函数。'
- en: The results are the same as those from the previous example. The readability,
    to a certain extent, is easier than having the deferred function declared as a
    named function, as in the previous example.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果与上一个例子相同。在一定程度上，可读性比将延迟函数声明为命名函数更容易，就像上一个例子中那样。
- en: 'It is also possible and common to have multiple `defer` statements in a function.
    However, they may not execute in the order that you expect. When using `defer`
    statements in front of functions, the execution follows the order of `defer` statement
    placed in front of them:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个函数中，也常见到有多个`defer`语句。然而，它们可能不会按照你预期的顺序执行。当在函数前使用`defer`语句时，执行顺序遵循它们前面放置的`defer`语句的顺序：
- en: '[PRE89]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The multiple `defer` output looks as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 多个`defer`输出的形式如下：
- en: '[PRE90]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The first three anonymous functions are having their execution deferred.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前三个匿名函数正在执行延迟。
- en: We declare `f1` and `f2` of type `func()`. These two functions are anonymous
    functions.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们声明`f1`和`f2`为`func()`类型。这两个函数是匿名函数。
- en: As you can see, our `f1()` and `f2()` executed as expected, but the order of
    the multiple `defer` statements executed in the reverse order of how they were
    declared in the code. The first `defer` was the last to execute and the last `defer`
    was the first to execute.
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如您所见，我们的`f1()`和`f2()`按预期执行，但多个`defer`语句的执行顺序与它们在代码中声明的顺序相反。第一个`defer`是最后一个执行的，而最后一个`defer`是第一个执行的。
- en: 'Careful consideration must be given when using `defer` statements. A situation
    that you should consider is when you use `defer` statements in conjunction with
    variables. When a variable is passed to a deferred function, the variable''s value
    at that time is what will be used in the deferred function. If that variable is
    changed after the deferred function, it will not be reflected when the deferred
    function runs:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`defer`语句时必须谨慎考虑。你应该考虑的情况是当你将`defer`语句与变量一起使用时。当一个变量被传递给延迟函数时，该变量在那一刻的值将在延迟函数中使用。如果该变量在延迟函数之后被更改，它将不会在延迟函数运行时反映出来：
- en: '[PRE91]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output would be as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE92]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '`age`:= `25`: We initialize the `age` variable to `25` before the `defer` function.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`age`:= `25`: 在`defer`函数之前，我们将`age`变量初始化为`25`。'
- en: '`name:=` `"John"`: We initialize the `name` variable to `"John"` before the
    `defer` function.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name:=` `"John"`: 在`defer`函数之前，我们将`name`变量初始化为`"John"`。'
- en: '`defer` `personAge`(`name`,`age`): We state that the function is going to be
    deferred.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defer` `personAge`(`name`,`age`): 我们声明该函数将被延迟调用。'
- en: '`age*=2`: We double the age after the deferred function. We then print the
    current value of `age` doubled.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`age*=2`: 在延迟函数之后，我们将年龄加倍。然后我们打印加倍后的当前`age`值。'
- en: '`personAge`(`name` `string`, `i` `int`): This is the function that is deferred;
    it only prints out the person and age.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`personAge`(`name` `string`, `i` `int`): 这是一个被延迟调用的函数；它只打印出人和年龄。'
- en: The results show the value of `age` (`25`) after it has been doubled in the
    `main` function.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果显示了在`main`函数中将年龄加倍后的`age`值（`25`）。
- en: When the execution of the program reaches the line that has `defer` `personAge(name,age)`,
    the value of `age` is `25`. Before the `main()` function completes, the deferred
    function runs and the value of `age` is still `25`. Variables used in the deferred
    function are the values before it was deferred, regardless of what happens after
    it.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当程序执行到达包含`defer` `personAge(name,age)`的行时，`age`的值为`25`。在`main()`函数完成之前，延迟函数运行，`age`的值仍然是`25`。在延迟函数中使用的变量是延迟之前的值，无论之后发生什么。
- en: 'Activity 5.02: Calculating Payable Amount for Employees Based on Working Hours'
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动编号 5.02：根据工作时间计算员工的应付款项
- en: 'This activity is based on the previous activity. We will keep the same functionality
    but we will be adding three additional features. In this version of the application,
    we would like to give the employee the ability to track their hours throughout
    the day without having logged them yet. This will allow the employees to keep
    better track of their hours before they log them at the end of the day. We are
    also enhancing the application to calculate the employee''s pay. The application
    will calculate their pay for any overtime they worked. The application will also
    print out details of how many hours were worked each day:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动基于之前的活动。我们将保持相同的功能，但我们将添加三个额外的功能。在这个应用程序的版本中，我们希望给员工提供在未记录的情况下跟踪他们一天中工作时间的功能。这将使员工在一天结束时记录工作时间之前能更好地跟踪他们的工作时间。我们还将增强应用程序以计算员工的工资。应用程序将计算他们加班的工资。应用程序还将打印出每天工作了多少小时的详细信息：
- en: Create a function called `nonLoggedHours()` `func(int)` `int`. Each time this
    function is called, it will calculate the hours of the employee that have not
    been logged. You will be using a closure inside the function.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`nonLoggedHours()`的函数（`func(int)` `int`）。每次调用此函数时，它将计算未记录的员工工作时间。你将在函数内部使用闭包。
- en: Create a method called `PayDay()(int,bool)`. This method will calculate the
    weekly pay. It needs to take into consideration overtime pay. The method will
    pay twice the hourly rate for hours greater than 40\. The function will return
    `int` as the weekly pay and `bool` for if the pay is overtime pay. The Boolean
    will be true if the employee worked more than `40` hours and false if they worked
    less than `40` hours.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PayDay()`的方法（`int`, `bool`）。此方法将计算每周工资。它需要考虑加班工资。对于超过40小时的工作，该方法将以两倍的时薪支付。该函数将返回`int`类型的每周工资，以及`bool`类型的加班工资标志。如果员工工作了超过`40`小时，布尔值将为`true`；如果他们工作少于`40`小时，则为`false`。
- en: Create a method called `PayDetails()`. This method will print each day and the
    hours worked that day by the employee. It will print the total hours for the week,
    the pay for the week, and if the pay contains overtime pay.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PayDetails()`的方法。此方法将打印出员工每天的工作时间和当天的工作时间。它将打印出每周的总工作时间、每周的工资以及工资是否包含加班工资。
- en: Inside of the `main` function, initialize a variable of type `Developer`. Assign
    a variable to `nonLoggedHours`. Print the variable assigned to `nonLoggedHours`
    with values of `2`, `3`, and `5`.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数内部，初始化一个类型为 `Developer` 的变量。将一个变量分配给 `nonLoggedHours`。打印分配给 `nonLoggedHours`
    的变量，其值为 `2`、`3` 和 `5`。
- en: 'Also, in the `main()` function, log the hours for the following days: Monday
    8, Tuesday 10, Wednesday 10, Thursday 10, Friday 6, and Saturday 8.'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在 `main()` 函数中，记录以下几天的时数：周一 8 小时，周二 10 小时，周三 10 小时，周四 10 小时，周五 6 小时，以及周六
    8 小时。
- en: Then run the `PayDetails()` method.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后运行 `PayDetails()` 方法。
- en: 'The following is the expected output:'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是我们预期的输出：
- en: '![Figure 5.13: Output for payable amount activity'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.13：可支付金额活动的输出]'
- en: '](img/B14177_05_13.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_05_13.jpg](img/B14177_05_13.jpg)'
- en: 'Figure 5.13: Output for payable amount activity'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13：可支付金额活动的输出
- en: Note
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 706.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第 706 页找到。
- en: The aim of this activity is to go a step further than *Activity 5.01,* *Calculating
    the Working Hours of Employees*, by using some more advanced programming with
    Go's functions. In this activity, we will continue to use functions as we did
    previously; however, we will be returning multiple values and returning a function
    from a function. We also demonstrate the use of closures for calculating hours
    not logged by an employee.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的目的是在比 *活动 5.01*，*计算员工的工作时间* 更进一步，通过使用一些更高级的 Go 函数编程来实现。在这个活动中，我们将继续使用函数，就像我们之前做的那样；然而，我们将返回多个值，并从函数中返回一个函数。我们还演示了使用闭包来计算员工未记录的小时数。
- en: Summary
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have studied why and how functions are an essential part of the Go programming
    language. We also discussed various features of functions in Go that make Go stand
    apart from other programming languages. Go has features that allow us to solve
    a lot of real-world problems. Functions in Go serve many purposes, including enhancing
    the usage and readability of code. We learned how to create and call functions.
    We studied the various types of functions used in Go and discussed scenarios where
    each of the function types can be used. We also expounded the concept of closures.
    Closures are essentially a type of anonymous function that can use variables declared
    at the same level as that at which the anonymous function was declared. We also
    discussed various parameters and return types and studied `defer`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经研究了为什么函数是 Go 编程语言的一个基本组成部分，以及函数在 Go 中的各种特性，这些特性使 Go 与其他编程语言区别开来。Go 具有允许我们解决许多现实世界问题的特性。Go
    中的函数服务于许多目的，包括增强代码的使用和可读性。我们学习了如何创建和调用函数。我们还研究了 Go 中使用的各种函数类型，并讨论了每种函数类型可以使用的场景。我们还阐述了闭包的概念。闭包本质上是一种匿名函数，它可以使用与匿名函数声明级别相同的变量。我们还讨论了各种参数和返回类型，并研究了
    `defer`。
- en: In the next chapter, we shall be exploring errors and error types and learning
    how to build custom errors, thus building a recovery mechanism to handle errors
    in Go.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨错误和错误类型，并学习如何构建自定义错误，从而构建一个恢复机制来处理 Go 中的错误。
