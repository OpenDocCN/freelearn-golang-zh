<html><head></head><body>
		<div>
			<div id="_idContainer095" class="Content">
			</div>
		</div>
		<div id="_idContainer096" class="Content">
			<h1 id="_idParaDest-188"><a id="_idTextAnchor197"/>6. Errors</h1>
		</div>
		<div id="_idContainer110" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we will be looking at various code snippets from the Go standard packages to get an understanding of Go's idiomatic way of performing error handling. We will also look at how to create custom error types in Go and see examples in the standard library.</p>
			<p class="callout">By the end of this chapter, you will be able to distinguish between the different types of errors and compare error handling and exception handling. You will also be able to create error values and use <strong class="source-inline">panic()</strong> to handle errors and recover after a panic.</p>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor198"/>Introduction</h1>
			<p>In the previous chapter, we learned about creating functions. We also discovered that functions can be passed as parameters and returned from a function. In this chapter, we will work with errors and learn how to return those from functions.</p>
			<p>Developers are not perfect and, by extension, neither is the code that they produce. All software at some point in time has had errors. Handling errors is critical when you are developing software. These errors can have a negative impact of varying degrees on its users. The impact on the users of your software can be more far-reaching than you realize.</p>
			<p>For instance, let's consider the Northeast Blackout of 2003. On August 14, there was a blackout for about 50 million people in the United States and Canada that lasted for 14 days. This was due to a race condition bug in the alarm system in a control room. Technically, a race condition bug is when two separate threads try to access the same memory location for a write operation. This race condition can cause a program to crash. In this instance, it resulted in over 250 power plants going offline. One way to handle a race condition is to ensure proper synchronization between the various threads and allow memory locations to be accessed for write operations by only one thread at a time. It is important that we, as developers, ensure proper handling of errors. If we do not handle errors properly, this can have a negative impact on the users of our application and their way of life, as seen by the power outage incident we described.</p>
			<p>In this chapter, we will be looking at what an error is, what an error looks like in Go, and, more specifically, how to handle errors the Go way. Let's get started!</p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor199"/>What Are Errors?</h1>
			<p>An error is something that causes your program to produce unintended results. Those unintended results could range from the application crashing, incorrect data calculation (such as a bank transaction not being processed correctly), or not providing any results. These unintended results are referred to as software bugs. Any software would contain errors during its lifetime due to numerous scenarios that programmers do not anticipate. The following are possible outcomes when errors occur:</p>
			<ul>
				<li>The erroneous code could cause the program to crash without warning.</li>
				<li>The output of the program was not the intended result.</li>
				<li>An error message is displayed.</li>
			</ul>
			<p>There are three types of errors that you might encounter:</p>
			<ul>
				<li>Syntax errors</li>
				<li>Runtime errors</li>
				<li>Semantic errors</li>
			</ul>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor200"/>Syntax Errors</h2>
			<p>Syntax errors result from improper use of the programming language. This often occurs due to mistyping the code. Most modern IDEs will have some visual way of bringing syntax errors to the attention of the programmer; for example, refer to <em class="italic">Figure 6.1</em>. In most modern IDEs, syntax errors can be caught at an early stage. They may occur more frequently when you are learning a new programming language. A few occurrences of syntax errors could be due to the following:</p>
			<ul>
				<li>Incorrect use of syntax for a loop</li>
				<li>Misplacing or omitting curly braces, parentheses, or brackets</li>
				<li>Misspelled function names or package names</li>
				<li>Passing the wrong type of argument to a function</li>
			</ul>
			<p>Here is an example of a syntax error:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  fmt.println("Enter your city:")</p>
			<p class="source-code">}</p>
			<p>The output appears as follows:</p>
			<p class="source-code">fmt.println("Enter your city:")</p>
			<p class="source-code">cannot refer to unexported name fmt.println</p>
			<p class="source-code">undefined: fmt.println</p>
			<p>Go is case sensitive, so,  <strong class="source-inline">println</strong> should be <strong class="source-inline">Println</strong>.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor201"/>Runtime Errors</h2>
			<p>These errors occur when the code is asked to perform a task that it cannot do. Unlike syntax errors, these are typically only found during the execution of the code.</p>
			<p>The following are common examples of runtime errors:</p>
			<ul>
				<li>Opening a connection to a database that does not exist</li>
				<li>Performing a loop that is bigger than the number of elements in the slice or array you are iterating over</li>
				<li>Opening a file that does not exist</li>
				<li>Performing a mathematical operation, such as dividing a number by zero</li>
			</ul>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor202"/>Exercise 6.01: Runtime Errors While Adding Numbers</h2>
			<p>In this exercise, we are going to write a simple program that sums up a slice of numbers. This program will demonstrate an example of a runtime error and will crash when it is executed.</p>
			<ol>
				<li>Inside <strong class="source-inline">$GOPATH</strong>, create a directory called <em class="italic">Exercise6.01</em>.</li>
				<li>Create a file called <strong class="source-inline">main.go</strong> inside the directory created in <em class="italic">step 1</em>.</li>
				<li>This program will be in <strong class="source-inline">package main</strong>. Import the <strong class="source-inline">fmt</strong> package:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Inside the <strong class="source-inline">main</strong> function, we will have a slice of integers that will have four elements:<p class="source-code">func main() {</p><p class="source-code">  nums := []int{2, 4, 6, 8}</p></li>
				<li>We will have a variable, <strong class="source-inline">total</strong>, to be used for the calculation of summing all the integer variables in the slice. Use a <strong class="source-inline">for</strong> loop to sum the variables:<p class="source-code">  total := 0</p><p class="source-code">  for i := 0; i &lt;= 10; i++ {</p><p class="source-code">    total += nums[i]</p><p class="source-code">  }</p></li>
				<li>Next, we print the results of the total:<p class="source-code">  fmt.Println("Total: ", total)</p><p class="source-code">}</p><p>We have introduced an example of a runtime error to the program; so, we will not get the following output:</p><p class="source-code">Total: 20</p></li>
				<li>At the command line, navigate to the directory created in <em class="italic">step 1</em>.</li>
				<li>At the command line, type the following:<p class="source-code">go build</p><p>The <strong class="source-inline">go build</strong> command will compile your program and create an executable named after the directory you created in <em class="italic">step 1</em>.</p></li>
				<li>Type the name of the file created in <em class="italic">step 8</em> and hit <em class="italic">Enter</em> to run the executable:</li>
			</ol>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B14177_06_01.jpg" alt="Figure 6.1: Output after executing&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1: Output after executing</p>
			<p>As you can see, the program crashed. The <strong class="source-inline">index out of range</strong> panic is a common error to new Go developers and veterans alike.</p>
			<p>In this example, the error, a panic (we will discuss what a panic is later in the chapter) in this program, is the result of iterating in the <strong class="source-inline">for</strong> loop by a greater number, in our case 10, than the actual number of elements in the slice, in our case 4. One possible solution would be to use a <strong class="source-inline">for</strong> loop with a range:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  nums := []int{2, 4, 6, 8}</p>
			<p class="source-code">  total := 0</p>
			<p class="source-code">  for i := range nums {</p>
			<p class="source-code">    total += nums[i]</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Println("Total: ", total)</p>
			<p class="source-code">}</p>
			<p>In this exercise, we saw how we can avoid runtime errors by paying attention to minute details.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor203"/>Semantic Errors</h2>
			<p>Syntax errors are the easiest to debug, followed by runtime errors, while logic errors are the hardest. Semantic errors are sometimes very hard to spot at first. For example, in 1998, when the Mars Climate Orbiter was launched, its purpose was to study the climate of Mars, but due to a logic error in the system, the Mars Climate Orbiter, valued at $235 million, was destroyed. After some analysis, it was discovered that the calculations of units on the ground controller system were done in imperial units and the software on the Orbiter was done in metric units. This is a logic error that caused the navigation system to incorrectly calculate its maneuvers in space. As you can see, these are defects in the way the code is processing elements of your program. Reasons for semantic errors to occur could be because of:</p>
			<ul>
				<li>Incorrect computations</li>
				<li>Accessing incorrect resources (files, databases, servers, variables, and so on)</li>
				<li>Incorrect setting of variables for negation (not equal versus equal)</li>
			</ul>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor204"/>Exercise 6.02: Logic Error with Walking Distance</h2>
			<p>We are writing an application that will determine whether we should walk to our destination or take a car. If our destination is greater than or equal to 2 km, we are going to take a car. If it is less than 2 km, then we will walk to our destination. We are going to demonstrate a semantic error with this program.</p>
			<p>The expected output of this exercise is as follows:</p>
			<p class="source-code">Take the car</p>
			<ol>
				<li value="1">Create a directory called <em class="italic">Exercise6.02</em> inside your <strong class="source-inline">$GOPATH</strong>.</li>
				<li>Save a file called <strong class="source-inline">main.go</strong> inside the directory created in <em class="italic">step 1</em>. This program will be inside <strong class="source-inline">package main</strong>.</li>
				<li>Import the <strong class="source-inline">fmt</strong> package:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Inside of the <strong class="source-inline">main</strong> function, display a message to take the car when <strong class="source-inline">km</strong> is greater than 2, and when <strong class="source-inline">km</strong> is less than 2, to send a message for walking:<p class="source-code">func main() {</p><p class="source-code">  km := 2</p><p class="source-code">  if  km &gt; 2 {</p><p class="source-code">    fmt.Println("Take the car")</p><p class="source-code">  } else {</p><p class="source-code">    fmt.Println("Going to walk today")</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>At the command line, navigate to the directory created in <em class="italic">step 1</em>.</li>
				<li>At the command line, type the following:<p class="source-code">go build</p><p>The <strong class="source-inline">go build</strong> command will compile your program and create an executable named after the directory you created in <em class="italic">step 1</em>.</p></li>
				<li>Type the name of the file created in <em class="italic">step 6</em> and hit <em class="italic">Enter</em> to run the executable. You will get the following output:<p class="source-code">Going to walk today</p></li>
			</ol>
			<p>The program runs with no errors, but the message displayed is not what was expected.</p>
			<p>As previously stated, the program runs with no errors, but the results are not what we expected. This is because we have a logic error. Our <strong class="source-inline">if</strong> statement is not accounting for the <strong class="source-inline">km</strong> equal to <strong class="source-inline">2</strong>. It is only checking that the distance is greater than <strong class="source-inline">2</strong>. It is a simple fix. Replace the <strong class="source-inline">&gt;</strong> with <strong class="source-inline">&gt;=</strong> and now the program will give the results that we expect.</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  km := 2</p>
			<p class="source-code">  if  km &gt;= 2 {</p>
			<p class="source-code">    fmt.Println("Take the car")</p>
			<p class="source-code">  } else {</p>
			<p class="source-code">    fmt.Println("Going to walk today")</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>This simple program made it easy to debug the logic error, but these types of errors in a larger program may not be as easy to spot.</p>
			<p>We will mainly be focusing on the runtime errors in this chapter. It is good to understand the various types of errors that you as a programmer could encounter.</p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor205"/>Error Handling Using Other Programming Languages</h1>
			<p>New programmers to Go who have a background in other programming languages will initially find Go's methodology for dealing with errors a bit odd. Go does not handle errors in the same fashion as other languages, such as Java, Python, C#, and Ruby. Those languages perform exception handling.</p>
			<p>The following code snippets are some examples of how other languages handle errors by performing exception handling:</p>
			<p class="source-code">//java</p>
			<p class="source-code">try {</p>
			<p class="source-code">  // code</p>
			<p class="source-code">}<strong class="bold">catch</strong> (exception e){</p>
			<p class="source-code">  // block of code to handle the error</p>
			<p class="source-code">}</p>
			<p class="source-code">//python</p>
			<p class="source-code"><strong class="bold">try</strong>:</p>
			<p class="source-code">  //code</p>
			<p class="source-code">except:</p>
			<p class="source-code">  //code</p>
			<p class="source-code">else:</p>
			<p class="source-code">  try:</p>
			<p class="source-code">  // code</p>
			<p class="source-code">  except:</p>
			<p class="source-code">  // code</p>
			<p class="source-code"><strong class="bold">finally</strong>:</p>
			<p class="source-code">  //code</p>
			<p>Typically, exceptions, if not handled, will crash your application. In most cases, exception handling tends to be implicit checking versus Go's explicit checking for errors returned by its functions. In the exception handling paradigm, anything can fail, and you must account for that. Each function can throw an exception, but you do not know what that exception could be.</p>
			<p>In the error handling paradigm that Go uses, it is obvious when the programmer did not handle the error, because the function returns the error code, and you can see that they did not check for the error. We will be looking at the specifics of checking for the error code later in the chapter.</p>
			<p>Most programming languages follow a similar pattern to the one shown in the previous code snippet. It is usually some sort of <strong class="source-inline">try..catch..finally</strong> block. One point of contention with the <strong class="source-inline">try..catch..finally</strong> block is that the control flow of the program execution gets interrupted and can follow a different path. This can sometimes lead to a number of logic errors and difficulty in the readability of the code. Here is a quick peek at how Go handles errors:</p>
			<p class="source-code">val, err:= someFunc() err</p>
			<p class="source-code">if err !=nil{</p>
			<p class="source-code">  return err</p>
			<p class="source-code">}</p>
			<p class="source-code">return nil</p>
			<p>The preceding code snippet is a very simple syntax for handling the error. We will see this in much greater detail in the following topics. In this topic, we want to introduce you to the simplicity of how Go handles errors compared to the syntax of other languages.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor206"/>Error Interface Type</h1>
			<p>What is an error in Go? An error in Go is a value. Here is a quote from Rob Pike, one of the pioneers of Go:</p>
			<p>"<em class="italic">Values can be programmed, and since errors are values, errors can be programmed. Errors are not like exceptions. There's nothing special about them, whereas an unhandled exception can crash your program.</em>"</p>
			<p>Since errors are values, they can be passed into a function, returned from a function, and evaluated just like any other value in Go.</p>
			<p>An error in Go is anything that implements the error interface. We need to look at some fundamental aspects that make up the error type in Go. To be an error type in Go, it must first satisfy the <strong class="source-inline">type error interface</strong>:</p>
			<p class="source-code">//https://golang.org/pkg/builtin/#error</p>
			<p class="source-code">type error interface {</p>
			<p class="source-code">  Error()string</p>
			<p class="source-code">}</p>
			<p>The wonderful thing about Go is the simplistic design of the language features. This can easily be seen with the error interface. Go's standard library uses the error interface. To satisfy the error interface, only two things are required:</p>
			<ul>
				<li>The method name, <strong class="source-inline">Error()</strong></li>
				<li>The <strong class="source-inline">Error()</strong> method to return a string</li>
			</ul>
			<p>Those are the two requirements. It is important to understand that an error type is an interface type. Any value that is an error can be described as a string. When performing error handling in Go, the functions will return an error value. The Go language uses this throughout the standard library.</p>
			<p>Look at the following code snippet for a starting discussion point on errors:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "strconv"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  v := "10"</p>
			<p class="source-code">  if s, err := strconv.Atoi(v); err == nil {</p>
			<p class="source-code">    fmt.Printf("%T, %v\n", s, s)</p>
			<p class="source-code">  }else{</p>
			<p class="source-code">    fmt.Println(err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  v = "s2"</p>
			<p class="source-code">  s, err := strconv.Atoi(v) </p>
			<p class="source-code">  if err != nil{</p>
			<p class="source-code">    fmt.Println(s, err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>We will not go into every detail of the function but focus on the error portion of the code. In <em class="italic">Chapter 5</em>, <em class="italic">Functions</em>, we stated that functions can return multiple values. This is a powerful feature that most languages do not have. It is powerful, especially when dealing with error values. The <strong class="source-inline">strconv.Atoi()</strong> function returns an <strong class="source-inline">int</strong> and an error, as seen in the example stated previously. It is a function that is in the Go standard library (<a href="https://packt.live/2YvL1BV">https://packt.live/2YvL1BV</a>). For functions that return error values, it should be the last return value.</p>
			<p>It is Go idiomatic to evaluate the error value for functions or methods that return an error. It is generally bad practice to not handle an error that is returned from the function. An error when returned and ignored can lead to lots of wasted debugging efforts. It can also cause unforeseen consequences in your program. If the value is not nil, then we have an error and must decide how we want to handle it. Depending on the scenario, we might want to:</p>
			<ul>
				<li>Return the error to the caller</li>
				<li>Log the error and continue execution</li>
				<li>Stop the execution of the program</li>
				<li>Ignore it (this is highly not recommended)</li>
				<li>Panic (only in very rare conditions, we will discuss this further later)</li>
			</ul>
			<p>If the value of error is nil, that means there is no error. No further steps are necessary.</p>
			<p>Let's look further into the standard package regarding the error type. We will start by looking at each piece of code in the <a href="https://packt.live/2rk6r8Z">https://packt.live/2rk6r8Z</a> file.</p>
			<p class="source-code">type errorString struct {</p>
			<p class="source-code">s string</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">struct</strong> <strong class="source-inline">errorString</strong> is in the <strong class="source-inline">errors</strong> package. The struct is used to store the string version of the error. The <strong class="source-inline">errorString</strong> has a single field of <strong class="source-inline">s</strong> that is of the <strong class="source-inline">string</strong> type. The <strong class="source-inline">errorString</strong> and the field are unexportable. This means that we can't access the <strong class="source-inline">errorString</strong> type or its field, <strong class="source-inline">s</strong>, directly. The following code gives an example of trying to access an unexported <strong class="source-inline">errorString</strong> type and its field, <strong class="source-inline">s</strong>:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "errors"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  es := errors.errorString{}</p>
			<p class="source-code">  es.s = "slacker"</p>
			<p class="source-code">  fmt.Println(es)</p>
			<p class="source-code">}</p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B14177_06_02.jpg" alt="Figure 6.2: Expected output for unexported field&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2: Expected output for unexported field</p>
			<p>On the surface, it appears that <strong class="source-inline">errorString</strong> is neither accessible nor useful but we should keep digging. We are still in the standard library:</p>
			<p class="source-code">func (e *errorString) Error() string {</p>
			<p class="source-code">    return e.s</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">errorString</strong> type has a method that implements the error interface. It satisfies requirements, a method called <strong class="source-inline">Error()</strong>, and it returns a string. The error interface has been satisfied. We now have access to the <strong class="source-inline">errorString</strong> field, <strong class="source-inline">s</strong>, through the <strong class="source-inline">Error()</strong> method. This is how an error gets returned within the standard library.</p>
			<p>You should now have a basic understanding of what an error is in Go. Now, we should look at how to create our own error types in Go.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor207"/>Creating Error Values</h2>
			<p>In the standard library, the package error has a method that we can use to create our own errors:</p>
			<p class="source-code">// https://golang.org/src/errors/errors.go</p>
			<p class="source-code">// New returns an error that formats as the given text.</p>
			<p class="source-code">func New(text string) error {</p>
			<p class="source-code">    return &amp;errorString{text}</p>
			<p class="source-code">}</p>
			<p>It is important to understand that the <strong class="source-inline">New</strong> function takes a string as an argument and converts it to <strong class="source-inline">*errors.errorString</strong> and returns as an error value. The underlying value of the error type that gets returned is of the <strong class="source-inline">*errors.errorSting</strong> type.</p>
			<p>We can prove this by running the following code:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "errors"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  ErrBadData := errors.New("Some bad data")</p>
			<p class="source-code">  fmt.Printf("ErrBadData type:  %T", ErrBadData)</p>
			<p class="source-code">}</p>
			<p>Here is an example from Go's standard library, <strong class="source-inline">http</strong>, that uses the <strong class="source-inline">errors</strong> package to create package-level variables:</p>
			<p class="source-code">var (</p>
			<p class="source-code">    ErrBodyNotAllowed = errors.New("http: request method or response status       code does not allow body")</p>
			<p class="source-code">    ErrHijacked = errors.New("http: connection has been hijacked")</p>
			<p class="source-code">    ErrContentLength = errors.New("http: wrote more than the declared Content-      Length")</p>
			<p class="source-code">    ErrWriteAfterFlush = errors.New("unused")</p>
			<p class="source-code">)</p>
			<p>When creating your own errors, it is idiomatic in Go to start with the <strong class="source-inline">Err</strong> variable.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor208"/>Exercise 6.03: Creating an Application to Calculate Pay for the Week</h2>
			<p>In this exercise, we are going to create a function that calculates pay for the week. This function will accept two arguments, the hours worked during the week and the hourly rate. The function is going to check whether the two parameters meet the criteria for being valid. The function will need to calculate regular pay, which is hours less than or equal to 40, and overtime pay, which is hours greater than 40 for the week.</p>
			<p>We will create two error values using <strong class="source-inline">errors.New()</strong>. The one error value will be used when there is an invalid hourly rate. An invalid hourly rate in our app is an hourly rate that is less than 10 or greater than 75. The second error value will be when hours per week are not between 0 and 80.</p>
			<p>Use the IDE of your choice. One option would be Visual Studio Code.</p>
			<ol>
				<li value="1">Create a directory called <em class="italic">Exercise6.03</em> inside your <strong class="source-inline">$GOPATH</strong>.</li>
				<li>Save a file called <strong class="source-inline">main.go</strong> inside the directory created in <em class="italic">step 1</em>. The <strong class="source-inline">main.go</strong> file will be in <strong class="source-inline">package main</strong>.</li>
				<li>Import the two Go standard libraries, <strong class="source-inline">errors</strong> and <strong class="source-inline">fmt</strong>:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "errors"</p><p class="source-code">  "fmt"</p><p class="source-code">)</p></li>
				<li>Now we have declared our error variables using <strong class="source-inline">errors.New()</strong>. We use idiomatic Go for the variable name, starting it with <strong class="source-inline">Err</strong> and camel casing. Our error string is in lowercase with no punctuation:<p class="source-code">var (</p><p class="source-code">  ErrHourlyRate  = errors.New("invalid hourly rate")</p><p class="source-code">  ErrHoursWorked = errors.New("invalid hours worked per week")</p><p class="source-code">)</p></li>
				<li>Inside the <strong class="source-inline">main</strong> function, we will be calling our <strong class="source-inline">payday()</strong> function three times. We declared our error variables using <strong class="source-inline">errors.New()</strong>:<p class="source-code">  pay, err := payDay(81, 50)</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">  }</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, check each <strong class="source-inline">err</strong> after the function. If <strong class="source-inline">err</strong> is not nil, this means there is an error, and we will print that error.<p>Create the <strong class="source-inline">payDay</strong> function to accept two arguments (<strong class="source-inline">hoursWorked</strong> and <strong class="source-inline">hourlyRate</strong>). The function will return an <strong class="source-inline">int</strong> and an error:</p><p class="source-code">func payDay(hoursWorked, hourlyRate int) (int, error) {</p><p class="source-code">  if hourlyRate &lt; 10 || hourlyRate &gt; 75 {</p><p class="source-code">    return 0, ErrHourlyRate</p><p class="source-code">  }</p><p class="source-code">  if hoursWorked &lt; 0 || hoursWorked &gt; 80 {</p><p class="source-code">    return 0, ErrHoursWorked</p><p class="source-code">  }</p><p class="source-code">  if hoursWorked &gt; 40 {</p><p class="source-code">    hoursOver := hoursWorked - 40</p><p class="source-code">    overTime := hoursOver * 2</p><p class="source-code">    regularPay := hoursWorked * hourlyRate</p><p class="source-code">    return regularPay + overTime, nil</p><p class="source-code">  }</p><p class="source-code">  return hoursWorked * hourlyRate, nil</p><p class="source-code">}</p></li>
				<li>We will use an <strong class="source-inline">if</strong> statement to check whether the hourly rate is less than 10 or greater than 75. If <strong class="source-inline">hourlyRate</strong> meets those conditions, we will return a <strong class="source-inline">0</strong> and our custom error, <strong class="source-inline">ErrHourlyRate</strong>. If <strong class="source-inline">hourlyRate</strong> does not meet those conditions, then the returned value will be <strong class="source-inline">return hoursWorked * hourlyRate, nil</strong>. We return <strong class="source-inline">nil</strong> for the error because there was no error:<p class="source-code">func payDay(hoursWorked, hourlyRate int) (int, error) {</p><p class="source-code">  if hourlyRate &lt; 10 || hourlyRate &gt; 75 {</p><p class="source-code">    return 0, ErrHourlyRate</p><p class="source-code">  }</p><p class="source-code">  return hoursWorked * hourlyRate, nil</p><p class="source-code">}</p></li>
				<li>In <em class="italic">step 7</em>, we validated <strong class="source-inline">hourlyRate</strong>. Now we will need to validate <strong class="source-inline">hoursWorked</strong>. We will add another <strong class="source-inline">if</strong> statement to the <strong class="source-inline">payDay()</strong> function that will check whether <strong class="source-inline">hoursWorked</strong> is less than <strong class="source-inline">0</strong> or greater than <strong class="source-inline">80</strong>. If the <strong class="source-inline">hoursWorked</strong> matches that condition, we will return <strong class="source-inline">0</strong> and the error, <strong class="source-inline">ErrHoursWorked</strong>:<p class="source-code">func payDay(hoursWorked, hourlyRate int) (int, error) {</p><p class="source-code">  if hourlyRate &lt; 10 || hourlyRate &gt; 75 {</p><p class="source-code">    return 0, ErrHourlyRate</p><p class="source-code">  }</p><p class="source-code">  if hoursWorked &lt; 0 || hoursWorked &gt; 80 {</p><p class="source-code">    return 0, ErrHoursWorked</p><p class="source-code">  }</p><p class="source-code">  return hoursWorked * hourlyRate, nil</p><p class="source-code">}</p></li>
				<li>In the previous two steps, we added <strong class="source-inline">if</strong> statements to validate the arguments being passed to the function. In this step, we will add another <strong class="source-inline">if</strong> statement to calculate overtime pay. Overtime pay is hours greater than <strong class="source-inline">40</strong>. The hours over <strong class="source-inline">40</strong> are double the <strong class="source-inline">hourlyRate</strong>. The hours less than or equal to <strong class="source-inline">40</strong> are at the <strong class="source-inline">hourlyRate</strong>:<p class="source-code">func payDay(hoursWorked, hourlyRate int) (int, error) {</p><p class="source-code">  if hourlyRate &lt; 10 || hourlyRate &gt; 75 {</p><p class="source-code">    return 0, ErrHourlyRate</p><p class="source-code">  }</p><p class="source-code">  if hoursWorked &lt; 0 || hoursWorked &gt; 80 {</p><p class="source-code">    return 0, ErrHoursWorked</p><p class="source-code">  }</p><p class="source-code">  if hoursWorked &gt; 40 {</p><p class="source-code">    hoursOver := hoursWorked - 40</p><p class="source-code">    overTime := hoursOver * 2</p><p class="source-code">    regularPay := hoursWorked * hourlyRate</p><p class="source-code">    return regularPay + overTime, nil</p><p class="source-code">  }</p><p class="source-code">  return hoursWorked * hourlyRate, nil</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, we will call the <strong class="source-inline">payDay()</strong> function three times with various arguments. We will check the error after each call and print the error message if applicable. If there is no error, then we print the pay for the week:<p class="source-code">func main() {</p><p class="source-code">  pay, err := payDay(81, 50)</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">  }</p><p class="source-code">  pay, err = payDay(80, 5)</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">  }</p><p class="source-code">  pay, err = payDay(80, 50)</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">  }</p><p class="source-code">  fmt.Println(pay)</p><p class="source-code">}</p></li>
				<li>In the command line, navigate to the directory created in <em class="italic">step 1</em>.</li>
				<li>In the command line, type the following:<p class="source-code">go build</p><p>The <strong class="source-inline">go build</strong> command will compile your program and create an executable named after the directory you created in <em class="italic">step 1</em>.</p></li>
				<li>Type the name of the file created in <em class="italic">step 12</em> and hit <em class="italic">Enter</em> to run the executable.<p>The expected output is as follows:</p><p class="source-code">Invalid hours worked per week</p><p class="source-code">Invalid hourly rate</p><p class="source-code">4080</p></li>
			</ol>
			<p>In this exercise, we saw how to create custom error messages that can be used to easily determine why the data was considered invalid. We also showed how to return multiple values from a function and to check for errors from the function. In the next topic, we will look at how to use panic in our applications.</p>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor209"/>Panic</h1>
			<p>Several languages use exceptions for handling errors. However, Go does not use exceptions, it uses something called panic. Panic is a built-in function that causes the program to crash. It stops the normal execution of the Goroutine.</p>
			<p>In Go, panic is not the norm, unlike other languages where an exception is a norm. A panic signal indicates something abnormal that is occurring within your code. Usually, when panic is initiated by runtime or the developer, it is to protect the integrity of the program.</p>
			<p>Errors and panics differ in their purposes and how they are handled by the Go runtime. An error in Go indicates that something unexpected occurred, but it will not adversely impact the integrity of the program. Go expects that the developer will handle the error properly. The function or other programs will not typically crash if you do not handle the error. However, panics differ in this regard. When panic occurs, it will ultimately crash the system unless there are handlers to handle the panic. If there are no handlers for the panic, it will go all the way up the stack and crash the program.</p>
			<p>One example that we will look at later in this chapter is where panic occurs due to an index being out of range. This is typical when trying to access the index of a collection that doesn't exist. If Go did not panic in this case, it could have an adverse impact on the integrity of the program, such as other parts of the program trying to store or retrieve data that is not there in the collection.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Review the topic of Goroutines. The <strong class="source-inline">main()</strong> function is a Goroutine. When panic occurs, you will see references to "Goroutine running" in the error message.</p>
			<p>Panics can be initiated by the developer and can be caused during the execution of a program by runtime errors. A <strong class="source-inline">panic()</strong> function accepts an empty interface. For now, suffice to say, this means it can accept anything as an argument. However, in most cases, you should pass an error type to the <strong class="source-inline">panic()</strong> function. It is more intuitive to the user of our function to have some details on what caused the panic. Passing an error to the panic function is also idiomatic in Go. We will also see how recovering from a panic that has an error type passed to it gives us some different options when dealing with panic. When panic occurs, it will generally follow these steps:</p>
			<ul>
				<li>The execution is stopped</li>
				<li>Any deferred functions in the panicking function will be called</li>
				<li>Any deferred functions in the stack of the panicking function will be called</li>
				<li>It will continue all the way up the stack until it reaches <strong class="source-inline">main()</strong></li>
				<li>Statements after the panicking function will not execute</li>
				<li>The program then crashes</li>
			</ul>
			<p>Here is how panic works:</p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B14177_06_03.jpg" alt="Figure 6.3: The working of panic&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3: The working of panic</p>
			<p>The preceding diagram illustrates code in the <strong class="source-inline">main</strong> function that calls function <strong class="source-inline">a()</strong>. Function <strong class="source-inline">a()</strong> then calls function <strong class="source-inline">b()</strong>. Inside of function <strong class="source-inline">b()</strong>, a panic occurs. The <strong class="source-inline">panic()</strong> function is not handled by any of the code upstream (function <strong class="source-inline">a()</strong> or the <strong class="source-inline">main()</strong> function), so the program will crash the <strong class="source-inline">main()</strong> function.</p>
			<p>Here is an example of a panic that occurs in Go. Try to determine why this program panics.</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  nums := []int{1, 2, 3}</p>
			<p class="source-code">  for i := 0; i &lt;= 10; i++ {</p>
			<p class="source-code">    fmt.Println(nums[i])</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>An example of panic is as follows:</p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B14177_06_04.jpg" alt="Figure 6.4: Panic example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4: Panic example</p>
			<p>The panic runtime error is a common one that you will encounter while developing. It is an <strong class="source-inline">index out of range</strong> error. Go generated this panic because we are trying to iterate over a slice more times than there are elements. Go felt that this is a reason to panic because it puts the program in an abnormal condition.</p>
			<p>Here is a snippet of code that demonstrates the basics of using a panic:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "errors"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  msg := "good-bye"</p>
			<p class="source-code">  message(msg)</p>
			<p class="source-code">  fmt.Println("This line will not get printed")</p>
			<p class="source-code">}</p>
			<p class="source-code">func message(msg string) {</p>
			<p class="source-code">  if msg == "good-bye" {</p>
			<p class="source-code">    panic(errors.New("something went wrong"))</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p><strong class="bold">Code Synopsis:</strong></p>
			<ul>
				<li>The function panics because the argument to the function message is <strong class="source-inline">"good-bye"</strong>.</li>
				<li>The <strong class="source-inline">panic()</strong> function will print the error message. Having a good error message helps with the debugging process.</li>
				<li>Inside the panic, we are using <strong class="source-inline">errors.New()</strong>, which we used in the previous topic to create an error type.</li>
				<li>As you can see, <strong class="source-inline">fmt.Println()</strong> does not get executed in the <strong class="source-inline">main()</strong> function. Since there are no <strong class="source-inline">defer</strong> statements, execution stops immediately.<p>The expected output for this code snippet is:</p></li>
			</ul>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B14177_06_05.jpg" alt="Figure 6.5: Panic example output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5: Panic example output</p>
			<p>In the following code snippet, we will see how using <strong class="source-inline">panic</strong> and a <strong class="source-inline">defer</strong> statement functions together.</p>
			<p class="source-code-heading">main.go</p>
			<p class="source-code">10 func test() {</p>
			<p class="source-code">11   n := func() {</p>
			<p class="source-code">12     fmt.Println("Defer in test")</p>
			<p class="source-code">13   }</p>
			<p class="source-code">14   defer n()</p>
			<p class="source-code">15   msg := "good-bye"</p>
			<p class="source-code">16   message(msg)</p>
			<p class="source-code">17 }</p>
			<p class="source-code">18 func message(msg string) {</p>
			<p class="source-code">19   f := func() {</p>
			<p class="source-code">20     fmt.Println("Defer in message func")</p>
			<p class="source-code">21   }</p>
			<p class="source-code">22   defer f()</p>
			<p class="source-code">23   if msg == "good-bye" {</p>
			<p class="source-code">24     panic(errors.New("something went wrong"))</p>
			<p class="source-code-link">The full code is available at: <a href="https://packt.live/2qyujFg">https://packt.live/2qyujFg</a></p>
			<p>The output of the panic example is as follows:</p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B14177_06_06.jpg" alt="Figure 6.6: Panic example output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6: Panic example output</p>
			<p>Let's understand the code in parts:</p>
			<ul>
				<li>We will start examining the code in the <strong class="source-inline">message()</strong> function since that is where the panic starts. When the panic occurs, it runs the <strong class="source-inline">defer</strong> statement within the panicking function, <strong class="source-inline">message()</strong>.</li>
				<li>The deferred function, <strong class="source-inline">func f()</strong>, runs in the <strong class="source-inline">message()</strong> function.</li>
				<li>Going up the call stack, the next function is the <strong class="source-inline">test()</strong> function, and its deferred function, <strong class="source-inline">n()</strong>, will execute.</li>
				<li>Finally, we get to the <strong class="source-inline">main()</strong> function where the execution is stopped by the panicking function. The print statement in <strong class="source-inline">main()</strong> does not get executed.<p class="callout-heading">Note</p><p class="callout">You may have seen <strong class="source-inline">os.Exit()</strong> used to stop execution of the program. <strong class="source-inline">os.Exit()</strong> stops execution immediately and returns a status code. No deferred statements are run when <strong class="source-inline">os.Exit()</strong> is performed. <strong class="source-inline">Panic</strong> is preferred over <strong class="source-inline">os.Exit()</strong> in certain cases. Panic will run deferred functions.</p></li>
			</ul>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor210"/>Exercise 6.04: Crashing the Program on Errors Using panic</h2>
			<p>We will be modifying <em class="italic">Exercise 6.03</em>, <em class="italic">Creating an Application to Calculate Pay for the Week.</em> Consider the following scenario, where the requirements have changed. We no longer need to return error values from our <strong class="source-inline">payDay()</strong> function. It has been decided that we cannot trust the user of the program to respond properly to the errors. There have been complaints of incorrect paychecks. We believe this is due to the caller of our function ignoring the errors being returned.</p>
			<p>The <strong class="source-inline">payDay()</strong> function will only now return the pay amount and no errors. When the arguments provided to the function are invalid, instead of returning an error, the function will panic. This will cause the program to stop immediately and, therefore, not process a paycheck.</p>
			<p>Use the IDE of your choice. One option could be Visual Studio Code.</p>
			<ol>
				<li value="1">Create a new file and save it in <strong class="source-inline">$GOPATH\err\panicEx\main.go</strong>.</li>
				<li>Enter the following code in <strong class="source-inline">main.go</strong>:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "errors"</p><p class="source-code">)</p><p class="source-code">var (</p><p class="source-code">  ErrHourlyRate  = errors.New("invalid hourly rate")</p><p class="source-code">  ErrHoursWorked = errors.New("invalid hours worked per week")</p><p class="source-code">)</p></li>
				<li>Inside the <strong class="source-inline">main</strong> function, call the <strong class="source-inline">payDay()</strong> function, assign it to only one variable, <strong class="source-inline">pay</strong>, and then print it:<p class="source-code">func main() {</p><p class="source-code">  pay := payDay(81, 50)</p><p class="source-code">  fmt.Println(pay)</p><p class="source-code">}</p></li>
				<li>Change the return type of the <strong class="source-inline">payDay()</strong> function to only return <strong class="source-inline">int</strong>:<p class="source-code">func payDay(hoursWorked, hourlyRate int) int {</p></li>
				<li>Inside the <strong class="source-inline">payDay()</strong> function, assign a variable, <strong class="source-inline">report</strong>, to an anonymous function. This anonymous function provides details of the arguments provided to the <strong class="source-inline">payDay()</strong> function. Even though we are not returning errors, this will provide some insight as to why the function panics. Since it is a deferred function, it will always execute before the function exits:<p class="source-code">func payDay(hoursWorked, hourlyRate int) int {</p><p class="source-code">  report := func() {</p><p class="source-code">    fmt.Printf("HoursWorked: %d\nHourldyRate: %d\n", hoursWorked, hourlyRate)</p><p class="source-code">  }</p><p class="source-code">  defer report()</p><p class="source-code">}</p><p>The business rule for valid <strong class="source-inline">hourlyRate</strong> and <strong class="source-inline">hoursWorked</strong> stays the same as in the previous exercise. Instead of returning an error, we will be using the <strong class="source-inline">panic</strong> function. When the data is invalid, we panic and pass the argument of <strong class="source-inline">ErrHourlyRate</strong> or <strong class="source-inline">ErrHoursWorked</strong>.</p><p>The arguments passed to the <strong class="source-inline">panic()</strong> function assist the user of our function in understanding the cause of the panic.</p></li>
				<li>When panic occurs in the <strong class="source-inline">payDay()</strong> function, the <strong class="source-inline">defer</strong> function, <strong class="source-inline">report()</strong>, will give the caller some insight into why the panic occurred. The panic will bubble up the stack to the <strong class="source-inline">main()</strong> function and execution will stop immediately:<p class="source-code">  if hourlyRate &lt; 10 || hourlyRate &gt; 75 {</p><p class="source-code">    panic(ErrHourlyRate)</p><p class="source-code">  }</p><p class="source-code">  if hoursWorked &lt; 0 || hoursWorked &gt; 80 {</p><p class="source-code">    panic(ErrHoursWorked )</p><p class="source-code">  }</p><p class="source-code">  if hoursWorked &gt; 40 {</p><p class="source-code">    hoursOver := hoursWorked - 40</p><p class="source-code">    overTime := hoursOver * 2</p><p class="source-code">    regularPay := hoursWorked * hourlyRate</p><p class="source-code">    return regularPay + overTime</p><p class="source-code">  }</p><p class="source-code">  return hoursWorked * hourlyRate</p></li>
				<li>At the command line, navigate to the directory created in <em class="italic">step 1</em>.</li>
				<li>At the command line, type the following:<p class="source-code">go build</p><p>The <strong class="source-inline">go build</strong> command will compile your program and create an executable named after the directory you created in <em class="italic">step 1</em>.</p></li>
				<li>Type the name of the file created in <em class="italic">step 8</em> and hit <em class="italic">Enter</em> to run the executable.<p>The expected output should be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B14177_06_07.jpg" alt="Figure 6.7: Panic exercise output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7: Panic exercise output</p>
			<p>In this exercise, we learned how to perform <strong class="source-inline">panic</strong> and pass an error to the <strong class="source-inline">panic()</strong> function. This aids the user of the function in gaining a good understanding of the cause of the panic. In the next topic, we will see how to regain control of the program after a panic occurs using <strong class="source-inline">Recover</strong>.</p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor211"/>Recover</h1>
			<p>Go provides us with the ability to regain control after <strong class="source-inline">panic</strong> has occurred. Recover is a function that is used to regain control of a panicking Goroutine.</p>
			<p>The signature of the <strong class="source-inline">recover()</strong> function is as follows:</p>
			<p class="source-code">func recover() interface{}</p>
			<p>The <strong class="source-inline">recover()</strong> function accepts no arguments and returns an empty <strong class="source-inline">interface{}</strong>. For now, an empty <strong class="source-inline">interface{}</strong> indicates that any type can be returned. The <strong class="source-inline">recover()</strong> function will return the value sent to the <strong class="source-inline">panic()</strong> function.</p>
			<p>The <strong class="source-inline">recover()</strong> function is only useful inside a deferred function. As you may recall, a deferred function gets executed before the encompassing function terminates. Executing a call to the <strong class="source-inline">recover()</strong> function inside a deferred function stops the panicking by restoring normal execution. If the <strong class="source-inline">recover()</strong> function is called outside a deferred function, it will not stop the panicking.</p>
			<p>The following diagram shows the steps a program would take when using <strong class="source-inline">panic()</strong>, <strong class="source-inline">recover()</strong>, and a <strong class="source-inline">defer()</strong> function:</p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B14177_06_08.jpg" alt="Figure 6.8: Recover function flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8: Recover function flow</p>
			<p>The steps followed in the diagram can be explained as follows:</p>
			<ul>
				<li>The <strong class="source-inline">main()</strong> function calls <strong class="source-inline">func a()</strong>.</li>
				<li><strong class="source-inline">func a()</strong> calls <strong class="source-inline">func b()</strong>.</li>
				<li>Inside <strong class="source-inline">func b()</strong>, there is a panic.</li>
				<li>The <strong class="source-inline">panic()</strong> function gets handled by a deferred function that is using the <strong class="source-inline">recover()</strong> function.</li>
				<li>The deferred function is the last function to execute inside <strong class="source-inline">func b()</strong>.</li>
				<li>The deferred function calls the <strong class="source-inline">recover()</strong> function.</li>
				<li>The call to <strong class="source-inline">recover()</strong> causes normal flow back to the caller, <strong class="source-inline">func a()</strong>.</li>
				<li>Normal flow continues, and control is finally back with the <strong class="source-inline">main()</strong> function.</li>
			</ul>
			<p>The following code snippet mimics the behavior of the preceding diagram:</p>
			<p class="source-code-heading">main.go</p>
			<p class="source-code">6  func main() {</p>
			<p class="source-code">7    a()</p>
			<p class="source-code">8    fmt.Println("This line will now get printed from main() function")</p>
			<p class="source-code">9  }</p>
			<p class="source-code">10 func a() {</p>
			<p class="source-code">11   b("good-bye")</p>
			<p class="source-code">12   fmt.Println("Back in function a()")</p>
			<p class="source-code">13 }</p>
			<p class="source-code">14 func b(msg string) {</p>
			<p class="source-code">15   defer func() {</p>
			<p class="source-code">16     if r:= recover(); r!= nil{</p>
			<p class="source-code">17       fmt.Println("error in func b()",r)</p>
			<p class="source-code">18     }</p>
			<p class="source-code">19   }()</p>
			<p class="source-code-link">The full code is available at: <a href="https://packt.live/2E6j6ig">https://packt.live/2E6j6ig</a></p>
			<p><strong class="bold">Code Synopsis</strong></p>
			<ul>
				<li>The <strong class="source-inline">main()</strong> function calls function <strong class="source-inline">a()</strong>. The <strong class="source-inline">a()</strong> function calls function <strong class="source-inline">b()</strong>.</li>
				<li>Function <strong class="source-inline">b()</strong> accepts a string type and assigns it to the <strong class="source-inline">msg</strong> variable. If <strong class="source-inline">msg</strong> evaluates to <strong class="source-inline">true</strong> in the <strong class="source-inline">if</strong> statement, a panic will occur.</li>
				<li>The argument for the panic is a new error created by the <strong class="source-inline">errors.New()</strong> function:</li>
			</ul>
			<p class="source-code">  if msg == "good-bye" {</p>
			<p class="source-code">    panic(errors.New("something went wrong"))</p>
			<p class="source-code">  }</p>
			<p>Once the panic occurs, the next call will be to the deferred function.</p>
			<p>The deferred function uses the <strong class="source-inline">recover()</strong> function. The value of the panic is returned from recover; in this case, the value of <strong class="source-inline">r</strong> is an error type. Then, the function prints out some details:</p>
			<p class="source-code">  defer func() {</p>
			<p class="source-code">    if r:= recover(); r!= nil{</p>
			<p class="source-code">      fmt.Println("error in func b()",r)</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }()</p>
			<ul>
				<li>The control flow goes back to function <strong class="source-inline">a()</strong>. Function <strong class="source-inline">a()</strong> prints out some details.</li>
				<li>Then, the control goes back to the <strong class="source-inline">main()</strong> function and it prints out some details and terminates:</li>
			</ul>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B14177_06_09.jpg" alt="Figure 6.9: Recover example output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9: Recover example output</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor212"/>Exercise 6.05: Recovering from a Panic</h2>
			<p>In this exercise, we will enhance our <strong class="source-inline">payDay()</strong> function to recover from a panic. When our <strong class="source-inline">payDay()</strong> function panics, we will inspect the error from that panic. Then, depending on the error, we will print an informative message to the user.</p>
			<p>Use the IDE of your choice, one option would be Visual Studio Code.</p>
			<ol>
				<li value="1">Create a new file and save it in <strong class="source-inline">$GOPATH\err\panicEx\main.go</strong>.</li>
				<li>Enter the following code in <strong class="source-inline">main.go</strong>:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "errors"</p><p class="source-code">  "fmt"</p><p class="source-code">)</p><p class="source-code">var (</p><p class="source-code">  ErrHourlyRate  = errors.New("invalid hourly rate")</p><p class="source-code">  ErrHoursWorked = errors.New("invalid hours worked per week")</p><p class="source-code">)</p></li>
				<li>Call the <strong class="source-inline">payDay()</strong> function with various arguments and then print the return value of the function:<p class="source-code">func main() {</p><p class="source-code">  pay := payDay(100, 25)</p><p class="source-code">  fmt.Println(pay)</p><p class="source-code">  pay = payDay(100, 200)</p><p class="source-code">  fmt.Println(pay)</p><p class="source-code">  pay = payDay(60, 25)</p><p class="source-code">  fmt.Println(pay)</p><p class="source-code">}</p></li>
				<li>Then, add a <strong class="source-inline">defer</strong> function to your <strong class="source-inline">payDay()</strong> function:<p class="source-code">func payDay(hoursWorked, hourlyRate int) int {</p><p class="source-code">  defer func() {</p></li>
				<li>We can check for the return value from the <strong class="source-inline">recover()</strong> function, as follows:<p class="source-code">if r := recover(); r != nil {</p><p class="source-code">      if r == ErrHourlyRate {</p><p>If <strong class="source-inline">r</strong> is not <strong class="source-inline">nil</strong>, that means a panic occurs and we should perform an action.</p></li>
				<li>We can evaluate <strong class="source-inline">r</strong> and see whether it equals our error values, <strong class="source-inline">ErrHourlyRate</strong> or <strong class="source-inline">ErrHoursWorked</strong>:<p class="source-code">        fmt.Printf("hourly rate: %d\nerr: %v\n\n", hourlyRate, r)</p><p class="source-code">      }</p><p class="source-code">      if r == ErrHoursWorked {</p><p class="source-code">        fmt.Printf("hours worked: %d\nerr: %v\n\n", hoursWorked, r)</p><p class="source-code">      }</p><p class="source-code">    }</p></li>
				<li>If our <strong class="source-inline">if</strong> statements evaluate to <strong class="source-inline">true</strong>, we print some details about the data and the error values from the <strong class="source-inline">recover()</strong> function. We then print how our pay was calculated:<p class="source-code">    fmt.Printf("Pay was calculated based on:\nhours worked: %d\nhourly Rate: %d\n", hoursWorked, hourlyRate)</p><p class="source-code">  }()</p></li>
				<li>The rest of the code in the <strong class="source-inline">payDay()</strong> function remains unchanged. To see a description of it, you can refer to <em class="italic">Exercise 6.04</em>, <em class="italic">Crashing the Program on Errors Using panic</em>:<p class="source-code">  if hourlyRate &lt; 10 || hourlyRate &gt; 75 {</p><p class="source-code">    panic(ErrHourlyRate)</p><p class="source-code">  }</p><p class="source-code">  if hoursWorked &lt; 0 || hoursWorked &gt; 80 {</p><p class="source-code">    panic(ErrHoursWorked)</p><p class="source-code">  }</p><p class="source-code">  if hoursWorked &gt; 40 {</p><p class="source-code">    hoursOver := hoursWorked - 40</p><p class="source-code">    overTime := hoursOver * 2</p><p class="source-code">    regularPay := hoursWorked * hourlyRate</p><p class="source-code">    return regularPay + overTime</p><p class="source-code">  }</p><p class="source-code">  return hoursWorked * hourlyRate</p><p class="source-code">}</p></li>
				<li>At the command line, navigate to the directory created in <em class="italic">step 1</em>.</li>
				<li>At the command line, type the following:<p class="source-code">go build</p><p>The <strong class="source-inline">go build</strong> command will compile your program and create an executable named after the directory you created in <em class="italic">step 1</em>.</p></li>
				<li>Type the name of the file created in <em class="italic">step 10</em> and hit <em class="italic">Enter</em> to run the executable.<p>The expected output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B14177_06_10.jpg" alt="Figure 6.10: Recovering from a panic exercise output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10: Recovering from a panic exercise output</p>
			<p>In the preceding exercises, we have seen the progression of creating a custom error and returning that error. From this, we have been able to crash programs when needed using <strong class="source-inline">panic</strong>. In the previous exercise, we demonstrated the ability to recover from panics and display error messages based on the error type that was passed to the <strong class="source-inline">panic()</strong> function. In the following topic, we will discuss some basic guidelines when performing error handling in Go.</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor213"/>Guidelines when working with Errors and Panic</h2>
			<p>Guidelines are just for guidance. They are not set in stone. This means, the majority of the time you should follow the guidelines; however, there could be exceptions. Some of these guidelines have been mentioned previously, but we have consolidated them here for quick reference:</p>
			<ul>
				<li>When declaring our own error type, the variable needs to start with <strong class="source-inline">Err</strong>. It should also follow the camel case naming convention.<p class="source-code">var ErrExampleNotAllowd= errors.New("error example text")</p></li>
				<li>The <strong class="source-inline">error</strong> string should start with lowercase and not end with punctuation. One of the reasons for this guideline is that the error can be returned and concatenated with other information relevant to the error.</li>
				<li>If a function or method returns an error, it should be evaluated. Errors not evaluated can cause the program to not function as expected.</li>
				<li>When using <strong class="source-inline">panic()</strong>, pass an error type as the argument, instead of an empty value.</li>
				<li>Do not evaluate the string value of an error.</li>
				<li>Use the <strong class="source-inline">panic()</strong> function sparingly.</li>
			</ul>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor214"/>Activity 6.01: Creating a Custom Error Message for a Banking Application</h2>
			<p>A bank wants to add some custom errors when checking for last name and valid routing numbers. They have found that the direct deposit procedure allows invalid names and routing numbers to be used. The bank wants a descriptive error message for when these incidents occur. Our job is to create two descriptive custom error messages. Remember to use an idiomatic naming convention for the error variable and a proper structure for the error message.</p>
			<p>You need to do the following:</p>
			<ol>
				<li value="1">Create two error values for <strong class="source-inline">InvalidLastName</strong> and <strong class="source-inline">InvalidRoutingNumber</strong>.</li>
				<li>Then, print the custom message in the <strong class="source-inline">main()</strong> function to show the bank the error message they will receive when those errors are encountered.<p>The expected output is as follows:</p></li>
			</ol>
			<p class="source-code">invalid last name</p>
			<p class="source-code">invalid routing number</p>
			<p>By the end of this activity, you will be familiar with the steps that are needed to create a custom error message.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 709.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor215"/>Activity 6.02: Validating a Bank Customer's Direct Deposit Submission</h2>
			<p>The bank was pleased with the custom error messages that you created in <em class="italic">Activity 6.01,</em> <em class="italic">Creating a Custom Error Message for a Banking Application</em>. They are so pleased that they now want you to implement two methods. These two methods are for validating the last name and the routing number:</p>
			<ol>
				<li value="1">You will need to create a struct called <strong class="source-inline">directDeposit</strong>.</li>
				<li>The <strong class="source-inline">directDeposit</strong> struct will have three string fields: <strong class="source-inline">lastName</strong>, <strong class="source-inline">firstName</strong>, and <strong class="source-inline">bankName</strong>. It will also have two <strong class="source-inline">int</strong> fields called <strong class="source-inline">routingNumber</strong> and <strong class="source-inline">accountNumber</strong>.</li>
				<li>The <strong class="source-inline">directDeposit</strong> struct will have a <strong class="source-inline">validateRoutingNumber</strong> method. The method will return <strong class="source-inline">ErrInvalidRoutingNum</strong> when the routing number is less than 100.</li>
				<li>The <strong class="source-inline">directDeposit</strong> struct will have a <strong class="source-inline">validateLastName</strong> method. It will return <strong class="source-inline">ErrInvalidLastName</strong> when the <strong class="source-inline">lastName</strong> is an empty string.</li>
				<li>The <strong class="source-inline">directDeposit</strong> struct will have a method report. It will print out each of the fields' values.</li>
				<li>In the <strong class="source-inline">main()</strong> function, assign values to the <strong class="source-inline">directDeposit</strong> struct's fields and call each of the <strong class="source-inline">directDeposit</strong> struct's methods.<p>The expected output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B14177_06_11.jpg" alt="Figure 6.11: Validating a bank customer's direct deposit submission&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11: Validating a bank customer's direct deposit submission</p>
			<p>By the end of this activity, you will have learned how to return errors from functions and how to check for errors returned from a function. You will also be able to check for a condition and, based on that condition, return your own custom error.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 710.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor216"/>Activity 6.03: Panic on Invalid Data Submission</h2>
			<p>The bank has now decided that they would rather crash the program when an invalid routing number is submitted. The bank feels that the erroneous data validates causing the program to stop processing the direct deposit data. You need to raise panic on an invalid data submission instance. Build this on top of <em class="italic">Activity 6.02</em>, <em class="italic">Validating a Bank Customer's Direct Deposit Submission</em>:</p>
			<ol>
				<li value="1">Change the <strong class="source-inline">validateRoutingNumber</strong> method to not return <strong class="source-inline">ErrInvalidRoutingNum</strong>, but instead perform a panic:<p>The expected output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B14177_06_12.jpg" alt="Figure 6.12: Panic on invalid routing number&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12: Panic on invalid routing number</p>
			<p>By the end of this activity, you will be able to cause a <strong class="source-inline">panic</strong> to occur and see how that impacts the flow of the program.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 713.</p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor217"/>Activity 6.04: Preventing a Panic from Crashing the App</h2>
			<p>After some initial alpha testing, the bank no longer wants the app to crash, Instead, in this activity, we need to recover from the panic that was an added feature in <em class="italic">Activity 6.03</em>, <em class="italic">Panic on Invalid Data Submission</em>, and print the error that caused the panic:</p>
			<ol>
				<li value="1">Add a <strong class="source-inline">defer</strong> function inside the <strong class="source-inline">validateRoutingNumber</strong> method.</li>
				<li>Add an <strong class="source-inline">if</strong> statement that checks the error returned from the <strong class="source-inline">recover()</strong> function. If there is an error, then print the error:<p>The expected output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B14177_06_11.jpg" alt="Figure 6.13: Recover from panic on an invalid routing number&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.13: Recover from pa<a id="_idTextAnchor218"/>nic on an invalid routing number</p>
			<p>By the end of this activity, you will cause a panic, but you will be able to prevent it from crashing the application. You will get an understanding of how the <strong class="source-inline">recover()</strong> function, used in conjunction with the <strong class="source-inline">defer</strong> statement, can be used to prevent the application from crashing.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution of this activity can be found on page 614.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor219"/>Summary</h1>
			<p>In this chapter, we have looked at the different types of errors that you will encounter while programming, such as syntax, runtime, and semantic errors. We focused more on runtime errors. These errors are more difficult to debug.</p>
			<p>We examined the difference between various language philosophies when it comes to dealing with errors. We have seen how Go's syntax for errors is simpler to understand compared to the exception handling that various languages are utilizing.</p>
			<p>An error in Go is a value. Values can be passed around to functions. Any error can be a value as long as it implements the error interface type. We learned how easily we can create errors. We also learned that we should name our error values starting with <strong class="source-inline">Err</strong> followed by a descriptive camel case name.</p>
			<p>Next, we discussed panics and the similarities between a panic and an exception. We also discovered that panics are pretty similar to exceptions; however, if panics are unhandled, they will cause the program to crash. However, Go has a mechanism that will return the control of the program back to normal. We do this by using the <strong class="source-inline">recover()</strong> function. The requirements for recovering from a panic requires the usage of the <strong class="source-inline">recover()</strong> function in a deferred function. We also learned the general guidelines for using <strong class="source-inline">errors</strong>, <strong class="source-inline">panic</strong>, and <strong class="source-inline">recover</strong>.</p>
			<p>In the next chapter, we will look at interfaces and their uses, as well as how they differ from how other programming languages implement interfaces. We will see how they can be used to solve various problems that you face as a programmer.</p>
		</div>
		<div>
			<div id="_idContainer111" class="Content">
			</div>
		</div>
	</body></html>