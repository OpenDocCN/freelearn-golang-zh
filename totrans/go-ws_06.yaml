- en: 6\. Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at various code snippets from the Go standard
    packages to get an understanding of Go's idiomatic way of performing error handling.
    We will also look at how to create custom error types in Go and see examples in
    the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to distinguish between the different
    types of errors and compare error handling and exception handling. You will also
    be able to create error values and use `panic()` to handle errors and recover
    after a panic.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about creating functions. We also discovered
    that functions can be passed as parameters and returned from a function. In this
    chapter, we will work with errors and learn how to return those from functions.
  prefs: []
  type: TYPE_NORMAL
- en: Developers are not perfect and, by extension, neither is the code that they
    produce. All software at some point in time has had errors. Handling errors is
    critical when you are developing software. These errors can have a negative impact
    of varying degrees on its users. The impact on the users of your software can
    be more far-reaching than you realize.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, let's consider the Northeast Blackout of 2003\. On August 14,
    there was a blackout for about 50 million people in the United States and Canada
    that lasted for 14 days. This was due to a race condition bug in the alarm system
    in a control room. Technically, a race condition bug is when two separate threads
    try to access the same memory location for a write operation. This race condition
    can cause a program to crash. In this instance, it resulted in over 250 power
    plants going offline. One way to handle a race condition is to ensure proper synchronization
    between the various threads and allow memory locations to be accessed for write
    operations by only one thread at a time. It is important that we, as developers,
    ensure proper handling of errors. If we do not handle errors properly, this can
    have a negative impact on the users of our application and their way of life,
    as seen by the power outage incident we described.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at what an error is, what an error looks
    like in Go, and, more specifically, how to handle errors the Go way. Let's get
    started!
  prefs: []
  type: TYPE_NORMAL
- en: What Are Errors?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An error is something that causes your program to produce unintended results.
    Those unintended results could range from the application crashing, incorrect
    data calculation (such as a bank transaction not being processed correctly), or
    not providing any results. These unintended results are referred to as software
    bugs. Any software would contain errors during its lifetime due to numerous scenarios
    that programmers do not anticipate. The following are possible outcomes when errors
    occur:'
  prefs: []
  type: TYPE_NORMAL
- en: The erroneous code could cause the program to crash without warning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output of the program was not the intended result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An error message is displayed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three types of errors that you might encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semantic errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syntax Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Syntax errors result from improper use of the programming language. This often
    occurs due to mistyping the code. Most modern IDEs will have some visual way of
    bringing syntax errors to the attention of the programmer; for example, refer
    to *Figure 6.1*. In most modern IDEs, syntax errors can be caught at an early
    stage. They may occur more frequently when you are learning a new programming
    language. A few occurrences of syntax errors could be due to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Incorrect use of syntax for a loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Misplacing or omitting curly braces, parentheses, or brackets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Misspelled function names or package names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing the wrong type of argument to a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of a syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Go is case sensitive, so, `println` should be `Println`.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These errors occur when the code is asked to perform a task that it cannot do.
    Unlike syntax errors, these are typically only found during the execution of the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are common examples of runtime errors:'
  prefs: []
  type: TYPE_NORMAL
- en: Opening a connection to a database that does not exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a loop that is bigger than the number of elements in the slice or
    array you are iterating over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opening a file that does not exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing a mathematical operation, such as dividing a number by zero
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 6.01: Runtime Errors While Adding Numbers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we are going to write a simple program that sums up a slice
    of numbers. This program will demonstrate an example of a runtime error and will
    crash when it is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `$GOPATH`, create a directory called *Exercise6.01*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `main.go` inside the directory created in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This program will be in `package main`. Import the `fmt` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main` function, we will have a slice of integers that will have
    four elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will have a variable, `total`, to be used for the calculation of summing
    all the integer variables in the slice. Use a `for` loop to sum the variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we print the results of the total:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have introduced an example of a runtime error to the program; so, we will
    not get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the command line, navigate to the directory created in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the command line, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `go build` command will compile your program and create an executable named
    after the directory you created in *step 1*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type the name of the file created in *step 8* and hit *Enter* to run the executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1: Output after executing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_06_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.1: Output after executing'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the program crashed. The `index out of range` panic is a common
    error to new Go developers and veterans alike.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the error, a panic (we will discuss what a panic is later
    in the chapter) in this program, is the result of iterating in the `for` loop
    by a greater number, in our case 10, than the actual number of elements in the
    slice, in our case 4\. One possible solution would be to use a `for` loop with
    a range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we saw how we can avoid runtime errors by paying attention
    to minute details.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Syntax errors are the easiest to debug, followed by runtime errors, while logic
    errors are the hardest. Semantic errors are sometimes very hard to spot at first.
    For example, in 1998, when the Mars Climate Orbiter was launched, its purpose
    was to study the climate of Mars, but due to a logic error in the system, the
    Mars Climate Orbiter, valued at $235 million, was destroyed. After some analysis,
    it was discovered that the calculations of units on the ground controller system
    were done in imperial units and the software on the Orbiter was done in metric
    units. This is a logic error that caused the navigation system to incorrectly
    calculate its maneuvers in space. As you can see, these are defects in the way
    the code is processing elements of your program. Reasons for semantic errors to
    occur could be because of:'
  prefs: []
  type: TYPE_NORMAL
- en: Incorrect computations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing incorrect resources (files, databases, servers, variables, and so
    on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorrect setting of variables for negation (not equal versus equal)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 6.02: Logic Error with Walking Distance'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are writing an application that will determine whether we should walk to
    our destination or take a car. If our destination is greater than or equal to
    2 km, we are going to take a car. If it is less than 2 km, then we will walk to
    our destination. We are going to demonstrate a semantic error with this program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expected output of this exercise is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Create a directory called *Exercise6.02* inside your `$GOPATH`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save a file called `main.go` inside the directory created in *step 1*. This
    program will be inside `package main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `fmt` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside of the `main` function, display a message to take the car when `km`
    is greater than 2, and when `km` is less than 2, to send a message for walking:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the command line, navigate to the directory created in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the command line, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `go build` command will compile your program and create an executable named
    after the directory you created in *step 1*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type the name of the file created in *step 6* and hit *Enter* to run the executable.
    You will get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The program runs with no errors, but the message displayed is not what was expected.
  prefs: []
  type: TYPE_NORMAL
- en: As previously stated, the program runs with no errors, but the results are not
    what we expected. This is because we have a logic error. Our `if` statement is
    not accounting for the `km` equal to `2`. It is only checking that the distance
    is greater than `2`. It is a simple fix. Replace the `>` with `>=` and now the
    program will give the results that we expect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This simple program made it easy to debug the logic error, but these types of
    errors in a larger program may not be as easy to spot.
  prefs: []
  type: TYPE_NORMAL
- en: We will mainly be focusing on the runtime errors in this chapter. It is good
    to understand the various types of errors that you as a programmer could encounter.
  prefs: []
  type: TYPE_NORMAL
- en: Error Handling Using Other Programming Languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: New programmers to Go who have a background in other programming languages will
    initially find Go's methodology for dealing with errors a bit odd. Go does not
    handle errors in the same fashion as other languages, such as Java, Python, C#,
    and Ruby. Those languages perform exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippets are some examples of how other languages handle
    errors by performing exception handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Typically, exceptions, if not handled, will crash your application. In most
    cases, exception handling tends to be implicit checking versus Go's explicit checking
    for errors returned by its functions. In the exception handling paradigm, anything
    can fail, and you must account for that. Each function can throw an exception,
    but you do not know what that exception could be.
  prefs: []
  type: TYPE_NORMAL
- en: In the error handling paradigm that Go uses, it is obvious when the programmer
    did not handle the error, because the function returns the error code, and you
    can see that they did not check for the error. We will be looking at the specifics
    of checking for the error code later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most programming languages follow a similar pattern to the one shown in the
    previous code snippet. It is usually some sort of `try..catch..finally` block.
    One point of contention with the `try..catch..finally` block is that the control
    flow of the program execution gets interrupted and can follow a different path.
    This can sometimes lead to a number of logic errors and difficulty in the readability
    of the code. Here is a quick peek at how Go handles errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is a very simple syntax for handling the error. We
    will see this in much greater detail in the following topics. In this topic, we
    want to introduce you to the simplicity of how Go handles errors compared to the
    syntax of other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Error Interface Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is an error in Go? An error in Go is a value. Here is a quote from Rob
    Pike, one of the pioneers of Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '"*Values can be programmed, and since errors are values, errors can be programmed.
    Errors are not like exceptions. There''s nothing special about them, whereas an
    unhandled exception can crash your program.*"'
  prefs: []
  type: TYPE_NORMAL
- en: Since errors are values, they can be passed into a function, returned from a
    function, and evaluated just like any other value in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'An error in Go is anything that implements the error interface. We need to
    look at some fundamental aspects that make up the error type in Go. To be an error
    type in Go, it must first satisfy the `type error interface`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The wonderful thing about Go is the simplistic design of the language features.
    This can easily be seen with the error interface. Go''s standard library uses
    the error interface. To satisfy the error interface, only two things are required:'
  prefs: []
  type: TYPE_NORMAL
- en: The method name, `Error()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Error()` method to return a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those are the two requirements. It is important to understand that an error
    type is an interface type. Any value that is an error can be described as a string.
    When performing error handling in Go, the functions will return an error value.
    The Go language uses this throughout the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following code snippet for a starting discussion point on errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We will not go into every detail of the function but focus on the error portion
    of the code. In *Chapter 5*, *Functions*, we stated that functions can return
    multiple values. This is a powerful feature that most languages do not have. It
    is powerful, especially when dealing with error values. The `strconv.Atoi()` function
    returns an `int` and an error, as seen in the example stated previously. It is
    a function that is in the Go standard library ([https://packt.live/2YvL1BV](https://packt.live/2YvL1BV)).
    For functions that return error values, it should be the last return value.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is Go idiomatic to evaluate the error value for functions or methods that
    return an error. It is generally bad practice to not handle an error that is returned
    from the function. An error when returned and ignored can lead to lots of wasted
    debugging efforts. It can also cause unforeseen consequences in your program.
    If the value is not nil, then we have an error and must decide how we want to
    handle it. Depending on the scenario, we might want to:'
  prefs: []
  type: TYPE_NORMAL
- en: Return the error to the caller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log the error and continue execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stop the execution of the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ignore it (this is highly not recommended)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Panic (only in very rare conditions, we will discuss this further later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value of error is nil, that means there is no error. No further steps
    are necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look further into the standard package regarding the error type. We will
    start by looking at each piece of code in the [https://packt.live/2rk6r8Z](https://packt.live/2rk6r8Z)
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `struct` `errorString` is in the `errors` package. The struct is used to
    store the string version of the error. The `errorString` has a single field of
    `s` that is of the `string` type. The `errorString` and the field are unexportable.
    This means that we can''t access the `errorString` type or its field, `s`, directly.
    The following code gives an example of trying to access an unexported `errorString`
    type and its field, `s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 6.2: Expected output for unexported field'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_06_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.2: Expected output for unexported field'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the surface, it appears that `errorString` is neither accessible nor useful
    but we should keep digging. We are still in the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `errorString` type has a method that implements the error interface. It
    satisfies requirements, a method called `Error()`, and it returns a string. The
    error interface has been satisfied. We now have access to the `errorString` field,
    `s`, through the `Error()` method. This is how an error gets returned within the
    standard library.
  prefs: []
  type: TYPE_NORMAL
- en: You should now have a basic understanding of what an error is in Go. Now, we
    should look at how to create our own error types in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Error Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the standard library, the package error has a method that we can use to
    create our own errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It is important to understand that the `New` function takes a string as an argument
    and converts it to `*errors.errorString` and returns as an error value. The underlying
    value of the error type that gets returned is of the `*errors.errorSting` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can prove this by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example from Go''s standard library, `http`, that uses the `errors`
    package to create package-level variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When creating your own errors, it is idiomatic in Go to start with the `Err`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.03: Creating an Application to Calculate Pay for the Week'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we are going to create a function that calculates pay for
    the week. This function will accept two arguments, the hours worked during the
    week and the hourly rate. The function is going to check whether the two parameters
    meet the criteria for being valid. The function will need to calculate regular
    pay, which is hours less than or equal to 40, and overtime pay, which is hours
    greater than 40 for the week.
  prefs: []
  type: TYPE_NORMAL
- en: We will create two error values using `errors.New()`. The one error value will
    be used when there is an invalid hourly rate. An invalid hourly rate in our app
    is an hourly rate that is less than 10 or greater than 75\. The second error value
    will be when hours per week are not between 0 and 80.
  prefs: []
  type: TYPE_NORMAL
- en: Use the IDE of your choice. One option would be Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called *Exercise6.03* inside your `$GOPATH`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save a file called `main.go` inside the directory created in *step 1*. The `main.go`
    file will be in `package main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the two Go standard libraries, `errors` and `fmt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we have declared our error variables using `errors.New()`. We use idiomatic
    Go for the variable name, starting it with `Err` and camel casing. Our error string
    is in lowercase with no punctuation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main` function, we will be calling our `payday()` function three
    times. We declared our error variables using `errors.New()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `main()` function, check each `err` after the function. If `err` is not
    nil, this means there is an error, and we will print that error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `payDay` function to accept two arguments (`hoursWorked` and `hourlyRate`).
    The function will return an `int` and an error:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will use an `if` statement to check whether the hourly rate is less than
    10 or greater than 75\. If `hourlyRate` meets those conditions, we will return
    a `0` and our custom error, `ErrHourlyRate`. If `hourlyRate` does not meet those
    conditions, then the returned value will be `return hoursWorked * hourlyRate,
    nil`. We return `nil` for the error because there was no error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In *step 7*, we validated `hourlyRate`. Now we will need to validate `hoursWorked`.
    We will add another `if` statement to the `payDay()` function that will check
    whether `hoursWorked` is less than `0` or greater than `80`. If the `hoursWorked`
    matches that condition, we will return `0` and the error, `ErrHoursWorked`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the previous two steps, we added `if` statements to validate the arguments
    being passed to the function. In this step, we will add another `if` statement
    to calculate overtime pay. Overtime pay is hours greater than `40`. The hours
    over `40` are double the `hourlyRate`. The hours less than or equal to `40` are
    at the `hourlyRate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, we will call the `payDay()` function three times
    with various arguments. We will check the error after each call and print the
    error message if applicable. If there is no error, then we print the pay for the
    week:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the command line, navigate to the directory created in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the command line, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `go build` command will compile your program and create an executable named
    after the directory you created in *step 1*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Type the name of the file created in *step 12* and hit *Enter* to run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we saw how to create custom error messages that can be used
    to easily determine why the data was considered invalid. We also showed how to
    return multiple values from a function and to check for errors from the function.
    In the next topic, we will look at how to use panic in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Panic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Several languages use exceptions for handling errors. However, Go does not use
    exceptions, it uses something called panic. Panic is a built-in function that
    causes the program to crash. It stops the normal execution of the Goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, panic is not the norm, unlike other languages where an exception is a
    norm. A panic signal indicates something abnormal that is occurring within your
    code. Usually, when panic is initiated by runtime or the developer, it is to protect
    the integrity of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Errors and panics differ in their purposes and how they are handled by the Go
    runtime. An error in Go indicates that something unexpected occurred, but it will
    not adversely impact the integrity of the program. Go expects that the developer
    will handle the error properly. The function or other programs will not typically
    crash if you do not handle the error. However, panics differ in this regard. When
    panic occurs, it will ultimately crash the system unless there are handlers to
    handle the panic. If there are no handlers for the panic, it will go all the way
    up the stack and crash the program.
  prefs: []
  type: TYPE_NORMAL
- en: One example that we will look at later in this chapter is where panic occurs
    due to an index being out of range. This is typical when trying to access the
    index of a collection that doesn't exist. If Go did not panic in this case, it
    could have an adverse impact on the integrity of the program, such as other parts
    of the program trying to store or retrieve data that is not there in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Review the topic of Goroutines. The `main()` function is a Goroutine. When panic
    occurs, you will see references to "Goroutine running" in the error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Panics can be initiated by the developer and can be caused during the execution
    of a program by runtime errors. A `panic()` function accepts an empty interface.
    For now, suffice to say, this means it can accept anything as an argument. However,
    in most cases, you should pass an error type to the `panic()` function. It is
    more intuitive to the user of our function to have some details on what caused
    the panic. Passing an error to the panic function is also idiomatic in Go. We
    will also see how recovering from a panic that has an error type passed to it
    gives us some different options when dealing with panic. When panic occurs, it
    will generally follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The execution is stopped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any deferred functions in the panicking function will be called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any deferred functions in the stack of the panicking function will be called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will continue all the way up the stack until it reaches `main()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements after the panicking function will not execute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program then crashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is how panic works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: The working of panic'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_06_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.3: The working of panic'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram illustrates code in the `main` function that calls function
    `a()`. Function `a()` then calls function `b()`. Inside of function `b()`, a panic
    occurs. The `panic()` function is not handled by any of the code upstream (function
    `a()` or the `main()` function), so the program will crash the `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of a panic that occurs in Go. Try to determine why this program
    panics.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of panic is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Panic example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_06_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.4: Panic example'
  prefs: []
  type: TYPE_NORMAL
- en: The panic runtime error is a common one that you will encounter while developing.
    It is an `index out of range` error. Go generated this panic because we are trying
    to iterate over a slice more times than there are elements. Go felt that this
    is a reason to panic because it puts the program in an abnormal condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a snippet of code that demonstrates the basics of using a panic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**Code Synopsis:**'
  prefs: []
  type: TYPE_NORMAL
- en: The function panics because the argument to the function message is `"good-bye"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `panic()` function will print the error message. Having a good error message
    helps with the debugging process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the panic, we are using `errors.New()`, which we used in the previous
    topic to create an error type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, `fmt.Println()` does not get executed in the `main()` function.
    Since there are no `defer` statements, execution stops immediately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The expected output for this code snippet is:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.5: Panic example output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_06_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.5: Panic example output'
  prefs: []
  type: TYPE_NORMAL
- en: In the following code snippet, we will see how using `panic` and a `defer` statement
    functions together.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the panic example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: Panic example output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_06_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.6: Panic example output'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the code in parts:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start examining the code in the `message()` function since that is where
    the panic starts. When the panic occurs, it runs the `defer` statement within
    the panicking function, `message()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deferred function, `func f()`, runs in the `message()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going up the call stack, the next function is the `test()` function, and its
    deferred function, `n()`, will execute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we get to the `main()` function where the execution is stopped by the
    panicking function. The print statement in `main()` does not get executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You may have seen `os.Exit()` used to stop execution of the program. `os.Exit()`
    stops execution immediately and returns a status code. No deferred statements
    are run when `os.Exit()` is performed. `Panic` is preferred over `os.Exit()` in
    certain cases. Panic will run deferred functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise 6.04: Crashing the Program on Errors Using panic'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be modifying *Exercise 6.03*, *Creating an Application to Calculate
    Pay for the Week.* Consider the following scenario, where the requirements have
    changed. We no longer need to return error values from our `payDay()` function.
    It has been decided that we cannot trust the user of the program to respond properly
    to the errors. There have been complaints of incorrect paychecks. We believe this
    is due to the caller of our function ignoring the errors being returned.
  prefs: []
  type: TYPE_NORMAL
- en: The `payDay()` function will only now return the pay amount and no errors. When
    the arguments provided to the function are invalid, instead of returning an error,
    the function will panic. This will cause the program to stop immediately and,
    therefore, not process a paycheck.
  prefs: []
  type: TYPE_NORMAL
- en: Use the IDE of your choice. One option could be Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file and save it in `$GOPATH\err\panicEx\main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main` function, call the `payDay()` function, assign it to only
    one variable, `pay`, and then print it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the return type of the `payDay()` function to only return `int`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `payDay()` function, assign a variable, `report`, to an anonymous
    function. This anonymous function provides details of the arguments provided to
    the `payDay()` function. Even though we are not returning errors, this will provide
    some insight as to why the function panics. Since it is a deferred function, it
    will always execute before the function exits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The business rule for valid `hourlyRate` and `hoursWorked` stays the same as
    in the previous exercise. Instead of returning an error, we will be using the
    `panic` function. When the data is invalid, we panic and pass the argument of
    `ErrHourlyRate` or `ErrHoursWorked`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The arguments passed to the `panic()` function assist the user of our function
    in understanding the cause of the panic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When panic occurs in the `payDay()` function, the `defer` function, `report()`,
    will give the caller some insight into why the panic occurred. The panic will
    bubble up the stack to the `main()` function and execution will stop immediately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the command line, navigate to the directory created in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the command line, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `go build` command will compile your program and create an executable named
    after the directory you created in *step 1*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Type the name of the file created in *step 8* and hit *Enter* to run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output should be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.7: Panic exercise output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_06_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.7: Panic exercise output'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned how to perform `panic` and pass an error to the
    `panic()` function. This aids the user of the function in gaining a good understanding
    of the cause of the panic. In the next topic, we will see how to regain control
    of the program after a panic occurs using `Recover`.
  prefs: []
  type: TYPE_NORMAL
- en: Recover
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go provides us with the ability to regain control after `panic` has occurred.
    Recover is a function that is used to regain control of a panicking Goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The signature of the `recover()` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `recover()` function accepts no arguments and returns an empty `interface{}`.
    For now, an empty `interface{}` indicates that any type can be returned. The `recover()`
    function will return the value sent to the `panic()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `recover()` function is only useful inside a deferred function. As you may
    recall, a deferred function gets executed before the encompassing function terminates.
    Executing a call to the `recover()` function inside a deferred function stops
    the panicking by restoring normal execution. If the `recover()` function is called
    outside a deferred function, it will not stop the panicking.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the steps a program would take when using `panic()`,
    `recover()`, and a `defer()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8: Recover function flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_06_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.8: Recover function flow'
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps followed in the diagram can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` function calls `func a()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func a()` calls `func b()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside `func b()`, there is a panic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `panic()` function gets handled by a deferred function that is using the
    `recover()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deferred function is the last function to execute inside `func b()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deferred function calls the `recover()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call to `recover()` causes normal flow back to the caller, `func a()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normal flow continues, and control is finally back with the `main()` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code snippet mimics the behavior of the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '**Code Synopsis**'
  prefs: []
  type: TYPE_NORMAL
- en: The `main()` function calls function `a()`. The `a()` function calls function
    `b()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function `b()` accepts a string type and assigns it to the `msg` variable. If
    `msg` evaluates to `true` in the `if` statement, a panic will occur.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The argument for the panic is a new error created by the `errors.New()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Once the panic occurs, the next call will be to the deferred function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The deferred function uses the `recover()` function. The value of the panic
    is returned from recover; in this case, the value of `r` is an error type. Then,
    the function prints out some details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The control flow goes back to function `a()`. Function `a()` prints out some
    details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, the control goes back to the `main()` function and it prints out some
    details and terminates:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.9: Recover example output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_06_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.9: Recover example output'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.05: Recovering from a Panic'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will enhance our `payDay()` function to recover from a
    panic. When our `payDay()` function panics, we will inspect the error from that
    panic. Then, depending on the error, we will print an informative message to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Use the IDE of your choice, one option would be Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file and save it in `$GOPATH\err\panicEx\main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following code in `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `payDay()` function with various arguments and then print the return
    value of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add a `defer` function to your `payDay()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can check for the return value from the `recover()` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If `r` is not `nil`, that means a panic occurs and we should perform an action.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can evaluate `r` and see whether it equals our error values, `ErrHourlyRate`
    or `ErrHoursWorked`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If our `if` statements evaluate to `true`, we print some details about the
    data and the error values from the `recover()` function. We then print how our
    pay was calculated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The rest of the code in the `payDay()` function remains unchanged. To see a
    description of it, you can refer to *Exercise 6.04*, *Crashing the Program on
    Errors Using panic*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the command line, navigate to the directory created in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the command line, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `go build` command will compile your program and create an executable named
    after the directory you created in *step 1*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Type the name of the file created in *step 10* and hit *Enter* to run the executable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.10: Recovering from a panic exercise output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_06_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.10: Recovering from a panic exercise output'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding exercises, we have seen the progression of creating a custom
    error and returning that error. From this, we have been able to crash programs
    when needed using `panic`. In the previous exercise, we demonstrated the ability
    to recover from panics and display error messages based on the error type that
    was passed to the `panic()` function. In the following topic, we will discuss
    some basic guidelines when performing error handling in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines when working with Errors and Panic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Guidelines are just for guidance. They are not set in stone. This means, the
    majority of the time you should follow the guidelines; however, there could be
    exceptions. Some of these guidelines have been mentioned previously, but we have
    consolidated them here for quick reference:'
  prefs: []
  type: TYPE_NORMAL
- en: When declaring our own error type, the variable needs to start with `Err`. It
    should also follow the camel case naming convention.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `error` string should start with lowercase and not end with punctuation.
    One of the reasons for this guideline is that the error can be returned and concatenated
    with other information relevant to the error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a function or method returns an error, it should be evaluated. Errors not
    evaluated can cause the program to not function as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using `panic()`, pass an error type as the argument, instead of an empty
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not evaluate the string value of an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `panic()` function sparingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Activity 6.01: Creating a Custom Error Message for a Banking Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bank wants to add some custom errors when checking for last name and valid
    routing numbers. They have found that the direct deposit procedure allows invalid
    names and routing numbers to be used. The bank wants a descriptive error message
    for when these incidents occur. Our job is to create two descriptive custom error
    messages. Remember to use an idiomatic naming convention for the error variable
    and a proper structure for the error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create two error values for `InvalidLastName` and `InvalidRoutingNumber`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, print the custom message in the `main()` function to show the bank the
    error message they will receive when those errors are encountered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: By the end of this activity, you will be familiar with the steps that are needed
    to create a custom error message.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 709.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.02: Validating a Bank Customer''s Direct Deposit Submission'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The bank was pleased with the custom error messages that you created in *Activity
    6.01,* *Creating a Custom Error Message for a Banking Application*. They are so
    pleased that they now want you to implement two methods. These two methods are
    for validating the last name and the routing number:'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to create a struct called `directDeposit`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `directDeposit` struct will have three string fields: `lastName`, `firstName`,
    and `bankName`. It will also have two `int` fields called `routingNumber` and
    `accountNumber`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `directDeposit` struct will have a `validateRoutingNumber` method. The method
    will return `ErrInvalidRoutingNum` when the routing number is less than 100.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `directDeposit` struct will have a `validateLastName` method. It will return
    `ErrInvalidLastName` when the `lastName` is an empty string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `directDeposit` struct will have a method report. It will print out each
    of the fields' values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main()` function, assign values to the `directDeposit` struct's fields
    and call each of the `directDeposit` struct's methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.11: Validating a bank customer''s direct deposit submission'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_06_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.11: Validating a bank customer''s direct deposit submission'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this activity, you will have learned how to return errors from
    functions and how to check for errors returned from a function. You will also
    be able to check for a condition and, based on that condition, return your own
    custom error.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 710.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.03: Panic on Invalid Data Submission'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The bank has now decided that they would rather crash the program when an invalid
    routing number is submitted. The bank feels that the erroneous data validates
    causing the program to stop processing the direct deposit data. You need to raise
    panic on an invalid data submission instance. Build this on top of *Activity 6.02*,
    *Validating a Bank Customer''s Direct Deposit Submission*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `validateRoutingNumber` method to not return `ErrInvalidRoutingNum`,
    but instead perform a panic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.12: Panic on invalid routing number'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_06_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.12: Panic on invalid routing number'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this activity, you will be able to cause a `panic` to occur and
    see how that impacts the flow of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 713.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.04: Preventing a Panic from Crashing the App'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After some initial alpha testing, the bank no longer wants the app to crash,
    Instead, in this activity, we need to recover from the panic that was an added
    feature in *Activity 6.03*, *Panic on Invalid Data Submission*, and print the
    error that caused the panic:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `defer` function inside the `validateRoutingNumber` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an `if` statement that checks the error returned from the `recover()` function.
    If there is an error, then print the error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.13: Recover from panic on an invalid routing number'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_06_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.13: Recover from panic on an invalid routing number'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this activity, you will cause a panic, but you will be able to
    prevent it from crashing the application. You will get an understanding of how
    the `recover()` function, used in conjunction with the `defer` statement, can
    be used to prevent the application from crashing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution of this activity can be found on page 614.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at the different types of errors that you will
    encounter while programming, such as syntax, runtime, and semantic errors. We
    focused more on runtime errors. These errors are more difficult to debug.
  prefs: []
  type: TYPE_NORMAL
- en: We examined the difference between various language philosophies when it comes
    to dealing with errors. We have seen how Go's syntax for errors is simpler to
    understand compared to the exception handling that various languages are utilizing.
  prefs: []
  type: TYPE_NORMAL
- en: An error in Go is a value. Values can be passed around to functions. Any error
    can be a value as long as it implements the error interface type. We learned how
    easily we can create errors. We also learned that we should name our error values
    starting with `Err` followed by a descriptive camel case name.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discussed panics and the similarities between a panic and an exception.
    We also discovered that panics are pretty similar to exceptions; however, if panics
    are unhandled, they will cause the program to crash. However, Go has a mechanism
    that will return the control of the program back to normal. We do this by using
    the `recover()` function. The requirements for recovering from a panic requires
    the usage of the `recover()` function in a deferred function. We also learned
    the general guidelines for using `errors`, `panic`, and `recover`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at interfaces and their uses, as well as how
    they differ from how other programming languages implement interfaces. We will
    see how they can be used to solve various problems that you face as a programmer.
  prefs: []
  type: TYPE_NORMAL
