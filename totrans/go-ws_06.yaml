- en: 6\. Errors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6. 错误
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will be looking at various code snippets from the Go standard
    packages to get an understanding of Go's idiomatic way of performing error handling.
    We will also look at how to create custom error types in Go and see examples in
    the standard library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过查看Go标准包中的各种代码片段来了解Go进行错误处理的惯用方式。我们还将了解如何在Go中创建自定义错误类型，并查看标准库中的示例。
- en: By the end of this chapter, you will be able to distinguish between the different
    types of errors and compare error handling and exception handling. You will also
    be able to create error values and use `panic()` to handle errors and recover
    after a panic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够区分不同类型的错误，并比较错误处理和异常处理。你还将能够创建错误值，并使用`panic()`来处理错误，并在恐慌后恢复。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we learned about creating functions. We also discovered
    that functions can be passed as parameters and returned from a function. In this
    chapter, we will work with errors and learn how to return those from functions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了创建函数。我们还发现函数可以作为参数传递，并从函数中返回。在本章中，我们将处理错误，并学习如何从函数中返回这些错误。
- en: Developers are not perfect and, by extension, neither is the code that they
    produce. All software at some point in time has had errors. Handling errors is
    critical when you are developing software. These errors can have a negative impact
    of varying degrees on its users. The impact on the users of your software can
    be more far-reaching than you realize.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者并不完美，因此他们生产的代码也不完美。所有软件在某个时间点都会出现错误。在开发软件时处理错误至关重要。这些错误可能会对用户产生不同程度的负面影响。你的软件对用户的影响可能比你想象的要深远得多。
- en: For instance, let's consider the Northeast Blackout of 2003\. On August 14,
    there was a blackout for about 50 million people in the United States and Canada
    that lasted for 14 days. This was due to a race condition bug in the alarm system
    in a control room. Technically, a race condition bug is when two separate threads
    try to access the same memory location for a write operation. This race condition
    can cause a program to crash. In this instance, it resulted in over 250 power
    plants going offline. One way to handle a race condition is to ensure proper synchronization
    between the various threads and allow memory locations to be accessed for write
    operations by only one thread at a time. It is important that we, as developers,
    ensure proper handling of errors. If we do not handle errors properly, this can
    have a negative impact on the users of our application and their way of life,
    as seen by the power outage incident we described.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑2003年的东北停电事件。2003年8月14日，美国和加拿大约有5000万人遭遇了为期14天的停电。这是由于一个控制室警报系统中的竞态条件错误。从技术上讲，竞态条件错误是指两个独立的线程试图对同一内存位置进行写操作。这种竞态条件可能导致程序崩溃。在这个例子中，它导致了超过250个发电厂关闭。处理竞态条件的一种方法是通过确保各种线程之间的适当同步，并允许一次只有一个线程访问内存位置进行写操作。作为开发者，确保正确处理错误非常重要。如果我们没有正确处理错误，这可能会对我们的应用程序用户及其生活方式产生负面影响，正如我们所描述的停电事件所示。
- en: In this chapter, we will be looking at what an error is, what an error looks
    like in Go, and, more specifically, how to handle errors the Go way. Let's get
    started!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨错误是什么，Go中的错误看起来像什么，以及更具体地，如何以Go的方式处理错误。让我们开始吧！
- en: What Are Errors?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是错误？
- en: 'An error is something that causes your program to produce unintended results.
    Those unintended results could range from the application crashing, incorrect
    data calculation (such as a bank transaction not being processed correctly), or
    not providing any results. These unintended results are referred to as software
    bugs. Any software would contain errors during its lifetime due to numerous scenarios
    that programmers do not anticipate. The following are possible outcomes when errors
    occur:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 错误是导致你的程序产生非预期结果的东西。这些非预期结果可能包括应用程序崩溃、数据计算错误（例如银行交易未正确处理）或没有任何结果。这些非预期结果被称为软件缺陷。由于程序员没有预料到的众多场景，任何软件在其生命周期中都会包含错误。当发生错误时，以下是一些可能的后果：
- en: The erroneous code could cause the program to crash without warning.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误的代码可能导致程序在没有警告的情况下崩溃。
- en: The output of the program was not the intended result.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序的输出不是预期的结果。
- en: An error message is displayed.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示错误信息。
- en: 'There are three types of errors that you might encounter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到三种类型的错误：
- en: Syntax errors
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法错误
- en: Runtime errors
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时错误
- en: Semantic errors
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语义错误
- en: Syntax Errors
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法错误
- en: 'Syntax errors result from improper use of the programming language. This often
    occurs due to mistyping the code. Most modern IDEs will have some visual way of
    bringing syntax errors to the attention of the programmer; for example, refer
    to *Figure 6.1*. In most modern IDEs, syntax errors can be caught at an early
    stage. They may occur more frequently when you are learning a new programming
    language. A few occurrences of syntax errors could be due to the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 语法错误是由于对编程语言的不当使用而产生的。这通常是由于代码输入错误造成的。大多数现代 IDE 都会有一些视觉方式将语法错误通知程序员；例如，参考 *图
    6.1*。在大多数现代 IDE 中，语法错误可以在早期阶段被发现。当你学习一门新的编程语言时，它们可能会更频繁地发生。一些语法错误可能是由以下原因造成的：
- en: Incorrect use of syntax for a loop
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环语法使用不当
- en: Misplacing or omitting curly braces, parentheses, or brackets
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误放置或省略花括号、括号或方括号
- en: Misspelled function names or package names
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误拼写的函数名或包名
- en: Passing the wrong type of argument to a function
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将错误的参数类型传递给函数
- en: 'Here is an example of a syntax error:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个语法错误的例子：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output appears as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Go is case sensitive, so, `println` should be `Println`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是区分大小写的，所以 `println` 应该是 `Println`。
- en: Runtime Errors
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时错误
- en: These errors occur when the code is asked to perform a task that it cannot do.
    Unlike syntax errors, these are typically only found during the execution of the
    code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码被要求执行它无法完成的任务时，这些错误会发生。与语法错误不同，这些错误通常只在代码执行期间被发现。
- en: 'The following are common examples of runtime errors:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见的运行时错误示例：
- en: Opening a connection to a database that does not exist
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个不存在的数据库连接
- en: Performing a loop that is bigger than the number of elements in the slice or
    array you are iterating over
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行一个比你要迭代的切片或数组中的元素数量更大的循环
- en: Opening a file that does not exist
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开一个不存在的文件
- en: Performing a mathematical operation, such as dividing a number by zero
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行数学运算，例如将一个数除以零
- en: 'Exercise 6.01: Runtime Errors While Adding Numbers'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.01：添加数字时的运行时错误
- en: In this exercise, we are going to write a simple program that sums up a slice
    of numbers. This program will demonstrate an example of a runtime error and will
    crash when it is executed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个简单的程序，该程序将计算数字切片的总和。这个程序将演示一个运行时错误的例子，并且在执行时会崩溃。
- en: Inside `$GOPATH`, create a directory called *Exercise6.01*.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `$GOPATH` 中，创建一个名为 *Exercise6.01* 的目录。
- en: Create a file called `main.go` inside the directory created in *step 1*.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中创建的目录内创建一个名为 `main.go` 的文件。
- en: 'This program will be in `package main`. Import the `fmt` package:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个程序将在 `package main` 中。导入 `fmt` 包：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Inside the `main` function, we will have a slice of integers that will have
    four elements:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们将有一个包含四个元素的整数切片：
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will have a variable, `total`, to be used for the calculation of summing
    all the integer variables in the slice. Use a `for` loop to sum the variables:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将有一个变量 `total`，用于计算切片中所有整型变量的总和。使用 `for` 循环来累加变量：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we print the results of the total:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们打印出总的结果：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have introduced an example of a runtime error to the program; so, we will
    not get the following output:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经在程序中引入了一个运行时错误的例子；因此，我们不会得到以下输出：
- en: '[PRE6]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: At the command line, navigate to the directory created in *step 1*.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，导航到 *步骤 1* 中创建的目录。
- en: 'At the command line, type the following:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，输入以下内容：
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `go build` command will compile your program and create an executable named
    after the directory you created in *step 1*.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`go build` 命令将编译你的程序，并创建一个以你在 *步骤 1* 中创建的目录命名的可执行文件。'
- en: 'Type the name of the file created in *step 8* and hit *Enter* to run the executable:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入在 *步骤 8* 中创建的文件名，然后按 *Enter* 键运行可执行文件：
- en: '![Figure 6.1: Output after executing'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1：执行后的输出'
- en: '](img/B14177_06_01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_06_01.jpg](img/B14177_06_01.jpg)'
- en: 'Figure 6.1: Output after executing'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：执行后的输出
- en: As you can see, the program crashed. The `index out of range` panic is a common
    error to new Go developers and veterans alike.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，程序崩溃了。`index out of range` 的恐慌是新手和经验丰富的 Go 开发者都常见的错误。
- en: 'In this example, the error, a panic (we will discuss what a panic is later
    in the chapter) in this program, is the result of iterating in the `for` loop
    by a greater number, in our case 10, than the actual number of elements in the
    slice, in our case 4\. One possible solution would be to use a `for` loop with
    a range:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，错误，即程序中的 panic（我们将在本章后面讨论 panic 是什么），是由于在 `for` 循环中迭代次数多于切片中的实际元素数量，在我们的例子中是
    10 次而不是 4 次。一个可能的解决方案是使用带有范围的 `for` 循环：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this exercise, we saw how we can avoid runtime errors by paying attention
    to minute details.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何通过关注细节来避免运行时错误。
- en: Semantic Errors
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语义错误
- en: 'Syntax errors are the easiest to debug, followed by runtime errors, while logic
    errors are the hardest. Semantic errors are sometimes very hard to spot at first.
    For example, in 1998, when the Mars Climate Orbiter was launched, its purpose
    was to study the climate of Mars, but due to a logic error in the system, the
    Mars Climate Orbiter, valued at $235 million, was destroyed. After some analysis,
    it was discovered that the calculations of units on the ground controller system
    were done in imperial units and the software on the Orbiter was done in metric
    units. This is a logic error that caused the navigation system to incorrectly
    calculate its maneuvers in space. As you can see, these are defects in the way
    the code is processing elements of your program. Reasons for semantic errors to
    occur could be because of:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 语法错误是最容易调试的，其次是运行时错误，而逻辑错误是最难调试的。语义错误有时一开始很难发现。例如，1998 年，当火星气候轨道器发射时，其目的是研究火星气候，但由于系统中的逻辑错误，价值
    2.35 亿美元的火星气候轨道器被摧毁。经过一些分析，发现地面控制器系统中的单位计算使用了英制单位，而轨道器上的软件使用了公制单位。这是一个导致导航系统在太空中错误计算其机动动作的逻辑错误。正如你所看到的，这些都是代码处理程序元素的方式中的缺陷。语义错误发生的原因可能包括：
- en: Incorrect computations
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算错误
- en: Accessing incorrect resources (files, databases, servers, variables, and so
    on)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问不正确的资源（文件、数据库、服务器、变量等）
- en: Incorrect setting of variables for negation (not equal versus equal)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量取反设置不正确（不等号与等号）
- en: 'Exercise 6.02: Logic Error with Walking Distance'
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.02：步行距离逻辑错误
- en: We are writing an application that will determine whether we should walk to
    our destination or take a car. If our destination is greater than or equal to
    2 km, we are going to take a car. If it is less than 2 km, then we will walk to
    our destination. We are going to demonstrate a semantic error with this program.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在编写一个应用程序，该程序将确定我们是应该步行去目的地还是开车。如果我们的目的地距离大于或等于 2 公里，我们将开车去。如果小于 2 公里，我们将步行到目的地。我们将通过这个程序演示一个语义错误。
- en: 'The expected output of this exercise is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的预期输出如下：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Create a directory called *Exercise6.02* inside your `$GOPATH`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `$GOPATH` 中创建一个名为 *Exercise6.02* 的目录。
- en: Save a file called `main.go` inside the directory created in *step 1*. This
    program will be inside `package main`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中创建的目录内保存一个名为 `main.go` 的文件。此程序将位于 `package main` 中。
- en: 'Import the `fmt` package:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `fmt` 包：
- en: '[PRE10]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside of the `main` function, display a message to take the car when `km`
    is greater than 2, and when `km` is less than 2, to send a message for walking:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数内部，当 `km` 大于 2 时显示一条开车信息，当 `km` 小于 2 时发送一条步行信息：
- en: '[PRE11]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At the command line, navigate to the directory created in *step 1*.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，导航到 *步骤 1* 中创建的目录。
- en: 'At the command line, type the following:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，输入以下内容：
- en: '[PRE12]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `go build` command will compile your program and create an executable named
    after the directory you created in *step 1*.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`go build` 命令将编译你的程序并创建一个以你在 *步骤 1* 中创建的目录命名的可执行文件。'
- en: 'Type the name of the file created in *step 6* and hit *Enter* to run the executable.
    You will get the following output:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 *步骤 6* 中创建的文件名并按 *Enter* 键运行可执行文件。你将得到以下输出：
- en: '[PRE13]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The program runs with no errors, but the message displayed is not what was expected.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 程序运行没有错误，但显示的消息并不是预期的。
- en: As previously stated, the program runs with no errors, but the results are not
    what we expected. This is because we have a logic error. Our `if` statement is
    not accounting for the `km` equal to `2`. It is only checking that the distance
    is greater than `2`. It is a simple fix. Replace the `>` with `>=` and now the
    program will give the results that we expect.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，程序在没有错误的情况下运行，但结果并不是我们预期的。这是因为我们有一个逻辑错误。我们的`if`语句没有考虑到`km`等于`2`的情况。它只是检查距离是否大于`2`。这是一个简单的修复。将`>`替换为`>=`，现在程序将给出我们预期的结果。
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This simple program made it easy to debug the logic error, but these types of
    errors in a larger program may not be as easy to spot.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的程序使调试逻辑错误变得容易，但在更大的程序中，这类错误可能并不容易发现。
- en: We will mainly be focusing on the runtime errors in this chapter. It is good
    to understand the various types of errors that you as a programmer could encounter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将主要关注运行时错误。了解作为程序员可能会遇到的错误类型是很有好处的。
- en: Error Handling Using Other Programming Languages
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用其他编程语言进行错误处理
- en: New programmers to Go who have a background in other programming languages will
    initially find Go's methodology for dealing with errors a bit odd. Go does not
    handle errors in the same fashion as other languages, such as Java, Python, C#,
    and Ruby. Those languages perform exception handling.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有其他编程语言背景的新Go程序员来说，最初可能会觉得Go处理错误的方法有些奇怪。Go处理错误的方式与其他语言，如Java、Python、C#和Ruby不同。那些语言执行异常处理。
- en: 'The following code snippets are some examples of how other languages handle
    errors by performing exception handling:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是其他语言通过执行异常处理来处理错误的示例：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Typically, exceptions, if not handled, will crash your application. In most
    cases, exception handling tends to be implicit checking versus Go's explicit checking
    for errors returned by its functions. In the exception handling paradigm, anything
    can fail, and you must account for that. Each function can throw an exception,
    but you do not know what that exception could be.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果未处理异常，它将导致应用程序崩溃。在大多数情况下，异常处理倾向于隐式检查，而Go则显式检查其函数返回的错误。在异常处理范例中，任何东西都可能失败，你必须考虑到这一点。每个函数都可能抛出异常，但你不知道那个异常会是什么。
- en: In the error handling paradigm that Go uses, it is obvious when the programmer
    did not handle the error, because the function returns the error code, and you
    can see that they did not check for the error. We will be looking at the specifics
    of checking for the error code later in the chapter.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go使用的错误处理范例中，当程序员没有处理错误时，这是显而易见的，因为函数返回错误代码，你可以看到他们没有检查错误。我们将在本章后面讨论检查错误代码的细节。
- en: 'Most programming languages follow a similar pattern to the one shown in the
    previous code snippet. It is usually some sort of `try..catch..finally` block.
    One point of contention with the `try..catch..finally` block is that the control
    flow of the program execution gets interrupted and can follow a different path.
    This can sometimes lead to a number of logic errors and difficulty in the readability
    of the code. Here is a quick peek at how Go handles errors:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言遵循与前面代码片段中所示类似的模式。通常是一些`try..catch..finally`块。与`try..catch..finally`块的一个争议点是程序执行的流程控制被中断，可能会遵循不同的路径。这有时会导致许多逻辑错误，并使代码的可读性变得困难。以下是如何快速查看Go处理错误的示例：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code snippet is a very simple syntax for handling the error. We
    will see this in much greater detail in the following topics. In this topic, we
    want to introduce you to the simplicity of how Go handles errors compared to the
    syntax of other languages.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段是处理错误的一个非常简单的语法。我们将在后续主题中更详细地探讨这一点。在本主题中，我们希望向您介绍Go如何以简洁的方式处理错误，与其他语言的语法相比。
- en: Error Interface Type
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误接口类型
- en: 'What is an error in Go? An error in Go is a value. Here is a quote from Rob
    Pike, one of the pioneers of Go:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的错误是什么？Go中的错误是一个值。以下是Go的先驱之一Rob Pike的引用：
- en: '"*Values can be programmed, and since errors are values, errors can be programmed.
    Errors are not like exceptions. There''s nothing special about them, whereas an
    unhandled exception can crash your program.*"'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: “值可以被编程，由于错误是值，错误也可以被编程。错误不像异常那样特殊。它们没有什么特别之处，而未处理的异常可能会使你的程序崩溃。”
- en: Since errors are values, they can be passed into a function, returned from a
    function, and evaluated just like any other value in Go.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于错误是值，它们可以被传递到函数中，从函数中返回，并且就像Go中的任何其他值一样进行评估。
- en: 'An error in Go is anything that implements the error interface. We need to
    look at some fundamental aspects that make up the error type in Go. To be an error
    type in Go, it must first satisfy the `type error interface`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的错误是任何实现了错误接口的东西。我们需要查看构成Go中错误类型的根本方面。要成为Go中的错误类型，它必须首先满足`type error interface`：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The wonderful thing about Go is the simplistic design of the language features.
    This can easily be seen with the error interface. Go''s standard library uses
    the error interface. To satisfy the error interface, only two things are required:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言最奇妙的地方在于其语言特性的简单设计。这一点可以通过错误接口轻易地看出。Go的标准库使用了错误接口。为了满足错误接口，只需要两件事：
- en: The method name, `Error()`
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名，`Error()`
- en: The `Error()` method to return a string
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Error()`方法返回一个字符串'
- en: Those are the two requirements. It is important to understand that an error
    type is an interface type. Any value that is an error can be described as a string.
    When performing error handling in Go, the functions will return an error value.
    The Go language uses this throughout the standard library.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是两个要求。重要的是要理解错误类型是一个接口类型。任何错误值都可以描述为一个字符串。在Go中进行错误处理时，函数将返回一个错误值。Go语言在整个标准库中都使用这一点。
- en: 'Look at the following code snippet for a starting discussion point on errors:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下代码片段，以作为错误讨论的起点：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will not go into every detail of the function but focus on the error portion
    of the code. In *Chapter 5*, *Functions*, we stated that functions can return
    multiple values. This is a powerful feature that most languages do not have. It
    is powerful, especially when dealing with error values. The `strconv.Atoi()` function
    returns an `int` and an error, as seen in the example stated previously. It is
    a function that is in the Go standard library ([https://packt.live/2YvL1BV](https://packt.live/2YvL1BV)).
    For functions that return error values, it should be the last return value.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入每个函数的细节，但会关注代码中的错误部分。在*第五章* *函数*中，我们提到函数可以返回多个值。这是一个大多数语言都没有的强大功能。它特别强大，尤其是在处理错误值时。`strconv.Atoi()`函数返回一个`int`和一个错误，正如之前提到的示例所示。它是一个位于Go标准库中的函数（[https://packt.live/2YvL1BV](https://packt.live/2YvL1BV)）。对于返回错误值的函数，它应该是最后一个返回值。
- en: 'It is Go idiomatic to evaluate the error value for functions or methods that
    return an error. It is generally bad practice to not handle an error that is returned
    from the function. An error when returned and ignored can lead to lots of wasted
    debugging efforts. It can also cause unforeseen consequences in your program.
    If the value is not nil, then we have an error and must decide how we want to
    handle it. Depending on the scenario, we might want to:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，评估返回错误值的函数或方法是一种习惯。通常，不处理从函数返回的错误是一种坏习惯。返回并忽略错误可能导致大量的调试工作浪费。它也可能导致程序中出现未预见的后果。如果值不是nil，那么我们有一个错误，必须决定我们想要如何处理它。根据场景，我们可能想要：
- en: Return the error to the caller
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将错误返回给调用者
- en: Log the error and continue execution
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录错误并继续执行
- en: Stop the execution of the program
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止程序的执行
- en: Ignore it (this is highly not recommended)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略它（这强烈不推荐）
- en: Panic (only in very rare conditions, we will discuss this further later)
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Panic（仅在非常罕见的情况下，我们将在稍后进一步讨论）
- en: If the value of error is nil, that means there is no error. No further steps
    are necessary.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错误的值为nil，这意味着没有错误。不需要进一步的操作。
- en: Let's look further into the standard package regarding the error type. We will
    start by looking at each piece of code in the [https://packt.live/2rk6r8Z](https://packt.live/2rk6r8Z)
    file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨标准包中关于错误类型的内容。我们将从查看[https://packt.live/2rk6r8Z](https://packt.live/2rk6r8Z)文件中的每一行代码开始。
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `struct` `errorString` is in the `errors` package. The struct is used to
    store the string version of the error. The `errorString` has a single field of
    `s` that is of the `string` type. The `errorString` and the field are unexportable.
    This means that we can''t access the `errorString` type or its field, `s`, directly.
    The following code gives an example of trying to access an unexported `errorString`
    type and its field, `s`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct` `errorString`位于`errors`包中。该结构用于存储错误的字符串版本。`errorString`有一个名为`s`的单个字段，其类型为`string`。`errorString`及其字段`s`是不可导出的。这意味着我们无法直接访问`errorString`类型或其字段`s`。以下代码给出了尝试访问不可导出的`errorString`类型及其字段`s`的示例：'
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![Figure 6.2: Expected output for unexported field'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 6.2: 未导出字段的预期输出]'
- en: '](img/B14177_06_02.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_06_02.jpg]'
- en: 'Figure 6.2: Expected output for unexported field'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 6.2: 未导出字段的预期输出'
- en: 'On the surface, it appears that `errorString` is neither accessible nor useful
    but we should keep digging. We are still in the standard library:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，`errorString` 似乎既不可访问也不实用，但我们应该继续挖掘。我们仍然在标准库中：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `errorString` type has a method that implements the error interface. It
    satisfies requirements, a method called `Error()`, and it returns a string. The
    error interface has been satisfied. We now have access to the `errorString` field,
    `s`, through the `Error()` method. This is how an error gets returned within the
    standard library.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`errorString` 类型有一个实现错误接口的方法。它满足了一个名为 `Error()` 的方法，并返回一个字符串。错误接口已被满足。我们现在可以通过
    `Error()` 方法访问 `errorString` 字段，`s`。这是在标准库中返回错误的方式。'
- en: You should now have a basic understanding of what an error is in Go. Now, we
    should look at how to create our own error types in Go.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该对 Go 中的错误有一个基本的理解。现在，我们应该看看如何在 Go 中创建我们自己的错误类型。
- en: Creating Error Values
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建错误值
- en: 'In the standard library, the package error has a method that we can use to
    create our own errors:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库中，`error` 包有一个我们可以用来创建自定义错误的方法：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is important to understand that the `New` function takes a string as an argument
    and converts it to `*errors.errorString` and returns as an error value. The underlying
    value of the error type that gets returned is of the `*errors.errorSting` type.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，`New` 函数接受一个字符串作为参数，并将其转换为 `*errors.errorString`，然后作为错误值返回。返回的错误类型的底层值是
    `*errors.errorSting` 类型。
- en: 'We can prove this by running the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下代码来证明这一点：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is an example from Go''s standard library, `http`, that uses the `errors`
    package to create package-level variables:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个来自 Go 标准库 `http` 的示例，它使用 `errors` 包创建包级变量：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When creating your own errors, it is idiomatic in Go to start with the `Err`
    variable.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自定义错误时，在 Go 中以 `Err` 变量开头是惯用的。
- en: 'Exercise 6.03: Creating an Application to Calculate Pay for the Week'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.03：创建一个计算每周工资的应用程序
- en: In this exercise, we are going to create a function that calculates pay for
    the week. This function will accept two arguments, the hours worked during the
    week and the hourly rate. The function is going to check whether the two parameters
    meet the criteria for being valid. The function will need to calculate regular
    pay, which is hours less than or equal to 40, and overtime pay, which is hours
    greater than 40 for the week.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个计算每周工资的函数。这个函数将接受两个参数，即一周内的工作小时数和时薪。该函数将检查这两个参数是否符合有效性的标准。该函数需要计算正常工资，即一周内的小时数小于或等于40，以及加班工资，即一周内的小时数大于40。
- en: We will create two error values using `errors.New()`. The one error value will
    be used when there is an invalid hourly rate. An invalid hourly rate in our app
    is an hourly rate that is less than 10 or greater than 75\. The second error value
    will be when hours per week are not between 0 and 80.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `errors.New()` 创建两个错误值。一个错误值将在时薪无效时使用。在我们的应用程序中，无效的时薪是指小于10或大于75的时薪。第二个错误值将在每周的小时数不在0到80之间时使用。
- en: Use the IDE of your choice. One option would be Visual Studio Code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您选择的 IDE。一个选项是 Visual Studio Code。
- en: Create a directory called *Exercise6.03* inside your `$GOPATH`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `$GOPATH` 内创建一个名为 *Exercise6.03* 的目录。
- en: Save a file called `main.go` inside the directory created in *step 1*. The `main.go`
    file will be in `package main`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 *步骤1* 创建的目录中保存一个名为 `main.go` 的文件。`main.go` 文件将在 `package main` 中。
- en: 'Import the two Go standard libraries, `errors` and `fmt`:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入两个 Go 标准库，`errors` 和 `fmt`：
- en: '[PRE25]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we have declared our error variables using `errors.New()`. We use idiomatic
    Go for the variable name, starting it with `Err` and camel casing. Our error string
    is in lowercase with no punctuation:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经使用 `errors.New()` 声明了我们的错误变量。我们使用惯用的 Go 变量命名，以 `Err` 开头并使用驼峰式命名。我们的错误字符串为小写，不带标点符号：
- en: '[PRE26]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Inside the `main` function, we will be calling our `payday()` function three
    times. We declared our error variables using `errors.New()`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数中，我们将调用我们的 `payday()` 函数三次。我们使用 `errors.New()` 声明了我们的错误变量：
- en: '[PRE27]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the `main()` function, check each `err` after the function. If `err` is not
    nil, this means there is an error, and we will print that error.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，检查函数后的每个 `err`。如果 `err` 不是 `nil`，这意味着存在一个错误，我们将打印出该错误。
- en: 'Create the `payDay` function to accept two arguments (`hoursWorked` and `hourlyRate`).
    The function will return an `int` and an error:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个接受两个参数（`hoursWorked` 和 `hourlyRate`）的 `payDay` 函数。该函数将返回一个 `int` 和一个错误：
- en: '[PRE28]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will use an `if` statement to check whether the hourly rate is less than
    10 or greater than 75\. If `hourlyRate` meets those conditions, we will return
    a `0` and our custom error, `ErrHourlyRate`. If `hourlyRate` does not meet those
    conditions, then the returned value will be `return hoursWorked * hourlyRate,
    nil`. We return `nil` for the error because there was no error:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `if` 语句检查时薪是否小于 10 或大于 75。如果 `hourlyRate` 满足这些条件，我们将返回 `0` 和我们的自定义错误 `ErrHourlyRate`。如果
    `hourlyRate` 不满足这些条件，则返回的值将是 `return hoursWorked * hourlyRate, nil`。我们返回 `nil`
    作为错误，因为没有错误发生：
- en: '[PRE29]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In *step 7*, we validated `hourlyRate`. Now we will need to validate `hoursWorked`.
    We will add another `if` statement to the `payDay()` function that will check
    whether `hoursWorked` is less than `0` or greater than `80`. If the `hoursWorked`
    matches that condition, we will return `0` and the error, `ErrHoursWorked`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*步骤 7*中，我们验证了 `hourlyRate`。现在我们需要验证 `hoursWorked`。我们将在 `payDay()` 函数中添加另一个
    `if` 语句，该语句将检查 `hoursWorked` 是否小于 `0` 或大于 `80`。如果 `hoursWorked` 符合该条件，我们将返回 `0`
    和错误 `ErrHoursWorked`：
- en: '[PRE30]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the previous two steps, we added `if` statements to validate the arguments
    being passed to the function. In this step, we will add another `if` statement
    to calculate overtime pay. Overtime pay is hours greater than `40`. The hours
    over `40` are double the `hourlyRate`. The hours less than or equal to `40` are
    at the `hourlyRate`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前两个步骤中，我们添加了 `if` 语句来验证传递给函数的参数。在这个步骤中，我们将添加另一个 `if` 语句来计算加班费。加班费是超过 `40` 小时的工时。超过
    `40` 小时的工时是时薪的两倍。不超过 `40` 小时的工时按时薪计算：
- en: '[PRE31]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the `main()` function, we will call the `payDay()` function three times
    with various arguments. We will check the error after each call and print the
    error message if applicable. If there is no error, then we print the pay for the
    week:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们将用不同的参数三次调用 `payDay()` 函数。我们将在每次调用后检查错误，并在适用的情况下打印错误信息。如果没有错误，则打印一周的工资：
- en: '[PRE32]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the command line, navigate to the directory created in *step 1*.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，导航到在*步骤 1*中创建的目录。
- en: 'In the command line, type the following:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，输入以下内容：
- en: '[PRE33]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `go build` command will compile your program and create an executable named
    after the directory you created in *step 1*.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`go build` 命令会编译你的程序并创建一个以你在*步骤 1*中创建的目录命名的可执行文件。'
- en: Type the name of the file created in *step 12* and hit *Enter* to run the executable.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入在*步骤 12*中创建的文件名，然后按 *Enter* 运行可执行文件。
- en: 'The expected output is as follows:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '[PRE34]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this exercise, we saw how to create custom error messages that can be used
    to easily determine why the data was considered invalid. We also showed how to
    return multiple values from a function and to check for errors from the function.
    In the next topic, we will look at how to use panic in our applications.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们展示了如何创建自定义错误消息，以便可以轻松确定数据被认为无效的原因。我们还展示了如何从函数中返回多个值以及如何检查函数的错误。在下一个主题中，我们将探讨如何在我们的应用程序中使用
    panic。
- en: Panic
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Panic
- en: Several languages use exceptions for handling errors. However, Go does not use
    exceptions, it uses something called panic. Panic is a built-in function that
    causes the program to crash. It stops the normal execution of the Goroutine.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 几种语言使用异常来处理错误。然而，Go 不使用异常，它使用一种称为 panic 的机制。Panic 是一个内置函数，会导致程序崩溃。它停止 Goroutine
    的正常执行。
- en: In Go, panic is not the norm, unlike other languages where an exception is a
    norm. A panic signal indicates something abnormal that is occurring within your
    code. Usually, when panic is initiated by runtime or the developer, it is to protect
    the integrity of the program.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，panic 不是常态，与在其他语言中异常是常态不同。panic 信号表示代码内部正在发生异常情况。通常，当 panic 由运行时或开发者启动时，是为了保护程序的完整性。
- en: Errors and panics differ in their purposes and how they are handled by the Go
    runtime. An error in Go indicates that something unexpected occurred, but it will
    not adversely impact the integrity of the program. Go expects that the developer
    will handle the error properly. The function or other programs will not typically
    crash if you do not handle the error. However, panics differ in this regard. When
    panic occurs, it will ultimately crash the system unless there are handlers to
    handle the panic. If there are no handlers for the panic, it will go all the way
    up the stack and crash the program.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 错误和恐慌在目的和Go运行时如何处理它们方面有所不同。Go中的错误表示发生了意外情况，但它不会对程序的完整性产生不利影响。Go期望开发者正确处理错误。如果你没有处理错误，函数或其它程序通常不会崩溃。然而，恐慌在这方面有所不同。当发生恐慌时，除非有处理程序，否则它最终会崩溃系统。如果没有处理程序，它将一直向上传递到栈顶并崩溃程序。
- en: One example that we will look at later in this chapter is where panic occurs
    due to an index being out of range. This is typical when trying to access the
    index of a collection that doesn't exist. If Go did not panic in this case, it
    could have an adverse impact on the integrity of the program, such as other parts
    of the program trying to store or retrieve data that is not there in the collection.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论的一个例子是，由于索引超出范围而发生的恐慌。这在尝试访问不存在的集合的索引时很典型。如果Go在这种情况下不发生恐慌，可能会对程序的完整性产生不利影响，例如，程序的其它部分尝试存储或检索集合中不存在的数据。
- en: Note
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Review the topic of Goroutines. The `main()` function is a Goroutine. When panic
    occurs, you will see references to "Goroutine running" in the error message.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾Goroutines的相关内容。`main()`函数是一个Goroutine。当发生恐慌时，你将在错误信息中看到“正在运行的Goroutine”的引用。
- en: 'Panics can be initiated by the developer and can be caused during the execution
    of a program by runtime errors. A `panic()` function accepts an empty interface.
    For now, suffice to say, this means it can accept anything as an argument. However,
    in most cases, you should pass an error type to the `panic()` function. It is
    more intuitive to the user of our function to have some details on what caused
    the panic. Passing an error to the panic function is also idiomatic in Go. We
    will also see how recovering from a panic that has an error type passed to it
    gives us some different options when dealing with panic. When panic occurs, it
    will generally follow these steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 恐慌可以被开发者引发，也可以在程序执行过程中由运行时错误引起。`panic()`函数接受一个空接口。目前，只需知道这意味着它可以接受任何类型的参数。然而，在大多数情况下，你应该将错误类型传递给`panic()`函数。对于我们的函数用户来说，了解导致恐慌的详细信息会更加直观。在Go中，将错误传递给panic函数也是一种惯例。我们还将看到如何从传递了错误类型的panic中恢复，这为我们处理panic提供了不同的选项。当发生恐慌时，它通常遵循以下步骤：
- en: The execution is stopped
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行被停止
- en: Any deferred functions in the panicking function will be called
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在恐慌函数中的任何延迟函数都将被调用
- en: Any deferred functions in the stack of the panicking function will be called
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在恐慌函数的调用栈中的任何延迟函数都将被调用
- en: It will continue all the way up the stack until it reaches `main()`
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会一直向上传递到`main()`函数
- en: Statements after the panicking function will not execute
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在恐慌函数之后的语句将不会执行
- en: The program then crashes
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序随后崩溃
- en: 'Here is how panic works:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是恐慌的工作原理：
- en: '![Figure 6.3: The working of panic'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3：恐慌的工作原理'
- en: '](img/B14177_06_03.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_06_03.jpg)'
- en: 'Figure 6.3: The working of panic'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：恐慌的工作原理
- en: The preceding diagram illustrates code in the `main` function that calls function
    `a()`. Function `a()` then calls function `b()`. Inside of function `b()`, a panic
    occurs. The `panic()` function is not handled by any of the code upstream (function
    `a()` or the `main()` function), so the program will crash the `main()` function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图展示了`main`函数中调用函数`a()`的代码。函数`a()`随后调用函数`b()`。在函数`b()`内部发生恐慌。`panic()`函数没有被上游的任何代码（函数`a()`或`main()`函数）处理，因此程序将崩溃`main()`函数。
- en: Here is an example of a panic that occurs in Go. Try to determine why this program
    panics.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个Go中发生恐慌的例子。尝试确定这个程序为什么会发生恐慌。
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'An example of panic is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 恐慌的一个例子如下：
- en: '![Figure 6.4: Panic example'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4：恐慌示例'
- en: '](img/B14177_06_04.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_06_04.jpg)'
- en: 'Figure 6.4: Panic example'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：恐慌示例
- en: The panic runtime error is a common one that you will encounter while developing.
    It is an `index out of range` error. Go generated this panic because we are trying
    to iterate over a slice more times than there are elements. Go felt that this
    is a reason to panic because it puts the program in an abnormal condition.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 潜在运行时错误是在开发过程中常见的一种错误。这是一个 `索引越界` 错误。Go 生成这个恐慌是因为我们试图迭代一个比元素多的切片。Go 认为这是一个恐慌的理由，因为它使程序处于不正常的状态。
- en: 'Here is a snippet of code that demonstrates the basics of using a panic:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个演示如何使用恐慌的基本代码片段：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Code Synopsis:**'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码摘要：**'
- en: The function panics because the argument to the function message is `"good-bye"`.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数因为传递给 `message` 函数的参数是 `"good-bye"` 而发生恐慌。
- en: The `panic()` function will print the error message. Having a good error message
    helps with the debugging process.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`panic()` 函数将打印错误信息。拥有良好的错误信息有助于调试过程。'
- en: Inside the panic, we are using `errors.New()`, which we used in the previous
    topic to create an error type.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在恐慌中，我们使用了 `errors.New()`，这是我们之前在创建错误类型时使用的。
- en: As you can see, `fmt.Println()` does not get executed in the `main()` function.
    Since there are no `defer` statements, execution stops immediately.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如你所见，`fmt.Println()` 在 `main()` 函数中不会执行。由于没有 `defer` 语句，执行会立即停止。
- en: 'The expected output for this code snippet is:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码片段的预期输出是：
- en: '![Figure 6.5: Panic example output'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.5：恐慌示例输出'
- en: '](img/B14177_06_05.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_06_05.jpg)'
- en: 'Figure 6.5: Panic example output'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5：恐慌示例输出
- en: In the following code snippet, we will see how using `panic` and a `defer` statement
    functions together.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们将看到如何使用 `panic` 和 `defer` 语句一起工作。
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output of the panic example is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 潜规则示例的输出如下：
- en: '![Figure 6.6: Panic example output'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6：恐慌示例输出'
- en: '](img/B14177_06_06.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_06_06.jpg)'
- en: 'Figure 6.6: Panic example output'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：恐慌示例输出
- en: 'Let''s understand the code in parts:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分部分理解代码：
- en: We will start examining the code in the `message()` function since that is where
    the panic starts. When the panic occurs, it runs the `defer` statement within
    the panicking function, `message()`.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从 `message()` 函数中的代码开始检查，因为恐慌就是从这里开始的。当发生恐慌时，它会运行恐慌函数 `message()` 内的 `defer`
    语句。
- en: The deferred function, `func f()`, runs in the `message()` function.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟函数 `func f()` 在 `message()` 函数中运行。
- en: Going up the call stack, the next function is the `test()` function, and its
    deferred function, `n()`, will execute.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用栈向上移动，下一个函数是 `test()` 函数，它的延迟函数 `n()` 将执行。
- en: Finally, we get to the `main()` function where the execution is stopped by the
    panicking function. The print statement in `main()` does not get executed.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们到达 `main()` 函数，执行被恐慌函数停止。`main()` 中的打印语句不会执行。
- en: Note
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You may have seen `os.Exit()` used to stop execution of the program. `os.Exit()`
    stops execution immediately and returns a status code. No deferred statements
    are run when `os.Exit()` is performed. `Panic` is preferred over `os.Exit()` in
    certain cases. Panic will run deferred functions.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能见过使用 `os.Exit()` 来停止程序的执行。`os.Exit()` 会立即停止执行并返回一个状态码。当执行 `os.Exit()` 时，不会运行任何延迟语句。在某些情况下，`panic`
    比 `os.Exit()` 更受欢迎。`panic` 会运行延迟函数。
- en: 'Exercise 6.04: Crashing the Program on Errors Using panic'
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 6.04：使用 panic 在错误时崩溃程序
- en: We will be modifying *Exercise 6.03*, *Creating an Application to Calculate
    Pay for the Week.* Consider the following scenario, where the requirements have
    changed. We no longer need to return error values from our `payDay()` function.
    It has been decided that we cannot trust the user of the program to respond properly
    to the errors. There have been complaints of incorrect paychecks. We believe this
    is due to the caller of our function ignoring the errors being returned.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改 *练习 6.03*，*创建一个计算周薪的应用程序*。考虑以下场景，其中要求已经改变。我们不再需要从我们的 `payDay()` 函数返回错误值。我们已经决定不能信任程序的用户正确地响应错误。有人抱怨工资单不正确。我们认为这是由于我们的函数调用者忽略了返回的错误。
- en: The `payDay()` function will only now return the pay amount and no errors. When
    the arguments provided to the function are invalid, instead of returning an error,
    the function will panic. This will cause the program to stop immediately and,
    therefore, not process a paycheck.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`payDay()` 函数现在将只返回工资金额，而不返回错误。当提供给函数的参数无效时，而不是返回错误，函数将恐慌。这将导致程序立即停止，因此不会处理工资单。'
- en: Use the IDE of your choice. One option could be Visual Studio Code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你选择的 IDE。一个选项可以是 Visual Studio Code。
- en: Create a new file and save it in `$GOPATH\err\panicEx\main.go`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，并将其保存在`$GOPATH\err\panicEx\main.go`。
- en: 'Enter the following code in `main.go`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中输入以下代码：
- en: '[PRE38]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Inside the `main` function, call the `payDay()` function, assign it to only
    one variable, `pay`, and then print it:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数内部，调用`payDay()`函数，将其赋值给一个变量`pay`，然后打印它：
- en: '[PRE39]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Change the return type of the `payDay()` function to only return `int`:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`payDay()`函数的返回类型更改为仅返回`int`：
- en: '[PRE40]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Inside the `payDay()` function, assign a variable, `report`, to an anonymous
    function. This anonymous function provides details of the arguments provided to
    the `payDay()` function. Even though we are not returning errors, this will provide
    some insight as to why the function panics. Since it is a deferred function, it
    will always execute before the function exits:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`payDay()`函数内部，将一个变量`report`赋值给匿名函数。这个匿名函数提供了传递给`payDay()`函数的参数的详细信息。尽管我们没有返回错误，但这将提供一些关于为什么函数会引发恐慌的洞察。由于它是一个deferred函数，它将在函数退出之前始终执行：
- en: '[PRE41]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The business rule for valid `hourlyRate` and `hoursWorked` stays the same as
    in the previous exercise. Instead of returning an error, we will be using the
    `panic` function. When the data is invalid, we panic and pass the argument of
    `ErrHourlyRate` or `ErrHoursWorked`.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于有效的`hourlyRate`和`hoursWorked`的业务规则与之前的练习相同。我们将使用`panic`函数而不是返回错误。当数据无效时，我们将引发恐慌并传递`ErrHourlyRate`或`ErrHoursWorked`作为参数。
- en: The arguments passed to the `panic()` function assist the user of our function
    in understanding the cause of the panic.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 传递给`panic()`函数的参数有助于我们的函数用户理解恐慌的原因。
- en: 'When panic occurs in the `payDay()` function, the `defer` function, `report()`,
    will give the caller some insight into why the panic occurred. The panic will
    bubble up the stack to the `main()` function and execution will stop immediately:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`payDay()`函数发生恐慌时，`defer`函数`report()`将向调用者提供一些关于恐慌发生原因的洞察。恐慌将沿着堆栈向上冒泡到`main()`函数，并且执行将立即停止：
- en: '[PRE42]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: At the command line, navigate to the directory created in *step 1*.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，导航到在*步骤1*中创建的目录。
- en: 'At the command line, type the following:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，键入以下内容：
- en: '[PRE43]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `go build` command will compile your program and create an executable named
    after the directory you created in *step 1*.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`go build`命令将编译您的程序，并创建一个以您在*步骤1*中创建的目录命名的可执行文件。'
- en: Type the name of the file created in *step 8* and hit *Enter* to run the executable.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入在*步骤8*中创建的文件名，然后按*Enter*键运行可执行文件。
- en: 'The expected output should be as follows:'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出应如下所示：
- en: '![Figure 6.7: Panic exercise output'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7：恐慌练习输出'
- en: '](img/B14177_06_07.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_06_07.jpg)'
- en: 'Figure 6.7: Panic exercise output'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7：恐慌练习输出
- en: In this exercise, we learned how to perform `panic` and pass an error to the
    `panic()` function. This aids the user of the function in gaining a good understanding
    of the cause of the panic. In the next topic, we will see how to regain control
    of the program after a panic occurs using `Recover`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何执行`panic`并将错误传递给`panic()`函数。这有助于用户更好地理解恐慌的原因。在下一个主题中，我们将看到如何使用`Recover`在恐慌发生后重新控制程序。
- en: Recover
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复
- en: Go provides us with the ability to regain control after `panic` has occurred.
    Recover is a function that is used to regain control of a panicking Goroutine.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Go为我们提供了在`panic`发生后重新控制程序的能力。Recover是一个用于重新控制恐慌的Goroutine的函数。
- en: 'The signature of the `recover()` function is as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`recover()`函数的签名如下：'
- en: '[PRE44]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `recover()` function accepts no arguments and returns an empty `interface{}`.
    For now, an empty `interface{}` indicates that any type can be returned. The `recover()`
    function will return the value sent to the `panic()` function.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`recover()`函数不接受任何参数，并返回一个空的`interface{}`。目前，一个空的`interface{}`表示可以返回任何类型。`recover()`函数将返回发送给`panic()`函数的值。'
- en: The `recover()` function is only useful inside a deferred function. As you may
    recall, a deferred function gets executed before the encompassing function terminates.
    Executing a call to the `recover()` function inside a deferred function stops
    the panicking by restoring normal execution. If the `recover()` function is called
    outside a deferred function, it will not stop the panicking.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`recover()`函数仅在deferred函数内部有用。如您所回忆的，deferred函数在包含函数终止之前执行。在deferred函数内部调用`recover()`函数将停止恐慌，通过恢复正常执行。如果`recover()`函数在deferred函数外部调用，它将不会停止恐慌。'
- en: 'The following diagram shows the steps a program would take when using `panic()`,
    `recover()`, and a `defer()` function:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了程序在使用`panic()`、`recover()`和`defer()`函数时采取的步骤：
- en: '![Figure 6.8: Recover function flow'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8：恢复函数流程]'
- en: '](img/B14177_06_08.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_06_08.jpg)'
- en: 'Figure 6.8: Recover function flow'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8：恢复函数流程]'
- en: 'The steps followed in the diagram can be explained as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 图表中遵循的步骤可以这样解释：
- en: The `main()` function calls `func a()`.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()`函数调用`func a()`。'
- en: '`func a()` calls `func b()`.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func a()`调用`func b()`。'
- en: Inside `func b()`, there is a panic.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`func b()`内部有一个panic。
- en: The `panic()` function gets handled by a deferred function that is using the
    `recover()` function.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`panic()`函数由使用`recover()`函数的延迟函数处理。'
- en: The deferred function is the last function to execute inside `func b()`.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟函数是`func b()`内部最后一个执行的函数。
- en: The deferred function calls the `recover()` function.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟函数调用了`recover()`函数。
- en: The call to `recover()` causes normal flow back to the caller, `func a()`.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recover()`的调用导致正常流程返回到调用者`func a()`。'
- en: Normal flow continues, and control is finally back with the `main()` function.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常流程继续，最终控制权回到`main()`函数。
- en: 'The following code snippet mimics the behavior of the preceding diagram:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段模拟了前面的图表行为：
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**Code Synopsis**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码摘要**'
- en: The `main()` function calls function `a()`. The `a()` function calls function
    `b()`.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main()`函数调用函数`a()`。`a()`函数调用函数`b()`。'
- en: Function `b()` accepts a string type and assigns it to the `msg` variable. If
    `msg` evaluates to `true` in the `if` statement, a panic will occur.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数`b()`接受一个字符串类型并将其分配给`msg`变量。如果`msg`在`if`语句中评估为`true`，将发生panic。
- en: 'The argument for the panic is a new error created by the `errors.New()` function:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: panic的参数是由`errors.New()`函数创建的新错误：
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Once the panic occurs, the next call will be to the deferred function.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发生panic，下一个调用将是延迟函数。
- en: 'The deferred function uses the `recover()` function. The value of the panic
    is returned from recover; in this case, the value of `r` is an error type. Then,
    the function prints out some details:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟函数使用了`recover()`函数。从`recover()`返回的panic值；在这种情况下，`r`的值是一个错误类型。然后，函数打印出一些详细信息：
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The control flow goes back to function `a()`. Function `a()` prints out some
    details.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制流程返回到函数`a()`。函数`a()`打印出一些详细信息。
- en: 'Then, the control goes back to the `main()` function and it prints out some
    details and terminates:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，控制权返回到`main()`函数，并打印出一些详细信息然后终止：
- en: '![Figure 6.9: Recover example output'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9：恢复示例输出]'
- en: '](img/B14177_06_09.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_06_09.jpg)'
- en: 'Figure 6.9: Recover example output'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.9：恢复示例输出]'
- en: 'Exercise 6.05: Recovering from a Panic'
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.05：从panic中恢复
- en: In this exercise, we will enhance our `payDay()` function to recover from a
    panic. When our `payDay()` function panics, we will inspect the error from that
    panic. Then, depending on the error, we will print an informative message to the
    user.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将增强我们的`payDay()`函数以从panic中恢复。当我们的`payDay()`函数panic时，我们将检查该panic的错误。然后，根据错误，我们将向用户打印一条信息性消息。
- en: Use the IDE of your choice, one option would be Visual Studio Code.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您选择的IDE，一个选项是Visual Studio Code。
- en: Create a new file and save it in `$GOPATH\err\panicEx\main.go`.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件，并将其保存在`$GOPATH\err\panicEx\main.go`。
- en: 'Enter the following code in `main.go`:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.go`中输入以下代码：
- en: '[PRE48]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Call the `payDay()` function with various arguments and then print the return
    value of the function:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用各种参数调用`payDay()`函数，然后打印函数的返回值：
- en: '[PRE49]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, add a `defer` function to your `payDay()` function:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在您的`payDay()`函数中添加一个`defer`函数：
- en: '[PRE50]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can check for the return value from the `recover()` function, as follows:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以检查`recover()`函数的返回值，如下所示：
- en: '[PRE51]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If `r` is not `nil`, that means a panic occurs and we should perform an action.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果`r`不是`nil`，这意味着发生了panic，我们应该执行某些操作。
- en: 'We can evaluate `r` and see whether it equals our error values, `ErrHourlyRate`
    or `ErrHoursWorked`:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以评估`r`并查看它是否等于我们的错误值`ErrHourlyRate`或`ErrHoursWorked`：
- en: '[PRE52]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If our `if` statements evaluate to `true`, we print some details about the
    data and the error values from the `recover()` function. We then print how our
    pay was calculated:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们的`if`语句评估为`true`，我们将打印有关数据和`recover()`函数中的错误值的一些详细信息。然后，我们打印出我们的工资是如何计算的：
- en: '[PRE53]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The rest of the code in the `payDay()` function remains unchanged. To see a
    description of it, you can refer to *Exercise 6.04*, *Crashing the Program on
    Errors Using panic*:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`payDay()`函数中的其余代码保持不变。要查看其描述，可以参考*练习6.04*，*使用panic在错误中崩溃程序*：'
- en: '[PRE54]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: At the command line, navigate to the directory created in *step 1*.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the command line, type the following:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `go build` command will compile your program and create an executable named
    after the directory you created in *step 1*.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Type the name of the file created in *step 10* and hit *Enter* to run the executable.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.10: Recovering from a panic exercise output'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_06_10.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.10: Recovering from a panic exercise output'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding exercises, we have seen the progression of creating a custom
    error and returning that error. From this, we have been able to crash programs
    when needed using `panic`. In the previous exercise, we demonstrated the ability
    to recover from panics and display error messages based on the error type that
    was passed to the `panic()` function. In the following topic, we will discuss
    some basic guidelines when performing error handling in Go.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Guidelines when working with Errors and Panic
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Guidelines are just for guidance. They are not set in stone. This means, the
    majority of the time you should follow the guidelines; however, there could be
    exceptions. Some of these guidelines have been mentioned previously, but we have
    consolidated them here for quick reference:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: When declaring our own error type, the variable needs to start with `Err`. It
    should also follow the camel case naming convention.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `error` string should start with lowercase and not end with punctuation.
    One of the reasons for this guideline is that the error can be returned and concatenated
    with other information relevant to the error.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a function or method returns an error, it should be evaluated. Errors not
    evaluated can cause the program to not function as expected.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using `panic()`, pass an error type as the argument, instead of an empty
    value.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not evaluate the string value of an error.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `panic()` function sparingly.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Activity 6.01: Creating a Custom Error Message for a Banking Application'
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bank wants to add some custom errors when checking for last name and valid
    routing numbers. They have found that the direct deposit procedure allows invalid
    names and routing numbers to be used. The bank wants a descriptive error message
    for when these incidents occur. Our job is to create two descriptive custom error
    messages. Remember to use an idiomatic naming convention for the error variable
    and a proper structure for the error message.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to do the following:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Create two error values for `InvalidLastName` and `InvalidRoutingNumber`.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, print the custom message in the `main()` function to show the bank the
    error message they will receive when those errors are encountered.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: By the end of this activity, you will be familiar with the steps that are needed
    to create a custom error message.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 709.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.02: Validating a Bank Customer''s Direct Deposit Submission'
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The bank was pleased with the custom error messages that you created in *Activity
    6.01,* *Creating a Custom Error Message for a Banking Application*. They are so
    pleased that they now want you to implement two methods. These two methods are
    for validating the last name and the routing number:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: You will need to create a struct called `directDeposit`.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `directDeposit` struct will have three string fields: `lastName`, `firstName`,
    and `bankName`. It will also have two `int` fields called `routingNumber` and
    `accountNumber`.'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `directDeposit` struct will have a `validateRoutingNumber` method. The method
    will return `ErrInvalidRoutingNum` when the routing number is less than 100.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `directDeposit` struct will have a `validateLastName` method. It will return
    `ErrInvalidLastName` when the `lastName` is an empty string.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `directDeposit` struct will have a method report. It will print out each
    of the fields' values.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main()` function, assign values to the `directDeposit` struct's fields
    and call each of the `directDeposit` struct's methods.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.11: Validating a bank customer''s direct deposit submission'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_06_11.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.11: Validating a bank customer''s direct deposit submission'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this activity, you will have learned how to return errors from
    functions and how to check for errors returned from a function. You will also
    be able to check for a condition and, based on that condition, return your own
    custom error.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 710.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.03: Panic on Invalid Data Submission'
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The bank has now decided that they would rather crash the program when an invalid
    routing number is submitted. The bank feels that the erroneous data validates
    causing the program to stop processing the direct deposit data. You need to raise
    panic on an invalid data submission instance. Build this on top of *Activity 6.02*,
    *Validating a Bank Customer''s Direct Deposit Submission*:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `validateRoutingNumber` method to not return `ErrInvalidRoutingNum`,
    but instead perform a panic:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.12: Panic on invalid routing number'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_06_12.jpg)'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.12: Panic on invalid routing number'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this activity, you will be able to cause a `panic` to occur and
    see how that impacts the flow of the program.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 713.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.04: Preventing a Panic from Crashing the App'
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After some initial alpha testing, the bank no longer wants the app to crash,
    Instead, in this activity, we need to recover from the panic that was an added
    feature in *Activity 6.03*, *Panic on Invalid Data Submission*, and print the
    error that caused the panic:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Add a `defer` function inside the `validateRoutingNumber` method.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an `if` statement that checks the error returned from the `recover()` function.
    If there is an error, then print the error:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.13: Recover from panic on an invalid routing number'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.13：从无效路由号恢复恐慌](img/B14177_06_11.jpg)'
- en: '](img/B14177_06_11.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: 'Figure 6.13: Recover from panic on an invalid routing number'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13：从无效路由号恢复恐慌
- en: By the end of this activity, you will cause a panic, but you will be able to
    prevent it from crashing the application. You will get an understanding of how
    the `recover()` function, used in conjunction with the `defer` statement, can
    be used to prevent the application from crashing.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在本活动的结束时，你将引发一个恐慌，但你将能够防止它使应用程序崩溃。你将了解如何使用 `recover()` 函数，结合 `defer` 语句，来防止应用程序崩溃。
- en: Note
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution of this activity can be found on page 614.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 614 页找到。
- en: Summary
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have looked at the different types of errors that you will
    encounter while programming, such as syntax, runtime, and semantic errors. We
    focused more on runtime errors. These errors are more difficult to debug.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了编程时可能会遇到的不同类型的错误，例如语法错误、运行时错误和语义错误。我们更关注运行时错误。这些错误更难调试。
- en: We examined the difference between various language philosophies when it comes
    to dealing with errors. We have seen how Go's syntax for errors is simpler to
    understand compared to the exception handling that various languages are utilizing.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了在处理错误时不同语言哲学之间的差异。我们看到了与各种语言使用的异常处理相比，Go 的错误语法更容易理解。
- en: An error in Go is a value. Values can be passed around to functions. Any error
    can be a value as long as it implements the error interface type. We learned how
    easily we can create errors. We also learned that we should name our error values
    starting with `Err` followed by a descriptive camel case name.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的错误是一个值。值可以被传递给函数。只要实现了错误接口类型，任何错误都可以作为一个值。我们学习了如何轻松地创建错误。我们还了解到，我们应该以 `Err`
    开头给错误值命名，后面跟着一个描述性的驼峰式命名。
- en: Next, we discussed panics and the similarities between a panic and an exception.
    We also discovered that panics are pretty similar to exceptions; however, if panics
    are unhandled, they will cause the program to crash. However, Go has a mechanism
    that will return the control of the program back to normal. We do this by using
    the `recover()` function. The requirements for recovering from a panic requires
    the usage of the `recover()` function in a deferred function. We also learned
    the general guidelines for using `errors`, `panic`, and `recover`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了恐慌以及恐慌与异常之间的相似性。我们还发现，恐慌与异常非常相似；然而，如果恐慌未被处理，它们将导致程序崩溃。但是，Go 有一种机制可以将程序的控制权返回到正常状态。我们通过使用
    `recover()` 函数来实现这一点。从恐慌中恢复的要求需要在延迟函数中使用 `recover()` 函数。我们还学习了使用 `errors`、`panic`
    和 `recover` 的一般指南。
- en: In the next chapter, we will look at interfaces and their uses, as well as how
    they differ from how other programming languages implement interfaces. We will
    see how they can be used to solve various problems that you face as a programmer.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨接口及其用途，以及它们与其他编程语言实现接口的方式有何不同。我们将看到它们如何被用来解决作为程序员面临的各类问题。
