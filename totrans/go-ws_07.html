<html><head></head><body>
		<div>
			<div id="_idContainer112" class="Content">
			</div>
		</div>
		<div id="_idContainer113" class="Content">
			<h1 id="_idParaDest-210"><a id="_idTextAnchor220"/>7. Interfaces</h1>
		</div>
		<div id="_idContainer127" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter aims to demonstrate the implementation of interfaces in Go. It is quite simple compared to other languages because it is done implicitly in Go, whereas other languages require interfaces to be implemented explicitly.</p>
			<p class="callout">In the beginning, you will be able to define and declare an interface for an application and implement an interface in your applications. This chapter introduces you to use duck typing and polymorphism and accept interfaces and return structs.</p>
			<p class="callout">By the end of this chapter, you will learn to use type assertion to access our interface's underlying concrete value, and use the type switch statement.</p>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor221"/>Introduction</h1>
			<p>In the previous chapter, we discussed error handling in Go. We looked at what an error is in Go. We discovered that an error in Go is anything that implements the error interface. At the time, we did not investigate what an interface was. In this chapter, we are going to look at what an interface is.</p>
			<p>For example, your manager requests that you create an API that can accept JSON data. The data contains information about various employees, such as their address and the hours they worked on a project. The data will need to be parsed into an <strong class="source-inline">employee</strong> struct, a relatively simple task. You then create a function called <strong class="source-inline">loadEmployee(s string)</strong>. The function will accept a string that is formatted as JSON, and then parse that string to load the <strong class="source-inline">employee</strong> struct.</p>
			<p>Your manager is happy with the work; however, he has another requirement. The clients need the ability to accept a file with the employee data in JSON format. The functionality to be performed is the same underlying task as before. You create another function called <strong class="source-inline">loadEmployeeFromFile(f *os.File)</strong> that reads the data from the file, parses the data, and loads the employee struct.</p>
			<p>Your manager has yet another requirement that the employee data should now also come from an HTTP endpoint. You will need to be able to read the data from the HTTP request, so you create another function called <strong class="source-inline">loadEmployeeFromHTTP(r *Request)</strong>.</p>
			<p>All three functions that were written have a common behavior that they are performing. They all need to be able to read the data. The underlying type could be different (such as <strong class="source-inline">string</strong>, <strong class="source-inline">os.File</strong>, or <strong class="source-inline">http.Request</strong>) but the behavior, or reading the data, is the same in all cases.</p>
			<p>The <strong class="source-inline">func loadEmployee(s string)</strong>, <strong class="source-inline">func loadEmployeeFromFile(f *os.File)</strong>, and <strong class="source-inline">func loadEmployeeFromHTTP(r *Request)</strong> functions can all be replaced using an interface, <strong class="source-inline">func loadEmployee (r io.Reader)</strong>. <strong class="source-inline">io.Reader</strong> is an interface, and we will discuss it in more depth later in the chapter, but for now, it is enough to say it can be used to solve the given problem.</p>
			<p>In this chapter, we will see how interfaces can solve such a problem; by defining the behavior that is being performed as an interface type, we can accept any underlying concrete type. Don't worry if that does not make sense right now; it will start to become clearer as we progress in this chapter. We will discuss how interfaces give us the ability to perform duck typing and polymorphism. We will see how accepting interfaces and returning structs will decrease coupling and increase the use of functions in more areas of our programs. We will also examine the empty interface and discuss use cases to fully utilize it, along with type assertion and type switch statements.</p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor222"/>Interface</h1>
			<p>An interface is a set of methods that describe the behavior of the data type. Interfaces define the behavior(s) of the type that must be satisfied to implement that interface. A behavior describes what that type can do. Almost everything exhibits certain behavior. For example, a cat can meow, walk, jump, and purr. All of those are behaviors of a cat. A car can start, stop, turn, and speed up. All of those are behaviors of a car. Similarly, behaviors for types are called methods.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The definition that the <a href="https://packt.live/2qOtKrd">https://packt.live/2qOtKrd</a> provides is "Interfaces in Go provide a way to specify the behavior of an object."</p>
			<p>There are several ways to describe an interface:</p>
			<ul>
				<li>A collection of method signatures is methods with only the name of the method, its arguments, types and a return type. This is an example of a collection of method signatures for the <strong class="source-inline">Speaker{}</strong> interface:<p class="source-code">type Speaker interface{</p><p class="source-code">Speak(message string) string</p><p class="source-code">Greet() string</p><p class="source-code">}</p></li>
				<li>Blueprints of the type's methods are needed to satisfy the interface. Using the <strong class="source-inline">Speaker{}</strong> interface, the blueprint (interface) states that to satisfy the <strong class="source-inline">Speaker{}</strong> interface, the type must have a <strong class="source-inline">Speak()</strong> method that accepts a <strong class="source-inline">string</strong> and returns a <strong class="source-inline">string</strong>. It also must have a <strong class="source-inline">Greet()</strong> method that returns a <strong class="source-inline">string</strong>.</li>
				<li>Behaviors are what the interface type must exhibit. For example, the <strong class="source-inline">Reader{}</strong> interface has a <strong class="source-inline">Read</strong> method. Its behavior is the reading of data and the Go standard library's <strong class="source-inline">Reader{}</strong> interface:<p class="source-code">type Reader interface{</p><p class="source-code">Read(b []byte)(n int, err error)</p><p class="source-code">}</p></li>
				<li>Interfaces can be described as having no implementation details. The <strong class="source-inline">Reader{}</strong> interface only contains the signature of the method but not the method's code. The implementer of the interface has the responsibility of providing the code or implementation details, not the interfaces themselves.<p>Behaviors of a type can be as follows:</p></li>
				<li><strong class="source-inline">Read()</strong></li>
				<li><strong class="source-inline">Write()</strong></li>
				<li><strong class="source-inline">Save()</strong></li>
			</ul>
			<p>These behaviors are collectively called <strong class="bold">methods sets</strong>. A behavior is defined by a set of methods. A method set is a group of method(s). These method sets comprise the method name, any input parameters, and any return types.</p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B14177_07_01.jpg" alt="Figure 7.1: Graphic representation of interface elements&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1: Graphic representation of interface elements</p>
			<p>When we are talking about behaviors, note that we did not discuss the implementation details. Implementation details are omitted when you define an interface. It is important to understand that no implementation is specified or enforced in the declaration of an interface. Each type that we create that implements an interface can have its own implementation details. An interface that has a method called <strong class="source-inline">Greeting()</strong> can be implemented in different ways by various types. A struct type of person can implement <strong class="source-inline">Greeting()</strong> in a different way than a struct type of animal. Interfaces focus on the behaviors that the type must exhibit. It is not the job of the interface to provide method implementations. That is the job of the type that is implementing the interface. The types, usually a struct, contain the implementation details of the method sets. Now that we have a basic understanding of an interface, in the next topic, we will be looking at how to define an interface.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor223"/>Defining an Interface</h2>
			<p>Defining an interface involves the following steps:</p>
			<div>
				<div id="_idContainer115" class="IMG---Figure">
					<img src="image/B14177_07_02.jpg" alt="Figure 7.2: Defining an interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2: Defining an interface</p>
			<p>Here is an example of declaring an interface:</p>
			<p class="source-code">ty<a id="_idTextAnchor224"/>pe Speaker interface {</p>
			<p class="source-code">  Speak() string</p>
			<p class="source-code">}</p>
			<p>Let's look at each part of this declaration:</p>
			<ul>
				<li>Start with the <strong class="source-inline">type</strong> keyword, followed by the name, and then the <strong class="source-inline">interface</strong> keyword.</li>
				<li>We are defining an interface type called <strong class="source-inline">Speaker{}</strong>. It is idiomatic in Go to name the interface with an <strong class="source-inline">er</strong> suffix. If it is a one-method interface, it is typical to name the interface after that one method.</li>
				<li>Next, you define the method set. Defining an interface type specifies the method(s) that belong to it. In this interface, we are declaring an interface type that has one method called <strong class="source-inline">Speak()</strong> and it returns a string.</li>
				<li>The method set of the <strong class="source-inline">Speaker{}</strong> interface is <strong class="source-inline">Speak()</strong>.</li>
			</ul>
			<p>Here is an interface that is used frequently in Go:</p>
			<p class="source-code">// https://golang.org/pkg/io/#Reader</p>
			<p class="source-code">type Reader interface {</p>
			<p class="source-code">    Read(p []byte) (n int, err error)</p>
			<p class="source-code">}</p>
			<p>Let's look at the parts of this code:</p>
			<ul>
				<li>The interface name is <strong class="source-inline">Reader{}</strong>.</li>
				<li>The method set is <strong class="source-inline">Read()</strong>.</li>
				<li>The signature of the <strong class="source-inline">Read()</strong> method is <strong class="source-inline">(p []byte)(n int, err error)</strong>.</li>
			</ul>
			<p>Interfaces can have more than one method as its method set. Let's look at an interface used in the Go package:</p>
			<p class="source-code">// https://golang.org/pkg/os/#FileInfo</p>
			<p class="source-code">type FileInfo interface {</p>
			<p class="source-code">        Name() string       // base name of the file</p>
			<p class="source-code">        Size() int64        // length in bytes for regular files; system-dependent for others</p>
			<p class="source-code">        Mode() FileMode     // file mode bits</p>
			<p class="source-code">        ModTime() time.Time // modification time</p>
			<p class="source-code">        IsDir() bool        // abbreviation for Mode().IsDir()</p>
			<p class="source-code">        Sys() interface{}   // underlying data source (can return nil)</p>
			<p class="source-code">}</p>
			<p>As you can see, <strong class="source-inline">FileInfo{}</strong> has multiple methods.</p>
			<p>In summary, interfaces are types that declare method sets. Similar to other languages that utilize interfaces, they do not implement the method sets. Implementation details are not part of defining an interface. In the next topic, we will be looking at what Go requires for you to be able to implement the interface.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor225"/>Implementing an Interface</h2>
			<p>Interfaces in other programming languages implement an interface explicitly. Explicit implementation means that the programming language directly and clearly states that this object is using this interface. For example, this is in Java:</p>
			<p class="source-code">class Dog implements Pet</p>
			<p>The <strong class="source-inline">Dog</strong> class will be implemented by the <strong class="source-inline">Pet</strong> interface. The code segment explicitly states that the <strong class="source-inline">Dog</strong> class will implement <strong class="source-inline">Pet</strong>.</p>
			<p>In Go, interfaces are implemented implicitly. This means that a type will implement the interface by having all the methods and their signature of the interface. Here is an example:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">type Speaker interface {</p>
			<p class="source-code">  Speak() string</p>
			<p class="source-code">}</p>
			<p class="source-code">type cat struct {</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  c := cat{}</p>
			<p class="source-code">  fmt.Println(c.Speak())</p>
			<p class="source-code">  c.Greeting()</p>
			<p class="source-code">}</p>
			<p class="source-code">func (c cat) Speak() string {</p>
			<p class="source-code">  return "Purr Meow"</p>
			<p class="source-code">}</p>
			<p class="source-code">func (c cat) Greeting() {</p>
			<p class="source-code">  fmt.Println("Meow,Meow!!!!mmmeeeeoooowwww")</p>
			<p class="source-code">}</p>
			<p>Let's break this code down into parts:</p>
			<p class="source-code">type Speaker interface {</p>
			<p class="source-code">  Speak() string</p>
			<p class="source-code">}</p>
			<p>We are defining a <strong class="source-inline">Speaker{}</strong> interface. It has one method that describes the <strong class="source-inline">Speak()</strong>behavior. The method returns a string. For a type to implement the <strong class="source-inline">Speaker{}</strong> interface, it must have the method listed in the interface declaration. Then, we create an empty struct type called <strong class="source-inline">cat</strong>:</p>
			<p class="source-code">type cat struct {</p>
			<p class="source-code">}</p>
			<p class="source-code">func (c cat) Speak() string {</p>
			<p class="source-code">  return "Purr Meow"</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">cat</strong> type has a <strong class="source-inline">Speak()</strong> method that returns the string. This satisfies the <strong class="source-inline">Speaker{}</strong> interface. It is now the responsibility of the implementer of <strong class="source-inline">cat</strong> to provide the implementation details for the cat type's <strong class="source-inline">Speak()</strong> method.</p>
			<p>Notice that there was no explicit statement that declares <strong class="source-inline">cat</strong> implements the <strong class="source-inline">Speaker{}</strong> interface; it does so by just having met the requirements of the interface.</p>
			<p>It is also important to notice that the <strong class="source-inline">cat</strong> type has a method called <strong class="source-inline">Greeting()</strong>. The type can have methods that are not needed to satisfy the <strong class="source-inline">Speaker{}</strong> interface. However, the cat must have at least the required method sets to be able to satisfy the interface.</p>
			<p>The output will be as follows:</p>
			<p class="source-code">Purr Meow</p>
			<p class="source-code">Meow,Meow!!!!mmmeeeeoooowwww</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor226"/>Advantages of Implementing Interfaces Implicitly</h2>
			<p>There are some advantages to implementing interfaces implicitly. We have seen that when you create an interface, you have to go to each type and explicitly state that the type implements the interface. In Go, the type that satisfies the interface is said to implement it. There is no <strong class="source-inline">implements</strong> keyword like in other languages; you do not need to say that a type implements the interface. In Go, if it has the method sets and signatures of the interface, it implicitly implements the interface.</p>
			<p>When you change the method sets of an interface, in other languages you would have to go to all those types that did not satisfy the interface and remove the explicit declaration for the type. This is not the case in Go, since it is an implicit declaration.</p>
			<p>Another advantage is you can write interfaces for types that are in another package. This decouples the definition of an interface from its implementation. We will discuss packages and their scope in <em class="italic">Chapter 8</em>, <em class="italic">Packages</em>.</p>
			<p>Let's look at an example of using an interface from a different package in our main package. The <strong class="source-inline">Stringer</strong> interface is an interface that is in the Go language. It is used by several packages through the Go language. One example is the <strong class="source-inline">fmt</strong> package, which is used for formatting when printing values:</p>
			<p class="source-code">type Stringer interface {</p>
			<p class="source-code">  String() string</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">Stringer</strong> is an interface that is a type that can describe itself as a string. Interface names typically follow the method name but with the addition of the <strong class="source-inline">er</strong> suffix:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">type Speaker interface {</p>
			<p class="source-code">  Speak() string</p>
			<p class="source-code">}</p>
			<p class="source-code">type cat struct {</p>
			<p class="source-code">  name string</p>
			<p class="source-code">  age  int</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  c := cat{name: "Oreo", age:9}</p>
			<p class="source-code">  fmt.Println(c.Speak())</p>
			<p class="source-code">  fmt.Println(c)</p>
			<p class="source-code">}</p>
			<p class="source-code">func (c cat) Speak() string {</p>
			<p class="source-code">  return "Purr Meow"</p>
			<p class="source-code">}</p>
			<p class="source-code">func (c cat) String() string {</p>
			<p class="source-code">  return fmt.Sprintf("%v (%v years old)", c.name, c.age)</p>
			<p class="source-code">}</p>
			<p>Let's break down this code into parts:</p>
			<ul>
				<li>We have added a <strong class="source-inline">String()</strong> method to our <strong class="source-inline">cat</strong> type. It returns the field data for <strong class="source-inline">name</strong> and <strong class="source-inline">age</strong>.</li>
				<li>When we call the <strong class="source-inline">fmt.Println()</strong> method in <strong class="source-inline">main()</strong> with the argument of <strong class="source-inline">cat</strong>, <strong class="source-inline">fmt.Println()</strong> calls the <strong class="source-inline">String()</strong> method on the <strong class="source-inline">cat</strong> type.</li>
				<li>Our <strong class="source-inline">cat</strong> type now implements two interfaces; the <strong class="source-inline">Speaker{}</strong> interface and the <strong class="source-inline">Stringer{}</strong> interface. It has the methods required to satisfy both of those interfaces:</li>
			</ul>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B14177_07_03.jpg" alt="Figure 7.3: Types can implement multiple interfaces&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3: Types can implement multiple interfaces</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor227"/>Exercise 7.01: Implementing an Interface</h2>
			<p>In this exercise, we are going to create a simple program that demonstrates how to implement interfaces implicitly. We will have a <strong class="source-inline">person</strong> struct that will implicitly implement the <strong class="source-inline">Speaker{}</strong> interface. The <strong class="source-inline">person</strong> struct will contain <strong class="source-inline">name</strong>, <strong class="source-inline">age</strong>, and <strong class="source-inline">isMarried</strong> as its fields. The program will call the <strong class="source-inline">Speak()</strong> method of our <strong class="source-inline">person</strong> struct and display a message displaying the <strong class="source-inline">person</strong> struct's <strong class="source-inline">name</strong>. The <strong class="source-inline">person</strong> struct will also satisfy the requirements for the <strong class="source-inline">Stringer{}</strong> interface by having a <strong class="source-inline">String()</strong> method. You may recall previously, in the <em class="italic">Advantages of Implementing Interfaces Implicitly</em> section, that the <strong class="source-inline">Stringer{}</strong> interface is an interface that is in the Go language. It can be used for formatting when printing values. That is how we are going to use it in this exercise to format the printing of the fields of the <strong class="source-inline">person</strong> struct:</p>
			<ol>
				<li>Create a new file and save it as <strong class="source-inline">main.go</strong>.</li>
				<li>We will have <strong class="source-inline">package</strong> <strong class="source-inline">main</strong> and will be using the <strong class="source-inline">fmt</strong> package in this program:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">)</p></li>
				<li>Create a <strong class="source-inline">Speaker{}</strong> interface with a method called <strong class="source-inline">Speak()</strong> that returns a string:<p class="source-code">type Speaker interface {</p><p class="source-code">  Speak() string</p><p class="source-code">}</p><p>We have created a <strong class="source-inline">Speaker{}</strong> interface. Any type that wants to implement our <strong class="source-inline">Speaker{}</strong> interface must have a <strong class="source-inline">Speak()</strong> method that returns a string.</p></li>
				<li>Create our <strong class="source-inline">person</strong> struct with <strong class="source-inline">name</strong>, <strong class="source-inline">age</strong>, and <strong class="source-inline">isMarried</strong> as its fields:<p class="source-code">type person struct {</p><p class="source-code">  name      string</p><p class="source-code">  age       int</p><p class="source-code">  isMarried bool</p><p class="source-code">}</p><p>Our <strong class="source-inline">person</strong> type contains <strong class="source-inline">name</strong>, <strong class="source-inline">age</strong>, and <strong class="source-inline">isMarried</strong> fields. We will later print the contents of these fields in our <strong class="source-inline">main</strong> function using a <strong class="source-inline">Speak()</strong> method that returns a string. Having a <strong class="source-inline">Speak()</strong> method will satisfy the <strong class="source-inline">Speaker{}</strong> interface.</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, we will initialize a person type, print the <strong class="source-inline">Speak()</strong> method, and print the <strong class="source-inline">person</strong> field values:<p class="source-code">func main() {</p><p class="source-code">  p := person{name: "Cailyn", age: 44, isMarried: false}</p><p class="source-code">  fmt.Println(p.Speak())</p><p class="source-code">  fmt.Println(p)</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">String()</strong> method for <strong class="source-inline">person</strong> and return a string value. This will satisfy the <strong class="source-inline">Stringer{}</strong> interface, which will now allow it to be called by the <strong class="source-inline">fmt.Println()</strong> method:<p class="source-code">func (p person) String() string {</p><p class="source-code">  return fmt.Sprintf("%v (%v years old).\nMarried status: %v ", p.name,     p.age, p.isMarried)</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">Speak()</strong> method for <strong class="source-inline">person</strong> that returns a string. The <strong class="source-inline">person</strong> type has a <strong class="source-inline">Speak()</strong> method that has the same signature as the <strong class="source-inline">Speak()</strong> method of the <strong class="source-inline">Speaker{}</strong> interface. The <strong class="source-inline">person</strong> type satisfies the <strong class="source-inline">Speaker{}</strong> interface by having a <strong class="source-inline">Speak()</strong> method that returns the string. To satisfy interfaces, you must have the same methods and method signatures of the interface:<p class="source-code">func (p person) Speak() string {</p><p class="source-code">  return "Hi my name is: " + p.name</p><p class="source-code">}</p></li>
				<li>Open the terminal and navigate to the code's directory.</li>
				<li>Run <strong class="source-inline">go build</strong>.</li>
				<li>Correct any errors that are returned and ensure your code matches the code snippet here.</li>
				<li>Run the executable by typing the executable name in the command line.<p>You should get the following output:</p><p class="source-code">Hi my name is Cailyn</p><p class="source-code">Cailyn (44 years old).</p><p class="source-code">Married status: false</p></li>
			</ol>
			<p>In this exercise, we saw how simple it is to implement interfaces implicitly. In the next topic, we will build on this by having different data types, such as structs, implement the same interface, which can be passed to any function that has the argument of that type of interface. We will go into greater detail of how that is possible in the next topic and see why it is a benefit for a type to appear in various forms.</p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor228"/>Duck Typing</h1>
			<p>We have been basically doing what is called duck typing. Duck typing is a test in computer programming: "<em class="italic">If it looks like a duck, swims like a duck, and quacks like a duck, then it must be a duck.</em>" If a type matches an interface, then you can use that type wherever that interface is used. Duck typing is matching a type based upon methods, rather than the expected type:</p>
			<p class="source-code">type Speaker interface {</p>
			<p class="source-code">  Speak() string</p>
			<p class="source-code">}</p>
			<p>Anything that matches the <strong class="source-inline">Speak()</strong> method can be a <strong class="source-inline">Speaker{}</strong> interface. When implementing an interface, we are essentially conforming to that interface by having the required method sets:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">type Speaker interface {</p>
			<p class="source-code">  Speak() string</p>
			<p class="source-code">}</p>
			<p class="source-code">type cat struct {</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  c := cat{}</p>
			<p class="source-code">  fmt.Println(c.Speak())</p>
			<p class="source-code">}</p>
			<p class="source-code">func (c cat) Speak() string {</p>
			<p class="source-code">  return "Purr Meow"</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">cat</strong> matches the <strong class="source-inline">Speak()</strong> method of the <strong class="source-inline">Speaker{}</strong> interface, so a <strong class="source-inline">cat</strong> is a <strong class="source-inline">Speaker{}</strong>:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">type Speaker interface {</p>
			<p class="source-code">  Speak() string</p>
			<p class="source-code">}</p>
			<p class="source-code">type cat struct {</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  c := cat{}</p>
			<p class="source-code">  chatter(c)</p>
			<p class="source-code">}</p>
			<p class="source-code">func (c cat) Speak() string {</p>
			<p class="source-code">  return "Purr Meow"</p>
			<p class="source-code">}</p>
			<p class="source-code">func chatter(s Speaker) {</p>
			<p class="source-code">  fmt.Println(s.Speak())</p>
			<p class="source-code">}</p>
			<p>Let's examine this code in parts:</p>
			<ul>
				<li>In the preceding code, we declare a <strong class="source-inline">cat</strong> type and create a method for the <strong class="source-inline">cat</strong> type called <strong class="source-inline">Speak()</strong>. This fulfills the required method sets for the <strong class="source-inline">Speaker{}</strong> interface.</li>
				<li>We create a method called <strong class="source-inline">chatter</strong> that takes the <strong class="source-inline">Speaker{}</strong> interface as an argument.</li>
				<li>In the <strong class="source-inline">main()</strong> function, we are able to pass a <strong class="source-inline">cat</strong> type into the <strong class="source-inline">chatter</strong> function, which can evaluate to the <strong class="source-inline">Speaker{}</strong> interface This satisfies the required method sets for the interface.</li>
			</ul>
			<h1 id="_idParaDest-218"><a id="_idTextAnchor229"/>Polymorphism</h1>
			<p>Polymorphism is the ability to appear in various forms. For example, a shape can appear as a square, circle, rectangle, or any other shape:</p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B14177_07_04.jpg" alt="Figure 7.4: Polymorphism example for shape&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4: Polymorphism example for shape</p>
			<p>Go does not do subclassing like other object-oriented languages because Go does not have classes. Subclassing in object-oriented programming is inheriting from one class to another. By doing subclassing, you are inheriting the fields and methods of another class. Go provides a similar behavior through embedding structs and by using polymorphism through interfaces.</p>
			<p>One of the advantages of using polymorphism is that it allows the reuse of methods that have been written once and tested. Code is reused by having an API that accepts an interface; if our type satisfies that interface, it can be passed to that API. There is no need to write additional code for each type; we just need to ensure we meet the interface method's set requirements. Obtaining polymorphism through the use of interfaces will increase the reusability of the code. If your API only accepts concrete types such as <strong class="source-inline">int</strong>, <strong class="source-inline">float</strong>, and <strong class="source-inline">bool</strong>, only that concrete type can be passed. However, if your API accepts an interface, then the caller can add the required method sets to satisfy that interface regardless of the underlying type. This reusability is accomplished by allowing your APIs to accept interfaces. Any type that satisfies the interface can be passed to the API. We have seen this type of behavior in a previous example. This is a good time to take a closer look at the <strong class="source-inline">Speaker{}</strong> interface.</p>
			<p>As we have seen in previous examples, each concrete type can implement one or more interfaces. Recall that our <strong class="source-inline">Speaker{}</strong> interface can be implemented by a <strong class="source-inline">dog</strong>, <strong class="source-inline">cat</strong>, or <strong class="source-inline">fish</strong> type:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B14177_07_05.jpg" alt="Figure 7.5: The Speaker interface implemented by multiple types&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5: The Speaker interface implemented by multiple types</p>
			<p>When a function accepts an interface as an input parameter, any concrete type that implements that interface can be passed as an argument. Now, you have achieved polymorphism by being able to pass various concrete types to a method or function that has an interface type as an input parameter.</p>
			<p>Let's look at some progressive examples that will enable us to demonstrate how polymorphism is achieved in Go:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">type Speaker interface {</p>
			<p class="source-code">  Speak() string</p>
			<p class="source-code">}</p>
			<p class="source-code">type cat struct {</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  c := cat{}</p>
			<p class="source-code">  catSpeak(c)</p>
			<p class="source-code">}</p>
			<p class="source-code">func (c cat) Speak() string {</p>
			<p class="source-code">  return "Purr Meow"</p>
			<p class="source-code">}</p>
			<p class="source-code">func catSpeak(c cat) {</p>
			<p class="source-code">  fmt.Println(c.Speak())</p>
			<p class="source-code">}</p>
			<p>Let's examine the code in parts:</p>
			<ul>
				<li><strong class="source-inline">cat</strong> satisfies the <strong class="source-inline">Speaker{}</strong> interface. The <strong class="source-inline">main()</strong> function calls <strong class="source-inline">catSpeak()</strong> and takes a type of <strong class="source-inline">cat</strong>.</li>
				<li>Inside <strong class="source-inline">catSpeak()</strong>, it prints out the results of its <strong class="source-inline">Speak()</strong> method.</li>
			</ul>
			<p>We are going to implement some code that takes a concrete type (<strong class="source-inline">cat</strong>, <strong class="source-inline">dog</strong>, <strong class="source-inline">person</strong>) and satisfies the <strong class="source-inline">Speaker{}</strong> interface type. Using the previous coding pattern, it would look like the following code snippet:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">type Speaker interface {</p>
			<p class="source-code">  Speak() string</p>
			<p class="source-code">}</p>
			<p class="source-code">type cat struct {</p>
			<p class="source-code">}</p>
			<p class="source-code">type dog struct {</p>
			<p class="source-code">}</p>
			<p class="source-code">type person struct {</p>
			<p class="source-code">  name string</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  c := cat{}</p>
			<p class="source-code">  d := dog{}</p>
			<p class="source-code">  p := person{name:"Heather"}</p>
			<p class="source-code">  catSpeak(c)</p>
			<p class="source-code">  dogSpeak(d)</p>
			<p class="source-code">  personSpeak(p)</p>
			<p class="source-code">}</p>
			<p class="source-code">func (c cat) Speak() string {</p>
			<p class="source-code">  return "Purr Meow"</p>
			<p class="source-code">}</p>
			<p class="source-code">func (d dog) Speak() string {</p>
			<p class="source-code">  return "Woof Woof"</p>
			<p class="source-code">}</p>
			<p class="source-code">func (p person) Speak() string {</p>
			<p class="source-code">  return "Hi my name is " + p.name +"."</p>
			<p class="source-code">}</p>
			<p class="source-code">func catSpeak(c cat) {</p>
			<p class="source-code">  fmt.Println(c.Speak())</p>
			<p class="source-code">}</p>
			<p class="source-code">func dogSpeak(d dog) {</p>
			<p class="source-code">  fmt.Println(d.Speak())</p>
			<p class="source-code">}</p>
			<p class="source-code">func personSpeak(p person) {</p>
			<p class="source-code">  fmt.Println(p.Speak())</p>
			<p class="source-code">}</p>
			<p>Let's look at this code in parts:</p>
			<p class="source-code">type cat struct {</p>
			<p class="source-code">}</p>
			<p class="source-code">type dog struct {</p>
			<p class="source-code">}</p>
			<p class="source-code">type person struct {</p>
			<p class="source-code">  name string</p>
			<p class="source-code">}</p>
			<p>We have three concrete types (<strong class="source-inline">cat</strong>, <strong class="source-inline">dog</strong>,and <strong class="source-inline">person</strong>). The <strong class="source-inline">cat</strong> and <strong class="source-inline">dog</strong> types are empty structs, while the <strong class="source-inline">person</strong> struct has a <strong class="source-inline">name</strong> field:</p>
			<p class="source-code">func (c cat) Speak() string {</p>
			<p class="source-code">  return "Purr Meow"</p>
			<p class="source-code">}</p>
			<p class="source-code">func (d dog) Speak() string {</p>
			<p class="source-code">  return "Woof Woof"</p>
			<p class="source-code">}</p>
			<p class="source-code">func (p person) Speak() string {</p>
			<p class="source-code">  return "Hi my name is " + p.name +"."</p>
			<p class="source-code">}</p>
			<p>Each of our types implicitly implements the <strong class="source-inline">Speaker{}</strong> interface. Each of the concrete types implements it differently from the others:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  c := cat{}</p>
			<p class="source-code">  d := dog{}</p>
			<p class="source-code">  p := person{name:"Heather"}</p>
			<p class="source-code">  catSpeak(c)</p>
			<p class="source-code">  dogSpeak(d)</p>
			<p class="source-code">  personSpeak(p)</p>
			<p class="source-code">}</p>
			<p>In the <strong class="source-inline">main()</strong> function, we call <strong class="source-inline">catSpeak()</strong>, <strong class="source-inline">dogSpeak()</strong>, and <strong class="source-inline">personSpeak()</strong> to invoke their respective <strong class="source-inline">Speak()</strong> method. The preceding code has a lot of redundant functions that perform similar actions. We can refactor this code to be more simple and easier to read. We will use some of the features you get with implementing interfaces to provide a more concise implementation:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">type Speaker interface {</p>
			<p class="source-code">  Speak() string</p>
			<p class="source-code">}</p>
			<p class="source-code">type cat struct {</p>
			<p class="source-code">}</p>
			<p class="source-code">type dog struct {</p>
			<p class="source-code">}</p>
			<p class="source-code">type person struct {</p>
			<p class="source-code">  name string</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  c := cat{}</p>
			<p class="source-code">  d := dog{}</p>
			<p class="source-code">  p := person{name: "Heather"}</p>
			<p class="source-code">  saySomething(c,d,p)</p>
			<p class="source-code">}</p>
			<p class="source-code">func saySomething(say ...Speaker) {</p>
			<p class="source-code">  for _, s := range say {</p>
			<p class="source-code">    fmt.Println(s.Speak())</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">func (c cat) Speak() string {</p>
			<p class="source-code">  return "Purr Meow"</p>
			<p class="source-code">}</p>
			<p class="source-code">func (d dog) Speak() string {</p>
			<p class="source-code">  return "Woof Woof"</p>
			<p class="source-code">}</p>
			<p class="source-code">func (p person) Speak() string {</p>
			<p class="source-code">  return "Hi my name is " + p.name + "."</p>
			<p class="source-code">}</p>
			<p>Let's look at the code in parts:</p>
			<p class="source-code">func saySomething(say ...Speaker)</p>
			<p>Our <strong class="source-inline">saySomething()</strong> function is using a variadic parameter. If you recall, a variadic parameter can accept zero or more arguments for that type. For more information on variadic functions, review <em class="italic">Chapter 5</em>, <em class="italic">Functions</em>. The parameter type is <strong class="source-inline">Speaker</strong>. An interface can be used as an input parameter:</p>
			<p class="source-code">func saySomething(say ...Speaker) {</p>
			<p class="source-code">  for _, s := range say {</p>
			<p class="source-code">    fmt.Println(s.Speak())</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>We range over the slice of <strong class="source-inline">Speaker</strong>. For each <strong class="source-inline">Speaker</strong> type, we call the <strong class="source-inline">Speak()</strong> method. In our code, we passed the <strong class="source-inline">cat</strong> and <strong class="source-inline">dog</strong> struct types to the <strong class="source-inline">person</strong> function. The function accepts an argument as an interface of <strong class="source-inline">Speaker{}</strong>. Any of the methods that make up that interface can be invoked. For each of those concrete types, the <strong class="source-inline">Speak()</strong> method is called.</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B14177_07_06.jpg" alt="Figure 7.6: Multiple types implementing the Speaker interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6: Multiple types implementing the Speaker interface</p>
			<p>In the <strong class="source-inline">main()</strong> function, we will see the use of polymorphism being demonstrated through the use of interfaces:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  c := cat{}</p>
			<p class="source-code">  d := dog{}</p>
			<p class="source-code">  p := person{name: "Heather"}</p>
			<p class="source-code">  saySomething(c,d,p)</p>
			<p class="source-code">}</p>
			<p>We implement each of the concrete types, <strong class="source-inline">cat</strong>, <strong class="source-inline">dog</strong>, and, <strong class="source-inline">person</strong>. The <strong class="source-inline">cat</strong>, <strong class="source-inline">dog</strong>, and, <strong class="source-inline">person</strong> types all satisfy the <strong class="source-inline">Speaker{}</strong> interface. Since they match an interface, you can use that type wherever that interface is used. As you can see, this also includes being able to pass the <strong class="source-inline">cat</strong>, <strong class="source-inline">dog</strong>, and <strong class="source-inline">person</strong> types into a method.</p>
			<p>Through the use of interfaces and polymorphism, this code is more concise than the previous code snippets. The example at the beginning of the chapter showed a single concrete type that satisfied the <strong class="source-inline">Speaker{}</strong> interface that invoked the <strong class="source-inline">Speak()</strong> method. We then added a few more concrete types to our running example (<strong class="source-inline">cat</strong>, <strong class="source-inline">dog</strong>, and <strong class="source-inline">person</strong>), each of these separately invoking their own <strong class="source-inline">Speak()</strong> method. We noticed there was a lot of redundant code in that example and started looking for a better way to implement the solution. We discovered that interface types can be parameter input types. Through duck typing and polymorphism, our third and final code snippet was able to have a single function that would call the <strong class="source-inline">Speak()</strong> method on each type that satisfied the <strong class="source-inline">Speaker()</strong> interface.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor230"/>Exercise 7.02: Calculating the Area of Different Shapes Using Polymorphism</h2>
			<p>We will be implementing a program that will calculate the area of a triangle, rectangle, and square. The program will use a single function that accepts a <strong class="source-inline">Shape</strong> interface. Any type that satisfies the <strong class="source-inline">Shape</strong> interface can be passed as an argument to the function. This function should then print the area and the name of the shape:</p>
			<ol>
				<li value="1">Use the IDE of your choice.</li>
				<li>Create a new file and save it as <strong class="source-inline">main.go</strong>.</li>
				<li>We will have a package called <strong class="source-inline">main</strong>, and we will be using the <strong class="source-inline">fmt</strong> package in this program:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">)</p></li>
				<li>Create the <strong class="source-inline">Shape{}</strong> interface that has two method sets called <strong class="source-inline">Area() float64</strong> and <strong class="source-inline">Name() string</strong>:<p class="source-code">type Shape interface {</p><p class="source-code">  Area() float64</p><p class="source-code">  Name() string</p><p class="source-code">}</p></li>
				<li>Next, we will create <strong class="source-inline">triangle</strong>, <strong class="source-inline">rectangle</strong>, and <strong class="source-inline">square</strong> struct types. These types will each satisfy the <strong class="source-inline">Shape{}</strong> interface. <strong class="source-inline">triangle</strong>, <strong class="source-inline">rectangle</strong>, and <strong class="source-inline">square</strong> have appropriate fields that are needed to calculate the area of the shape:<p class="source-code">type triangle struct {</p><p class="source-code">  base   float64</p><p class="source-code">  height float64</p><p class="source-code">}</p><p class="source-code">type rectangle struct {</p><p class="source-code">  length float64</p><p class="source-code">  width  float64</p><p class="source-code">}</p><p class="source-code">type square struct {</p><p class="source-code">  side float64</p><p class="source-code">}</p></li>
				<li>We create the <strong class="source-inline">Area()</strong> and <strong class="source-inline">Name()</strong> methods for the <strong class="source-inline">triangle</strong> struct type. The area of a triangle is <strong class="source-inline">base * height\2</strong>. The <strong class="source-inline">Name()</strong> method returns the name of the shape:<p class="source-code">func (t triangle) Area() float64 {</p><p class="source-code">  return (t.base * t.height) / 2</p><p class="source-code">}</p><p class="source-code">func (t triangle) Name() string {</p><p class="source-code">  return "triangle"</p><p class="source-code">}</p></li>
				<li>We create the <strong class="source-inline">Area()</strong> and <strong class="source-inline">Name()</strong> methods for the <strong class="source-inline">rectangle</strong> struct type. The area of a rectangle is <strong class="source-inline">length * width</strong>. The <strong class="source-inline">Name()</strong> method returns the name of the shape:<p class="source-code">func (r rectangle) Area() float64 {</p><p class="source-code">  return r.length * r.width</p><p class="source-code">}</p><p class="source-code">func (r rectangle) Name() string {</p><p class="source-code">  return "rectangle"</p><p class="source-code">}</p></li>
				<li>We create the <strong class="source-inline">Area()</strong> and <strong class="source-inline">Name()</strong> methods for the <strong class="source-inline">square</strong> struct type. The area of a square is <strong class="source-inline">side * side</strong>. The <strong class="source-inline">Name()</strong> method returns the name of the shape:<p class="source-code">func (s square) Area() float64 {</p><p class="source-code">  return s.side * s.side</p><p class="source-code">}</p><p class="source-code">func (s square) Name() string {</p><p class="source-code">  return "square"</p><p class="source-code">}</p><p>Now, each of our shapes (<strong class="source-inline">triangle</strong>, <strong class="source-inline">rectangle</strong>, and <strong class="source-inline">square</strong>) satisfies the <strong class="source-inline">Shape</strong> interface because they each have an <strong class="source-inline">Area()</strong> and <strong class="source-inline">Name()</strong> method with the appropriate signatures:</p><div id="_idContainer120" class="IMG---Figure"><img src="image/B14177_07_07.jpg" alt="Figure 7.7: square, triangle, rectangle area of the Shape type&#13;&#10;"/></div><p class="figure-caption">Figure 7.7: square, triangle, rectangle area of the Shape type</p></li>
				<li>We will now create a function that accepts the <strong class="source-inline">Shape</strong> interface as a variadic parameter. The function will iterate over the <strong class="source-inline">Shape</strong> type and will execute each of its <strong class="source-inline">Name()</strong> and <strong class="source-inline">Area()</strong> methods:<p class="source-code">func printShapeDetails(shapes ...Shape) {</p><p class="source-code">  for _, item := range shapes {</p><p class="source-code">    fmt.Printf("The area of %s is: %.2f\n", item.Name(), item.Area())</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Inside the <strong class="source-inline">main()</strong> function, set the fields for <strong class="source-inline">triangle</strong>, <strong class="source-inline">rectangle</strong>, and <strong class="source-inline">square</strong>. Pass all three to the <strong class="source-inline">printShapeDetail()</strong> function. All three can be passed because they each satisfy the <strong class="source-inline">Shape</strong> interface:<p class="source-code">func main() {</p><p class="source-code">  t := triangle{base: 15.5, height: 20.1}</p><p class="source-code">  r := rectangle{length: 20, width: 10}</p><p class="source-code">  s := square{side: 10}</p><p class="source-code">  printShapeDetails(t, r, s)</p><p class="source-code">}</p><p class="source-code">}</p></li>
				<li>Build the program by running <strong class="source-inline">go build</strong> at the command line:<p class="source-code">go build</p></li>
				<li>Correct any errors that are returned and ensure your code matches the code snippet here.</li>
				<li>Run the executable by typing the name of the executable and hit <em class="italic">Enter</em> to run it.<p>You should see the following output:</p><p class="source-code">The area of triangle is: 155.78</p><p class="source-code">The area of rectangle is: 200.00</p><p class="source-code">The area of square is: 100.00</p></li>
			</ol>
			<p>In this exercise, we saw the flexibility and the reusable code that interfaces provide to our programs. Further, we will discuss how accepting interfaces and returning structs for our functions and methods increase code reusability and low coupling by not being dependent on the concrete types. When we use interfaces as input arguments to an API, we are stating that a type needs to satisfy the interface. When using concrete types, we require that the argument for the API must be of that type. For instance, if a function signature is <strong class="source-inline">func greeting(msg string)</strong>, we know that the argument being passed must be a string. Concrete types can be thought of as types that are not abstract (<strong class="source-inline">float64</strong>, <strong class="source-inline">int</strong>, <strong class="source-inline">string</strong>, and so on); however, interfaces could be considered as an abstract type because you are satisfying the method sets of the interface type. The underlying interface type is a concrete type, but the underlying type is not what needs to be passed into the API. The type must meet the requirements of having the method sets the interface type defines.</p>
			<p>In the future, if we require another type to be passed, this will mean the code upstream to our API will need to change, or if the caller of our API needs to change its data type, it might request we change our API to accommodate it. If we use interfaces, this is not an issue; the caller of our code needs to satisfy the interface's method sets. The caller can then change the underlying type as long as it complies with the interface requirements.</p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor231"/>Accepting Interfaces and Returning Structs</h1>
			<p>There is a Go proverb that states "<em class="italic">Accept interfaces, return structs</em>." It can be restated as accept interfaces and return concrete types. This proverb is talking about accepting interfaces for your APIs (functions, methods, and so on) and the return to be structs or concrete types. This proverb follows Postel's Law, which states "<em class="italic">Be conservative with what you do, be liberal with what you accept</em>." We are focusing on the "<em class="italic">be liberal with what you accept</em>." By accepting interfaces, you are increasing the flexibility of the API for your function or method. By doing this, you are allowing for the user of the API to meet the requirements of the interface, but not forcing the user to use a concrete type. If our functions or methods only accept concrete types, then we are limiting the users of our functions to a specific implementation. In this chapter, we are going to explore the previously mentioned Go proverb and learn why it is a good design pattern to follow. We will see that as we go over the code example:</p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B14177_07_08.jpg" alt="Figure 7.8: Benefits of accepting interfaces&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8: Benefits of accepting interfaces</p>
			<p>The following example will illustrate the benefits of accepting interfaces versus using concrete types. We will have two functions that perform the same task of decoding JSON, but each has different inputs. One of these functions is superior to the other, and we will go over the reasons why that is the case.</p>
			<p>Look at the following example:</p>
			<p class="source-code-heading">main.go</p>
			<p class="source-code">1  package main</p>
			<p class="source-code">2  import (</p>
			<p class="source-code">3    "encoding/json"</p>
			<p class="source-code">4    "fmt"</p>
			<p class="source-code">5    "io"</p>
			<p class="source-code">6    "strings"</p>
			<p class="source-code">7  )</p>
			<p class="source-code">8  type Person struct {</p>
			<p class="source-code">9    Name string `json:"name"`</p>
			<p class="source-code">10   Age  int    `json:"age"`</p>
			<p class="source-code">11 }</p>
			<p class="source-code-link">The full code is available at: <a href="https://packt.live/38teYHn">https://packt.live/38teYHn</a><a href="https://github.com/PacktWorkshops/The-Go-Workshop/blob/eb27021c9a72841c04dcd9f9935fd86780a86478/Chapter07/Examples/main.go#L1-L41 "/></p>
			<p>The expected output is as follows:</p>
			<p class="source-code">{Joe 18}</p>
			<p class="source-code">{Jane 21}</p>
			<p>Let's examine each part of this code. We will discuss some parts of this code in the upcoming chapters. This code decodes some data into a struct. There are two functions being used for that purpose, <strong class="source-inline">loadPerson2()</strong> and <strong class="source-inline">loadPerson()</strong>:</p>
			<p class="source-code">func loadPerson2(s string) (Person, error) {</p>
			<p class="source-code">  var p Person</p>
			<p class="source-code">  err := json.NewDecoder(strings.NewReader(s)).Decode(&amp;p)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">  return p, err</p>
			<p class="source-code">  }</p>
			<p class="source-code">  return p, nil</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">loadPerson2()</strong> function accepts an argument that is a concrete <strong class="source-inline">string</strong> and returns a <strong class="source-inline">struct</strong>. The returning of the struct meets half of "<em class="italic">accept interfaces</em>, <em class="italic">return structs</em>". However, it is very limited and not liberal in what it accepts. This limits the user of the function to a narrow implementation. The only thing that can ever be passed is a string. Granted, in some cases that might be acceptable, but in other situations, it could be a problem. For example, if your function or method should only accept a specific data type, then you may not want to accept interfaces:</p>
			<p class="source-code">func loadPerson(r io.Reader) (Person, error) {</p>
			<p class="source-code">  var p Person</p>
			<p class="source-code">  err := json.NewDecoder(r).Decode(&amp;p)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    return p, err</p>
			<p class="source-code">  }</p>
			<p class="source-code">  return p, err</p>
			<p class="source-code">}</p>
			<p>In this function, we are accepting the <strong class="source-inline">io.Reader{}</strong> interface. The <strong class="source-inline">io.Reader{}</strong> (<a href="https://packt.live/2LRG3Kv">https://packt.live/2LRG3Kv</a>) and <strong class="source-inline">io.Writer{}</strong> (<a href="https://packt.live/2YIAJhP">https://packt.live/2YIAJhP</a>) interfaces are among the most utilized interfaces in Go packages. <strong class="source-inline">json.NewDecoder</strong> accepts anything that satisfies the <strong class="source-inline">io.Reader{}</strong> interface. The caller code just needs to make sure whatever they pass satisfies the <strong class="source-inline">io.Reader{}</strong> interface:</p>
			<p class="source-code">p, err := loadPerson(strings.NewReader(s))</p>
			<p><strong class="source-inline">strings.NewReader</strong> returns a <strong class="source-inline">Reader</strong> type that has a <strong class="source-inline">Read(b []byte) (n int, err error) </strong>method that satisfies the <strong class="source-inline">io.Reader{}</strong> interface. It can be passed to our <strong class="source-inline">loadPerson()</strong> function. You may be thinking that each function still does what it was intended for. You would be correct, but let's say the caller is no longer going to pass a string, or another caller will be passing a file that contains the JSON data:</p>
			<p class="source-code">f, err := os.Open("data.json")</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">  fmt.Println(err)</p>
			<p class="source-code">}</p>
			<p>Our <strong class="source-inline">loadPerson2()</strong> function would not work; however, our <strong class="source-inline">loadPerson()</strong> data would work because the return type from <strong class="source-inline">os.Open()</strong> satisfies the <strong class="source-inline">io.Reader{}</strong> interface.</p>
			<p>Say, for instance, the data will be coming through an HTTP endpoint. We will be getting the data from <strong class="source-inline">*http.Request</strong>. Again, the <strong class="source-inline">loadPerson2()</strong> function would not be a good choice. We would get the data from <strong class="source-inline">request.Body</strong>, which just so happens to implement the <strong class="source-inline">io.Reader{}</strong> interface.</p>
			<p>You may be wondering if interfaces are good for input arguments. If so, why would we not return them too? If you return an interface, it adds unnecessary difficulty to the user. The user will have to look up the interface to then find the method set and the method sets signature:</p>
			<p class="source-code">func someFunc() Speaker{} {</p>
			<p class="source-code">// code</p>
			<p class="source-code">}</p>
			<p>You would need to look at the definition of the <strong class="source-inline">Speaker{}</strong> interface and then spend time looking at the implementation code, all of which is unnecessary for the user of the function. If an interface is needed from the return type of the function, the user of the function can create the interface for that concrete type and use it in their code.</p>
			<p>As you start to follow this Go proverb, check to see whether there is an interface in the Go standard packages. This will increase the number of different implementations that your function can provide. Our users of the function can have various implementations using <strong class="source-inline">strings.newReader</strong>, <strong class="source-inline">http.Request.Body</strong>, <strong class="source-inline">os.File</strong>, and many others, just like in our code example, by using the <strong class="source-inline">io.Reader{}</strong> interface from the Go standard packages.</p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor232"/>Empty interface{}</h2>
			<p>An empty interface is an interface that has no method sets and no behaviors. An empty interface specifies no methods:</p>
			<p class="source-code">interface{}</p>
			<p>This is a simple but complex concept to wrap your head around. As you may recall, interfaces are implemented implicitly; there is no <strong class="source-inline">implements</strong> keyword. Since an empty interface specifies no methods, that means that every type in Go implements an empty interface automatically. All types satisfy the empty interface.</p>
			<p>In the following code snippet, we will demonstrate how to use the empty interface. We will also see how a function that accepts an empty interface allows any type to be passed to that function:</p>
			<p class="source-code-heading">main.go</p>
			<p class="source-code">1  package main</p>
			<p class="source-code">2  import (</p>
			<p class="source-code">3    "fmt"</p>
			<p class="source-code">4  )</p>
			<p class="source-code">5  type Speaker interface {</p>
			<p class="source-code">6    Speak() string</p>
			<p class="source-code">7  }</p>
			<p class="source-code">8  type cat struct {</p>
			<p class="source-code">9    name string</p>
			<p class="source-code">10 }</p>
			<p class="source-code-link">The full code is available at: <a href="https://packt.live/34dVEdB">https://packt.live/34dVEdB</a><a href="https://github.com/PacktWorkshops/The-Go-Workshop/blob/180a2fea2bc4eaedd2c71b39a072fd39b135c53f/Chapter07/Example3/main.go#L1-L26 "/></p>
			<p>The expected output is as follows:</p>
			<p class="source-code">({oreo}, main.cat)</p>
			<p class="source-code">({oreo}, main.cat)</p>
			<p class="source-code">(99, int)</p>
			<p class="source-code">(false, bool)</p>
			<p class="source-code">(test, string)</p>
			<p>Let's evaluate the code in sections:</p>
			<p class="source-code">func emptyDetails(s <strong class="bold">interface{}</strong>) {</p>
			<p class="source-code">  fmt.Printf("(%v, %T)\n", i, i)</p>
			<p class="source-code">}</p>
			<p>The function accepts an empty <strong class="source-inline">interface{}</strong>. Any type can be passed to the function since all types implement the empty <strong class="source-inline">interface{}</strong>. It prints the value and the concrete type. The <strong class="source-inline">%v</strong> verb prints the value and the <strong class="source-inline">%T</strong> verb prints the concrete type:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  c := cat{name: "oreo"}</p>
			<p class="source-code">  i := 99</p>
			<p class="source-code">  b := false</p>
			<p class="source-code">  str := "test"</p>
			<p class="source-code">  catDetails(c)</p>
			<p class="source-code">  emptyDetails(c)</p>
			<p class="source-code">  emptyDetails(i)</p>
			<p class="source-code">  emptyDetails(b)</p>
			<p class="source-code">  emptyDetails(str)</p>
			<p class="source-code">}</p>
			<p>We pass a <strong class="source-inline">cat</strong> type, <strong class="source-inline">integer</strong>, <strong class="source-inline">bool</strong>, and <strong class="source-inline">string</strong>. The <strong class="source-inline">emptyDetails()</strong> function will print each of them:</p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B14177_07_09.jpg" alt="Figure 7.9: The type cat implements an empty interface and the Speaker interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9: The type cat implements an empty interface and the Speaker interface</p>
			<p>The <strong class="source-inline">cat</strong> type implements the empty <strong class="source-inline">interface{}</strong> and the <strong class="source-inline">Speaker{}</strong> interface implicitly.</p>
			<p>Now that we have a basic understanding of empty interfaces, we will be looking at various use cases for them in the upcoming topics, including the following:</p>
			<ul>
				<li>Type switching</li>
				<li>Type assertion</li>
				<li>Examples of Go packages</li>
			</ul>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor233"/>Type Assertion and Switches</h2>
			<p>Type assertion provides access to an interface's concrete type. Remember that <strong class="source-inline">interface{}</strong> can be any value:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  var str interface{} ="some string"</p>
			<p class="source-code">  var i interface{} = 42</p>
			<p class="source-code">  var b interface{} = true</p>
			<p class="source-code">  fmt.Println(str)</p>
			<p class="source-code">  fmt.Println(i)</p>
			<p class="source-code">  fmt.Println(b)</p>
			<p class="source-code">}</p>
			<p>The type assertion output would look as follows:</p>
			<p class="source-code">some string</p>
			<p class="source-code">42</p>
			<p class="source-code">true</p>
			<p>In each instance of the variable declaration, each variable is declared as an empty interface, but the concrete value for <strong class="source-inline">str</strong> is a string, for <strong class="source-inline">i</strong> is an integer, and for <strong class="source-inline">b</strong> is a Boolean.</p>
			<p>When there is an empty <strong class="source-inline">interface{}</strong> type, sometimes, it is beneficial to know the underlying concrete type. For instance, you may need to perform data manipulation based upon that type. If that type is a string, you would perform data modification and validation different from how you would if it was an integer value. This also comes into play when you are consuming JSON data of an unknown schema. The values in that JSON might be known during the ingesting process. We would need to convert that data to <strong class="source-inline">map[string]interface{}</strong> and perform various data massaging. We have an activity later in this chapter that will show us how to perform such an action. We could perform a type conversion with the <strong class="source-inline">strconv</strong> package:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "strconv"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  var str interface{} ="some string"</p>
			<p class="source-code">  var i interface{} = 42</p>
			<p class="source-code">  fmt.Println(strconv.Atoi(i))</p>
			<p class="source-code">}</p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B14177_07_10.jpg" alt="Figure 7.10: Error when type assertion is needed&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.10: Error when type assertion is needed</p>
			<p>So, it appears we cannot use type conversion because the types are not compatible with type conversion. We will need to use <strong class="source-inline">type</strong> assertion:</p>
			<p class="source-code">v := s.(T)</p>
			<p>The preceding statement says that it asserts that the interface value <strong class="source-inline">s</strong> is of type <strong class="source-inline">T</strong> and assigns the underlying value of <strong class="source-inline">v</strong>:</p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B14177_07_11.jpg" alt="Figure 7.11: Type assertion flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.11: Type assertion flow</p>
			<p>Consider the following code snippet:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "strings"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  var str interface{} ="some string"</p>
			<p class="source-code">  v := str.(string)</p>
			<p class="source-code">  fmt.Println(strings.Title(v))</p>
			<p class="source-code">}</p>
			<p>Let's examine the preceding code:</p>
			<ul>
				<li>The preceding code asserts that <strong class="source-inline">str</strong> is of the <strong class="source-inline">string</strong> type and assigns it to the variable <strong class="source-inline">v</strong>.</li>
				<li>Since <strong class="source-inline">v</strong> is a <strong class="source-inline">string</strong>, it will print it with title casing.</li>
			</ul>
			<p>The result is as follows:</p>
			<p class="source-code">Some String</p>
			<p>It is good when the assertion matches the expected type. So, what will happen if <strong class="source-inline">s</strong> is not of type <strong class="source-inline">T</strong>? Let's take a look:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "strings"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  var str interface{} = 49</p>
			<p class="source-code">  v := str.(string)</p>
			<p class="source-code">  fmt.Println(strings.Title(v))</p>
			<p class="source-code">}</p>
			<p>Let's examine the preceding code:</p>
			<ul>
				<li><strong class="source-inline">str{}</strong> is an empty interface and the concrete type is of <strong class="source-inline">int</strong>.</li>
				<li>The type assertion is checking whether <strong class="source-inline">str</strong> is of the string type, but in this scenario, it is not, so the code will panic.</li>
				<li>The result is as follows:</li>
			</ul>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/B14177_07_12.jpg" alt="Figure 7.12: Failed type assertion&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.12: Failed type assertion</p>
			<p>Having a panic being thrown is not something that is desirable. However, Go has a way to check whether <strong class="source-inline">str</strong> is a string:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  var str interface{} = "the book club"</p>
			<p class="source-code">  v, isValid := str.(int)</p>
			<p class="source-code">  fmt.Println(v, isValid)</p>
			<p class="source-code">}</p>
			<p>Let's examine the preceding code:</p>
			<ul>
				<li>A type assertion returns two values, the underlying value and a Boolean value.</li>
				<li><strong class="source-inline">isValid</strong> is assigned to a return type of <strong class="source-inline">bool</strong>. If it returns <strong class="source-inline">true</strong>, that indicates that <strong class="source-inline">str</strong> is of the <strong class="source-inline">int</strong> type. It means that the assertion is true. We can use the Boolean that was returned to determine what action we can take on <strong class="source-inline">str</strong>.</li>
				<li>When the assertion fails, it will return <strong class="source-inline">false</strong>. The return value will be the zero value that you are trying to assert to. It also will not panic.</li>
			</ul>
			<p>There will be times when you do not know the empty interface concrete type. This is when you will use a type switch. A type switch can perform several types of assertions; it is similar to a regular switch statement. It has a case and default clauses. The difference is that type switch statements evaluate for a type rather than a value.</p>
			<p>Here is a basic syntax structure:</p>
			<p class="source-code">switch v:= i.(type){</p>
			<p class="source-code">case S:</p>
			<p class="source-code">  // code to act upon the type S</p>
			<p class="source-code">}</p>
			<p>Let's examine the preceding code:</p>
			<p class="source-code">i.(type)</p>
			<p>The syntax is similar to that of the type assertion, <strong class="source-inline">i.(int)</strong>, except the specified type, <strong class="source-inline">int</strong> in our example, is replaced with the <strong class="source-inline">type</strong> keyword. The type being asserted of type <strong class="source-inline">i</strong> is assigned to <strong class="source-inline">v</strong>; then, it is compared to each of the <strong class="source-inline">case</strong> statements.</p>
			<p class="source-code">case S:</p>
			<p>In the <strong class="source-inline">switch</strong> type, the statements evaluate for types. In regular switching, they evaluate for values. Here, it is evaluated for a type of <strong class="source-inline">S</strong>.</p>
			<p>Now that we have a fundamental understanding of the type switch statement, let's look at an example that uses the syntax we have just evaluated:</p>
			<p class="source-code-heading">main.go</p>
			<p class="source-code">13 func typeExample(i []interface{}) {</p>
			<p class="source-code">14   for _, x := range i {</p>
			<p class="source-code">15     switch v := x.(type) {</p>
			<p class="source-code">16     case int:</p>
			<p class="source-code">17       fmt.Printf("%v is int\n", v)</p>
			<p class="source-code">18     case string:</p>
			<p class="source-code">19       fmt.Printf("%v is a string\n",v)</p>
			<p class="source-code">20     case bool:</p>
			<p class="source-code">21       fmt.Printf("a bool %v\n", v)</p>
			<p class="source-code">22     default:</p>
			<p class="source-code">23       fmt.Printf("Unknown type %T\n", v)</p>
			<p class="source-code">24     }</p>
			<p class="source-code">25   }</p>
			<p class="source-code">26 }</p>
			<p class="source-code-link">The full code is available at: <a href="https://packt.live/38xWEwH">https://packt.live/38xWEwH</a><a href="https://github.com/PacktWorkshops/The-Go-Workshop/blob/1b3e861e2fc0a9d204c25818dfc2691427c1c514/Chapter07/Example2/main.go#L1-L26 "/></p>
			<p>Let's now explore the code in pieces:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  c:=cat{name:"oreo"}</p>
			<p class="source-code">  i := []interface{}{42, "The book club", true,c}</p>
			<p class="source-code">  typeExample(i)</p>
			<p class="source-code">}</p>
			<p>In the <strong class="source-inline">main()</strong> function, we are initializing a variable, <strong class="source-inline">i</strong>, to a slice of interfaces. In the slice, we have the <strong class="source-inline">int</strong>, <strong class="source-inline">string</strong>, <strong class="source-inline">bool</strong>, and <strong class="source-inline">cat</strong> types:</p>
			<p class="source-code">func typeExample(i []interface{})</p>
			<p>The function accepts a slice of interfaces:</p>
			<p class="source-code">  for _, x := range i {</p>
			<p class="source-code">    switch v := x.(type) {</p>
			<p class="source-code">    case int:</p>
			<p class="source-code">      fmt.Printf("%v is int\n", v)</p>
			<p class="source-code">    case string:</p>
			<p class="source-code">      fmt.Printf("%v is a string\n",v)</p>
			<p class="source-code">    case bool:</p>
			<p class="source-code">      fmt.Printf("a bool %v\n", v)</p>
			<p class="source-code">    default:</p>
			<p class="source-code">      fmt.Printf("Unknown type %T\n", v)</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p>The <strong class="source-inline">for</strong> loop ranges over the slice of interfaces. The first value in the slice is 42. The <strong class="source-inline">switch</strong> case asserts that the slice value of 42 is an <strong class="source-inline">int</strong> type. The <strong class="source-inline">case int</strong> statement will evaluate to <strong class="source-inline">true</strong>, and print 42 is <strong class="source-inline">int</strong>. When the <strong class="source-inline">for</strong> loop iterates over the last value of the <strong class="source-inline">cat</strong> type, the <strong class="source-inline">switch</strong> statement will not find that type in its case evaluations. Since there is no <strong class="source-inline">cat</strong> type being checked for in the <strong class="source-inline">case</strong> statements, the default will execute its print statement. Here are the results of the code being executed:</p>
			<p class="source-code">42 is int</p>
			<p class="source-code">The book club is string</p>
			<p class="source-code">a bool true</p>
			<p class="source-code">Unknown type main.cat</p>
			<h2 id="_idParaDest-223"><a id="_idTextAnchor234"/>Exercise 7.03: Analyzing Empty interface{} Data</h2>
			<p>In this exercise, we are given a map. The map's key is a string and its value is an empty <strong class="source-inline">interface{}</strong>. The map's value contains different types of data stored in the value portion of the map. Our job is to determine each key's value type. We are going to write a program that will analyze the data of <strong class="source-inline">map[string]</strong> <strong class="source-inline">interface{}</strong>. Understand that the values of the data can be of any type. We need to write logic to catch types we are not looking for. We are going to store that information in a slice of structs that will hold the key name, data, and the type of data:</p>
			<ol>
				<li value="1">Create a new file called <strong class="source-inline">main.go</strong>.</li>
				<li>Inside the file, we will have a <strong class="source-inline">main</strong> package and will need to import the <strong class="source-inline">fmt</strong> package:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">)</p></li>
				<li>We will create a <strong class="source-inline">struct</strong> called <strong class="source-inline">record</strong> that will store the key, type of value, and data from <strong class="source-inline">map[string]interface{}</strong>. This struct is used to store the analysis that we are performing on the map. The <strong class="source-inline">key</strong> field is the name as the map key. The <strong class="source-inline">valueType</strong> field is storing the type of data stored as a value in the map. The data field stores the data we are analyzing. It is an empty <strong class="source-inline">interface{}</strong>, since there can be various types of data in the map:<p class="source-code">type record struct {</p><p class="source-code">  key       string</p><p class="source-code">  valueType string</p><p class="source-code">  data      interface{}</p><p class="source-code">}</p></li>
				<li>We will create a <strong class="source-inline">person</strong> struct that will be added to our <strong class="source-inline">map[string]interface{}</strong>:<p class="source-code">type person struct {</p><p class="source-code">  lastName  string</p><p class="source-code">  age       int</p><p class="source-code">  isMarried bool</p><p class="source-code">}</p></li>
				<li>We will create an <strong class="source-inline">animal</strong> struct that will be added to our <strong class="source-inline">map[string]interface{}</strong>:<p class="source-code">type animal struct {</p><p class="source-code">  name     string</p><p class="source-code">  category string</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">newRecord()</strong> function. The <strong class="source-inline">key</strong> parameter will be our map's key. The function also takes an <strong class="source-inline">interface{}</strong> as an input parameter. <strong class="source-inline">i</strong> will be our map's value for the key that is passed to the function. It will return a <strong class="source-inline">record</strong> type:<p class="source-code">func newRecord(key string, i interface{}) record {</p></li>
				<li>Inside the <strong class="source-inline">newRecord()</strong> function, we initialize <strong class="source-inline">record{}</strong> and assign it to the <strong class="source-inline">r</strong> variable. We then assign <strong class="source-inline">r.key</strong> to the key input parameter.</li>
				<li>The <strong class="source-inline">switch</strong> statement assigns the type of <strong class="source-inline">i</strong> to the <strong class="source-inline">v</strong> variable. The <strong class="source-inline">v</strong> variable type gets evaluated against a series of <strong class="source-inline">case</strong> statements. If a type evaluates to <strong class="source-inline">true</strong> for one of the <strong class="source-inline">case</strong> statements, then the <strong class="source-inline">valueType</strong> record gets assigned to that type, along with the value of <strong class="source-inline">v</strong> to <strong class="source-inline">r.data</strong>, and then returns the <strong class="source-inline">record</strong> type:<p class="source-code">  r := record{}</p><p class="source-code">  r.key = key</p><p class="source-code">  switch v := i.(type) {</p><p class="source-code">  case int:</p><p class="source-code">    r.valueType = "int"</p><p class="source-code">    r.data = v</p><p class="source-code">    return r</p><p class="source-code">  case bool:</p><p class="source-code">    r.valueType = "bool"</p><p class="source-code">    r.data = v</p><p class="source-code">    return r</p><p class="source-code">  case string:</p><p class="source-code">    r.valueType = "string"</p><p class="source-code">    r.data = v</p><p class="source-code">    return r</p><p class="source-code">  case person:</p><p class="source-code">    r.valueType = "person"</p><p class="source-code">    r.data = v</p><p class="source-code">    return r</p></li>
				<li>A <strong class="source-inline">default</strong> statement is needed for the <strong class="source-inline">switch</strong> statement. If the type of <strong class="source-inline">v</strong> does not get evaluated to <strong class="source-inline">true</strong> in the <strong class="source-inline">case</strong> statements, then <strong class="source-inline">default</strong> will be executed. The <strong class="source-inline">record.valueType</strong> will be marked as <strong class="source-inline">unknown</strong>:<p class="source-code">  default:</p><p class="source-code">    r.valueType = "unknown"</p><p class="source-code">    r.data = v</p><p class="source-code">    return r</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Inside the <strong class="source-inline">main()</strong> function, we will initialize our map. The map is initialized to a string for the key and an empty interface for the value. We then assign <strong class="source-inline">a</strong> to an <strong class="source-inline">animal</strong> struct literal and <strong class="source-inline">p</strong> to a <strong class="source-inline">person</strong> struct literal. Then, we start adding various key-value pairs to the map:<p class="source-code">func main() {</p><p class="source-code">  m := make(map[string]interface{})</p><p class="source-code">  a := animal{name: "oreo", category: "cat"}</p><p class="source-code">  p := person{lastName: "Doe", isMarried: false, age: 19}</p><p class="source-code">  m["person"] = p</p><p class="source-code">  m["animal"] = a</p><p class="source-code">  m["age"] = 54</p><p class="source-code">  m["isMarried"] = true</p><p class="source-code">  m["lastName"] = "Smith"</p></li>
				<li>Next, we initialize a slice of <strong class="source-inline">record</strong>. We iterate over the map and add records to <strong class="source-inline">rs</strong>:<p class="source-code">  rs := []record{}</p><p class="source-code">  for k, v := range m {</p><p class="source-code">    r := newRecord(k, v)</p><p class="source-code">    rs = append(rs, r)</p><p class="source-code">  }</p></li>
				<li>Now, print out the record field values. We range over the slice of records and print each record value:<p class="source-code">  for _, v := range rs {</p><p class="source-code">    fmt.Println("Key: ", v.key)</p><p class="source-code">    fmt.Println("Data: ", v.data)</p><p class="source-code">    fmt.Println("Type: ", v.valueType)</p><p class="source-code">    fmt.Println()</p><p class="source-code">  }</p><p class="source-code">}</p><p>The expected output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/B14177_07_13.jpg" alt="Figure 7.13: Output for the exercise&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.13: Output for the exercise</p>
			<p>The exercise has demonstrated Go's ability to identify the underlying type of an empty interface. As you can see from the results, our type switch was able to identify each type except for the value for the key of <strong class="source-inline">animal</strong>. It has its type marked as <strong class="source-inline">unknown</strong>. Also, it was even able to identify the <strong class="source-inline">person</strong> struct type, and the data has the field values of the struct.</p>
			<h2 id="_idParaDest-224"><a id="_idTextAnchor235"/>Activity 7.01: Calculating Pay and Performance Review</h2>
			<p>In this activity, we are going to calculate the annual pay for a manager and a developer. We will print out the developer's and manager's names and the pay for the year. The developer pay will be based on an hourly rate. The developer type will also keep track of the number of hours they have worked in a year. The developer type will also include their review. The review will need to be a collection of keys of strings. These strings are the category that the developer is being reviewed on, for example, work quality, teamwork, communication, and so on.</p>
			<p>The aim of this activity is to use an interface to demonstrate polymorphism by calling a single function called <strong class="source-inline">payDetails()</strong> that accepts an interface. This <strong class="source-inline">payDetails()</strong> function will print the salary information for a developer type and a manager type.</p>
			<p>The following steps should help you with the solution:</p>
			<ol>
				<li value="1">Create an <strong class="source-inline">Employee</strong> type that has <strong class="source-inline">Id</strong>, <strong class="source-inline">FirstName</strong>, and <strong class="source-inline">LastName</strong> fields.</li>
				<li>Create a <strong class="source-inline">Developer</strong> type that has the following fields: <strong class="source-inline">Individual</strong> of the <strong class="source-inline">Employee</strong> type, <strong class="source-inline">HourlyRate</strong>, <strong class="source-inline">HoursWorkedInYear</strong>, and <strong class="source-inline">Review</strong> of the <strong class="source-inline">map[string]interface{}</strong> type.</li>
				<li>Create a <strong class="source-inline">Manager</strong> type with the following fields: <strong class="source-inline">Individual</strong> of the <strong class="source-inline">Employee</strong> type, <strong class="source-inline">Salary</strong>, and <strong class="source-inline">CommissionRate</strong>.</li>
				<li>Create a <strong class="source-inline">Payer</strong> interface that has a <strong class="source-inline">Pay()</strong> method that returns a <strong class="source-inline">string</strong> and <strong class="source-inline">float64</strong>.</li>
				<li>The <strong class="source-inline">Developer</strong> type should implement the <strong class="source-inline">Payer{}</strong> interface by returning the <strong class="source-inline">Developer</strong> name and returning the developer year pay based on the calculation of <strong class="source-inline">Developer.HourlyRate * Developer.HoursWorkInYear</strong>.</li>
				<li>The <strong class="source-inline">Manager</strong> type should implement the <strong class="source-inline">Payer{}</strong> interface by returning the <strong class="source-inline">Manager</strong> name and returning the <strong class="source-inline">Manager</strong> year pay based on the calculation of <strong class="source-inline">Manager.Salary</strong> + (<strong class="source-inline">Manager.Salary * Manager.CommissionRate</strong>).</li>
				<li>Add a function called <strong class="source-inline">payDetails</strong>(<strong class="source-inline">p Payer</strong>) that accepts a <strong class="source-inline">Payer</strong> interface and prints <strong class="source-inline">fullName</strong> and the pay that is returned from the <strong class="source-inline">Pay()</strong> method.</li>
				<li>We now need to calculate the review rating for a developer. The <strong class="source-inline">Review</strong> is obtained by <strong class="source-inline">map[string]interface{}</strong>. The key of the map is a string; it is what the developer is being rated on, such as work quality, teamwork, skills, and so on.</li>
				<li>The empty <strong class="source-inline">interface{}</strong> of the map is needed because some managers give the rating as a string and others as a number. Here is the mapping of the <strong class="source-inline">string</strong> to the <strong class="source-inline">integer</strong>:<p>"Excellent" – 5</p><p>"Good" – 4</p><p>"Fair" – 3</p><p>"Poor" – 2</p><p>"Unsatisfactory" – 1</p></li>
				<li>We need to calculate the performance review value as a <strong class="source-inline">float</strong> type. It is the sum of the map <strong class="source-inline">interface{}</strong> divided by the length of the map. Take into consideration that the rating can be a string or an integer, so you will need to be able to accept both and convert it to a float.<p>The expected output is as follows:</p><p class="source-code">Eric Davis got a review rating of 2.80</p><p class="source-code">Eric Davis got paid 84000.00 for the year</p><p class="source-code">Mr. Boss got paid 160500.00 for the year</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 715</p></li>
			</ol>
			<p>In this activity, we saw the benefits of using an empty interface that allows us to accept any type of data. We then used type assertion and type switch statements to perform certain tasks based on the underlying concrete type of the empty interface.</p>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor236"/>Summary</h1>
			<p>This <a id="_idTextAnchor237"/>chapter presented some fundamental and advanced topics when using interfaces. We learned that Go's implementation of interfaces has some similarities with other languages; for example, an interface does not contain the implementation details of the behaviors it is representing, and an interface is the blueprint of the methods. The different types that implement the interface can differ in their implementation details. However, Go differs in how you implement an interface compared to other languages. We learned that the implementation is done implicitly and not explicitly, like other languages.</p>
			<p>This concludes that Go does not do subclassing, so, for it to implement polymorphism, it uses interfaces. It allows an interface type to appear in different forms, such as a <strong class="source-inline">Shape</strong> interface appearing as a rectangle, square, or circle.</p>
			<p>We also discussed a design pattern of accept interfaces and return structs. We demonstrated that this pattern allows for broader uses by other callers. We examined the empty interface and saw how it can be used when you do not know the type being passed or when there could be multiple different types being passed to your API. Even though we did not know the type at runtime, we showed you how to use type assertion and type switching to determine the type. The knowledge and practicing of these various tools will help you build robust and fluid programs. </p>
			<p>In the following chapter, we will look at how Go uses packages and how we can use them to further aid in building well-organized and focused code segments.</p>
		</div>
		<div>
			<div id="_idContainer128" class="Content">
			</div>
		</div>
	</body></html>