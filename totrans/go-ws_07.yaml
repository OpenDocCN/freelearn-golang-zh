- en: 7\. Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7. 接口
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter aims to demonstrate the implementation of interfaces in Go. It
    is quite simple compared to other languages because it is done implicitly in Go,
    whereas other languages require interfaces to be implemented explicitly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在展示在 Go 语言中实现接口的过程。与其他语言相比，这相当简单，因为在 Go 中它是隐式实现的，而其他语言则需要显式地实现接口。
- en: In the beginning, you will be able to define and declare an interface for an
    application and implement an interface in your applications. This chapter introduces
    you to use duck typing and polymorphism and accept interfaces and return structs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，你将能够为应用程序定义和声明一个接口，并在你的应用程序中实现接口。本章将向你介绍使用鸭子类型和多态，接受接口并返回结构体。
- en: By the end of this chapter, you will learn to use type assertion to access our
    interface's underlying concrete value, and use the type switch statement.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将学会使用类型断言来访问接口的底层具体值，并使用类型选择语句。
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we discussed error handling in Go. We looked at what
    an error is in Go. We discovered that an error in Go is anything that implements
    the error interface. At the time, we did not investigate what an interface was.
    In this chapter, we are going to look at what an interface is.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了 Go 语言中的错误处理。我们探讨了 Go 中的错误是什么。我们发现，在 Go 中，任何实现了错误接口的东西都可以被视为错误。当时，我们没有深入研究接口是什么。在本章中，我们将探讨接口是什么。
- en: For example, your manager requests that you create an API that can accept JSON
    data. The data contains information about various employees, such as their address
    and the hours they worked on a project. The data will need to be parsed into an
    `employee` struct, a relatively simple task. You then create a function called
    `loadEmployee(s string)`. The function will accept a string that is formatted
    as JSON, and then parse that string to load the `employee` struct.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你的经理要求你创建一个可以接受 JSON 数据的 API。数据包含有关各种员工的信息，例如他们的地址和他们在项目上工作的小时数。数据需要被解析到
    `employee` 结构体中，这是一个相对简单的任务。然后你创建了一个名为 `loadEmployee(s string)` 的函数。该函数将接受一个格式为
    JSON 的字符串，然后将该字符串解析以加载 `employee` 结构体。
- en: Your manager is happy with the work; however, he has another requirement. The
    clients need the ability to accept a file with the employee data in JSON format.
    The functionality to be performed is the same underlying task as before. You create
    another function called `loadEmployeeFromFile(f *os.File)` that reads the data
    from the file, parses the data, and loads the employee struct.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你的经理对你的工作感到满意；然而，他还有另一个要求。客户需要能够接受一个包含员工数据的 JSON 格式文件。要执行的功能与之前相同。你创建了一个名为 `loadEmployeeFromFile(f
    *os.File)` 的另一个函数，该函数从文件中读取数据，解析数据并加载员工结构体。
- en: Your manager has yet another requirement that the employee data should now also
    come from an HTTP endpoint. You will need to be able to read the data from the
    HTTP request, so you create another function called `loadEmployeeFromHTTP(r *Request)`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你的经理还有另一个要求，即员工数据现在也应来自 HTTP 端点。你需要能够从 HTTP 请求中读取数据，因此你创建了一个名为 `loadEmployeeFromHTTP(r
    *Request)` 的另一个函数。
- en: All three functions that were written have a common behavior that they are performing.
    They all need to be able to read the data. The underlying type could be different
    (such as `string`, `os.File`, or `http.Request`) but the behavior, or reading
    the data, is the same in all cases.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的三个函数都有一个共同的行为，即它们正在执行的操作。它们都需要能够读取数据。底层类型可能不同（例如 `string`、`os.File` 或 `http.Request`），但在所有情况下，行为，或者说读取数据，都是相同的。
- en: The `func loadEmployee(s string)`, `func loadEmployeeFromFile(f *os.File)`,
    and `func loadEmployeeFromHTTP(r *Request)` functions can all be replaced using
    an interface, `func loadEmployee (r io.Reader)`. `io.Reader` is an interface,
    and we will discuss it in more depth later in the chapter, but for now, it is
    enough to say it can be used to solve the given problem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`func loadEmployee(s string)`、`func loadEmployeeFromFile(f *os.File)` 和 `func
    loadEmployeeFromHTTP(r *Request)` 这三个函数都可以使用一个接口 `func loadEmployee (r io.Reader)`
    来替换。`io.Reader` 是一个接口，我们将在本章后面更深入地讨论它，但就目前而言，只需说它可以用来解决给定的问题。'
- en: In this chapter, we will see how interfaces can solve such a problem; by defining
    the behavior that is being performed as an interface type, we can accept any underlying
    concrete type. Don't worry if that does not make sense right now; it will start
    to become clearer as we progress in this chapter. We will discuss how interfaces
    give us the ability to perform duck typing and polymorphism. We will see how accepting
    interfaces and returning structs will decrease coupling and increase the use of
    functions in more areas of our programs. We will also examine the empty interface
    and discuss use cases to fully utilize it, along with type assertion and type
    switch statements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到接口如何解决此类问题；通过将正在执行的行为定义为接口类型，我们可以接受任何底层具体类型。如果现在这还不清楚，请不要担心；随着本章的深入，它将开始变得清晰。我们将讨论接口如何使我们能够执行鸭子类型和多态。我们将看到接受接口和返回结构体如何减少耦合并增加函数在我们程序更多区域的使用。我们还将检查空接口，并讨论使用案例以充分利用它，包括类型断言和类型选择语句。
- en: Interface
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: An interface is a set of methods that describe the behavior of the data type.
    Interfaces define the behavior(s) of the type that must be satisfied to implement
    that interface. A behavior describes what that type can do. Almost everything
    exhibits certain behavior. For example, a cat can meow, walk, jump, and purr.
    All of those are behaviors of a cat. A car can start, stop, turn, and speed up.
    All of those are behaviors of a car. Similarly, behaviors for types are called
    methods.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是一组描述数据类型行为的函数。接口定义了实现该接口必须满足的行为。行为描述了该类型可以做什么。几乎一切事物都表现出某些行为。例如，猫可以喵喵叫、行走、跳跃和咕噜咕噜。所有这些都是猫的行为。汽车可以启动、停止、转弯和加速。所有这些都是汽车的行为。同样，类型的行为被称为方法。
- en: Note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The definition that the [https://packt.live/2qOtKrd](https://packt.live/2qOtKrd)
    provides is "Interfaces in Go provide a way to specify the behavior of an object."
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.live/2qOtKrd](https://packt.live/2qOtKrd)提供的定义是：“Go中的接口提供了一种指定对象行为的方式。”'
- en: 'There are several ways to describe an interface:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 描述接口有几种方式：
- en: 'A collection of method signatures is methods with only the name of the method,
    its arguments, types and a return type. This is an example of a collection of
    method signatures for the `Speaker{}` interface:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法签名集合是一组只有方法名称、参数、类型和返回类型的方法。这是`Speaker{}`接口方法签名集合的一个例子：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Blueprints of the type's methods are needed to satisfy the interface. Using
    the `Speaker{}` interface, the blueprint (interface) states that to satisfy the
    `Speaker{}` interface, the type must have a `Speak()` method that accepts a `string`
    and returns a `string`. It also must have a `Greet()` method that returns a `string`.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类型的实现方法蓝图是满足接口所需的。使用`Speaker{}`接口，蓝图（接口）声明，为了满足`Speaker{}`接口，该类型必须有一个接受`string`并返回`string`的`Speak()`方法。它还必须有一个返回`string`的`Greet()`方法。
- en: 'Behaviors are what the interface type must exhibit. For example, the `Reader{}`
    interface has a `Read` method. Its behavior is the reading of data and the Go
    standard library''s `Reader{}` interface:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为是接口类型必须表现出的。例如，`Reader{}`接口有一个`Read`方法。它的行为是读取数据，以及Go标准库的`Reader{}`接口：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Interfaces can be described as having no implementation details. The `Reader{}`
    interface only contains the signature of the method but not the method's code.
    The implementer of the interface has the responsibility of providing the code
    or implementation details, not the interfaces themselves.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口可以描述为没有实现细节。`Reader{}`接口只包含方法的签名，但不包含方法的代码。接口的实现者有责任提供代码或实现细节，而不是接口本身。
- en: 'Behaviors of a type can be as follows:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类型的行为可以是以下几种：
- en: '`Read()`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Read()`'
- en: '`Write()`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Write()`'
- en: '`Save()`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Save()`'
- en: These behaviors are collectively called **methods sets**. A behavior is defined
    by a set of methods. A method set is a group of method(s). These method sets comprise
    the method name, any input parameters, and any return types.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行为统称为**方法集**。行为由一组方法定义。方法集是一组方法。这些方法集包括方法名称、任何输入参数和任何返回类型。
- en: '![Figure 7.1: Graphic representation of interface elements'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1：接口元素的图形表示]'
- en: '](img/B14177_07_01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1：接口元素的图形表示](img/B14177_07_01.jpg)'
- en: 'Figure 7.1: Graphic representation of interface elements'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：接口元素的图形表示
- en: When we are talking about behaviors, note that we did not discuss the implementation
    details. Implementation details are omitted when you define an interface. It is
    important to understand that no implementation is specified or enforced in the
    declaration of an interface. Each type that we create that implements an interface
    can have its own implementation details. An interface that has a method called
    `Greeting()` can be implemented in different ways by various types. A struct type
    of person can implement `Greeting()` in a different way than a struct type of
    animal. Interfaces focus on the behaviors that the type must exhibit. It is not
    the job of the interface to provide method implementations. That is the job of
    the type that is implementing the interface. The types, usually a struct, contain
    the implementation details of the method sets. Now that we have a basic understanding
    of an interface, in the next topic, we will be looking at how to define an interface.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论行为时，请注意我们没有讨论实现细节。定义接口时省略了实现细节。重要的是要理解，接口声明中未指定或强制实施任何实现。我们创建的每个实现接口的类型都可以有自己的实现细节。一个名为
    `Greeting()` 的方法可以通过不同的方式由各种类型实现。人的结构体类型可以以不同于动物的结构体类型的方式实现 `Greeting()`。接口关注的是类型必须展示的行为。接口的职责不是提供方法实现。这是实现接口的类型的工作。类型，通常是结构体，包含方法集的实现细节。现在我们已对接口有了基本了解，在下一个主题中，我们将探讨如何定义接口。
- en: Defining an Interface
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义接口
- en: 'Defining an interface involves the following steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 定义接口包括以下步骤：
- en: '![Figure 7.2: Defining an interface'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2：定义接口'
- en: '](img/B14177_07_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_07_02.jpg](img/B14177_07_02.jpg)'
- en: 'Figure 7.2: Defining an interface'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：定义接口
- en: 'Here is an example of declaring an interface:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是声明接口的一个例子：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s look at each part of this declaration:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个声明的每个部分：
- en: Start with the `type` keyword, followed by the name, and then the `interface`
    keyword.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `type` 关键字开始，然后是名称，然后是 `interface` 关键字。
- en: We are defining an interface type called `Speaker{}`. It is idiomatic in Go
    to name the interface with an `er` suffix. If it is a one-method interface, it
    is typical to name the interface after that one method.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在定义一个名为 `Speaker{}` 的接口类型。在Go中，用 `er` 后缀命名接口是惯用的。如果是一个单方法接口，通常将接口命名为那个方法。
- en: Next, you define the method set. Defining an interface type specifies the method(s)
    that belong to it. In this interface, we are declaring an interface type that
    has one method called `Speak()` and it returns a string.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，你定义方法集。定义接口类型指定了属于它的方法（们）。在这个接口中，我们声明了一个接口类型，它有一个名为 `Speak()` 的方法，并返回一个字符串。
- en: The method set of the `Speaker{}` interface is `Speak()`.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Speaker{}` 接口的方法集是 `Speak()`。'
- en: 'Here is an interface that is used frequently in Go:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在Go中经常使用的接口：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s look at the parts of this code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这段代码的各个部分：
- en: The interface name is `Reader{}`.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口名称是 `Reader{}`。
- en: The method set is `Read()`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法集是 `Read()`。
- en: The signature of the `Read()` method is `(p []byte)(n int, err error)`.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Read()` 方法的签名是 `(p []byte)(n int, err error)`。'
- en: 'Interfaces can have more than one method as its method set. Let''s look at
    an interface used in the Go package:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以有多个方法作为其方法集。让我们看看Go包中使用的接口：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, `FileInfo{}` has multiple methods.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`FileInfo{}` 有多个方法。
- en: In summary, interfaces are types that declare method sets. Similar to other
    languages that utilize interfaces, they do not implement the method sets. Implementation
    details are not part of defining an interface. In the next topic, we will be looking
    at what Go requires for you to be able to implement the interface.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，接口是声明方法集的类型。与其他使用接口的语言类似，它们不实现方法集。实现细节不是定义接口的一部分。在下一个主题中，我们将探讨Go要求你能够实现接口的条件。
- en: Implementing an Interface
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现接口
- en: 'Interfaces in other programming languages implement an interface explicitly.
    Explicit implementation means that the programming language directly and clearly
    states that this object is using this interface. For example, this is in Java:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 其他编程语言中的接口明确实现接口。明确实现意味着编程语言直接且清晰地声明该对象正在使用此接口。例如，这是在Java中：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Dog` class will be implemented by the `Pet` interface. The code segment
    explicitly states that the `Dog` class will implement `Pet`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dog` 类将通过 `Pet` 接口实现。代码段明确指出 `Dog` 类将实现 `Pet`。'
- en: 'In Go, interfaces are implemented implicitly. This means that a type will implement
    the interface by having all the methods and their signature of the interface.
    Here is an example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，接口是隐式实现的。这意味着一个类型将通过具有接口的所有方法和它们的签名来实现接口。以下是一个例子：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s break this code down into parts:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这段代码分解成几个部分：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We are defining a `Speaker{}` interface. It has one method that describes the
    `Speak()`behavior. The method returns a string. For a type to implement the `Speaker{}`
    interface, it must have the method listed in the interface declaration. Then,
    we create an empty struct type called `cat`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在定义一个`Speaker{}`接口。它有一个描述`Speak()`行为的方法。该方法返回一个字符串。为了实现`Speaker{}`接口，类型必须具有接口声明中列出的方法。然后，我们创建一个名为`cat`的空结构体类型：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `cat` type has a `Speak()` method that returns the string. This satisfies
    the `Speaker{}` interface. It is now the responsibility of the implementer of
    `cat` to provide the implementation details for the cat type's `Speak()` method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`类型有一个返回字符串的`Speak()`方法。这满足了`Speaker{}`接口。现在，`cat`类型的实现者有责任提供`Speak()`方法的实现细节。'
- en: Notice that there was no explicit statement that declares `cat` implements the
    `Speaker{}` interface; it does so by just having met the requirements of the interface.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有显式声明`cat`实现了`Speaker{}`接口；它只是通过满足接口的要求来实现。
- en: It is also important to notice that the `cat` type has a method called `Greeting()`.
    The type can have methods that are not needed to satisfy the `Speaker{}` interface.
    However, the cat must have at least the required method sets to be able to satisfy
    the interface.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 还很重要的一点是，`cat`类型有一个名为`Greeting()`的方法。类型可以拥有不需要满足`Speaker{}`接口的方法。然而，猫必须至少有满足接口所需的方法集。
- en: 'The output will be as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Advantages of Implementing Interfaces Implicitly
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式实现接口的优势
- en: There are some advantages to implementing interfaces implicitly. We have seen
    that when you create an interface, you have to go to each type and explicitly
    state that the type implements the interface. In Go, the type that satisfies the
    interface is said to implement it. There is no `implements` keyword like in other
    languages; you do not need to say that a type implements the interface. In Go,
    if it has the method sets and signatures of the interface, it implicitly implements
    the interface.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式实现接口有一些优势。我们看到了当你创建一个接口时，你必须访问每个类型并明确声明该类型实现了接口。在Go中，满足接口的类型被认为是实现了它。没有像其他语言那样的`implements`关键字；你不需要声明一个类型实现了接口。在Go中，如果它具有接口的方法集和签名，它就隐式地实现了接口。
- en: When you change the method sets of an interface, in other languages you would
    have to go to all those types that did not satisfy the interface and remove the
    explicit declaration for the type. This is not the case in Go, since it is an
    implicit declaration.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更改接口的方法集时，在其他语言中，你可能需要访问所有那些不满足接口的类型，并移除对类型的显式声明。但在Go中并非如此，因为它是隐式声明。
- en: Another advantage is you can write interfaces for types that are in another
    package. This decouples the definition of an interface from its implementation.
    We will discuss packages and their scope in *Chapter 8*, *Packages*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优势是你可以为另一个包中的类型编写接口。这解耦了接口定义与其实现。我们将在*第8章*，*包*中讨论包及其作用域。
- en: 'Let''s look at an example of using an interface from a different package in
    our main package. The `Stringer` interface is an interface that is in the Go language.
    It is used by several packages through the Go language. One example is the `fmt`
    package, which is used for formatting when printing values:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在主包中如何使用来自不同包的接口的例子。`Stringer`接口是Go语言中的一个接口。它通过Go语言被几个包使用。一个例子是`fmt`包，它用于打印值时的格式化：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`Stringer` is an interface that is a type that can describe itself as a string.
    Interface names typically follow the method name but with the addition of the
    `er` suffix:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stringer`是一个可以描述自身为字符串的接口类型。接口名称通常遵循方法名称，但添加了`er`后缀：'
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s break down this code into parts:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这段代码分解成几个部分：
- en: We have added a `String()` method to our `cat` type. It returns the field data
    for `name` and `age`.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为`cat`类型添加了一个`String()`方法。它返回`name`和`age`字段的值。
- en: When we call the `fmt.Println()` method in `main()` with the argument of `cat`,
    `fmt.Println()` calls the `String()` method on the `cat` type.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们在`main()`中调用`fmt.Println()`方法，并使用`cat`作为参数时，`fmt.Println()`会在`cat`类型上调用`String()`方法。
- en: 'Our `cat` type now implements two interfaces; the `Speaker{}` interface and
    the `Stringer{}` interface. It has the methods required to satisfy both of those
    interfaces:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的`cat`类型现在实现了两个接口；`Speaker{}`接口和`Stringer{}`接口。它具有满足这两个接口所需的方法：
- en: '![Figure 7.3: Types can implement multiple interfaces'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3：类型可以实现多个接口'
- en: '](img/B14177_07_03.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_07_03.jpg)'
- en: 'Figure 7.3: Types can implement multiple interfaces'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：类型可以实现多个接口
- en: 'Exercise 7.01: Implementing an Interface'
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习7.01：实现接口
- en: 'In this exercise, we are going to create a simple program that demonstrates
    how to implement interfaces implicitly. We will have a `person` struct that will
    implicitly implement the `Speaker{}` interface. The `person` struct will contain
    `name`, `age`, and `isMarried` as its fields. The program will call the `Speak()`
    method of our `person` struct and display a message displaying the `person` struct''s
    `name`. The `person` struct will also satisfy the requirements for the `Stringer{}`
    interface by having a `String()` method. You may recall previously, in the *Advantages
    of Implementing Interfaces Implicitly* section, that the `Stringer{}` interface
    is an interface that is in the Go language. It can be used for formatting when
    printing values. That is how we are going to use it in this exercise to format
    the printing of the fields of the `person` struct:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个简单的程序，演示如何隐式实现接口。我们将有一个`person`结构体，它将隐式实现`Speaker{}`接口。`person`结构体将包含`name`、`age`和`isMarried`作为其字段。程序将调用我们的`person`结构体的`Speak()`方法，并显示一个显示`person`结构体`name`的消息。`person`结构体还将通过拥有一个`String()`方法来满足`Stringer{}`接口的要求。你可能还记得，在*隐式实现接口的优势*部分，`Stringer{}`接口是Go语言中的一个接口。它可以在打印值时用于格式化。这就是我们在这个练习中将如何使用它来格式化`person`结构体字段的打印：
- en: Create a new file and save it as `main.go`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件，并将其保存为`main.go`。
- en: 'We will have `package` `main` and will be using the `fmt` package in this program:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将拥有`package` `main`，并将在这个程序中使用`fmt`包：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Create a `Speaker{}` interface with a method called `Speak()` that returns
    a string:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Speak()`的方法的`Speaker{}`接口，该方法返回一个字符串：
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We have created a `Speaker{}` interface. Any type that wants to implement our
    `Speaker{}` interface must have a `Speak()` method that returns a string.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经创建了一个`Speaker{}`接口。任何想要实现我们的`Speaker{}`接口的类型都必须有一个返回字符串的`Speak()`方法。
- en: 'Create our `person` struct with `name`, `age`, and `isMarried` as its fields:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的`person`结构体，其中包含`name`、`age`和`isMarried`作为其字段：
- en: '[PRE14]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our `person` type contains `name`, `age`, and `isMarried` fields. We will later
    print the contents of these fields in our `main` function using a `Speak()` method
    that returns a string. Having a `Speak()` method will satisfy the `Speaker{}`
    interface.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的`person`类型包含`name`、`age`和`isMarried`字段。我们将在`main`函数中使用一个返回字符串的`Speak()`方法来打印这些字段的值。拥有一个`Speak()`方法将满足`Speaker{}`接口。
- en: 'In the `main()` function, we will initialize a person type, print the `Speak()`
    method, and print the `person` field values:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们将初始化一个`person`类型，打印`Speak()`方法，并打印`person`字段值：
- en: '[PRE15]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a `String()` method for `person` and return a string value. This will
    satisfy the `Stringer{}` interface, which will now allow it to be called by the
    `fmt.Println()` method:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`person`创建一个`String()`方法并返回一个字符串值。这将满足`Stringer{}`接口，现在它可以通过`fmt.Println()`方法被调用：
- en: '[PRE16]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create a `Speak()` method for `person` that returns a string. The `person`
    type has a `Speak()` method that has the same signature as the `Speak()` method
    of the `Speaker{}` interface. The `person` type satisfies the `Speaker{}` interface
    by having a `Speak()` method that returns the string. To satisfy interfaces, you
    must have the same methods and method signatures of the interface:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`person`创建一个返回字符串的`Speak()`方法。`person`类型有一个与`Speaker{}`接口的`Speak()`方法具有相同签名的`Speak()`方法。`person`类型通过拥有一个返回字符串的`Speak()`方法来满足`Speaker{}`接口。为了满足接口，你必须有与接口相同的方法和方法签名：
- en: '[PRE17]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Open the terminal and navigate to the code's directory.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并导航到代码目录。
- en: Run `go build`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`go build`。
- en: Correct any errors that are returned and ensure your code matches the code snippet
    here.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修正返回的错误，并确保你的代码与这里的代码片段匹配。
- en: Run the executable by typing the executable name in the command line.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在命令行中输入可执行文件名来运行可执行文件。
- en: 'You should get the following output:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '[PRE18]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this exercise, we saw how simple it is to implement interfaces implicitly.
    In the next topic, we will build on this by having different data types, such
    as structs, implement the same interface, which can be passed to any function
    that has the argument of that type of interface. We will go into greater detail
    of how that is possible in the next topic and see why it is a benefit for a type
    to appear in various forms.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了隐式实现接口是多么简单。在下一个主题中，我们将通过让不同的数据类型，如结构体，实现相同的接口，并将这些接口传递给任何具有该接口类型的参数的函数来进一步探讨。我们将在下一个主题中更详细地探讨这是如何可能的，并了解为什么类型以各种形式出现是一个好处。
- en: Duck Typing
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鸭子类型
- en: 'We have been basically doing what is called duck typing. Duck typing is a test
    in computer programming: "*If it looks like a duck, swims like a duck, and quacks
    like a duck, then it must be a duck.*" If a type matches an interface, then you
    can use that type wherever that interface is used. Duck typing is matching a type
    based upon methods, rather than the expected type:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在做的是所谓的鸭子类型。鸭子类型是计算机编程中的一个测试：“*如果它看起来像鸭子，游泳像鸭子，嘎嘎叫像鸭子，那么它一定是一只鸭子。*”如果一个类型匹配一个接口，那么你可以在使用该接口的任何地方使用该类型。鸭子类型是基于方法匹配类型，而不是预期的类型：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Anything that matches the `Speak()` method can be a `Speaker{}` interface.
    When implementing an interface, we are essentially conforming to that interface
    by having the required method sets:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 任何匹配`Speak()`方法的都可以是`Speaker{}`接口。在实现接口时，我们本质上是通过拥有所需的方法集来符合该接口：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`cat` matches the `Speak()` method of the `Speaker{}` interface, so a `cat`
    is a `Speaker{}`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`匹配`Speaker{}`接口的`Speak()`方法，所以`cat`是`Speaker{}`：'
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s examine this code in parts:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分部分来检查这段代码：
- en: In the preceding code, we declare a `cat` type and create a method for the `cat`
    type called `Speak()`. This fulfills the required method sets for the `Speaker{}`
    interface.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们声明了一个`cat`类型，并为`cat`类型创建了一个名为`Speak()`的方法。这满足了`Speaker{}`接口所需的方法集。
- en: We create a method called `chatter` that takes the `Speaker{}` interface as
    an argument.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`chatter`的方法，它接受`Speaker{}`接口作为参数。
- en: In the `main()` function, we are able to pass a `cat` type into the `chatter`
    function, which can evaluate to the `Speaker{}` interface This satisfies the required
    method sets for the interface.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们可以将`cat`类型传递给`chatter`函数，该函数可以评估为`Speaker{}`接口。这满足了接口所需的方法集。
- en: Polymorphism
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: 'Polymorphism is the ability to appear in various forms. For example, a shape
    can appear as a square, circle, rectangle, or any other shape:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是能够以各种形式出现的能力。例如，一个形状可以表现为正方形、圆形、矩形或任何其他形状：
- en: '![Figure 7.4: Polymorphism example for shape'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4：形状的多态示例'
- en: '](img/B14177_07_04.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_07_04.jpg)'
- en: 'Figure 7.4: Polymorphism example for shape'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：形状的多态示例
- en: Go does not do subclassing like other object-oriented languages because Go does
    not have classes. Subclassing in object-oriented programming is inheriting from
    one class to another. By doing subclassing, you are inheriting the fields and
    methods of another class. Go provides a similar behavior through embedding structs
    and by using polymorphism through interfaces.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言不像其他面向对象的语言那样进行子类化，因为Go没有类。面向对象编程中的子类化是从一个类继承到另一个类。通过子类化，你继承了另一个类的字段和方法。Go通过嵌入结构和通过接口使用多态提供了类似的行为。
- en: One of the advantages of using polymorphism is that it allows the reuse of methods
    that have been written once and tested. Code is reused by having an API that accepts
    an interface; if our type satisfies that interface, it can be passed to that API.
    There is no need to write additional code for each type; we just need to ensure
    we meet the interface method's set requirements. Obtaining polymorphism through
    the use of interfaces will increase the reusability of the code. If your API only
    accepts concrete types such as `int`, `float`, and `bool`, only that concrete
    type can be passed. However, if your API accepts an interface, then the caller
    can add the required method sets to satisfy that interface regardless of the underlying
    type. This reusability is accomplished by allowing your APIs to accept interfaces.
    Any type that satisfies the interface can be passed to the API. We have seen this
    type of behavior in a previous example. This is a good time to take a closer look
    at the `Speaker{}` interface.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多态的一个优点是它允许重用已经编写并测试过的方法。通过接受一个接口的API来重用代码；如果我们的类型满足该接口，则可以将其传递给该API。不需要为每个类型编写额外的代码；我们只需要确保我们满足接口方法的要求集。通过使用接口获得的多态性将提高代码的可重用性。如果你的API只接受`int`、`float`和`bool`等具体类型，则只能传递该具体类型。然而，如果你的API接受一个接口，那么调用者可以添加所需的方法集以满足该接口，无论底层类型如何。这种可重用性是通过允许你的API接受接口来实现的。任何满足接口的类型都可以传递给API。我们已经在之前的例子中看到了这种行为。现在是时候更仔细地看看`Speaker{}`接口了。
- en: 'As we have seen in previous examples, each concrete type can implement one
    or more interfaces. Recall that our `Speaker{}` interface can be implemented by
    a `dog`, `cat`, or `fish` type:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的例子中看到的，每个具体类型都可以实现一个或多个接口。回想一下，我们的`Speaker{}`接口可以被`dog`、`cat`或`fish`类型实现：
- en: '![Figure 7.5: The Speaker interface implemented by multiple types'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5：由多个类型实现的Speaker接口](img/B14177_07_05.jpg)'
- en: '](img/B14177_07_05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.5: The Speaker interface implemented by multiple types](img/B14177_07_05.jpg)'
- en: 'Figure 7.5: The Speaker interface implemented by multiple types'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：由多个类型实现的Speaker接口
- en: When a function accepts an interface as an input parameter, any concrete type
    that implements that interface can be passed as an argument. Now, you have achieved
    polymorphism by being able to pass various concrete types to a method or function
    that has an interface type as an input parameter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数接受一个接口作为输入参数时，任何实现了该接口的具体类型都可以作为参数传递。现在，你通过能够将各种具体类型传递给具有接口类型作为输入参数的方法或函数，实现了多态性。
- en: 'Let''s look at some progressive examples that will enable us to demonstrate
    how polymorphism is achieved in Go:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些渐进的例子，这将使我们能够展示如何在Go中实现多态性：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s examine the code in parts:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分部分来检查这段代码：
- en: '`cat` satisfies the `Speaker{}` interface. The `main()` function calls `catSpeak()`
    and takes a type of `cat`.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cat`实现了`Speaker{}`接口。`main()`函数调用`catSpeak()`并传递一个`cat`类型。'
- en: Inside `catSpeak()`, it prints out the results of its `Speak()` method.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`catSpeak()`内部，它打印出其`Speak()`方法的结果。
- en: 'We are going to implement some code that takes a concrete type (`cat`, `dog`,
    `person`) and satisfies the `Speaker{}` interface type. Using the previous coding
    pattern, it would look like the following code snippet:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现一些代码，这些代码接受一个具体类型（`cat`、`dog`、`person`）并满足`Speaker{}`接口类型。使用之前的编码模式，它将看起来像以下代码片段：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s look at this code in parts:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分部分来看这段代码：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We have three concrete types (`cat`, `dog`,and `person`). The `cat` and `dog`
    types are empty structs, while the `person` struct has a `name` field:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个具体类型（`cat`、`dog`和`person`）。`cat`和`dog`类型是空结构体，而`person`结构体有一个`name`字段：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Each of our types implicitly implements the `Speaker{}` interface. Each of
    the concrete types implements it differently from the others:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有类型都隐式实现了`Speaker{}`接口。每个具体类型都以与其他类型不同的方式实现它：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `main()` function, we call `catSpeak()`, `dogSpeak()`, and `personSpeak()`
    to invoke their respective `Speak()` method. The preceding code has a lot of redundant
    functions that perform similar actions. We can refactor this code to be more simple
    and easier to read. We will use some of the features you get with implementing
    interfaces to provide a more concise implementation:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们调用`catSpeak()`、`dogSpeak()`和`personSpeak()`来调用它们各自的`Speak()`方法。前面的代码有很多执行类似操作的重冗余函数。我们可以重构这段代码，使其更简单、更容易阅读。我们将使用实现接口时获得的一些特性来提供一个更简洁的实现：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s look at the code in parts:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分部分来看这段代码：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Our `saySomething()` function is using a variadic parameter. If you recall,
    a variadic parameter can accept zero or more arguments for that type. For more
    information on variadic functions, review *Chapter 5*, *Functions*. The parameter
    type is `Speaker`. An interface can be used as an input parameter:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `saySomething()` 函数使用可变参数。如果您还记得，可变参数可以接受零个或多个该类型的参数。有关可变函数的更多信息，请参阅 *第
    5 章*，*函数*。参数类型是 `Speaker`。接口可以用作输入参数：
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We range over the slice of `Speaker`. For each `Speaker` type, we call the `Speak()`
    method. In our code, we passed the `cat` and `dog` struct types to the `person`
    function. The function accepts an argument as an interface of `Speaker{}`. Any
    of the methods that make up that interface can be invoked. For each of those concrete
    types, the `Speak()` method is called.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历 `Speaker` 的切片。对于每种 `Speaker` 类型，我们调用 `Speak()` 方法。在我们的代码中，我们将 `cat` 和 `dog`
    结构体类型传递给 `person` 函数。该函数接受一个 `Speaker{}` 接口的参数。接口中的任何方法都可以被调用。对于这些具体类型，都会调用 `Speak()`
    方法。
- en: '![Figure 7.6: Multiple types implementing the Speaker interface'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6：实现 Speaker 接口的多种类型](img/B14177_07_06.jpg)'
- en: '](img/B14177_07_06.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6：实现 Speaker 接口的多种类型](img/B14177_07_06.jpg)'
- en: 'Figure 7.6: Multiple types implementing the Speaker interface'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.6：实现 Speaker 接口的多种类型](img/B14177_07_06.jpg)'
- en: 'In the `main()` function, we will see the use of polymorphism being demonstrated
    through the use of interfaces:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们将通过使用接口来展示多态的使用：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We implement each of the concrete types, `cat`, `dog`, and, `person`. The `cat`,
    `dog`, and, `person` types all satisfy the `Speaker{}` interface. Since they match
    an interface, you can use that type wherever that interface is used. As you can
    see, this also includes being able to pass the `cat`, `dog`, and `person` types
    into a method.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了每个具体类型，`cat`、`dog` 和 `person`。`cat`、`dog` 和 `person` 类型都满足 `Speaker{}`
    接口。由于它们匹配接口，因此可以在使用该接口的任何地方使用这些类型。如您所见，这还包括能够将 `cat`、`dog` 和 `person` 类型传递给方法。
- en: Through the use of interfaces and polymorphism, this code is more concise than
    the previous code snippets. The example at the beginning of the chapter showed
    a single concrete type that satisfied the `Speaker{}` interface that invoked the
    `Speak()` method. We then added a few more concrete types to our running example
    (`cat`, `dog`, and `person`), each of these separately invoking their own `Speak()`
    method. We noticed there was a lot of redundant code in that example and started
    looking for a better way to implement the solution. We discovered that interface
    types can be parameter input types. Through duck typing and polymorphism, our
    third and final code snippet was able to have a single function that would call
    the `Speak()` method on each type that satisfied the `Speaker()` interface.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用接口和多态，这段代码比之前的代码片段更简洁。本章开头示例展示了一个满足 `Speaker{}` 接口并调用 `Speak()` 方法的单个具体类型。然后我们向运行示例中添加了几个更多具体类型（`cat`、`dog`
    和 `person`），每个类型都分别调用它们自己的 `Speak()` 方法。我们注意到那个示例中有大量冗余代码，并开始寻找更好的实现解决方案的方法。我们发现接口类型可以作为参数输入类型。通过鸭子类型和多态，我们的第三个和最后一个代码片段能够拥有一个单函数，该函数会对满足
    `Speaker()` 接口的每个类型调用 `Speak()` 方法。
- en: 'Exercise 7.02: Calculating the Area of Different Shapes Using Polymorphism'
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.02：使用多态计算不同形状的面积
- en: 'We will be implementing a program that will calculate the area of a triangle,
    rectangle, and square. The program will use a single function that accepts a `Shape`
    interface. Any type that satisfies the `Shape` interface can be passed as an argument
    to the function. This function should then print the area and the name of the
    shape:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个程序，该程序将计算三角形、矩形和正方形的面积。该程序将使用一个接受 `Shape` 接口的单个函数。任何满足 `Shape` 接口类型的都可以作为函数的参数传递。该函数应打印出形状的面积和名称：
- en: Use the IDE of your choice.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的集成开发环境（IDE）。
- en: Create a new file and save it as `main.go`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件并将其保存为 `main.go`。
- en: 'We will have a package called `main`, and we will be using the `fmt` package
    in this program:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将有一个名为 `main` 的包，并且在这个程序中我们将使用 `fmt` 包：
- en: '[PRE31]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create the `Shape{}` interface that has two method sets called `Area() float64`
    and `Name() string`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Shape{}` 的接口，它包含两个方法集，分别是 `Area() float64` 和 `Name() string`：
- en: '[PRE32]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we will create `triangle`, `rectangle`, and `square` struct types. These
    types will each satisfy the `Shape{}` interface. `triangle`, `rectangle`, and
    `square` have appropriate fields that are needed to calculate the area of the
    shape:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建 `triangle`、`rectangle` 和 `square` 结构体类型。这些类型将各自满足 `Shape{}` 接口。`triangle`、`rectangle`
    和 `square` 具有计算形状面积所需的适当字段：
- en: '[PRE33]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We create the `Area()` and `Name()` methods for the `triangle` struct type.
    The area of a triangle is `base * height\2`. The `Name()` method returns the name
    of the shape:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为 `triangle` 结构体类型创建了 `Area()` 和 `Name()` 方法。三角形的面积是 `底边 * 高\2`。`Name()` 方法返回形状的名称：
- en: '[PRE34]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We create the `Area()` and `Name()` methods for the `rectangle` struct type.
    The area of a rectangle is `length * width`. The `Name()` method returns the name
    of the shape:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为 `rectangle` 结构体类型创建了 `Area()` 和 `Name()` 方法。矩形的面积是 `长度 * 宽度`。`Name()` 方法返回形状的名称：
- en: '[PRE35]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We create the `Area()` and `Name()` methods for the `square` struct type. The
    area of a square is `side * side`. The `Name()` method returns the name of the
    shape:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为 `square` 结构体类型创建了 `Area()` 和 `Name()` 方法。正方形的面积是 `边长 * 边长`。`Name()` 方法返回形状的名称：
- en: '[PRE36]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, each of our shapes (`triangle`, `rectangle`, and `square`) satisfies the
    `Shape` interface because they each have an `Area()` and `Name()` method with
    the appropriate signatures:'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们的每个形状（`triangle`、`rectangle` 和 `square`）都满足 `Shape` 接口，因为它们各自都有一个 `Area()`
    和 `Name()` 方法，具有适当的签名：
- en: '![Figure 7.7: square, triangle, rectangle area of the Shape type'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 7.7：Shape 类型的正方形、三角形、矩形面积'
- en: '](img/B14177_07_07.jpg)'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_07_07.jpg)'
- en: 'Figure 7.7: square, triangle, rectangle area of the Shape type'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7.7：Shape 类型的正方形、三角形、矩形面积
- en: 'We will now create a function that accepts the `Shape` interface as a variadic
    parameter. The function will iterate over the `Shape` type and will execute each
    of its `Name()` and `Area()` methods:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个函数，该函数接受 `Shape` 接口作为可变参数。该函数将遍历 `Shape` 类型，并执行其每个 `Name()` 和 `Area()`
    方法：
- en: '[PRE37]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Inside the `main()` function, set the fields for `triangle`, `rectangle`, and
    `square`. Pass all three to the `printShapeDetail()` function. All three can be
    passed because they each satisfy the `Shape` interface:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数内部，设置 `triangle`、`rectangle` 和 `square` 的字段。将所有三个传递给 `printShapeDetail()`
    函数。所有三个都可以传递，因为它们各自满足 `Shape` 接口：
- en: '[PRE38]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Build the program by running `go build` at the command line:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在命令行运行 `go build` 来构建程序：
- en: '[PRE39]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Correct any errors that are returned and ensure your code matches the code snippet
    here.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修正返回的错误，并确保你的代码与这里的代码片段匹配。
- en: Run the executable by typing the name of the executable and hit *Enter* to run
    it.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入可执行文件名并按 *Enter* 键来运行可执行文件。
- en: 'You should see the following output:'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE40]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this exercise, we saw the flexibility and the reusable code that interfaces
    provide to our programs. Further, we will discuss how accepting interfaces and
    returning structs for our functions and methods increase code reusability and
    low coupling by not being dependent on the concrete types. When we use interfaces
    as input arguments to an API, we are stating that a type needs to satisfy the
    interface. When using concrete types, we require that the argument for the API
    must be of that type. For instance, if a function signature is `func greeting(msg
    string)`, we know that the argument being passed must be a string. Concrete types
    can be thought of as types that are not abstract (`float64`, `int`, `string`,
    and so on); however, interfaces could be considered as an abstract type because
    you are satisfying the method sets of the interface type. The underlying interface
    type is a concrete type, but the underlying type is not what needs to be passed
    into the API. The type must meet the requirements of having the method sets the
    interface type defines.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了接口为我们的程序提供的灵活性和可重用代码。进一步地，我们将讨论通过不接受具体类型，而是接受接口和返回结构体来增加函数和方法的可重用性和降低耦合度。当我们使用接口作为
    API 的输入参数时，我们是在声明一个类型需要满足该接口。当使用具体类型时，我们要求 API 的参数必须是该类型。例如，如果函数签名是 `func greeting(msg
    string)`，我们知道传递的参数必须是一个字符串。具体类型可以被认为是非抽象类型（`float64`、`int`、`string` 等）；然而，接口可以被认为是抽象类型，因为你在满足接口类型的方法集。底层接口类型是一个具体类型，但底层类型不是需要传递到
    API 中的类型。类型必须满足接口类型定义的方法集要求。
- en: In the future, if we require another type to be passed, this will mean the code
    upstream to our API will need to change, or if the caller of our API needs to
    change its data type, it might request we change our API to accommodate it. If
    we use interfaces, this is not an issue; the caller of our code needs to satisfy
    the interface's method sets. The caller can then change the underlying type as
    long as it complies with the interface requirements.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，如果我们需要传递其他类型，这意味着我们的 API 上游的代码需要更改，或者如果 API 的调用者需要更改其数据类型，它可能会要求我们更改 API
    以适应它。如果我们使用接口，这不会成为问题；我们的代码的调用者需要满足接口的方法集。只要它符合接口的要求，调用者就可以更改底层类型。
- en: Accepting Interfaces and Returning Structs
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受接口和返回结构体
- en: 'There is a Go proverb that states "*Accept interfaces, return structs*." It
    can be restated as accept interfaces and return concrete types. This proverb is
    talking about accepting interfaces for your APIs (functions, methods, and so on)
    and the return to be structs or concrete types. This proverb follows Postel''s
    Law, which states "*Be conservative with what you do, be liberal with what you
    accept*." We are focusing on the "*be liberal with what you accept*." By accepting
    interfaces, you are increasing the flexibility of the API for your function or
    method. By doing this, you are allowing for the user of the API to meet the requirements
    of the interface, but not forcing the user to use a concrete type. If our functions
    or methods only accept concrete types, then we are limiting the users of our functions
    to a specific implementation. In this chapter, we are going to explore the previously
    mentioned Go proverb and learn why it is a good design pattern to follow. We will
    see that as we go over the code example:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 Go 谚语说“*接受接口，返回结构体*。”它可以重新表述为“接受接口，返回具体类型”。这个谚语是在谈论为你的 API（函数、方法等）接受接口，并返回结构体或具体类型。这个谚语遵循
    Postel 的法律，即“*对你所做的事情要保守，对你所接受的要开放*。”我们关注的是“*对你所接受的要开放*。”通过接受接口，你增加了函数或方法的 API
    的灵活性。通过这样做，你允许 API 的使用者满足接口的要求，但不必强制使用者使用具体类型。如果我们只接受具体类型，那么我们就限制了函数的使用者只能使用特定的实现。在本章中，我们将探讨前面提到的
    Go 谚语，并了解为什么它是一个好的设计模式。我们将看到，当我们查看代码示例时：
- en: '![Figure 7.8: Benefits of accepting interfaces'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.8：接受接口的好处'
- en: '](img/B14177_07_08.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_07_08.jpg](img/B14177_07_08.jpg)'
- en: 'Figure 7.8: Benefits of accepting interfaces'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8：接受接口的好处
- en: The following example will illustrate the benefits of accepting interfaces versus
    using concrete types. We will have two functions that perform the same task of
    decoding JSON, but each has different inputs. One of these functions is superior
    to the other, and we will go over the reasons why that is the case.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将说明接受接口与使用具体类型相比的好处。我们将有两个函数执行相同的解码 JSON 任务，但它们的输入不同。其中一个函数比另一个函数更优越，我们将讨论为什么是这样的情况。
- en: 'Look at the following example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 看以下示例：
- en: '[PRE41]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The expected output is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s examine each part of this code. We will discuss some parts of this code
    in the upcoming chapters. This code decodes some data into a struct. There are
    two functions being used for that purpose, `loadPerson2()` and `loadPerson()`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这段代码的每一部分。我们将在接下来的章节中讨论这段代码的一些部分。这段代码将一些数据解码到一个结构体中。为此使用了两个函数，`loadPerson2()`
    和 `loadPerson()`：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `loadPerson2()` function accepts an argument that is a concrete `string`
    and returns a `struct`. The returning of the struct meets half of "*accept interfaces*,
    *return structs*". However, it is very limited and not liberal in what it accepts.
    This limits the user of the function to a narrow implementation. The only thing
    that can ever be passed is a string. Granted, in some cases that might be acceptable,
    but in other situations, it could be a problem. For example, if your function
    or method should only accept a specific data type, then you may not want to accept
    interfaces:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadPerson2()` 函数接受一个具体的 `string` 类型的参数，并返回一个 `struct`。返回 `struct` 符合 "*接受接口，返回结构体*"
    的半部分。然而，它的接受范围非常有限，并不开放。这限制了函数的使用范围，使其只能应用于狭窄的实现。唯一可以传递的是字符串。当然，在某些情况下这可能是可以接受的，但在其他情况下可能会出现问题。例如，如果你的函数或方法应该只接受特定的数据类型，那么你可能不想接受接口：'
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In this function, we are accepting the `io.Reader{}` interface. The `io.Reader{}`
    ([https://packt.live/2LRG3Kv](https://packt.live/2LRG3Kv)) and `io.Writer{}` ([https://packt.live/2YIAJhP](https://packt.live/2YIAJhP))
    interfaces are among the most utilized interfaces in Go packages. `json.NewDecoder`
    accepts anything that satisfies the `io.Reader{}` interface. The caller code just
    needs to make sure whatever they pass satisfies the `io.Reader{}` interface:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们接受 `io.Reader{}` 接口。`io.Reader{}` ([https://packt.live/2LRG3Kv](https://packt.live/2LRG3Kv))
    和 `io.Writer{}` ([https://packt.live/2YIAJhP](https://packt.live/2YIAJhP)) 接口是
    Go 包中最常用的接口之一。`json.NewDecoder` 接受任何满足 `io.Reader{}` 接口的对象。调用者代码只需确保他们传递的对象满足
    `io.Reader{}` 接口：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`strings.NewReader` returns a `Reader` type that has a `Read(b []byte) (n int,
    err error)` method that satisfies the `io.Reader{}` interface. It can be passed
    to our `loadPerson()` function. You may be thinking that each function still does
    what it was intended for. You would be correct, but let''s say the caller is no
    longer going to pass a string, or another caller will be passing a file that contains
    the JSON data:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings.NewReader` 返回一个具有 `Read(b []byte) (n int, err error)` 方法的 `Reader`
    类型，该方法满足 `io.Reader{}` 接口。它可以传递给我们的 `loadPerson()` 函数。你可能认为每个函数仍然在执行其预期功能。你会是对的，但让我们假设调用者将不再传递一个字符串，或者另一个调用者将传递一个包含
    JSON 数据的文件：'
- en: '[PRE46]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Our `loadPerson2()` function would not work; however, our `loadPerson()` data
    would work because the return type from `os.Open()` satisfies the `io.Reader{}`
    interface.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `loadPerson2()` 函数将无法工作；然而，我们的 `loadPerson()` 数据将工作，因为 `os.Open()` 返回的类型满足
    `io.Reader{}` 接口。
- en: Say, for instance, the data will be coming through an HTTP endpoint. We will
    be getting the data from `*http.Request`. Again, the `loadPerson2()` function
    would not be a good choice. We would get the data from `request.Body`, which just
    so happens to implement the `io.Reader{}` interface.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，数据将通过 HTTP 端点传入。我们将从 `*http.Request` 获取数据。再次强调，`loadPerson2()` 函数不是一个好的选择。我们将从
    `request.Body` 获取数据，它恰好实现了 `io.Reader{}` 接口。
- en: 'You may be wondering if interfaces are good for input arguments. If so, why
    would we not return them too? If you return an interface, it adds unnecessary
    difficulty to the user. The user will have to look up the interface to then find
    the method set and the method sets signature:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道接口是否适合作为输入参数。如果是这样，为什么我们还要返回它们呢？如果你返回一个接口，它会给用户增加不必要的难度。用户将不得不查找接口，然后找到方法集和方法签名：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You would need to look at the definition of the `Speaker{}` interface and then
    spend time looking at the implementation code, all of which is unnecessary for
    the user of the function. If an interface is needed from the return type of the
    function, the user of the function can create the interface for that concrete
    type and use it in their code.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要查看 `Speaker{}` 接口的定义，然后花时间查看实现代码，这对于函数的用户来说都是不必要的。如果函数的返回类型需要接口，函数的用户可以为此具体类型创建接口并在他们的代码中使用它。
- en: As you start to follow this Go proverb, check to see whether there is an interface
    in the Go standard packages. This will increase the number of different implementations
    that your function can provide. Our users of the function can have various implementations
    using `strings.newReader`, `http.Request.Body`, `os.File`, and many others, just
    like in our code example, by using the `io.Reader{}` interface from the Go standard
    packages.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始遵循这个 Go 谚语时，检查 Go 标准包中是否有接口。这将增加你的函数可以提供不同实现的数量。我们的函数用户可以使用 `strings.newReader`、`http.Request.Body`、`os.File`
    以及许多其他实现，就像我们的代码示例一样，通过使用 Go 标准包中的 `io.Reader{}` 接口。
- en: Empty interface{}
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空接口 `interface{}`
- en: 'An empty interface is an interface that has no method sets and no behaviors.
    An empty interface specifies no methods:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 空接口是一个没有方法集和行为的接口。空接口没有指定任何方法：
- en: '[PRE48]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is a simple but complex concept to wrap your head around. As you may recall,
    interfaces are implemented implicitly; there is no `implements` keyword. Since
    an empty interface specifies no methods, that means that every type in Go implements
    an empty interface automatically. All types satisfy the empty interface.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单但复杂的概念，需要你理解。正如你可能记得的，接口是隐式实现的；没有 `implements` 关键字。由于空接口没有指定任何方法，这意味着
    Go 中的每个类型都自动实现了空接口。所有类型都满足空接口。
- en: 'In the following code snippet, we will demonstrate how to use the empty interface.
    We will also see how a function that accepts an empty interface allows any type
    to be passed to that function:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们将演示如何使用空接口。我们还将看到接受空接口的函数如何允许传递任何类型到该函数：
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The expected output is as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s evaluate the code in sections:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分部分评估代码：
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The function accepts an empty `interface{}`. Any type can be passed to the
    function since all types implement the empty `interface{}`. It prints the value
    and the concrete type. The `%v` verb prints the value and the `%T` verb prints
    the concrete type:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受一个空的`interface{}`。由于所有类型都实现了空的`interface{}`，因此可以将任何类型传递给该函数。它将打印值和具体类型。`%v`动词打印值，`%T`动词打印具体类型：
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We pass a `cat` type, `integer`, `bool`, and `string`. The `emptyDetails()`
    function will print each of them:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递`cat`类型、`integer`、`bool`和`string`。`emptyDetails()`函数将打印它们中的每一个：
- en: '![Figure 7.9: The type cat implements an empty interface and the Speaker interface'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9：类型cat实现了空接口和Speaker接口'
- en: '](img/B14177_07_09.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_07_09.jpg)'
- en: 'Figure 7.9: The type cat implements an empty interface and the Speaker interface'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：类型cat实现了空接口和Speaker接口
- en: The `cat` type implements the empty `interface{}` and the `Speaker{}` interface
    implicitly.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`类型隐式实现了空接口和`Speaker{}`接口。'
- en: 'Now that we have a basic understanding of empty interfaces, we will be looking
    at various use cases for them in the upcoming topics, including the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对空接口有了基本的了解，我们将在接下来的主题中查看它们的各种用例，包括以下内容：
- en: Type switching
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型切换
- en: Type assertion
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型断言
- en: Examples of Go packages
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go包的示例
- en: Type Assertion and Switches
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型断言和切换
- en: 'Type assertion provides access to an interface''s concrete type. Remember that
    `interface{}` can be any value:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言提供了访问接口的具体类型。请记住，`interface{}`可以是任何值：
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The type assertion output would look as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 类型断言的输出将如下所示：
- en: '[PRE54]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In each instance of the variable declaration, each variable is declared as an
    empty interface, but the concrete value for `str` is a string, for `i` is an integer,
    and for `b` is a Boolean.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量声明的每个实例中，每个变量都被声明为空接口，但对于`str`来说，其具体值是字符串，对于`i`来说是整数，对于`b`来说是布尔值。
- en: 'When there is an empty `interface{}` type, sometimes, it is beneficial to know
    the underlying concrete type. For instance, you may need to perform data manipulation
    based upon that type. If that type is a string, you would perform data modification
    and validation different from how you would if it was an integer value. This also
    comes into play when you are consuming JSON data of an unknown schema. The values
    in that JSON might be known during the ingesting process. We would need to convert
    that data to `map[string]interface{}` and perform various data massaging. We have
    an activity later in this chapter that will show us how to perform such an action.
    We could perform a type conversion with the `strconv` package:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在空的`interface{}`类型时，有时了解其底层具体类型是有益的。例如，您可能需要根据该类型执行数据操作。如果该类型是字符串，您将执行与整数值不同的数据修改和验证。当您消费未知模式的JSON数据时，这也适用。在摄入过程中，该JSON中的值可能是已知的。我们将在本章后面的活动中展示如何执行此类操作。我们可以使用`strconv`包执行类型转换：
- en: '[PRE55]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![Figure 7.10: Error when type assertion is needed'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10：需要类型断言时的错误'
- en: '](img/B14177_07_10.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_07_10.jpg)'
- en: 'Figure 7.10: Error when type assertion is needed'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：需要类型断言时的错误
- en: 'So, it appears we cannot use type conversion because the types are not compatible
    with type conversion. We will need to use `type` assertion:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，看起来我们不能使用类型转换，因为类型不兼容类型转换。我们需要使用类型断言：
- en: '[PRE56]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The preceding statement says that it asserts that the interface value `s` is
    of type `T` and assigns the underlying value of `v`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 上一条语句表示它断言接口值`s`是类型`T`，并将`v`的底层值赋值：
- en: '![Figure 7.11: Type assertion flow'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.11：类型断言流程'
- en: '](img/B14177_07_11.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_07_11.jpg)'
- en: 'Figure 7.11: Type assertion flow'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：类型断言流程
- en: 'Consider the following code snippet:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE57]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let''s examine the preceding code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查前面的代码：
- en: The preceding code asserts that `str` is of the `string` type and assigns it
    to the variable `v`.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一段代码断言`str`是`string`类型，并将其赋值给变量`v`。
- en: Since `v` is a `string`, it will print it with title casing.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`v`是`string`类型，它将以标题大小写打印。
- en: 'The result is as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE58]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'It is good when the assertion matches the expected type. So, what will happen
    if `s` is not of type `T`? Let''s take a look:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当断言匹配预期类型时，这是很好的。那么，如果`s`不是类型`T`呢？让我们看看：
- en: '[PRE59]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s examine the preceding code:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查前面的代码：
- en: '`str{}` is an empty interface and the concrete type is of `int`.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str{}`是一个空接口，具体类型是`int`。'
- en: The type assertion is checking whether `str` is of the string type, but in this
    scenario, it is not, so the code will panic.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型断言正在检查`str`是否为字符串类型，但在这个场景中，它不是，所以代码会崩溃。
- en: 'The result is as follows:'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Figure 7.12: Failed type assertion'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.12：失败的类型断言'
- en: '](img/B14177_07_12.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_07_12.jpg)'
- en: 'Figure 7.12: Failed type assertion'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12：失败的类型断言
- en: 'Having a panic being thrown is not something that is desirable. However, Go
    has a way to check whether `str` is a string:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出恐慌不是我们期望的事情。然而，Go 有一种方法来检查`str`是否为字符串：
- en: '[PRE60]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s examine the preceding code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查前面的代码：
- en: A type assertion returns two values, the underlying value and a Boolean value.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型断言返回两个值，基础值和布尔值。
- en: '`isValid` is assigned to a return type of `bool`. If it returns `true`, that
    indicates that `str` is of the `int` type. It means that the assertion is true.
    We can use the Boolean that was returned to determine what action we can take
    on `str`.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isValid`被分配给返回类型`bool`。如果它返回`true`，这表明`str`是`int`类型。这意味着断言是正确的。我们可以使用返回的布尔值来确定我们可以对`str`采取什么行动。'
- en: When the assertion fails, it will return `false`. The return value will be the
    zero value that you are trying to assert to. It also will not panic.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当断言失败时，它将返回`false`。返回值将是您试图断言的零值。它也不会崩溃。
- en: There will be times when you do not know the empty interface concrete type.
    This is when you will use a type switch. A type switch can perform several types
    of assertions; it is similar to a regular switch statement. It has a case and
    default clauses. The difference is that type switch statements evaluate for a
    type rather than a value.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会遇到不知道空接口具体类型的情况。这就是你将使用类型选择的时候。类型选择可以执行几种类型的断言；它类似于常规的`switch`语句。它有`case`和`default`子句。区别在于类型选择语句是对类型而不是值进行评估。
- en: 'Here is a basic syntax structure:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个基本的语法结构：
- en: '[PRE61]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s examine the preceding code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查前面的代码：
- en: '[PRE62]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The syntax is similar to that of the type assertion, `i.(int)`, except the specified
    type, `int` in our example, is replaced with the `type` keyword. The type being
    asserted of type `i` is assigned to `v`; then, it is compared to each of the `case`
    statements.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 语法与类型断言类似，`i.(int)`，但指定的类型，在我们的例子中是`int`，被`type`关键字替换。被断言的类型`i`被分配给`v`；然后，它被与每个`case`语句进行比较。
- en: '[PRE63]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the `switch` type, the statements evaluate for types. In regular switching,
    they evaluate for values. Here, it is evaluated for a type of `S`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在`switch`类型中，语句是对类型进行评估。在常规切换中，它们是对值进行评估。在这里，它是对类型`S`进行评估。
- en: 'Now that we have a fundamental understanding of the type switch statement,
    let''s look at an example that uses the syntax we have just evaluated:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对类型选择语句有了基本理解，让我们看看一个使用我们刚刚评估的语法的例子：
- en: '[PRE64]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let''s now explore the code in pieces:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在分块探索代码：
- en: '[PRE65]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the `main()` function, we are initializing a variable, `i`, to a slice of
    interfaces. In the slice, we have the `int`, `string`, `bool`, and `cat` types:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们初始化一个变量`i`为接口切片。在切片中，我们有`int`、`string`、`bool`和`cat`类型：
- en: '[PRE66]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The function accepts a slice of interfaces:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受接口切片：
- en: '[PRE67]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `for` loop ranges over the slice of interfaces. The first value in the
    slice is 42\. The `switch` case asserts that the slice value of 42 is an `int`
    type. The `case int` statement will evaluate to `true`, and print 42 is `int`.
    When the `for` loop iterates over the last value of the `cat` type, the `switch`
    statement will not find that type in its case evaluations. Since there is no `cat`
    type being checked for in the `case` statements, the default will execute its
    print statement. Here are the results of the code being executed:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环遍历接口切片。切片中的第一个值是42。`switch`情况断言切片值42是`int`类型。`case int`语句将评估为`true`，并打印`42
    is int`。当`for`循环遍历`cat`类型的最后一个值时，`switch`语句将不会在其`case`评估中找到该类型。由于在`case`语句中没有检查`cat`类型，所以默认将执行其打印语句。以下是代码执行的结果：'
- en: '[PRE68]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Exercise 7.03: Analyzing Empty interface{} Data'
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.03：分析空的 interface{} 数据
- en: 'In this exercise, we are given a map. The map''s key is a string and its value
    is an empty `interface{}`. The map''s value contains different types of data stored
    in the value portion of the map. Our job is to determine each key''s value type.
    We are going to write a program that will analyze the data of `map[string]` `interface{}`.
    Understand that the values of the data can be of any type. We need to write logic
    to catch types we are not looking for. We are going to store that information
    in a slice of structs that will hold the key name, data, and the type of data:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们得到了一个映射。映射的键是一个字符串，其值是一个空的 `interface{}`。映射的值包含存储在映射值部分的不同类型的数据。我们的任务是确定每个键的值类型。我们将编写一个程序来分析
    `map[string]interface{}` 的数据。理解数据的值可以是任何类型。我们需要编写逻辑来捕获我们不想查找的类型。我们将把信息存储在一个包含键名、数据和数据类型的结构体切片中：
- en: Create a new file called `main.go`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的新文件。
- en: 'Inside the file, we will have a `main` package and will need to import the
    `fmt` package:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中，我们将有一个 `main` 包，并需要导入 `fmt` 包：
- en: '[PRE69]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We will create a `struct` called `record` that will store the key, type of
    value, and data from `map[string]interface{}`. This struct is used to store the
    analysis that we are performing on the map. The `key` field is the name as the
    map key. The `valueType` field is storing the type of data stored as a value in
    the map. The data field stores the data we are analyzing. It is an empty `interface{}`,
    since there can be various types of data in the map:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `record` 的结构体，用于存储来自 `map[string]interface{}` 的键、值类型和数据。此结构体用于存储我们对映射进行的分析。`key`
    字段是映射键的名称。`valueType` 字段存储映射中作为值存储的数据类型。数据字段存储我们正在分析的数据。它是一个空的 `interface{}`，因为映射中可能有各种类型的数据：
- en: '[PRE70]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We will create a `person` struct that will be added to our `map[string]interface{}`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个 `person` 结构体，并将其添加到我们的 `map[string]interface{}` 中：
- en: '[PRE71]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We will create an `animal` struct that will be added to our `map[string]interface{}`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `animal` 的结构体，并将其添加到我们的 `map[string]interface{}` 中：
- en: '[PRE72]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Create a `newRecord()` function. The `key` parameter will be our map''s key.
    The function also takes an `interface{}` as an input parameter. `i` will be our
    map''s value for the key that is passed to the function. It will return a `record`
    type:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `newRecord()` 函数。`key` 参数将是我们的映射键。该函数还接受一个 `interface{}` 作为输入参数。`i` 将是传递给函数的键的映射值。它将返回一个
    `record` 类型：
- en: '[PRE73]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Inside the `newRecord()` function, we initialize `record{}` and assign it to
    the `r` variable. We then assign `r.key` to the key input parameter.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `newRecord()` 函数中，我们初始化 `record{}` 并将其分配给 `r` 变量。然后我们将 `r.key` 分配给键输入参数。
- en: 'The `switch` statement assigns the type of `i` to the `v` variable. The `v`
    variable type gets evaluated against a series of `case` statements. If a type
    evaluates to `true` for one of the `case` statements, then the `valueType` record
    gets assigned to that type, along with the value of `v` to `r.data`, and then
    returns the `record` type:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`switch` 语句将 `i` 的类型分配给 `v` 变量。`v` 变量的类型将与一系列 `case` 语句进行比较。如果一个类型在某个 `case`
    语句中评估为 `true`，则将 `valueType` 记录分配给该类型，并将 `v` 的值分配给 `r.data`，然后返回 `record` 类型：'
- en: '[PRE74]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'A `default` statement is needed for the `switch` statement. If the type of
    `v` does not get evaluated to `true` in the `case` statements, then `default`
    will be executed. The `record.valueType` will be marked as `unknown`:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 `switch` 语句需要一个 `default` 语句。如果 `v` 的类型在 `case` 语句中没有评估为 `true`，则执行 `default`。`record.valueType`
    将被标记为 `unknown`：
- en: '[PRE75]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Inside the `main()` function, we will initialize our map. The map is initialized
    to a string for the key and an empty interface for the value. We then assign `a`
    to an `animal` struct literal and `p` to a `person` struct literal. Then, we start
    adding various key-value pairs to the map:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们将初始化我们的映射。映射初始化为字符串键和空接口值。然后我们将 `a` 分配给 `animal` 结构字面量，将 `p`
    分配给 `person` 结构字面量。然后我们开始向映射添加各种键值对：
- en: '[PRE76]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, we initialize a slice of `record`. We iterate over the map and add records
    to `rs`:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们初始化一个 `record` 切片。我们遍历映射，并将记录添加到 `rs` 中：
- en: '[PRE77]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Now, print out the record field values. We range over the slice of records
    and print each record value:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打印出记录字段值。我们遍历记录切片并打印每个记录值：
- en: '[PRE78]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The expected output is as follows:'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期输出如下：
- en: '![Figure 7.13: Output for the exercise'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.13：练习的输出'
- en: '](img/B14177_07_13.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_07_13.jpg)'
- en: 'Figure 7.13: Output for the exercise'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13：练习的输出
- en: The exercise has demonstrated Go's ability to identify the underlying type of
    an empty interface. As you can see from the results, our type switch was able
    to identify each type except for the value for the key of `animal`. It has its
    type marked as `unknown`. Also, it was even able to identify the `person` struct
    type, and the data has the field values of the struct.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习展示了Go识别空接口底层类型的能力。正如您从结果中看到的，我们的类型切换能够识别每个类型，除了`animal`键的值，它的类型被标记为`unknown`。它甚至能够识别`person`结构体类型，并且数据具有结构体的字段值。
- en: 'Activity 7.01: Calculating Pay and Performance Review'
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动七点零一：计算工资和绩效评价
- en: In this activity, we are going to calculate the annual pay for a manager and
    a developer. We will print out the developer's and manager's names and the pay
    for the year. The developer pay will be based on an hourly rate. The developer
    type will also keep track of the number of hours they have worked in a year. The
    developer type will also include their review. The review will need to be a collection
    of keys of strings. These strings are the category that the developer is being
    reviewed on, for example, work quality, teamwork, communication, and so on.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将计算经理和开发者的年薪。我们将打印出开发者和经理的名字以及全年的工资。开发者的工资将基于时薪。开发者类型还将跟踪他们在一年中工作的小时数。开发者类型还将包括他们的评价。评价将需要是一个字符串键的集合。这些字符串是开发者被评价的类别，例如工作质量、团队合作、沟通等等。
- en: The aim of this activity is to use an interface to demonstrate polymorphism
    by calling a single function called `payDetails()` that accepts an interface.
    This `payDetails()` function will print the salary information for a developer
    type and a manager type.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的目的是通过调用一个接受接口的单个函数`payDetails()`来演示Go的多态性。这个`payDetails()`函数将打印出开发者类型和经理类型的工资信息。
- en: 'The following steps should help you with the solution:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将有助于您找到解决方案：
- en: Create an `Employee` type that has `Id`, `FirstName`, and `LastName` fields.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有`Id`、`FirstName`和`LastName`字段的`Employee`类型。
- en: 'Create a `Developer` type that has the following fields: `Individual` of the
    `Employee` type, `HourlyRate`, `HoursWorkedInYear`, and `Review` of the `map[string]interface{}`
    type.'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有以下字段的`Developer`类型：`Employee`类型的`Individual`、`HourlyRate`、`HoursWorkedInYear`和`map[string]interface{}`类型的`Review`。
- en: 'Create a `Manager` type with the following fields: `Individual` of the `Employee`
    type, `Salary`, and `CommissionRate`.'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有以下字段的`Manager`类型：`Employee`类型的`Individual`、`Salary`和`CommissionRate`。
- en: Create a `Payer` interface that has a `Pay()` method that returns a `string`
    and `float64`.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有`Pay()`方法并返回`string`和`float64`的`Payer`接口。
- en: The `Developer` type should implement the `Payer{}` interface by returning the
    `Developer` name and returning the developer year pay based on the calculation
    of `Developer.HourlyRate * Developer.HoursWorkInYear`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Developer`类型应通过返回`Developer`名称和基于`Developer.HourlyRate * Developer.HoursWorkInYear`计算的年工资来实现`Payer{}`接口。'
- en: The `Manager` type should implement the `Payer{}` interface by returning the
    `Manager` name and returning the `Manager` year pay based on the calculation of
    `Manager.Salary` + (`Manager.Salary * Manager.CommissionRate`).
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Manager`类型应通过返回`Manager`名称和基于`Manager.Salary`加上(`Manager.Salary * Manager.CommissionRate`)计算的`Manager`年工资来实现`Payer{}`接口。'
- en: Add a function called `payDetails`(`p Payer`) that accepts a `Payer` interface
    and prints `fullName` and the pay that is returned from the `Pay()` method.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`payDetails`的函数，它接受一个`Payer`接口并打印`fullName`和从`Pay()`方法返回的工资。
- en: We now need to calculate the review rating for a developer. The `Review` is
    obtained by `map[string]interface{}`. The key of the map is a string; it is what
    the developer is being rated on, such as work quality, teamwork, skills, and so
    on.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要计算一个开发者的评价等级。`Review`是通过`map[string]interface{}`获得的。该映射的键是一个字符串；这是开发者被评价的内容，例如工作质量、团队合作、技能等等。
- en: 'The empty `interface{}` of the map is needed because some managers give the
    rating as a string and others as a number. Here is the mapping of the `string`
    to the `integer`:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 映射中的空`interface{}`是必需的，因为一些经理将评价作为字符串给出，而另一些则作为数字给出。以下是`string`到`integer`的映射：
- en: '"Excellent" – 5'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"优秀" – 5'
- en: '"Good" – 4'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"良好" – 4'
- en: '"Fair" – 3'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"一般" – 3'
- en: '"Poor" – 2'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"差" – 2'
- en: '"Unsatisfactory" – 1'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"不满意" – 1'
- en: We need to calculate the performance review value as a `float` type. It is the
    sum of the map `interface{}` divided by the length of the map. Take into consideration
    that the rating can be a string or an integer, so you will need to be able to
    accept both and convert it to a float.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要计算绩效评估值作为一个`float`类型。它是`interface{}`映射的总和除以映射的长度。考虑到评分可以是字符串或整数，所以你需要能够接受两者并将它们转换为浮点数。
- en: 'The expected output is as follows:'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '[PRE79]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 715
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第715页找到
- en: In this activity, we saw the benefits of using an empty interface that allows
    us to accept any type of data. We then used type assertion and type switch statements
    to perform certain tasks based on the underlying concrete type of the empty interface.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们看到了使用允许我们接受任何类型数据的空接口的好处。然后我们使用了类型断言和类型切换语句来根据空接口的底层具体类型执行某些任务。
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter presented some fundamental and advanced topics when using interfaces.
    We learned that Go's implementation of interfaces has some similarities with other
    languages; for example, an interface does not contain the implementation details
    of the behaviors it is representing, and an interface is the blueprint of the
    methods. The different types that implement the interface can differ in their
    implementation details. However, Go differs in how you implement an interface
    compared to other languages. We learned that the implementation is done implicitly
    and not explicitly, like other languages.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了使用接口时的基本和高级主题。我们了解到Go的接口实现与其他语言有一些相似之处；例如，接口不包含它所表示的行为的实现细节，接口是方法的蓝图。实现接口的不同类型可以在实现细节上有所不同。然而，Go在实现接口的方式上与其他语言不同。我们了解到实现是隐式进行的，而不是像其他语言那样显式进行。
- en: This concludes that Go does not do subclassing, so, for it to implement polymorphism,
    it uses interfaces. It allows an interface type to appear in different forms,
    such as a `Shape` interface appearing as a rectangle, square, or circle.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明Go不进行子类化，因此，为了实现多态性，它使用接口。它允许接口类型以不同的形式出现，例如，`Shape`接口可以表现为矩形、正方形或圆形。
- en: We also discussed a design pattern of accept interfaces and return structs.
    We demonstrated that this pattern allows for broader uses by other callers. We
    examined the empty interface and saw how it can be used when you do not know the
    type being passed or when there could be multiple different types being passed
    to your API. Even though we did not know the type at runtime, we showed you how
    to use type assertion and type switching to determine the type. The knowledge
    and practicing of these various tools will help you build robust and fluid programs.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了一个接受接口和返回结构体的设计模式。我们演示了这种模式允许其他调用者有更广泛的使用。我们检查了空接口，并看到了在不知道传递的类型或当有多个不同类型传递给API时如何使用它。尽管我们在运行时不知道类型，但我们展示了如何使用类型断言和类型切换来确定类型。掌握和实践这些各种工具将有助于你构建健壮和流畅的程序。
- en: In the following chapter, we will look at how Go uses packages and how we can
    use them to further aid in building well-organized and focused code segments.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Go如何使用包，以及我们如何使用它们来进一步帮助构建有组织和专注的代码段。
