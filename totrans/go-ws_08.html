<html><head></head><body>
		<div>
			<div id="_idContainer129" class="Content">
			</div>
		</div>
		<div id="_idContainer130" class="Content">
			<h1 id="_idParaDest-226"><a id="_idTextAnchor238"/>8. Packages</h1>
		</div>
		<div id="_idContainer146" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter aims to demonstrate the importance of the use of packages in our Go programs. We will discuss how packages can be used to assist our code in being more maintainable, reusable, and modular. In this chapter, you will see how they can be used to bring structure and organization to our code. This will also be seen in our exercises, activities, and some examples from the Go standard library.</p>
			<p class="callout">By the end of the chapter, you will be able to describe a package and its structure and declare a package. You will learn to evaluate exported and unexported names in a package, create your own package and import your custom package. You will also be able to distinguish between an executable package and non-executable packages, and create an alias of a package.</p>
			<h1 id="_idParaDest-227"><a id="_idTextAnchor239"/>Introduction</h1>
			<p>In the previous chapter, we looked at interfaces. We saw how we can use interfaces to describe the behavior of a type. We also discovered that we can pass different types to functions that accept an interface, as long as the type satisfies the interface's method sets. We also saw how we can achieve polymorphism using interfaces.</p>
			<p>In this chapter, we will look at how Go organizes its code into packages. We will see how we can hide or expose different Go constructs such as structs, interfaces, functions, and more, using packages. Our programs have been rather small in the number lines of code and in complexity to a certain extent. Most of our programs have been contained in a single code file, often named <strong class="source-inline">main.go</strong>, and inside a single package named <strong class="source-inline">main</strong>. Later in this chapter, we will explore the significance of <strong class="source-inline">package main</strong>, so do not be worried at this juncture if you do not understand it. This will not always be the case when you are working on a development team. Often, your code base can become rather large, with multiple files, multiple libraries, and multiple members of the team. It would be rather restrictive if we could not break our code into smaller, manageable parts. The Go programming language solves the complexity of managing large codebases with the ability to modularize similar concepts into packages. The creators of Go use packages for their own standard libraries to tackle this problem. In this book, you have been working with many Go packages, such as <strong class="source-inline">fmt</strong>, <strong class="source-inline">string</strong>, <strong class="source-inline">os</strong>, <strong class="source-inline">ioutil</strong>, and so on.</p>
			<p>Let's look at an example of a package structure from the Go standard library. The Go <strong class="source-inline">strings</strong> package encapsulates string functions that manipulate strings. By keeping the <strong class="source-inline">strings</strong> package focused on only the functions that manipulate strings, we, as Go developers, know that this function should contain all that we need for string manipulation.</p>
			<p>The Go package for strings is structured as follows (<a href="https://packt.live/35jueEu">https://packt.live/35jueEu</a>):</p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B14177_08_01.jpg" alt="Figure 8.1: The strings package along with the files contained within it&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1: The strings package along with the files contained within it</p>
			<p>The preceding diagram shows the <strong class="source-inline">strings</strong> package and the files that are in the package. Each file in the <strong class="source-inline">strings</strong> package is named after the functionality it is supporting. The logical organization of the code goes from package to file. We can easily conclude that the <strong class="source-inline">strings</strong> package contains code for manipulating strings. We can then further conclude that the <strong class="source-inline">replace.go</strong> file contains functions for replacing strings. You can already see that the conceptual structure of packages can organize your code into modular chunks. You start with code that is working together to serve a purpose, string manipulation, and it gets stored in a package called <strong class="source-inline">string</strong>. You can then further organize the code into <strong class="source-inline">.go</strong> files and name them according to their purpose. The next step is keeping functions in there that perform a single purpose that reflects the name of the file and the name of the package. We will discuss these conceptual ideas later in the chapter when we discuss structuring code.</p>
			<p>It is important to develop software that is maintainable, reusable, and modular. Let's briefly discuss each of these core components of software development.</p>
			<h3 id="_idParaDest-228"><a id="_idTextAnchor240"/>Maintainable</h3>
			<p>For code to be maintainable, it must be easy to change, and any changes must have a low risk of having an adverse impact on the program. Maintainable code is easy to modify and extend and is readable. As code progresses through the different stages of the software development life cycle, the cost of changes to the code increases. These changes can be due to bugs, enhancements, or a change in requirements. Costs also increase when code is not easily maintainable. Another reason that code needs to be maintainable is the need to be competitive in the industry. If your code is not easily maintainable, it may be hard to react to a competitor who is releasing a software feature that could be used to outsell your application. These are just some of the reasons for code needing to be maintainable.</p>
			<h3 id="_idParaDest-229"><a id="_idTextAnchor241"/>Reusable</h3>
			<p>Reusable code is code that can be used in new software. For example, I have code in my existing application that has a function that returns an address for my mailing application; that function may be used in a new piece of software. That function that returns the address could be used in my new software that returns a customer address for an order the customer has placed.</p>
			<p>The advantages of having reusable code are as follows:</p>
			<ul>
				<li>It decreases future project costs by using existing packages.</li>
				<li>It decreases the time it takes to deliver an application, due to not having to reinvent the wheel.</li>
				<li>The quality of the program will increase through increased testing and more usage.</li>
				<li>More time can be spent on other areas of innovation during the development cycle.</li>
				<li>As your packages grow, it becomes easier to lay the foundations for future projects in a timely manner.</li>
			</ul>
			<h3 id="_idParaDest-230"><a id="_idTextAnchor242"/>Modular</h3>
			<p>Modular and reusable code is related to a certain extent, in the sense that having modular code makes it more likely that it will be reusable. One of the prominent problems when developing code is the organization of the code. Finding the code that performs a certain function in a large program that is unorganized would be near to impossible, and even finding out whether there is code that performs a certain task would be difficult to ascertain without some code organization. Modularization aids in that area. The idea is that each discrete task that your code performs has its own section of code located in a specific spot.</p>
			<p>Go encourages you to develop maintainable, reusable, and modular code by using packages. It was designed to encourage good software practices. We will be diving into how Go utilizes packages to accomplish those tasks:</p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B14177_08_02.jpg" alt="Figure 8.2: The types of code packages can provide&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2: The types of code packages can provide</p>
			<p>In the next topic, we are going to discuss what a package is and what the components that make up a package are.</p>
			<h1 id="_idParaDest-231"><a id="_idTextAnchor243"/>What Is a Package?</h1>
			<p>Go follows the <strong class="bold">Don't Repeat Yourself</strong> (<strong class="bold">DRY</strong>) principle. This means that you should not write the same code twice. Refactoring your code into functions is the first step of the DRY principle. What if you had hundreds or even thousands of functions that you used regularly? How would you keep track of all those functions? Some of those functions might even have common characteristics. You could have a group of functions that perform math operations, string manipulations, printing, or file-based operations. You may be thinking of breaking them up into individual files:</p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/B14177_08_03.jpg" alt="Figure 8.3: Group functions by files&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3: Group functions by files</p>
			<p>That could alleviate some of the issues. However, what if your string's functionality started to grow further? You would then have a ton of string functions in one file or even multiple files. Every program you build would also have to include all of the code for <strong class="source-inline">string</strong>, <strong class="source-inline">math</strong>, and <strong class="source-inline">io</strong>. You would be copying code to every application that you built. Bugs in one code base would have to be fixed in multiple programs. That kind of code structure is not maintainable, nor does it encourage code reusability. The packages in Go are the next step to organizing your code in a way that makes it easy to reuse the components of your code. The following diagram shows the progression of organizing code from functions to source files to packages:</p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B14177_08_04.jpg" alt="Figure 8.4: Code progression organization&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4: Code progression organization</p>
			<p>Go organizes its code for reusability into directories called packages. A package is essentially a directory inside your workspace that contains one or more Go source files, which is used for grouping code that performs a task. It exposes only the necessary parts in order for those using your package to get a job done. The package concept is akin to using directories to organize files on a computer.</p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor244"/>Package Structure</h2>
			<p>It does not matter to Go how many different files are in a package. You should separate code into as many files as makes sense for readability and logic grouping. However, all the files that are in a package must live in the same directory. The source files should contain code that is related, meaning that if the package is for configuration parsing, you should not have code in there for connecting to a database. The basic structure of a package consists of a directory and contains one or more Go files and related code. The following diagram summarizes the core components of a package structure:</p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/B14177_08_05.jpg" alt="Figure 8.5: Package structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5: Package structure</p>
			<p>One of the commonly used packages in Go is the <strong class="source-inline">strings</strong> package. It contains several Go files that are referred to in the Go documentation as package files. Package files are <strong class="source-inline">.go</strong> source files that are part of the package, for example:</p>
			<ul>
				<li><strong class="source-inline">builder.go</strong></li>
				<li><strong class="source-inline">compare.go</strong></li>
				<li><strong class="source-inline">reader.go</strong></li>
				<li><strong class="source-inline">replace.go</strong></li>
				<li><strong class="source-inline">search.go</strong></li>
				<li><strong class="source-inline">strings.go</strong></li>
			</ul>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor245"/>Package Naming</h2>
			<p>Before we discuss how to declare a package, we need to discuss proper Go naming conventions for a package. The name of your package is significant. It represents what your package contains and identifies its purpose. You can think of a package name as self-documentation. Careful consideration needs to go into naming a package. The name of the package should be short and concise. It should not be verbose. Simple nouns are often chosen for a package name. The following would be poor names for a package:</p>
			<ul>
				<li><strong class="source-inline">stringconversion</strong></li>
				<li><strong class="source-inline">synchronizationprimitives</strong></li>
				<li><strong class="source-inline">measuringtime</strong></li>
			</ul>
			<p>Better alternatives would be the following:</p>
			<ul>
				<li><strong class="source-inline">strconv</strong></li>
				<li><strong class="source-inline">sync</strong></li>
				<li><strong class="source-inline">time</strong><p class="callout-heading">Note</p><p class="callout"><strong class="source-inline">strconv</strong>, <strong class="source-inline">sync</strong>, and <strong class="source-inline">time</strong> are actual Go packages found in the standard library.</p></li>
			</ul>
			<p>Also, the styling of a package is something to take into consideration. The following would be poor style choices for a Go package name:</p>
			<ul>
				<li><strong class="source-inline">StringConversion</strong></li>
				<li><strong class="source-inline">synchronization_primitives</strong></li>
				<li><strong class="source-inline">measuringTime</strong></li>
			</ul>
			<p>In Go, package names should be all lowercase with no underscores. Don't use camel case or snake case styling. There are multiple packages with pluralized names.</p>
			<p>Abbreviations are encouraged, just as long as they are familiar or common in the programming community. The user of the package should easily understand what the package is used for just from its name, for example:</p>
			<ul>
				<li><strong class="source-inline">strconv</strong> (string conversion)</li>
				<li><strong class="source-inline">regexp</strong> (regular expression search)</li>
				<li><strong class="source-inline">sync</strong> (synchronization)</li>
				<li><strong class="source-inline">os</strong> (operating system)</li>
			</ul>
			<p>Avoid package names such as <strong class="source-inline">misc</strong>, <strong class="source-inline">util</strong>, <strong class="source-inline">common</strong>, or <strong class="source-inline">data</strong>. These package names make it harder for the user of your package to understand its purpose. In some cases, there is a deviation from these guidelines, but for the most part, it is something we should strive for:</p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B14177_08_06.jpg" alt="Figure 8.6: Package naming conventions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6: Package naming conventions</p>
			<h2 id="_idParaDest-234"><a id="_idTextAnchor246"/>Package Declarations</h2>
			<p>Every Go file starts with a package declaration. The package declaration is the name of the package. The first line of executable code must be the package declaration:</p>
			<p class="source-code">package &lt;packageName&gt;</p>
			<p>Recall that the <strong class="source-inline">strings</strong> package from the standard library has the following Go source files:</p>
			<p>Each one of those files starts with the package declaration, even though they are all separate files. We will look at an example from the Go standard library. In the Go standard library, there is a package called <strong class="source-inline">strings</strong> (<a href="https://packt.live/35jueEu">https://packt.live/35jueEu</a>). It is made up of multiple files. We will only be looking at a snippet of code from the files in the package: <strong class="source-inline">builder.go</strong>, <strong class="source-inline">compare.go</strong>, and <strong class="source-inline">replace.go</strong>. We have removed comments and some code just to demonstrate that the package files start with the package name. There will be no output from the code snippet. This is an example of how Go organizes code into multiple files but in the same package:</p>
			<p class="source-code-heading">main.go</p>
			<p class="source-code">// https://golang.org/src/strings/builder.go</p>
			<p class="source-code">1  package strings</p>
			<p class="source-code">2  import (</p>
			<p class="source-code">3    "unicode/utf8"</p>
			<p class="source-code">4    "unsafe"</p>
			<p class="source-code">5  )</p>
			<p class="source-code">6  type Builder struct {</p>
			<p class="source-code">7    addr *Builder // of receiver, to detect copies by value</p>
			<p class="source-code">8    buf  []byte</p>
			<p class="source-code">9  }</p>
			<p class="source-code">10 // https://golang.org/src/strings/compare.go</p>
			<p class="source-code">11 package strings</p>
			<p class="source-code">12 func Compare(a, b string) int {</p>
			<p class="source-code">13   if a == b {</p>
			<p class="source-code">14     return 0</p>
			<p class="source-code">15   }</p>
			<p class="source-code-link">The full code is available at: <a href="https://packt.live/35sihwF">https://packt.live/35sihwF</a></p>
			<p>All the functions, types, and variables that are defined in the Go source file are accessible within that package. Though your package could spread across multiple files, it is all part of the same package. Internally, all code is accessible across the files. Simply stated, code is visible within the package. Notice that not all of the code is visible outside of the package. The preceding snippet is from the official Go libraries. For a further explanation of the code, visit the links in the preceding Go snippets.</p>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor247"/>Exported and Unexported Code</h1>
			<p>Go has a very simple way to determine whether code is exported or unexported. Exported means that variables, types, functions, and so on are visible from outside of the package. Unexported means it is only visible from inside the package. If a function, type, variable, and so on starts with an uppercase letter, it is exportable; if it starts with a lowercase letter, it is unexportable. There are no access modifiers to be concerned with in <strong class="source-inline">Go</strong>. If the function name is capitalized, then it is exported, and if it is lowercase, then it is unexported.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is good practice to only expose code that we want other packages to see. We should hide everything else that is not needed by external packages.</p>
			<p>Let's look at the following code snippet:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import ("strings"</p>
			<p class="source-code">"fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  str := "found me"</p>
			<p class="source-code">  if strings.Contains(str, "found") {</p>
			<p class="source-code">    fmt.Println("value found in str")</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>This code snippet uses the <strong class="source-inline">strings</strong> package. We are calling a <strong class="source-inline">strings</strong> function called <strong class="source-inline">Contains</strong>. The <strong class="source-inline">stings.Contains</strong> function searchs the <strong class="source-inline">str</strong> variable to see whether it has the value "<strong class="source-inline">found</strong>" within in it. If "found" is within the <strong class="source-inline">str</strong> variable, the <strong class="source-inline">strings.Constains</strong> will return <strong class="source-inline">true</strong>; if "<strong class="source-inline">found</strong>" is not within the <strong class="source-inline">str</strong> variable, the <strong class="source-inline">strings.Contains</strong> function will return <strong class="source-inline">false</strong>:</p>
			<p class="source-code">strings.Contains(str, "found")</p>
			<p>To call the function, we prefix it with the package name, then the function name.</p>
			<p>This function is exportable, thus is accessible to others outside of the <strong class="source-inline">strings</strong> package. We know it is an exported function because the first letter of the function is capitalized.</p>
			<p>When you import a package, you only have access to the exported names.</p>
			<p>We can validate whether the function exists in the <strong class="source-inline">strings</strong> package by looking at the <strong class="source-inline">strings.go</strong> file:</p>
			<p class="source-code">// https://golang.org/src/strings/strings.go</p>
			<p class="source-code">// Contains reports whether substr is within s.</p>
			<p class="source-code">    func Contains(s, substr string) bool {</p>
			<p class="source-code">    return Index(s, substr) &gt;= 0</p>
			<p class="source-code">    }</p>
			<p>The next code snippet will attempt to access an unexported function in the <strong class="source-inline">strings</strong> package:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "strings"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  str := "found me"</p>
			<p class="source-code">  slc := strings.explode(str, 3)</p>
			<p class="source-code">  fmt.Println(slc)</p>
			<p class="source-code">}</p>
			<p>The function is unexported because it starts with a lowercase letter. Only code within the package can access the function; it is not visible outside of the package.</p>
			<p>The code is attempting to call an unexported function in the <strong class="source-inline">strings.go</strong> package file:</p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/B14177_08_07.jpg" alt="Figure 8.7: Program output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7: Program output</p>
			<p>The following code snippet is from the Go standard library <strong class="source-inline">strings</strong> package and from the <strong class="source-inline">strings.go</strong> file inside of that package (<a href="https://packt.live/2RMxXqh">https://packt.live/2RMxXqh</a>). You can see that the <strong class="source-inline">explode</strong> function is unexportable because the function name starts with a lowercase letter:</p>
			<p class="source-code-heading">main.go</p>
			<p class="source-code">1  // https://golang.org/src/strings/strings.go</p>
			<p class="source-code">2  // explode splits s into a slice of UTF-8 strings,</p>
			<p class="source-code">3  // one string per Unicode character up to a maximum of n (n &lt; 0 means no limit).</p>
			<p class="source-code">4  // Invalid UTF-8 sequences become correct encodings of U+FFFD.</p>
			<p class="source-code">func explode(s string, n int) []string {</p>
			<p class="source-code">5    l := utf8.RuneCountInString(s)</p>
			<p class="source-code">6    if n &lt; 0 || n &gt; l {</p>
			<p class="source-code">7      n = l</p>
			<p class="source-code">8    }</p>
			<p class="source-code">9    a := make([]string, n)</p>
			<p class="source-code">10   for i := 0; i &lt; n-1; i++ {</p>
			<p class="source-code">11     ch, size := utf8.DecodeRuneInString(s)</p>
			<p class="source-code">12     a[i] = s[:size]</p>
			<p class="source-code">13     s = s[size:]</p>
			<p class="source-code">14     if ch == utf8.RuneError {</p>
			<p class="source-code">15       a[i] = string(utf8.RuneError)</p>
			<p class="source-code-link">The full code is available at <a href="https://packt.live/2teXDBN">https://packt.live/2teXDBN</a>.</p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor248"/>GOROOT and GOPATH</h2>
			<p>We have looked at what a package is and its purpose. We have a basic understanding that multiple files can be part of a package construct. We have discussed the idiomatic Go way of naming packages. We have seen all these fundamental concepts being utilized in the Go standard library. We have one more concept to go over before we begin creating our own packages. It is important to understand how the Go compiler looks for the locations of the packages that are used in our applications. </p>
			<p>The Go compiler needs a way to know how to find our source files (packages) so that the compiler can build and install them. The compiler utilizes two environmental variables for this job. <strong class="source-inline">$GOROOT</strong> and <strong class="source-inline">$GOPATH</strong> tell the Go compiler where to search for the locations of the Go packages listed by the <strong class="source-inline">import</strong> statement. </p>
			<p><strong class="source-inline">$GOROOT</strong> is used to tell the Go compiler the location of the Go standard library packages. <strong class="source-inline">$GOROOT</strong> is specific to the Go standard library. It is what Go uses to determine where its standard library packages and tools are located.</p>
			<p><strong class="source-inline">$GOPATH</strong> is the location for packages we create and third-party packages that we may have imported. At the command line, type the following code:</p>
			<p class="source-code">ECHO $GOPATH</p>
			<p>Inside the <strong class="source-inline">$GOPATH</strong> file structure, there are three directories: <strong class="source-inline">bin</strong>, <strong class="source-inline">pkg</strong>, and <strong class="source-inline">src</strong>. The <strong class="source-inline">bin</strong> directory is the easiest to understand. This is where Go places the binaries or executables when you run the <strong class="source-inline">go install</strong> command. One of the main uses of the <strong class="source-inline">pkg</strong> directory is used by the compiler to store object files for the packages the Go compiler builds. This is to help with speeding up the compiling of programs. The <strong class="source-inline">src</strong> directory is the one we are most interested in understanding as it is the directory where we place our packages. This is the directory where we place files with the <strong class="source-inline">.go</strong> extension.</p>
			<p>For example, if we have a package located at <strong class="source-inline">$GOPATH/src/person/address/</strong> and we want to use the address packages, we would need the following <strong class="source-inline">import</strong> statement:</p>
			<p class="source-code">import "person/address"</p>
			<p>Another example would be if we have a package at <strong class="source-inline">$GOPATH/src/company/employee</strong>. If we were interested in using the <strong class="source-inline">employee</strong> package, the <strong class="source-inline">import</strong> statement would be as follows:</p>
			<p class="source-code">import "company/employee"</p>
			<p>Packages that are located in a source code repository would follow a similar pattern. If we wanted to import source code from <a href="https://packt.live/2EKp357">https://packt.live/2EKp357</a>, the location in the filesystem would be <strong class="source-inline">$GOPATH/src/github.com/PacktWorkshops/The-Go-Workshop/Chapter08/Exercise8.01</strong>.</p>
			<p>The import would be as follows:</p>
			<p class="source-code">import "github.com/PacktWorkshops/Get-Ready-To-Go/Chapter08/Exercise8.01"</p>
			<p>The following is a diagram showing the differences between <strong class="source-inline">$GOROOT</strong> and <strong class="source-inline">$GOPATH</strong>:</p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/B14177_08_08.jpg" alt="Figure 8.8: GOROOT and GOPATH comparisons&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8: GOROOT and GOPATH comparisons</p>
			<p>We are going to create a simple package called <strong class="source-inline">msg</strong>. The location of this file is within <strong class="source-inline">$GOPATH</strong> <strong class="source-inline">$GOPATH/msg/msg.go</strong>:</p>
			<p class="source-code">package msg</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">//Greeting greets the input parameter</p>
			<p class="source-code">func Greeting(str string) {</p>
			<p class="source-code">    fmt.Printf("Greeting %s\n", str)</p>
			<p class="source-code">}</p>
			<p>The package is named <strong class="source-inline">msg</strong>.</p>
			<p>It has one exported function. The function takes a string and prints <strong class="source-inline">"Greeting"</strong> to the argument passed to the function.</p>
			<p>To be able to use Go packages and our custom packages, we must import them. The <strong class="source-inline">import</strong> declaration contains the path location and the name of the package. The name of the package is the last directory that contains the package files. For example, if we have a directory structure in the <strong class="source-inline">$GOPATH</strong> location, <strong class="source-inline">packt/chpkg/test/mpeg</strong>, the package name would be <strong class="source-inline">mpeg</strong>.</p>
			<p>The following code snippet is the <strong class="source-inline">main</strong> package file. It is in the following directory structure inside <strong class="source-inline">$GOPATH</strong>:</p>
			<p><strong class="source-inline">$GOPATH/demoimport/demoimport.go</strong>:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "msg"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  fmt.Println("Demo Import App")</p>
			<p class="source-code">  msg.Greeting("George")</p>
			<p class="source-code">}</p>
			<p>The output will be as follows:</p>
			<p class="source-code">Greeting George</p>
			<p>This basic program imports the <strong class="source-inline">msg</strong> package. Since we have imported the <strong class="source-inline">msg</strong> package, we can then call any exportable function in the package by preferencing it with <strong class="source-inline">"msg.&lt;functionName&gt;"</strong>. We know that our <strong class="source-inline">msg</strong> package has an exportable function called <strong class="source-inline">Greeting</strong>. We call the exportable <strong class="source-inline">Greeting</strong> function from our <strong class="source-inline">msg</strong> package and get the output in the preceding figure.</p>
			<p>When creating a package, it can contain multiple files within the same directory. We need to make sure that each of those files in that directory belongs to the same package. If you have a <strong class="source-inline">shape</strong> package and, in that directory, you have two files, but each has a different package declaration, the Go compiler will return an error:</p>
			<p><strong class="source-inline">shape.go</strong></p>
			<p class="source-code">package shape</p>
			<p><strong class="source-inline">junk.go</strong></p>
			<p class="source-code">package notright</p>
			<p>If you attempted to perform a build, you would get the following error:</p>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/B14177_08_09.jpg" alt="Figure 8.9: Program output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9: Program output</p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor249"/>Package Alias</h2>
			<p>Go also has the ability to alias package names. There a few reasons that you may want to use alias names:</p>
			<ul>
				<li>The package name may not make it easy to understand its purpose. For the purpose of clarity, it might be better to alias a different name for the package.</li>
				<li>The package name might be too long. In this case, you want the alias to be more concise and less verbose.</li>
				<li>There could be scenarios where the package path is unique but both package names are the same. You would need to then use aliasing to differentiate between the two packages.</li>
			</ul>
			<p>The package aliasing syntax is very simple. You place the alias name before the <strong class="source-inline">import</strong> package path:</p>
			<p class="source-code">import  f "fmt"</p>
			<p>Here is a simple example showing how to use package aliasing:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  f "fmt"</p>
			<p class="source-code">  //"fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  f.Println("Hello, Gophers")</p>
			<p class="source-code">}</p>
			<p class="source-code">import (</p>
			<p class="source-code">  f "fmt"</p>
			<p>We are aliasing the <strong class="source-inline">fmt</strong> package as <strong class="source-inline">f</strong>:</p>
			<p class="source-code">  f.Println("Hello, Gophers")</p>
			<p>In the <strong class="source-inline">main()</strong> function, we are now able to call the <strong class="source-inline">Println()</strong> function using the <strong class="source-inline">f</strong> alias.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor250"/>Main Package</h2>
			<p>The main package is a special package. There are two basic types of packages in Go: executable and non-executable. The main package is an executable package in Go. The main package requires there to be a <strong class="source-inline">main()</strong> function in its package. The <strong class="source-inline">main()</strong> function is the entry point for a Go executable. When you perform <strong class="source-inline">go build</strong> on the main package, it will compile the package and create a binary. The binary is created inside of the directory where the main package is located. The name of the binary will be the name of the folder it resides in:</p>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/B14177_08_10.jpg" alt="Figure 8.10: Main package functionality&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10: Main package functionality</p>
			<p>Here's a simple example of the main package code:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  fmt.Println("Hello Gophers!")</p>
			<p class="source-code">}</p>
			<p>The expected output is as follows:</p>
			<p class="source-code">Hello Gophers !</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor251"/>Exercise 8.01: Creating a Package to Calculate Areas of Various Shapes</h2>
			<p>In <em class="italic">Chapter 7</em>, <em class="italic">Interfaces</em>, we implemented code to calculate areas of different shapes. In this exercise, we will move all the code about shapes into a package called <strong class="source-inline">shape</strong>. We will then update the code in the package shape to be exportable. Then, we will update <strong class="source-inline">main</strong> to import our new <strong class="source-inline">shape</strong> package. However, we want it to still perform the same functionality in the <strong class="source-inline">main()</strong> function of the main package.</p>
			<p>Here is the code that we will be converting into packages:</p>
			<p class="Normal" lang="en-US" xml:lang="en-US"><a href="https://packt.live/36zt6gv">https://packt.live/36zt6gv</a>.</p>
			<p>You should have a directory structure within your <strong class="source-inline">$GOPATH</strong> and files in those appropriate directories, as displayed in the following screenshot:</p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/B14177_08_11.jpg" alt="Figure 8.11: Program directory structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11: Program directory structure</p>
			<p>The <strong class="source-inline">shape.go</strong> file should contain the entire code: </p>
			<p class="Normal" lang="en-US" xml:lang="en-US"><a href="https://packt.live/2PFsWNx">https://packt.live/2PFsWNx</a>.</p>
			<p>We will only be going over the changes that are relevant to making this code a package, and for details on the parts of the code that we have gone over in a previous chapter, please see <em class="italic">Chapter 7</em>, <em class="italic">Interfaces</em>:</p>
			<ol>
				<li>Create a directory called <strong class="source-inline">Exercise8.01</strong> inside <strong class="source-inline">Chapter08</strong>.</li>
				<li>Create two more directories called <strong class="source-inline">area</strong> and <strong class="source-inline">shape</strong> inside the <strong class="source-inline">Exercise8.01</strong> directory.</li>
				<li>Create a file called <strong class="source-inline">main.go</strong> inside the <strong class="source-inline">Exercise8.01/area</strong> directory.</li>
				<li>Create a file called <strong class="source-inline">shape.go</strong> inside the <strong class="source-inline">Exercise8.01/shape</strong> directory.</li>
				<li>Open the <strong class="source-inline">Exercise8.01/shape.go</strong> file.</li>
				<li>Add the following code:<p class="source-code">package shape</p><p class="source-code">import "fmt"</p><p>The first line of code in this file tells us this is a non-executable package called <strong class="source-inline">shape</strong>. A non-executable package, when compiled, does not result in binary or executable code. Recall that a <strong class="source-inline">main</strong> package is a package that is executable.</p></li>
				<li>Next, we need to make the types exportable. For each <strong class="source-inline">struct</strong> type, we have to capitalize on the type name and its fields to make it exportable. Exportable means that it is visible outside of this package:<p class="source-code">type Shape interface {</p><p class="source-code">  area() float64</p><p class="source-code">  name() string</p><p class="source-code">}</p><p class="source-code">type Triangle struct {</p><p class="source-code">  Base   float64</p><p class="source-code">  Height float64</p><p class="source-code">}</p><p class="source-code">type Rectangle struct {</p><p class="source-code">  Length float64 </p><p class="source-code">  Width  float64</p><p class="source-code">}</p><p class="source-code">type Square struct {</p><p class="source-code">  Side float64</p><p class="source-code">}</p></li>
				<li>We also have to make the methods non-exportable, by changing the method name to lowercase. There is no need at the moment to make those methods visible outside of the package:<p class="source-code-heading">Exercise8.01</p><p class="source-code">18 func PrintShapeDetails(shapes ...Shape) {</p><p class="source-code">19   for _, item := range shapes {</p><p class="source-code">20     fmt.Printf("The area of %s is: %.2f\n", item.name(), item.area())</p><p class="source-code">21   }</p><p class="source-code">22 }</p><p class="source-code">23 func (t Triangle) area() float64 {</p><p class="source-code">24   return (t.Base * t.Height) / 2</p><p class="source-code">25 }</p><p class="source-code">26 func (t Triangle) name() string {</p><p class="source-code">27   return "Triangle"</p><p class="source-code">28 }</p><p class="source-code">29 func (r Rectangle) area() float64 {</p><p class="source-code">30   return r.Length * r.Width</p><p class="source-code">31 }</p><p class="source-code">32 func (r Rectangle) name() string {</p><p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/2rngdHf">https://packt.live/2rngdHf</a>.</p></li>
				<li>The <strong class="source-inline">PrintShapeDetails</strong> function also needs to be capitalized:<p class="source-code">func PrintShapeDetails(shapes ...Shape) {</p><p class="source-code">  for _, item := range shapes {</p><p class="source-code">    fmt.Printf("The area of %s is: %.2f\n", item.name(), item.area())</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Perform a build to ensure that there are no compile errors:<p class="source-code">go build</p></li>
				<li>Here is the listing for the <strong class="source-inline">main.go</strong> file. By having a package as <strong class="source-inline">main</strong>, we know that this is executable:<p class="source-code">package main</p></li>
				<li>The <strong class="source-inline">import</strong> declaration only has one import. It is the <strong class="source-inline">shape</strong> package. The path location is <strong class="source-inline">$GOPATH</strong> plus the <strong class="source-inline">import</strong> path declaration. We can see the name of the package is <strong class="source-inline">shape</strong> since it is the last directory name in the path declaration. The <strong class="source-inline">$GOPATH</strong> mentioned here may differ from yours:<p class="source-code">import (</p><p class="source-code">  import "github.com/PacktWorkshops/The-Go-Workshop/Chapter08/Exercise8.01/shape"</p><p class="source-code">)</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, we are initializing the <strong class="source-inline">shape</strong> package's exportable types:<p class="source-code">func main() {</p><p class="source-code">  t := shape.Triangle{Base: 15.5, Height: 20.1}</p><p class="source-code">  r := shape.Rectangle{Length: 20, Width: 10}</p><p class="source-code">  s := shape.Square{Side: 10}</p></li>
				<li>We then call the <strong class="source-inline">shape()</strong> function, <strong class="source-inline">PrintShapeDetails</strong>, to get the area of each shape:<p class="source-code">  shape.PrintShapeDetails(t, r, s)</p><p class="source-code">}</p></li>
				<li>At the command line, go to the <strong class="source-inline">\Exercise8.01\area</strong> directory structure.</li>
				<li>At the command line, type the following:<p class="source-code">go build</p></li>
				<li>The <strong class="source-inline">go build</strong> command will compile your program and create an executable named after the <strong class="source-inline">dir</strong> area.</li>
				<li>Type the executable name and hit <em class="italic">Enter</em>:<p class="source-code">./ar<a id="_idTextAnchor252"/>ea</p><p>The expected output is as follows:</p><p class="source-code">The area of Triangle is: 155.78</p><p class="source-code">The area of Rectangle is: 200.00</p><p class="source-code">The area of Square is 100.00</p></li>
			</ol>
			<p>We now have the functionality that we previously had in the interface chapter's implementation of <strong class="source-inline">shape</strong>. We have the <strong class="source-inline">shape</strong> functionality now encapsulated in the <strong class="source-inline">shape</strong> package. We exposed or made visible only the functions or methods that are needed to maintain the previous implementation. The <strong class="source-inline">main</strong> package has less clutter and imports the <strong class="source-inline">shape</strong> package to provide the functionality that was in the previous implementation.</p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor253"/>The init() Function</h1>
			<p>As we have discussed, every Go program (executable) starts in the <strong class="source-inline">main</strong> package and the entry point is the <strong class="source-inline">main</strong> function. There is another special function that we should be aware of, called <strong class="source-inline">init()</strong>. Each source file can have an <strong class="source-inline">init()</strong> function, but for now, we will look at the <strong class="source-inline">init</strong> function in the context of the <strong class="source-inline">main</strong> package. When you start writing packages, you might need to provide some initialization (the <strong class="source-inline">init()</strong> function) for the package. The <strong class="source-inline">init()</strong> function is used to set up states or values. The <strong class="source-inline">init()</strong> function adds initialization logic for your package. Here are some examples of uses of the <strong class="source-inline">init()</strong> function:</p>
			<ul>
				<li>Setting database objects and connections</li>
				<li>The initialization of package variables</li>
				<li>Creating files </li>
				<li>Loading configuration data</li>
				<li>Verifying or repairing the program state</li>
			</ul>
			<p>The <strong class="source-inline">init()</strong> function requires the following pattern to be called:</p>
			<ul>
				<li>Imported packages are initialized first.</li>
				<li>Package-level variables are initialized.</li>
				<li>The package's <strong class="source-inline">init()</strong> function is called.</li>
				<li><strong class="source-inline">main</strong> is executed.</li>
			</ul>
			<p>The following diagram shows the execution order that a typical Go program follows:</p>
			<div>
				<div id="_idContainer142" class="IMG---Figure">
					<img src="image/B14177_08_12.jpg" alt="Figure 8.12: Order of execution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.12: Order of execution</p>
			<p>Here is a simple example that demonstrates the <strong class="source-inline">package main</strong> order of execution:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">var name = "Gopher"</p>
			<p class="source-code">func init() {</p>
			<p class="source-code">  fmt.Println("Hello, ",name)</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  fmt.Println("Hello, main function")</p>
			<p class="source-code">}</p>
			<p>The output of the code is as follows:</p>
			<p class="source-code">Hello, Gopher</p>
			<p class="source-code">Hello, main function</p>
			<p>Let's understand the code in parts:</p>
			<p class="source-code">var name = "Gopher"</p>
			<p>Based on the output of the code, the package level variable declaration got executed first. We know this because the <strong class="source-inline">name</strong> variable is printed in the <strong class="source-inline">init()</strong> function:</p>
			<p class="source-code">func init() {</p>
			<p class="source-code">  fmt.Println("Hello, ",name)</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">init()</strong> function then gets called and prints out <strong class="source-inline">"Hello, Gopher"</strong>:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  fmt.Println("Hello, main function")</p>
			<p class="source-code">}</p>
			<p>Finally, the <strong class="source-inline">main()</strong> function is executed:</p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/B14177_08_13.jpg" alt="Figure 8.13: Execution flow of the code snippet&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.13: Execution flow of the code snippet</p>
			<p>The <strong class="source-inline">init()</strong> function cannot have any arguments or return values:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">var name = "Gopher"</p>
			<p class="source-code">func init(age int) {</p>
			<p class="source-code">  fmt.Println("Hello, ",name)</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  fmt.Println("Hello, main function")</p>
			<p class="source-code">}</p>
			<p>Running this code snippet will result in the following error:</p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/B14177_08_14.jpg" alt="Figure 8.14: Program output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.14: Program output</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor254"/>Exercise 8.02: Loading Budget Categories</h2>
			<p>Write a program that will load budget categories into a global map, before the <strong class="source-inline">main</strong> function runs. The <strong class="source-inline">main</strong> function should then print out the data on the map:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">main.go</strong> file.</li>
				<li>The code file will belong to <strong class="source-inline">package main</strong> and will need to import the <strong class="source-inline">fmt</strong> package:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create a global variable that will contain a map of budget categories with a key of <strong class="source-inline">int</strong> and a value of <strong class="source-inline">string</strong>:<p class="source-code">var budgetCategories = make(map[int]string)</p></li>
				<li>We will need to use an <strong class="source-inline">init()</strong> function to load our budget categories before <strong class="source-inline">main</strong> runs:<p class="source-code">func init() {</p><p class="source-code">    fmt.Println("Initializing our budgetCategories")</p><p class="source-code">    budgetCategories[1] = "Car Insurance"</p><p class="source-code">    budgetCategories[2] = "Mortgage"</p><p class="source-code">    budgetCategories[3] = "Electricity"</p><p class="source-code">    budgetCategories[4] = "Retirement"</p><p class="source-code">    budgetCategories[5] = "Vacation"</p><p class="source-code">    budgetCategories[7] = "Groceries"</p><p class="source-code">    budgetCategories[8] = "Car Payment"</p><p class="source-code">}</p></li>
				<li>Since our budget categories have been loaded, we can now iterate over the map and print them:<p class="source-code">func main() {</p><p class="source-code">    for k, v := range budgetCategories {</p><p class="source-code">        fmt.Printf("key: %d, value: %s\n", k, v)</p><p class="source-code">    }</p><p class="source-code">}</p><p>We will get the following output:</p><p class="source-code">Initializing our budgetCategories</p><p class="source-code">key: 5, value: Vacation</p><p class="source-code">key: 7, value: Groceries</p><p class="source-code">key: 8, value: Car Payment</p><p class="source-code">key: 1, value: Car Insurance</p><p class="source-code">key: 2, value: Mortgage</p><p class="source-code">key: 3, value: Electricity</p><p class="source-code">key: 4, value: Retirement</p></li>
			</ol>
			<p>The aim here was to demonstrate how the <strong class="source-inline">init()</strong> function can be used to perform data initialization and loading before the <strong class="source-inline">main</strong> function executes. Data that generally needs to be loaded before <strong class="source-inline">main</strong> runs is static data, such as picklist values or some sort of configuration. As demonstrated, after the data gets loaded through the <strong class="source-inline">init</strong> function, it can be used by the <strong class="source-inline">main</strong> function. In the next topic, we will see how multiple <strong class="source-inline">init</strong> functions get executed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The output may differ in terms of the order displayed; Go maps do not guarantee the order of data.</p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor255"/>Executing Multiple init() Functions</h2>
			<p>There can be more than one <strong class="source-inline">init()</strong> function in a package. This enables you to modularize your initialization for better code maintenance. For example, suppose you need to set up various files and database connections and repair the state of the environment that your program will be executed in. Doing all that in one <strong class="source-inline">init()</strong> function would make it complicated for maintaining and debugging. The order of execution of multiple <strong class="source-inline">init()</strong> functions is the order in which the functions are placed in the code:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">var name = "Gopher"</p>
			<p class="source-code">func init() {</p>
			<p class="source-code">  fmt.Println("Hello, ",name)</p>
			<p class="source-code">}</p>
			<p class="source-code">func init(){</p>
			<p class="source-code">  fmt.Println("Second")</p>
			<p class="source-code">}</p>
			<p class="source-code">func init(){</p>
			<p class="source-code">  fmt.Println("Third")</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  fmt.Println("Hello, main function")</p>
			<p class="source-code">}</p>
			<p>Let's break the code into parts and evaluate it:</p>
			<p class="source-code">var name = "Gopher"</p>
			<p>Go initializes the <strong class="source-inline">name</strong> variable first, before the <strong class="source-inline">init</strong> function gets executed:</p>
			<p class="source-code">func init(){</p>
			<p class="source-code">  fmt.Println("Hello, ",name)</p>
			<p class="source-code">}</p>
			<p>This prints out first since it is the first <strong class="source-inline">init</strong> in the function:</p>
			<p class="source-code">func init(){</p>
			<p class="source-code">  fmt.Println("Second")</p>
			<p class="source-code">}</p>
			<p>The preceding gets printed out second since it is the second <strong class="source-inline">init</strong> in the function:</p>
			<p class="source-code">func init(){</p>
			<p class="source-code">  fmt.Println("Third")</p>
			<p class="source-code">}</p>
			<p>The preceding gets printed out third since it is the third <strong class="source-inline">init</strong> in the function:</p>
			<p class="source-code">func main(){</p>
			<p class="source-code">  fmt.Println("Hello, main function")</p>
			<p class="source-code">}</p>
			<p>Finally, the <strong class="source-inline">main()</strong> function gets executed.</p>
			<p>The results would be as follows:</p>
			<p class="source-code">Hello, Gopher</p>
			<p class="source-code">Second</p>
			<p class="source-code">Third</p>
			<p class="source-code">Hello, main function</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor256"/>Exercise 8.03: Assigning Payees to Budget Categories</h2>
			<p>We are going to expand our program from <em class="italic">Exercise 8.02</em>, <em class="italic">Loading Budget Categories</em>, to now assign payees to budget categories. This is similar to many budgeting applications that try to match payees to commonly used categories. We will then print the mapping of a payee to a category:</p>
			<ol>
				<li value="1">Create the <strong class="source-inline">main.go</strong> file.</li>
				<li>Copy the code from <em class="italic">Exercise 8.02</em>, <em class="italic">Load Budget Categories</em>, <a href="https://github.com/PacktWorkshops/The-Go-Workshop/blob/master/Chapter08/Exercise8.02/main.go">https://github.com/PacktWorkshops/The-Go-Workshop/blob/master/Chapter08/Exercise8.02/main.go</a> into the <strong class="source-inline">main.go</strong> file.</li>
				<li>Add a <strong class="source-inline">payeeToCategory</strong> map after <strong class="source-inline">budgetCategories</strong>:<p class="source-code">var budgetCategories = make(map[int]string)</p><p class="source-code">var payeeToCategory = make(map[string]int)</p></li>
				<li>Add another <strong class="source-inline">init()</strong> function. This <strong class="source-inline">init()</strong> function will be used to populate our new <strong class="source-inline">payeeToCategory</strong> map. We will assign payees to the key value of the categories:<p class="source-code-heading">main.go</p><p class="source-code">5  func init() {</p><p class="source-code">6      fmt.Println("Initializing our budgetCategories")</p><p class="source-code">7      budgetCategories[1] = "Car Insurance"</p><p class="source-code">8      budgetCategories[2] = "Mortgage"</p><p class="source-code">9      budgetCategories[3] = "Electricity"</p><p class="source-code">10     budgetCategories[4] = "Retirement"</p><p class="source-code">11     budgetCategories[5] = "Vacation"</p><p class="source-code">12     budgetCategories[7] = "Groceries"</p><p class="source-code">13     budgetCategories[8] = "Car Payment"</p><p class="source-code">14 }</p><p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/2Qdss1E">https://packt.live/2Qdss1E</a>.</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, we will print out the payees to categories. We iterate over the <strong class="source-inline">payeeToCategory</strong> map, printing the key (<strong class="source-inline">payee</strong>). We print the category by passing the value of the <strong class="source-inline">payeeToCategory</strong> map as a key to the <strong class="source-inline">budgetCategories</strong> map:<p class="source-code">func main() {</p><p class="source-code">    fmt.Println("In main, printing payee to category")</p><p class="source-code">    for k, v := range payeeToCategory {</p><p class="source-code">        fmt.Printf("Payee: %s, Category: %s\n", k, budgetCategories[v])</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here's the expected output:</p>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/B14177_08_15.jpg" alt="Figure 8.15: Assign a payee to budget categories&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.15: Assign a payee to budget categories</p>
			<p>You have now created a program that executes multiple <strong class="source-inline">init()</strong> functions before the execution of the <strong class="source-inline">main</strong> function. Each of the <strong class="source-inline">init()</strong> functions loaded data into our global map variables. We have determined the order of <strong class="source-inline">init</strong> functions executing because of the <strong class="source-inline">print</strong> statements that get displayed. This demonstrates that the <strong class="source-inline">init()</strong> functions print in the order they are present in the code. It is important to be aware of the order of your <strong class="source-inline">init</strong> functions as you may have unforeseen results based on the order of the code execution.</p>
			<p>In the upcoming activity, we will be using all these concepts that we have looked at with packages and see how they all work together.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor257"/>Activity 8.01: Creating a Function to Calculate Payroll and Performance Review</h2>
			<p>In this activity, we are going to take <em class="italic">Activity 7.01</em>, <em class="italic">Calculating Pay and Performance Review</em>, and modularize it using packages. We will be refactoring the code from <a href="https://packt.live/2YNnfS6">https://packt.live/2YNnfS6</a>:</p>
			<ol>
				<li value="1">Move the types and methods of <strong class="source-inline">Developer</strong>, <strong class="source-inline">Employee</strong>, and <strong class="source-inline">Manager</strong> into their own package. Types, methods, and functions must be properly exported or unexported.</li>
				<li>Name the package <strong class="source-inline">payroll</strong>.</li>
				<li>Logically separate the types and their methods into different package files. Recall that good code organization involves separating similar functionality into separate files.</li>
				<li>Create the <strong class="source-inline">main()</strong> function as an alias to the <strong class="source-inline">payroll</strong> package.</li>
				<li>Introduce the two <strong class="source-inline">init()</strong> functions in the <strong class="source-inline">main</strong> package. The first <strong class="source-inline">init()</strong> function should simply print a greeting message to <strong class="source-inline">stdout</strong>. The second <strong class="source-inline">init()</strong> should initialize/set up the key-value pairs.<p>The expected output would be as follows:</p><p class="source-code">Welcome to the Employee Pay and Performance Review</p><p class="source-code">++++++++++++++++++++++++++++++++++++++++++++++++++</p><p class="source-code">Initializing variables</p><p class="source-code">Eric Davis got a review rating of 2.80</p><p class="source-code">Eric Davis got paid 84000.00 for the year</p><p class="source-code">Mr. Boss got paid 160500.00 for the year</p></li>
			</ol>
			<p>In this activity, we have seen how to use packages to separate our code and then to logically separate the code into individual files. We can see that each of those files make up a package. Each file of the package has internal access to the other files regardless of the fact that they are in separate files. This activity demonstrates how to create a package with multiple files and how those separate files can be used to further organize our code.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 720.</p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor258"/>Summary</h1>
			<p>We look<a id="_idTextAnchor259"/>ed at the importance of developing software that is maintainable, reusable, and modular. We discovered how Go's packages play an important part in meeting those criteria for developing software. We looked at the overall structure of a package. It is made up of a directory, can contain one or more files, and it has code that is related. A package is essentially a directory inside of your workspace that contains one or more files that are used for grouping code that is to perform a task. It exposes only the necessary parts to those using your package to get a job done. We discussed the importance of naming packages properly. We also learned how to name a package, that is, concisely, in lowercase, descriptively, using non-plural names, and avoiding generic names. Packages can be executable or non-executable. If a package is the main package, then it is an executable package. The main package must have a main function and that is where the entry point is for our package.</p>
			<p>We also talked about what is exportable and unexportable code. When we capitalize the name of a function, type, or method, it is visible to others using our package. Lowercasing a function, type, or method makes it not visible to other users from outside our package. When creating a package, we realized that <strong class="source-inline">GOROOT</strong> and <strong class="source-inline">GOPATH</strong> are important to know – they determine where Go looks for a package. We learned that <strong class="source-inline">init</strong> functions can perform the following duties: initializing variables, loading configuration data, setting database connections, or verifying that our program state is ready for execution. The <strong class="source-inline">init()</strong> function has certain rules when it gets executed and on how to utilize it. This chapter will help you to write highly manageable, reusable, and modular code.</p>
			<p>In the next chapter, we will be studying basic debugging. We will look at various techniques that help us to locate bugs in our programs. We will also discuss ways to minimize the difficulty of locating bugs and how to increase the chances of locating a bug after making a modification to the codebase.</p>
		</div>
		<div>
			<div id="_idContainer147" class="Content">
			</div>
		</div>
	</body></html>