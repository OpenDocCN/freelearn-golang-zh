<html><head></head><body>
		<div>
			<div id="_idContainer148" class="Content">
			</div>
		</div>
		<div id="_idContainer149" class="Content">
			<h1 id="_idParaDest-246"><a id="_idTextAnchor260"/>9. Basic Debugging</h1>
		</div>
		<div id="_idContainer164" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we will look at basic debugging methodologies. We will look at some proactive measures that we can take to reduce the number of bugs that we introduce into our program. Once we understand these measures, we will investigate the ways in which we can locate a bug.</p>
			<p class="callout">You will be able to acquaint yourself with debugging in Go and implement various ways to format printing. You will evaluate various techniques of basic debugging and find the general location of a bug in the code. By the end of the chapter, you will know to print out variable types and values using Go code and also log the state of an application for debugging purposes.</p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor261"/>Introduction</h1>
			<p>As you develop software programs, there are going to be times that your program behaves in an unintended way. For instance, the program could be throwing an error and might crash. A crash is when our code stops functioning midway and then exits abruptly. Perhaps, the program has given us unexpected results. For example, we request a video streaming service for the movie <em class="italic">Rocky 1</em>, but instead get <em class="italic">Creed 1!</em> Or, you deposited a check into your bank account but, instead of being credited, the bank software debited your account. These examples of software programs behaving in an unintended way are called bugs. Sometimes, "bug" and "error" are used interchangeably. In <em class="italic">Chapter 6</em>, <em class="italic">Errors</em>, in the <em class="italic">What Are Errors?</em> section, we discussed how there are three different types of errors or bugs: syntax errors, runtime errors, and logic errors. We also examined examples and saw the difficulty of discovering the location of each type of error.</p>
			<p>The process of determining the cause of unintended behavior is called debugging. There are various causes of bugs that get released into production:</p>
			<ul>
				<li><strong class="bold">Testing is performed at the end of the development</strong>: During the development life cycle, it is tempting to not perform testing incrementally. For instance, we are creating multiple functions for an application, and once we finish all the functions, they then get tested. A possibly better way of testing our code would be to test each function as we complete it. This is known as incrementally testing or delivering code in smaller chunks. This gives us better code stability. This is accomplished by testing a function to ensure it works before continuing to the next function. The function that we just completed could be used by other functions. If we do not test it before we continue, the other functions that use our function could be using a buggy function. Depending on the bug and the change to our function, it could impact other users of our function. Later in the chapter, we will discuss some more benefits of coding and testing incrementally. </li>
				<li><strong class="bold">Application enhancements or changes to requirements</strong>: Our code is often changing between the development phase and when we release it to production. Once in production, we receive feedback from the users; the feedback could be additional requirements or even enhancements to the code. Changing the production-level code in one area could have a negative impact in another area. If the development team uses unit tests, then this would aid in mitigating some of the bugs introduced in a change to the code base. By using unit tests, we could run our unit test before we deliver the code to see whether our change had a negative impact. We will discuss what a unit test is later.</li>
				<li><strong class="bold">Unrealistic development timeframe</strong>: There are times when functionality is requested to be delivered in very tight timeframes. This can lead to taking shortcuts in best practices, shortening the design phase, performing less testing, and receiving unclear requirements. All of those can increase the chance of introducing bugs.</li>
				<li><strong class="bold">Unhanding of errors</strong>: Some developers may choose not to handle errors as they occur. For example, a file that is needed for the application to load configuration data is not found, not handling an error return for an invalid mathematical operation such as dividing by zero, or perhaps a connection to a server could not be established. If your program does not properly handle these and other types of errors, this can cause bugs.</li>
			</ul>
			<p>These are just a few causes of bugs. Bugs have a negative impact on our programs. The results of a bug that causes a miscalculation can be life-threatening. In the medical industry, a machine is used to administer a drug called heparin; this drug is a blood thinner, and it is used to prevent blood clots. If the code that determines the calculation of how often and how much heparin can be administered has a bug that causes it to malfunction, the machine could deliver too much or too little of the drug. This could have an adverse effect on the patient. As you can see, it is critical to deliver software that is as bug-free as possible. In this chapter, we are going to look at some ways to minimize the number of bugs that are introduced and ways of isolating the location of the bug.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor262"/>Methods for Bug-Free Code</h1>
			<p>We will briefly look at some methods that will help us to minimize the number of bugs that could be introduced into our code. These methods will also aid in giving us confidence as to the portions of the code that introduced the bug:<a id="_idTextAnchor263"/></p>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/B14177_09_01.jpg" alt="Figure 9.1: Different methods to debug code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1: Different methods to debug code</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor264"/>Code Incrementally and Test Often</h2>
			<p>Let's consider the approach of developing incrementally. This means developing the program incrementally and testing it often after adding an incremental piece of code. This pattern will help you to track the bug easily because you are testing every small snippet of code as opposed to one large program.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor265"/>Writing Unit Tests</h2>
			<p>When a test is written and code changes occur, the unit test protects the code from potential bugs being introduced. A typical unit test takes a given input and validates that a given result is produced. If the unit test is passing before the code change, but is now failing after the code change, then we can conclude that we introduced some unintended behavior. The unit test needs to pass before we push our code to a production system.</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor266"/>Handling All Errors</h2>
			<p>This was discussed in <em class="italic">Chapter 6</em>, <em class="italic">Errors</em>. Ignoring errors can lead to potentially unintended results in our program. We need to handle the errors properly to make the debugging process easier.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor267"/>Performing Logging</h2>
			<p>Logging is another technique that we can use to determine what is occurring in the program. There are various types of logging; some of the common logging types are debug, info, warn, error, fatal, and trace. We will not go into the details of each type; we will focus instead on performing debug type logging. This type of logging is typically used to determine the state of the program before a bug occurs. Some of the information that is gathered includes the values of the variables, the portion of the code that is being executed (one example would be function name), the values of the arguments being passed, the output of the function or method, and more. In this chapter, we will be performing our own custom debug logging using built-in features of the Go standard library. The built-in log package of Go can provide timestamps. This is useful when trying to understand the timing of various events. When you perform logging, you will need to keep in mind the performance implications. Depending on the application and the load it is under, the logging could be extensive during peak times and may have a negative impact on the performance of the application. In certain circumstances, it could cause it to be unresponsive.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor268"/>Formatting Using fmt</h2>
			<p>One of the uses of the <strong class="source-inline">fmt</strong> package is to display data to the console or to the filesystem, such as a text file, that will contain information that could be helpful in debugging the code. We have used the <strong class="source-inline">Println()</strong> function on numerous occasions. Let's take a slightly deeper look at the functionality of <strong class="source-inline">fmt.Println()</strong>. The <strong class="source-inline">fmt.Println()</strong> function places spaces between the variables and then appends a new line at the end of the string. The <strong class="source-inline">fmt.Println()</strong> function prints the default formats of the variables.</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor269"/>Exercise 9.01: Working with fmt.Println</h2>
			<p>In this exercise, we will print a <strong class="source-inline">hello</strong> statement using <strong class="source-inline">fmt.Println</strong>:</p>
			<ol>
				<li>Import the <strong class="source-inline">fmt</strong> package:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">    "fmt"</p><p class="source-code">)</p></li>
				<li>Declare the <strong class="source-inline">fname</strong> and <strong class="source-inline">lname</strong> variables in a <strong class="source-inline">main()</strong> function, and assign two strings to a variable:<p class="source-code">func main() {</p><p class="source-code">    fname:= "Edward"</p><p class="source-code">    lname:= "Scissorhands"</p></li>
				<li>Call the <strong class="source-inline">Println</strong> method from the <strong class="source-inline">fmt</strong> package. It will print <strong class="source-inline">Hello:</strong> and then the value of both variables followed by a space. Then, it will print a <strong class="source-inline">\n</strong> (newline) to the standard output:<p class="source-code">    fmt.Println("Hello:",fname,lname)</p></li>
				<li>The following statement prints <strong class="source-inline">Next Line</strong> plus <strong class="source-inline">\n</strong> to the standard output:<p class="source-code">    fmt.Println("Next Line")</p><p class="source-code">}</p><p>The output is as follows:</p><p class="source-code">Hello: Edward Scissorhands</p><p class="source-code">Next Line</p></li>
			</ol>
			<p>We have demonstrated the basics of printing out messages. In the next topic, we will look at how we can format the data that we want to print.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor270"/>Formatting Using fmt.Printf()</h2>
			<p>The <strong class="source-inline">fmt</strong> package also has numerous ways of formatting the output of our various print statements. We will look next at the <strong class="source-inline">fmt.Printf()</strong>.</p>
			<p>The <strong class="source-inline">fmt.Printf()</strong> formats the string according to the verb and prints it to <strong class="source-inline">stdout</strong>. The standard output (<strong class="source-inline">stdout</strong>) is a stream for output. By default, the standard output is pointed to the terminal. The function uses something called format verbs or sometimes called a format specifier. The verbs tell the <strong class="source-inline">fmt</strong> function where to insert the variable. For example, <strong class="source-inline">%s</strong> prints a string; it is a placeholder for a string. These verbs are based upon the C language:</p>
			<div>
				<div id="_idContainer151" class="IMG---Figure">
					<img src="image/B14177_09_02.jpg" alt="Figure 9.2: Explanation of Printf&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2: Explanation of Printf</p>
			<p>Consider the following example:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">    "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    fname:= "Edward"</p>
			<p class="source-code">    fmt.Printf("Hello %s, good morning",fname)</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">fname</strong> variable is assigned as <strong class="source-inline">Edward</strong>. When the <strong class="source-inline">fmt.Printf()</strong> function runs, the <strong class="source-inline">%s</strong> verb will have the value of <strong class="source-inline">fname</strong>.</p>
			<p>The output is as follows:</p>
			<p class="source-code">Hello Edward, good morning</p>
			<p>But what happens when we have more than one variable that we want to print? How can we print more than one variable in the <strong class="source-inline">fmt.Printf()</strong> function? Let's take a look:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">    "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    fname:= "Edward"</p>
			<p class="source-code">    lname:= "Scissorhands"</p>
			<p class="source-code">    fmt.Printf("Hello Mr. %s %s",fname,lname)</p>
			<p class="source-code">}</p>
			<p>As you see in the preceding code, we now have <strong class="source-inline">fname</strong> and <strong class="source-inline">lname</strong> assigned to a string. The <strong class="source-inline">fmt.Printf()</strong> function has two verb strings and two variables. The first variable, <strong class="source-inline">fname</strong>, is assigned to the first <strong class="source-inline">%s</strong>. The second variable, <strong class="source-inline">lname</strong>, is assigned to the second <strong class="source-inline">%s</strong>. The variables replace the verbs in the order they are placed in the <strong class="source-inline">fmt.Printf()</strong> function.</p>
			<p>The output is as follows:</p>
			<p class="source-code">Hello Mr. Edward Scissorhands</p>
			<p>The <strong class="source-inline">fmt.Printf()</strong> function does not add a new line to the end of the string that it prints. We have to add a newline in the string if we want to return the output with a new line:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">    "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    fname := "Edward"</p>
			<p class="source-code">    lname := "Scissorhands"</p>
			<p class="source-code">    fmt.Printf("Hello my first name is %s\n", fname)</p>
			<p class="source-code">    fmt.Printf("Hello my last name is %s", lname)</p>
			<p class="source-code">}</p>
			<p>In Go, you can escape characters using the <strong class="source-inline">\</strong>. This tells us that a character should not be printed because it has a special meaning. When you use <strong class="source-inline">\n</strong>, it denotes a newline. We can place a newline anywhere within the string.</p>
			<p>The output is as follows:</p>
			<p class="source-code">Hello my first name is Edward</p>
			<p class="source-code">Hello my last name is Scissorhands</p>
			<p>The following would be the result if we did not place the <strong class="source-inline">\n</strong> in the string:</p>
			<p class="source-code">Hello my first name is EdwardHello my last name is Scissorhands</p>
			<p>The Go language has several printing verbs. We will introduce some of the basic verbs that are frequently used. We will introduce others as they become pertinent to performing basic debugging:</p>
			<div>
				<div id="_idContainer152" class="IMG---Figure">
					<img src="image/B14177_09_03.jpg" alt="Figure 9.3: Table representing verbs and their meanings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3: Table representing verbs and their meanings</p>
			<p>Let's take a look at an example of using verbs for printing out various data types:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">    "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    fname := "Joe"</p>
			<p class="source-code">    gpa := 3.75</p>
			<p class="source-code">    hasJob := true</p>
			<p class="source-code">    age := 24</p>
			<p class="source-code">    hourlyWage := 45.53</p>
			<p class="source-code">    fmt.Printf("%s has a gpa of %f.\n", fname, gpa)</p>
			<p class="source-code">    fmt.Printf("He has a job equals %t.\n", hasJob)</p>
			<p class="source-code">    fmt.Printf("He is %d earning %v per hour.\n", age, hourlyWage)</p>
			<p class="source-code">}</p>
			<p class="source-code">    fname := "Joe"</p>
			<p class="source-code">    gpa := 3.75</p>
			<p class="source-code">    hasJob := true</p>
			<p class="source-code">    age := 24</p>
			<p class="source-code">    hourlyWage := 45.53</p>
			<ul>
				<li>We initialize various variables of different types that will be used in our <strong class="source-inline">Printf()</strong> function:<p class="source-code">fmt.Printf("%s has a gpa of %f.\n", fname, gpa)</p><p><strong class="source-inline">%s</strong> is the placeholder for a string; when the <strong class="source-inline">Printf()</strong> statement runs the value in the <strong class="source-inline">fname</strong> variable, it will replace <strong class="source-inline">%s</strong>. The <strong class="source-inline">%f</strong> is the placeholder for a float; when the <strong class="source-inline">Printf()</strong> statement runs the value in the <strong class="source-inline">gpa</strong> variable, it will replace <strong class="source-inline">%f</strong>.</p></li>
				<li>Check whether the person has a job as follows:<p class="source-code">fmt.Printf("He has a job equals %t.\n", hasJob)</p></li>
				<li><strong class="source-inline">%t</strong> is the placeholder for a <strong class="source-inline">bool</strong>. When the <strong class="source-inline">Printf()</strong> statement runs the value in the <strong class="source-inline">hasJob</strong> variable, it will replace <strong class="source-inline">%t</strong>.</li>
				<li>Print the age of the person and their wage per hour:<p class="source-code">fmt.Printf("He is %d earning %v per hour.\n", age, hourlyWage)</p></li>
				<li><strong class="source-inline">%d</strong> is the placeholder for an <strong class="source-inline">int</strong> base-10. When the <strong class="source-inline">Printf</strong> statement runs the value in the <strong class="source-inline">age</strong> variable, it will replace <strong class="source-inline">%d</strong>.<p><strong class="source-inline">%v</strong> is the placeholder for the value in a default format.</p><p>The following is the expected output:</p><p class="source-code">Joe has a gpa of 3.750000.</p><p class="source-code">He has a job equals true.</p><p class="source-code">He is 24 earning 45.53 per hour.</p><p class="callout-heading">Note</p><p class="callout">We will demonstrate how to format verbs, such as <strong class="source-inline">gpa</strong>, to make it round to a specific number of decimal places.</p></li>
			</ul>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor271"/>Additional Options for Formatting</h2>
			<p>Verbs can also be formatted by adding additional options to the verb. In our previous example, the <strong class="source-inline">gpa</strong> variable printed out some erroneous zeros. In this topic, we are going to demonstrate how to control the printing of certain verbs. If we want to round to a certain precision when using the <strong class="source-inline">%f</strong> verb, we can do so by placing a decimal and a number following the <strong class="source-inline">%</strong> symbol: <strong class="source-inline">%.2f</strong>. That would specify two decimal places with the second one being rounded. Given the following examples, notice how the <strong class="source-inline">nth</strong> number is rounded to what is specified by the n(number) used in the <strong class="source-inline">%.nf</strong> verb:</p>
			<div>
				<div id="_idContainer153" class="IMG---Figure">
					<img src="image/B14177_09_04.jpg" alt="Figure 9.4: Rounding off the decimals&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4: Rounding off the decimals</p>
			<p>You can also specify the overall width of the number; this includes the decimal point. The width of the number refers to the total characters of the number you are formatting including the decimal point. You can specify the width of the number you are formatting by putting a number before the decimal point. <strong class="source-inline">%10.0f</strong> states the format will be a total width of 10; this includes the decimal point. It will pad with spaces if the width is less than what is being formatted, and it will be right-aligned.</p>
			<p>Let's take a look at an example of formatting various numbers using the width and <strong class="source-inline">%.f</strong> verb together:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">    "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main()</p>
			<p class="source-code">{</p>
			<p class="source-code">  v := 1234.0</p>
			<p class="source-code">  v1 := 1234.6</p>
			<p class="source-code">  v2 := 1234.67</p>
			<p class="source-code">  v3 := 1234.678</p>
			<p class="source-code">  v4 := 1234.6789</p>
			<p class="source-code">  v5 := 1234.67891</p>
			<p class="source-code">    fmt.Printf("%10.0f\n", v)</p>
			<p class="source-code">    fmt.Printf("%10.1f\n", v1)</p>
			<p class="source-code">    fmt.Printf("%10.2f\n", v2)</p>
			<p class="source-code">    fmt.Printf("%10.3f\n", v3)</p>
			<p class="source-code">    fmt.Printf("%10.4f\n", v4)</p>
			<p class="source-code">    fmt.Printf("%10.5f\n", v5)</p>
			<p class="source-code">}</p>
			<p>Now, let's understand this code in detail:</p>
			<ul>
				<li>In the <strong class="source-inline">main()</strong> function, we declared variables with different decimal places:<p class="source-code">func main() {</p><p class="source-code">  v := 1234.0</p><p class="source-code">  v1 := 1234.6</p><p class="source-code">  v2 := 1234.67</p><p class="source-code">  v3 := 1234.678</p><p class="source-code">  v4 := 1234.6789</p><p class="source-code">  v5 := 1234.67891</p></li>
				<li><strong class="source-inline">%10.0f</strong> states that the total width is ten with a precision of zero, using <strong class="source-inline">v</strong> and the verbs total width is 4:<p class="source-code">    fmt.Printf("%10.0f\n", v)</p></li>
				<li><strong class="source-inline">%10.1f</strong> states that the total width is ten with a precision of one, using <strong class="source-inline">v1</strong> and the verbs total width is 6:<p class="source-code">    fmt.Printf("%10.1f\n", v1)</p></li>
				<li><strong class="source-inline">%10.2f</strong> states that the total width is ten with a precision of two, using <strong class="source-inline">v2</strong> and the verbs total width is 7:<p class="source-code">    fmt.Printf("%10.2f\n", v2)</p></li>
				<li><strong class="source-inline">%10.3f</strong> states that the total width is ten with a precision of three, using <strong class="source-inline">v3</strong> and the verbs total width is 8:<p class="source-code">    fmt.Printf("%10.3f\n", v3)</p></li>
				<li><strong class="source-inline">%10.4f</strong> states that the total width is ten with a precision of four, using <strong class="source-inline">v4</strong> and the verbs total width is 9:<p class="source-code">    fmt.Printf("%10.4f\n", v4)</p></li>
				<li><strong class="source-inline">%10.5f</strong> states that the total width is ten with a precision of five, using <strong class="source-inline">v5</strong> and the verbs total width is 10:<p class="source-code">    fmt.Printf("%10.5f\n", v5)</p><p class="source-code">}</p><p>The result is as follows:</p></li>
			</ul>
			<div>
				<div id="_idContainer154" class="IMG---Figure">
					<img src="image/B14177_09_05.jpg" alt="Figure 9.5: Output after formatting verbs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5: Output after formatting verbs</p>
			<ul>
				<li>To make the results left align your fields, you can use the <strong class="source-inline">–</strong> flag after the <strong class="source-inline">%</strong> symbol as follows:<p class="source-code">    fmt.Printf("%-10.0f\n", v)</p><p class="source-code">    fmt.Printf("%-10.1f\n", v1)</p><p class="source-code">    fmt.Printf("%-10.2f\n", v2)</p><p class="source-code">    fmt.Printf("%-10.3f\n", v3)</p><p class="source-code">    fmt.Printf("%-10.4f\n", v4)</p><p class="source-code">    fmt.Printf("%-10.5f\n", v5)</p><p>Using the same variables before the results would be as follows:</p></li>
			</ul>
			<div>
				<div id="_idContainer155" class="IMG---Figure">
					<img src="image/B14177_09_06.jpg" alt="Figure 9.6: Output after left aligning the formatted verbs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6: Output after left aligning the formatted verbs</p>
			<p>We have just skimmed the surface of Go's support for using verbs. You should, by now, have a fundamental understanding of how verbs work. We will continue to build on using verbs and the various ways to format <strong class="source-inline">print</strong> in the upcoming topics. This topic laid the groundwork for the techniques that we will be using to do basic debugging.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor272"/>Exercise 9.02: Printing Decimal, Binary, and Hex Values</h2>
			<p>In this exercise, we will be printing decimal, binary, and hex values from 1 to 255. The results should be right aligned. The decimal width should be set to three, the binary or base 2 width set to 8, and the hex width set to 2. The aim of this exercise is to properly format the output of our data by using a Go standard library package.</p>
			<p>All directories and files created should be within your <strong class="source-inline">$GOPATH</strong>:</p>
			<ol>
				<li value="1">Create a directory called <strong class="source-inline">Exercise9.02</strong> inside the <strong class="source-inline">Chapter09</strong> directory.</li>
				<li>Create a file called <strong class="source-inline">main.go</strong> inside the <strong class="source-inline">Chapter09/Exercise9.02/</strong> directory.</li>
				<li>Using Visual Studio Code, open the <strong class="source-inline">main.go</strong> file.</li>
				<li>Import the following packages:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">    "fmt"</p><p class="source-code">)</p></li>
				<li>Add the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, use a <strong class="source-inline">for</strong> loop that will loop up to 255 times:<p class="source-code">func main() {</p><p class="source-code">  for i := 1; i &lt;= 255; i++ {</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Next, we want to print the variable three different ways, formatted to the following specifications:<p>Display <strong class="source-inline">i</strong> as a decimal value with a width of 3 and right aligned.</p><p>Display <strong class="source-inline">i</strong> as a base 2 value with a width of 8 and right aligned.</p><p>Display <strong class="source-inline">i</strong> as a hex value with a width of 2 and right aligned.</p><p>This code should be placed inside of the <strong class="source-inline">for</strong> loop:</p><p class="source-code">func main() {</p><p class="source-code">  for i := 1; i &lt;= 255; i++ {</p><p class="source-code">    fmt.Printf("Decimal: %3.d Base Two: %8.b Hex:  %2.x\n", i, i, i)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>At the command line, change the directory using the following code:<p class="source-code">cd Chapter09/Exercise9.02/</p></li>
				<li>At the command line, type the following:<p class="source-code">go build</p></li>
				<li>Type the executable that was created from the <strong class="source-inline">go build</strong> command and hit <em class="italic">Enter</em>.</li>
			</ol>
			<p>Here are the expected results of the program:</p>
			<div>
				<div id="_idContainer156" class="IMG---Figure">
					<img src="image/B14177_09_07.jpg" alt="Figure 9.7: Expected output after printing the decimal, binary, and hex values&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7: Expected output after printing the decimal, binary, and hex values</p>
			<p>We have seen how to format our data using the <strong class="source-inline">Printf()</strong> from the Go standard library <strong class="source-inline">fmt</strong> package. We will use this knowledge to perform some basic debugging of printing code markers in our programs. We will learn more about this in the following section.</p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor273"/>Basic Debugging</h1>
			<p>We have been happily coding along. The big moment has arrived; it is time to run our program. We run our program and find the results are not as we expected them to be. In fact, something is grossly wrong. Our inputs and outputs are not matching up. So, how do we figure out what went wrong? Well, having bugs appear in our programs is something that we all face as developers. However, there is some basic debugging that we can perform to aid us in remediating or, at the very least, gathering information about these bugs by:</p>
			<ul>
				<li><strong class="bold">Printing out the code markers in the code</strong>:<p>Markers in our code are print statements that help us to identify where we are in the program when the bug occurred:</p><p class="source-code">fmt.Println("We are in function calculateGPA")</p></li>
				<li><strong class="bold">Printing out the type of the variable</strong>:<p>While debugging, it might be useful to know the variable type that we are evaluating:</p><p class="source-code">fmt.Printf("fname is of type %T\n", fname)</p></li>
				<li><strong class="bold">Printing out the value of the variable</strong>:<p>Along with knowing the type of the variable, it is sometimes valuable to know the value that is stored in the variable:</p><p class="source-code">fmt.Printf("fname value %#v\n", fname)</p></li>
				<li><strong class="bold">Perform debug logging</strong>: <p>At times, it might be necessary to print debug statements to a file: maybe there is an error that only occurs in a production environment. Or perhaps we would like to compare the results of data printed in a file for different inputs to our code:</p><p class="source-code">log. Printf("fname value %#v\n", fname)</p></li>
			</ul>
			<p>Here are some basic debugging methods:</p>
			<div>
				<div id="_idContainer157" class="IMG---Figure">
					<img src="image/B14177_09_08.jpg" alt="Figure 9.8: Basic debugging methods&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8: Basic debugging methods</p>
			<p>One of the first steps in debugging is to identify the general location of where the bug is in the code. Before you can start to analyze any data, we need to know where this bug is occurring. We do this by printing out markers in our code. Markers in our code are typically nothing more than print statements that help us to identify where we are in the program when the bug occurred. They are also used to narrow the scope of the location of the bug. Generally, this process involves placing a print statement with a message that shows us where we are in the code. If our code reaches that point, we can then determine, based on some conditions, whether that area is where the bug is at. If we find that it is not, we potentially remove that print statement and place it in other spots in the code.</p>
			<p>Given the following trivial example, here is a bug that returns:</p>
			<p class="source-code">Incorrect value</p>
			<p class="source-code">Program exited: status 1.</p>
			<p>The code is reporting an error, but we do not know where the error is coming from. This code generates a random number and that random number is passed to <strong class="source-inline">func a</strong> and <strong class="source-inline">func b</strong>. Depending on the value of the random number, it will depend on which function the error occurs in. The following code demonstrates the importance of having properly placed <strong class="source-inline">debug</strong> statements to help determine the area of the code that a potential bug is located:</p>
			<p class="source-code-heading">main.go</p>
			<p class="source-code">9  func main() {</p>
			<p class="source-code">10     r := random(1, 20)</p>
			<p class="source-code">11     err := a(r)</p>
			<p class="source-code">12     if err != nil {</p>
			<p class="source-code">13         fmt.Println(err)</p>
			<p class="source-code">14         os.Exit(1)</p>
			<p class="source-code">15     }</p>
			<p class="source-code">16     err = b(r)</p>
			<p class="source-code">17     if err != nil {</p>
			<p class="source-code">18         fmt.Println(err)</p>
			<p class="source-code">19         os.Exit(1)</p>
			<p class="source-code">20     }</p>
			<p class="source-code">21 }</p>
			<p class="source-code-link">The full code is available at: <a href="https://packt.live/35TQpl0">https://packt.live/35TQpl0</a></p>
			<ul>
				<li>We are using the <strong class="source-inline">rand</strong> package to generate a random number.</li>
				<li><strong class="source-inline">rand.Seed()</strong> is used so that each time you run the program with <strong class="source-inline">rand.Intn</strong>, it lowers the possibility of returning the same number. However, if you use the same seed each time, the random number generator will return the same number the first time you run the code. To minimize the probability of the same number being generated, we need to provide the seed function with a unique number each time. We use <strong class="source-inline">time.Now().UTC.UnixNano()</strong> to help our program get a more random number. It should be noted, though, that if you put this in a loop, the loop could iterate at a speed that <strong class="source-inline">time.Now().UTC.UnixNano()</strong> could generate the same time value. However, for our program, this is not as likely, rather it is just something to consider in future code.</li>
				<li>The <strong class="source-inline">rand.Intn((max-min)+1)+min</strong> is starting to generate a random number between two other numbers. In our program, it is 1 and 20:<p class="source-code">func a(i int) error {</p><p class="source-code">    if i &lt; 10 {</p><p class="source-code">        fmt.Println("Error is in func a")</p><p class="source-code">        return errors.New("Incorrect value")</p><p class="source-code">    }</p><p class="source-code">    return nil</p><p class="source-code">}</p><p class="source-code">func b(i int) error {</p><p class="source-code">    if i &gt;= 10 {</p><p class="source-code">        fmt.Println("Error is in func b.)</p><p class="source-code">        return errors.New("Incorrect value")</p><p class="source-code">    }</p><p class="source-code">    return nil</p><p class="source-code">}</p></li>
				<li>The preceding two functions evaluate <strong class="source-inline">i</strong> to see whether it falls within a given range. If the value that falls within that range returns an error, but also prints a <strong class="source-inline">debug</strong> statement to let us know where the error occurred.</li>
			</ul>
			<p>By strategically placing print statements in our code, we can see which function the error is in.</p>
			<p>The output should look something as follows:</p>
			<p class="source-code">Error is in func a</p>
			<p class="source-code">Incorrect value</p>
			<p class="source-code">Program exited: status 1.</p>
			<p>This section covered debugging. We were introduced to using <strong class="source-inline">print</strong> statements for debugging. In the next topic, we will build on our knowledge of printing and look at how to print the variable type.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Due to the randomness of the value of <strong class="source-inline">r</strong>, it can be different, which will impact the results of the program to be either <strong class="source-inline">func a</strong> or <strong class="source-inline">func b</strong>.</p>
			<p class="callout">Additionally, if you run the preceding program in the Go playground, it will give you the same result every time. This is due to the fact that the playground caches, so it does not adhere to the randomness of the answer.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor274"/>Printing Go Variable Types</h2>
			<p>It is often useful to know the type of a variable when debugging. Go provides this functionality through the use of a <strong class="source-inline">%T</strong> verb. Go is case sensitive. A capital <strong class="source-inline">%T</strong> means the type of the variable and a lowercase <strong class="source-inline">%t</strong> means the <strong class="source-inline">bool</strong> type: </p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">    "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">type person struct {</p>
			<p class="source-code">    lname string</p>
			<p class="source-code">    age int</p>
			<p class="source-code">    salary float64</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    fname := "Joe"</p>
			<p class="source-code">    grades := []int{100, 87, 67}</p>
			<p class="source-code">    states := map[string]string{"KY": "Kentucky", "WV": "West Virginia", "VA": "Virginia"}</p>
			<p class="source-code">    p:= person{lname:"Lincoln", age:210,salary: 25000.00}</p>
			<p class="source-code">    fmt.Printf("fname is of type %T\n", fname)</p>
			<p class="source-code">    fmt.Printf("grades is of type %T\n", grades)</p>
			<p class="source-code">    fmt.Printf("states is of type %T\n", states)</p>
			<p class="source-code">    fmt.Printf("p is of type %T\n", p)</p>
			<p class="source-code">}</p>
			<p>Here are the results of the preceding code snippet:</p>
			<p class="source-code">fname is of type string</p>
			<p class="source-code">grades is of type []int</p>
			<p class="source-code">states is of type map[string]string</p>
			<p class="source-code">p is of type main.person</p>
			<p>The <strong class="source-inline">%T</strong> is used in each <strong class="source-inline">print</strong> statement to print the concrete type of the variable. In a previous topic, we printed out values. We can also print out a Go syntax representation of the type using <strong class="source-inline">%#v</strong>. It is useful to be able to print out the Go representation of a variable. The Go representation of a variable is the syntax that can be copied and pasted into the Go code:</p>
			<div>
				<div id="_idContainer158" class="IMG---Figure">
					<img src="image/B14177_09_09.jpg" alt="Figure 9.9: Syntax representation of the type using %T and the Go syntax representation, %#v&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9: Syntax representation of the type using %T and the Go syntax representation, %#v</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor275"/>Exercise 9.03 Printing the Go Representation of a Variable</h2>
			<p>In this exercise, we will create a simple program that will demonstrate how to print out the Go representation of various variables. We will use various types (such as a string, slice, map, and a struct) and print the Go representations of those types:</p>
			<ol>
				<li value="1">Create a directory called <strong class="source-inline">Exercise9.03</strong> inside the <strong class="source-inline">Chapter09</strong> directory.</li>
				<li>Create a file called <strong class="source-inline">main.go</strong> inside the <strong class="source-inline">Chapter09/Exercise9.03/</strong> directory.</li>
				<li>Using Visual Studio Code, open the <strong class="source-inline">main.go</strong> file.</li>
				<li>Add the following code to <strong class="source-inline">main.go</strong>:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">    "fmt"</p><p class="source-code">)</p></li>
				<li>Next, create a person struct with the same fields listed as follows:<p class="source-code">type person struct {</p><p class="source-code">    lname string</p><p class="source-code">    age int</p><p class="source-code">    salary float64</p><p class="source-code">}</p></li>
				<li>Inside the <strong class="source-inline">main</strong> function, assign a value to the <strong class="source-inline">fname</strong> variable:<p class="source-code">func main() {</p><p class="source-code">    fname := "Joe"</p></li>
				<li>Create a slice literal and assign to a grades variable:<p class="source-code">    grades := []int{100, 87, 67}</p></li>
				<li>Create a <strong class="source-inline">map</strong> literal of a key string and a value string, and assign it to a variable of states. This is a map of state abbreviations and their respective names:<p class="source-code">    states := map[string]string{"KY": "Kentucky", "WV": "West Virginia",       "VA": "Virginia"}</p></li>
				<li>Create a person literal and assign it to p:<p class="source-code">    p:= person{lname:"Lincoln", age:210,salary: 25000.00}</p></li>
				<li>Next, we will be printing out the Go representation of each of our variables using <strong class="source-inline">%#v</strong>:<p class="source-code">    fmt.Printf("fname value %#v\n", fname)</p><p class="source-code">    fmt.Printf("grades value %#v\n", grades)</p><p class="source-code">    fmt.Printf("states value %#v\n", states)</p><p class="source-code">    fmt.Printf("p value %#v\n", p)</p><p class="source-code">}</p></li>
				<li>At the command line, change the directory using the following code:<p class="source-code">cd Chapter09/Exercise9.03/</p></li>
				<li>At the command line, type the following:<p class="source-code">go build</p></li>
				<li>Type the executable that was created from the <strong class="source-inline">go build</strong> command and hit <em class="italic">Enter</em>.<p>You will get the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer159" class="IMG---Figure">
					<img src="image/B14177_09_10.jpg" alt="Figure 9.10: Go representation of the types&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.10: Go representation of the types</p>
			<p>In this exercise, we saw how we can print the Go representation of simple types (the <strong class="source-inline">fname</strong> string) to more complex types such as a <strong class="source-inline">person</strong> struct. This is another tool in our toolbox that we can use for debugging; it allows us to see the data the way Go sees it. In the next topic, we will be looking at another tool to help us debug our code. We will be looking at how we log information that can be used to further aid in debugging.</p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor276"/>Logging</h1>
			<p>Logging can be used to help debug a bug in our program. Operating systems log various information such as access to resources, what an application is doing, the overall health of the system, and much more. It is not doing this because there is an error, rather it is logging to make it easier on the system administrator to determine what is going on with the operating system at various times. It allows for easier debugging when the operating system acts or performs a certain task that was not expected. This is the same attitude we should take when logging our application. We need to think about the information that we gather and how that would help us to debug the application if something is not performing the way we think it should.</p>
			<p>We should be performing logging regardless of whether the program needs debugging. Logging is useful for understanding events that happen, the health of the application, any potential issues, and who is accessing our application or data. Logging is an infrastructure to your program that can be utilized when an abnormality occurs in the application. Logging helps us to track abnormalities that we would otherwise miss. In production, our code could be executing in different conditions compared to a development environment, such as an increase in the number of requests to the server. </p>
			<p>If we do not have the ability to log this information and how our code performs, we could spend endless hours trying to figure out why our code behaves the way it does in production but not in development. Another example would be that we get some malformed data as a request in production, and our code does not handle the format properly and causes undesired behavior. Without proper logging, it could take an extradentary amount of time to determine that we received data that we were not adequately handling.</p>
			<p>The Go standard library provides a package called <strong class="source-inline">log</strong>. It includes basic logging that can be used by our programs. We will look into how the package can be used to log various information. </p>
			<p>Consider the following example:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">    "fmt"</p>
			<p class="source-code">    "log"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    name := "Thanos"</p>
			<p class="source-code">    log.Println("Demo app")</p>
			<p class="source-code">    log.Printf("%s is here!",name)</p>
			<p class="source-code">    log.Print("Run")</p>
			<p class="source-code">}</p>
			<p>The log functions, <strong class="source-inline">Println()</strong>, <strong class="source-inline">Printf()</strong>, and <strong class="source-inline">Print()</strong>, perform the same functionality as their <strong class="source-inline">fmt</strong> counterparts with one exception. When the log functions execute, it gives additional details such as the date and time of the execution, as follows:</p>
			<p class="source-code">2019/11/10 23:00:00 Demo app</p>
			<p class="source-code">2019/11/10 23:00:00 Thanos is here!</p>
			<p class="source-code">2019/11/10 23:00:00 Run</p>
			<p>This information can be useful when investigating and reviewing the logs at a later time and for understanding the order of events. We can even get more details to be logged by our logger. The Go log package has a function called <strong class="source-inline">SetFlags</strong> that allows us to be more specific.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Here is a list of the options for logging provided by the Go package that we can set in the function (<a href="https://golang.org/src/log/log.go?s=8483:8506#L267">https://golang.org/src/log/log.go?s=8483:8506#L267</a>):</p>
			<div>
				<div id="_idContainer160" class="IMG---Figure">
					<img src="image/B14177_09_11.jpg" alt="Figure 9.11: List of flags in Go&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.11: List of flags in Go</p>
			<p>Let's set some of the flags in <em class="italic">Figure 9.11</em> and observe the difference in behavior that we had before.</p>
			<p>Consider the following example:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">    "log"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile)</p>
			<p class="source-code">    name := "Thanos"</p>
			<p class="source-code">    log.Println("Demo app")</p>
			<p class="source-code">    log.Printf("%s is here!", name)</p>
			<p class="source-code">    log.Print("Run")</p>
			<p class="source-code">}</p>
			<p>Let's break down the code in order to understand it better:</p>
			<p class="source-code">log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile)</p>
			<p>The <strong class="source-inline">log.Ldate</strong> is the date of the local timezone. This is the same information that was logged before.</p>
			<p>The <strong class="source-inline">log.Lmicroseconds</strong> will give this is the microseconds of the formatted date. Note that we have not discussed time yet; for further details on time, please refer to <em class="italic">Chapter 10</em>, <em class="italic">About Time</em>.</p>
			<p>The <strong class="source-inline">log.LlongFile</strong> will give us the full filename and line number that the log comes from.</p>
			<p>The output is as follows:</p>
			<div>
				<div id="_idContainer161" class="IMG---Figure">
					<img src="image/B14177_09_12.jpg" alt="Figure 9.12: Output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.12: Output</p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor277"/>Log Fatal Errors</h1>
			<p>Using the log package, we can also log fatal errors. The <strong class="source-inline">Fatal()</strong>, <strong class="source-inline">Fatalf()</strong>, and <strong class="source-inline">Fatalln()</strong> functions are similar to <strong class="source-inline">Print()</strong>, <strong class="source-inline">Printf()</strong>, and <strong class="source-inline">Println()</strong>. The difference is after the log <strong class="source-inline">Fatal()</strong> functions are followed by an <strong class="source-inline">os.Exit(1)</strong> a system call. The log package also has the following functions: <strong class="source-inline">Panic</strong>, <strong class="source-inline">Panicf</strong>, and <strong class="source-inline">Panicln</strong>. The difference between the <strong class="source-inline">Panic()</strong> functions and the <strong class="source-inline">Fatal</strong> function is that the <strong class="source-inline">Panic</strong> functions are recoverable. When using the <strong class="source-inline">Panic</strong> functions, you can use the <strong class="source-inline">defer()</strong> function, whereas when using the <strong class="source-inline">Fatal</strong> functions, you cannot. As stated earlier, the <strong class="source-inline">Fatal</strong> functions call <strong class="source-inline">os.Exit()</strong>; a <strong class="source-inline">defer</strong> function will not be called when an <strong class="source-inline">os.Exit()</strong> gets called. There may be some instances where you want to abort the program immediately with no possibility of recovery. For example, the application may have gotten to a state where it is best to exit it before data corruption or undesired behavior results. Or you may have developed a command-line utility that is used by others and you need to provide an exit code to the callers of your executable to signal it has completed its tasks.</p>
			<p>In the following code example, we will look at how <strong class="source-inline">log.Fataln</strong> is used:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">    "log"</p>
			<p class="source-code">    "errors"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile)</p>
			<p class="source-code">    log.Println("Start of our app")</p>
			<p class="source-code">    err := errors.New("Application Aborted!")</p>
			<p class="source-code">    if err != nil {</p>
			<p class="source-code">        log.Fatalln(err)</p>
			<p class="source-code">    }</p>
			<p class="source-code">    log.Println("End of our app")</p>
			<p class="source-code">}</p>
			<p>Let's break down the code in order to understand it better:</p>
			<p class="source-code">log.Println("Start of our app")</p>
			<p>The statement prints to <strong class="source-inline">stdout</strong> with the date, time, and line number of the log message:</p>
			<p class="source-code">err := errors.New("We crashed!")</p>
			<p>We create an error to test the logging of the <strong class="source-inline">Fatal()</strong> errors:</p>
			<p class="source-code">log.Fatalln(err)</p>
			<p>We log the error and then it exits the program:</p>
			<p class="source-code">log.Println("End of our app")</p>
			<p>The line did not execute because we logged the error as <strong class="source-inline">fatal</strong> and that causes the program to exit.</p>
			<p>Here are the results. Notice that even though it was an error, it still logs the same details about the error as it does the print functionality, and then it exits:</p>
			<div>
				<div id="_idContainer162" class="IMG---Figure">
					<img src="image/B14177_09_13.jpg" alt="Figure 9.13: Logging a fatal error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.13: Logging a fatal error</p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor278"/>Activity 9.01: Building a Program to Validate Social Security Numbers</h2>
			<p>In this activity, we are going to be validating <strong class="bold">Social Security Numbers</strong> (<strong class="bold">SSNs</strong>). Our program will be accepting SSNs without the dashes. We will want to log the validation process for the SSNs so that we can trace the entire process. We do not want our application to stop if an SSN is invalid; we want it to log the invalid number and continue to the next one:</p>
			<ol>
				<li value="1">Create a custom error called <strong class="source-inline">ErrInvalidSSNLength</strong> for invalid SSN length.</li>
				<li>Create a custom error called <strong class="source-inline">ErrInvalidSSNNumbers</strong> for SSNs that have non-numeric digits.</li>
				<li>Create a custom error called <strong class="source-inline">ErrInvalidSSNPrefix</strong> for an SSN that has three zeros as the prefix.</li>
				<li>Create a custom error called <strong class="source-inline">ErrInvalidDigitPlace</strong> for SSNs that starts with a 9 it requires 7 or 9 in the fourth place.</li>
				<li>Create a function that returns an error if the SSN length is not 9.</li>
				<li>Create a function that checks whether the SSN is a length of 9. The function returns an error that has the SSN that was invalid and the custom error, <strong class="source-inline">ErrInvalidSSNLength</strong>.</li>
				<li>Create a function that checks whether the SSN contains all numbers. The function returns an error that has the SSN that was invalid and the custom error, <strong class="source-inline">ErrInvalidSSNNumbers</strong>.</li>
				<li>Create a function that checks whether the SSN does not have a prefix of 000. The function returns an error that has the SSN that was invalid and the custom error, <strong class="source-inline">ErrInvalidSSNPrefix</strong>.</li>
				<li>Create a function that checks that if the SSN starts with a 9, then it requires a 7 or 9 in the fourth place. The function returns an error that has the SSN that was invalid and the custom error, <strong class="source-inline">ErrInvalidDigitPlace</strong>.</li>
				<li>In the <strong class="source-inline">main()</strong> function, create a slice of SSN so that your program will validate each of them.</li>
				<li>For each SSN that you are validating, if errors are returned from your functions that are being used to validate, then log those errors and continue processing the slice.</li>
				<li>An example slice to validate is as follows:<p class="source-code">validateSSN := []string{"123-45-6789", "012-8-678", "000-12-0962", "999-33-  3333", "087-65-4321","123-45-zzzz"}</p><p>The preceding slice should have the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer163" class="IMG---Figure">
					<img src="image/B14177_09_14.jpg" alt="Figure 9.14: Validating the SSN output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.14: Validating the SSN output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 725.</p>
			<p>In this activity, we used the log package to capture information to trace the process of validating an SSN. If we ever need to debug the validation process for our SSN, then we can look at the logging messages and follow the validation failures of the SSN. We also demonstrated how to format the logging messages to contain the information that would be needed for debugging.</p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor279"/>Summary</h1>
			<p>In this chapter, we studied various methodologies for easing the debugging process such as coding incrementally and testing the code often, writing unit tests, handling all errors, and performing logging on the code.</p>
			<p>Looking at the <strong class="source-inline">fmt</strong> package, we discovered various ways to output information to help us to find bugs. The <strong class="source-inline">fmt</strong> package offered different print formatting, verbs, and ways to control the output of the verbs by use of various flags.</p>
			<p>With the usage of logging from Go's standard library, we were able to see details of how our application is executing. The log package allowed us to see the file path and line number that the log event took place on. The log package came with various print functions that mimic some of the <strong class="source-inline">fmt</strong> print functions, which provided us with various insights into the usage of the verbs we learned in this chapter. We were also able to save the logging information to a file. Each time we call a print function from the log package, it placed the results in the file.</p>
			<p>We were able to perform basic debugging by using the standard library that is provided by Go. We looked at the log package and were introduced to the <strong class="source-inline">time</strong> type. We did not go into the details of Go's implementations of time.</p>
			<p>In the next chapter, we will be looking at how time is represented in Go. We will be discussing the various functions used with the <strong class="source-inline">time</strong> type. We will also demonstrate how to convert time to various time constructs (such as nanoseconds, microseconds, milliseconds, seconds, minutes, hours, and so on). Then, we will finally learn about the underlying type of time.</p>
		</div>
		<div>
			<div id="_idContainer165" class="Content">
			</div>
		</div>
	</body></html>