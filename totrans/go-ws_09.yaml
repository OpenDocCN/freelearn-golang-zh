- en: 9\. Basic Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at basic debugging methodologies. We will look
    at some proactive measures that we can take to reduce the number of bugs that
    we introduce into our program. Once we understand these measures, we will investigate
    the ways in which we can locate a bug.
  prefs: []
  type: TYPE_NORMAL
- en: You will be able to acquaint yourself with debugging in Go and implement various
    ways to format printing. You will evaluate various techniques of basic debugging
    and find the general location of a bug in the code. By the end of the chapter,
    you will know to print out variable types and values using Go code and also log
    the state of an application for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you develop software programs, there are going to be times that your program
    behaves in an unintended way. For instance, the program could be throwing an error
    and might crash. A crash is when our code stops functioning midway and then exits
    abruptly. Perhaps, the program has given us unexpected results. For example, we
    request a video streaming service for the movie *Rocky 1*, but instead get *Creed
    1!* Or, you deposited a check into your bank account but, instead of being credited,
    the bank software debited your account. These examples of software programs behaving
    in an unintended way are called bugs. Sometimes, "bug" and "error" are used interchangeably.
    In *Chapter 6*, *Errors*, in the *What Are Errors?* section, we discussed how
    there are three different types of errors or bugs: syntax errors, runtime errors,
    and logic errors. We also examined examples and saw the difficulty of discovering
    the location of each type of error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of determining the cause of unintended behavior is called debugging.
    There are various causes of bugs that get released into production:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing is performed at the end of the development**: During the development
    life cycle, it is tempting to not perform testing incrementally. For instance,
    we are creating multiple functions for an application, and once we finish all
    the functions, they then get tested. A possibly better way of testing our code
    would be to test each function as we complete it. This is known as incrementally
    testing or delivering code in smaller chunks. This gives us better code stability.
    This is accomplished by testing a function to ensure it works before continuing
    to the next function. The function that we just completed could be used by other
    functions. If we do not test it before we continue, the other functions that use
    our function could be using a buggy function. Depending on the bug and the change
    to our function, it could impact other users of our function. Later in the chapter,
    we will discuss some more benefits of coding and testing incrementally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application enhancements or changes to requirements**: Our code is often
    changing between the development phase and when we release it to production. Once
    in production, we receive feedback from the users; the feedback could be additional
    requirements or even enhancements to the code. Changing the production-level code
    in one area could have a negative impact in another area. If the development team
    uses unit tests, then this would aid in mitigating some of the bugs introduced
    in a change to the code base. By using unit tests, we could run our unit test
    before we deliver the code to see whether our change had a negative impact. We
    will discuss what a unit test is later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unrealistic development timeframe**: There are times when functionality is
    requested to be delivered in very tight timeframes. This can lead to taking shortcuts
    in best practices, shortening the design phase, performing less testing, and receiving
    unclear requirements. All of those can increase the chance of introducing bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unhanding of errors**: Some developers may choose not to handle errors as
    they occur. For example, a file that is needed for the application to load configuration
    data is not found, not handling an error return for an invalid mathematical operation
    such as dividing by zero, or perhaps a connection to a server could not be established.
    If your program does not properly handle these and other types of errors, this
    can cause bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few causes of bugs. Bugs have a negative impact on our programs.
    The results of a bug that causes a miscalculation can be life-threatening. In
    the medical industry, a machine is used to administer a drug called heparin; this
    drug is a blood thinner, and it is used to prevent blood clots. If the code that
    determines the calculation of how often and how much heparin can be administered
    has a bug that causes it to malfunction, the machine could deliver too much or
    too little of the drug. This could have an adverse effect on the patient. As you
    can see, it is critical to deliver software that is as bug-free as possible. In
    this chapter, we are going to look at some ways to minimize the number of bugs
    that are introduced and ways of isolating the location of the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Methods for Bug-Free Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will briefly look at some methods that will help us to minimize the number
    of bugs that could be introduced into our code. These methods will also aid in
    giving us confidence as to the portions of the code that introduced the bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Different methods to debug code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.1: Different methods to debug code'
  prefs: []
  type: TYPE_NORMAL
- en: Code Incrementally and Test Often
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's consider the approach of developing incrementally. This means developing
    the program incrementally and testing it often after adding an incremental piece
    of code. This pattern will help you to track the bug easily because you are testing
    every small snippet of code as opposed to one large program.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Unit Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a test is written and code changes occur, the unit test protects the code
    from potential bugs being introduced. A typical unit test takes a given input
    and validates that a given result is produced. If the unit test is passing before
    the code change, but is now failing after the code change, then we can conclude
    that we introduced some unintended behavior. The unit test needs to pass before
    we push our code to a production system.
  prefs: []
  type: TYPE_NORMAL
- en: Handling All Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This was discussed in *Chapter 6*, *Errors*. Ignoring errors can lead to potentially
    unintended results in our program. We need to handle the errors properly to make
    the debugging process easier.
  prefs: []
  type: TYPE_NORMAL
- en: Performing Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logging is another technique that we can use to determine what is occurring
    in the program. There are various types of logging; some of the common logging
    types are debug, info, warn, error, fatal, and trace. We will not go into the
    details of each type; we will focus instead on performing debug type logging.
    This type of logging is typically used to determine the state of the program before
    a bug occurs. Some of the information that is gathered includes the values of
    the variables, the portion of the code that is being executed (one example would
    be function name), the values of the arguments being passed, the output of the
    function or method, and more. In this chapter, we will be performing our own custom
    debug logging using built-in features of the Go standard library. The built-in
    log package of Go can provide timestamps. This is useful when trying to understand
    the timing of various events. When you perform logging, you will need to keep
    in mind the performance implications. Depending on the application and the load
    it is under, the logging could be extensive during peak times and may have a negative
    impact on the performance of the application. In certain circumstances, it could
    cause it to be unresponsive.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting Using fmt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the uses of the `fmt` package is to display data to the console or to
    the filesystem, such as a text file, that will contain information that could
    be helpful in debugging the code. We have used the `Println()` function on numerous
    occasions. Let's take a slightly deeper look at the functionality of `fmt.Println()`.
    The `fmt.Println()` function places spaces between the variables and then appends
    a new line at the end of the string. The `fmt.Println()` function prints the default
    formats of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.01: Working with fmt.Println'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will print a `hello` statement using `fmt.Println`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `fmt` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the `fname` and `lname` variables in a `main()` function, and assign
    two strings to a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `Println` method from the `fmt` package. It will print `Hello:` and
    then the value of both variables followed by a space. Then, it will print a `\n`
    (newline) to the standard output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following statement prints `Next Line` plus `\n` to the standard output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have demonstrated the basics of printing out messages. In the next topic,
    we will look at how we can format the data that we want to print.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting Using fmt.Printf()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fmt` package also has numerous ways of formatting the output of our various
    print statements. We will look next at the `fmt.Printf()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fmt.Printf()` formats the string according to the verb and prints it to
    `stdout`. The standard output (`stdout`) is a stream for output. By default, the
    standard output is pointed to the terminal. The function uses something called
    format verbs or sometimes called a format specifier. The verbs tell the `fmt`
    function where to insert the variable. For example, `%s` prints a string; it is
    a placeholder for a string. These verbs are based upon the C language:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Explanation of Printf'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.2: Explanation of Printf'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `fname` variable is assigned as `Edward`. When the `fmt.Printf()` function
    runs, the `%s` verb will have the value of `fname`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'But what happens when we have more than one variable that we want to print?
    How can we print more than one variable in the `fmt.Printf()` function? Let''s
    take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you see in the preceding code, we now have `fname` and `lname` assigned to
    a string. The `fmt.Printf()` function has two verb strings and two variables.
    The first variable, `fname`, is assigned to the first `%s`. The second variable,
    `lname`, is assigned to the second `%s`. The variables replace the verbs in the
    order they are placed in the `fmt.Printf()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fmt.Printf()` function does not add a new line to the end of the string
    that it prints. We have to add a newline in the string if we want to return the
    output with a new line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In Go, you can escape characters using the `\`. This tells us that a character
    should not be printed because it has a special meaning. When you use `\n`, it
    denotes a newline. We can place a newline anywhere within the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following would be the result if we did not place the `\n` in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The Go language has several printing verbs. We will introduce some of the basic
    verbs that are frequently used. We will introduce others as they become pertinent
    to performing basic debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: Table representing verbs and their meanings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.3: Table representing verbs and their meanings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of using verbs for printing out various data
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialize various variables of different types that will be used in our
    `Printf()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`%s` is the placeholder for a string; when the `Printf()` statement runs the
    value in the `fname` variable, it will replace `%s`. The `%f` is the placeholder
    for a float; when the `Printf()` statement runs the value in the `gpa` variable,
    it will replace `%f`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check whether the person has a job as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`%t` is the placeholder for a `bool`. When the `Printf()` statement runs the
    value in the `hasJob` variable, it will replace `%t`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Print the age of the person and their wage per hour:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`%d` is the placeholder for an `int` base-10\. When the `Printf` statement
    runs the value in the `age` variable, it will replace `%d`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%v` is the placeholder for the value in a default format.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We will demonstrate how to format verbs, such as `gpa`, to make it round to
    a specific number of decimal places.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Additional Options for Formatting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Verbs can also be formatted by adding additional options to the verb. In our
    previous example, the `gpa` variable printed out some erroneous zeros. In this
    topic, we are going to demonstrate how to control the printing of certain verbs.
    If we want to round to a certain precision when using the `%f` verb, we can do
    so by placing a decimal and a number following the `%` symbol: `%.2f`. That would
    specify two decimal places with the second one being rounded. Given the following
    examples, notice how the `nth` number is rounded to what is specified by the n(number)
    used in the `%.nf` verb:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: Rounding off the decimals'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.4: Rounding off the decimals'
  prefs: []
  type: TYPE_NORMAL
- en: You can also specify the overall width of the number; this includes the decimal
    point. The width of the number refers to the total characters of the number you
    are formatting including the decimal point. You can specify the width of the number
    you are formatting by putting a number before the decimal point. `%10.0f` states
    the format will be a total width of 10; this includes the decimal point. It will
    pad with spaces if the width is less than what is being formatted, and it will
    be right-aligned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of formatting various numbers using the width
    and `%.f` verb together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s understand this code in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main()` function, we declared variables with different decimal places:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`%10.0f` states that the total width is ten with a precision of zero, using
    `v` and the verbs total width is 4:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`%10.1f` states that the total width is ten with a precision of one, using
    `v1` and the verbs total width is 6:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`%10.2f` states that the total width is ten with a precision of two, using
    `v2` and the verbs total width is 7:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`%10.3f` states that the total width is ten with a precision of three, using
    `v3` and the verbs total width is 8:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`%10.4f` states that the total width is ten with a precision of four, using
    `v4` and the verbs total width is 9:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`%10.5f` states that the total width is ten with a precision of five, using
    `v5` and the verbs total width is 10:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.5: Output after formatting verbs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.5: Output after formatting verbs'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the results left align your fields, you can use the `â€“` flag after
    the `%` symbol as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the same variables before the results would be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.6: Output after left aligning the formatted verbs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.6: Output after left aligning the formatted verbs'
  prefs: []
  type: TYPE_NORMAL
- en: We have just skimmed the surface of Go's support for using verbs. You should,
    by now, have a fundamental understanding of how verbs work. We will continue to
    build on using verbs and the various ways to format `print` in the upcoming topics.
    This topic laid the groundwork for the techniques that we will be using to do
    basic debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.02: Printing Decimal, Binary, and Hex Values'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be printing decimal, binary, and hex values from 1
    to 255\. The results should be right aligned. The decimal width should be set
    to three, the binary or base 2 width set to 8, and the hex width set to 2\. The
    aim of this exercise is to properly format the output of our data by using a Go
    standard library package.
  prefs: []
  type: TYPE_NORMAL
- en: 'All directories and files created should be within your `$GOPATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `Exercise9.02` inside the `Chapter09` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `main.go` inside the `Chapter09/Exercise9.02/` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Visual Studio Code, open the `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the following packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, use a `for` loop that will loop up to 255 times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we want to print the variable three different ways, formatted to the
    following specifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display `i` as a decimal value with a width of 3 and right aligned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Display `i` as a base 2 value with a width of 8 and right aligned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Display `i` as a hex value with a width of 2 and right aligned.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This code should be placed inside of the `for` loop:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the command line, change the directory using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the command line, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Type the executable that was created from the `go build` command and hit *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the expected results of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7: Expected output after printing the decimal, binary, and hex values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.7: Expected output after printing the decimal, binary, and hex values'
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to format our data using the `Printf()` from the Go standard
    library `fmt` package. We will use this knowledge to perform some basic debugging
    of printing code markers in our programs. We will learn more about this in the
    following section.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have been happily coding along. The big moment has arrived; it is time to
    run our program. We run our program and find the results are not as we expected
    them to be. In fact, something is grossly wrong. Our inputs and outputs are not
    matching up. So, how do we figure out what went wrong? Well, having bugs appear
    in our programs is something that we all face as developers. However, there is
    some basic debugging that we can perform to aid us in remediating or, at the very
    least, gathering information about these bugs by:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Printing out the code markers in the code**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Markers in our code are print statements that help us to identify where we
    are in the program when the bug occurred:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Printing out the type of the variable**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While debugging, it might be useful to know the variable type that we are evaluating:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Printing out the value of the variable**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Along with knowing the type of the variable, it is sometimes valuable to know
    the value that is stored in the variable:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Perform debug logging**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At times, it might be necessary to print debug statements to a file: maybe
    there is an error that only occurs in a production environment. Or perhaps we
    would like to compare the results of data printed in a file for different inputs
    to our code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here are some basic debugging methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8: Basic debugging methods'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.8: Basic debugging methods'
  prefs: []
  type: TYPE_NORMAL
- en: One of the first steps in debugging is to identify the general location of where
    the bug is in the code. Before you can start to analyze any data, we need to know
    where this bug is occurring. We do this by printing out markers in our code. Markers
    in our code are typically nothing more than print statements that help us to identify
    where we are in the program when the bug occurred. They are also used to narrow
    the scope of the location of the bug. Generally, this process involves placing
    a print statement with a message that shows us where we are in the code. If our
    code reaches that point, we can then determine, based on some conditions, whether
    that area is where the bug is at. If we find that it is not, we potentially remove
    that print statement and place it in other spots in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following trivial example, here is a bug that returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is reporting an error, but we do not know where the error is coming
    from. This code generates a random number and that random number is passed to
    `func a` and `func b`. Depending on the value of the random number, it will depend
    on which function the error occurs in. The following code demonstrates the importance
    of having properly placed `debug` statements to help determine the area of the
    code that a potential bug is located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `rand` package to generate a random number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rand.Seed()` is used so that each time you run the program with `rand.Intn`,
    it lowers the possibility of returning the same number. However, if you use the
    same seed each time, the random number generator will return the same number the
    first time you run the code. To minimize the probability of the same number being
    generated, we need to provide the seed function with a unique number each time.
    We use `time.Now().UTC.UnixNano()` to help our program get a more random number.
    It should be noted, though, that if you put this in a loop, the loop could iterate
    at a speed that `time.Now().UTC.UnixNano()` could generate the same time value.
    However, for our program, this is not as likely, rather it is just something to
    consider in future code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `rand.Intn((max-min)+1)+min` is starting to generate a random number between
    two other numbers. In our program, it is 1 and 20:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding two functions evaluate `i` to see whether it falls within a given
    range. If the value that falls within that range returns an error, but also prints
    a `debug` statement to let us know where the error occurred.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By strategically placing print statements in our code, we can see which function
    the error is in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output should look something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This section covered debugging. We were introduced to using `print` statements
    for debugging. In the next topic, we will build on our knowledge of printing and
    look at how to print the variable type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Due to the randomness of the value of `r`, it can be different, which will impact
    the results of the program to be either `func a` or `func b`.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if you run the preceding program in the Go playground, it will
    give you the same result every time. This is due to the fact that the playground
    caches, so it does not adhere to the randomness of the answer.
  prefs: []
  type: TYPE_NORMAL
- en: Printing Go Variable Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is often useful to know the type of a variable when debugging. Go provides
    this functionality through the use of a `%T` verb. Go is case sensitive. A capital
    `%T` means the type of the variable and a lowercase `%t` means the `bool` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the results of the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `%T` is used in each `print` statement to print the concrete type of the
    variable. In a previous topic, we printed out values. We can also print out a
    Go syntax representation of the type using `%#v`. It is useful to be able to print
    out the Go representation of a variable. The Go representation of a variable is
    the syntax that can be copied and pasted into the Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9: Syntax representation of the type using %T and the Go syntax
    representation, %#v'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.9: Syntax representation of the type using %T and the Go syntax representation,
    %#v'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 9.03 Printing the Go Representation of a Variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a simple program that will demonstrate how
    to print out the Go representation of various variables. We will use various types
    (such as a string, slice, map, and a struct) and print the Go representations
    of those types:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `Exercise9.03` inside the `Chapter09` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `main.go` inside the `Chapter09/Exercise9.03/` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Visual Studio Code, open the `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a person struct with the same fields listed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `main` function, assign a value to the `fname` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a slice literal and assign to a grades variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `map` literal of a key string and a value string, and assign it to
    a variable of states. This is a map of state abbreviations and their respective
    names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a person literal and assign it to p:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will be printing out the Go representation of each of our variables
    using `%#v`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the command line, change the directory using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the command line, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Type the executable that was created from the `go build` command and hit *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.10: Go representation of the types'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.10: Go representation of the types'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw how we can print the Go representation of simple types
    (the `fname` string) to more complex types such as a `person` struct. This is
    another tool in our toolbox that we can use for debugging; it allows us to see
    the data the way Go sees it. In the next topic, we will be looking at another
    tool to help us debug our code. We will be looking at how we log information that
    can be used to further aid in debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging can be used to help debug a bug in our program. Operating systems log
    various information such as access to resources, what an application is doing,
    the overall health of the system, and much more. It is not doing this because
    there is an error, rather it is logging to make it easier on the system administrator
    to determine what is going on with the operating system at various times. It allows
    for easier debugging when the operating system acts or performs a certain task
    that was not expected. This is the same attitude we should take when logging our
    application. We need to think about the information that we gather and how that
    would help us to debug the application if something is not performing the way
    we think it should.
  prefs: []
  type: TYPE_NORMAL
- en: We should be performing logging regardless of whether the program needs debugging.
    Logging is useful for understanding events that happen, the health of the application,
    any potential issues, and who is accessing our application or data. Logging is
    an infrastructure to your program that can be utilized when an abnormality occurs
    in the application. Logging helps us to track abnormalities that we would otherwise
    miss. In production, our code could be executing in different conditions compared
    to a development environment, such as an increase in the number of requests to
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: If we do not have the ability to log this information and how our code performs,
    we could spend endless hours trying to figure out why our code behaves the way
    it does in production but not in development. Another example would be that we
    get some malformed data as a request in production, and our code does not handle
    the format properly and causes undesired behavior. Without proper logging, it
    could take an extradentary amount of time to determine that we received data that
    we were not adequately handling.
  prefs: []
  type: TYPE_NORMAL
- en: The Go standard library provides a package called `log`. It includes basic logging
    that can be used by our programs. We will look into how the package can be used
    to log various information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The log functions, `Println()`, `Printf()`, and `Print()`, perform the same
    functionality as their `fmt` counterparts with one exception. When the log functions
    execute, it gives additional details such as the date and time of the execution,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This information can be useful when investigating and reviewing the logs at
    a later time and for understanding the order of events. We can even get more details
    to be logged by our logger. The Go log package has a function called `SetFlags`
    that allows us to be more specific.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the options for logging provided by the Go package that we
    can set in the function ([https://golang.org/src/log/log.go?s=8483:8506#L267](https://golang.org/src/log/log.go?s=8483:8506#L267)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11: List of flags in Go'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.11: List of flags in Go'
  prefs: []
  type: TYPE_NORMAL
- en: Let's set some of the flags in *Figure 9.11* and observe the difference in behavior
    that we had before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the code in order to understand it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `log.Ldate` is the date of the local timezone. This is the same information
    that was logged before.
  prefs: []
  type: TYPE_NORMAL
- en: The `log.Lmicroseconds` will give this is the microseconds of the formatted
    date. Note that we have not discussed time yet; for further details on time, please
    refer to *Chapter 10*, *About Time*.
  prefs: []
  type: TYPE_NORMAL
- en: The `log.LlongFile` will give us the full filename and line number that the
    log comes from.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12: Output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.12: Output'
  prefs: []
  type: TYPE_NORMAL
- en: Log Fatal Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the log package, we can also log fatal errors. The `Fatal()`, `Fatalf()`,
    and `Fatalln()` functions are similar to `Print()`, `Printf()`, and `Println()`.
    The difference is after the log `Fatal()` functions are followed by an `os.Exit(1)`
    a system call. The log package also has the following functions: `Panic`, `Panicf`,
    and `Panicln`. The difference between the `Panic()` functions and the `Fatal`
    function is that the `Panic` functions are recoverable. When using the `Panic`
    functions, you can use the `defer()` function, whereas when using the `Fatal`
    functions, you cannot. As stated earlier, the `Fatal` functions call `os.Exit()`;
    a `defer` function will not be called when an `os.Exit()` gets called. There may
    be some instances where you want to abort the program immediately with no possibility
    of recovery. For example, the application may have gotten to a state where it
    is best to exit it before data corruption or undesired behavior results. Or you
    may have developed a command-line utility that is used by others and you need
    to provide an exit code to the callers of your executable to signal it has completed
    its tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, we will look at how `log.Fataln` is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the code in order to understand it better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement prints to `stdout` with the date, time, and line number of the
    log message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an error to test the logging of the `Fatal()` errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We log the error and then it exits the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The line did not execute because we logged the error as `fatal` and that causes
    the program to exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results. Notice that even though it was an error, it still logs
    the same details about the error as it does the print functionality, and then
    it exits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13: Logging a fatal error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.13: Logging a fatal error'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.01: Building a Program to Validate Social Security Numbers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we are going to be validating **Social Security Numbers**
    (**SSNs**). Our program will be accepting SSNs without the dashes. We will want
    to log the validation process for the SSNs so that we can trace the entire process.
    We do not want our application to stop if an SSN is invalid; we want it to log
    the invalid number and continue to the next one:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a custom error called `ErrInvalidSSNLength` for invalid SSN length.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a custom error called `ErrInvalidSSNNumbers` for SSNs that have non-numeric
    digits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a custom error called `ErrInvalidSSNPrefix` for an SSN that has three
    zeros as the prefix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a custom error called `ErrInvalidDigitPlace` for SSNs that starts with
    a 9 it requires 7 or 9 in the fourth place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that returns an error if the SSN length is not 9.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that checks whether the SSN is a length of 9\. The function
    returns an error that has the SSN that was invalid and the custom error, `ErrInvalidSSNLength`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that checks whether the SSN contains all numbers. The function
    returns an error that has the SSN that was invalid and the custom error, `ErrInvalidSSNNumbers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that checks whether the SSN does not have a prefix of 000\.
    The function returns an error that has the SSN that was invalid and the custom
    error, `ErrInvalidSSNPrefix`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that checks that if the SSN starts with a 9, then it requires
    a 7 or 9 in the fourth place. The function returns an error that has the SSN that
    was invalid and the custom error, `ErrInvalidDigitPlace`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main()` function, create a slice of SSN so that your program will validate
    each of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each SSN that you are validating, if errors are returned from your functions
    that are being used to validate, then log those errors and continue processing
    the slice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An example slice to validate is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding slice should have the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.14: Validating the SSN output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.14: Validating the SSN output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 725.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we used the log package to capture information to trace the
    process of validating an SSN. If we ever need to debug the validation process
    for our SSN, then we can look at the logging messages and follow the validation
    failures of the SSN. We also demonstrated how to format the logging messages to
    contain the information that would be needed for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied various methodologies for easing the debugging process
    such as coding incrementally and testing the code often, writing unit tests, handling
    all errors, and performing logging on the code.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the `fmt` package, we discovered various ways to output information
    to help us to find bugs. The `fmt` package offered different print formatting,
    verbs, and ways to control the output of the verbs by use of various flags.
  prefs: []
  type: TYPE_NORMAL
- en: With the usage of logging from Go's standard library, we were able to see details
    of how our application is executing. The log package allowed us to see the file
    path and line number that the log event took place on. The log package came with
    various print functions that mimic some of the `fmt` print functions, which provided
    us with various insights into the usage of the verbs we learned in this chapter.
    We were also able to save the logging information to a file. Each time we call
    a print function from the log package, it placed the results in the file.
  prefs: []
  type: TYPE_NORMAL
- en: We were able to perform basic debugging by using the standard library that is
    provided by Go. We looked at the log package and were introduced to the `time`
    type. We did not go into the details of Go's implementations of time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at how time is represented in Go. We
    will be discussing the various functions used with the `time` type. We will also
    demonstrate how to convert time to various time constructs (such as nanoseconds,
    microseconds, milliseconds, seconds, minutes, hours, and so on). Then, we will
    finally learn about the underlying type of time.
  prefs: []
  type: TYPE_NORMAL
