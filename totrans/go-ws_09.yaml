- en: 9\. Basic Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9. 基本调试
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will look at basic debugging methodologies. We will look
    at some proactive measures that we can take to reduce the number of bugs that
    we introduce into our program. Once we understand these measures, we will investigate
    the ways in which we can locate a bug.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨基本的调试方法。我们将探讨我们可以采取的一些主动措施来减少我们引入程序中的错误数量。一旦我们理解了这些措施，我们将研究我们可以定位错误的方法。
- en: You will be able to acquaint yourself with debugging in Go and implement various
    ways to format printing. You will evaluate various techniques of basic debugging
    and find the general location of a bug in the code. By the end of the chapter,
    you will know to print out variable types and values using Go code and also log
    the state of an application for debugging purposes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将能够熟悉Go语言中的调试，并实现各种格式化打印的方法。你将评估基本的调试技术，并找到代码中错误的通用位置。到本章结束时，你将知道如何使用Go代码打印变量类型和值，以及为了调试目的记录应用程序的状态。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'As you develop software programs, there are going to be times that your program
    behaves in an unintended way. For instance, the program could be throwing an error
    and might crash. A crash is when our code stops functioning midway and then exits
    abruptly. Perhaps, the program has given us unexpected results. For example, we
    request a video streaming service for the movie *Rocky 1*, but instead get *Creed
    1!* Or, you deposited a check into your bank account but, instead of being credited,
    the bank software debited your account. These examples of software programs behaving
    in an unintended way are called bugs. Sometimes, "bug" and "error" are used interchangeably.
    In *Chapter 6*, *Errors*, in the *What Are Errors?* section, we discussed how
    there are three different types of errors or bugs: syntax errors, runtime errors,
    and logic errors. We also examined examples and saw the difficulty of discovering
    the location of each type of error.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开发软件程序时，你的程序有时会以未预期的方式表现。例如，程序可能会抛出错误并可能崩溃。崩溃是指我们的代码在中间停止功能并突然退出。也许，程序给出了意外的结果。例如，我们请求视频流服务观看电影
    *Rocky 1*，但反而得到了 *Creed 1!* 或者，你将支票存入银行账户，但银行软件并没有给你账户记入，反而从你的账户中扣除。这些软件程序以未预期方式表现的情况被称为错误。有时，“错误”和“错误”可以互换使用。在
    *第6章* 的 *什么是错误？* 部分，我们讨论了有三种不同类型的错误或错误：语法错误、运行时错误和逻辑错误。我们还检查了示例，并看到了发现每种类型错误位置的困难。
- en: 'The process of determining the cause of unintended behavior is called debugging.
    There are various causes of bugs that get released into production:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 确定意外行为原因的过程称为调试。有各种原因的bug被发布到生产环境中：
- en: '**Testing is performed at the end of the development**: During the development
    life cycle, it is tempting to not perform testing incrementally. For instance,
    we are creating multiple functions for an application, and once we finish all
    the functions, they then get tested. A possibly better way of testing our code
    would be to test each function as we complete it. This is known as incrementally
    testing or delivering code in smaller chunks. This gives us better code stability.
    This is accomplished by testing a function to ensure it works before continuing
    to the next function. The function that we just completed could be used by other
    functions. If we do not test it before we continue, the other functions that use
    our function could be using a buggy function. Depending on the bug and the change
    to our function, it could impact other users of our function. Later in the chapter,
    we will discuss some more benefits of coding and testing incrementally.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试是在开发结束时进行的**：在开发生命周期中，可能会诱使我们不进行增量测试。例如，我们正在为应用程序创建多个功能，一旦我们完成所有功能，它们然后被测试。测试我们代码的更好方法可能是，在我们完成每个功能后立即对其进行测试。这被称为增量测试或以更小的块交付代码。这使我们拥有更好的代码稳定性。这是通过在继续到下一个功能之前测试一个功能来确保它正常工作来实现的。我们刚刚完成的功能可能被其他功能使用。如果我们继续之前不对其进行测试，使用我们的功能的其他功能可能会使用一个有缺陷的功能。根据错误和我们对功能所做的更改，这可能会影响我们功能的其他用户。在本章的后面部分，我们将讨论一些编码和测试增量的一些更多好处。'
- en: '**Application enhancements or changes to requirements**: Our code is often
    changing between the development phase and when we release it to production. Once
    in production, we receive feedback from the users; the feedback could be additional
    requirements or even enhancements to the code. Changing the production-level code
    in one area could have a negative impact in another area. If the development team
    uses unit tests, then this would aid in mitigating some of the bugs introduced
    in a change to the code base. By using unit tests, we could run our unit test
    before we deliver the code to see whether our change had a negative impact. We
    will discuss what a unit test is later.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unrealistic development timeframe**: There are times when functionality is
    requested to be delivered in very tight timeframes. This can lead to taking shortcuts
    in best practices, shortening the design phase, performing less testing, and receiving
    unclear requirements. All of those can increase the chance of introducing bugs.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unhanding of errors**: Some developers may choose not to handle errors as
    they occur. For example, a file that is needed for the application to load configuration
    data is not found, not handling an error return for an invalid mathematical operation
    such as dividing by zero, or perhaps a connection to a server could not be established.
    If your program does not properly handle these and other types of errors, this
    can cause bugs.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few causes of bugs. Bugs have a negative impact on our programs.
    The results of a bug that causes a miscalculation can be life-threatening. In
    the medical industry, a machine is used to administer a drug called heparin; this
    drug is a blood thinner, and it is used to prevent blood clots. If the code that
    determines the calculation of how often and how much heparin can be administered
    has a bug that causes it to malfunction, the machine could deliver too much or
    too little of the drug. This could have an adverse effect on the patient. As you
    can see, it is critical to deliver software that is as bug-free as possible. In
    this chapter, we are going to look at some ways to minimize the number of bugs
    that are introduced and ways of isolating the location of the bug.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Methods for Bug-Free Code
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will briefly look at some methods that will help us to minimize the number
    of bugs that could be introduced into our code. These methods will also aid in
    giving us confidence as to the portions of the code that introduced the bug:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Different methods to debug code'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.1: Different methods to debug code'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Code Incrementally and Test Often
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's consider the approach of developing incrementally. This means developing
    the program incrementally and testing it often after adding an incremental piece
    of code. This pattern will help you to track the bug easily because you are testing
    every small snippet of code as opposed to one large program.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Writing Unit Tests
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a test is written and code changes occur, the unit test protects the code
    from potential bugs being introduced. A typical unit test takes a given input
    and validates that a given result is produced. If the unit test is passing before
    the code change, but is now failing after the code change, then we can conclude
    that we introduced some unintended behavior. The unit test needs to pass before
    we push our code to a production system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写测试并发生代码更改时，单元测试可以保护代码免受潜在错误的引入。一个典型的单元测试会接受一个给定的输入并验证是否产生了预期的结果。如果代码更改前单元测试通过，但代码更改后失败，那么我们可以得出结论，我们引入了一些意外的行为。在将代码推送到生产系统之前，单元测试必须通过。
- en: Handling All Errors
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理所有错误
- en: This was discussed in *Chapter 6*, *Errors*. Ignoring errors can lead to potentially
    unintended results in our program. We need to handle the errors properly to make
    the debugging process easier.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 *第 6 章*，*错误* 中讨论过。忽略错误可能导致我们的程序出现潜在的不期望的结果。我们需要正确处理错误，以便使调试过程更容易。
- en: Performing Logging
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行日志记录
- en: Logging is another technique that we can use to determine what is occurring
    in the program. There are various types of logging; some of the common logging
    types are debug, info, warn, error, fatal, and trace. We will not go into the
    details of each type; we will focus instead on performing debug type logging.
    This type of logging is typically used to determine the state of the program before
    a bug occurs. Some of the information that is gathered includes the values of
    the variables, the portion of the code that is being executed (one example would
    be function name), the values of the arguments being passed, the output of the
    function or method, and more. In this chapter, we will be performing our own custom
    debug logging using built-in features of the Go standard library. The built-in
    log package of Go can provide timestamps. This is useful when trying to understand
    the timing of various events. When you perform logging, you will need to keep
    in mind the performance implications. Depending on the application and the load
    it is under, the logging could be extensive during peak times and may have a negative
    impact on the performance of the application. In certain circumstances, it could
    cause it to be unresponsive.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是我们可以用来确定程序中发生情况的另一种技术。有各种类型的日志；一些常见的日志类型包括 debug、info、warn、error、fatal 和
    trace。我们不会深入到每种类型的细节；相反，我们将专注于执行 debug 类型的日志。这种类型的日志通常用于确定错误发生前的程序状态。收集的一些信息包括变量的值、正在执行的代码部分（例如函数名）、传递的参数的值、函数或方法的输出，等等。在本章中，我们将使用
    Go 标准库的内置功能执行我们自己的自定义 debug 日志。Go 的内置日志包可以提供时间戳。这在尝试理解各种事件的时机时很有用。当你进行日志记录时，你需要考虑到性能的影响。根据应用程序及其负载，在高峰时段日志可能会非常详细，可能会对应用程序的性能产生负面影响。在某些情况下，它可能会导致应用程序无响应。
- en: Formatting Using fmt
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 fmt 格式化
- en: One of the uses of the `fmt` package is to display data to the console or to
    the filesystem, such as a text file, that will contain information that could
    be helpful in debugging the code. We have used the `Println()` function on numerous
    occasions. Let's take a slightly deeper look at the functionality of `fmt.Println()`.
    The `fmt.Println()` function places spaces between the variables and then appends
    a new line at the end of the string. The `fmt.Println()` function prints the default
    formats of the variables.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt` 包的一个用途是在控制台或文件系统中显示数据，例如一个包含可能有助于调试代码的信息的文本文件。我们已经多次使用了 `Println()` 函数。让我们稍微深入地看看
    `fmt.Println()` 的功能。`fmt.Println()` 函数在变量之间放置空格，然后在字符串的末尾追加一个新行。`fmt.Println()`
    函数打印变量的默认格式。'
- en: 'Exercise 9.01: Working with fmt.Println'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.01：使用 fmt.Println
- en: 'In this exercise, we will print a `hello` statement using `fmt.Println`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 `fmt.Println` 打印一个 `hello` 语句：
- en: 'Import the `fmt` package:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `fmt` 包：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Declare the `fname` and `lname` variables in a `main()` function, and assign
    two strings to a variable:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中声明 `fname` 和 `lname` 变量，并将两个字符串赋给一个变量：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Call the `Println` method from the `fmt` package. It will print `Hello:` and
    then the value of both variables followed by a space. Then, it will print a `\n`
    (newline) to the standard output:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `fmt` 包中调用 `Println` 方法。它将打印 `Hello:` 然后打印两个变量的值，后面跟着一个空格。然后，它将打印一个 `\n`（换行符）到标准输出：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following statement prints `Next Line` plus `\n` to the standard output:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下语句将 `Next Line` 加上 `\n` 打印到标准输出：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as follows:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have demonstrated the basics of printing out messages. In the next topic,
    we will look at how we can format the data that we want to print.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Formatting Using fmt.Printf()
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fmt` package also has numerous ways of formatting the output of our various
    print statements. We will look next at the `fmt.Printf()`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fmt.Printf()` formats the string according to the verb and prints it to
    `stdout`. The standard output (`stdout`) is a stream for output. By default, the
    standard output is pointed to the terminal. The function uses something called
    format verbs or sometimes called a format specifier. The verbs tell the `fmt`
    function where to insert the variable. For example, `%s` prints a string; it is
    a placeholder for a string. These verbs are based upon the C language:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: Explanation of Printf'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.2: Explanation of Printf'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `fname` variable is assigned as `Edward`. When the `fmt.Printf()` function
    runs, the `%s` verb will have the value of `fname`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'But what happens when we have more than one variable that we want to print?
    How can we print more than one variable in the `fmt.Printf()` function? Let''s
    take a look:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you see in the preceding code, we now have `fname` and `lname` assigned to
    a string. The `fmt.Printf()` function has two verb strings and two variables.
    The first variable, `fname`, is assigned to the first `%s`. The second variable,
    `lname`, is assigned to the second `%s`. The variables replace the verbs in the
    order they are placed in the `fmt.Printf()` function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `fmt.Printf()` function does not add a new line to the end of the string
    that it prints. We have to add a newline in the string if we want to return the
    output with a new line:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Go, you can escape characters using the `\`. This tells us that a character
    should not be printed because it has a special meaning. When you use `\n`, it
    denotes a newline. We can place a newline anywhere within the string.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following would be the result if we did not place the `\n` in the string:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Go language has several printing verbs. We will introduce some of the basic
    verbs that are frequently used. We will introduce others as they become pertinent
    to performing basic debugging:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: Table representing verbs and their meanings'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_03.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.3: Table representing verbs and their meanings'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of using verbs for printing out various data
    types:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We initialize various variables of different types that will be used in our
    `Printf()` function:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`%s` is the placeholder for a string; when the `Printf()` statement runs the
    value in the `fname` variable, it will replace `%s`. The `%f` is the placeholder
    for a float; when the `Printf()` statement runs the value in the `gpa` variable,
    it will replace `%f`.'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check whether the person has a job as follows:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`%t` is the placeholder for a `bool`. When the `Printf()` statement runs the
    value in the `hasJob` variable, it will replace `%t`.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%t` 是 `bool` 类型的占位符。当 `Printf()` 语句运行 `hasJob` 变量的值时，它将替换 `%t`。'
- en: 'Print the age of the person and their wage per hour:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印人的年龄和每小时的工资：
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`%d` is the placeholder for an `int` base-10\. When the `Printf` statement
    runs the value in the `age` variable, it will replace `%d`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%d` 是十进制 `int` 类型的占位符。当 `Printf` 语句运行 `age` 变量的值时，它将替换 `%d`。'
- en: '`%v` is the placeholder for the value in a default format.'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`%v` 是默认格式中值的占位符。'
- en: 'The following is the expected output:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为预期输出：
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We will demonstrate how to format verbs, such as `gpa`, to make it round to
    a specific number of decimal places.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将演示如何格式化动词，如 `gpa`，使其四舍五入到特定的位数。
- en: Additional Options for Formatting
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化选项的附加选项
- en: 'Verbs can also be formatted by adding additional options to the verb. In our
    previous example, the `gpa` variable printed out some erroneous zeros. In this
    topic, we are going to demonstrate how to control the printing of certain verbs.
    If we want to round to a certain precision when using the `%f` verb, we can do
    so by placing a decimal and a number following the `%` symbol: `%.2f`. That would
    specify two decimal places with the second one being rounded. Given the following
    examples, notice how the `nth` number is rounded to what is specified by the n(number)
    used in the `%.nf` verb:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 动词也可以通过添加额外的选项来格式化。在我们之前的例子中，`gpa` 变量打印了一些错误的零。在本主题中，我们将演示如何控制某些动词的打印。如果我们想在使用
    `%f` 动词时四舍五入到一定的精度，我们可以通过在 `%` 符号后放置小数点和数字来实现：`%.2f`。这将指定两位小数，第二位进行四舍五入。根据以下示例，注意
    `nth` 数字是如何根据 `%.nf` 动词中使用的 n(数字)来四舍五入的：
- en: '![Figure 9.4: Rounding off the decimals'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.4：舍入小数]'
- en: '](img/B14177_09_04.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_09_04.jpg]'
- en: 'Figure 9.4: Rounding off the decimals'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4：舍入小数
- en: You can also specify the overall width of the number; this includes the decimal
    point. The width of the number refers to the total characters of the number you
    are formatting including the decimal point. You can specify the width of the number
    you are formatting by putting a number before the decimal point. `%10.0f` states
    the format will be a total width of 10; this includes the decimal point. It will
    pad with spaces if the width is less than what is being formatted, and it will
    be right-aligned.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以指定数字的整体宽度；这包括小数点。数字的宽度是指您正在格式化的数字的总字符数，包括小数点。您可以通过在小数点前放置一个数字来指定您正在格式化的数字的宽度。`%10.0f`
    表示格式将具有总宽度 10；这包括小数点。如果宽度小于要格式化的内容，则用空格填充，并且它将右对齐。
- en: 'Let''s take a look at an example of formatting various numbers using the width
    and `%.f` verb together:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用宽度和 `%.f` 动词一起格式化各种数字的示例：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s understand this code in detail:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细理解这段代码：
- en: 'In the `main()` function, we declared variables with different decimal places:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们声明了具有不同小数位的变量：
- en: '[PRE18]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`%10.0f` states that the total width is ten with a precision of zero, using
    `v` and the verbs total width is 4:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%10.0f` 表示总宽度为十，精度为零，使用 `v`，动词的总宽度为 4：'
- en: '[PRE19]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`%10.1f` states that the total width is ten with a precision of one, using
    `v1` and the verbs total width is 6:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%10.1f` 表示总宽度为十，精度为一位，使用 `v1`，动词的总宽度为 6：'
- en: '[PRE20]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`%10.2f` states that the total width is ten with a precision of two, using
    `v2` and the verbs total width is 7:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%10.2f` 表示总宽度为十，精度为两位，使用 `v2`，动词的总宽度为 7：'
- en: '[PRE21]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`%10.3f` states that the total width is ten with a precision of three, using
    `v3` and the verbs total width is 8:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%10.3f` 表示总宽度为十，精度为三，使用 `v3`，动词的总宽度为 8：'
- en: '[PRE22]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`%10.4f` states that the total width is ten with a precision of four, using
    `v4` and the verbs total width is 9:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%10.4f` 表示总宽度为十，精度为四位，使用 `v4`，动词的总宽度为 9：'
- en: '[PRE23]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`%10.5f` states that the total width is ten with a precision of five, using
    `v5` and the verbs total width is 10:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%10.5f` 表示总宽度为十，精度为五，使用 `v5`，动词的总宽度为 10：'
- en: '[PRE24]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result is as follows:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Figure 9.5: Output after formatting verbs'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5：格式化动词后的输出]'
- en: '](img/B14177_09_05.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14177_09_05.jpg]'
- en: 'Figure 9.5: Output after formatting verbs'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5：格式化动词后的输出
- en: 'To make the results left align your fields, you can use the `–` flag after
    the `%` symbol as follows:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使字段左对齐，您可以在 `%` 符号后使用 `–` 标志，如下所示：
- en: '[PRE25]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Using the same variables before the results would be as follows:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在结果之前使用相同的变量将是以下内容：
- en: '![Figure 9.6: Output after left aligning the formatted verbs'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_06.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.6: Output after left aligning the formatted verbs'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: We have just skimmed the surface of Go's support for using verbs. You should,
    by now, have a fundamental understanding of how verbs work. We will continue to
    build on using verbs and the various ways to format `print` in the upcoming topics.
    This topic laid the groundwork for the techniques that we will be using to do
    basic debugging.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.02: Printing Decimal, Binary, and Hex Values'
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be printing decimal, binary, and hex values from 1
    to 255\. The results should be right aligned. The decimal width should be set
    to three, the binary or base 2 width set to 8, and the hex width set to 2\. The
    aim of this exercise is to properly format the output of our data by using a Go
    standard library package.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'All directories and files created should be within your `$GOPATH`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `Exercise9.02` inside the `Chapter09` directory.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `main.go` inside the `Chapter09/Exercise9.02/` directory.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Visual Studio Code, open the `main.go` file.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the following packages:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the `main()` function:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the `main()` function, use a `for` loop that will loop up to 255 times:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we want to print the variable three different ways, formatted to the
    following specifications:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display `i` as a decimal value with a width of 3 and right aligned.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Display `i` as a base 2 value with a width of 8 and right aligned.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Display `i` as a hex value with a width of 2 and right aligned.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This code should be placed inside of the `for` loop:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'At the command line, change the directory using the following code:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At the command line, type the following:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Type the executable that was created from the `go build` command and hit *Enter*.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here are the expected results of the program:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7: Expected output after printing the decimal, binary, and hex values'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_07.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.7: Expected output after printing the decimal, binary, and hex values'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to format our data using the `Printf()` from the Go standard
    library `fmt` package. We will use this knowledge to perform some basic debugging
    of printing code markers in our programs. We will learn more about this in the
    following section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Basic Debugging
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have been happily coding along. The big moment has arrived; it is time to
    run our program. We run our program and find the results are not as we expected
    them to be. In fact, something is grossly wrong. Our inputs and outputs are not
    matching up. So, how do we figure out what went wrong? Well, having bugs appear
    in our programs is something that we all face as developers. However, there is
    some basic debugging that we can perform to aid us in remediating or, at the very
    least, gathering information about these bugs by:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '**Printing out the code markers in the code**:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Markers in our code are print statements that help us to identify where we
    are in the program when the bug occurred:'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们代码中的标记是打印语句，帮助我们识别在出现错误时程序的位置：
- en: '[PRE32]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Printing out the type of the variable**:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印变量的类型**：'
- en: 'While debugging, it might be useful to know the variable type that we are evaluating:'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在调试过程中，了解我们正在评估的变量类型可能是有用的：
- en: '[PRE33]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Printing out the value of the variable**:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打印变量的值**：'
- en: 'Along with knowing the type of the variable, it is sometimes valuable to know
    the value that is stored in the variable:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了知道变量的类型外，有时了解变量中存储的值也是有价值的：
- en: '[PRE34]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '**Perform debug logging**:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行调试日志**：'
- en: 'At times, it might be necessary to print debug statements to a file: maybe
    there is an error that only occurs in a production environment. Or perhaps we
    would like to compare the results of data printed in a file for different inputs
    to our code:'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时，可能需要将调试语句打印到文件中：可能是在生产环境中才会出现的错误。或者，我们可能希望比较不同输入到我们的代码中打印到文件中的数据结果：
- en: '[PRE35]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here are some basic debugging methods:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些基本的调试方法：
- en: '![Figure 9.8: Basic debugging methods'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8：基本的调试方法](img/B14177_09_08.jpg)'
- en: '](img/B14177_09_08.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_09_08.jpg)'
- en: 'Figure 9.8: Basic debugging methods'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：基本的调试方法
- en: One of the first steps in debugging is to identify the general location of where
    the bug is in the code. Before you can start to analyze any data, we need to know
    where this bug is occurring. We do this by printing out markers in our code. Markers
    in our code are typically nothing more than print statements that help us to identify
    where we are in the program when the bug occurred. They are also used to narrow
    the scope of the location of the bug. Generally, this process involves placing
    a print statement with a message that shows us where we are in the code. If our
    code reaches that point, we can then determine, based on some conditions, whether
    that area is where the bug is at. If we find that it is not, we potentially remove
    that print statement and place it in other spots in the code.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 调试的第一步之一是确定bug在代码中的大致位置。在你开始分析任何数据之前，我们需要知道这个bug发生在哪里。我们通过在代码中打印标记来实现这一点。代码中的标记通常只是打印语句，帮助我们识别在出现bug时程序的位置。它们也用于缩小bug可能存在的范围。通常，这个过程涉及放置一个带有消息的打印语句，显示我们在代码中的位置。如果我们的代码到达那个点，我们就可以根据某些条件判断该区域是否是bug所在的地方。如果我们发现它不是，我们可能需要移除那个打印语句，并将其放置在代码的其他位置。
- en: 'Given the following trivial example, here is a bug that returns:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下简单的示例，这里有一个返回错误的bug：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The code is reporting an error, but we do not know where the error is coming
    from. This code generates a random number and that random number is passed to
    `func a` and `func b`. Depending on the value of the random number, it will depend
    on which function the error occurs in. The following code demonstrates the importance
    of having properly placed `debug` statements to help determine the area of the
    code that a potential bug is located:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 代码报告了一个错误，但我们不知道错误来自哪里。此代码生成一个随机数，并将该随机数传递给 `func a` 和 `func b`。根据随机数的值，它将决定哪个函数中发生错误。以下代码演示了正确放置
    `debug` 语句以帮助确定潜在bug所在代码区域的重要性：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We are using the `rand` package to generate a random number.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用 `rand` 包生成随机数。
- en: '`rand.Seed()` is used so that each time you run the program with `rand.Intn`,
    it lowers the possibility of returning the same number. However, if you use the
    same seed each time, the random number generator will return the same number the
    first time you run the code. To minimize the probability of the same number being
    generated, we need to provide the seed function with a unique number each time.
    We use `time.Now().UTC.UnixNano()` to help our program get a more random number.
    It should be noted, though, that if you put this in a loop, the loop could iterate
    at a speed that `time.Now().UTC.UnixNano()` could generate the same time value.
    However, for our program, this is not as likely, rather it is just something to
    consider in future code.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rand.Seed()` 用于确保每次运行程序时使用 `rand.Intn` 时，降低返回相同数字的可能性。然而，如果你每次都使用相同的种子，随机数生成器在第一次运行代码时将返回相同的数字。为了最小化生成相同数字的概率，我们需要每次向种子函数提供一个唯一的数字。我们使用
    `time.Now().UTC.UnixNano()` 来帮助我们的程序获得更随机的数字。不过，需要注意的是，如果你将这个操作放在循环中，循环的迭代速度可能会使得
    `time.Now().UTC.UnixNano()` 生成相同的时间值。然而，对于我们的程序来说，这种情况不太可能发生，这只是一个在未来的代码中需要考虑的因素。'
- en: 'The `rand.Intn((max-min)+1)+min` is starting to generate a random number between
    two other numbers. In our program, it is 1 and 20:'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rand.Intn((max-min)+1)+min` 开始在两个数字之间生成一个随机数。在我们的程序中，它是 1 和 20：'
- en: '[PRE38]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding two functions evaluate `i` to see whether it falls within a given
    range. If the value that falls within that range returns an error, but also prints
    a `debug` statement to let us know where the error occurred.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前两个函数评估 `i` 以查看它是否在给定的范围内。如果该范围内的值返回一个错误，但也会打印一个 `debug` 语句，让我们知道错误发生的位置。
- en: By strategically placing print statements in our code, we can see which function
    the error is in.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在代码中战略性地放置打印语句，我们可以看到错误在哪个函数中。
- en: 'The output should look something as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像以下这样：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This section covered debugging. We were introduced to using `print` statements
    for debugging. In the next topic, we will build on our knowledge of printing and
    look at how to print the variable type.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了调试。我们介绍了使用 `print` 语句进行调试。在下一个主题中，我们将基于打印的知识，看看如何打印变量类型。
- en: Note
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Due to the randomness of the value of `r`, it can be different, which will impact
    the results of the program to be either `func a` or `func b`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `r` 的值是随机的，它可能不同，这将影响程序的结果，使其变为 `func a` 或 `func b`。
- en: Additionally, if you run the preceding program in the Go playground, it will
    give you the same result every time. This is due to the fact that the playground
    caches, so it does not adhere to the randomness of the answer.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您在 Go playground 中运行前面的程序，它每次都会给出相同的结果。这是因为 playground 缓存，所以它不遵循答案的随机性。
- en: Printing Go Variable Types
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印 Go 变量类型
- en: 'It is often useful to know the type of a variable when debugging. Go provides
    this functionality through the use of a `%T` verb. Go is case sensitive. A capital
    `%T` means the type of the variable and a lowercase `%t` means the `bool` type:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试时，了解变量的类型通常很有用。Go 通过使用 `%T` 动词提供这种功能。Go 是区分大小写的。大写的 `%T` 表示变量的类型，而小写的 `%t`
    表示 `bool` 类型：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here are the results of the preceding code snippet:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码片段的结果：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `%T` is used in each `print` statement to print the concrete type of the
    variable. In a previous topic, we printed out values. We can also print out a
    Go syntax representation of the type using `%#v`. It is useful to be able to print
    out the Go representation of a variable. The Go representation of a variable is
    the syntax that can be copied and pasted into the Go code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`%T` 在每个 `print` 语句中使用，以打印变量的具体类型。在先前的主题中，我们打印了值。我们还可以使用 `%#v` 打印类型的 Go 语法表示。能够打印出变量的
    Go 表示很有用。变量的 Go 表示是可以在 Go 代码中复制粘贴的语法：'
- en: '![Figure 9.9: Syntax representation of the type using %T and the Go syntax
    representation, %#v'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.9：使用 %T 和 Go 语法表示的类型语法表示](img/B14177_09_09.jpg)'
- en: '](img/B14177_09_09.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_09_09.jpg)'
- en: 'Figure 9.9: Syntax representation of the type using %T and the Go syntax representation,
    %#v'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9：使用 %T 和 Go 语法表示的类型语法表示
- en: Exercise 9.03 Printing the Go Representation of a Variable
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9.03 打印变量的 Go 表示
- en: 'In this exercise, we will create a simple program that will demonstrate how
    to print out the Go representation of various variables. We will use various types
    (such as a string, slice, map, and a struct) and print the Go representations
    of those types:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个简单的程序，演示如何打印出各种变量的 Go 表示。我们将使用各种类型（如字符串、切片、映射和结构体）并打印这些类型的 Go
    表示：
- en: Create a directory called `Exercise9.03` inside the `Chapter09` directory.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter09` 目录内创建一个名为 `Exercise9.03` 的目录。
- en: Create a file called `main.go` inside the `Chapter09/Exercise9.03/` directory.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter09/Exercise9.03/` 目录内创建一个名为 `main.go` 的文件。
- en: Using Visual Studio Code, open the `main.go` file.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Visual Studio Code 打开 `main.go` 文件。
- en: 'Add the following code to `main.go`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `main.go` 中：
- en: '[PRE42]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, create a person struct with the same fields listed as follows:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个具有以下字段的 person 结构体：
- en: '[PRE43]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Inside the `main` function, assign a value to the `fname` variable:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main` 函数内部，给 `fname` 变量赋值：
- en: '[PRE44]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create a slice literal and assign to a grades variable:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 grades 变量的切片字面量：
- en: '[PRE45]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create a `map` literal of a key string and a value string, and assign it to
    a variable of states. This is a map of state abbreviations and their respective
    names:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个键字符串和值字符串的 `map` 字面量，并将其分配给名为 states 的变量。这是一个包含州缩写及其相应名称的映射：
- en: '[PRE46]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a person literal and assign it to p:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 person 字面量并将其分配给 p：
- en: '[PRE47]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, we will be printing out the Go representation of each of our variables
    using `%#v`:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'At the command line, change the directory using the following code:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'At the command line, type the following:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Type the executable that was created from the `go build` command and hit *Enter*.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will get the following output:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.10: Go representation of the types'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_10.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.10: Go representation of the types'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw how we can print the Go representation of simple types
    (the `fname` string) to more complex types such as a `person` struct. This is
    another tool in our toolbox that we can use for debugging; it allows us to see
    the data the way Go sees it. In the next topic, we will be looking at another
    tool to help us debug our code. We will be looking at how we log information that
    can be used to further aid in debugging.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging can be used to help debug a bug in our program. Operating systems log
    various information such as access to resources, what an application is doing,
    the overall health of the system, and much more. It is not doing this because
    there is an error, rather it is logging to make it easier on the system administrator
    to determine what is going on with the operating system at various times. It allows
    for easier debugging when the operating system acts or performs a certain task
    that was not expected. This is the same attitude we should take when logging our
    application. We need to think about the information that we gather and how that
    would help us to debug the application if something is not performing the way
    we think it should.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: We should be performing logging regardless of whether the program needs debugging.
    Logging is useful for understanding events that happen, the health of the application,
    any potential issues, and who is accessing our application or data. Logging is
    an infrastructure to your program that can be utilized when an abnormality occurs
    in the application. Logging helps us to track abnormalities that we would otherwise
    miss. In production, our code could be executing in different conditions compared
    to a development environment, such as an increase in the number of requests to
    the server.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: If we do not have the ability to log this information and how our code performs,
    we could spend endless hours trying to figure out why our code behaves the way
    it does in production but not in development. Another example would be that we
    get some malformed data as a request in production, and our code does not handle
    the format properly and causes undesired behavior. Without proper logging, it
    could take an extradentary amount of time to determine that we received data that
    we were not adequately handling.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The Go standard library provides a package called `log`. It includes basic logging
    that can be used by our programs. We will look into how the package can be used
    to log various information.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The log functions, `Println()`, `Printf()`, and `Print()`, perform the same
    functionality as their `fmt` counterparts with one exception. When the log functions
    execute, it gives additional details such as the date and time of the execution,
    as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This information can be useful when investigating and reviewing the logs at
    a later time and for understanding the order of events. We can even get more details
    to be logged by our logger. The Go log package has a function called `SetFlags`
    that allows us to be more specific.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the options for logging provided by the Go package that we
    can set in the function ([https://golang.org/src/log/log.go?s=8483:8506#L267](https://golang.org/src/log/log.go?s=8483:8506#L267)):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11: List of flags in Go'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_11.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.11: List of flags in Go'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Let's set some of the flags in *Figure 9.11* and observe the difference in behavior
    that we had before.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let''s break down the code in order to understand it better:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `log.Ldate` is the date of the local timezone. This is the same information
    that was logged before.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The `log.Lmicroseconds` will give this is the microseconds of the formatted
    date. Note that we have not discussed time yet; for further details on time, please
    refer to *Chapter 10*, *About Time*.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: The `log.LlongFile` will give us the full filename and line number that the
    log comes from.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12: Output'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_12.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.12: Output'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Log Fatal Errors
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the log package, we can also log fatal errors. The `Fatal()`, `Fatalf()`,
    and `Fatalln()` functions are similar to `Print()`, `Printf()`, and `Println()`.
    The difference is after the log `Fatal()` functions are followed by an `os.Exit(1)`
    a system call. The log package also has the following functions: `Panic`, `Panicf`,
    and `Panicln`. The difference between the `Panic()` functions and the `Fatal`
    function is that the `Panic` functions are recoverable. When using the `Panic`
    functions, you can use the `defer()` function, whereas when using the `Fatal`
    functions, you cannot. As stated earlier, the `Fatal` functions call `os.Exit()`;
    a `defer` function will not be called when an `os.Exit()` gets called. There may
    be some instances where you want to abort the program immediately with no possibility
    of recovery. For example, the application may have gotten to a state where it
    is best to exit it before data corruption or undesired behavior results. Or you
    may have developed a command-line utility that is used by others and you need
    to provide an exit code to the callers of your executable to signal it has completed
    its tasks.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, we will look at how `log.Fataln` is used:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s break down the code in order to understand it better:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The statement prints to `stdout` with the date, time, and line number of the
    log message:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We create an error to test the logging of the `Fatal()` errors:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We log the error and then it exits the program:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The line did not execute because we logged the error as `fatal` and that causes
    the program to exit.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results. Notice that even though it was an error, it still logs
    the same details about the error as it does the print functionality, and then
    it exits:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13: Logging a fatal error'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_13.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.13: Logging a fatal error'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.01: Building a Program to Validate Social Security Numbers'
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we are going to be validating **Social Security Numbers**
    (**SSNs**). Our program will be accepting SSNs without the dashes. We will want
    to log the validation process for the SSNs so that we can trace the entire process.
    We do not want our application to stop if an SSN is invalid; we want it to log
    the invalid number and continue to the next one:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Create a custom error called `ErrInvalidSSNLength` for invalid SSN length.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a custom error called `ErrInvalidSSNNumbers` for SSNs that have non-numeric
    digits.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a custom error called `ErrInvalidSSNPrefix` for an SSN that has three
    zeros as the prefix.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a custom error called `ErrInvalidDigitPlace` for SSNs that starts with
    a 9 it requires 7 or 9 in the fourth place.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that returns an error if the SSN length is not 9.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that checks whether the SSN is a length of 9\. The function
    returns an error that has the SSN that was invalid and the custom error, `ErrInvalidSSNLength`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that checks whether the SSN contains all numbers. The function
    returns an error that has the SSN that was invalid and the custom error, `ErrInvalidSSNNumbers`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that checks whether the SSN does not have a prefix of 000\.
    The function returns an error that has the SSN that was invalid and the custom
    error, `ErrInvalidSSNPrefix`.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that checks that if the SSN starts with a 9, then it requires
    a 7 or 9 in the fourth place. The function returns an error that has the SSN that
    was invalid and the custom error, `ErrInvalidDigitPlace`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main()` function, create a slice of SSN so that your program will validate
    each of them.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each SSN that you are validating, if errors are returned from your functions
    that are being used to validate, then log those errors and continue processing
    the slice.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An example slice to validate is as follows:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The preceding slice should have the following output:'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.14: Validating the SSN output'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_09_14.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.14: Validating the SSN output'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 725.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we used the log package to capture information to trace the
    process of validating an SSN. If we ever need to debug the validation process
    for our SSN, then we can look at the logging messages and follow the validation
    failures of the SSN. We also demonstrated how to format the logging messages to
    contain the information that would be needed for debugging.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied various methodologies for easing the debugging process
    such as coding incrementally and testing the code often, writing unit tests, handling
    all errors, and performing logging on the code.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the `fmt` package, we discovered various ways to output information
    to help us to find bugs. The `fmt` package offered different print formatting,
    verbs, and ways to control the output of the verbs by use of various flags.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: With the usage of logging from Go's standard library, we were able to see details
    of how our application is executing. The log package allowed us to see the file
    path and line number that the log event took place on. The log package came with
    various print functions that mimic some of the `fmt` print functions, which provided
    us with various insights into the usage of the verbs we learned in this chapter.
    We were also able to save the logging information to a file. Each time we call
    a print function from the log package, it placed the results in the file.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: We were able to perform basic debugging by using the standard library that is
    provided by Go. We looked at the log package and were introduced to the `time`
    type. We did not go into the details of Go's implementations of time.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at how time is represented in Go. We
    will be discussing the various functions used with the `time` type. We will also
    demonstrate how to convert time to various time constructs (such as nanoseconds,
    microseconds, milliseconds, seconds, minutes, hours, and so on). Then, we will
    finally learn about the underlying type of time.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
