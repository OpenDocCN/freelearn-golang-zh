<html><head></head><body>
		<div>
			<div id="_idContainer166" class="Content">
			</div>
		</div>
		<div id="_idContainer167" class="Content">
			<h1 id="_idParaDest-265"><a id="_idTextAnchor280"/>10. About Time</h1>
		</div>
		<div id="_idContainer172" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter demonstrates how Go handles variables representing time data, which is a very important aspect of the language.</p>
			<p class="callout">By the end of this chapter, you will be able to create your own time format, compare and manage time, calculate the duration of time series, and format time according to user requirements.</p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor281"/>Introduction</h1>
			<p>The previous chapter introduced you to basic debugging in Go. The more you develop code in Go, the better you get; however, developing and deploying code may come with corner cases that need to be debugged. The previous chapter showed you how to use the <strong class="source-inline">fmt</strong> package, how to log into files, and how to use the <strong class="source-inline">f</strong> function format.</p>
			<p>This chapter is dedicated to teaching you all you need to know about handling variables that represent time data. You will learn how to do it the "Go-way". First, we will start out with basic time creation, timestamps, and more; then, we will learn how to compare and manipulate time, calculate the duration between two dates, and create timestamps. Finally, we will learn how to format the time according to our needs. So, let's not waste any more time and jump right in.</p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor282"/>Making Time</h1>
			<p>Making time means declaring a variable that holds the time formatted in a specific way. Formatting time will be covered at the end of this chapter; so, for now, we will use the default formatting that is provided by Go. In this topic, we will be executing everything in the <strong class="source-inline">main()</strong> function of our script, so the skeleton should look like this:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">import "time"</p>
			<p class="source-code">func main(){</p>
			<p class="source-code">  //this is where the code goes.</p>
			<p class="source-code">}</p>
			<p>Let's look at our skeleton first and learn how to create and manipulate time variables. Our skeleton has the standard <strong class="source-inline">package main</strong> definition that is necessary. We use the <strong class="source-inline">fmt</strong> package to print the output to the console. Since we'll be using the <strong class="source-inline">time</strong> module, we'll need to import that as well.</p>
			<p>Whenever we issue <strong class="source-inline">go run &lt;script&gt;.go</strong>, the <strong class="source-inline">main()</strong> function gets called and executes whatever is declared in it.</p>
			<p>One of the most common jobs for the <strong class="source-inline">time</strong> module is to measure the duration of the execution for the script. We can do this by capturing the current time in a variable, at the beginning and at the end, so that we can calculate the difference and know how long the specific action took to complete. The very first example is as follows:</p>
			<p class="source-code">  start := time.Now()</p>
			<p class="source-code">  fmt.Println("The script has started at: ",start)</p>
			<p class="source-code">  fmt.Println("Saving the world...")</p>
			<p class="source-code">  time.Sleep(2 * time.Second)</p>
			<p class="source-code">  end := time.Now()</p>
			<p class="source-code">  fmt.Println("The script has completed at: ",end)</p>
			<p>The output from our script should look like this:</p>
			<p class="source-code">The script has started at:  2019-09-27 08:19:33.8358274 +0200 CEST m=+0.001998701</p>
			<p class="source-code">Saving the world...</p>
			<p class="source-code">The script has completed at:  2019-09-27 08:19:35.8400169 +0200 CEST m=+2.006161301</p>
			<p>As you can see, this does not look very fancy; however, by the end of this chapter, you will have learned how to make it more readable.</p>
			<p>Consider the following scenario; your employer gives you a task to develop a small Go application that tests a web application based on the day of week. Your employer has the main release of a new web app every Monday at 12:00 AM CEST. With a downtime window from 12:00 AM CEST to 2:00 PM CEST, and the deployment being about 30 minutes, you have 1.5 hours to test the app. This is where Go's time module comes to your rescue. The script performs a <strong class="source-inline">hit-n-run</strong> test on the other days of the week, but, on release day, you are required to perform a <strong class="source-inline">full-blown</strong> functionality test. The first version of the script took the argument to see which test to perform, but the second script version made the decision based on the day and the hour:</p>
			<div>
				<div id="_idContainer168" class="IMG---Figure">
					<img src="image/B14177_10_01.jpg" alt="Figure 10.1: Testing strategies&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1: Testing strategies</p>
			<p>Consider the following code:</p>
			<p class="source-code">  Day := time.Now().Weekday()</p>
			<p class="source-code">  Hour := time.Now().Hour()</p>
			<p class="source-code">  fmt.Println("Day: ",Day, "Hour: ",Hour)</p>
			<p class="source-code">  if Day.String() == "Monday"{</p>
			<p class="source-code">    if Hour &gt;= 1{</p>
			<p class="source-code">      fmt.Println("Performing full blown test!")</p>
			<p class="source-code">    }else{</p>
			<p class="source-code">      fmt.Println("Performing hit-n-run test!")</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }else{ fmt.Println("Performing hit-n-run test!")}</p>
			<p>The current day of the week is captured in the variable called <strong class="source-inline">Day</strong>. The hour of execution is also captured in the variable called <strong class="source-inline">Hour</strong>. When this script is executed, there are two types of output. </p>
			<p>The first one is a simple <strong class="source-inline">hit-n-run</strong> output, as follows:</p>
			<p class="source-code">Day: Thursday Hour: 14</p>
			<p class="source-code">Performing hit-n-run test!</p>
			<p>The second one is the <strong class="source-inline">full blown</strong> output, as follows:</p>
			<p class="source-code">Day: Thursday Hour: 14</p>
			<p class="source-code">Performing full blown test!</p>
			<p>In this example, we have seen how the day of execution modifies the behavior of the application.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The actual test was left out intentionally as this is not part of the chapter's topic. However, the output clearly shows which part was responsible for the control of the test.</p>
			<p>Another example would be to create the log filenames for scripts in Go. The basic idea is to collect a log per day and have a timestamp concatenated to the name of the log file. The skeleton looks like this:</p>
			<p class="source-code">Application_Action_Year_Month_Day</p>
			<p>In Go, there is an elegant and simple way to do it:</p>
			<p class="source-code">import "strconv"</p>
			<p class="source-code">AppName := "HTTPCHECKER"</p>
			<p class="source-code">  Action := "BASIC"</p>
			<p class="source-code">  Date := time.Now()</p>
			<p class="source-code">  LogFileName := AppName + "_" + Action + "_" + strconv.Itoa(Date.Year()) + "_" + Date.Month().String() + "_" + strconv.Itoa(Date.Day()) + ".log"</p>
			<p class="source-code">  fmt.Println("The name of<a id="_idTextAnchor283"/> the logfile is: ",LogFileName)</p>
			<p class="source-code">}</p>
			<p>The output appears as follows:</p>
			<p class="source-code">The name of the logfile is:  HTTPCHECKER_BASIC_2019_September_27.log</p>
			<p>However, there is a catch. If you want to concatenate strings with <strong class="source-inline">time</strong> types, which are not implicitly convertible, use the <strong class="source-inline">strconv</strong> package, which needs to be imported on top of your script:</p>
			<p class="source-code">import "strconv"</p>
			<p>In turn, this allows you to call the <strong class="source-inline">strconv.Itoa()</strong> function, which converts your <strong class="source-inline">Year</strong> and <strong class="source-inline">Day</strong> values and, finally, lets you concatenate them into a single string.</p>
			<p>Now that we have learned how to make time variables, let's learn to compare them.</p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor284"/>Exercise 10.1: Creating a Function to Return a timestamp</h2>
			<p>In this exercise, we will create a function called <strong class="source-inline">whatstheclock</strong>. The goal of this function is to demonstrate how you can create a function that wraps a nice, formatted <strong class="source-inline">time.Now()</strong> function and returns the date in an <strong class="source-inline">ANSIC</strong> format. The <strong class="source-inline">ANSIC</strong> format will be explained in further detail in the <em class="italic">Formatting Time</em> section:</p>
			<ol>
				<li>Create a file called <strong class="source-inline">Chapter_10_Exercise_1.go</strong>.</li>
				<li>Initialize the script with the package and import statements:<p class="source-code">package main</p><p class="source-code">import "time"</p><p class="source-code">import "fmt"</p></li>
				<li>Define the function called <strong class="source-inline">whatstheclock()</strong>:<p class="source-code">func whatstheclock() string {</p><p class="source-code">  return time.Now().Format(time.ANSIC)</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, define a call to the <strong class="source-inline">whatstheclock()</strong> function and print the result to the console:<p class="source-code">func main(){</p><p class="source-code">  fmt.Println(whatstheclock())</p><p class="source-code">}</p></li>
				<li>Save the file and run the code:<p class="source-code">go run Chapter_10_Exercise_1.go</p><p>You should see the following output:</p><p class="source-code">Thu Oct 17 13:56:03 2019</p></li>
			</ol>
			<p>In this exercise, we demonstrated how you can create a small function that returns the current time in an ANSIC format.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Any type of operating system that you work with will provide two types of clocks to measure the time; one is called the "monotonic clock", and the other is called the "wall clock." The wall clock is what you see on a Windows machine in the taskbar; it's subject to change and is usually synchronized with a public or corporate NTP server based on your current location. The <strong class="bold">NTP</strong> server stands for <strong class="bold">Network Time Protocol</strong> and is used to tell clients the time based on an atomic clock, or from a satellite reference.</p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor285"/>Comparing Time</h1>
			<p>Most of the time, when working with Go on smaller scripts, it is very important for your statistics to know when a script should run, or between what hours and minutes a script should be completed. By statistics, we mean knowing how much time the app saves by executing a specific operation compared to what time cost it would have if we had to perform these manually. This allows us to measure the improvement of the script over time when we develop the functionality further. In this topic, we will look at some live examples demonstrating how you can solve this problem.</p>
			<p>Let's take a look at the logic for the first script, which was intended not to run before or after a specified time. This time can arrive either via another automation, or when a trigger file is manually placed there; every day, the script needs to run at different times, specifically, after the specified time as soon as possible.</p>
			<p>The time was in the following <strong class="source-inline">2019-09-27T22:08:41+00:00</strong> format:</p>
			<p class="source-code">  now := time.Now()</p>
			<p class="source-code">  only_after, _ := time.Parse(time.RFC3339,"2020-11-01T22:08:41+00:00")</p>
			<p class="source-code">  fmt.Println(now, only_after)</p>
			<p class="source-code">  fmt.Println(now.After(only_after))</p>
			<p class="source-code">  if now.After(only_after){</p>
			<p class="source-code">    fmt.Println("Executing actions!")</p>
			<p class="source-code">  }else{</p>
			<p class="source-code">    fmt.Println("Now is not the time yet!!")</p>
			<p class="source-code">  }</p>
			<p>The output of the script when we are not yet at the deadline is as follows:</p>
			<p class="source-code">Now is not the time yet!!</p>
			<p>When we meet the criteria, the output looks like this:</p>
			<p class="source-code">Executing actions!</p>
			<p>Let's examine what is happening here. We create the <strong class="source-inline">now</strong> variable, which is crucial for the execution. We have the <strong class="source-inline">time</strong> string parsed based on RFC3339. RFC3339 specifies the format that should be used for the <strong class="source-inline">date</strong> and <strong class="source-inline">time</strong> strings. This function returns two values: one value is the output if the conversion succeeds, and the other is the error if there is one. We capture the output in the <strong class="source-inline">only_after</strong> variable, and we use a throwaway variable for capturing any output; this is the underscore sign, <strong class="source-inline">_</strong>. We could use a standard variable such as <strong class="source-inline">only_after_error</strong>, but unless we use that variable later in time, the compiler will throw an error that the variable was declared but never used. This is circumvented by the use of the <strong class="source-inline">_</strong> variable. Based on this logic, we could implement the <strong class="source-inline">only_before</strong> argument or variable very simply. The <strong class="source-inline">time</strong> package has two very useful functions: one is called <strong class="source-inline">After()</strong>, and the other is called <strong class="source-inline">Before()</strong>. They allow us to simply compare two <strong class="source-inline">time</strong> variables.</p>
			<p>There is a third function in the package called <strong class="source-inline">Equal()</strong>. This function allows you to compare two <strong class="source-inline">time</strong> variables and returns <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> depending on whether they are equal.</p>
			<p>Let's take a look at an example of the <strong class="source-inline">Equal()</strong> function in action:</p>
			<p class="source-code">now := time.Now()</p>
			<p class="source-code">  now_too := now</p>
			<p class="source-code">  time.Sleep(2*time.Second)</p>
			<p class="source-code">  later := time.Now()</p>
			<p class="source-code">  if now.Equal(now_too){</p>
			<p class="source-code">    fmt.Println("The two time variables are equal!")</p>
			<p class="source-code">  }else{</p>
			<p class="source-code">    fmt.Println("The two time variables are different!")</p>
			<p class="source-code">  }</p>
			<p class="source-code">  if now.Equal(later){</p>
			<p class="source-code">    fmt.Println("The two time variables are equal!")</p>
			<p class="source-code">  }else{</p>
			<p class="source-code">    fmt.Println("The two time variables are different!")</p>
			<p class="source-code">  }</p>
			<p>The output looks like this:</p>
			<p class="source-code">The two time variables are equal!</p>
			<p class="source-code">The two time variables are different!</p>
			<p>Let's see what happens here. We have three <strong class="source-inline">time</strong> variables, which are called <strong class="source-inline">now</strong>, <strong class="source-inline">now_too</strong>, and <strong class="source-inline">later</strong>. The <strong class="source-inline">time</strong> module's <strong class="source-inline">Sleep()</strong> function is used to simulate the latency of 2 seconds. This function takes an integer argument and waits for the given time to pass and then continues the execution. The result of this is that the <strong class="source-inline">later</strong> variable holds different time values and allows us to demonstrate the <strong class="source-inline">Equal()</strong> function's purpose, which you can see in the output.</p>
			<p>Now, the time has come to check what facilities are provided to calculate the duration or difference between the two <strong class="source-inline">time</strong> variables.</p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor286"/>Duration Calculation</h1>
			<p>The ability to calculate the duration of an execution comes in handy during many aspects of programming. In our everyday life, we can monitor discrepancies and performance bottlenecks that our infrastructure might face. For example, if you have a script that takes only 5 seconds to complete on average and the monitoring execution time shows you a huge bump during certain hours of a day or certain days, it might be wise to investigate. The other aspect is related to web applications. Measuring the duration of request-response in your scripts can give you an insight into how well invested you are in your apps to serve high loads, and it even allows you to expand your capacity on certain days or weeks of the year. For example, if you have an online shop dealing with products, it might be wise to size your capacity according to patterns such as Black Friday or Christmas. </p>
			<p>You may do well with a lower capacity during most of the year, but those holidays can result in revenue loss if the infrastructure is not sufficiently well sized. There is very little coding required to add such functionality to your scripts. Let's now take a look at how to do it:</p>
			<p class="source-code">  Start := time.Now()</p>
			<p class="source-code">  fmt.Println("The script started at: ", Start)</p>
			<p class="source-code">  sum := 0</p>
			<p class="source-code">  for i := 1; i &lt; 10000000000; i++ {</p>
			<p class="source-code">      sum += i</p>
			<p class="source-code">  }</p>
			<p class="source-code">  End := time.Now()</p>
			<p class="source-code">  Duration := End.Sub(Start)</p>
			<p class="source-code">  fmt.Println("The script completed at: ", End)</p>
			<p class="source-code">  fmt.Println("The task took",Duration.Hours(), "hour(s) to complete!")</p>
			<p class="source-code">  fmt.Println("The task took",Duration.Minutes(), "minutes(s) to complete!")</p>
			<p class="source-code">  fmt.Println("The task took",Duration.Seconds(), "seconds(s) to complete!")</p>
			<p class="source-code">  fmt.Println("The task took",Duration.Nanoseconds(), "nanosecond(s) to complete!")</p>
			<p>If you execute this script, the result will be something like this, depending on the PC's performance:</p>
			<div>
				<div id="_idContainer169" class="IMG---Figure">
					<img src="image/B14177_10_02.jpg" alt="Figure 10.2: Measuring the execution time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2: Measuring the execution time</p>
			<p>All that needs to be done is to capture the time when the script starts and ends. Then, we can calculate the duration by subtracting the start time and the end time. After that, we can utilize the <strong class="source-inline">Duration</strong> variable's functions to get the <strong class="source-inline">Hours()</strong>, <strong class="source-inline">Minutes()</strong>, <strong class="source-inline">Seconds()</strong>, and <strong class="source-inline">Nanoseconds()</strong> values of the time it took to complete the task.</p>
			<p>There are four resolutions you will be provided with, namely:</p>
			<ul>
				<li>Hours</li>
				<li>Minutes</li>
				<li>Seconds</li>
				<li>Nanoseconds</li>
			</ul>
			<p>If you need, for example, days, weeks, or months, then you can calculate it from the resolutions provided.</p>
			<p>Back in the day, we had a requirement to measure the duration of transactions, and we had a Service Level Agreement (SLA) that needed to be met. This meant that there were applications that needed to process a request in, let's say, 1,000 ms or 5 s depending on the criticality of the product. The next script will show you how this was implemented. There are 6 different resolutions that you have the option to choose from:</p>
			<ul>
				<li>Hour</li>
				<li>Minute</li>
				<li>Second</li>
				<li>Millisecond</li>
				<li>Microsecond</li>
				<li>Nanosecond</li>
			</ul>
			<p>Let's consider the following example:</p>
			<p class="source-code">  deadline_seconds := time.Duration((600 * 10) * time.Millisecond)</p>
			<p class="source-code">  Start := time.Now()</p>
			<p class="source-code">  fmt.Println("Deadline for the transaction is  ",deadline_seconds)</p>
			<p class="source-code">  fmt.Println("The transaction has started at: ", Start)</p>
			<p class="source-code">  sum := 0</p>
			<p class="source-code">  for i := 1; i &lt; 25000000000; i++ {</p>
			<p class="source-code">      sum += i</p>
			<p class="source-code">  }</p>
			<p class="source-code">  End := time.Now()</p>
			<p class="source-code">  //Duration := time.Duration((End.Sub(Start)).Seconds() * time.Second)</p>
			<p class="source-code">  Duration := End.Sub(Start)</p>
			<p class="source-code">  TransactionTime := time.Duration(Duration.Nanoseconds()) * time.Nanosecond</p>
			<p class="source-code">  fmt.Println("The transaction has completed at: ", End, Duration)</p>
			<p class="source-code">  if TransactionTime &lt;= deadline_seconds{</p>
			<p class="source-code">    fmt.Println("Performance is OK transaction completed in",TransactionTime)</p>
			<p class="source-code">  }else{</p>
			<p class="source-code">    fmt.Println("Performance problem, transaction completed in",TransactionTime,"second(s)!")</p>
			<p class="source-code">  }  </p>
			<p>When we don't meet the deadline, the output is as follows:</p>
			<div>
				<div id="_idContainer170" class="IMG---Figure">
					<img src="image/B14177_10_03.jpg" alt="Figure 10.3: Transaction deadline not met&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3: Transaction deadline not met</p>
			<p>When we meet the deadline, it looks like this:</p>
			<div>
				<div id="_idContainer171" class="IMG---Figure">
					<img src="image/B14177_10_04.jpg" alt="Figure 10.4: Transaction deadline met&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4: Transaction deadline met</p>
			<p>Let's dissect our example. First, we define a deadline for the transaction with the <strong class="source-inline">time.Duration()</strong> variable. In my experience, the <strong class="source-inline">Millisecond</strong> resolution is optimal; however, it does take some time to get used to calculating it. Feel free to use whichever resolution you prefer. We mark the beginning with the <strong class="source-inline">Start</strong> variable, do some calculations, and mark the completion with the <strong class="source-inline">End</strong> variable. The magic happens after this. We would like to calculate the difference between the deadline and the transaction duration, but we cannot do it directly. We need to convert the <strong class="source-inline">Duration</strong> value to <strong class="source-inline">Transaction</strong> time. This is done the same way when we created our deadline. We simply use the <strong class="source-inline">Nanosecond</strong> resolution, which is the lowest resolution we should go to. However, in this case, you can use the resolution you would like. After conversion, we can easily compare and decide whether the transaction is fine or not.</p>
			<p>Now, let's see how we can manipulate time.</p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor287"/>Managing Time</h1>
			<p>The Go programming language's <strong class="source-inline">time</strong> package provides two functions that allow you to manipulate time. One of them is called <strong class="source-inline">Sub()</strong>, and the other one is called <strong class="source-inline">Add()</strong>. There have not been many cases, in my experience, where this has been used. Mostly, when calculating the elapsed time of a script's execution, the <strong class="source-inline">Sub()</strong> function is used to tell the difference.</p>
			<p>Let's see what the addition looks like:</p>
			<p class="source-code">  TimeToManipulate := time.Now()</p>
			<p class="source-code">  ToBeAdded := time.Duration(10 * time.Second)</p>
			<p class="source-code">  fmt.Println("The original time:",TimeToManipulate)</p>
			<p class="source-code">  fmt.Println(ToBeAdded," duration later:",TimeToManipulate.Add(ToBeAdded))</p>
			<p>After execution, the following output welcomes us:</p>
			<p class="source-code">The original time: 2019-10-18 08:49:53.1499273 +0200 CEST m=+0.001994601</p>
			<p class="source-code">10s duration later: 2019-10-18 08:50:03.1499273 +0200 CEST m=+10.001994601</p>
			<p>Let's inspect what happened here. We created a variable to hold our time, which requires some manipulation. The <strong class="source-inline">ToBeAdded</strong> variable represents a duration of 10 seconds, which we would like to add. The <strong class="source-inline">Add()</strong> function of the <strong class="source-inline">time</strong> package expects a variable of the <strong class="source-inline">time.Duration()</strong> type. Then, we simply call the <strong class="source-inline">Add()</strong> function of our date, and the result is visible on the console. The functionality of the <strong class="source-inline">Sub()</strong> function is rather cumbersome, and it is not really intended to remove a specific duration from the time we have. It can be done, but you need many more lines of code to achieve this. What you can do is craft your duration with a negative value. If you swap out the second line to this:</p>
			<p class="source-code">ToBeAdded := time.Duration(-10 * time.Minute)</p>
			<p>It will work just fine and output you this:</p>
			<p class="source-code">The original time: 2019-10-18 08:50:36.5950116 +0200 CEST m=+0.001994401</p>
			<p class="source-code">-10m0s duration later: 2019-10-18 08:40:36.5950116 +0200 CEST m=+599.998005599</p>
			<p>This works as we expected; we have successfully calculated what time it was 10 minutes ago.</p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor288"/>Exercise 10.2: Duration of Execution</h2>
			<p>In this exercise, we will craft a function that allows you to calculate the duration of the execution between two <strong class="source-inline">time.Time</strong> variables and return a string that tells you how long the execution took to complete:</p>
			<p>Perform the following steps in order:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">Chapter_10_Exercise_2.go</strong>.</li>
				<li>Initialize the script with the following <strong class="source-inline">package</strong> and <strong class="source-inline">import</strong> statements:<p class="source-code">package main </p><p class="source-code">import "time"</p><p class="source-code">import "fmt"</p><p class="source-code">import "strconv"</p></li>
				<li>Let's now define our <strong class="source-inline">elapsedTime()</strong> function:<p class="source-code">func elapsedTime(start time.Time, end time.Time) string {</p><p class="source-code">  Elapsed := end.Sub(start)</p><p class="source-code">  Hours := strconv.Itoa(int(Elapsed.Hours()))</p><p class="source-code">  Minutes := strconv.Itoa(int(Elapsed.Minutes()))</p><p class="source-code">  Seconds := strconv.Itoa(int(Elapsed.Seconds()))</p><p class="source-code">  return "The total execution time elapsed is: " + Hours + " hour(s) and " +     Minutes + " minute(s) and " + Seconds + " second(s)!"</p><p class="source-code">}</p></li>
				<li>Now we are ready to define our <strong class="source-inline">main()</strong> function:<p class="source-code">func main(){</p><p class="source-code">  Start := time.Now()</p><p class="source-code">  time.Sleep(2 * time.Second)</p><p class="source-code">  End := time.Now()</p><p class="source-code">  fmt.Println(elapsedTime(Start,End))</p><p class="source-code">}</p></li>
				<li>Run the code:<p class="source-code">go run Chapter_10_Exercise_2.go</p><p>The following should appear as the output:</p><p class="source-code">The total execution time elapsed is: 0 hour(s) and 0 minute(s) and 2   second(s)!</p></li>
			</ol>
			<p>In this exercise, we created a function that shows us how many hours, minutes, and seconds it took to execute the action. This is useful because you can reuse this function in other Go apps.</p>
			<p>Now, let's turn our eyes toward the formatting of time.</p>
			<h1 id="_idParaDest-273"><a id="_idTextAnchor289"/>Formatting Time</h1>
			<p>So far in this chapter, you may have noticed that the dates are pretty ugly. I mean, take a look at the following lines:</p>
			<p class="source-code">The transaction has started at:  2019-09-27 13:50:58.2715452 +0200 CEST   m=+0.002992801</p>
			<p>These were intentionally left there to force you to think about whether this is all that Go can do. Is there a way to format down these lines to make them more convenient and easier to read? If so, what are those extra lines?</p>
			<p>Here, we will answer those questions. When we talk about time formatting, there are two main concepts we are referring to. The first option is for instances when we would like our time variable to output a desired looking string when we use it in print, and the second option is for when we would like to take a string and parse it to a specific format. Both have their own use cases; we are going to look at them in more detail as I teach you how to use both.</p>
			<p>First, we are going to learn about the <strong class="source-inline">Parse()</strong> function. This function has essentially two arguments. The first one is the standard to parse against, and the second one is the string that needs to be parsed. The end of this parse will result in a time variable that can utilize built-in Go functions. Go uses a POSIX-based date format. <strong class="source-inline">Parse()</strong> is very useful when you have an application that is working with time values from different time zones and you would like to convert them, for example, to the same time zone for better understanding and easier comparison:</p>
			<p class="source-code">Mon Jan 2 15:04:05 -0700 MST 2006</p>
			<p class="source-code">0      1     2   3   4   5      6</p>
			<p>This date format is equal to "123456" in POSIX, which can be decoded from the preceding example. There are constants provided in the language to help you deal with parsing different time strings.</p>
			<p>There are three main standards against which we can parse the time:</p>
			<ul>
				<li>RFC3339</li>
				<li>UnixDate</li>
				<li>ANSIC</li>
			</ul>
			<p>Let's take a look at how <strong class="source-inline">Parse()</strong> works:</p>
			<p class="source-code">  t1, _ := time.Parse(time.RFC3339,"2019-09-27T22:18:11+00:00")</p>
			<p class="source-code">  t2, _ := time.Parse(time.UnixDate,"2019-09-27T22:18:11+00:00")</p>
			<p class="source-code">  t3, _ := time.Parse(time.ANSIC,"2019-09-27T22:18:11+00:00")</p>
			<p class="source-code">  fmt.Println("RFC3339:",t1)</p>
			<p class="source-code">  fmt.Println("UnixDate",t2)</p>
			<p class="source-code">  fmt.Println("ANSIC",t3)</p>
			<p>The output is as follows:</p>
			<p class="source-code">RFC3339: 2019-19-27 22:18:11 +0000 +0000</p>
			<p class="source-code">UnixDate 0001-01-01 00:00:00 +0000 UTC</p>
			<p class="source-code">ANSIC 0001-01-01 00:00:00 +0000 UTC</p>
			<p>What happens behind the scenes is as follows. We have the <strong class="source-inline">t1</strong>, <strong class="source-inline">t2</strong>, and <strong class="source-inline">t3</strong> variables that hold the time, which is parsed against the specified format. The <strong class="source-inline">_</strong> variables hold the error results if there are any during the conversion. The output from the <strong class="source-inline">t1</strong> variable is the only one that makes sense; <strong class="source-inline">UnixDate</strong> and the ANSIC are wrong because the wrong string is parsed against the standard. <strong class="source-inline">UnixDate</strong> expects something that they call <strong class="source-inline">epoch</strong>. The epoch is a very unique date; on UNIX systems, it marks the beginning of time, which starts at January 1, 1970. It expects a huge integer, which is the number of seconds elapsed since this date. The format expects something like this as the input: <strong class="source-inline">Mon Sep _27 18:24:05 2019</strong>. Providing such time allows the <strong class="source-inline">Parse()</strong> function to provide the correct output.</p>
			<p>Now that we have clarified the <strong class="source-inline">Parse()</strong> function, it's time to look at the <strong class="source-inline">Format()</strong> function.</p>
			<p>Go allows you to craft your own <strong class="source-inline">time</strong> variables. Let's learn how we can do that and, afterward, we will format it:</p>
			<p class="source-code">date := time.Date(2019, 9, 27, 18, 50, 48, 324359102, time.UTC)</p>
			<p class="source-code">fmt.Println(date)</p>
			<p>The preceding code demonstrates how you can craft the time for yourself; however, we are going to look at what all those numbers are. The skeleton syntax for that is as follows:</p>
			<p class="source-code">func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location)   Time</p>
			<p>Essentially, we need to specify the year, month, day, hour, and so on. We would like to reformat our output based on the input variables; this should appear as follows:</p>
			<p class="source-code">2019-09-27 18:50:48.324359102 +0000 UTC</p>
			<p>Time zones were not important until people started working in big enterprise environments. When you have a global fleet of interconnected devices, it is important to be able to differentiate between time zones. If you want to have an <strong class="source-inline">AddDate()</strong> function, which can be used to add <strong class="source-inline">Year</strong>, <strong class="source-inline">Month</strong>, and <strong class="source-inline">Day</strong> to your current time, then this must enable you to dynamically add to your dates. Let's take a look at an example. Given our previous date, let's add 1 year, 2 months, and 3 days:</p>
			<p class="source-code">date := time.Date(2019, 9, 27, 18, 50, 48, 324359102, time.UTC)</p>
			<p class="source-code">next_date := date.AddDate(1, 2, 3)</p>
			<p class="source-code">fmt.Prinln(next_date)</p>
			<p>You will get the following output upon execution of this program:</p>
			<p class="source-code">2020-11-30 18:50:48.324359102 +0000 UTC</p>
			<p>The <strong class="source-inline">AddDate()</strong> function takes three arguments: the first is <strong class="source-inline">Year</strong>, the second is <strong class="source-inline">Month</strong>, and the third is <strong class="source-inline">Day</strong>. This gives you the opportunity to fine-tune the scripts you have. In order to properly understand how formatting works, you need to know what is under the hood.</p>
			<p>One last important aspect of time formatting is to understand how you can utilize the <strong class="source-inline">LoadLocation()</strong> function of the <strong class="source-inline">time</strong> package to convert your local time to the local time of another time zone. Our reference time zone will be the <strong class="source-inline">Los Angeles</strong> time zone. The <strong class="source-inline">Format()</strong> function is used to tell Go how we would like to see our output formatted. The <strong class="source-inline">In()</strong> function is a reference to a specific time zone we want our formatting to be present in.</p>
			<p>Let's find out what the time is in Berlin:</p>
			<p class="source-code">Current := time.Now()</p>
			<p class="source-code">  Berlin, _ := time.LoadLocation("America/Los_Angeles")</p>
			<p class="source-code">  fmt.Println("The local current time is:",Current.Format(time.ANSIC))</p>
			<p class="source-code">  fmt.Println("The time in Berlin is: ",Current.In(Berlin).Format(time.ANSIC))</p>
			<p>Depending on your day of execution, you should see the following output:</p>
			<p class="source-code">The local current time is: Fri Oct 18 08:14:48 2019</p>
			<p class="source-code">The time in Berlin is: Thu Oct 17 23:14:48 2019</p>
			<p>The key here is that we get our local time in a variable, and then we use the <strong class="source-inline">In()</strong> function of the <strong class="source-inline">time</strong> package to, say, convert that value to a specific time zone's value. It's simple, yet useful.</p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor290"/>Exercise 10.03: What Is the Time in Your Zone?</h2>
			<p>In this exercise, we will create a function that tells the difference between the current time zone and the specified time zone. The function will utilize the <strong class="source-inline">LoadLocation()</strong> function to specify the location based on which a variable will be set to a specific time. The <strong class="source-inline">In()</strong> location will be used to convert a specific time value to a given time zone value. The output format should be in the ANSIC standard.</p>
			<p>Perform the following steps in order:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">Chapter_10_Exercise_3.go</strong>.</li>
				<li>Initialize the script with the following <strong class="source-inline">package</strong> and <strong class="source-inline">import</strong> statements:<p class="source-code">package main</p><p class="source-code">import "time"</p><p class="source-code">import "fmt"</p></li>
				<li>Now is the time to create our function called <strong class="source-inline">timeDiff()</strong>, which will also return the <strong class="source-inline">Current</strong> and the <strong class="source-inline">RemoteTime</strong> variable formatted with ANSIC:<p class="source-code">func timeDiff(timezone string) (string, string)  {</p><p class="source-code">  Current := time.Now()</p><p class="source-code">  RemoteZone, _ := time.LoadLocation(timezone)</p><p class="source-code">  RemoteTime := Current.In(RemoteZone)</p><p class="source-code">  fmt.Println("The current time is: ",Current.Format(time.ANSIC))</p><p class="source-code">  fmt.Println("The timezone:",timezone,"time is:",RemoteTime)</p><p class="source-code">  return Current.Format(time.ANSIC), RemoteTime.Format(time.ANSIC)</p><p class="source-code">}</p></li>
				<li>Define the <strong class="source-inline">main()</strong> function:<p class="source-code">func main(){</p><p class="source-code">  fmt.Println(timeDiff("America/Los_Angeles"))</p><p class="source-code">}</p></li>
				<li>Run the code:<p class="source-code">go run Chapter_10_Exercise_3.go</p><p>The output looks as follows:</p><p class="source-code">The current time is: Thu Oct 17 15:37:02 2019</p><p class="source-code">The timezone: America/Los_Angeles time is: 2019-10-17 06:37:02.2440679 -0700   PDT</p><p class="source-code">Thu Oct 17 15:37:02 2019 Thu Oct 17 06:37:02 2019</p></li>
			</ol>
			<p>In this exercise, we saw how easy it is to navigate between different time zones.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor291"/>Activity 10.01: Formatting a Date According to User Requirements</h2>
			<p>In this activity, you need to create a small script that takes the current date and outputs it in the following format: "02:49:21 31/01/2019." You need to utilize what you have learned so far regarding the conversion of an integer to a string. This will allow you to concatenate different parts of your <strong class="source-inline">time</strong> variable. Remember that the <strong class="source-inline">date.Month()</strong> function omits the name and not the number of the month.</p>
			<p>You have to perform the following steps to get the desired output:</p>
			<ol>
				<li value="1">Use the <strong class="source-inline">time.Now()</strong> function to capture the current date in a variable.</li>
				<li>Dissect the captured date to <strong class="source-inline">day</strong>, <strong class="source-inline">month</strong>, <strong class="source-inline">year</strong>, <strong class="source-inline">hour</strong>, <strong class="source-inline">minute</strong>, and <strong class="source-inline">seconds</strong> variables by converting them into strings.</li>
				<li>Print out the concatenated variables in order.<p>Once the script is complete, the output should appear as follows (note that this depends on when you run the code):</p><p class="source-code">15:32:30 2019/10/17</p><p>By the end of this activity, you should have learned how you can craft your custom <strong class="source-inline">time</strong> variables and use <strong class="source-inline">strconv.Itoa()</strong> to convert a number to a string and concatenate the result.</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 729.</p></li>
			</ol>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor292"/>Activity 10.02: Enforcing a Specific Format of Date and Time</h2>
			<p>This activity requires you to use the knowledge you have accumulated in this chapter about time. We would like to create a small script that prints out a date with the following format: "02:49:21 31/01/2019."</p>
			<p>First, you need to create a <strong class="source-inline">date</strong> variable by utilizing the <strong class="source-inline">time.Date()</strong> function. You then need to recall how we accessed the <strong class="source-inline">Year</strong>, <strong class="source-inline">Month</strong>, and <strong class="source-inline">Day</strong> properties of the variable, and create a concatenation with an appropriate order. Remember that you cannot concatenate string and integer variables. The <strong class="source-inline">strconv()</strong> function is there to help you. You also need to remember that when you omit the <strong class="source-inline">date.Month()</strong> command, it prints the name of the month, but it also needs to be converted into an integer and then back into a string with a number.</p>
			<p>You have to perform the following steps to get the desired output:</p>
			<ol>
				<li value="1">Capture the current date with the <strong class="source-inline">time.Now()</strong> function in a variable.</li>
				<li>Use the <strong class="source-inline">strconv.Itoa()</strong> function to save the appropriate parts of the captured <strong class="source-inline">date</strong> variable into the following variables: <strong class="source-inline">day</strong>, <strong class="source-inline">month</strong>, <strong class="source-inline">year</strong>, <strong class="source-inline">hour</strong>, <strong class="source-inline">minute</strong>, and <strong class="source-inline">second</strong>.</li>
				<li>Finally, print these out using the appropriate concatenation.<p>The expected output should look like this:</p><p class="source-code">2:49:21 2019/1/31</p><p>By the end of this activity, you should have learned how to format the current date to a specific custom format.</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 730.</p></li>
			</ol>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor293"/>Activity 10.03: Measuring Elapsed Time</h2>
			<p>This activity requires you to measure the duration of sleep. You should use the <strong class="source-inline">time.Sleep()</strong> function to sleep for 2 seconds, and once the sleep is complete, you need to calculate the difference from the start and end times and show how many seconds it took.</p>
			<p>First, you mark the start of the execution, sleep for 2 seconds, and then capture the end of the execution time in a variable. By utilizing the <strong class="source-inline">time.Sub()</strong> function, we can use the <strong class="source-inline">Seconds()</strong> function to output the result. The output will be a bit strange as it will be slightly longer than expected.</p>
			<p>You have to perform the following steps to get the desired output:</p>
			<ol>
				<li value="1">Capture the start time in a variable.</li>
				<li>Craft a sleep variable that is 2 seconds long.</li>
				<li>Capture the end time in a variable.</li>
				<li>Calculate the length by subtracting the start time from the end time.</li>
				<li>Print out the result.<p>Depending on the speed of your PC, you should expect the following output:</p><p class="source-code">The execution took exactly 2.0016895 seconds!</p><p>By the end of this activity, you should have learned how to measure the elapsed time for a specific activity.</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 730.</p></li>
			</ol>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor294"/>Activity 10.04: Calculating the Future Date and Time</h2>
			<p>In this activity, we are going to calculate the date that is 6 hours, 6 minutes, and 6 seconds from <strong class="source-inline">Now()</strong>. You will need to capture the current time in a variable. Then, utilize the <strong class="source-inline">Add()</strong> function on the given date to add the previously mentioned length. Please use the <strong class="source-inline">time.ANSIC</strong> format for convenience. There is a catch, however. Because the <strong class="source-inline">Add()</strong> function expects a duration, you need to pick a resolution such as <strong class="source-inline">Second</strong> and craft the duration before you can add it.</p>
			<p>You have to perform the following steps to get the desired output:</p>
			<ol>
				<li value="1">Capture the current time in a variable.</li>
				<li>Print out this value as a reference in ANSIC format.</li>
				<li>Calculate the duration with seconds as input.</li>
				<li>Add the duration to the current time.</li>
				<li>Print out the future date in ANSIC format.<p>Make sure your output looks like this, with the string formatting:</p><p class="source-code">The current time: Thu Oct 17 15:16:48 2019</p><p class="source-code">6 hours, 6 minutes and 6 seconds from now the time will be:  Thu Oct 17   21:22:54 2019</p><p>By the end of this activity, you should have learned how you can calculate specific dates in the future by utilizing the <strong class="source-inline">time.Duration()</strong> and <strong class="source-inline">time.Add()</strong> functions.</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 731.</p></li>
			</ol>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor295"/>Activity 10.05: Printing the Local Time in Different Time Zones</h2>
			<p>This activity requires you to utilize what you learned in the <em class="italic">Formatting Time</em> section. You need to load an east coast city and a west coast city. Then, print out the current time for each city.</p>
			<p>The key here is the <strong class="source-inline">LoadLocation()</strong> function, and you need to use the <strong class="source-inline">ANSIC</strong> format for the output. Remember that the <strong class="source-inline">LoadLocation()</strong> function returns two values!</p>
			<p>You have to perform the following steps to get the desired output:</p>
			<ol>
				<li value="1">Capture the current time in a variable.</li>
				<li>Create the reference time zone variables for <strong class="source-inline">NYtime</strong> and <strong class="source-inline">LA</strong> using the <strong class="source-inline">time.LoadLocation()</strong> function.</li>
				<li>Print out, in ANSIC format, the current time in the respective time zones.<p>Depending on your day of execution, the following could be your expected output:</p><p class="source-code">The local current time is: Thu Oct 17 15:16:13 2019</p><p class="source-code">The time in New York is: Thu Oct 17 09:16:13 2019</p><p class="source-code">The time in Los Angeles is: Thu Oct 17 06:16:13 2019</p><p>By the end of this activity, you should have learned how to convert your time variables to a specific time zone.</p><p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 732.</p></li>
			</ol>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor296"/>Summary</h1>
			<p>This chapter introduced you to the <strong class="source-inline">time</strong> package of <strong class="source-inline">go</strong>, which allows you to reuse code that has been invented by other programmers and incorporated into the language. The goal was to teach you how to create, manipulate, and format time variables, and, in general, make you familiar with what you can do with the help of the <strong class="source-inline">time</strong> package. If you would like to further improve or dig deeper into what the package has to offer, you should check out the following link: <a href="https://golang.org/pkg/time/">https://golang.org/pkg/time/</a>.</p>
			<p>Timestamps and time manipulation are essential skills for every developer. Whether you have a big or small script put into production, the time module helps you to measure the elapsed time of actions and provide you with the logging of actions that happen during the execution. The most important thing about it, if used correctly, is that it helps you to easily trace back production problems to their roots.</p>
			<p>The next chapter will introduce you to encoding and decoding JSON, that is, the JavaScript Object Notation.</p>
		</div>
		<div>
			<div id="_idContainer173" class="Content">
			</div>
		</div>
	</body></html>