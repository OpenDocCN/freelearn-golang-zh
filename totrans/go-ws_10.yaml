- en: 10\. About Time
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10. 关于时间
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter demonstrates how Go handles variables representing time data, which
    is a very important aspect of the language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章演示了 Go 如何处理表示时间数据的变量，这是语言非常重要的一个方面。
- en: By the end of this chapter, you will be able to create your own time format,
    compare and manage time, calculate the duration of time series, and format time
    according to user requirements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够创建自己的时间格式，比较和管理时间，计算时间序列的持续时间，并根据用户要求格式化时间。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The previous chapter introduced you to basic debugging in Go. The more you develop
    code in Go, the better you get; however, developing and deploying code may come
    with corner cases that need to be debugged. The previous chapter showed you how
    to use the `fmt` package, how to log into files, and how to use the `f` function
    format.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章向您介绍了 Go 中的基本调试。在 Go 中编写代码越多，你的技能就越好；然而，开发和部署代码可能会遇到需要调试的边缘情况。前一章展示了如何使用
    `fmt` 包，如何将日志记录到文件中，以及如何使用 `f` 函数格式。
- en: This chapter is dedicated to teaching you all you need to know about handling
    variables that represent time data. You will learn how to do it the "Go-way".
    First, we will start out with basic time creation, timestamps, and more; then,
    we will learn how to compare and manipulate time, calculate the duration between
    two dates, and create timestamps. Finally, we will learn how to format the time
    according to our needs. So, let's not waste any more time and jump right in.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于教你所有关于处理表示时间数据的变量的知识。你将学习如何以“Go方式”完成它。首先，我们将从基本的时间创建、时间戳等开始；然后，我们将学习如何比较和操作时间，计算两个日期之间的持续时间，并创建时间戳。最后，我们将学习如何根据我们的需求格式化时间。所以，我们不要浪费时间，直接进入正题。
- en: Making Time
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建时间
- en: 'Making time means declaring a variable that holds the time formatted in a specific
    way. Formatting time will be covered at the end of this chapter; so, for now,
    we will use the default formatting that is provided by Go. In this topic, we will
    be executing everything in the `main()` function of our script, so the skeleton
    should look like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 创建时间意味着声明一个变量，该变量以特定方式格式化时间。格式化时间将在本章末尾介绍；因此，现在我们将使用 Go 提供的默认格式化。在这个主题中，我们将在脚本的
    `main()` 函数中执行所有操作，所以骨架应该如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's look at our skeleton first and learn how to create and manipulate time
    variables. Our skeleton has the standard `package main` definition that is necessary.
    We use the `fmt` package to print the output to the console. Since we'll be using
    the `time` module, we'll need to import that as well.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看我们的骨架，并学习如何创建和操作时间变量。我们的骨架有必要的标准 `package main` 定义。我们使用 `fmt` 包将输出打印到控制台。由于我们将使用
    `time` 模块，我们还需要导入它。
- en: Whenever we issue `go run <script>.go`, the `main()` function gets called and
    executes whatever is declared in it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们执行 `go run <script>.go` 时，`main()` 函数会被调用并执行其中声明的任何内容。
- en: 'One of the most common jobs for the `time` module is to measure the duration
    of the execution for the script. We can do this by capturing the current time
    in a variable, at the beginning and at the end, so that we can calculate the difference
    and know how long the specific action took to complete. The very first example
    is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`time` 模块最常见的任务之一是测量脚本的执行持续时间。我们可以通过在开始和结束时捕获当前时间到变量中来实现这一点，以便我们可以计算差异并知道特定操作完成所需的时间。第一个例子如下：'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output from our script should look like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本的输出应该看起来像这样：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, this does not look very fancy; however, by the end of this chapter,
    you will have learned how to make it more readable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这看起来并不很花哨；然而，到本章结束时，你将学会如何让它更易于阅读。
- en: 'Consider the following scenario; your employer gives you a task to develop
    a small Go application that tests a web application based on the day of week.
    Your employer has the main release of a new web app every Monday at 12:00 AM CEST.
    With a downtime window from 12:00 AM CEST to 2:00 PM CEST, and the deployment
    being about 30 minutes, you have 1.5 hours to test the app. This is where Go''s
    time module comes to your rescue. The script performs a `hit-n-run` test on the
    other days of the week, but, on release day, you are required to perform a `full-blown`
    functionality test. The first version of the script took the argument to see which
    test to perform, but the second script version made the decision based on the
    day and the hour:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Testing strategies'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_10_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.1: Testing strategies'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The current day of the week is captured in the variable called `Day`. The hour
    of execution is also captured in the variable called `Hour`. When this script
    is executed, there are two types of output.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is a simple `hit-n-run` output, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The second one is the `full blown` output, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we have seen how the day of execution modifies the behavior
    of the application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The actual test was left out intentionally as this is not part of the chapter's
    topic. However, the output clearly shows which part was responsible for the control
    of the test.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example would be to create the log filenames for scripts in Go. The
    basic idea is to collect a log per day and have a timestamp concatenated to the
    name of the log file. The skeleton looks like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In Go, there is an elegant and simple way to do it:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output appears as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, there is a catch. If you want to concatenate strings with `time` types,
    which are not implicitly convertible, use the `strconv` package, which needs to
    be imported on top of your script:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In turn, this allows you to call the `strconv.Itoa()` function, which converts
    your `Year` and `Day` values and, finally, lets you concatenate them into a single
    string.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to make time variables, let's learn to compare
    them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.1: Creating a Function to Return a timestamp'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a function called `whatstheclock`. The goal
    of this function is to demonstrate how you can create a function that wraps a
    nice, formatted `time.Now()` function and returns the date in an `ANSIC` format.
    The `ANSIC` format will be explained in further detail in the *Formatting Time*
    section:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `Chapter_10_Exercise_1.go`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize the script with the package and import statements:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Define the function called `whatstheclock()`:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `main()` function, define a call to the `whatstheclock()` function and
    print the result to the console:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Save the file and run the code:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should see the following output:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this exercise, we demonstrated how you can create a small function that returns
    the current time in an ANSIC format.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Any type of operating system that you work with will provide two types of clocks
    to measure the time; one is called the "monotonic clock", and the other is called
    the "wall clock." The wall clock is what you see on a Windows machine in the taskbar;
    it's subject to change and is usually synchronized with a public or corporate
    NTP server based on your current location. The **NTP** server stands for **Network
    Time Protocol** and is used to tell clients the time based on an atomic clock,
    or from a satellite reference.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Time
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, when working with Go on smaller scripts, it is very important
    for your statistics to know when a script should run, or between what hours and
    minutes a script should be completed. By statistics, we mean knowing how much
    time the app saves by executing a specific operation compared to what time cost
    it would have if we had to perform these manually. This allows us to measure the
    improvement of the script over time when we develop the functionality further.
    In this topic, we will look at some live examples demonstrating how you can solve
    this problem.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the logic for the first script, which was intended not
    to run before or after a specified time. This time can arrive either via another
    automation, or when a trigger file is manually placed there; every day, the script
    needs to run at different times, specifically, after the specified time as soon
    as possible.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'The time was in the following `2019-09-27T22:08:41+00:00` format:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the script when we are not yet at the deadline is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we meet the criteria, the output looks like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s examine what is happening here. We create the `now` variable, which
    is crucial for the execution. We have the `time` string parsed based on RFC3339\.
    RFC3339 specifies the format that should be used for the `date` and `time` strings.
    This function returns two values: one value is the output if the conversion succeeds,
    and the other is the error if there is one. We capture the output in the `only_after`
    variable, and we use a throwaway variable for capturing any output; this is the
    underscore sign, `_`. We could use a standard variable such as `only_after_error`,
    but unless we use that variable later in time, the compiler will throw an error
    that the variable was declared but never used. This is circumvented by the use
    of the `_` variable. Based on this logic, we could implement the `only_before`
    argument or variable very simply. The `time` package has two very useful functions:
    one is called `After()`, and the other is called `Before()`. They allow us to
    simply compare two `time` variables.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: There is a third function in the package called `Equal()`. This function allows
    you to compare two `time` variables and returns `true` or `false` depending on
    whether they are equal.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of the `Equal()` function in action:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Equal()`函数的一个实际例子：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output looks like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来像这样：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let's see what happens here. We have three `time` variables, which are called
    `now`, `now_too`, and `later`. The `time` module's `Sleep()` function is used
    to simulate the latency of 2 seconds. This function takes an integer argument
    and waits for the given time to pass and then continues the execution. The result
    of this is that the `later` variable holds different time values and allows us
    to demonstrate the `Equal()` function's purpose, which you can see in the output.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里会发生什么。我们有三个`time`变量，分别称为`now`、`now_too`和`later`。`time`模块的`Sleep()`函数用于模拟2秒的延迟。这个函数接受一个整数参数，等待给定的时间过去然后继续执行。结果是`later`变量持有不同的时间值，使我们能够展示`Equal()`函数的目的，这在输出中可以看到。
- en: Now, the time has come to check what facilities are provided to calculate the
    duration or difference between the two `time` variables.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候检查提供了哪些设施来计算两个`time`变量之间的持续时间或差异了。
- en: Duration Calculation
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续时间计算
- en: The ability to calculate the duration of an execution comes in handy during
    many aspects of programming. In our everyday life, we can monitor discrepancies
    and performance bottlenecks that our infrastructure might face. For example, if
    you have a script that takes only 5 seconds to complete on average and the monitoring
    execution time shows you a huge bump during certain hours of a day or certain
    days, it might be wise to investigate. The other aspect is related to web applications.
    Measuring the duration of request-response in your scripts can give you an insight
    into how well invested you are in your apps to serve high loads, and it even allows
    you to expand your capacity on certain days or weeks of the year. For example,
    if you have an online shop dealing with products, it might be wise to size your
    capacity according to patterns such as Black Friday or Christmas.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 计算执行持续时间的功能在编程的许多方面都很有用。在我们的日常生活中，我们可以监控我们的基础设施可能面临的不一致和性能瓶颈。例如，如果你有一个脚本平均只需要5秒钟就能完成，而监控执行时间显示在一天中的某些小时或某些天有大幅增加，那么进行调查可能很明智。另一个方面与Web应用程序有关。测量脚本中请求-响应的持续时间可以让你了解你在应用程序中投入了多少来应对高负载，甚至允许你在一年中的某些天或周扩展你的容量。例如，如果你有一个在线商店处理产品，根据像黑色星期五或圣诞节这样的模式来调整你的容量可能很明智。
- en: 'You may do well with a lower capacity during most of the year, but those holidays
    can result in revenue loss if the infrastructure is not sufficiently well sized.
    There is very little coding required to add such functionality to your scripts.
    Let''s now take a look at how to do it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数年份，你可能只需要较低容量，但那些假日如果没有足够好地调整基础设施，可能会导致收入损失。添加这样的功能到你的脚本中几乎不需要编写多少代码。现在让我们看看如何做：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you execute this script, the result will be something like this, depending
    on the PC''s performance:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个脚本，结果可能如下，这取决于电脑的性能：
- en: '![Figure 10.2: Measuring the execution time'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.2：测量执行时间'
- en: '](img/B14177_10_02.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_10_02.jpg)'
- en: 'Figure 10.2: Measuring the execution time'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2：测量执行时间
- en: All that needs to be done is to capture the time when the script starts and
    ends. Then, we can calculate the duration by subtracting the start time and the
    end time. After that, we can utilize the `Duration` variable's functions to get
    the `Hours()`, `Minutes()`, `Seconds()`, and `Nanoseconds()` values of the time
    it took to complete the task.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 所需要做的只是捕捉脚本开始和结束的时间。然后，我们可以通过减去开始时间和结束时间来计算持续时间。之后，我们可以利用`Duration`变量的函数来获取完成任务所需时间的`小时()`、`分钟()`、`秒()`和`纳秒()`值。
- en: 'There are four resolutions you will be provided with, namely:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你将获得四个分辨率，分别是：
- en: Hours
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小时
- en: Minutes
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分钟
- en: Seconds
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秒
- en: Nanoseconds
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纳秒
- en: If you need, for example, days, weeks, or months, then you can calculate it
    from the resolutions provided.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要，例如，天、周或月，那么你可以从提供的分辨率中计算出来。
- en: 'Back in the day, we had a requirement to measure the duration of transactions,
    and we had a Service Level Agreement (SLA) that needed to be met. This meant that
    there were applications that needed to process a request in, let''s say, 1,000
    ms or 5 s depending on the criticality of the product. The next script will show
    you how this was implemented. There are 6 different resolutions that you have
    the option to choose from:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我们有一个要求测量事务持续时间的任务，并且我们需要满足一个服务级别协议（SLA）。这意味着有一些应用程序需要根据产品的关键性在1,000毫秒或5秒内处理请求。接下来的脚本将向您展示这是如何实现的。您有6种不同的分辨率可供选择：
- en: Hour
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小时
- en: Minute
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分钟
- en: Second
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二
- en: Millisecond
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 毫秒
- en: Microsecond
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微秒
- en: Nanosecond
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纳秒
- en: 'Let''s consider the following example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下示例：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When we don''t meet the deadline, the output is as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们没有满足截止时间时，输出如下：
- en: '![Figure 10.3: Transaction deadline not met'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.3：未满足事务截止时间'
- en: '](img/B14177_10_03.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_10_03.jpg)'
- en: 'Figure 10.3: Transaction deadline not met'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3：未满足事务截止时间
- en: 'When we meet the deadline, it looks like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到截止时间时，它看起来是这样的：
- en: '![Figure 10.4: Transaction deadline met'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4：事务截止时间满足'
- en: '](img/B14177_10_04.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_10_04.jpg)'
- en: 'Figure 10.4: Transaction deadline met'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4：事务截止时间满足
- en: Let's dissect our example. First, we define a deadline for the transaction with
    the `time.Duration()` variable. In my experience, the `Millisecond` resolution
    is optimal; however, it does take some time to get used to calculating it. Feel
    free to use whichever resolution you prefer. We mark the beginning with the `Start`
    variable, do some calculations, and mark the completion with the `End` variable.
    The magic happens after this. We would like to calculate the difference between
    the deadline and the transaction duration, but we cannot do it directly. We need
    to convert the `Duration` value to `Transaction` time. This is done the same way
    when we created our deadline. We simply use the `Nanosecond` resolution, which
    is the lowest resolution we should go to. However, in this case, you can use the
    resolution you would like. After conversion, we can easily compare and decide
    whether the transaction is fine or not.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们剖析我们的例子。首先，我们使用`time.Duration()`变量为事务定义一个截止时间。根据我的经验，`Millisecond`的分辨率是最优的；然而，适应计算它确实需要一些时间。请随意使用您喜欢的任何分辨率。我们用`Start`变量标记开始，进行一些计算，并用`End`变量标记完成。魔法就在此之后发生。我们希望计算截止时间和事务持续时间之间的差异，但我们不能直接这样做。我们需要将`Duration`值转换为`Transaction`时间。这与我们创建截止时间时的方法相同。我们简单地使用`Nanosecond`分辨率，这是我们应达到的最低分辨率。然而，在这种情况下，您可以使用您想要的任何分辨率。转换后，我们可以轻松比较并决定事务是否正常。
- en: Now, let's see how we can manipulate time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何操作时间。
- en: Managing Time
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理时间
- en: The Go programming language's `time` package provides two functions that allow
    you to manipulate time. One of them is called `Sub()`, and the other one is called
    `Add()`. There have not been many cases, in my experience, where this has been
    used. Mostly, when calculating the elapsed time of a script's execution, the `Sub()`
    function is used to tell the difference.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Go编程语言的`time`包提供了两个函数，允许您操作时间。其中一个叫做`Sub()`，另一个叫做`Add()`。在我的经验中，这种情况并不常见。大多数情况下，当计算脚本的执行时间时，使用`Sub()`函数来告知差异。
- en: 'Let''s see what the addition looks like:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看添加的样子：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After execution, the following output welcomes us:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 执行后，以下输出欢迎我们：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s inspect what happened here. We created a variable to hold our time,
    which requires some manipulation. The `ToBeAdded` variable represents a duration
    of 10 seconds, which we would like to add. The `Add()` function of the `time`
    package expects a variable of the `time.Duration()` type. Then, we simply call
    the `Add()` function of our date, and the result is visible on the console. The
    functionality of the `Sub()` function is rather cumbersome, and it is not really
    intended to remove a specific duration from the time we have. It can be done,
    but you need many more lines of code to achieve this. What you can do is craft
    your duration with a negative value. If you swap out the second line to this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这里发生了什么。我们创建了一个变量来保存我们的时间，这需要一些操作。`ToBeAdded`变量代表10秒的持续时间，这是我们想要添加的。`time`包的`Add()`函数期望一个`time.Duration()`类型的变量。然后，我们简单地调用我们的日期的`Add()`函数，结果在控制台上可见。`Sub()`函数的功能相当繁琐，它并不是真正用来从我们拥有的时间中移除特定持续时间的。这是可以做到的，但你需要更多的代码行来实现这一点。您可以做的另一件事是用负值构建您的持续时间。如果您将第二行替换为以下内容：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It will work just fine and output you this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它将正常工作并输出以下内容：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This works as we expected; we have successfully calculated what time it was
    10 minutes ago.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这正如我们所期望的；我们已经成功计算出了10分钟前的时间。
- en: 'Exercise 10.2: Duration of Execution'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习10.2：执行持续时间
- en: 'In this exercise, we will craft a function that allows you to calculate the
    duration of the execution between two `time.Time` variables and return a string
    that tells you how long the execution took to complete:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个函数，允许您计算两个`time.Time`变量之间的执行持续时间，并返回一个字符串，告诉您执行完成花费了多长时间：
- en: 'Perform the following steps in order:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下顺序执行以下步骤：
- en: Create a file called `Chapter_10_Exercise_2.go`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Chapter_10_Exercise_2.go`的文件。
- en: 'Initialize the script with the following `package` and `import` statements:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`package`和`import`语句初始化脚本：
- en: '[PRE26]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s now define our `elapsedTime()` function:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来定义我们的`elapsedTime()`函数：
- en: '[PRE27]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we are ready to define our `main()` function:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备定义我们的`main()`函数：
- en: '[PRE28]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the code:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码：
- en: '[PRE29]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following should appear as the output:'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下应该是输出结果：
- en: '[PRE30]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this exercise, we created a function that shows us how many hours, minutes,
    and seconds it took to execute the action. This is useful because you can reuse
    this function in other Go apps.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建了一个函数，展示了执行动作花费了多少小时、分钟和秒。这很有用，因为您可以在其他Go应用程序中重用这个函数。
- en: Now, let's turn our eyes toward the formatting of time.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向时间的格式化。
- en: Formatting Time
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间格式化
- en: 'So far in this chapter, you may have noticed that the dates are pretty ugly.
    I mean, take a look at the following lines:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，您可能已经注意到日期看起来相当丑陋。我的意思是，看看以下行：
- en: '[PRE31]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These were intentionally left there to force you to think about whether this
    is all that Go can do. Is there a way to format down these lines to make them
    more convenient and easier to read? If so, what are those extra lines?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被故意留下以迫使您思考这真的是Go能做的所有事情。有没有一种方法可以将这些行格式化，使它们更方便、更容易阅读？如果有，那些额外的行是什么？
- en: Here, we will answer those questions. When we talk about time formatting, there
    are two main concepts we are referring to. The first option is for instances when
    we would like our time variable to output a desired looking string when we use
    it in print, and the second option is for when we would like to take a string
    and parse it to a specific format. Both have their own use cases; we are going
    to look at them in more detail as I teach you how to use both.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将回答这些问题。当我们谈论时间格式化时，有两个主要概念是我们所指的。第一个选项是在我们希望我们的时间变量在打印时输出一个期望的字符串时，第二个选项是在我们希望将一个字符串解析为特定格式时。两者都有自己的用例；我将详细向您介绍如何使用这两个选项。
- en: 'First, we are going to learn about the `Parse()` function. This function has
    essentially two arguments. The first one is the standard to parse against, and
    the second one is the string that needs to be parsed. The end of this parse will
    result in a time variable that can utilize built-in Go functions. Go uses a POSIX-based
    date format. `Parse()` is very useful when you have an application that is working
    with time values from different time zones and you would like to convert them,
    for example, to the same time zone for better understanding and easier comparison:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将学习关于`Parse()`函数的内容。这个函数本质上有两个参数。第一个是要解析的标准，第二个是需要解析的字符串。解析的结束将产生一个可以利用内置Go函数的时间变量。Go使用基于POSIX的日期格式。`Parse()`在您有一个处理来自不同时区的时间值的应用程序时非常有用，您希望将它们转换为同一时区，以便更好地理解和比较：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This date format is equal to "123456" in POSIX, which can be decoded from the
    preceding example. There are constants provided in the language to help you deal
    with parsing different time strings.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种日期格式在POSIX中等于"123456"，可以从前面的示例中解码。语言中提供了常量来帮助您处理解析不同的时间字符串。
- en: 'There are three main standards against which we can parse the time:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对照以下三个主要标准来解析时间：
- en: RFC3339
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RFC3339
- en: UnixDate
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UnixDate
- en: ANSIC
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ANSIC
- en: 'Let''s take a look at how `Parse()` works:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Parse()`是如何工作的：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'What happens behind the scenes is as follows. We have the `t1`, `t2`, and `t3`
    variables that hold the time, which is parsed against the specified format. The
    `_` variables hold the error results if there are any during the conversion. The
    output from the `t1` variable is the only one that makes sense; `UnixDate` and
    the ANSIC are wrong because the wrong string is parsed against the standard. `UnixDate`
    expects something that they call `epoch`. The epoch is a very unique date; on
    UNIX systems, it marks the beginning of time, which starts at January 1, 1970\.
    It expects a huge integer, which is the number of seconds elapsed since this date.
    The format expects something like this as the input: `Mon Sep _27 18:24:05 2019`.
    Providing such time allows the `Parse()` function to provide the correct output.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 背后发生的事情如下。我们有 `t1`、`t2` 和 `t3` 变量，它们持有时间，这些时间与指定的格式进行解析。如果转换过程中有任何错误，`_` 变量将持有错误结果。`t1`
    变量的输出是唯一有意义的；`UnixDate` 和 ANSIC 是错误的，因为它们解析了错误的字符串与标准格式。`UnixDate` 期望的是它们称之为 `epoch`
    的东西。`epoch` 是一个非常独特的日期；在 UNIX 系统中，它标志着时间的开始，始于 1970 年 1 月 1 日。它期望一个巨大的整数，这是从这个日期开始经过的秒数。格式期望的输入如下：`Mon
    Sep _27 18:24:05 2019`。提供这样的时间允许 `Parse()` 函数提供正确的输出。
- en: Now that we have clarified the `Parse()` function, it's time to look at the
    `Format()` function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经阐明了 `Parse()` 函数，现在是时候看看 `Format()` 函数了。
- en: 'Go allows you to craft your own `time` variables. Let''s learn how we can do
    that and, afterward, we will format it:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Go 允许你创建自己的 `time` 变量。让我们学习如何做到这一点，然后我们将对其进行格式化：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code demonstrates how you can craft the time for yourself; however,
    we are going to look at what all those numbers are. The skeleton syntax for that
    is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码演示了如何自己创建时间；然而，我们将查看所有这些数字的含义。其骨架语法如下：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Essentially, we need to specify the year, month, day, hour, and so on. We would
    like to reformat our output based on the input variables; this should appear as
    follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，我们需要指定年、月、日、小时等等。我们希望根据输入变量重新格式化我们的输出；它应该如下所示：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Time zones were not important until people started working in big enterprise
    environments. When you have a global fleet of interconnected devices, it is important
    to be able to differentiate between time zones. If you want to have an `AddDate()`
    function, which can be used to add `Year`, `Month`, and `Day` to your current
    time, then this must enable you to dynamically add to your dates. Let''s take
    a look at an example. Given our previous date, let''s add 1 year, 2 months, and
    3 days:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 时区在人们开始在大企业环境中工作之前并不重要。当你有一支全球互联的设备舰队时，能够区分时区很重要。如果你想有一个 `AddDate()` 函数，它可以用来将
    `Year`、`Month` 和 `Day` 添加到你的当前时间，那么这必须允许你动态地添加到你的日期。让我们看看一个例子。给定我们之前的日期，让我们添加
    1 年、2 个月和 3 天：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You will get the following output upon execution of this program:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此程序后，你会得到以下输出：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `AddDate()` function takes three arguments: the first is `Year`, the second
    is `Month`, and the third is `Day`. This gives you the opportunity to fine-tune
    the scripts you have. In order to properly understand how formatting works, you
    need to know what is under the hood.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddDate()` 函数接受三个参数：第一个是 `Year`，第二个是 `Month`，第三个是 `Day`。这给了你调整你拥有的脚本的精细度。为了正确理解格式化是如何工作的，你需要知道其背后的原理。'
- en: One last important aspect of time formatting is to understand how you can utilize
    the `LoadLocation()` function of the `time` package to convert your local time
    to the local time of another time zone. Our reference time zone will be the `Los
    Angeles` time zone. The `Format()` function is used to tell Go how we would like
    to see our output formatted. The `In()` function is a reference to a specific
    time zone we want our formatting to be present in.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 时间格式化的最后一个重要方面是了解你如何利用 `time` 包的 `LoadLocation()` 函数将你的本地时间转换为另一个时区的本地时间。我们的参考时区将是
    `洛杉矶` 时区。`Format()` 函数用于告诉 Go 我们希望如何格式化输出。`In()` 函数是指我们希望格式化存在的特定时区。
- en: 'Let''s find out what the time is in Berlin:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们找出柏林的时间：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Depending on your day of execution, you should see the following output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的执行日，你应该看到以下输出：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The key here is that we get our local time in a variable, and then we use the
    `In()` function of the `time` package to, say, convert that value to a specific
    time zone's value. It's simple, yet useful.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于我们得到本地时间的一个变量，然后我们使用 `time` 包的 `In()` 函数，比如说，将这个值转换为一个特定时区的值。这很简单，但很有用。
- en: 'Exercise 10.03: What Is the Time in Your Zone?'
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create a function that tells the difference between
    the current time zone and the specified time zone. The function will utilize the
    `LoadLocation()` function to specify the location based on which a variable will
    be set to a specific time. The `In()` location will be used to convert a specific
    time value to a given time zone value. The output format should be in the ANSIC
    standard.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps in order:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `Chapter_10_Exercise_3.go`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize the script with the following `package` and `import` statements:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now is the time to create our function called `timeDiff()`, which will also
    return the `Current` and the `RemoteTime` variable formatted with ANSIC:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Define the `main()` function:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the code:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output looks as follows:'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this exercise, we saw how easy it is to navigate between different time zones.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 10.01: Formatting a Date According to User Requirements'
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, you need to create a small script that takes the current
    date and outputs it in the following format: "02:49:21 31/01/2019." You need to
    utilize what you have learned so far regarding the conversion of an integer to
    a string. This will allow you to concatenate different parts of your `time` variable.
    Remember that the `date.Month()` function omits the name and not the number of
    the month.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to perform the following steps to get the desired output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Use the `time.Now()` function to capture the current date in a variable.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dissect the captured date to `day`, `month`, `year`, `hour`, `minute`, and `seconds`
    variables by converting them into strings.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print out the concatenated variables in order.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the script is complete, the output should appear as follows (note that
    this depends on when you run the code):'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: By the end of this activity, you should have learned how you can craft your
    custom `time` variables and use `strconv.Itoa()` to convert a number to a string
    and concatenate the result.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 729.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Activity 10.02: Enforcing a Specific Format of Date and Time'
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This activity requires you to use the knowledge you have accumulated in this
    chapter about time. We would like to create a small script that prints out a date
    with the following format: "02:49:21 31/01/2019."'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to create a `date` variable by utilizing the `time.Date()` function.
    You then need to recall how we accessed the `Year`, `Month`, and `Day` properties
    of the variable, and create a concatenation with an appropriate order. Remember
    that you cannot concatenate string and integer variables. The `strconv()` function
    is there to help you. You also need to remember that when you omit the `date.Month()`
    command, it prints the name of the month, but it also needs to be converted into
    an integer and then back into a string with a number.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to perform the following steps to get the desired output:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Capture the current date with the `time.Now()` function in a variable.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `strconv.Itoa()` function to save the appropriate parts of the captured
    `date` variable into the following variables: `day`, `month`, `year`, `hour`,
    `minute`, and `second`.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, print these out using the appropriate concatenation.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output should look like this:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: By the end of this activity, you should have learned how to format the current
    date to a specific custom format.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 730.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Activity 10.03: Measuring Elapsed Time'
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This activity requires you to measure the duration of sleep. You should use
    the `time.Sleep()` function to sleep for 2 seconds, and once the sleep is complete,
    you need to calculate the difference from the start and end times and show how
    many seconds it took.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: First, you mark the start of the execution, sleep for 2 seconds, and then capture
    the end of the execution time in a variable. By utilizing the `time.Sub()` function,
    we can use the `Seconds()` function to output the result. The output will be a
    bit strange as it will be slightly longer than expected.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to perform the following steps to get the desired output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Capture the start time in a variable.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Craft a sleep variable that is 2 seconds long.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Capture the end time in a variable.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the length by subtracting the start time from the end time.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print out the result.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Depending on the speed of your PC, you should expect the following output:'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: By the end of this activity, you should have learned how to measure the elapsed
    time for a specific activity.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 730.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Activity 10.04: Calculating the Future Date and Time'
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we are going to calculate the date that is 6 hours, 6 minutes,
    and 6 seconds from `Now()`. You will need to capture the current time in a variable.
    Then, utilize the `Add()` function on the given date to add the previously mentioned
    length. Please use the `time.ANSIC` format for convenience. There is a catch,
    however. Because the `Add()` function expects a duration, you need to pick a resolution
    such as `Second` and craft the duration before you can add it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to perform the following steps to get the desired output:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Capture the current time in a variable.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print out this value as a reference in ANSIC format.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the duration with seconds as input.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the duration to the current time.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print out the future date in ANSIC format.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure your output looks like this, with the string formatting:'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: By the end of this activity, you should have learned how you can calculate specific
    dates in the future by utilizing the `time.Duration()` and `time.Add()` functions.
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 731.
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Activity 10.05: Printing the Local Time in Different Time Zones'
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This activity requires you to utilize what you learned in the *Formatting Time*
    section. You need to load an east coast city and a west coast city. Then, print
    out the current time for each city.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The key here is the `LoadLocation()` function, and you need to use the `ANSIC`
    format for the output. Remember that the `LoadLocation()` function returns two
    values!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to perform the following steps to get the desired output:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Capture the current time in a variable.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the reference time zone variables for `NYtime` and `LA` using the `time.LoadLocation()`
    function.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print out, in ANSIC format, the current time in the respective time zones.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Depending on your day of execution, the following could be your expected output:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: By the end of this activity, you should have learned how to convert your time
    variables to a specific time zone.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 732.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduced you to the `time` package of `go`, which allows you
    to reuse code that has been invented by other programmers and incorporated into
    the language. The goal was to teach you how to create, manipulate, and format
    time variables, and, in general, make you familiar with what you can do with the
    help of the `time` package. If you would like to further improve or dig deeper
    into what the package has to offer, you should check out the following link: [https://golang.org/pkg/time/](https://golang.org/pkg/time/).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Timestamps and time manipulation are essential skills for every developer. Whether
    you have a big or small script put into production, the time module helps you
    to measure the elapsed time of actions and provide you with the logging of actions
    that happen during the execution. The most important thing about it, if used correctly,
    is that it helps you to easily trace back production problems to their roots.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will introduce you to encoding and decoding JSON, that is,
    the JavaScript Object Notation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
