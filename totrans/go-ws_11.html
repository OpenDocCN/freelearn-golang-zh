<html><head></head><body>
		<div>
			<div id="_idContainer174" class="Content">
			</div>
		</div>
		<div id="_idContainer175" class="Content">
			<h1 id="_idParaDest-281"><a id="_idTextAnchor297"/>11. Encoding and Decoding (JSON)</h1>
		</div>
		<div id="_idContainer197" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter aims to acquaint you with the fundamentals of JavaScript Object Notation (JSON). You will learn how to use Go to parse JSON, and then gain the ability to convert JSON to a struct and back to JSON.</p>
			<p class="callout">Here, you will learn to describe JSON and unmarshal JSON to a struct. You will also learn to marshal a struct to JSON and set the JSON key name to something different than the struct field name. By the end of the chapter, you will be able to use various JSON tag attributes to control what gets converted to JSON, unmarshal an unknown JSON structure, and use encoding for data transmission.</p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor298"/>Introduction</h1>
			<p>In the previous chapter, we looked at errors in Go and discovered that, in Go, errors are values, which allows us to pass errors around as arguments to functions and methods. We also saw that Go functions can return multiple values, one of which is often an error. We learned that a good practice is to check for the value of an error returned by a function. By not ignoring the error, it prevents unexpected behavior in our program. In Go, we saw that you can create your own custom error types. Finally, we looked at panics and learned how to recover from them.</p>
			<p>In this chapter, we will be working with JSON by using only the standard library of Go. Before we start looking at using JSON in Go code, let's have a brief introduction to JSON.</p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor299"/>JSON</h1>
			<p><strong class="bold">JSON</strong> stands for <strong class="bold">JavaScript Object Notation</strong>. It is widely used in many programming languages for transferring and storing data. Often, this is done by transferring data from a web server to a client. JSON is transferred in web applications and is even used to store data in a file for later processing. We will look at various examples of where this is done in this chapter. JSON is minimal; it is not as verbose as XML. It is self-describing; this increases its readability and the ease of writing it. JSON is a text format that is language-independent:</p>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="image/B14177_11_01.jpg" alt="Figure 11.1: Describing JSON&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1: Describing JSON</p>
			<p>JSON is widely used as a data format for exchanging data between web applications and for various server-to-server communications. A common API that is used in applications is the REST API. JSON is frequently used in applications that utilize the REST API. One of the reasons that JSON is used in the REST API instead of XML is because it is less verbose than XML, more lightweight, and easier to read. Looking at the following JSON and XML, respectively, we can see that JSON is less verbose, easier to read, and more lightweight:</p>
			<p class="source-code">{</p>
			<p class="source-code">"firstname":"Captain",</p>
			<p class="source-code">"lastname":"Marvel"</p>
			<p class="source-code">}</p>
			<p class="source-code">&lt;avenger&gt;</p>
			<p class="source-code">&lt;firstname&gt;Captain&lt;/firstname&gt;</p>
			<p class="source-code">&lt;lastname&gt;"Marvel"&lt;/lastname&gt;</p>
			<p class="source-code">&lt;/avenger&gt;</p>
			<p>Most modern databases also now store JSON as a data type in a field. Static web applications sometimes use JSON for rendering their web pages.</p>
			<p>The JSON format is very structured. The primary parts that make up the JSON format consists of a collection of key-value pairs, as shown in the following figure:</p>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="image/B14177_11_02.jpg" alt="Figure 11.2: JSON key-value pairs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2: JSON key-value pairs</p>
			<p>The key is always a string enclosed in quotation marks, whereas the value can encompass a multitude of data types. A key-value pair in JSON is a <strong class="source-inline">key</strong> name followed by a colon, followed by a <strong class="source-inline">value</strong>. If there are additional key-value pairs, they will be separated with a comma.</p>
			<p>In <em class="italic">Figure 11.2</em>, there are two key-value pairs. The <strong class="source-inline">firstname</strong> key and its value of <strong class="source-inline">Captain</strong> is one. The other set is <strong class="source-inline">lastname</strong> and <strong class="source-inline">Marvel</strong>.</p>
			<p>JSON can contain arrays. The values are within a set of brackets. In <em class="italic">Figure 11.3</em>, lines <em class="italic">3</em> and <em class="italic">4</em> are the values of the <strong class="source-inline">phonenumbers</strong> key:</p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/B14177_11_03.jpg" alt="Figure 11.3: JSON array&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3: JSON array</p>
			<p>Now that we've seen key-value pairs, let's look at JSON data types. The JSON object supports many different data types; the following diagram shows those data types:</p>
			<div>
				<div id="_idContainer179" class="IMG---Figure">
					<img src="image/B14177_11_04.jpg" alt="Figure 11.4: JSON data types&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4: JSON data types</p>
			<p>Here are a few examples:</p>
			<ul>
				<li>String:<p class="source-code">Example: {"firstname": "Captain"}</p></li>
				<li>Number: This can be a float or an integer:<p class="source-code">Example: {"age": 32}</p></li>
				<li>Array:<p class="source-code">Example: {"hobbies": ["Go", "Saving Earth", "Shield"]}</p></li>
				<li>Boolean: Can only be <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>:<p class="source-code">Example: {"ismarried": false}</p></li>
				<li>Null:<p class="source-code">Example: {"middlename": null}</p></li>
				<li>Object:<p>JSON objects are like structs in Go. The following example shows a Go struct and a JSON object:</p><p class="source-code">type person struct {</p><p class="source-code">  firstname string</p><p class="source-code">  middlename string</p><p class="source-code">  lastname string</p><p class="source-code">  age int</p><p class="source-code">  ismarried bool</p><p class="source-code">  hobbies []string</p><p class="source-code">}</p><p class="source-code">{</p><p class="source-code">  "person": {</p><p class="source-code">    "firstname": "Captain",</p><p class="source-code">    "middlename": null,</p><p class="source-code">    "lastname": "Marvel",</p><p class="source-code">    "age": 32,</p><p class="source-code">    "ismarried": false,</p><p class="source-code">    "hobbies": ["Go", "Saving Earth", "Shield"]</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ul>
			<p>In this section, we provided a brief introduction to JSON. In the following sections, we will look at how Go can decode and encode JSON.</p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor300"/>Decoding JSON</h1>
			<p>When we talk about decoding JSON, what we are stating is that we are taking a JSON data structure and converting it into a Go data structure. Converting the JSON into a Go data structure gives us the benefit of working with the data natively. For example, if the JSON data has a field that is an array in Go, that would get decoded to a slice. We will then be able to treat that slice as we would any other slice, meaning we can iterate over the slice using a <strong class="source-inline">range</strong> clause, we can get the length of the slice, append to the slice, and so on.</p>
			<p>If we know what our JSON looks like ahead of time, we can use structs when parsing the JSON. Using Go terms, we need to be able to <strong class="source-inline">unmarshal</strong> the JSON-encoded data and store the results in the struct. To be able to do this, we will need to import the <strong class="source-inline">encoding/json</strong> package. We will be using the JSON <strong class="source-inline">Unmarshal</strong> function. Unmarshaling is the process of parsing JSON to a data structure. Often, you will hear unmarshaling and decoding used interchangeably:</p>
			<p class="source-code">func Unmarshal(data []byte, v interface{}) error</p>
			<p>In the preceding code, the variable data is defined as a slice of bytes. The <strong class="source-inline">v</strong> variable is a pointer to a struct. The <strong class="source-inline">Unmarshal</strong> function takes the slice of bytes of JSON data and stores the results in the value pointed to by <strong class="source-inline">v</strong>.</p>
			<p>The argument for <strong class="source-inline">v</strong> must be a pointer and must not be <strong class="source-inline">nil</strong>. If either of those requirements are not met, then an error will be returned as follows:</p>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="image/B14177_11_05.jpg" alt="Figure 11.5: Unmarshal error for a non-pointer passed as an argument&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5: Unmarshal error for a non-pointer passed as an argument</p>
			<p>Let's look at the following code as a simple example of unmarshaling data. We will describe each portion of the code in detail to get a better understanding of the program:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "encoding/json"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">type greeting struct {</p>
			<p class="source-code">  Message string </p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  data := []byte(`</p>
			<p class="source-code">  {</p>
			<p class="source-code">  "message": "Greetings fellow gopher!"</p>
			<p class="source-code">  }</p>
			<p class="source-code">`)</p>
			<p class="source-code">  var v greeting</p>
			<p class="source-code">  err := json.Unmarshal(data, &amp;v)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    fmt.Println(err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Println(v.Message)</p>
			<p class="source-code">}</p>
			<p>Let's break down the code for better understanding:</p>
			<p class="source-code">type greeting struct {</p>
			<p class="source-code">  Message string </p>
			<p class="source-code">}</p>
			<p>The greeting struct has an exportable field called <strong class="source-inline">Message</strong> of the <strong class="source-inline">string</strong> type:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  data := []byte(`</p>
			<p class="source-code">  {</p>
			<p class="source-code">  "message": "Greetings fellow gopher!"</p>
			<p class="source-code">  }</p>
			<p class="source-code">`)</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">`</strong> symbol is a backtick and not a single quote. It is used for string literals.</p>
			<p>The <strong class="source-inline">json.Unmarshal</strong> struct requires that the JSON encoded data must be a byte of slices:</p>
			<p class="source-code">var g greeting</p>
			<p>We are declaring <strong class="source-inline">g</strong> to be of the greeting type:</p>
			<p class="source-code">  err := json.Unmarshal(data, &amp;v)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    fmt.Println(err)</p>
			<p class="source-code">  }</p>
			<p>The <strong class="source-inline">Unmarshal()</strong> function takes the slice of bytes of JSON data and stores the results in the value pointed to by <strong class="source-inline">v</strong>.</p>
			<p>The <strong class="source-inline">v</strong> variable is pointing to our greeting struct.</p>
			<p>It unmarshals the JSON to a greeting instance, as depicted in the following diagram:</p>
			<div>
				<div id="_idContainer181" class="IMG---Figure">
					<img src="image/B14177_11_06.jpg" alt="Figure 11.6: Unmarshaling JSON to a Go struct&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.6: Unmarshaling JSON to a Go struct</p>
			<p>Now, let's see the output after unmarshaling:</p>
			<p class="source-code">fmt.Println(v.Message)</p>
			<p>It should look as follows:</p>
			<p class="source-code">Greetings fellow gopher!</p>
			<p>In our previous example, the JSON marshaler matched our field name, <strong class="source-inline">Message</strong>, to the JSON key, <strong class="source-inline">message</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To be able to unmarshal into a struct, the struct field must be exportable. The struct's field name must be capitalized. Only fields that are exportable are visible externally, including the JSON unmarshaler. Only the exported fields will be in the JSON output; other fields are ignored.</p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor301"/>Struct Tags</h2>
			<p>We can use struct tags to provide transformation information on how the struct field is unmarshaled or marshaled. Tags follow the format of <strong class="source-inline">`key:</strong> <strong class="source-inline">"value"`</strong>. The tag begins and ends with a backtick (<strong class="source-inline">`</strong>).</p>
			<p>Consider the following example:</p>
			<p class="source-code">type person struct {</p>
			<p class="source-code">  LastName string `json:"lname"`</p>
			<p class="source-code">}</p>
			<p>Using tags gives us more control. We can now name our struct field name anything as long as it is exportable.</p>
			<p>The <strong class="source-inline">json</strong> field that will be unmarshaled in this example is <strong class="source-inline">lname</strong>.</p>
			<p>Once you use tags for JSON unmarshaling and marshaling, it will not compile if the struct field is not exportable. The Go compiler is smart enough to realize that since there is a JSON tag associated with the struct field, it must be exportable to be used in the JSON marshaling and unmarshaling process. See the following example of the error you will get when <strong class="source-inline">lastname</strong> is lowercase:</p>
			<p class="source-code">type person struct {</p>
			<p class="source-code">  lastName string `json:"lname"`</p>
			<p class="source-code">}</p>
			<p>This is the error message for unexported JSON struct fields:</p>
			<div>
				<div id="_idContainer182" class="IMG---Figure">
					<img src="image/B14177_11_07.jpg" alt="Figure 11.7: Error for unexported JSON struct fields&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.7: Error for unexported JSON struct fields</p>
			<p>We have already seen this code before and we know how to unmarshal JSON. However, there is one small change that we will be making, and that is adding a <strong class="source-inline">struct</strong> tag to our code:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "encoding/json"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">type greeting struct {</p>
			<p class="source-code">  SomeMessage string `json:"message"`</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  data := []byte(`</p>
			<p class="source-code">  {</p>
			<p class="source-code">  "message": "Greetings fellow gopher!"</p>
			<p class="source-code">  }</p>
			<p class="source-code">`)</p>
			<p class="source-code">  var g greeting</p>
			<p class="source-code">  err := json.Unmarshal(data, &amp;g)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    fmt.Println(err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Println(g.SomeMessage)</p>
			<p class="source-code">}</p>
			<p>Let's break down the code for better understanding:</p>
			<p class="source-code">type greeting struct {</p>
			<p class="source-code">  SomeMessage string `json:"message"`</p>
			<p class="source-code">}</p>
			<p>We changed our <strong class="source-inline">greeting</strong> struct to use a different exportable field name than what is in JSON.</p>
			<p>The <strong class="source-inline">`json:"message"`</strong> tag states that this exportable field corresponds to the <strong class="source-inline">message</strong> key in the JSON data:</p>
			<p class="source-code">err := json.Unmarshal(data, &amp;g)</p>
			<p>When the data gets unmarshaled, the JSON message value will be placed in the <strong class="source-inline">SomeMessage</strong> struct field.</p>
			<p>We will get the following output:</p>
			<p class="source-code">Greetings fellow gopher!</p>
			<p>The Go JSON <strong class="source-inline">unmarshaller</strong> follows a process of determining which struct field to map the JSON data when decoding it:</p>
			<ul>
				<li>An exported field with a tag.</li>
				<li>An exported field name whose case matches the JSON key name.</li>
				<li>An exported field name with a case-insensitive match.</li>
				<li>We could also verify whether the JSON that we are going to unmarshal is valid.</li>
			</ul>
			<p>The following is the code to perform the unmarshaling:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "encoding/json"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "os"</p>
			<p class="source-code">)</p>
			<p class="source-code">type greeting struct {</p>
			<p class="source-code">  SomeMessage string `json:"message"`</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  data := []byte(`</p>
			<p class="source-code">  {</p>
			<p class="source-code">  message": "Greetings fellow gopher!"</p>
			<p class="source-code">  }</p>
			<p class="source-code">`)</p>
			<p class="source-code">  if !json.Valid(data) {</p>
			<p class="source-code">    fmt.Printf("JSON is not valid: %s", data)</p>
			<p class="source-code">    os.Exit(1)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  //Code to perform the unmarshal</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">Valid()</strong> function takes as an argument slice of bytes and will return a Bool that indicates whether the JSON is valid. It will display <strong class="source-inline">True</strong> for valid JSON and <strong class="source-inline">False</strong> for invalid JSON.</p>
			<p>This can be useful for checking our JSON before we try to unmarshal it into a struct.</p>
			<p>What structs do you think you would need for the following JSON? Let's take a look.</p>
			<p class="source-code">{</p>
			<p class="source-code">"lname": "Smith",</p>
			<p class="source-code">  "fname": "John",</p>
			<p class="source-code">  "address": {</p>
			<p class="source-code">    "street": "Sulphur Springs Rd",</p>
			<p class="source-code">      "city": "Park City",</p>
			<p class="source-code">      "state": "VA",</p>
			<p class="source-code">      "zipcode": 12345</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The preceding JSON has an embedded object called <strong class="source-inline">address</strong>. As you may recall from the introduction of this chapter, objects are one of the types that JSON supports. The Go representation of an object type in JSON is structs. Our <strong class="source-inline">parent</strong> struct would need to have an embedded struct called <strong class="source-inline">address</strong>.</p>
			<p>The following code snippet is an example of unmarshaling more than one JSON object into Go structs:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "encoding/json"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">type person struct {</p>
			<p class="source-code">  Lastname  string  `json:"lname"`</p>
			<p class="source-code">  Firstname string  `json:"fname"`</p>
			<p class="source-code">  Address   address `json:"address"`</p>
			<p class="source-code">}</p>
			<p class="source-code">type address struct {</p>
			<p class="source-code">  Street  string `json:"street"`</p>
			<p class="source-code">  City    string `json:"city"`</p>
			<p class="source-code">  State   string `json:"state"`</p>
			<p class="source-code">  ZipCode int    `json:"zipcode"`</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  data := []byte(`</p>
			<p class="source-code">      {</p>
			<p class="source-code">      "lname": "Smith",</p>
			<p class="source-code">      "fname": "John",</p>
			<p class="source-code">      "address": {</p>
			<p class="source-code">        "street": "Sulphur Springs Rd",</p>
			<p class="source-code">        "city": "Park City",</p>
			<p class="source-code">        "state": "VA",</p>
			<p class="source-code">        "zipcode": 12345</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  `)</p>
			<p class="source-code">  var p person</p>
			<p class="source-code">  err := json.Unmarshal(data, &amp;p)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    fmt.Println(err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Printf("%+v",p)</p>
			<p class="source-code">}</p>
			<p>Let's break the code down for better understanding:</p>
			<p class="source-code">type person struct {</p>
			<p class="source-code">  Lastname  string  `json:"lname"`</p>
			<p class="source-code">  Firstname string  `json:"fname"`</p>
			<p class="source-code">  Address   address `json:"address"`</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">person</strong> struct has an embedded struct called <strong class="source-inline">Address</strong>. It is represented in the JSON as an object called <strong class="source-inline">address</strong>. The fields in the <strong class="source-inline">address</strong> struct will have the JSON values unmarshaled to them:</p>
			<p class="source-code">  data := []byte(`</p>
			<p class="source-code">      {</p>
			<p class="source-code">      "lname": "Smith",</p>
			<p class="source-code">      "fname": "John",</p>
			<p class="source-code">      "address": {</p>
			<p class="source-code">        "street": "Sulphur Springs Rd",</p>
			<p class="source-code">        "city": "Park City",</p>
			<p class="source-code">        "state": "VA",</p>
			<p class="source-code">        "zipcode": 12345</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  `)</p>
			<p>The <strong class="source-inline">address</strong> in JSON is an object that will get unmarshaled into our <strong class="source-inline">person struct's address</strong> field:</p>
			<div>
				<div id="_idContainer183" class="IMG---Figure">
					<img src="image/B14177_11_08.jpg" alt="Figure 11.8: Unmarshaled JSON address to person.address&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.8: Unmarshaled JSON address to person.address</p>
			<p>The <strong class="source-inline">Unmarshal()</strong> function decodes the JSON-encoded <strong class="source-inline">data</strong> into the pointer <strong class="source-inline">p</strong>:</p>
			<p class="source-code">var p person</p>
			<p class="source-code">  err := json.Unmarshal(data, &amp;p)</p>
			<p>The results are as follows:</p>
			<div>
				<div id="_idContainer184" class="IMG---Figure">
					<img src="image/B14177_11_09.jpg" alt="Figure 11.9: The person struct after decoding JSON&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.9: The person struct after decoding JSON</p>
			<p>We will be using these concepts that we have learned thus far in the next exercise.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor302"/>Exercise 11.01: Unmarshaling Student Courses</h2>
			<p>In this exercise, we will be writing a program that takes a JSON from a web request for college class enrollment. Our program needs to unmarshal the JSON data into a Go struct. The JSON will contain data about a student and the courses that they are taking. After we have unmarshaled the JSON, we will print the struct for verification purposes. The output should be as follows:</p>
			<div>
				<div id="_idContainer185" class="IMG---Figure">
					<img src="image/B14177_11_10.jpg" alt="Figure 11.10: Printing the student courses struct&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.10: Printing the student courses struct</p>
			<p>All directories and files created need to be created within your <strong class="source-inline">$GOPATH</strong>:</p>
			<ol>
				<li>Create a directory called <strong class="source-inline">Exercise11.01</strong> within a directory called <strong class="source-inline">Chapter11</strong>.</li>
				<li>Create a file called <strong class="source-inline">main.go</strong> inside of <strong class="source-inline">Chapter11/Exercise11.01</strong>.</li>
				<li>Using Visual Studio Code, open the newly created <strong class="source-inline">main.go</strong> file.</li>
				<li>Add the following package name and import statements:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "encoding/json"</p><p class="source-code">  "fmt"</p><p class="source-code">)</p></li>
				<li>We will need to create a <strong class="source-inline">student</strong> struct. The <strong class="source-inline">student</strong> struct will need for all its fields to be exported so that we can unmarshal the JSON data to them. Each struct field will need to have a JSON tag that will be the name of the JSON data fields:<p class="source-code">type student struct {</p><p class="source-code">  StudentId     int      `json:"id"`</p><p class="source-code">  LastName      string   `json:"lname"`</p><p class="source-code">  MiddleInitial string   `json:"minitial"`</p><p class="source-code">  FirstName     string   `json:"fname"`</p><p class="source-code">  IsEnrolled    bool     `json:"enrolled"`</p><p class="source-code">  Courses       []course `json:"classes"`</p><p class="source-code">}</p></li>
				<li>We will need to create a <strong class="source-inline">course</strong> struct. The <strong class="source-inline">course</strong> struct will need all its fields to be exported so that we can unmarshal the JSON data to them. Each struct field will need to have a JSON tag that will be the name of the JSON data fields:<p class="source-code">type course struct {</p><p class="source-code">  Name   string `json:"coursename"`</p><p class="source-code">  Number int    `json:"coursenum"`</p><p class="source-code">  Hours  int    `json:"coursehours"`</p><p class="source-code">}</p></li>
				<li>Add a <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p><p class="source-code">  }</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, add the JSON data that we will be unmarshaling into our structs (<strong class="source-inline">student</strong> and <strong class="source-inline">course</strong>):<p class="source-code">  data := []byte(`</p><p class="source-code">    {</p><p class="source-code">      "id": 123,</p><p class="source-code">      "lname": "Smith",</p><p class="source-code">      "minitial": null,</p><p class="source-code">      "fname": "John",</p><p class="source-code">      "enrolled": true,</p><p class="source-code">      "classes": [{</p><p class="source-code">        "coursename": "Intro to Golang",</p><p class="source-code">        "coursenum": 101,</p><p class="source-code">        "coursehours": 4</p><p class="source-code">      },</p><p class="source-code">    {</p><p class="source-code">        "coursename": "English Lit",</p><p class="source-code">        "coursenum": 101,</p><p class="source-code">        "coursehours": 3</p><p class="source-code">      },</p><p class="source-code">    {</p><p class="source-code">        "coursename": "World History",</p><p class="source-code">        "coursenum": 101,</p><p class="source-code">        "coursehours": 3</p><p class="source-code">      }</p><p class="source-code">  ]</p><p class="source-code">    }</p><p class="source-code">  `)</p></li>
				<li>Declare a variable of the <strong class="source-inline">student</strong> type:<p class="source-code">  var s student</p></li>
				<li>Next, we will unmarshal the JSON into our <strong class="source-inline">student</strong> struct. We will also handle any errors that get returned from the <strong class="source-inline">json.Unmarshal()</strong> method:<p class="source-code">  err := json.Unmarshal(data, &amp;s)</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">  }</p></li>
				<li>We will print the <strong class="source-inline">student</strong> struct so that we can see that all the data from the JSON is present:<p class="source-code">  fmt.Println(s)</p><p class="source-code">}</p></li>
				<li>Build the program by running <strong class="source-inline">go build</strong> in the command line:<p class="source-code">go build</p><p>Correct any errors that are returned and ensure your code matches the code snippet here.</p></li>
				<li>Run the executable by typing in the name of the executable and then hit <em class="italic">Enter</em> to run it.<p>The output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer186" class="IMG---Figure">
					<img src="image/B14177_11_10.jpg" alt="Figure 11.11: Printing the student courses struct&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.11: Printing the student courses struct</p>
			<p>This exercise demonstrated how to unmarshal JSON data into a Go struct successfully.</p>
			<h1 id="_idParaDest-287"><a id="_idTextAnchor303"/>Encoding JSON</h1>
			<p>We have studied how to unmarshal JSON into a struct. We will now do the opposite: marshal a struct into JSON. When we talk about encoding JSON, what we mean is we are taking a Go struct and converting it to a JSON data structure. The typical scenario in which this is done is when you have a service that is responding to an HTTP request from a client. The client wants the data in a certain format, and this is frequently JSON. Another situation is that the data is stored in a NoSQL database and it requires JSON as the format, or even a traditional database that has a column with a data type of JSON.</p>
			<p>We need to be able to <strong class="source-inline">Marshal</strong> the Go struct into a JSON-encoded structure. To be able to do this, we will need to import the <strong class="source-inline">encoding/json</strong> package. We will be using the <strong class="source-inline">json.Marshal</strong> function:</p>
			<p class="source-code">func Marshal(v interface{}) ([]byte, error)</p>
			<p>The <strong class="source-inline">v</strong> becomes encoded as JSON. Typically, <strong class="source-inline">v</strong> is a <strong class="source-inline">struct</strong>. The <strong class="source-inline">Marshal()</strong> function returns the JSON encoding as a slice of bytes and an error. It is always a good idea to check whether there was an error during the process of encoding <strong class="source-inline">v</strong>. Let's look at a simple example to further explain the marshaling of Go structs to JSON:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "encoding/json"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">type greeting struct {</p>
			<p class="source-code">  SomeMessage string</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  var v greeting</p>
			<p class="source-code">  v.SomeMessage = "Marshal me!"</p>
			<p class="source-code">  json, err := json.Marshal(v)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    fmt.Println(err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Printf("%s",json)</p>
			<p class="source-code">}</p>
			<p>Let's break down the code for better understanding:</p>
			<p class="source-code">type greeting struct {</p>
			<p class="source-code">  SomeMessage string</p>
			<p class="source-code">}</p>
			<p>We have a struct with one exportable field. Notice there are no JSON tags. You should be able to guess what the field will be in the JSON data:</p>
			<p class="source-code">json, err := json.Marshal(v)</p>
			<p>The following diagram shows how the <strong class="source-inline">greeting</strong> struct gets marshaled into JSON using the <strong class="source-inline">json.Marshal</strong> method. The <strong class="source-inline">v</strong> interface argument in the <strong class="source-inline">marshal</strong> method is the <strong class="source-inline">greeting</strong> struct. The <strong class="source-inline">marshal</strong> method will encode the <strong class="source-inline">greeting</strong> field, <strong class="source-inline">SomeMessage</strong>, into JSON. The following diagram shows the process:</p>
			<div>
				<div id="_idContainer187" class="IMG---Figure">
					<img src="image/B14177_11_12.jpg" alt="Figure 11.12: Marshaling a Go struct to JSON&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.12: Marshaling a Go struct to JSON</p>
			<p>When we call the <strong class="source-inline">Marshal</strong> function, we are passing it a struct. The function will return back an error and the JSON encoding of <strong class="source-inline">g</strong>.</p>
			<p>The results of the print statement are as follows:</p>
			<p class="source-code">{"SomeMessage":"Marshal me!"}</p>
			<p>Since we did not provide the JSON tag for the struct greeting, <strong class="source-inline">SomeMessage</strong>, the Go <strong class="source-inline">Marshal</strong> encodes the exportable fields and its values. The Go <strong class="source-inline">Marshal</strong> uses the name of the field, <strong class="source-inline">SomeMessage</strong> ,as the name of the <strong class="source-inline">key</strong> field in the JSON data.</p>
			<p>The following code produces a result that is not desirable. Examine the following code and notice the result of struct fields that are not set. Pay close attention to the fields that are not being set in the <strong class="source-inline">main()</strong> function.</p>
			<p>Consider the following example:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "encoding/json"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">type book struct {</p>
			<p class="source-code">  ISBN          string `json:"isbn"`</p>
			<p class="source-code">  Title         string `json:"title"`</p>
			<p class="source-code">  YearPublished int    `json:"yearpub"`</p>
			<p class="source-code">  Author        string `json:"author"`</p>
			<p class="source-code">  CoAuthor      string `json:"coauthor"`</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  var b book</p>
			<p class="source-code">  b.ISBN = "9933HIST"</p>
			<p class="source-code">  b.Title = "Greatest of all Books"</p>
			<p class="source-code">  b.Author = "John Adams"</p>
			<p class="source-code">  json, err := json.Marshal(b)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    fmt.Println(err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Printf("%s", json)</p>
			<p class="source-code">} </p>
			<p>Marshaling struct data when the field value is not set gives you the following output:</p>
			<p class="source-code">{"isbn":"9933HIST","title":"Greatest of all Books","yearpub":0,"author":"John   Adams","coauthor":""}</p>
			<p>There are times that we might not want our struct fields to be marshaled to JSON when the fields are not set. Our <strong class="source-inline">CoAuthor</strong> field and <strong class="source-inline">YearPublished</strong> were not set, and thus the JSON values were an empty string and zero, respectively. There is a JSON tag attribute that we can utilize called <strong class="source-inline">omitempty</strong>. It will omit the struct field from the JSON if it is empty:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "encoding/json"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">type book struct {</p>
			<p class="source-code">  ISBN          string `json:"isbn"`</p>
			<p class="source-code">  Title         string `json:"title"`</p>
			<p class="source-code">  YearPublished int    `json:"yearpub,omitempty"`</p>
			<p class="source-code">  Author        string `json:"author"`</p>
			<p class="source-code">  CoAuthor      string `json:"coauthor,omitempty"`</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  var b book</p>
			<p class="source-code">  b.ISBN = "9933HIST"</p>
			<p class="source-code">  b.Title = "Greatest of all Books"</p>
			<p class="source-code">  b.Author = "John Adams"</p>
			<p class="source-code">  json, err := json.Marshal(b)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    fmt.Println(err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Printf("%s", json)</p>
			<p class="source-code">}</p>
			<p>Let's break down the code for better understanding:</p>
			<p class="source-code">  YearPublished int    `json:"yearpub,omitempty"`</p>
			<p class="source-code">  CoAuthor      string `json:"coauthor,omitempty"`</p>
			<p>The two <strong class="source-inline">book</strong> fields' JSON tags use the <strong class="source-inline">omitempty</strong> attribute. If these fields are not set, they will not appear in the JSON. The result is as follows:</p>
			<p class="source-code">{"isbn":"9933HIST","title":"Greatest of all Books","author":"John Adams"}</p>
			<p>When using the JSON tags, you will need to be careful not to have any spaces in the values. Using our previous example, let's change our <strong class="source-inline">YearPublished</strong> JSON tag to this:</p>
			<p class="source-code">YearPublished int    `json:"yearpub, omitempty"`</p>
			<p>Notice the space between the comma and <strong class="source-inline">omitempty</strong>. This would result in the following error if you use <strong class="source-inline">go vet</strong>:</p>
			<div>
				<div id="_idContainer188" class="IMG---Figure">
					<img src="image/B14177_11_13.jpg" alt="Figure 11.13: Go vet error&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.13: Go vet error</p>
			<p>Another thing to keep in mind is that if you do not properly handle errors, you will get some erroneous results:</p>
			<p class="source-code">{"isbn":"9933HIST","title":"Greatest of all Books","yearpub":0,"author":"John </p>
			<p class="source-code">  Adams"}</p>
			<p>Even though the <strong class="source-inline">json.Marshal(b)</strong> function errored, it still marshaled the struct to JSON. The <strong class="source-inline">yearpub</strong> value was set to zero. That is one of the reasons it is important to handle our errors.</p>
			<p>There are other JSON tags that we will look at briefly in the following example:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "encoding/json"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">type book struct {</p>
			<p class="source-code">  ISBN          string `json:"isbn"`</p>
			<p class="source-code">  Title         string `json:"title"`</p>
			<p class="source-code">  YearPublished int    `json:",omitempty"`</p>
			<p class="source-code">  Author        string `json:",omitempty"`</p>
			<p class="source-code">  CoAuthor      string `json:"-"`</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  var b book</p>
			<p class="source-code">  b.ISBN = "9933HIST"</p>
			<p class="source-code">  b.Title = "Greatest of all Books"</p>
			<p class="source-code">  b.Author = "John Adams"</p>
			<p class="source-code">  b.CoAuthor ="Can't see me"</p>
			<p class="source-code">  json, err := json.Marshal(b)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    fmt.Println(err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Printf("%s", json)</p>
			<p class="source-code">}</p>
			<p>Let's break down the code for better understanding:</p>
			<p class="source-code">  YearPublished int    `json:",omitempty"`</p>
			<p class="source-code">  Author        string `json:",omitempty"`</p>
			<ul>
				<li>In the above code,<strong class="source-inline"> `json:",omitempty"`</strong> does not have a value for a field. Notice the JSON tag value starts with a comma.</li>
				<li><strong class="source-inline">`json:",omitempty"`</strong> will have the field in the JSON if there is a value for the key. If <strong class="source-inline">Author</strong> has a value set, it will appear in the JSON as the <strong class="source-inline">"Author" :"somevalue"</strong> key:<p class="source-code">CoAuthor      string `json:"-"`</p></li>
				<li>The dash is used to ignore the field. The field will not be marshaled to JSON.</li>
			</ul>
			<p>The result is as follows:</p>
			<p class="source-code">{"isbn":"9933HIST","title":"Greatest of all Books","Author":"John Adams"}</p>
			<p>The following diagram summarizes the different JSON tag attributes that we have used with our structs when we marshal the struct to JSON:</p>
			<div>
				<div id="_idContainer189" class="IMG---Figure">
					<img src="image/B14177_11_14.jpg" alt="Figure 11.14: JSON tag field descriptions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.14: JSON tag field descriptions</p>
			<p>Having the JSON output as a one-liner is not very readable, especially when you start working with larger JSON structures. The Go JSON package provides a way to format the JSON output. The <strong class="source-inline">MarshalIndent()</strong> function provides the same functionality as the <strong class="source-inline">Marshal</strong> function. In addition to encoding JSON, the <strong class="source-inline">MarshalIndent()</strong> function can format the JSON make it easy to read. This is often referred to as "pretty printing." The following code shows an example code for the <strong class="source-inline">MarshalIndent()</strong> function:</p>
			<p class="source-code">func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)</p>
			<p>We will not be using a prefix in our examples. It just applies a string before our indent string. Each element will begin on a new line:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "encoding/json"</p>
			<p class="source-code">  "fmt" </p>
			<p class="source-code">  "os"</p>
			<p class="source-code">)</p>
			<p class="source-code">type person struct {</p>
			<p class="source-code">  LastName  string  `json:"lname"`</p>
			<p class="source-code">  FirstName string  `json:"fname"`</p>
			<p class="source-code">  Address   address `json:"address"`</p>
			<p class="source-code">}</p>
			<p class="source-code">type address struct {</p>
			<p class="source-code">  Street  string `json:"street"`</p>
			<p class="source-code">  City    string `json:"city"`</p>
			<p class="source-code">  State   string `json:"state"`</p>
			<p class="source-code">  ZipCode int    `json:"zipcode"`</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  p := person{LastName: "Vader", FirstName: "Darth"} </p>
			<p class="source-code">  p.Address.Street = "Galaxy Far Away" </p>
			<p class="source-code">  p.Address.City= "Dark Side"</p>
			<p class="source-code">  p.Address.State= "Tatooine"</p>
			<p class="source-code">  p.Address.ZipCode =12345</p>
			<p class="source-code">  noPrettyPrint, err := json.Marshal(p)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    fmt.Println(err)</p>
			<p class="source-code">    os.Exit(1)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  prettyPrint, err := json.MarshalIndent(p, "", "    ")</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    fmt.Println(err)</p>
			<p class="source-code">    os.Exit(1)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Println(string(noPrettyPrint))</p>
			<p class="source-code">  fmt.Println()</p>
			<p class="source-code">  fmt.Println(string(prettyPrint))</p>
			<p class="source-code">}</p>
			<p>Let's break down the code for better understanding:</p>
			<p class="source-code">type person struct {</p>
			<p class="source-code">  LastName  string  `json:"lname"`</p>
			<p class="source-code">  FirstName string  `json:"fname"`</p>
			<p class="source-code">  Address   address `json:"address"`</p>
			<p class="source-code">}</p>
			<p class="source-code">type address struct {</p>
			<p class="source-code">  Street  string `json:"street"`</p>
			<p class="source-code">  City    string `json:"city"`</p>
			<p class="source-code">  State   string `json:"state"`</p>
			<p class="source-code">  ZipCode int    `json:"zipcode"`</p>
			<p class="source-code">}</p>
			<p>We have two structs: a <strong class="source-inline">person</strong> struct and an <strong class="source-inline">address</strong> struct. The <strong class="source-inline">address</strong> struct is embedded inside the <strong class="source-inline">person</strong> struct. Both structs have the JSON key names defined in the JSON tags. The <strong class="source-inline">address</strong> struct will be a separate object inside the JSON:</p>
			<p class="source-code">  p := person{LastName: "Vader", FirstName: "Darth"} </p>
			<p class="source-code">  p.Address.Street = "Galaxy Far Away" </p>
			<p class="source-code">  p.Address.City= "Dark Side"</p>
			<p class="source-code">  p.Address.State= "Tatooine"</p>
			<p class="source-code">  p.Address.ZipCode =12345</p>
			<p>We initialize the <strong class="source-inline">person</strong> struct and set the values for the <strong class="source-inline">person.Address</strong> fields. Every field has a value set, so there will be no empty strings or zero values set in our JSON:</p>
			<p class="source-code">  noPrettyPrint, err := json.Marshal(p)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    fmt.Println(err)</p>
			<p class="source-code">    os.Exit(1)</p>
			<p class="source-code">  }</p>
			<p>The <strong class="source-inline">noPrettyPrint</strong> variable is the JSON encoding of <strong class="source-inline">p</strong>.</p>
			<p>We, of course, check for any errors returned from the <strong class="source-inline">json.Marshal()</strong> function:</p>
			<p class="source-code">  prettyPrint, err := json.MarshalIndent(p, "", "    ")</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    fmt.Println(err)</p>
			<p class="source-code">    os.Exit(1)</p>
			<p class="source-code">  }</p>
			<p>The <strong class="source-inline">prettyPrint</strong> variable is the JSON encoding of <strong class="source-inline">p</strong>, by using <strong class="source-inline">json.MarshalIndent()</strong>. We set the prefix argument to an empty string and the indent argument to four spaces.</p>
			<p>As with the <strong class="source-inline">json.Marshal()</strong> function, we also check for any errors returned from the <strong class="source-inline">json.MarshalIndent()</strong> function. We can see these various steps using the <strong class="source-inline">json.MarshalIndent()</strong> method depicted in the following diagram:</p>
			<div>
				<div id="_idContainer190" class="IMG---Figure">
					<img src="image/B14177_11_15.jpg" alt="Figure 11.15: The json.MarshalIndent() method&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.15: The json.MarshalIndent() method</p>
			<p>We then print the results of the JSON encoding using the <strong class="source-inline">json.Marshal()</strong> function:</p>
			<p class="source-code">fmt.Println(string(noPrettyPrint))</p>
			<p>As you can see, the readability of the JSON is slightly challenging.</p>
			<p>JSON marshaling without <strong class="source-inline">MarshalIndent</strong> looks as follows:</p>
			<p class="source-code">{"lname":"Vader","fname":"Darth","address":{"street":"Galaxy Far   Away","city":"Dark Side","state":"Tatooine","zipcode":12345}}</p>
			<p>We also print the results of the JSON encoding using the <strong class="source-inline">json.MarshalIndent()</strong> function:</p>
			<p class="source-code">fmt.Println(string(prettyPrint))</p>
			<p>The results are less of a challenge to read using the <strong class="source-inline">json.MarshalIndent()</strong> function. You can clearly read the output more easily than the previous results that were printed:</p>
			<div>
				<div id="_idContainer191" class="IMG---Figure">
					<img src="image/B14177_11_16.jpg" alt="Figure 11.16: Using the MarshalIndent JSON result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.16: Using the MarshalIndent JSON result</p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor304"/>Exercise 11.02: Marshaling Student Courses</h2>
			<p>In this exercise, we are going to do the opposite to what we did in <em class="italic">Exercise 11.01</em>, <em class="italic">Unmarshaling Student Courses</em>. We will marshal from a struct into JSON. This is the previous struct:</p>
			<p class="source-code"> type student struct {</p>
			<p class="source-code">  StudentId     int      `json:"id"`</p>
			<p class="source-code">  LastName      string   `json:"lname"`</p>
			<p class="source-code">  MiddleInitial string   `json:"minitial"`</p>
			<p class="source-code">  FirstName     string   `json:"fname"`</p>
			<p class="source-code">  IsEnrolled    bool     `json:"enrolled"`</p>
			<p class="source-code">  Courses       []course `json:"classes"`</p>
			<p class="source-code">}</p>
			<p>We are going to make some changes to the JSON tags.</p>
			<p>All directories and files created need to be created within your <strong class="source-inline">$GOPATH</strong>:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">main.go</strong>.</li>
				<li>Add the following package name and import statements:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "encoding/json"</p><p class="source-code">  "fmt"</p><p class="source-code">  "os"</p><p class="source-code">)</p></li>
				<li>Create a <strong class="source-inline">student</strong> struct. All fields will be exportable. The following fields' JSON tags will need the following functionality when they get marshaled:<p><strong class="source-inline">MiddleInitial</strong> should be omitted if a value is not set; <strong class="source-inline">IsMarried</strong> should not appear in the JSON; and <strong class="source-inline">IsEnrolled</strong> should be the field name and omitted if not set:</p><p class="source-code">type student struct {</p><p class="source-code">  StudentId     int      `json:"id"`</p><p class="source-code">  LastName      string   `json:"lname"`</p><p class="source-code">  MiddleInitial string   `json:"mname,omitempty"`</p><p class="source-code">  FirstName     string   `json:"fname"`</p><p class="source-code">  IsMarried     bool   `json:"-"`</p><p class="source-code">  IsEnrolled    bool     `json:"enrolled,omitempty "`</p><p class="source-code">  Courses       []course `json:"classes"`</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">course</strong> struct:<p class="source-code">type course struct {</p><p class="source-code">  Name   string `json:"coursename"`</p><p class="source-code">  Number int    `json:"coursenum"`</p><p class="source-code">  Hours  int    `json:"coursehours"`</p><p class="source-code">}</p></li>
				<li>Create a function called <strong class="source-inline">newStudent()</strong>. This function will return a <strong class="source-inline">student</strong> struct:<p class="source-code">func newStudent(studentID int, lastName, middleInitial, firstName string,</p><p class="source-code">  isMarried, isEnrolled bool) student {</p><p class="source-code">  s := student{StudentId: studentID,</p><p class="source-code">    LastName:      lastName,</p><p class="source-code">    MiddleInitial: middleInitial,</p><p class="source-code">    FirstName:     firstName,</p><p class="source-code">    IsMarried:     isMarried,</p><p class="source-code">    IsEnrolled:    isEnrolled,</p><p class="source-code">  }</p><p class="source-code">  return s</p><p class="source-code">}</p></li>
				<li>Add the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, use the <strong class="source-inline">newStudent()</strong> function to create a <strong class="source-inline">student</strong> struct and assign the result of the function to a variable, <strong class="source-inline">s</strong>:<p class="source-code">  s := newStudent(1, "Williams", "s", "Felicia", false, false)</p></li>
				<li>Next, marshal <strong class="source-inline">s</strong> to JSON. We want the indenting of the JSON to be four spaces for each field for ease of readability:<p class="source-code">  student1, err := json.MarshalIndent(s, "", "<strong class="bold">    </strong>")</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>Print <strong class="source-inline">student1</strong>:<p class="source-code">  fmt.Println(string(student1))</p><p class="source-code">  fmt.Println()</p></li>
				<li>Create another <strong class="source-inline">student</strong> using the <strong class="source-inline">newStudent()</strong> function:<p class="source-code">  s2 := newStudent(2, "Washington", "", "Bill", true, true)</p></li>
				<li>We will now add various courses to <strong class="source-inline">s2</strong>:<p class="source-code">  c := course{Name: "World Lit", Number: 101, Hours: 3}</p><p class="source-code">  s2.Courses = append(s2.Courses, c)</p><p class="source-code">  c = course{Name: "Biology", Number: 201, Hours: 4}</p><p class="source-code">  s2.Courses = append(s2.Courses, c)</p><p class="source-code">  c = course{Name: "Intro to Go", Number: 101, Hours: 4}</p><p class="source-code">  s2.Courses = append(s2.Courses, c)</p></li>
				<li>Next, marshal <strong class="source-inline">s2</strong> to JSON. We want the indenting of the JSON to be four spaces for each field for ease of readability:<p class="source-code">  student2, err := json.MarshalIndent(s2, "", "<strong class="bold">    </strong>")</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>Print <strong class="source-inline">student2</strong>:<p class="source-code">  fmt.Println(string(student2))</p><p class="source-code">}</p><p>The result of the <strong class="source-inline">student1</strong> print statement is as follows:</p><p class="source-code">{</p><p class="source-code">    "id": 1,</p><p class="source-code">    "lname": "Williams",</p><p class="source-code">    "mname": "S",</p><p class="source-code">    "fname": "Felicia",</p><p class="source-code">    "classes": null</p><p class="source-code">}</p><p>The result of the <strong class="source-inline">student2</strong> print statement is as follows:</p><p class="source-code">{</p><p class="source-code">    "id": 2,</p><p class="source-code">    "lname": "Washington",</p><p class="source-code">    "Fname": "Bill",</p><p class="source-code">    "IsEnrolled": true,</p><p class="source-code">    "classes": [</p><p class="source-code">        {</p><p class="source-code">            "coursename": "World Lit",</p><p class="source-code">            "coursenum": 101,</p><p class="source-code">            "coursehours": 3</p><p class="source-code">        },</p><p class="source-code">        {</p><p class="source-code">            "coursename": "Biology",</p><p class="source-code">            "coursenum": 201,</p><p class="source-code">            "coursehours": 4</p><p class="source-code">        },</p><p class="source-code">        {</p><p class="source-code">            "coursename": "Intro to Go",</p><p class="source-code">            "coursenum": 101,</p><p class="source-code">            "coursehours": 4</p><p class="source-code">        }</p><p class="source-code">    ]</p><p class="source-code">}</p></li>
			</ol>
			<p>The aim of this exercise was to demonstrate how to encode JSON. We took a struct and encoded it into JSON. We were able to change the encoding to make it easier to read by indenting the fields. We also saw how to change some of the behavior of how fields are encoded to JSON. We saw that we can omit fields from getting encoded to JSON if the struct field does not have any data. We demonstrated that we can use JSON tags to name the fields in the JSON data differently than the field names in the struct. We also saw how we can even ignore fields in the struct so that they will not appear in the JSON when we marshal it.</p>
			<p>So far, we have dealt with knowing the structure of the JSON beforehand and that it is not changing. In the next section, we are going to discuss how to handle situations when you get a JSON structure, but that structure can change and is not stable.</p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor305"/>Unknown JSON Structures</h2>
			<p>When we know the JSON structure beforehand, it allows us the flexibility to design our structs to match the expected JSON. As we have seen, we can unmarshal our JSON values into the destination struct types. Go offers support for encoding (marshaling) and decoding (unmarshaling) to and from struct types.</p>
			<p>There are situations in which you may not know the JSON structure. For example, you may be interacting with a third-party tool that posts metrics for a streaming service. This metric is in the format of JSON; however, it is very dynamic and serves various customers. They frequently add new metrics for their various clients. You want to subscribe to this service and report on these various metrics. The problem is that the producer of these metrics changes the JSON data frequently. They change it so often, they do not provide the changes, and not on any prescribed schedule. You need to be able to perform the analysis on new metrics and old ones, and you cannot afford to take your service down to add the new fields from the JSON into your struct. You need the ability to continuously report on their metrics with minimal interruption to the service.</p>
			<p>If your JSON is dynamic, it will not work decoding it to a struct. So, what do you do when you do not know the JSON structure or when it changes frequently?</p>
			<p>In these cases, we can use <strong class="source-inline">map[string]interface{}</strong>. The keys of the JSON data will be the string key of the map. The <strong class="source-inline">empty interface{}</strong> will be the values of those JSON keys. Every type implements the empty interface:</p>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="image/B14177_11_17.jpg" alt="Figure 11.17: Mapping of JSON to a map data type&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.17: Mapping of JSON to a map data type</p>
			<p>The <strong class="source-inline">json.Unmarshal</strong> function will decode the unknown JSON structure into the map whose keys are strings and whose values will be empty interfaces. This works out well because JSON keys have to be strings.</p>
			<p>Consider the following example:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "encoding/json"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  jsonData := []byte(`{"checkNum":123,"amount":200,"category":["gift","clothing"]}`)</p>
			<p class="source-code">  var v interface{}</p>
			<p class="source-code">  json.Unmarshal(jsonData, &amp;v)</p>
			<p class="source-code">  fmt.Println(v)</p>
			<p class="source-code">}</p>
			<p>Let's break down the code for better understanding:</p>
			<p class="source-code">jsonData := []byte(`{"checkNum":123,"amount":200,"category":["gift","clothing"]}`)</p>
			<p><strong class="source-inline">jsonData</strong> represents the JSON that we are given but do not know the structure of:</p>
			<p class="source-code">  var v interface{}</p>
			<p class="source-code">  json.Unmarshal(jsonData, &amp;v)</p>
			<p>Even though we do not know the JSON structure, we can unmarshal it into an interface.</p>
			<p>The <strong class="source-inline">jsonData</strong> gets unmarshaled into <strong class="source-inline">v</strong>, the empty interface, which will be a map.</p>
			<p>The map keys are the strings and the values are empty interfaces. The result of printing out <strong class="source-inline">v</strong> is as follows:</p>
			<p class="source-code">map[amount:200 category:[gift clothing] checkNum: 123]</p>
			<p>The printing of <strong class="source-inline">map[string]interface{}</strong> does not match the order the data is stored. That is because maps are unordered, so their order is not guaranteed. </p>
			<p>The Go representation of <strong class="source-inline">v</strong> is as follows:</p>
			<p class="source-code">v = map[string]interface{}{</p>
			<p class="source-code">  "amount": 200,</p>
			<p class="source-code">  "category": []interface{}{</p>
			<p class="source-code">    "gift",</p>
			<p class="source-code">    "clothing",</p>
			<p class="source-code">  },</p>
			<p class="source-code">  "checkNum":  123,</p>
			<p class="source-code">}</p>
			<p>Remember the keys are strings and the values are interfaces. Even when there are slices in the JSON, the values become a slice of <strong class="source-inline">interfaces{}</strong>, represented as <strong class="source-inline">[]interface{}</strong>.</p>
			<p>We learned in the <em class="italic">Chapter 7</em>, <em class="italic">Interfaces</em>, that we have the ability to access the concrete types. We can do type assertion to access the underlying concrete type of <strong class="source-inline">map[string]interface{}</strong>. Let's look at another example where we have a variety of data types to work with.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor306"/>Exercise 11.03: Analyzing College Class JSON</h2>
			<p>In this exercise, we are going to analyze data from a college administration office and see whether we can replace the current college course grade submission application. The problem is that the old system's JSON data is not well documented. The data types in the JSON are not known, nor is the structure. In some instances, the JSON structure is different. We need to write a program that can analyze an unknown JSON structure and, for each field in the structure, print the data type and the JSON key-value pair.</p>
			<p>All directories and files created need to be created within your <strong class="source-inline">$GOPATH</strong>:</p>
			<ol>
				<li value="1">Create a directory called <strong class="source-inline">Exercise11.03</strong> within a directory called <strong class="source-inline">Chapter11</strong>.</li>
				<li>Create a file called <strong class="source-inline">main.go</strong> inside of <strong class="source-inline">Chapter11/Exercise11.03</strong>.</li>
				<li>Using Visual Studio Code, open the newly created <strong class="source-inline">main.go</strong> file.</li>
				<li>Add the following <strong class="source-inline">package</strong> name and <strong class="source-inline">import</strong> statements:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "encoding/json"</p><p class="source-code">  "fmt"</p><p class="source-code">  "os"</p><p class="source-code">)</p></li>
				<li>Create a <strong class="source-inline">main()</strong> function and then assign <strong class="source-inline">jsonData</strong> to a <strong class="source-inline">[]byte</strong> that will represent the <strong class="source-inline">JSON</strong> from the college grade submission program:<p class="source-code">func main() {</p><p class="source-code">  jsonData := []byte(`</p><p class="source-code">{</p><p class="source-code">  "id": 2,</p><p class="source-code">  "lname": "Washington",</p><p class="source-code">  "fname": "Bill",</p><p class="source-code">  "IsEnrolled": true,</p><p class="source-code">  "grades":[100,76,93,50],</p><p class="source-code">  "class": </p><p class="source-code">    {</p><p class="source-code">      "coursename": "World Lit",</p><p class="source-code">      "coursenum": 101,</p><p class="source-code">      "coursehours": 3</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">`)</p></li>
				<li>Check whether the <strong class="source-inline">jsonData</strong> is valid <strong class="source-inline">JSON</strong>. If it is not, print an error message and exit the application:<p class="source-code">  if !json.Valid(jsonData) {</p><p class="source-code">    fmt.Printf("JSON is not valid: %s", jsonData)</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>Declare an empty <strong class="source-inline">interface</strong> variable:<p class="source-code">  var v interface{}</p></li>
				<li>Unmarshal <strong class="source-inline">jsonData</strong> into an empty interface. Check for any errors. If there is an error, print the error and exit the application:<p class="source-code">  err := json.Unmarshal(jsonData, &amp;v)</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>Perform type switching on each value in the map. Have a case statement for <strong class="source-inline">string</strong>, <strong class="source-inline">float64</strong>, <strong class="source-inline">bool</strong>, <strong class="source-inline">[]interface</strong>, and <strong class="source-inline">default</strong> to capture the unknown type of a value. Each of the <strong class="source-inline">case</strong> statements should print the data type, the key, and the value. Our switch type assertion flow should work as shown in the following diagram:<div id="_idContainer193" class="IMG---Figure"><img src="image/B14177_11_18.jpg" alt="Figure 11.18: Switch type assertion flow&#13;&#10;"/></div><p class="figure-caption">Figure 11.18: Switch type assertion flow</p><p>The following is the code for performing type switching on each value in the map:</p><p class="source-code">  data := v.(map[string]interface{})</p><p class="source-code">  for k, v := range data {</p><p class="source-code">    switch value := v.(type) {</p><p class="source-code">    case string:</p><p class="source-code">      fmt.Println("(string):", k, value)</p><p class="source-code">    case float64:</p><p class="source-code">      fmt.Println("(float64):", k, value)</p><p class="source-code">    case bool:</p><p class="source-code">      fmt.Println("(bool):", k, value)</p><p class="source-code">    case []interface{}:</p><p class="source-code">      fmt.Println("(slice):", k)</p><p class="source-code">      for i, j := range value {</p><p class="source-code">        fmt.Println("    ", i, j)</p><p class="source-code">      }</p><p class="source-code">    default:</p><p class="source-code">      fmt.Println( "(unknown):",k, value)</p><p class="source-code">      }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Build the program by running <strong class="source-inline">go build</strong> on the command line:<p class="source-code">go build</p></li>
				<li>Correct any errors that are returned and ensure your code matches the code snippet at <a href="https://packt.live/2Qr4dNx">https://packt.live/2Qr4dNx</a>.</li>
				<li>Run the executable by typing the name of the executable and then hit <em class="italic">Enter</em>.<p>The output from the type <strong class="source-inline">switch</strong> statement should be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer194" class="IMG---Figure">
					<img src="image/B14177_11_19.jpg" alt="Figure 11.19: Output of the college class JSON&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.19: Output of the college class JSON</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The output from the map could differ from the preceding example because iterating over a map with a range loop is not a sure thing from one iteration to the next.</p>
			<p>In this exercise, we saw how to parse a JSON structure even if we did not know its content. We learned that by unmarshaling the JSON into an empty interface, we get the structure of <strong class="source-inline">map[string]interface{}</strong>. The key of the map is the field of the JSON and the <strong class="source-inline">interface{}</strong> of the map is the JSON value. We were then able to iterate over the map and perform a switch type statement to get the map value's type and data, and also the key name.</p>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor307"/>GOB: Go's Own Encoding</h1>
			<p>Go has its own special data encoding protocol called <strong class="source-inline">gob</strong>. You can only use <strong class="source-inline">gob</strong> when the encoding and decoding are happening in Go. Being limited to Go is only a deal-breaker if you need to communicate with software written in other languages. It's common with software written to be used internally in an organization for both the encoding and decoding software to be written in the same language. As such, it's not a problem in most cases.</p>
			<p>If you can use it, gob gives you exceptionally high performance and efficiency. For example, JSON is a string-based protocol that needs to be useable in any programming language. This limits what's possible with JSON and protocols like it. <strong class="source-inline">Gob</strong>, on the other hand, is a binary-based protocol, and gob only needs to work for Go users. This frees gob to become a space- and processing-efficient encoding protocol while still being easy to use.</p>
			<p>Gob doesn't require any configuration or setup to use. Also, gob doesn't require the sender and receiver's data model to match exactly. So not only is it efficient and quick, it's also easy to use.</p>
			<p>While Go is strict when it comes to types, gob is not. Gob treats all numbers the same be they <strong class="source-inline">int</strong> or <strong class="source-inline">float</strong>. You can use pointers with gob and when encoding, gob will pull the value from the pointer for you. Gob will also happily set values to pointer or value types regardless of whether the value was encoded from a pointer or a value.</p>
			<p>Gob can encode complex types such as structs. Gob's flexibility continues because it doesn't require that the properties on the structs match. If there is a matching property on the struct it's decoding to, it'll use it; if not, then it'll discard the value. This fact gives the added benefit that you can add new properties without worrying about it breaking your legacy services.</p>
			<p>When using gob for communication between Go web services, it's common practice to use Go's <strong class="source-inline">rpc</strong> package to handle the networking aspects of the communication between the services. The <strong class="source-inline">rpc</strong> package provides a simple way to make calls to other Go web services, and, by default, the <strong class="source-inline">rpc</strong> package uses gob to handle encoding duties. This means you'll get all the benefits of using gob without having to do any extra work. </p>
			<p>Using <strong class="source-inline">gob</strong> for <strong class="source-inline">rpc</strong> service-to-service communication will result in lower latency communications. Low latency communications are what allows for modern software architecture designs, such as microservices.</p>
			<p>To encode data using the gob protocol in Go directly, you use Go's <strong class="source-inline">gob</strong> package. The package is Go's implementation of the gob protocol. When encoding data using this package, it'll return a <strong class="source-inline">byte</strong> slice. These byte slices are common in code for when dealing with files and networks. This means there are already a great number of helper functions for you to take advantage of.</p>
			<p>Gob is not limited to use only in networked solutions. You can also use gob to store data in files. A common use case for writing Go data to files is for making data resilient to server restarts. In modern cloud server deployments, if a server is starting to have problems, it gets killed, and your application is started up again on a new server. If you have any important data that's only in memory, it'll be lost. Prevent this loss by writing that data to a mounted filesystem attached to the server. When the replacement server starts, it attaches to the same filesystem, and on startup, your application recovers the data from the filesystem.</p>
			<p>One example of using files for data resilience is in transaction-based workloads. In a transaction-based workload, losing a single transaction can be a big problem. To prevent this from happening, a backup of the transaction is written to disk while your application is processing it. If a restart were to happen, your application would check these backups to ensure everything's in order. Using gob to encode this data would ensure it's written to the filesystem as soon as possible, minimizing the chance of data loss. </p>
			<p>Another use case is cold-start cache priming. When using a cache for performance reasons, you need to store it in memory. It's not uncommon for the size of this cache to grow to be gigabytes in size. A server restart means this cache is lost and needs reloading from the database. If a lot of servers get restarted all at once, it causes a cache stampede, which could crash the database. A way to avoid this overload situation is to make a copy of the cache and write it to a mounted filesystem. Then, when your application starts up, it would prime its cache from the files and not the database. Using gob to encode this data would allow much more efficient use of disk space, which, in turn, allows faster reading and more efficient decoding. This also means your server gets back online sooner.</p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor308"/>Exercise 11.04: Using gob to Encode Data</h2>
			<p>In this exercise, we're going to encode and transmit, then decode a transaction using gob. We're going to send a banking transaction from a client to a server using a dummy network. The transaction is a struct that also has an embedded user struct. This shows that complex data can be easily encoded. </p>
			<p>To show the flexibility of the <strong class="source-inline">gob</strong> protocol, the client and server structs don't match in several ways. For example, the client's user is a pointer, but the server's user is not. The amounts are of different float types, and the client is a <strong class="source-inline">float64</strong> while the server is a <strong class="source-inline">*float32</strong>. Some of the fields are missing in the server types that are present in the client types. </p>
			<p>We'll be using the <strong class="source-inline">bytes</strong> package to store our encoded data. This shows that once encoded, you can use the standard library to work with the gob binary data.</p>
			<p><strong class="bold">Steps:</strong></p>
			<ol>
				<li value="1">Define <strong class="source-inline">client</strong> structs.</li>
				<li>Define <strong class="source-inline">server</strong> structs that differ in a number of ways.</li>
				<li>Create a byte buffer to act as a dummy network.</li>
				<li>Create a client value with some dummy data.</li>
				<li>Encode the client value.</li>
				<li>Write the encoded data to the dummy network.</li>
				<li>Create a function that acts as the server.</li>
				<li>Read the data from the dummy network.</li>
				<li>Decode the data.</li>
				<li>Print the decoded data to the console.</li>
			</ol>
			<p>Let's get started with the exercise:</p>
			<ol>
				<li value="1">Create a directory called <em class="italic">Exercise11.04</em> within a directory called <strong class="source-inline">Chapter11</strong>.</li>
				<li>Create a file called <strong class="source-inline">main.go</strong> inside of <em class="italic">Chapter11/Exercise11.04</em>.</li>
				<li>Using Visual Studio Code, open the newly created <strong class="source-inline">main.go</strong> file.</li>
				<li>Add the following package name and import statements:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "bytes"</p><p class="source-code">  "encoding/gob"</p><p class="source-code">  "fmt"</p><p class="source-code">  "io"</p><p class="source-code">  "log"</p><p class="source-code">)</p></li>
				<li>Create a <strong class="source-inline">struct</strong> to be our client-side user model:<p class="source-code">type UserClient struct {</p><p class="source-code">  ID   string</p><p class="source-code">  Name string</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">struct</strong> to be our client-side transaction. <strong class="source-inline">Tx</strong> is a common shorthand for transaction:<p class="source-code">type TxClient struct {</p><p class="source-code">  ID          string</p><p class="source-code">  User        *UserClient</p><p class="source-code">  AccountFrom string</p><p class="source-code">  AccountTo   string</p><p class="source-code">  Amount      float64</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">struct</strong> to be our server-side user model. This model doesn't match the client model because it doesn't have the <strong class="source-inline">Name</strong> property:<p class="source-code">type UserServer struct {</p><p class="source-code">  ID string</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">struct</strong> to be our server-side transaction. Here, the user is not a pointer. The amount is a pointer, however, and the pointer is for a <strong class="source-inline">float32</strong>, not a <strong class="source-inline">float64</strong>:<p class="source-code">type TxServer struct {</p><p class="source-code">  ID          string</p><p class="source-code">  User        UserServer</p><p class="source-code">  AccountFrom string</p><p class="source-code">  AccountTo   string</p><p class="source-code">  Amount      *float32</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Create the dummy network, which is a buffer from the <strong class="source-inline">bytes</strong> package:<p class="source-code">  var net bytes.Buffer</p></li>
				<li>Create the dummy data using the client-side structs:<p class="source-code">  clientTx := &amp;TxClient{</p><p class="source-code">    ID: "123456789",</p><p class="source-code">    User: &amp;UserClient{</p><p class="source-code">      ID:   "ABCDEF",</p><p class="source-code">      Name: "James",</p><p class="source-code">    },</p><p class="source-code">    AccountFrom: "Bob",</p><p class="source-code">    AccountTo:   "Jane",</p><p class="source-code">    Amount:      9.99,</p><p class="source-code">  }</p></li>
				<li>Encode the data. The target for the encoded data is our dummy network:<p class="source-code">  enc := gob.NewEncoder(&amp;net)</p></li>
				<li>Check for errors and exit if any are found:<p class="source-code">  if err := enc.Encode(clientTx); err != nil {</p><p class="source-code">    log.Fatal("error encoding: ", err)</p><p class="source-code">  }</p></li>
				<li>Send the data to the server:<p class="source-code">  serverTx, err := sendToServer(&amp;net)</p></li>
				<li>Check for errors and exit if any are found:<p class="source-code">  if err != nil {</p><p class="source-code">    log.Fatal("server error: ", err)</p><p class="source-code">  }</p></li>
				<li>Print the decoded data to the console:<p class="source-code">  fmt.Printf("%#v\n", serverTx)</p></li>
				<li>Close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p></li>
				<li>Create our <strong class="source-inline">sendToServer</strong> function. This function takes a single <strong class="source-inline">io.Reader</strong> interface and returns a server-side transaction and an <strong class="source-inline">error</strong>:<p class="source-code">func sendToServer(net io.Reader) (*TxServer, error) {</p></li>
				<li>Create a variable to be the target for decoding:<p class="source-code">  tx := &amp;TxServer{}</p></li>
				<li>Create a decoder with the network as the source:<p class="source-code">  dec := gob.NewDecoder(net)</p></li>
				<li>Decode and capture any errors:<p class="source-code">  err := dec.Decode(tx)</p></li>
				<li>Return the decoded data and any errors captured:<p class="source-code">  return tx, err</p></li>
				<li>Close the function:<p class="source-code">}</p></li>
				<li>Build the program by running <strong class="source-inline">go build</strong> at the command line:<p class="source-code">go build</p></li>
				<li>Run the executable by typing the name of the executable and hitting <em class="italic">Enter</em>.<p>The output from the type switch statement should be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="image/B14177_11_20.jpg" alt="Figure 11.20: Gob output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.20: Gob output</p>
			<p>In this exercise, we encoded the data using the client types, <strong class="source-inline">sent</strong> it to the server, and dumped out what the server decoded. In what we get back from the server, we can see it's using different types, that the user has an ID but no name, and that <strong class="source-inline">Amount</strong> is a 32-bit float pointer type.</p>
			<p>We can see how easy and flexible gob can be to work with. Gob is also a great choice for performance when you need to communicate between servers, but both servers will need to be written in Go to be able to take advantage of these features.</p>
			<p>In the next a<a id="_idTextAnchor309"/>ctivity, we're going to test what we've learned so far with JSON.</p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor310"/>Activity 11.01: Mimicking a Customer Order Using JSON</h2>
			<p>In this activity, we are going to mimic a customer order. An online e-commerce portal needs to accept customer orders over its web application. As the customer browses through the site, the customer will add items to their order. This web application will need to be able to take the JSON and add orders to the JSON. </p>
			<p><strong class="bold">Steps:</strong></p>
			<ol>
				<li value="1">Create an <strong class="source-inline">address</strong> <strong class="source-inline">struct</strong> with all the exportable fields (the <strong class="source-inline">Street</strong> string, the <strong class="source-inline">City</strong> string, the <strong class="source-inline">State </strong>string, and the <strong class="source-inline">Zipcode</strong> int).</li>
				<li>Create an <strong class="source-inline">item</strong> <strong class="source-inline">struct</strong> with all its exportable fields (the <strong class="source-inline">Name</strong> string, the <strong class="source-inline">Description</strong> string, the <strong class="source-inline">Quantity</strong> int, and the <strong class="source-inline">Price</strong> int). The description field should not show up in the JSON if it has no data.</li>
				<li>Create an <strong class="source-inline">order</strong> <strong class="source-inline">struct</strong> with all its exportable fields (the <strong class="source-inline">TotalPrice</strong> int, the <strong class="source-inline">IsPaid</strong> bool, the <strong class="source-inline">Fragile</strong> bool, and <strong class="source-inline">OrderDetail []item</strong>). The <strong class="source-inline">Fragile</strong> field should not show up in the JSON if it has no data.</li>
				<li>Create a <strong class="source-inline">customer</strong> <strong class="source-inline">struct</strong> with all its the<strong class="source-inline"> UserName</strong> string, the <strong class="source-inline">Password</strong> string, the <strong class="source-inline">Token</strong> string, the <strong class="source-inline">ShipTo</strong> address, and the <strong class="source-inline">PurchaseOrder</strong> order). The <strong class="source-inline">Password</strong> and <strong class="source-inline">Token</strong> fields should never appear in the JSON.</li>
				<li>The application should check that <strong class="source-inline">jsonData</strong> is valid JSON. The following code snippet is some example JSON to use for a customer order for our application:<p class="source-code">  jsonData := []byte(`</p><p class="source-code">  {</p><p class="source-code">    "username" :"blackhat",</p><p class="source-code">    "shipto":  </p><p class="source-code">      {</p><p class="source-code">          "street": "Sulphur Springs Rd",</p><p class="source-code">          "city": "Park City",</p><p class="source-code">          "state": "VA",</p><p class="source-code">          "zipcode": 12345</p><p class="source-code">      },</p><p class="source-code">    "order":</p><p class="source-code">      {</p><p class="source-code">        "paid":false,</p><p class="source-code">        "orderdetail" : </p><p class="source-code">          [{</p><p class="source-code">            "itemname":"A Guide to the World of zeros and ones",</p><p class="source-code">            "desc": "book",</p><p class="source-code">            "qty": 3,</p><p class="source-code">            "price": 50</p><p class="source-code">          }]</p><p class="source-code">      }</p><p class="source-code">  }</p><p class="source-code">  `)</p></li>
				<li>The application should decode the <strong class="source-inline">jsonData</strong> into the customer struct.</li>
				<li>Add two additional items to the order include the <strong class="source-inline">TotalPrice</strong> for all the items in the order, whether the order has any fragile items, and whether the items are all paid for in full.</li>
				<li>Print the customer order so that it is easily readable.<p>The expected output from the application is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer196" class="IMG---Figure">
					<img src="image/B14177_11_21.jpg" alt="Figure 11.21: Customer order printout&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.21: Customer order printout</p>
			<p>We have seen how to encode and decode complex types such as slices in JSON. We have checked whether the JSON was valid JSON. We also have seen how to control which fields in the struct are displayed, and whether the fields that do not have data were able to omit them from the JSON. When we printed out the JSON, we were able to print it in a format that is easy to read.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 732.</p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor311"/>Summary</h1>
			<p>In this chapter, we studied what JSON is and how we can use Go to store JSON in our structs.</p>
			<p>JSON is used by many programming languages including Go. JSON is made up of key-value pairs. These key-value pairs can be any of the following types: string, number, object, array, Boolean, or null.</p>
			<p>Go's standard library provides many capabilities that make working with JSON easy. This includes the ability to decode JSON data into structs. It also has the ability to encode structs into JSON.</p>
			<p>We have seen that, through the use of JSON tags, we have greater flexibility and control over how the encoding and decoding of JSON occurs. These tags give us the ability to name the JSON key name, ignore fields and not encode them into JSON, and omit fields when they are empty.</p>
			<p>The Go standard library gives us the ability to determine how to print in an easy to read format by using the <strong class="source-inline">json.MarshalIndent()</strong> function. We have also seen how to decode JSON structures when we do not know the format of the JSON ahead of time. All of these features and many others demonstrate the powerful functionality that comes in the Go standard library.</p>
			<p>In the next chapter, we will be looking at files and systems. The chapter will go over how to interact with the filesystem, including creating and modifying files. You will also learn about file permissions and creating a command-line application that uses various flags and arguments. We will also look at another format for storing data called CSV. All of this and more in the following chapter.</p>
		</div>
	</body></html>