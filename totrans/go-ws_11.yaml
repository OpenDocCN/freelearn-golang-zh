- en: 11\. Encoding and Decoding (JSON)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter aims to acquaint you with the fundamentals of JavaScript Object
    Notation (JSON). You will learn how to use Go to parse JSON, and then gain the
    ability to convert JSON to a struct and back to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you will learn to describe JSON and unmarshal JSON to a struct. You will
    also learn to marshal a struct to JSON and set the JSON key name to something
    different than the struct field name. By the end of the chapter, you will be able
    to use various JSON tag attributes to control what gets converted to JSON, unmarshal
    an unknown JSON structure, and use encoding for data transmission.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at errors in Go and discovered that, in Go,
    errors are values, which allows us to pass errors around as arguments to functions
    and methods. We also saw that Go functions can return multiple values, one of
    which is often an error. We learned that a good practice is to check for the value
    of an error returned by a function. By not ignoring the error, it prevents unexpected
    behavior in our program. In Go, we saw that you can create your own custom error
    types. Finally, we looked at panics and learned how to recover from them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be working with JSON by using only the standard library
    of Go. Before we start looking at using JSON in Go code, let's have a brief introduction
    to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON** stands for **JavaScript Object Notation**. It is widely used in many
    programming languages for transferring and storing data. Often, this is done by
    transferring data from a web server to a client. JSON is transferred in web applications
    and is even used to store data in a file for later processing. We will look at
    various examples of where this is done in this chapter. JSON is minimal; it is
    not as verbose as XML. It is self-describing; this increases its readability and
    the ease of writing it. JSON is a text format that is language-independent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: Describing JSON'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.1: Describing JSON'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON is widely used as a data format for exchanging data between web applications
    and for various server-to-server communications. A common API that is used in
    applications is the REST API. JSON is frequently used in applications that utilize
    the REST API. One of the reasons that JSON is used in the REST API instead of
    XML is because it is less verbose than XML, more lightweight, and easier to read.
    Looking at the following JSON and XML, respectively, we can see that JSON is less
    verbose, easier to read, and more lightweight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Most modern databases also now store JSON as a data type in a field. Static
    web applications sometimes use JSON for rendering their web pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON format is very structured. The primary parts that make up the JSON
    format consists of a collection of key-value pairs, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: JSON key-value pairs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.2: JSON key-value pairs'
  prefs: []
  type: TYPE_NORMAL
- en: The key is always a string enclosed in quotation marks, whereas the value can
    encompass a multitude of data types. A key-value pair in JSON is a `key` name
    followed by a colon, followed by a `value`. If there are additional key-value
    pairs, they will be separated with a comma.
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 11.2*, there are two key-value pairs. The `firstname` key and its
    value of `Captain` is one. The other set is `lastname` and `Marvel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON can contain arrays. The values are within a set of brackets. In *Figure
    11.3*, lines *3* and *4* are the values of the `phonenumbers` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: JSON array'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.3: JSON array'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve seen key-value pairs, let''s look at JSON data types. The JSON
    object supports many different data types; the following diagram shows those data
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4: JSON data types'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.4: JSON data types'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'String:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Number: This can be a float or an integer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Boolean: Can only be `true` or `false`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Null:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JSON objects are like structs in Go. The following example shows a Go struct
    and a JSON object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this section, we provided a brief introduction to JSON. In the following
    sections, we will look at how Go can decode and encode JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about decoding JSON, what we are stating is that we are taking
    a JSON data structure and converting it into a Go data structure. Converting the
    JSON into a Go data structure gives us the benefit of working with the data natively.
    For example, if the JSON data has a field that is an array in Go, that would get
    decoded to a slice. We will then be able to treat that slice as we would any other
    slice, meaning we can iterate over the slice using a `range` clause, we can get
    the length of the slice, append to the slice, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we know what our JSON looks like ahead of time, we can use structs when
    parsing the JSON. Using Go terms, we need to be able to `unmarshal` the JSON-encoded
    data and store the results in the struct. To be able to do this, we will need
    to import the `encoding/json` package. We will be using the JSON `Unmarshal` function.
    Unmarshaling is the process of parsing JSON to a data structure. Often, you will
    hear unmarshaling and decoding used interchangeably:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the variable data is defined as a slice of bytes. The
    `v` variable is a pointer to a struct. The `Unmarshal` function takes the slice
    of bytes of JSON data and stores the results in the value pointed to by `v`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument for `v` must be a pointer and must not be `nil`. If either of
    those requirements are not met, then an error will be returned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5: Unmarshal error for a non-pointer passed as an argument'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.5: Unmarshal error for a non-pointer passed as an argument'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following code as a simple example of unmarshaling data.
    We will describe each portion of the code in detail to get a better understanding
    of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the code for better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The greeting struct has an exportable field called `Message` of the `string`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `` ` `` symbol is a backtick and not a single quote. It is used for string
    literals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `json.Unmarshal` struct requires that the JSON encoded data must be a byte
    of slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We are declaring `g` to be of the greeting type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Unmarshal()` function takes the slice of bytes of JSON data and stores
    the results in the value pointed to by `v`.
  prefs: []
  type: TYPE_NORMAL
- en: The `v` variable is pointing to our greeting struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'It unmarshals the JSON to a greeting instance, as depicted in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6: Unmarshaling JSON to a Go struct'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.6: Unmarshaling JSON to a Go struct'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the output after unmarshaling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In our previous example, the JSON marshaler matched our field name, `Message`,
    to the JSON key, `message`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To be able to unmarshal into a struct, the struct field must be exportable.
    The struct's field name must be capitalized. Only fields that are exportable are
    visible externally, including the JSON unmarshaler. Only the exported fields will
    be in the JSON output; other fields are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Struct Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use struct tags to provide transformation information on how the struct
    field is unmarshaled or marshaled. Tags follow the format of `` `key: `` `` "value"`
    ``. The tag begins and ends with a backtick (`` ` ``).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using tags gives us more control. We can now name our struct field name anything
    as long as it is exportable.
  prefs: []
  type: TYPE_NORMAL
- en: The `json` field that will be unmarshaled in this example is `lname`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you use tags for JSON unmarshaling and marshaling, it will not compile
    if the struct field is not exportable. The Go compiler is smart enough to realize
    that since there is a JSON tag associated with the struct field, it must be exportable
    to be used in the JSON marshaling and unmarshaling process. See the following
    example of the error you will get when `lastname` is lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the error message for unexported JSON struct fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7: Error for unexported JSON struct fields'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.7: Error for unexported JSON struct fields'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen this code before and we know how to unmarshal JSON. However,
    there is one small change that we will be making, and that is adding a `struct`
    tag to our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the code for better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We changed our `greeting` struct to use a different exportable field name than
    what is in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `` `json:"message"` `` tag states that this exportable field corresponds
    to the `message` key in the JSON data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When the data gets unmarshaled, the JSON message value will be placed in the
    `SomeMessage` struct field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The Go JSON `unmarshaller` follows a process of determining which struct field
    to map the JSON data when decoding it:'
  prefs: []
  type: TYPE_NORMAL
- en: An exported field with a tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exported field name whose case matches the JSON key name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exported field name with a case-insensitive match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could also verify whether the JSON that we are going to unmarshal is valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the code to perform the unmarshaling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `Valid()` function takes as an argument slice of bytes and will return a
    Bool that indicates whether the JSON is valid. It will display `True` for valid
    JSON and `False` for invalid JSON.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful for checking our JSON before we try to unmarshal it into
    a struct.
  prefs: []
  type: TYPE_NORMAL
- en: What structs do you think you would need for the following JSON? Let's take
    a look.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding JSON has an embedded object called `address`. As you may recall
    from the introduction of this chapter, objects are one of the types that JSON
    supports. The Go representation of an object type in JSON is structs. Our `parent`
    struct would need to have an embedded struct called `address`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is an example of unmarshaling more than one JSON
    object into Go structs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break the code down for better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `person` struct has an embedded struct called `Address`. It is represented
    in the JSON as an object called `address`. The fields in the `address` struct
    will have the JSON values unmarshaled to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `address` in JSON is an object that will get unmarshaled into our `person
    struct''s address` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8: Unmarshaled JSON address to person.address'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.8: Unmarshaled JSON address to person.address'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Unmarshal()` function decodes the JSON-encoded `data` into the pointer
    `p`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9: The person struct after decoding JSON'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.9: The person struct after decoding JSON'
  prefs: []
  type: TYPE_NORMAL
- en: We will be using these concepts that we have learned thus far in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.01: Unmarshaling Student Courses'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will be writing a program that takes a JSON from a web
    request for college class enrollment. Our program needs to unmarshal the JSON
    data into a Go struct. The JSON will contain data about a student and the courses
    that they are taking. After we have unmarshaled the JSON, we will print the struct
    for verification purposes. The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10: Printing the student courses struct'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.10: Printing the student courses struct'
  prefs: []
  type: TYPE_NORMAL
- en: 'All directories and files created need to be created within your `$GOPATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `Exercise11.01` within a directory called `Chapter11`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `main.go` inside of `Chapter11/Exercise11.01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Visual Studio Code, open the newly created `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following package name and import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will need to create a `student` struct. The `student` struct will need for
    all its fields to be exported so that we can unmarshal the JSON data to them.
    Each struct field will need to have a JSON tag that will be the name of the JSON
    data fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will need to create a `course` struct. The `course` struct will need all
    its fields to be exported so that we can unmarshal the JSON data to them. Each
    struct field will need to have a JSON tag that will be the name of the JSON data
    fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, add the JSON data that we will be unmarshaling into
    our structs (`student` and `course`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a variable of the `student` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will unmarshal the JSON into our `student` struct. We will also handle
    any errors that get returned from the `json.Unmarshal()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will print the `student` struct so that we can see that all the data from
    the JSON is present:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the program by running `go build` in the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Correct any errors that are returned and ensure your code matches the code snippet
    here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run the executable by typing in the name of the executable and then hit *Enter*
    to run it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.11: Printing the student courses struct'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.11: Printing the student courses struct'
  prefs: []
  type: TYPE_NORMAL
- en: This exercise demonstrated how to unmarshal JSON data into a Go struct successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have studied how to unmarshal JSON into a struct. We will now do the opposite:
    marshal a struct into JSON. When we talk about encoding JSON, what we mean is
    we are taking a Go struct and converting it to a JSON data structure. The typical
    scenario in which this is done is when you have a service that is responding to
    an HTTP request from a client. The client wants the data in a certain format,
    and this is frequently JSON. Another situation is that the data is stored in a
    NoSQL database and it requires JSON as the format, or even a traditional database
    that has a column with a data type of JSON.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to be able to `Marshal` the Go struct into a JSON-encoded structure.
    To be able to do this, we will need to import the `encoding/json` package. We
    will be using the `json.Marshal` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `v` becomes encoded as JSON. Typically, `v` is a `struct`. The `Marshal()`
    function returns the JSON encoding as a slice of bytes and an error. It is always
    a good idea to check whether there was an error during the process of encoding
    `v`. Let''s look at a simple example to further explain the marshaling of Go structs
    to JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the code for better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a struct with one exportable field. Notice there are no JSON tags.
    You should be able to guess what the field will be in the JSON data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows how the `greeting` struct gets marshaled into JSON
    using the `json.Marshal` method. The `v` interface argument in the `marshal` method
    is the `greeting` struct. The `marshal` method will encode the `greeting` field,
    `SomeMessage`, into JSON. The following diagram shows the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12: Marshaling a Go struct to JSON'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.12: Marshaling a Go struct to JSON'
  prefs: []
  type: TYPE_NORMAL
- en: When we call the `Marshal` function, we are passing it a struct. The function
    will return back an error and the JSON encoding of `g`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of the print statement are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Since we did not provide the JSON tag for the struct greeting, `SomeMessage`,
    the Go `Marshal` encodes the exportable fields and its values. The Go `Marshal`
    uses the name of the field, `SomeMessage` ,as the name of the `key` field in the
    JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: The following code produces a result that is not desirable. Examine the following
    code and notice the result of struct fields that are not set. Pay close attention
    to the fields that are not being set in the `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Marshaling struct data when the field value is not set gives you the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'There are times that we might not want our struct fields to be marshaled to
    JSON when the fields are not set. Our `CoAuthor` field and `YearPublished` were
    not set, and thus the JSON values were an empty string and zero, respectively.
    There is a JSON tag attribute that we can utilize called `omitempty`. It will
    omit the struct field from the JSON if it is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the code for better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The two `book` fields'' JSON tags use the `omitempty` attribute. If these fields
    are not set, they will not appear in the JSON. The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the JSON tags, you will need to be careful not to have any spaces
    in the values. Using our previous example, let''s change our `YearPublished` JSON
    tag to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the space between the comma and `omitempty`. This would result in the
    following error if you use `go vet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13: Go vet error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.13: Go vet error'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing to keep in mind is that if you do not properly handle errors,
    you will get some erroneous results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Even though the `json.Marshal(b)` function errored, it still marshaled the struct
    to JSON. The `yearpub` value was set to zero. That is one of the reasons it is
    important to handle our errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other JSON tags that we will look at briefly in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the code for better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the above code, `` `json:",omitempty"` `` does not have a value for a field.
    Notice the JSON tag value starts with a comma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `json:",omitempty"` `` will have the field in the JSON if there is a value
    for the key. If `Author` has a value set, it will appear in the JSON as the `"Author"
    :"somevalue"` key:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The dash is used to ignore the field. The field will not be marshaled to JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram summarizes the different JSON tag attributes that we
    have used with our structs when we marshal the struct to JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14: JSON tag field descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.14: JSON tag field descriptions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having the JSON output as a one-liner is not very readable, especially when
    you start working with larger JSON structures. The Go JSON package provides a
    way to format the JSON output. The `MarshalIndent()` function provides the same
    functionality as the `Marshal` function. In addition to encoding JSON, the `MarshalIndent()`
    function can format the JSON make it easy to read. This is often referred to as
    "pretty printing." The following code shows an example code for the `MarshalIndent()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not be using a prefix in our examples. It just applies a string before
    our indent string. Each element will begin on a new line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the code for better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two structs: a `person` struct and an `address` struct. The `address`
    struct is embedded inside the `person` struct. Both structs have the JSON key
    names defined in the JSON tags. The `address` struct will be a separate object
    inside the JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialize the `person` struct and set the values for the `person.Address`
    fields. Every field has a value set, so there will be no empty strings or zero
    values set in our JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `noPrettyPrint` variable is the JSON encoding of `p`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We, of course, check for any errors returned from the `json.Marshal()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `prettyPrint` variable is the JSON encoding of `p`, by using `json.MarshalIndent()`.
    We set the prefix argument to an empty string and the indent argument to four
    spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the `json.Marshal()` function, we also check for any errors returned
    from the `json.MarshalIndent()` function. We can see these various steps using
    the `json.MarshalIndent()` method depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15: The json.MarshalIndent() method'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.15: The json.MarshalIndent() method'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then print the results of the JSON encoding using the `json.Marshal()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the readability of the JSON is slightly challenging.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON marshaling without `MarshalIndent` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We also print the results of the JSON encoding using the `json.MarshalIndent()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are less of a challenge to read using the `json.MarshalIndent()`
    function. You can clearly read the output more easily than the previous results
    that were printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16: Using the MarshalIndent JSON result'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.16: Using the MarshalIndent JSON result'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.02: Marshaling Student Courses'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to do the opposite to what we did in *Exercise
    11.01*, *Unmarshaling Student Courses*. We will marshal from a struct into JSON.
    This is the previous struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We are going to make some changes to the JSON tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'All directories and files created need to be created within your `$GOPATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following package name and import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `student` struct. All fields will be exportable. The following fields''
    JSON tags will need the following functionality when they get marshaled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`MiddleInitial` should be omitted if a value is not set; `IsMarried` should
    not appear in the JSON; and `IsEnrolled` should be the field name and omitted
    if not set:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `course` struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function called `newStudent()`. This function will return a `student`
    struct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, use the `newStudent()` function to create a `student`
    struct and assign the result of the function to a variable, `s`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, marshal `s` to JSON. We want the indenting of the JSON to be four spaces
    for each field for ease of readability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print `student1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another `student` using the `newStudent()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now add various courses to `s2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, marshal `s2` to JSON. We want the indenting of the JSON to be four spaces
    for each field for ease of readability:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print `student2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of the `student1` print statement is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of the `student2` print statement is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The aim of this exercise was to demonstrate how to encode JSON. We took a struct
    and encoded it into JSON. We were able to change the encoding to make it easier
    to read by indenting the fields. We also saw how to change some of the behavior
    of how fields are encoded to JSON. We saw that we can omit fields from getting
    encoded to JSON if the struct field does not have any data. We demonstrated that
    we can use JSON tags to name the fields in the JSON data differently than the
    field names in the struct. We also saw how we can even ignore fields in the struct
    so that they will not appear in the JSON when we marshal it.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have dealt with knowing the structure of the JSON beforehand and
    that it is not changing. In the next section, we are going to discuss how to handle
    situations when you get a JSON structure, but that structure can change and is
    not stable.
  prefs: []
  type: TYPE_NORMAL
- en: Unknown JSON Structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we know the JSON structure beforehand, it allows us the flexibility to
    design our structs to match the expected JSON. As we have seen, we can unmarshal
    our JSON values into the destination struct types. Go offers support for encoding
    (marshaling) and decoding (unmarshaling) to and from struct types.
  prefs: []
  type: TYPE_NORMAL
- en: There are situations in which you may not know the JSON structure. For example,
    you may be interacting with a third-party tool that posts metrics for a streaming
    service. This metric is in the format of JSON; however, it is very dynamic and
    serves various customers. They frequently add new metrics for their various clients.
    You want to subscribe to this service and report on these various metrics. The
    problem is that the producer of these metrics changes the JSON data frequently.
    They change it so often, they do not provide the changes, and not on any prescribed
    schedule. You need to be able to perform the analysis on new metrics and old ones,
    and you cannot afford to take your service down to add the new fields from the
    JSON into your struct. You need the ability to continuously report on their metrics
    with minimal interruption to the service.
  prefs: []
  type: TYPE_NORMAL
- en: If your JSON is dynamic, it will not work decoding it to a struct. So, what
    do you do when you do not know the JSON structure or when it changes frequently?
  prefs: []
  type: TYPE_NORMAL
- en: 'In these cases, we can use `map[string]interface{}`. The keys of the JSON data
    will be the string key of the map. The `empty interface{}` will be the values
    of those JSON keys. Every type implements the empty interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17: Mapping of JSON to a map data type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.17: Mapping of JSON to a map data type'
  prefs: []
  type: TYPE_NORMAL
- en: The `json.Unmarshal` function will decode the unknown JSON structure into the
    map whose keys are strings and whose values will be empty interfaces. This works
    out well because JSON keys have to be strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the code for better understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '`jsonData` represents the JSON that we are given but do not know the structure
    of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Even though we do not know the JSON structure, we can unmarshal it into an interface.
  prefs: []
  type: TYPE_NORMAL
- en: The `jsonData` gets unmarshaled into `v`, the empty interface, which will be
    a map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The map keys are the strings and the values are empty interfaces. The result
    of printing out `v` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The printing of `map[string]interface{}` does not match the order the data is
    stored. That is because maps are unordered, so their order is not guaranteed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go representation of `v` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Remember the keys are strings and the values are interfaces. Even when there
    are slices in the JSON, the values become a slice of `interfaces{}`, represented
    as `[]interface{}`.
  prefs: []
  type: TYPE_NORMAL
- en: We learned in the *Chapter 7*, *Interfaces*, that we have the ability to access
    the concrete types. We can do type assertion to access the underlying concrete
    type of `map[string]interface{}`. Let's look at another example where we have
    a variety of data types to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.03: Analyzing College Class JSON'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we are going to analyze data from a college administration
    office and see whether we can replace the current college course grade submission
    application. The problem is that the old system's JSON data is not well documented.
    The data types in the JSON are not known, nor is the structure. In some instances,
    the JSON structure is different. We need to write a program that can analyze an
    unknown JSON structure and, for each field in the structure, print the data type
    and the JSON key-value pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'All directories and files created need to be created within your `$GOPATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `Exercise11.03` within a directory called `Chapter11`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `main.go` inside of `Chapter11/Exercise11.03`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Visual Studio Code, open the newly created `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `package` name and `import` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `main()` function and then assign `jsonData` to a `[]byte` that will
    represent the `JSON` from the college grade submission program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check whether the `jsonData` is valid `JSON`. If it is not, print an error
    message and exit the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare an empty `interface` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Unmarshal `jsonData` into an empty interface. Check for any errors. If there
    is an error, print the error and exit the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Perform type switching on each value in the map. Have a case statement for
    `string`, `float64`, `bool`, `[]interface`, and `default` to capture the unknown
    type of a value. Each of the `case` statements should print the data type, the
    key, and the value. Our switch type assertion flow should work as shown in the
    following diagram:![Figure 11.18: Switch type assertion flow'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_11_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the program by running `go build` on the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Correct any errors that are returned and ensure your code matches the code snippet
    at [https://packt.live/2Qr4dNx](https://packt.live/2Qr4dNx).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the executable by typing the name of the executable and then hit *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output from the type `switch` statement should be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.19: Output of the college class JSON'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.19: Output of the college class JSON'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The output from the map could differ from the preceding example because iterating
    over a map with a range loop is not a sure thing from one iteration to the next.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw how to parse a JSON structure even if we did not know
    its content. We learned that by unmarshaling the JSON into an empty interface,
    we get the structure of `map[string]interface{}`. The key of the map is the field
    of the JSON and the `interface{}` of the map is the JSON value. We were then able
    to iterate over the map and perform a switch type statement to get the map value's
    type and data, and also the key name.
  prefs: []
  type: TYPE_NORMAL
- en: 'GOB: Go''s Own Encoding'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go has its own special data encoding protocol called `gob`. You can only use
    `gob` when the encoding and decoding are happening in Go. Being limited to Go
    is only a deal-breaker if you need to communicate with software written in other
    languages. It's common with software written to be used internally in an organization
    for both the encoding and decoding software to be written in the same language.
    As such, it's not a problem in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: If you can use it, gob gives you exceptionally high performance and efficiency.
    For example, JSON is a string-based protocol that needs to be useable in any programming
    language. This limits what's possible with JSON and protocols like it. `Gob`,
    on the other hand, is a binary-based protocol, and gob only needs to work for
    Go users. This frees gob to become a space- and processing-efficient encoding
    protocol while still being easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: Gob doesn't require any configuration or setup to use. Also, gob doesn't require
    the sender and receiver's data model to match exactly. So not only is it efficient
    and quick, it's also easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: While Go is strict when it comes to types, gob is not. Gob treats all numbers
    the same be they `int` or `float`. You can use pointers with gob and when encoding,
    gob will pull the value from the pointer for you. Gob will also happily set values
    to pointer or value types regardless of whether the value was encoded from a pointer
    or a value.
  prefs: []
  type: TYPE_NORMAL
- en: Gob can encode complex types such as structs. Gob's flexibility continues because
    it doesn't require that the properties on the structs match. If there is a matching
    property on the struct it's decoding to, it'll use it; if not, then it'll discard
    the value. This fact gives the added benefit that you can add new properties without
    worrying about it breaking your legacy services.
  prefs: []
  type: TYPE_NORMAL
- en: When using gob for communication between Go web services, it's common practice
    to use Go's `rpc` package to handle the networking aspects of the communication
    between the services. The `rpc` package provides a simple way to make calls to
    other Go web services, and, by default, the `rpc` package uses gob to handle encoding
    duties. This means you'll get all the benefits of using gob without having to
    do any extra work.
  prefs: []
  type: TYPE_NORMAL
- en: Using `gob` for `rpc` service-to-service communication will result in lower
    latency communications. Low latency communications are what allows for modern
    software architecture designs, such as microservices.
  prefs: []
  type: TYPE_NORMAL
- en: To encode data using the gob protocol in Go directly, you use Go's `gob` package.
    The package is Go's implementation of the gob protocol. When encoding data using
    this package, it'll return a `byte` slice. These byte slices are common in code
    for when dealing with files and networks. This means there are already a great
    number of helper functions for you to take advantage of.
  prefs: []
  type: TYPE_NORMAL
- en: Gob is not limited to use only in networked solutions. You can also use gob
    to store data in files. A common use case for writing Go data to files is for
    making data resilient to server restarts. In modern cloud server deployments,
    if a server is starting to have problems, it gets killed, and your application
    is started up again on a new server. If you have any important data that's only
    in memory, it'll be lost. Prevent this loss by writing that data to a mounted
    filesystem attached to the server. When the replacement server starts, it attaches
    to the same filesystem, and on startup, your application recovers the data from
    the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: One example of using files for data resilience is in transaction-based workloads.
    In a transaction-based workload, losing a single transaction can be a big problem.
    To prevent this from happening, a backup of the transaction is written to disk
    while your application is processing it. If a restart were to happen, your application
    would check these backups to ensure everything's in order. Using gob to encode
    this data would ensure it's written to the filesystem as soon as possible, minimizing
    the chance of data loss.
  prefs: []
  type: TYPE_NORMAL
- en: Another use case is cold-start cache priming. When using a cache for performance
    reasons, you need to store it in memory. It's not uncommon for the size of this
    cache to grow to be gigabytes in size. A server restart means this cache is lost
    and needs reloading from the database. If a lot of servers get restarted all at
    once, it causes a cache stampede, which could crash the database. A way to avoid
    this overload situation is to make a copy of the cache and write it to a mounted
    filesystem. Then, when your application starts up, it would prime its cache from
    the files and not the database. Using gob to encode this data would allow much
    more efficient use of disk space, which, in turn, allows faster reading and more
    efficient decoding. This also means your server gets back online sooner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.04: Using gob to Encode Data'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we're going to encode and transmit, then decode a transaction
    using gob. We're going to send a banking transaction from a client to a server
    using a dummy network. The transaction is a struct that also has an embedded user
    struct. This shows that complex data can be easily encoded.
  prefs: []
  type: TYPE_NORMAL
- en: To show the flexibility of the `gob` protocol, the client and server structs
    don't match in several ways. For example, the client's user is a pointer, but
    the server's user is not. The amounts are of different float types, and the client
    is a `float64` while the server is a `*float32`. Some of the fields are missing
    in the server types that are present in the client types.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be using the `bytes` package to store our encoded data. This shows that
    once encoded, you can use the standard library to work with the gob binary data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps:**'
  prefs: []
  type: TYPE_NORMAL
- en: Define `client` structs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define `server` structs that differ in a number of ways.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a byte buffer to act as a dummy network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a client value with some dummy data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encode the client value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the encoded data to the dummy network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that acts as the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read the data from the dummy network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decode the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the decoded data to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s get started with the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called *Exercise11.04* within a directory called `Chapter11`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `main.go` inside of *Chapter11/Exercise11.04*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Visual Studio Code, open the newly created `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following package name and import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `struct` to be our client-side user model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `struct` to be our client-side transaction. `Tx` is a common shorthand
    for transaction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `struct` to be our server-side user model. This model doesn''t match
    the client model because it doesn''t have the `Name` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `struct` to be our server-side transaction. Here, the user is not
    a pointer. The amount is a pointer, however, and the pointer is for a `float32`,
    not a `float64`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the dummy network, which is a buffer from the `bytes` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the dummy data using the client-side structs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Encode the data. The target for the encoded data is our dummy network:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check for errors and exit if any are found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Send the data to the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check for errors and exit if any are found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the decoded data to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create our `sendToServer` function. This function takes a single `io.Reader`
    interface and returns a server-side transaction and an `error`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a variable to be the target for decoding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a decoder with the network as the source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Decode and capture any errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Return the decoded data and any errors captured:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Build the program by running `go build` at the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the executable by typing the name of the executable and hitting *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output from the type switch statement should be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.20: Gob output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.20: Gob output'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we encoded the data using the client types, `sent` it to the
    server, and dumped out what the server decoded. In what we get back from the server,
    we can see it's using different types, that the user has an ID but no name, and
    that `Amount` is a 32-bit float pointer type.
  prefs: []
  type: TYPE_NORMAL
- en: We can see how easy and flexible gob can be to work with. Gob is also a great
    choice for performance when you need to communicate between servers, but both
    servers will need to be written in Go to be able to take advantage of these features.
  prefs: []
  type: TYPE_NORMAL
- en: In the next activity, we're going to test what we've learned so far with JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.01: Mimicking a Customer Order Using JSON'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we are going to mimic a customer order. An online e-commerce
    portal needs to accept customer orders over its web application. As the customer
    browses through the site, the customer will add items to their order. This web
    application will need to be able to take the JSON and add orders to the JSON.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps:**'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `address` `struct` with all the exportable fields (the `Street` string,
    the `City` string, the `State` string, and the `Zipcode` int).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `item` `struct` with all its exportable fields (the `Name` string,
    the `Description` string, the `Quantity` int, and the `Price` int). The description
    field should not show up in the JSON if it has no data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `order` `struct` with all its exportable fields (the `TotalPrice`
    int, the `IsPaid` bool, the `Fragile` bool, and `OrderDetail []item`). The `Fragile`
    field should not show up in the JSON if it has no data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `customer` `struct` with all its the `UserName` string, the `Password`
    string, the `Token` string, the `ShipTo` address, and the `PurchaseOrder` order).
    The `Password` and `Token` fields should never appear in the JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The application should check that `jsonData` is valid JSON. The following code
    snippet is some example JSON to use for a customer order for our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The application should decode the `jsonData` into the customer struct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add two additional items to the order include the `TotalPrice` for all the items
    in the order, whether the order has any fragile items, and whether the items are
    all paid for in full.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the customer order so that it is easily readable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output from the application is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.21: Customer order printout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_11_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.21: Customer order printout'
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to encode and decode complex types such as slices in JSON.
    We have checked whether the JSON was valid JSON. We also have seen how to control
    which fields in the struct are displayed, and whether the fields that do not have
    data were able to omit them from the JSON. When we printed out the JSON, we were
    able to print it in a format that is easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 732.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we studied what JSON is and how we can use Go to store JSON
    in our structs.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON is used by many programming languages including Go. JSON is made up of
    key-value pairs. These key-value pairs can be any of the following types: string,
    number, object, array, Boolean, or null.'
  prefs: []
  type: TYPE_NORMAL
- en: Go's standard library provides many capabilities that make working with JSON
    easy. This includes the ability to decode JSON data into structs. It also has
    the ability to encode structs into JSON.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that, through the use of JSON tags, we have greater flexibility
    and control over how the encoding and decoding of JSON occurs. These tags give
    us the ability to name the JSON key name, ignore fields and not encode them into
    JSON, and omit fields when they are empty.
  prefs: []
  type: TYPE_NORMAL
- en: The Go standard library gives us the ability to determine how to print in an
    easy to read format by using the `json.MarshalIndent()` function. We have also
    seen how to decode JSON structures when we do not know the format of the JSON
    ahead of time. All of these features and many others demonstrate the powerful
    functionality that comes in the Go standard library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at files and systems. The chapter will
    go over how to interact with the filesystem, including creating and modifying
    files. You will also learn about file permissions and creating a command-line
    application that uses various flags and arguments. We will also look at another
    format for storing data called CSV. All of this and more in the following chapter.
  prefs: []
  type: TYPE_NORMAL
