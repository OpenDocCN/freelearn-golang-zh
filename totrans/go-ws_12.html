<html><head></head><body>
		<div>
			<div id="_idContainer198" class="Content">
			</div>
		</div>
		<div id="_idContainer199" class="Content">
			<h1 id="_idParaDest-295"><a id="_idTextAnchor312"/>12. Files and Systems</h1>
		</div>
		<div id="_idContainer222" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter aims to give you an understanding of how to interact with the filesystem. This includes creating and modifying files. You will also learn how to check whether the file exists. We will write to the file and save it on disk. We will then create a command-line application that accepts various flags and arguments. We will also be able to catch signals and determine what to do with them before we exit the program.</p>
			<p class="callout">In this chapter, you will create command-line applications that accept arguments and display help content. By the end of the chapter, you will be able to handle signals that are sent to the application from the operating system (OS), and control the exit from the application when the OS sends a signal to immediately stop the application.</p>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor313"/>Introduction</h1>
			<p>In the previous chapter, we looked at how to marshal and unmarshal JSON. We were able to set our struct to the JSON key values and place our struct values into JSON. The Go programming language has great library support for JSON, just like it has good support for the filesystem-type operations (for example, the <strong class="source-inline">open</strong>, <strong class="source-inline">create</strong>, and <strong class="source-inline">modify</strong> files).</p>
			<p>In this chapter, we will interact with the filesystem. The levels we are going to be working with the filesystem at are the file, directory, and permission levels. We will tackle everyday issues that developers face when working with the filesystem, including how to write a command-line application that needs to accept arguments from the command line. We will learn how to create a command-line application that will read and write files. Along with discussing what happens when we get a signal interrupt from the OS, we will demonstrate how to perform cleanup actions before our application stops running. We will also handle a scenario of receiving an interrupt to our application and handling how the applications exits. There are times when your application is running, and a signal comes from the OS to shut down the application. In such instances, we may want to log information at the time of the shutdown for debugging purposes; this will help us to understand why the application shut down. We will look at how we can do that in this chapter. However, before we start tackling these issues, let's get a basic understanding of the filesystem.</p>
			<h1 id="_idParaDest-297"><a id="_idTextAnchor314"/>Filesystem</h1>
			<p>A filesystem controls how data is named, stored, accessed, and retrieved on a device such as a hard drive, USB, DVD, or another medium. Each filesystem for a specific OS will specify its conventions for naming files, such as the length of the filename, the specific characters that can be used, how long the suffix or file extension can be, and more. There are some file descriptors or metadata about a file that most filesystems contain, such as file size, location, access permissions, date created, date modified, and more:</p>
			<div>
				<div id="_idContainer200" class="IMG---Figure">
					<img src="image/B14177_12_01.jpg" alt="Figure 12.1: Filesystem metadata for a file&#13;&#10;"/>
				</div>
			</div>
			<p><a id="_idTextAnchor315"/></p>
			<p class="figure-caption">Figure 12.1: Filesystem metadata for a file</p>
			<p>Files are generally placed in some sort of hierarchal structure. This structure typically consists of multiple directories and sub-directories. The placement of the files within the directories is a way to organize your data and get access to the file or directory:</p>
			<div>
				<div id="_idContainer201" class="IMG---Figure">
					<img src="image/B14177_12_02.jpg" alt="Figure 12.2: Filesystem directory structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.2: Filesystem directory structure</p>
			<p>As shown in <em class="italic">Figure 12.2</em>, the top-level directory is <strong class="source-inline">Chapter12</strong>. This has sub-directories <strong class="source-inline">ex1</strong>, <strong class="source-inline">ex2</strong>, and <strong class="source-inline">activity1</strong>. In this example, those sub-directories organize files according to each of the exercises and activities. The filesystem is also responsible for who or what can access the directories and files. In the next topic, we will be looking at file permissions.</p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor316"/>File Permissions</h2>
			<p>Permissions are an important aspect that you need to understand when dealing with file creation and modifications.</p>
			<p>We need to look at various permission types that can be assigned to a file. We also need to look at how those permission types are represented as a symbolic and octal notation.</p>
			<p>Go uses the Unix nomenclature for representing permission types. They are represented as symbolic notation or octal notation. The three permission types are <em class="italic">Read</em>, <em class="italic">Write</em>, and <em class="italic">Execute</em>. </p>
			<p>Each one has a symbolic and octal notation. The following table explains the permission type and how it is represented:</p>
			<div>
				<div id="_idContainer202" class="IMG---Figure">
					<img src="image/B14177_12_03.jpg" alt="Figure 12.3: Permissions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.3: Permissions</p>
			<p>For every file, there are three sets of individuals or groups that have their permissions specified:</p>
			<p><em class="italic">Owner</em>:</p>
			<ul>
				<li>To an individual, this is a single person such as John Smith or the root user.</li>
			</ul>
			<p><em class="italic">Group</em>:</p>
			<ul>
				<li>A group typically consists of multiple individuals or other groups.</li>
			</ul>
			<p><em class="italic">Others</em>:</p>
			<ul>
				<li>Those that are not in a group or the owner.</li>
				<li>The following is an example of a file and its permissions on a Unix machine:<div id="_idContainer203" class="IMG---Figure"><img src="image/B14177_12_04.jpg" alt="Figure 12.4: Permission sets&#13;&#10;"/></div></li>
			</ul>
			<p class="figure-caption">Figure 12.4: Permission sets</p>
			<ul>
				<li>The first dash indicates that this is a file; if it was a <strong class="source-inline">d</strong>, that would indicate a directory.</li>
				<li>Octal notation can be used to show multiple permissions types by a single number. For example, if you want to show a permission for <strong class="source-inline">read</strong> and <strong class="source-inline">write</strong> using symbolic notation, it would be <strong class="source-inline">rw-</strong>. If this was to be represented as an octal number, it would be <strong class="source-inline">6</strong>:</li>
			</ul>
			<div>
				<div id="_idContainer204" class="IMG---Figure">
					<img src="image/B14177_12_05.jpg" alt="Figure 12.5: Permission types&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.5: Permission types</p>
			<p>The following table presents the numbers and symbols for the different permission types:</p>
			<div>
				<div id="_idContainer205" class="IMG---Figure">
					<img src="image/B14177_12_06.jpg" alt="Figure 12.6: Permission type, octal, and symbolic&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.6: Permission type, octal, and symbolic</p>
			<p>The next table is an example of various file permissions for <strong class="source-inline">owner</strong>, <strong class="source-inline">group</strong>, and <strong class="source-inline">others</strong>:</p>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="image/B14177_12_07.jpg" alt="Figure 12.7: Permissions based on owner, group, and others&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.7: Permissions based on owner, group, and others</p>
			<h1 id="_idParaDest-299"><a id="_idTextAnchor317"/>Flags and Arguments</h1>
			<p>Go provides support for creating command-line interface tools. Many times, when we are writing Go programs that are executables, they need to accept various inputs. These inputs could include the location of a file, a value to run the program in the debug state, getting help to run the program, and more. All of this is made possible by a package in the Go standard library called <strong class="source-inline">flag</strong>. It is used to allow the passing of arguments to the program. A flag is an argument that is passed to a Go program. The order of the flags being passed to the Go program using the <strong class="source-inline">flag</strong> package does not matter to Go.</p>
			<p>To define your <strong class="source-inline">flag</strong>, you must know the <strong class="source-inline">flag</strong> type you will be accepting. The <strong class="source-inline">flag</strong> package provides many functions for defining flags. Here is a sample list:</p>
			<p class="source-code">func Bool(name string, value bool, usage string) *bool</p>
			<p class="source-code">func Duration(name string, value time.Duration, usage string) *time.Duration</p>
			<p class="source-code">func Float64(name string, value float64, usage string) *float64</p>
			<p class="source-code">func Int(name string, value int, usage string) *int</p>
			<p class="source-code">func Int64(name string, value int64, usage string) *int64</p>
			<p class="source-code">func String(name string, value string, usage string) *string</p>
			<p class="source-code">func Uint(name string, value uint, usage string) *uint</p>
			<p class="source-code">func Uint64(name string, value uint64, usage string) *uint64</p>
			<p>The parameters of the preceding functions can be explained as follows:</p>
			<p><em class="italic">name</em>:</p>
			<ul>
				<li>This parameter is the name of the flag; it is a string type. For example, if you pass <strong class="source-inline">file</strong> as an argument, you would access that flag from the command line by:<p class="source-code">app.exe -file</p></li>
			</ul>
			<p><em class="italic">value</em>:</p>
			<ul>
				<li>This parameter is the default value that the flag is set to.</li>
			</ul>
			<p><em class="italic">usage</em>:</p>
			<ul>
				<li>This parameter is used to describe the flag's purpose. It will often show up on the command line when you incorrectly set the value.</li>
				<li>Passing the wrong type for a flag will stop the program and cause an error; the usage will be printed.</li>
			</ul>
			<p><em class="italic">return value</em>:</p>
			<ul>
				<li>This is the address of the variable that stores the value of the flag.</li>
			</ul>
			<p>Let's take a look at a simple example:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "flag"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  v := flag.Int("value", -1, "Needs a value for the flag.")</p>
			<p class="source-code">  flag.Parse()</p>
			<p class="source-code">  fmt.Println(*v)</p>
			<p class="source-code">}</p>
			<p>The following diagram describes the preceding example when using the flag package.</p>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="image/B14177_12_08.jpg" alt="Figure 12.8: flag.Int arguments&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.8: flag.Int arguments</p>
			<p>We will go over the code in the diagram and the previous code snippet.</p>
			<ul>
				<li>The variable <strong class="source-inline">v</strong> will reference the value for either <strong class="source-inline">-value</strong> or –<strong class="source-inline">value</strong>.</li>
				<li>The initial value of <strong class="source-inline">*v</strong> is the default value of <strong class="source-inline">-1</strong> before calling <strong class="source-inline">flag.Parse()</strong>:<p class="source-code">flag.Parse()</p></li>
				<li>After defining the flags, you must call <strong class="source-inline">flag.Parse()</strong> to parse the command line into the defined flags.</li>
				<li>Calling <strong class="source-inline">flag.Parse()</strong> places the argument for <strong class="source-inline">-value</strong> into <strong class="source-inline">*v</strong>.</li>
				<li>Once you have called the <strong class="source-inline">flag.Parse() function</strong>, the flags will be available.</li>
				<li>On the command line, execute the following <strong class="source-inline">go build -o exFlag</strong> command and you will get the executable in the directory called <strong class="source-inline">exFlag</strong>:</li>
			</ul>
			<div>
				<div id="_idContainer208" class="IMG---Figure">
					<img src="image/B14177_12_09.jpg" alt="Figure 12.9: Application flag and arguments&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.9: Application flag and arguments</p>
			<p>Let's look at using flags of various types in the following code snippet:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "flag"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  i := flag.Int("age", -1, "your age")</p>
			<p class="source-code">  n := flag.String("name", "", "your first name")</p>
			<p class="source-code">  b := flag.Bool("married", false, "are you married?")</p>
			<p class="source-code">  flag.Parse()</p>
			<p class="source-code">  fmt.Println("Name: ", *n)</p>
			<p class="source-code">  fmt.Println("Age: ", *i)</p>
			<p class="source-code">  fmt.Println("Married: ", *b)</p>
			<p class="source-code">}</p>
			<p>Let's analyze the preceding code:</p>
			<ul>
				<li>We define three flags of the <strong class="source-inline">Int</strong>, <strong class="source-inline">String</strong>, and <strong class="source-inline">Bool</strong> type.</li>
				<li>We then call the <strong class="source-inline">flag.Parse()</strong> function to place the arguments for those flags into their respective reference variables.</li>
				<li>Then, we simply print the values.</li>
				<li>Running the executable with no parameters: <strong class="source-inline">./exFlag</strong><p class="source-code">Name:  </p><p class="source-code">Age:  -1</p><p class="source-code">Married:  false</p></li>
				<li>Running without supplying arguments; the values of the reference pointers are the default values assigned when we defined our flag types: <strong class="source-inline">./exFlag -h</strong>:<p class="source-code">Usage of ./exFlag:</p><p class="source-code">  -age int</p><p class="source-code">    your age (default -1)</p><p class="source-code">  -married</p><p class="source-code">    are you married?</p><p class="source-code">  -name string</p><p class="source-code">    your first name</p></li>
				<li>Running our application with the <strong class="source-inline">-h</strong> flag prints out the usage statement that we set when we defined our flags: <p><strong class="source-inline">./exFlag -name=John –age 42 -married true results</strong>:</p><p class="source-code">Name:  John</p><p class="source-code">Age:  42</p><p class="source-code">Married:  false</p></li>
			</ul>
			<p>There are times when we might want to make a <strong class="source-inline">flag</strong> necessary for the command-line application. Carefully choosing the default value when a flag is required is important. You can check and see whether the value of the flag is the default and whether it is exiting the program:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "flag"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "os"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  i := flag.Int("age", -1, "your age")</p>
			<p class="source-code">  n := flag.String("name", "", "your first name")</p>
			<p class="source-code">  b := flag.Bool("married", false, "are you married?")</p>
			<p class="source-code">  flag.Parse()</p>
			<p class="source-code">  if *n == "" {</p>
			<p class="source-code">  fmt.Println("Name is required.")</p>
			<p class="source-code">  flag.PrintDefaults()</p>
			<p class="source-code">  os.Exit(1)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Println("Name: ", *n)</p>
			<p class="source-code">  fmt.Println("Age: ", *i)</p>
			<p class="source-code">  fmt.Println("Married: ", *b)</p>
			<p class="source-code">  if *n == "" {</p>
			<p class="source-code">  fmt.Println("Name is required.")</p>
			<p class="source-code">  flag.PrintDefaults()</p>
			<p class="source-code">  os.Exit(1)</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Let's review the code in detail:</p>
			<ul>
				<li>The name flag has the default value of an empty string.</li>
				<li>We check to see whether that is the value of <strong class="source-inline">*n</strong>. If it is, we print a message informing the user that <strong class="source-inline">Name</strong> is required.</li>
				<li>We then call <strong class="source-inline">flag.PrintDefaults()</strong>; this prints the usage message to the user.</li>
				<li>The results of calling the application are <strong class="source-inline">/exFlag --age 42 -married true</strong>:</li>
			</ul>
			<p class="source-code">Name is required.</p>
			<p class="source-code">  -age int</p>
			<p class="source-code">    your age (default -1)</p>
			<p class="source-code">  -married</p>
			<p class="source-code">    are you married?</p>
			<p class="source-code">  -name string</p>
			<p class="source-code">    your first name</p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor318"/>Signals</h2>
			<ul>
				<li>What is a signal? In our context, a signal is an interrupt that is sent to our program or to a process by the OS. When a signal is delivered to our program, the program will stop what it is doing; either it will handle the signal or, if possible, ignore it. We have seen other Go commands that change the flow of the program; you may be wondering which one to use.</li>
			</ul>
			<p>We use <strong class="source-inline">defer</strong> statements in our applications to perform various cleanup activities, such as the following:  </p>
			<ul>
				<li>The release of resources</li>
				<li>The closing of files</li>
				<li>The closing of database connections</li>
				<li>Performing the removal of configuration or temporary files</li>
			</ul>
			<p>In some use cases, it is imperative that these activities are completed. Using a <strong class="source-inline">defer</strong> function will execute it just before returning to the caller. However, this does not guarantee that it will always run. There are certain scenarios in which the <strong class="source-inline">defer</strong> function won't execute; for example, an OS interrupt to your program:</p>
			<ul>
				<li><strong class="source-inline">os.Exit(1)</strong></li>
				<li><em class="italic">Ctrl</em> + <em class="italic">C</em></li>
				<li>Other instructions from the OS</li>
				<li>The preceding scenarios indicate where it may warrant using signals. Signals can help us control the exit of our program. Depending on the signal, it could terminate our program. For example, the application is running and encounters an OS interrupt signal after executing <strong class="source-inline">employee.CalculateSalary()</strong>. In this scenario, the <strong class="source-inline">defer</strong> function will not run, thus, <strong class="source-inline">employee.DepositCheck()</strong> does not execute and the employee does not get paid. A signal can change the flow of the program. The following diagram goes over the scenario we discussed previously:<div id="_idContainer209" class="IMG---Figure"><img src="image/B14177_12_10.jpg" alt="Figure 12.10: Signal changing the flow of the program&#13;&#10;"/></div></li>
			</ul>
			<p class="figure-caption">Figure 12.10: Signal changing the flow of the program</p>
			<ul>
				<li>Support for handling signals is built into the Go standard library; it is in the <strong class="source-inline">os/signal</strong> package. This package will allow us to make our programs more resilient. We want to gracefully shut down when we receive certain signals.The first thing to do when handling signals in Go is to trap or catch the signal that you are interested in. This is done by using the following:</li>
			</ul>
			<p class="source-code">func Notify(c chan&lt;- os.Signal, sig ...os.Signal)</p>
			<ul>
				<li>The <strong class="source-inline">Notify()</strong> function accepts an <strong class="source-inline">os.Signal</strong> data type on a channel, <strong class="source-inline">c</strong>. The <strong class="source-inline">sig</strong> argument is a variadic variable of <strong class="source-inline">os.Signal</strong>; we specify zero or more <strong class="source-inline">os.Signal</strong> data types that we are interested in.</li>
				<li>The following is an example that handles a <strong class="source-inline">syscall.SIGINT</strong> interrupt, which is akin to <strong class="source-inline">CTRL-C</strong>:</li>
			</ul>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "os"</p>
			<p class="source-code">  "os/signal"</p>
			<p class="source-code">  "syscall"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  sigs := make(chan os.Signal, 1)</p>
			<p class="source-code">  done := make(chan bool)</p>
			<p class="source-code">  signal.Notify(sigs,syscall.SIGINT)</p>
			<p class="source-code">  go func() {</p>
			<p class="source-code">  for {</p>
			<p class="source-code">    s := &lt;-sigs</p>
			<p class="source-code">    switch s {</p>
			<p class="source-code">    case syscall.SIGINT:</p>
			<p class="source-code">    fmt.Println()</p>
			<p class="source-code">    fmt.Println("My process has been interrupted.  Someone might of pressed CTRL-  C")</p>
			<p class="source-code">    fmt.Println("Some clean up is occuring")</p>
			<p class="source-code">    done &lt;- true    </p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">  }()</p>
			<p class="source-code">  fmt.Println("Program is blocked until a signal is caught")</p>
			<p class="source-code">  &lt;-done</p>
			<p class="source-code">  fmt.Println("Out of here")</p>
			<p class="source-code">}</p>
			<ul>
				<li>Let's look at the preceding code snippet in detail:<p class="source-code">sigs := make(chan os.Signal, 1)</p></li>
				<li>We create a channel of the <strong class="source-inline">os.Signal</strong> type. The <strong class="source-inline">Notify</strong> method works by sending values of the <strong class="source-inline">os.Signal</strong> type to a channel. The <strong class="source-inline">sigs</strong> channel is used to receive these notifications from the <strong class="source-inline">Notify</strong> method:<p class="source-code">done := make(chan bool)</p></li>
				<li>The <strong class="source-inline">done</strong> channel is used to let us know when the program can exit:<p class="source-code">signal.Notify(sigs,syscall.SIGINT)</p></li>
				<li>The <strong class="source-inline">signal.Notify</strong> method will receive notifications on the <strong class="source-inline">sigs</strong> channel, which is of the <strong class="source-inline">syscall.SIGINT</strong> type:<p class="source-code">  go func() {</p><p class="source-code">  for {</p><p class="source-code">    s := &lt;-sigs</p><p class="source-code">    switch s {</p><p class="source-code">    case syscall.SIGINT:</p><p class="source-code">    fmt.Println("My process has been interrupted.  Someone might of pressed   CTRL-C")</p><p class="source-code">    fmt.Println("Some clean up is occurring")</p><p class="source-code">    done &lt;- true    </p><p class="source-code">    }</p><p class="source-code">  }</p></li>
				<li>We create an anonymous function that is a goroutine. This function currently only has a case statement, which is blocking until it gets a <strong class="source-inline">syscall.SIGINT</strong> type.</li>
				<li>It will print out various messages.</li>
				<li>We send <strong class="source-inline">true</strong> to our <strong class="source-inline">done</strong> channel to indicate that we received the signal. This will stop our channel from blocking:<p class="source-code">  fmt.Println("Program is blocked until a signal is caught")</p><p class="source-code">  &lt;-done</p><p class="source-code">  fmt.Println("Out of here")</p></li>
				<li>The <strong class="source-inline">&lt;-done</strong> channel will be blocking until our program receives the signal. </li>
				<li>Here are the results:<p class="source-code">Program is blocked until a signal is caught</p><p class="source-code">^C</p><p class="source-code">My process has been interrupted.  Someone might of pressed CTRL-C</p><p class="source-code">Some clean up is occurring</p><p class="source-code">Out of here</p></li>
			</ul>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor319"/>Exercise 12.01: Simulating Cleanup</h2>
			<p>In this exercise, we will be catching two signals: <strong class="source-inline">SIGINT</strong> and <strong class="source-inline">SIGTSTP</strong>. Once those signals have been caught, we will simulate a cleanup of the files. We have not gone over how to remove files yet, so, in this example, we will simply create a delay to demonstrate how we can run a function after a signal is caught. This is the desired output from this exercise:</p>
			<ol>
				<li>Create a file called <strong class="source-inline">main.go</strong>.</li>
				<li>Add to the file the package <strong class="source-inline">main</strong> and the following import statements:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "os"</p><p class="source-code">  "os/signal"</p><p class="source-code">  "syscall"</p><p class="source-code">  "time"</p><p class="source-code">)</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, create a channel of the <strong class="source-inline">os.Signal</strong> type. The <strong class="source-inline">sigs</strong> channel is used to receive these notifications from the <strong class="source-inline">Notify</strong> method:<p class="source-code">func main() {</p><p class="source-code">  sigs := make(chan os.Signal, 1)</p></li>
				<li>Next, add a <strong class="source-inline">done</strong> channel. The <strong class="source-inline">done</strong> channel is used to let us know when the program can exit:<p class="source-code">  done := make(chan bool)</p></li>
				<li>We will then add a <strong class="source-inline">signal.Notify</strong> method. The <strong class="source-inline">Notify</strong> method works by sending values of the <strong class="source-inline">os.Signal</strong> type to a channel.</li>
				<li>Recall that the last parameter of the <strong class="source-inline">signal.Notify</strong> method is a variadic parameter of the <strong class="source-inline">os.Signal</strong> type.</li>
				<li>The <strong class="source-inline">signal.Notify</strong> method will receive notifications on the channel sigs that are of the <strong class="source-inline">syscall.SIGINT</strong> and <strong class="source-inline">syscall.SIGTSTP</strong> types.</li>
				<li>Generally speaking, the <strong class="source-inline">syscall.SIGINT</strong> type can occur when you press <em class="italic">Ctrl</em> + <em class="italic">C</em>.</li>
				<li>Generally speaking, the <strong class="source-inline">syscall.SIGTSTP</strong> type can occur when you press <em class="italic">Ctrl</em> + <em class="italic">Z</em>:<p class="source-code">  signal.Notify(sigs, syscall.SIGINT, syscall.SIGTSTP)</p></li>
				<li>Create an anonymous function as a goroutine:<p class="source-code">  go func() {</p></li>
				<li> Inside the goroutine, create an infinite loop.</li>
				<li> Inside the infinite loop, we will receive a value from the <strong class="source-inline">sigs</strong> channel and store it in the <strong class="source-inline">s</strong> variable, <strong class="source-inline">s := &lt;-sigs</strong>:<p class="source-code">    for {</p><p class="source-code">      s := &lt;-sigs</p></li>
				<li>Create a <strong class="source-inline">switch</strong> statement that evaluates what is received from the channel.</li>
				<li>We will have two case statements that will check for the <strong class="source-inline">syscall.SIGINT</strong> and <strong class="source-inline">syscall.SIGTSP</strong> types.</li>
				<li>Each case statement will have a message being printed.</li>
				<li>We will also call our <strong class="source-inline">cleanup()</strong> function.</li>
				<li>The last statement in the case statement is sending <strong class="source-inline">true</strong> to the <strong class="source-inline">done</strong> channel to stop the blocking:<p class="source-code">      switch s {</p><p class="source-code">      case syscall.SIGINT:</p><p class="source-code">        fmt.Println()</p><p class="source-code">        fmt.Println("My process has been interrupted.  Someone might of pressed CTRL-C")</p><p class="source-code">        fmt.Println("Some clean up is occuring")</p><p class="source-code">        cleanUp()</p><p class="source-code">        done &lt;- true</p><p class="source-code">      case syscall.SIGTSTP:</p><p class="source-code">        fmt.Println()</p><p class="source-code">        fmt.Println("Someone pressed CTRL-Z")</p><p class="source-code">        fmt.Println("Some clean up is occuring")</p><p class="source-code">        cleanUp()</p><p class="source-code">        done &lt;- true</p><p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }()</p><p class="source-code">  fmt.Println("Program is blocked until a signal is caught(ctrl-z, ctrl-c)")</p><p class="source-code">  &lt;-done</p><p class="source-code">  fmt.Println("Out of here")</p><p class="source-code">}</p></li>
				<li>Create a simple function to mimic a process performing a cleanup:<p class="source-code">func cleanUp() {</p><p class="source-code">  fmt.Println("Simulating clean up")</p><p class="source-code">  for i := 0; i &lt;= 10; i++ {</p><p class="source-code">    fmt.Println("Deleting Files.. Not really.", i)</p><p class="source-code">    time.Sleep(1 * time.Second)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>You can try running this program and pressing <em class="italic">Ctrl + Z</em> and <em class="italic">Ctrl + C</em> to examine the different results of the program. This only works on Linux and macOS:</li>
				<li>Now run the code:<p class="source-code">go run main.go</p><p>The following is the output:</p></li>
			</ol>
			<div>
				<div id="_idContainer210" class="IMG---Figure">
					<img src="image/B14177_12_11.jpg" alt="Figure 12.11: Simulating cleanup output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.11: Simulating cleanup output</p>
			<p>In this exercise, we have demonstrated the ability to intercept an interrupt and perform a task before the application closes. We have the ability to control our exit. This is a powerful feature that allows us to perform cleanup actions that include removing files, performing a last-minute log, freeing up memory, and more. In the next topic, we are going to be creating and writing to files. We will be using functions that come from the Go standard package, <strong class="source-inline">os</strong>.</p>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor320"/>Creating and Writing to Files </h1>
			<p>The Go language provides support in various ways to create and write to new files. We will examine some of the most common ways in which this is performed.</p>
			<p>The <strong class="source-inline">os</strong> package provides a simple way in which to create a file. For those who are familiar with the <strong class="source-inline">touch</strong> command from the Unix world, it is similar to this. Here is the signature of the function:</p>
			<p class="source-code">func Create(name string(*File, error)</p>
			<p>The function will create an empty file just like the <strong class="source-inline">touch</strong> command. It is important to note that if it already exists, then it will truncate the file.</p>
			<p>The <strong class="source-inline">Create</strong> function from the <strong class="source-inline">os</strong> package input parameter is the name of the file and the location that you want to create. If successful, it will return a <strong class="source-inline">File</strong> type. It is worth noting that the <strong class="source-inline">File</strong> type satisfies the <strong class="source-inline">io.Write</strong> and <strong class="source-inline">io.Read</strong> interfaces. This is important to know for later in the chapter:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "os"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  f, err := os.Create("test.txt")</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">  panic(err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  defer f.Close()</p>
			<p class="source-code">}</p>
			<ul>
				<li>The preceding code simply creates an empty file:<p class="source-code">f, err := os.Create("test.txt")</p></li>
				<li>It creates a file named test.txt.</li>
				<li>If a file by that name already exists, then it will truncate that file.</li>
				<li>Since we did not provide a location for the file, it will create the file in the directory of our executable:<p class="source-code">  if err != nil {</p><p class="source-code">  fmt.Println(err)</p><p class="source-code">  }</p></li>
				<li>We then check for errors from the os.Create function. It is a good practice to check for errors immediately, because if an error occurred and we did not check for the error, this would make debugging in our program difficult later.</li>
				<li>We panic if there is an error. It is better to panic and then to exit, because the defer function will not run if you do an os.Exit(1) with a function that has a defer function.</li>
				<li>If an error did occur, then it would be of the *PathError type. For example, say that we gave the os.Create function an incorrect path such as /lol/test.txt. We would get the following error:<p class="source-code"><strong class="bold">open /lol/test.txt: no such file or directory</strong></p></li>
			</ul>
			<p>Creating an empty file is straightforward, but let's continue with <strong class="source-inline">os.Create</strong> and write to the file we just created. Recall that <strong class="source-inline">os.Create</strong> returns an <strong class="source-inline">*os.File</strong> type. There are two methods of interest that can be used to write to the file:</p>
			<ul>
				<li><strong class="source-inline">Write</strong></li>
				<li><strong class="source-inline">WriteString</strong>:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "os"</p><p class="source-code">)</p><p class="source-code">func main() {</p><p class="source-code">  f, err := os.Create("test.txt")</p><p class="source-code">  if err != nil {</p><p class="source-code">  panic(err)</p><p class="source-code">  }</p><p class="source-code">  defer f.Close()</p><p class="source-code">  f.Write([]byte("Using Write function.\n"))</p><p class="source-code">  f.WriteString("Using Writestring function.\n")</p><p class="source-code">}</p><p>Let's look at the preceding code in more detail:</p><p class="source-code">func (f *File) Write(b []byte) (n int, err error)</p></li>
				<li>The <strong class="source-inline">Write</strong> method accepts a slice of bytes and returns the number of bytes written and an error if there is any. This method also allows the <strong class="source-inline">os.File</strong> type to satisfy the <strong class="source-inline">io.Write</strong> interface:<p class="source-code">f.Write([]byte("Using Write function.\n"))</p></li>
				<li>We are taking the <strong class="source-inline">"Using Write function.\n"</strong> string and converting it into a slice of bytes.</li>
				<li>Then, we are writing it to our <strong class="source-inline">test.txt</strong> file. The <strong class="source-inline">Write</strong> method accepts <strong class="source-inline">[]byte</strong>:<p class="source-code">f.WriteString("Using Writestring function.\n")</p></li>
				<li>The <strong class="source-inline">WriteString</strong> method behaves the same as the <strong class="source-inline">Write</strong> method, except that it takes a string as an input parameter versus a <strong class="source-inline">[]byte</strong> data type.<p>Go provides us with the ability to create and write to a file within a single command. We will be leveraging the <strong class="source-inline">io/ioutil</strong> package in Go to accomplish this task. The <strong class="source-inline">ioutil.WriteFile</strong> method is a very handy method that provides this ability:</p><p class="source-code">func WriteFile(filename string, data []byte, perm os.FileMode) error</p><p>The method writes the data to the file specified in the filename parameter, with the given permissions.  It will return an error if one exists. Let's take a look at this in action:</p><p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "io/ioutil"</p><p class="source-code">)</p><p class="source-code">func main() {</p><p class="source-code">  message := []byte("Look!")</p><p class="source-code">  err := ioutil.WriteFile("test.txt", message, 0644)</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">  }</p><p class="source-code">}</p><p>Let's understand the code in pieces:</p><p class="source-code">err := ioutil.WriteFile("test.txt", message, 0644)</p></li>
				<li>The <strong class="source-inline">WriteFile</strong> method will write the <strong class="source-inline">[]byte</strong> variable message to the <strong class="source-inline">test.txt</strong> file.</li>
				<li>If the <strong class="source-inline">test.txt</strong> file does not exist, it will create the <strong class="source-inline">test.txt</strong> file with the permissions of <strong class="source-inline">0644</strong>. The owner will have read/write permissions. The group and others will have read permissions.</li>
				<li>If the file does exist, it will truncate it.</li>
			</ul>
			<p>Both <strong class="source-inline">os.Create</strong> and <strong class="source-inline">ioutil.WriteFile</strong> will truncate the file if it exists. This may not always be the desired behavior. There may be times that we want to check to see whether the file exists before we create the file or before we attempt to read the file. Lucky for us, Go provides a simple mechanism for checking whether a file exists:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The following code snippet requires the <strong class="source-inline">junk.txt</strong> file to not exist. It also requires the <strong class="source-inline">test.txt</strong> file to exist in the same directory as the program's executable.</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "os"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  file, err := os.Stat("junk.txt")</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">  if os.IsNotExist((err)) {</p>
			<p class="source-code">    fmt.Println("junk.txt:  File does not exist!")</p>
			<p class="source-code">    fmt.Println(file)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Println()</p>
			<p class="source-code">  file, err = os.Stat("test.txt")</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">  if os.IsNotExist((err)) {</p>
			<p class="source-code">    fmt.Println("test.txt:  File does not exist!")</p>
			<p class="source-code">  }</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Printf("file name: %s\nIsDir: %t\nModTime: %v\nMode: %v\nSize: %d\n", file.Name(), file.IsDir(), file.ModTime(), file.Mode(), file.Size())</p>
			<p class="source-code">}</p>
			<p>Let's look at the preceding code snippet in more detail:</p>
			<p class="source-code">file, err := os.Stat("junk.txt")</p>
			<ul>
				<li>We are calling <strong class="source-inline">os.Stat()</strong> on the <strong class="source-inline">junk.txt</strong> file to check to see whether it exists. The <strong class="source-inline">os.Stat()</strong> method will return a <strong class="source-inline">FileInfo</strong> type if the file exists. If not, <strong class="source-inline">FileInfo</strong> will be <strong class="source-inline">nil</strong> and an error will be returned instead:<p class="source-code">  if err != nil {</p><p class="source-code">  if os.IsNotExist((err)) {</p><p class="source-code">    fmt.Println("junk.txt:  File does not exist!")</p><p class="source-code">    fmt.Prinln(file)</p><p class="source-code">  }</p><p class="source-code">  }</p></li>
				<li>The <strong class="source-inline">os.Stat()</strong> method can return multiple errors. We must inspect the error to determine whether the error is due to the file not being there. The standard library provides <strong class="source-inline">os.IsNotExist(error)</strong>, which can be used to check to see whether the error is the result of the file not existing. Here is the result:<p class="source-code">IsNotExist returns a boolean indicating whether the error is known to report that a file or a directory does not exist. It is satisfied by ErrNotExist as well as some syscall errors.</p><p class="source-code">func os.IsNotExist(err error) bool</p></li>
				<li>The printing of <strong class="source-inline">file(FileInfo)</strong> will be <strong class="source-inline">nil</strong> in this scenario, since <strong class="source-inline">junk.txt</strong> does not exist:<p class="source-code">file, err = os.Stat("test.txt")</p></li>
				<li>The <strong class="source-inline">test.txt</strong> file does exist in this scenario, so the <strong class="source-inline">err</strong> will be <strong class="source-inline">nil</strong> and the file will contain the <strong class="source-inline">FileInfo</strong> type:<p class="source-code">  fmt.Printf("file name: %s\nIsDir: %t\nModTime: %v\nMode: %v\nSize: %d\n",     file.Name(), file.IsDir(), file.ModTime(), file.Mode(), file.Size())</p><p class="source-code">}</p></li>
				<li>There are various pieces of information that the <strong class="source-inline">FileInfo</strong> type contains, which can be useful to know.</li>
				<li>The following details on the <strong class="source-inline">FileInfo</strong> interface can be found at <a href="https://golang.org/src/os/types.go?s=479:840#L11">https://golang.org/src/os/types.go?s=479:840#L11</a>:<p class="source-code">// A FileInfo describes a file and is returned by Stat and Lstat.</p><p class="source-code">  type FileInfo interface {</p><p class="source-code">  Name() string     // base name of the file</p><p class="source-code">  Size() int64    // length in bytes for regular files; system-dependent for others</p><p class="source-code">  Mode() FileMode   // file mode bits</p><p class="source-code">  ModTime() time.Time // modification time</p><p class="source-code">  IsDir() bool    // abbreviation for Mode().IsDir()</p><p class="source-code">  Sys() interface{}   // underlying data source (can return nil)</p><p class="source-code">  }</p></li>
				<li>Here are the results of the executed code:</li>
			</ul>
			<div>
				<div id="_idContainer211" class="IMG---Figure">
					<img src="image/B14177_12_12.jpg" alt="Figure 12.12: os.Stat &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.12: os.Stat </p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor321"/>Reading the Whole File at Once</h2>
			<p>In this topic, we will look at two methods that read all the contents of the file. These two functions are good to use when your file size is small. While these two methods are convenient and easy to use, they have one major drawback. That is, if the file size is too large, then it could exhaust the memory on the system. It is important to keep this in mind and understand the limitations of the two methods we will be going over in this topic. Even though these methods are one of the quickest and easiest ways to load data, it is important to understand that they should be limited to small files and not large ones.</p>
			<p>The first method we will examine for reading a file is the following:</p>
			<p class="source-code">func ReadFile(filename string) ([]byte, error)</p>
			<p>The <strong class="source-inline">ReadFile</strong> function reads the contents of the file and returns it as a slice of bytes along with any reported errors. We will look at the error return when the <strong class="source-inline">ReadFile</strong> method is used: </p>
			<ul>
				<li>A successful call returns <strong class="source-inline">err == nil</strong>.</li>
				<li>In some of the other read methods for files, EOF is treated as an error. This is not the case for functions that read the entire file into memory:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "io/ioutil"</p><p class="source-code">)</p><p class="source-code">func main() {</p><p class="source-code">  content, err := ioutil.ReadFile("test.txt")</p><p class="source-code">  if err != nil {</p><p class="source-code">  fmt.Println(err)</p><p class="source-code">  }</p><p class="source-code">  fmt.Println("File contents: ")</p><p class="source-code">  fmt.Println(string(content))</p><p class="source-code">}</p></li>
				<li>For this code snippet, I have a <strong class="source-inline">test.txt</strong> file that is located in the same location as my executable. It contains the following content:</li>
			</ul>
			<div>
				<div id="_idContainer212" class="IMG---Figure">
					<img src="image/B14177_12_13.jpg" alt="Figure 12.13: Example text file&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.13: Example text file</p>
			<p class="source-code">content, err := ioutil.ReadFile("test.txt")</p>
			<ul>
				<li>The contents of <strong class="source-inline">text.txt</strong> get assigned as a slice of bytes into the variable content. If there are any errors, they will be stored in the <strong class="source-inline">err</strong> variable:<p class="source-code">  fmt.Println("File contents: ")</p><p class="source-code">  fmt.Println(string(content))</p></li>
				<li>Since this is a slice of bytes, it must be converted into a string format for ease of readability. Here are the results of the print statements:</li>
			</ul>
			<div>
				<div id="_idContainer213" class="IMG---Figure">
					<img src="image/B14177_12_14.jpg" alt="Figure 12.14: Example output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.14: Example output</p>
			<p>The next function we will look at that reads the entire content into memory is the following:</p>
			<p class="source-code">func ReadAll(r io.Reader) ([]byte, error)</p>
			<p>Unlike the <strong class="source-inline">ReadFile</strong> method, <strong class="source-inline">ReadAll</strong> takes <strong class="source-inline">io.Reader</strong> as an argument. That is the only real difference in the behavior of <strong class="source-inline">ReadFile</strong> and <strong class="source-inline">ReadAll</strong>:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "io/ioutil"</p>
			<p class="source-code">  "os"</p>
			<p class="source-code">  "strings"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  f, err := os.Open("test.txt")</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">  fmt.Println(err)</p>
			<p class="source-code">  os.Exit(1)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  content, err := ioutil.ReadAll(f)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">  fmt.Println(err)</p>
			<p class="source-code">  os.Exit(1)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Println("File contents: ")</p>
			<p class="source-code">  fmt.Println(string(content))</p>
			<p class="source-code">  r := strings.NewReader("No file here.")</p>
			<p class="source-code">  c, err := ioutil.ReadAll(r)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">  fmt.Println(err)</p>
			<p class="source-code">  os.Exit(1)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Println()</p>
			<p class="source-code">  fmt.Println("Contents of strings.NewReader: ")</p>
			<p class="source-code">  fmt.Println(string(c))</p>
			<p class="source-code">}</p>
			<p>Let's understand the code in pieces:</p>
			<p class="source-code">f, err := os.Open("test.txt")</p>
			<ul>
				<li>The <strong class="source-inline">ioutil.ReadAll</strong> method requires <strong class="source-inline">io.Reader</strong> as an argument. The <strong class="source-inline">os.Open</strong> method returns an <strong class="source-inline">*os.File</strong> type, which satisfies the <strong class="source-inline">io.Reader</strong> interface:<p class="source-code">  content, err := ioutil.ReadAll(f)</p><p class="source-code">  if err != nil {</p><p class="source-code">  fmt.Println(err)</p><p class="source-code">  os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>The content stores the <strong class="source-inline">[]byte</strong> data from the result of the <strong class="source-inline">ioutil.ReadAll(f)</strong> method. If there are any errors, they will be stored in the <strong class="source-inline">err</strong> variable:<p class="source-code">  fmt.Println("File contents: ")</p><p class="source-code">  fmt.Println(string(content))</p></li>
				<li>Since this is a slice of bytes, it must be converted to a string format for ease of readability. The results of the print statements are as follows:</li>
			</ul>
			<div>
				<div id="_idContainer214" class="IMG---Figure">
					<img src="image/B14177_12_15.jpg" alt="Figure 12.15: Example output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.15: Example output</p>
			<p class="source-code">r := strings.NewReader("No file here.")</p>
			<ul>
				<li>Since the <strong class="source-inline">ioutil.ReadAll</strong> method accepts an interface, this gives us more flexibility. If you recall <em class="italic">Chapter 7, Interfaces</em>, when using interfaces, it allows for more flexibility and uses.</li>
				<li>We are using <strong class="source-inline">strings.NewReader</strong>, which takes a string and returns a <strong class="source-inline">Reader</strong> type that implements the <strong class="source-inline">io.Reader</strong> interface. This allows us to use the <strong class="source-inline">ioutil.ReadAll()</strong> method without having a file. By doing this, we can perform various tests on the data when we have not yet been given the file:<p class="source-code">c, err := ioutil.ReadAll(r)</p></li>
				<li>We can use the <strong class="source-inline">ioutil.Readall</strong> method in the same fashion with the results of <strong class="source-inline">strings.Reader()</strong> as we did with <strong class="source-inline">os.Open()</strong>:<p class="source-code">  fmt.Println()</p><p class="source-code">  fmt.Println("Contents of strings.NewReader: ")</p><p class="source-code">  fmt.Println(string(c))</p></li>
				<li>Following are the results of the print statement:</li>
			</ul>
			<div>
				<div id="_idContainer215" class="IMG---Figure">
					<img src="image/Image74026.jpg" alt="Figure 12.16: The strings.NewReader content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.16: The strings.NewReader content</p>
			<p>We have seen various ways to write to files, create files, and to read from files. However, we have yet to see how to append data to a file. There are times when you would want to append a file with additional information.  The <strong class="source-inline">os.OpenFile()</strong> method provides this ability. Most of the time, you will use <strong class="source-inline">Create</strong> or <strong class="source-inline">Open</strong> for your open or create processes; however, when you want to append data to a file, you will need to use <strong class="source-inline">OpenFile</strong>. The signature of the method is as follows:</p>
			<p class="source-code">func OpenFile(name string, flag int, perm FileMode) (*File, error)</p>
			<p>The one parameter that is unique is the <strong class="source-inline">flag</strong> parameter. This is used to determine what actions to allow when opening the file; it is not to be confused with the <strong class="source-inline">FileMode</strong> type, which is what permission types get to assign to the file itself.</p>
			<p>Here is a list of flags that can be used to open a file (<a href="http://golang.org/src/pkg/os/file.go">http://golang.org/src/pkg/os/file.go</a>): </p>
			<p class="source-code">// Flags to OpenFile wrapping those of the underlying system. Not all</p>
			<p class="source-code">// flags may be implemented on a given system.</p>
			<p class="source-code">const (</p>
			<p class="source-code">// Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.</p>
			<p class="source-code">  O_RDONLY int = syscall.O_RDONLY // open the file read-only.</p>
			<p class="source-code">  O_WRONLY int = syscall.O_WRONLY // open the file write-only.</p>
			<p class="source-code">  O_RDWR   int = syscall.O_RDWR   // open the file read-write.</p>
			<p class="source-code">  // The remaining values may be or'ed in to control behavior.</p>
			<p class="source-code">  O_APPEND int = syscall.O_APPEND // append data to the file when writing.</p>
			<p class="source-code">  O_CREATE int = syscall.O_CREAT  // create a new file if none exists.</p>
			<p class="source-code">  O_EXCL   int = syscall.O_EXCL   // used with O_CREATE, file must not exist.</p>
			<p class="source-code">  O_SYNC   int = syscall.O_SYNC   // open for synchronous I/O.</p>
			<p class="source-code">  O_TRUNC  int = syscall.O_TRUNC  // truncate regular writable file when opened.</p>
			<p class="source-code"> )</p>
			<p>These flags can be used in various combinations when opening a file. Let's take a look at some various examples using the flags:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "os"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  f, err := os.OpenFile("junk101.txt", os.O_CREATE, 0644)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">  panic(err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  defer f.Close()</p>
			<p class="source-code">}</p>
			<p>Let's look at <strong class="source-inline">os.OpenFile</strong> in the previous example:</p>
			<p class="source-code">f, err := os.OpenFile("junk101.txt", os.O_CREATE, 0644)</p>
			<ul>
				<li>Using <strong class="source-inline">os.OpenFile</strong> with the <strong class="source-inline">os.O_CREATE</strong> file mode will create the <strong class="source-inline">junk101.txt</strong> file if it does not exist, and then open it.</li>
			</ul>
			<p>Let's look at an example using different file modes for <strong class="source-inline">os.OpenFile</strong>:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "os"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  f, err := os.OpenFile("junk101.txt", os.O_CREATE|os.O_WRONLY, 0644)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">  panic(err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  defer f.Close()</p>
			<p class="source-code">  if _, err := f.Write([]byte("adding stuff\n")); err != nil {</p>
			<p class="source-code">  panic(err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Let's look at the preceding code in more detail.</p>
			<p class="source-code">f, err := os.OpenFile("junk101.txt", os.O_CREATE| os.O_WRONLY, 0644)</p>
			<ul>
				<li>Using <strong class="source-inline">os.OpenFile</strong> with the <strong class="source-inline">os.O_CREATE</strong> flag will create the <strong class="source-inline">junk101.txt</strong> file if it does not exist and then open it. If it does exist, it will just open the file. It will also allow the reading and writing of the file while it is open because of the <strong class="source-inline">os.O_WRONLY</strong> flag:<p class="source-code">  if _, err := f.Write([]byte("adding stuff\n")); err != nil {</p><p class="source-code">  panic(err)</p><p class="source-code">  }</p></li>
				<li>Since we used the <strong class="source-inline">os.O_WRONLY</strong> flag, we can write to the file while it is open.</li>
			</ul>
			<p>Let's look at an example of how to append data to a file:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "os"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  f, err := os.OpenFile("junk.txt", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    panic(err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  defer f.Close()</p>
			<p class="source-code">  if _, err := f.Write([]byte("adding stuff\n")); err != nil {</p>
			<p class="source-code">    panic(err)</p>
			<p class="source-code">  }}</p>
			<p class="source-code">f, err := os.OpenFile("junk101.txt", os.O_APPEND | os.O_CREATE| os.O_WRONLY,   0644)</p>
			<ul>
				<li>Using <strong class="source-inline">os.OpenFile</strong> with the <strong class="source-inline">os.O_CREATE</strong> flag will create the <strong class="source-inline">junk101.txt</strong> file if it does not exist and then open it. If it does exist, it will just open the file:</li>
				<li>It will also allow the reading and writing of the file while it is open because of the <strong class="source-inline">os.O_WRONLY</strong> flag.</li>
				<li><strong class="source-inline">os.O_APPEND</strong> will allow you to append data to the bottom of the file:<p class="source-code">  if _, err := f.Write([]byte("adding stuff\n")); err != nil {</p><p class="source-code">  panic(err)</p><p class="source-code">  }</p></li>
				<li>Since we used the <strong class="source-inline">os.O_WRONLY</strong> flag, we can write to the file while it is open.</li>
			</ul>
			<p>The data will be appended to the bottom of the file and not override the existing data since we included the <strong class="source-inline">os.O_APPEND</strong> flag. The following define some common permission flag combinations that can be used for <strong class="source-inline">os.OpenFile</strong>:</p>
			<p><strong class="bold">os.O_CREATE</strong></p>
			<ul>
				<li>If the file does not exist, it will create the file when attempting to open it.</li>
			</ul>
			<p><strong class="bold">os.O_CREATE | os.O_WRONLY</strong></p>
			<ul>
				<li>When opening a file, you can now write to it.</li>
				<li>Any data that is in the file will be overwritten.</li>
			</ul>
			<p><strong class="bold">os.O_CREATE | os.O_WRONLY | os.O_APPEND</strong></p>
			<ul>
				<li>When writing to the file, it will not overwrite the data but rather append the data to the end of the file.</li>
			</ul>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor322"/>Exercise 12.02: Backing Up Files</h2>
			<p>Oftentimes, when working with files, we need to back up a file before making changes to it. This is for instances where we might make mistakes or want the original file for auditing purposes. In this exercise, we will take an existing file called <strong class="source-inline">note.txt</strong> and back it up to <strong class="source-inline">backupFile.txt</strong>. We will then open <strong class="source-inline">note.txt</strong> and add some additional notes to the end of the file. Our directory will contain the following files:</p>
			<div>
				<div id="_idContainer216" class="IMG---Figure">
					<img src="image/B14177_12_17.jpg" alt="Figure 12.17: Backing up files to the directory&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.17: Backing up files to the directory</p>
			<ol>
				<li value="1">We must first create the <strong class="source-inline">note.txt</strong> file in the same directory as our executable. This file can be blank or contain some sample data such as this:<div id="_idContainer217" class="IMG---Figure"><img src="image/B14177_12_18.jpg" alt="Figure 12.18: Example of the notes.txt file content&#13;&#10;"/></div><p class="figure-caption">Figure 12.18: Example of the notes.txt file content</p></li>
				<li>Create a Go file called <strong class="source-inline">main.go</strong>.</li>
				<li>This program will be part of the <strong class="source-inline">main</strong> package.</li>
				<li>Include the imports, as seen in the following code:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "errors"</p><p class="source-code">  "fmt"</p><p class="source-code">  "io/ioutil"</p><p class="source-code">  "os"</p><p class="source-code">  "strconv"</p><p class="source-code">)</p></li>
				<li>Create a custom error that will be used for when the working file (<strong class="source-inline">note.txt</strong>) is not found:<p class="source-code">var (</p><p class="source-code">  ErrWorkingFileNotFound = errors.New("The working file is not found.")</p><p class="source-code">)</p></li>
				<li>Create a function that will be performing the backup. This function is responsible for taking the working file and storing its content into the <strong class="source-inline">backup</strong> file. This function accepts two arguments. The <strong class="source-inline">working</strong> parameter is the file path of the file that you currently are working on:<p class="source-code">func createBackup(working, backup string) error {</p><p class="source-code">}</p></li>
				<li>Inside this function, we will need to check to see whether the working file exists. It must first exist before we can read its contents and store them in our backup file.</li>
				<li>We are able to check to see whether the error is one where the file does not exist by using <strong class="source-inline">os.IsNotExist(err)</strong>.</li>
				<li>If the file does not exist, we will return with our custom error: <strong class="source-inline">ErrWorkingFileNotFound</strong>:<p class="source-code">  // check to see if our working file exists,</p><p class="source-code">  // before backing it up</p><p class="source-code">  _, err := os.Stat(working)</p><p class="source-code">  if err != nil {</p><p class="source-code">  if os.IsNotExist(err) {</p><p class="source-code">    return ErrWorkingFileNotFound</p><p class="source-code">  }</p><p class="source-code">  return err</p><p class="source-code">  }</p></li>
				<li>Next, we need to open the working file and store the <strong class="source-inline">os.File</strong> return by the function to the <strong class="source-inline">workFile</strong> variable:<p class="source-code">workFile, err := os.Open(working)</p><p class="source-code">  if err != nil {</p><p class="source-code">  return err</p><p class="source-code">  }</p></li>
				<li> We need to read the contents of the <strong class="source-inline">workFile</strong>. We will be using the <strong class="source-inline">ioutil.ReadAll</strong> method to get all the contents of the <strong class="source-inline">workFile</strong>. The <strong class="source-inline">workFile</strong> is of the <strong class="source-inline">os.File</strong> type, which satisfies the <strong class="source-inline">io.Reader</strong> interface; this allows us to pass it to <strong class="source-inline">ioutil.ReadFile</strong>.</li>
				<li>Check to see whether there is an error:<p class="source-code">  content, err := ioutil.ReadAll(workFile)</p><p class="source-code">  if err != nil {</p><p class="source-code">  return err</p><p class="source-code">  }</p></li>
				<li>The <strong class="source-inline">content</strong> variable contains the data of the <strong class="source-inline">workFile</strong> represented as a slice of bytes. That data needs to be written to the backup file. We will implement the code that will write the data of the <strong class="source-inline">content</strong> variable to the backup file.</li>
				<li>The content stores the <strong class="source-inline">[]byte</strong> data that gets returned from the function. This is the entire content of the file stored in the variable.</li>
				<li>We can use the <strong class="source-inline">ioutil.Writefile</strong> method. If the backup file does not exist, it will create the file. If the backup file does exist, it will overwrite the file with the content variable data:<p class="source-code">  err = ioutil.WriteFile(backup, content, 0644)</p><p class="source-code">  if err != nil {</p><p class="source-code">  fmt.Println(err)</p><p class="source-code">  }</p></li>
				<li>We need to return <strong class="source-inline">nil</strong>, indicating that, at this juncture, we have not encountered any errors:<p class="source-code">  return nil</p><p class="source-code">}</p></li>
				<li>Create a function that will append data to our working file.</li>
				<li>Name the function <strong class="source-inline">addNotes</strong>; this will accept the location of our working file and a string argument that will be appended to the working file. The function will need to return an error:<p class="source-code">func addNotes(workingFile, notes string) error {</p><p class="source-code">//…</p><p class="source-code">  return nil</p><p class="source-code">}</p></li>
				<li>Inside the <strong class="source-inline">addNotes</strong> function, add a line that will append a new line to each note's string. This will place each note on a separate line:<p class="source-code">func addNotes(workingFile, notes string) error {</p><p class="source-code">  notes += "\n"</p><p class="source-code">  //…</p><p class="source-code">  return nil</p><p class="source-code">}</p></li>
				<li>Next, we will open the working file and allow for appending to the file. The <strong class="source-inline">os.OpenFile()</strong> function will create the file if it does not exist. Check for any errors:<p class="source-code">func addNotes(workingFile, notes string) error {</p><p class="source-code">  notes += "\n"</p><p class="source-code">  f, err := os.OpenFile(workingFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)</p><p class="source-code">  if err != nil {</p><p class="source-code">  return err</p><p class="source-code">  }</p><p class="source-code">// …</p><p class="source-code">  return nil</p><p class="source-code">}</p></li>
				<li>After opening a file and checking for an error, we should make sure that it closes when the function exits by using the defer function, <strong class="source-inline">f.Close()</strong>:<p class="source-code">func addNotes(workingFile, notes string) error {</p><p class="source-code">  notes += "\n"</p><p class="source-code">  f, err := os.OpenFile(workingFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)</p><p class="source-code">  if err != nil {</p><p class="source-code">  return err</p><p class="source-code">  }</p><p class="source-code">  defer f.Close()</p><p class="source-code">//…</p><p class="source-code">  return nil</p><p class="source-code">}</p></li>
				<li>The final step of the function is to write the contents of the note to the <strong class="source-inline">workingFile</strong> variable. We can use the <strong class="source-inline">Write</strong> method to accomplish this:<p class="source-code">func addNotes(workingFile, notes string) error {</p><p class="source-code">  notes += "\n"</p><p class="source-code">  f, err := os.OpenFile(workingFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)</p><p class="source-code">  if err != nil {</p><p class="source-code">  return err</p><p class="source-code">  }</p><p class="source-code">  defer f.Close()</p><p class="source-code">  if _, err := f.Write([]byte(notes)); err != nil {</p><p class="source-code">  return err</p><p class="source-code">  }</p><p class="source-code">  return nil</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, we will initialize three variables; the <strong class="source-inline">backupFile</strong> variable contains the name of the file for backing up our <strong class="source-inline">workingFile</strong> variable, while the <strong class="source-inline">data</strong> variable is what we will be writing to our <strong class="source-inline">workingFile</strong> variable:<p class="source-code">func main() {</p><p class="source-code">  backupFile := "backupFile.txt"</p><p class="source-code">  workingFile := "note.txt"</p><p class="source-code">  data := "note"</p></li>
				<li>Call our <strong class="source-inline">createBackup()</strong> function to back up our <strong class="source-inline">workingFile</strong>. Check for errors after calling the function:<p class="source-code">  err := createBackup(workingFile, backupFile)</p><p class="source-code">  if err != nil {</p><p class="source-code">  fmt.Println(err)</p><p class="source-code">  os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>Create a <strong class="source-inline">for</strong> loop that will iterate <strong class="source-inline">10</strong> times.</li>
				<li>Each iteration we set our <strong class="source-inline">note</strong> variable to the <strong class="source-inline">data</strong> variable plus the <strong class="source-inline">i</strong> variable of our loop.</li>
				<li>Since our <strong class="source-inline">note</strong> variable is a string and our <strong class="source-inline">i</strong> variable is an <strong class="source-inline">int</strong>, we will need to convert <strong class="source-inline">i</strong> to a string using the <strong class="source-inline">strconv.Itoa(i)</strong> method.</li>
				<li>Call our <strong class="source-inline">addNotes()</strong> function and pass the <strong class="source-inline">workingFile</strong> and our <strong class="source-inline">note</strong> variables.</li>
				<li>Check for any errors returned from the function:<p class="source-code">  for i := 1; i &lt;= 10; i++ {</p><p class="source-code">  note := data + " " + strconv.Itoa(i)</p><p class="source-code">  err := addNotes(workingFile, note)</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Run the program:<p class="source-code">go run main.go</p></li>
				<li>Evaluate the changes to the files after running the program.<p>Following are the results after running the program:</p><div id="_idContainer218" class="IMG---Figure"><img src="image/B14177_12_19.jpg" alt="Figure 12.19: The results of backing up the files&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 12.19: The results of backing up the files</p>
			<h1 id="_idParaDest-305"><a id="_idTextAnchor323"/>CSV</h1>
			<p>One of the most common ways a file is structured is as a comma-separated value. This is a clear text file that contains data, which is basically represented as rows and columns. Frequently, these files are used to exchange data. A CSV file has a simple structure. Each piece of data is separated by a comma and then a new line for another record. An example of a CSV file would be as follows:</p>
			<p class="source-code">firstName, lastName, age</p>
			<p class="source-code">Celina, Jones, 18</p>
			<p class="source-code">Cailyn, Henderson, 13 </p>
			<p class="source-code">Cayden, Smith, 42</p>
			<ul>
				<li>You will, at some point in your life, come across CSV files as they are very common. The Go programming language has a standard library that is used for handling CSV files: <strong class="source-inline">encoding/csv</strong>:</li>
			</ul>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "encoding/csv"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "io"</p>
			<p class="source-code">  "log"</p>
			<p class="source-code">  "strings"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  in := `firstName, lastName, age</p>
			<p class="source-code">Celina, Jones, 18</p>
			<p class="source-code">Cailyn, Henderson, 13 </p>
			<p class="source-code">Cayden, Smith, 42</p>
			<p class="source-code">`</p>
			<p class="source-code">  r := csv.NewReader(strings.NewReader(in))</p>
			<p class="source-code">  for {</p>
			<p class="source-code">  record, err := r.Read()</p>
			<p class="source-code">  if err == io.EOF {</p>
			<p class="source-code">    break</p>
			<p class="source-code">  }</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    log.Fatal(err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Println(record)</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The following creates a <strong class="source-inline">reader</strong> type and returns it:</p>
			<p class="source-code">r := csv.NewReader(strings.NewReader(in))</p>
			<p>The <strong class="source-inline">NewReader</strong> method takes an argument of <strong class="source-inline">io.Reader</strong> and returns a type of <strong class="source-inline">Reader</strong> that is used to read the CSV data:</p>
			<p class="source-code">for {</p>
			<p class="source-code">  record, err := r.Read()</p>
			<p class="source-code">  if err == io.EOF {</p>
			<p class="source-code">    break</p>
			<p class="source-code">  }</p>
			<p>Here, we are reading in each record one at a time in an infinite loop. After each record we read, we check first to see whether it is the end of the file (<strong class="source-inline">io.EOF</strong>); if so, we break out of the loop. The <strong class="source-inline">r.Read()</strong> function reads one record; it is a slice of strings from the <strong class="source-inline">r</strong> variable. It returns that record as a <strong class="source-inline">[]string</strong> type.</p>
			<p>Here is the result of printing the record:</p>
			<div>
				<div id="_idContainer219" class="IMG---Figure">
					<img src="image/B14177_12_20.jpg" alt="Figure 12.20: CSV example output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.20: CSV example output</p>
			<p>Do you think there might be a way to access each individual value? Currently, we have only looked at printing out of each row. There are instances, however, where we might want to access just the age or the first name. The next example will show us just how to do that:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "encoding/csv"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "io"</p>
			<p class="source-code">  "log"</p>
			<p class="source-code">  "strings"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  in := `firstName, lastName, age</p>
			<p class="source-code">Celina, Jones, 18</p>
			<p class="source-code">Cailyn, Henderson, 13 </p>
			<p class="source-code">Cayden, Smith, 42</p>
			<p class="source-code">`</p>
			<p class="source-code">  r := csv.NewReader(strings.NewReader(in))</p>
			<p class="source-code">  header := true</p>
			<p class="source-code">  for {</p>
			<p class="source-code">  record, err := r.Read()</p>
			<p class="source-code">  if err == io.EOF {</p>
			<p class="source-code">    break</p>
			<p class="source-code">  }</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    log.Fatal(err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  if !header {</p>
			<p class="source-code">    for idx, value := range record {</p>
			<p class="source-code">    switch idx {</p>
			<p class="source-code">    case 0:</p>
			<p class="source-code">      fmt.Println("First Name: ", value)</p>
			<p class="source-code">    case 1:</p>
			<p class="source-code">      fmt.Println("Last Name: ", value)</p>
			<p class="source-code">    case 2:</p>
			<p class="source-code">      fmt.Println("Age: ", value)</p>
			<p class="source-code">    }</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">  header = false</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>We will discuss the new portions of the code in this example:</p>
			<p><strong class="source-inline">header := true</strong></p>
			<p>We will use the <strong class="source-inline">header</strong> variable as a flag. It will aid us in parsing the headers of the CSV data:</p>
			<p class="source-code">  for {</p>
			<p>The infinite loop will stop once the end of the file is reached:</p>
			<p class="source-code">  record, err := r.Read()</p>
			<p class="source-code">  if err == io.EOF {</p>
			<p>The <strong class="source-inline">r.Read()</strong> function reads a single record and returns a slice of strings that contains the fields of that record:</p>
			<p class="source-code">    break</p>
			<p class="source-code">  }</p>
			<p class="source-code">  // Code omitted for brevity  </p>
			<p>This breaks out of the infinite loop if it is the end of the file.</p>
			<p class="source-code">  if !header {</p>
			<p>Next, check to see whether this is the first iteration of the loop. If this is the first iteration of the loop, then the first row would be the headers of the fields; we do not want to parse the headers:</p>
			<p class="source-code">    for idx, value := range record {</p>
			<p>Range over the fields in the record:</p>
			<p class="source-code">    switch idx {  </p>
			<p class="source-code">    }</p>
			<p>The <strong class="source-inline">switch</strong> statement is used to perform the specific parsing of each field:</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">  header = false</p>
			<p class="source-code">  }</p>
			<p>Initially set to <strong class="source-inline">true</strong>, after the first time through the loop, it can be set to <strong class="source-inline">false</strong>. Headers are usually the first row of the file.</p>
			<p>The output is as follows:</p>
			<div>
				<div id="_idContainer220" class="IMG---Figure">
					<img src="image/B14177_12_21.jpg" alt="Figure 12.21: Output of parsing CSV fields&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.21: Output of parsing CSV fields</p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor324"/>Activity 12.01: Parsing Bank Transaction Files</h2>
			<p>In this activity, we will be ingesting a transaction file from the bank. The file is a CSV file. Our bank also includes budget categories for the transactions in the file. The file is as follows:</p>
			<p class="source-code">id,payee,spent,category</p>
			<p class="source-code">1, sheetz, 32.45, fuel</p>
			<p class="source-code">2, martins,225.52,food</p>
			<p class="source-code">3, wells fargo, 1100, mortgage</p>
			<p class="source-code">4, joe the plumber, 275, repairs</p>
			<p class="source-code">5, comcast, 110, tv</p>
			<p class="source-code">6, bp, 40, fuel</p>
			<p class="source-code">7, aldi, 120, food</p>
			<p class="source-code">8, nationwide, 150, car insurance</p>
			<p class="source-code">9, nationwide, 100, life insurance</p>
			<p class="source-code">10, jim electric, 140, utilities</p>
			<p class="source-code">11, propane, 200, utilities</p>
			<p class="source-code">12, county water, 100, utilities</p>
			<p class="source-code">13, county sewer, 105, utilities</p>
			<p class="source-code">14, 401k, 500, retirement</p>
			<p>The aim of this activity is to create a command-line program that will accept two flags: the location of the CSV bank transaction file and the location of a log file. We will check that the log and bank file location is valid before the application starts parsing the CSV file. The program will parse the CSV file and log any errors it encounters to the log. Upon each restart of the program, it will also delete the previous log file.</p>
			<p>Follow these steps to complete the activity:</p>
			<ol>
				<li value="1">We will need to create budget category types for <strong class="source-inline">fuel</strong>, <strong class="source-inline">food</strong>, <strong class="source-inline">mortgage</strong>, <strong class="source-inline">repairs</strong>, <strong class="source-inline">insurance</strong>, <strong class="source-inline">utilities</strong>, and <strong class="source-inline">retirement</strong>.</li>
				<li>Create a custom error for when a budget category is not found.</li>
				<li>Create a struct type transaction that has <strong class="source-inline">ID</strong>, <strong class="source-inline">payee</strong>, <strong class="source-inline">spent</strong>, and <strong class="source-inline">category</strong> fields (the type is what we created in the first step).</li>
				<li>Create a function that will accept the category from the bank transaction file. This function will map the transaction categories to our categories. Mappings include <strong class="source-inline">fuel</strong> and <strong class="source-inline">gas</strong> maps to <strong class="source-inline">autoFuel</strong>, <strong class="source-inline">food</strong> maps to <strong class="source-inline">food</strong>, <strong class="source-inline">mortgage</strong> maps to <strong class="source-inline">mortgage</strong>, <strong class="source-inline">repairs</strong> map to <strong class="source-inline">repairs</strong>, <strong class="source-inline">car</strong> <strong class="source-inline">insurance</strong> and <strong class="source-inline">life</strong> <strong class="source-inline">insurance</strong> maps to <strong class="source-inline">insurance</strong>, <strong class="source-inline">utilities</strong> maps to <strong class="source-inline">utilities</strong>, and everything else will return the custom error that we created in the previous step. The function will return our <strong class="source-inline">budgetCategory</strong> type and an error.</li>
				<li>Create a <strong class="source-inline">writeErrorToLog(msg string, err error, data string, logfile string) error.</strong> function. This will take the <strong class="source-inline">msg</strong>, <strong class="source-inline">err</strong>, and <strong class="source-inline">data</strong> strings and write them to the log file.</li>
				<li>Create a function with the following signature: <strong class="source-inline">parseBankFile(bankTransactions io.Reader, logFile string) []transaction</strong>. This function will iterate over the <strong class="source-inline">bankTransaction</strong> file.As it is looping, use a <strong class="source-inline">switch</strong> statement and examine the index of the record.<p>Each <strong class="source-inline">case</strong> statement assigns the value of the index to the respective value of the <strong class="source-inline">transaction</strong> struct.When the case statement index matches the category of the CSV file, we need to call our <strong class="source-inline">convertToBudgeCategory()</strong>. This will map the bank transaction to our budget category. </p></li>
				<li>In the <strong class="source-inline">main()</strong> function, we need two <strong class="source-inline">c</strong> flags for the transaction file and <strong class="source-inline">l</strong> for the location of the log file.</li>
				<li>The bank transaction file and log file are required, so you must ensure they are present before continuing.</li>
				<li>You will then call the <strong class="source-inline">parsBankFile()</strong> function and print the <strong class="source-inline">[]transactions</strong> that gets returned from the function.<p>The following is the output:</p></li>
			</ol>
			<div>
				<div id="_idContainer221" class="IMG---Figure">
					<img src="image/B14177_12_22.jpg" alt="Figure 12.22: Format of the transaction file&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.22: Format of the transaction file</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 737.</p>
			<p>In this activity, we created a command-line application that accepted flags. We also configured our command-line application to require those flags. In this command-line application, we created and modified files. We also parsed a common file format used in system programming, the comma-separated value (CSV) file. We were able to read from the file and store the data in the file in our various struct types. We were able to continue to process the CSV file when we encountered an error. When we encountered an error, we wrote to a log file for later debugging. This command-line application demonstrated real-world activities that are generally done in programming command-line applications (such as accepting flags, requiring flags, parsing a file such as CSV, modifying and creating files, and logging).</p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor325"/>Summary</h1>
			<p>In this chapter, we gained an understanding of how Go views and uses file permissions. We learned that file permissions can be represented as symbolic and octal notations. We discovered that the Go standard library has built-in support for opening, reading, writing, creating, deleting, and appending data to a file. We looked at the <strong class="source-inline">flag</strong> package and how it provides functionality to create command-line applications to accept arguments.</p>
			<p>Using the <strong class="source-inline">flag</strong> package, we could also print out <strong class="source-inline">usage</strong> statements that pertained to our command-line application.</p>
			<p>Then, we demonstrated how OS signals can impact our Go program; however, by using the Go standard library, we can capture OS signals and, if applicable, control how we want to exit our program.</p>
			<p>We also learned that Go has a standard library for working with CSV files. In working with files previously, we saw that we can also work with files that are structured as CSV files. That Go CSV package provides the ability to iterate over the contents of the file. The CSV file can be viewed as rows and columns similar to database tables. In the next chapter, we will look at how to connect to databases and execute SQL statements against a database. This will demonstrate the ability of Go to be used for applications that require a backend for storing data.</p>
		</div>
	</body></html>