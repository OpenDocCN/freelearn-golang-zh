["```go\nfunc Bool(name string, value bool, usage string) *bool\nfunc Duration(name string, value time.Duration, usage string) *time.Duration\nfunc Float64(name string, value float64, usage string) *float64\nfunc Int(name string, value int, usage string) *int\nfunc Int64(name string, value int64, usage string) *int64\nfunc String(name string, value string, usage string) *string\nfunc Uint(name string, value uint, usage string) *uint\nfunc Uint64(name string, value uint64, usage string) *uint64\n```", "```go\n    app.exe -file\n    ```", "```go\npackage main\nimport (\n  \"flag\"\n  \"fmt\"\n)\nfunc main() {\n  v := flag.Int(\"value\", -1, \"Needs a value for the flag.\")\n  flag.Parse()\n  fmt.Println(*v)\n}\n```", "```go\n    flag.Parse()\n    ```", "```go\npackage main\nimport (\n  \"flag\"\n  \"fmt\"\n)\nfunc main() {\n  i := flag.Int(\"age\", -1, \"your age\")\n  n := flag.String(\"name\", \"\", \"your first name\")\n  b := flag.Bool(\"married\", false, \"are you married?\")\n  flag.Parse()\n  fmt.Println(\"Name: \", *n)\n  fmt.Println(\"Age: \", *i)\n  fmt.Println(\"Married: \", *b)\n}\n```", "```go\n    Name:  \n    Age:  -1\n    Married:  false\n    ```", "```go\n    Usage of ./exFlag:\n      -age int\n        your age (default -1)\n      -married\n        are you married?\n      -name string\n        your first name\n    ```", "```go\n    Name:  John\n    Age:  42\n    Married:  false\n    ```", "```go\npackage main\nimport (\n  \"flag\"\n  \"fmt\"\n  \"os\"\n)\nfunc main() {\n  i := flag.Int(\"age\", -1, \"your age\")\n  n := flag.String(\"name\", \"\", \"your first name\")\n  b := flag.Bool(\"married\", false, \"are you married?\")\n  flag.Parse()\n  if *n == \"\" {\n  fmt.Println(\"Name is required.\")\n  flag.PrintDefaults()\n  os.Exit(1)\n  }\n  fmt.Println(\"Name: \", *n)\n  fmt.Println(\"Age: \", *i)\n  fmt.Println(\"Married: \", *b)\n  if *n == \"\" {\n  fmt.Println(\"Name is required.\")\n  flag.PrintDefaults()\n  os.Exit(1)\n  }\n}\n```", "```go\nName is required.\n  -age int\n    your age (default -1)\n  -married\n    are you married?\n  -name string\n    your first name\n```", "```go\nfunc Notify(c chan<- os.Signal, sig ...os.Signal)\n```", "```go\npackage main\nimport (\n  \"fmt\"\n  \"os\"\n  \"os/signal\"\n  \"syscall\"\n)\nfunc main() {\n  sigs := make(chan os.Signal, 1)\n  done := make(chan bool)\n  signal.Notify(sigs,syscall.SIGINT)\n  go func() {\n  for {\n    s := <-sigs\n    switch s {\n    case syscall.SIGINT:\n    fmt.Println()\n    fmt.Println(\"My process has been interrupted.  Someone might of pressed CTRL-  C\")\n    fmt.Println(\"Some clean up is occuring\")\n    done <- true    \n    }\n  }\n  }()\n  fmt.Println(\"Program is blocked until a signal is caught\")\n  <-done\n  fmt.Println(\"Out of here\")\n}\n```", "```go\n    sigs := make(chan os.Signal, 1)\n    ```", "```go\n    done := make(chan bool)\n    ```", "```go\n    signal.Notify(sigs,syscall.SIGINT)\n    ```", "```go\n      go func() {\n      for {\n        s := <-sigs\n        switch s {\n        case syscall.SIGINT:\n        fmt.Println(\"My process has been interrupted.  Someone might of pressed   CTRL-C\")\n        fmt.Println(\"Some clean up is occurring\")\n        done <- true    \n        }\n      }\n    ```", "```go\n      fmt.Println(\"Program is blocked until a signal is caught\")\n      <-done\n      fmt.Println(\"Out of here\")\n    ```", "```go\n    Program is blocked until a signal is caught\n    ^C\n    My process has been interrupted.  Someone might of pressed CTRL-C\n    Some clean up is occurring\n    Out of here\n    ```", "```go\n    package main\n    import (\n      \"fmt\"\n      \"os\"\n      \"os/signal\"\n      \"syscall\"\n      \"time\"\n    )\n    ```", "```go\n    func main() {\n      sigs := make(chan os.Signal, 1)\n    ```", "```go\n      done := make(chan bool)\n    ```", "```go\n      signal.Notify(sigs, syscall.SIGINT, syscall.SIGTSTP)\n    ```", "```go\n      go func() {\n    ```", "```go\n        for {\n          s := <-sigs\n    ```", "```go\n          switch s {\n          case syscall.SIGINT:\n            fmt.Println()\n            fmt.Println(\"My process has been interrupted.  Someone might of pressed CTRL-C\")\n            fmt.Println(\"Some clean up is occuring\")\n            cleanUp()\n            done <- true\n          case syscall.SIGTSTP:\n            fmt.Println()\n            fmt.Println(\"Someone pressed CTRL-Z\")\n            fmt.Println(\"Some clean up is occuring\")\n            cleanUp()\n            done <- true\n          }\n        }\n      }()\n      fmt.Println(\"Program is blocked until a signal is caught(ctrl-z, ctrl-c)\")\n      <-done\n      fmt.Println(\"Out of here\")\n    }\n    ```", "```go\n    func cleanUp() {\n      fmt.Println(\"Simulating clean up\")\n      for i := 0; i <= 10; i++ {\n        fmt.Println(\"Deleting Files.. Not really.\", i)\n        time.Sleep(1 * time.Second)\n      }\n    }\n    ```", "```go\n    go run main.go\n    ```", "```go\nfunc Create(name string(*File, error)\n```", "```go\npackage main\nimport (\n  \"fmt\"\n  \"os\"\n)\nfunc main() {\n  f, err := os.Create(\"test.txt\")\n  if err != nil {\n  panic(err)\n  }\n  defer f.Close()\n}\n```", "```go\n    f, err := os.Create(\"test.txt\")\n    ```", "```go\n      if err != nil {\n      fmt.Println(err)\n      }\n    ```", "```go\n    open /lol/test.txt: no such file or directory\n    ```", "```go\n    package main\n    import (\n      \"os\"\n    )\n    func main() {\n      f, err := os.Create(\"test.txt\")\n      if err != nil {\n      panic(err)\n      }\n      defer f.Close()\n      f.Write([]byte(\"Using Write function.\\n\"))\n      f.WriteString(\"Using Writestring function.\\n\")\n    }\n    ```", "```go\n    func (f *File) Write(b []byte) (n int, err error)\n    ```", "```go\n    f.Write([]byte(\"Using Write function.\\n\"))\n    ```", "```go\n    f.WriteString(\"Using Writestring function.\\n\")\n    ```", "```go\n    func WriteFile(filename string, data []byte, perm os.FileMode) error\n    ```", "```go\n    package main\n    import (\n      \"fmt\"\n      \"io/ioutil\"\n    )\n    func main() {\n      message := []byte(\"Look!\")\n      err := ioutil.WriteFile(\"test.txt\", message, 0644)\n      if err != nil {\n        fmt.Println(err)\n      }\n    }\n    ```", "```go\n    err := ioutil.WriteFile(\"test.txt\", message, 0644)\n    ```", "```go\njunk.txt file to not exist. It also requires the test.txt file to exist in the same directory as the program's executable.\npackage main\nimport (\n  \"fmt\"\n  \"os\"\n)\nfunc main() {\n  file, err := os.Stat(\"junk.txt\")\n  if err != nil {\n  if os.IsNotExist((err)) {\n    fmt.Println(\"junk.txt:  File does not exist!\")\n    fmt.Println(file)\n  }\n  }\n  fmt.Println()\n  file, err = os.Stat(\"test.txt\")\n  if err != nil {\n  if os.IsNotExist((err)) {\n    fmt.Println(\"test.txt:  File does not exist!\")\n  }\n  }\n  fmt.Printf(\"file name: %s\\nIsDir: %t\\nModTime: %v\\nMode: %v\\nSize: %d\\n\", file.Name(), file.IsDir(), file.ModTime(), file.Mode(), file.Size())\n}\n```", "```go\nfile, err := os.Stat(\"junk.txt\")\n```", "```go\n      if err != nil {\n      if os.IsNotExist((err)) {\n        fmt.Println(\"junk.txt:  File does not exist!\")\n        fmt.Prinln(file)\n      }\n      }\n    ```", "```go\n    IsNotExist returns a boolean indicating whether the error is known to report that a file or a directory does not exist. It is satisfied by ErrNotExist as well as some syscall errors.\n    func os.IsNotExist(err error) bool\n    ```", "```go\n    file, err = os.Stat(\"test.txt\")\n    ```", "```go\n      fmt.Printf(\"file name: %s\\nIsDir: %t\\nModTime: %v\\nMode: %v\\nSize: %d\\n\",     file.Name(), file.IsDir(), file.ModTime(), file.Mode(), file.Size())\n    }\n    ```", "```go\n    // A FileInfo describes a file and is returned by Stat and Lstat.\n      type FileInfo interface {\n      Name() string     // base name of the file\n      Size() int64    // length in bytes for regular files; system-dependent for others\n      Mode() FileMode   // file mode bits\n      ModTime() time.Time // modification time\n      IsDir() bool    // abbreviation for Mode().IsDir()\n      Sys() interface{}   // underlying data source (can return nil)\n      }\n    ```", "```go\nfunc ReadFile(filename string) ([]byte, error)\n```", "```go\n    package main\n    import (\n      \"fmt\"\n      \"io/ioutil\"\n    )\n    func main() {\n      content, err := ioutil.ReadFile(\"test.txt\")\n      if err != nil {\n      fmt.Println(err)\n      }\n      fmt.Println(\"File contents: \")\n      fmt.Println(string(content))\n    }\n    ```", "```go\ncontent, err := ioutil.ReadFile(\"test.txt\")\n```", "```go\n      fmt.Println(\"File contents: \")\n      fmt.Println(string(content))\n    ```", "```go\nfunc ReadAll(r io.Reader) ([]byte, error)\n```", "```go\npackage main\nimport (\n  \"fmt\"\n  \"io/ioutil\"\n  \"os\"\n  \"strings\"\n)\nfunc main() {\n  f, err := os.Open(\"test.txt\")\n  if err != nil {\n  fmt.Println(err)\n  os.Exit(1)\n  }\n  content, err := ioutil.ReadAll(f)\n  if err != nil {\n  fmt.Println(err)\n  os.Exit(1)\n  }\n  fmt.Println(\"File contents: \")\n  fmt.Println(string(content))\n  r := strings.NewReader(\"No file here.\")\n  c, err := ioutil.ReadAll(r)\n  if err != nil {\n  fmt.Println(err)\n  os.Exit(1)\n  }\n  fmt.Println()\n  fmt.Println(\"Contents of strings.NewReader: \")\n  fmt.Println(string(c))\n}\n```", "```go\nf, err := os.Open(\"test.txt\")\n```", "```go\n      content, err := ioutil.ReadAll(f)\n      if err != nil {\n      fmt.Println(err)\n      os.Exit(1)\n      }\n    ```", "```go\n      fmt.Println(\"File contents: \")\n      fmt.Println(string(content))\n    ```", "```go\nr := strings.NewReader(\"No file here.\")\n```", "```go\n    c, err := ioutil.ReadAll(r)\n    ```", "```go\n      fmt.Println()\n      fmt.Println(\"Contents of strings.NewReader: \")\n      fmt.Println(string(c))\n    ```", "```go\nfunc OpenFile(name string, flag int, perm FileMode) (*File, error)\n```", "```go\n// Flags to OpenFile wrapping those of the underlying system. Not all\n// flags may be implemented on a given system.\nconst (\n// Exactly one of O_RDONLY, O_WRONLY, or O_RDWR must be specified.\n  O_RDONLY int = syscall.O_RDONLY // open the file read-only.\n  O_WRONLY int = syscall.O_WRONLY // open the file write-only.\n  O_RDWR   int = syscall.O_RDWR   // open the file read-write.\n  // The remaining values may be or'ed in to control behavior.\n  O_APPEND int = syscall.O_APPEND // append data to the file when writing.\n  O_CREATE int = syscall.O_CREAT  // create a new file if none exists.\n  O_EXCL   int = syscall.O_EXCL   // used with O_CREATE, file must not exist.\n  O_SYNC   int = syscall.O_SYNC   // open for synchronous I/O.\n  O_TRUNC  int = syscall.O_TRUNC  // truncate regular writable file when opened.\n )\n```", "```go\npackage main\nimport (\n  \"os\"\n)\nfunc main() {\n  f, err := os.OpenFile(\"junk101.txt\", os.O_CREATE, 0644)\n  if err != nil {\n  panic(err)\n  }\n  defer f.Close()\n}\n```", "```go\nf, err := os.OpenFile(\"junk101.txt\", os.O_CREATE, 0644)\n```", "```go\npackage main\nimport (\n  \"os\"\n)\nfunc main() {\n  f, err := os.OpenFile(\"junk101.txt\", os.O_CREATE|os.O_WRONLY, 0644)\n  if err != nil {\n  panic(err)\n  }\n  defer f.Close()\n  if _, err := f.Write([]byte(\"adding stuff\\n\")); err != nil {\n  panic(err)\n  }\n}\n```", "```go\nf, err := os.OpenFile(\"junk101.txt\", os.O_CREATE| os.O_WRONLY, 0644)\n```", "```go\n      if _, err := f.Write([]byte(\"adding stuff\\n\")); err != nil {\n      panic(err)\n      }\n    ```", "```go\npackage main\nimport (\n  \"os\"\n)\nfunc main() {\n  f, err := os.OpenFile(\"junk.txt\", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n  if err != nil {\n    panic(err)\n  }\n  defer f.Close()\n  if _, err := f.Write([]byte(\"adding stuff\\n\")); err != nil {\n    panic(err)\n  }}\nf, err := os.OpenFile(\"junk101.txt\", os.O_APPEND | os.O_CREATE| os.O_WRONLY,   0644)\n```", "```go\n      if _, err := f.Write([]byte(\"adding stuff\\n\")); err != nil {\n      panic(err)\n      }\n    ```", "```go\n    package main\n    import (\n      \"errors\"\n      \"fmt\"\n      \"io/ioutil\"\n      \"os\"\n      \"strconv\"\n    )\n    ```", "```go\n    var (\n      ErrWorkingFileNotFound = errors.New(\"The working file is not found.\")\n    )\n    ```", "```go\n    func createBackup(working, backup string) error {\n    }\n    ```", "```go\n      // check to see if our working file exists,\n      // before backing it up\n      _, err := os.Stat(working)\n      if err != nil {\n      if os.IsNotExist(err) {\n        return ErrWorkingFileNotFound\n      }\n      return err\n      }\n    ```", "```go\n    workFile, err := os.Open(working)\n      if err != nil {\n      return err\n      }\n    ```", "```go\n      content, err := ioutil.ReadAll(workFile)\n      if err != nil {\n      return err\n      }\n    ```", "```go\n      err = ioutil.WriteFile(backup, content, 0644)\n      if err != nil {\n      fmt.Println(err)\n      }\n    ```", "```go\n      return nil\n    }\n    ```", "```go\n    func addNotes(workingFile, notes string) error {\n    //…\n      return nil\n    }\n    ```", "```go\n    func addNotes(workingFile, notes string) error {\n      notes += \"\\n\"\n      //…\n      return nil\n    }\n    ```", "```go\n    func addNotes(workingFile, notes string) error {\n      notes += \"\\n\"\n      f, err := os.OpenFile(workingFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n      if err != nil {\n      return err\n      }\n    // …\n      return nil\n    }\n    ```", "```go\n    func addNotes(workingFile, notes string) error {\n      notes += \"\\n\"\n      f, err := os.OpenFile(workingFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n      if err != nil {\n      return err\n      }\n      defer f.Close()\n    //…\n      return nil\n    }\n    ```", "```go\n    func addNotes(workingFile, notes string) error {\n      notes += \"\\n\"\n      f, err := os.OpenFile(workingFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n      if err != nil {\n      return err\n      }\n      defer f.Close()\n      if _, err := f.Write([]byte(notes)); err != nil {\n      return err\n      }\n      return nil\n    }\n    ```", "```go\n    func main() {\n      backupFile := \"backupFile.txt\"\n      workingFile := \"note.txt\"\n      data := \"note\"\n    ```", "```go\n      err := createBackup(workingFile, backupFile)\n      if err != nil {\n      fmt.Println(err)\n      os.Exit(1)\n      }\n    ```", "```go\n      for i := 1; i <= 10; i++ {\n      note := data + \" \" + strconv.Itoa(i)\n      err := addNotes(workingFile, note)\n      if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n      }\n      }\n    }\n    ```", "```go\n    go run main.go\n    ```", "```go\nfirstName, lastName, age\nCelina, Jones, 18\nCailyn, Henderson, 13 \nCayden, Smith, 42\n```", "```go\npackage main\nimport (\n  \"encoding/csv\"\n  \"fmt\"\n  \"io\"\n  \"log\"\n  \"strings\"\n)\nfunc main() {\n  in := `firstName, lastName, age\nCelina, Jones, 18\nCailyn, Henderson, 13 \nCayden, Smith, 42\n`\n  r := csv.NewReader(strings.NewReader(in))\n  for {\n  record, err := r.Read()\n  if err == io.EOF {\n    break\n  }\n  if err != nil {\n    log.Fatal(err)\n  }\n  fmt.Println(record)\n  }\n}\n```", "```go\nr := csv.NewReader(strings.NewReader(in))\n```", "```go\nfor {\n  record, err := r.Read()\n  if err == io.EOF {\n    break\n  }\n```", "```go\npackage main\nimport (\n  \"encoding/csv\"\n  \"fmt\"\n  \"io\"\n  \"log\"\n  \"strings\"\n)\nfunc main() {\n  in := `firstName, lastName, age\nCelina, Jones, 18\nCailyn, Henderson, 13 \nCayden, Smith, 42\n`\n  r := csv.NewReader(strings.NewReader(in))\n  header := true\n  for {\n  record, err := r.Read()\n  if err == io.EOF {\n    break\n  }\n  if err != nil {\n    log.Fatal(err)\n  }\n  if !header {\n    for idx, value := range record {\n    switch idx {\n    case 0:\n      fmt.Println(\"First Name: \", value)\n    case 1:\n      fmt.Println(\"Last Name: \", value)\n    case 2:\n      fmt.Println(\"Age: \", value)\n    }\n    }\n  }\n  header = false\n  }\n}\n```", "```go\n  for {\n```", "```go\n  record, err := r.Read()\n  if err == io.EOF {\n```", "```go\n    break\n  }\n  // Code omitted for brevity  \n```", "```go\n  if !header {\n```", "```go\n    for idx, value := range record {\n```", "```go\n    switch idx {  \n    }\n```", "```go\n    }\n  }\n  header = false\n  }\n```", "```go\nid,payee,spent,category\n1, sheetz, 32.45, fuel\n2, martins,225.52,food\n3, wells fargo, 1100, mortgage\n4, joe the plumber, 275, repairs\n5, comcast, 110, tv\n6, bp, 40, fuel\n7, aldi, 120, food\n8, nationwide, 150, car insurance\n9, nationwide, 100, life insurance\n10, jim electric, 140, utilities\n11, propane, 200, utilities\n12, county water, 100, utilities\n13, county sewer, 105, utilities\n14, 401k, 500, retirement\n```"]