- en: 12\. Files and Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter aims to give you an understanding of how to interact with the filesystem.
    This includes creating and modifying files. You will also learn how to check whether
    the file exists. We will write to the file and save it on disk. We will then create
    a command-line application that accepts various flags and arguments. We will also
    be able to catch signals and determine what to do with them before we exit the
    program.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will create command-line applications that accept arguments
    and display help content. By the end of the chapter, you will be able to handle
    signals that are sent to the application from the operating system (OS), and control
    the exit from the application when the OS sends a signal to immediately stop the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how to marshal and unmarshal JSON. We
    were able to set our struct to the JSON key values and place our struct values
    into JSON. The Go programming language has great library support for JSON, just
    like it has good support for the filesystem-type operations (for example, the
    `open`, `create`, and `modify` files).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will interact with the filesystem. The levels we are going
    to be working with the filesystem at are the file, directory, and permission levels.
    We will tackle everyday issues that developers face when working with the filesystem,
    including how to write a command-line application that needs to accept arguments
    from the command line. We will learn how to create a command-line application
    that will read and write files. Along with discussing what happens when we get
    a signal interrupt from the OS, we will demonstrate how to perform cleanup actions
    before our application stops running. We will also handle a scenario of receiving
    an interrupt to our application and handling how the applications exits. There
    are times when your application is running, and a signal comes from the OS to
    shut down the application. In such instances, we may want to log information at
    the time of the shutdown for debugging purposes; this will help us to understand
    why the application shut down. We will look at how we can do that in this chapter.
    However, before we start tackling these issues, let's get a basic understanding
    of the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A filesystem controls how data is named, stored, accessed, and retrieved on
    a device such as a hard drive, USB, DVD, or another medium. Each filesystem for
    a specific OS will specify its conventions for naming files, such as the length
    of the filename, the specific characters that can be used, how long the suffix
    or file extension can be, and more. There are some file descriptors or metadata
    about a file that most filesystems contain, such as file size, location, access
    permissions, date created, date modified, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Filesystem metadata for a file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.1: Filesystem metadata for a file'
  prefs: []
  type: TYPE_NORMAL
- en: 'Files are generally placed in some sort of hierarchal structure. This structure
    typically consists of multiple directories and sub-directories. The placement
    of the files within the directories is a way to organize your data and get access
    to the file or directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: Filesystem directory structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.2: Filesystem directory structure'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 12.2*, the top-level directory is `Chapter12`. This has
    sub-directories `ex1`, `ex2`, and `activity1`. In this example, those sub-directories
    organize files according to each of the exercises and activities. The filesystem
    is also responsible for who or what can access the directories and files. In the
    next topic, we will be looking at file permissions.
  prefs: []
  type: TYPE_NORMAL
- en: File Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Permissions are an important aspect that you need to understand when dealing
    with file creation and modifications.
  prefs: []
  type: TYPE_NORMAL
- en: We need to look at various permission types that can be assigned to a file.
    We also need to look at how those permission types are represented as a symbolic
    and octal notation.
  prefs: []
  type: TYPE_NORMAL
- en: Go uses the Unix nomenclature for representing permission types. They are represented
    as symbolic notation or octal notation. The three permission types are *Read*,
    *Write*, and *Execute*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each one has a symbolic and octal notation. The following table explains the
    permission type and how it is represented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: Permissions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.3: Permissions'
  prefs: []
  type: TYPE_NORMAL
- en: 'For every file, there are three sets of individuals or groups that have their
    permissions specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Owner*:'
  prefs: []
  type: TYPE_NORMAL
- en: To an individual, this is a single person such as John Smith or the root user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Group*:'
  prefs: []
  type: TYPE_NORMAL
- en: A group typically consists of multiple individuals or other groups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Others*:'
  prefs: []
  type: TYPE_NORMAL
- en: Those that are not in a group or the owner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of a file and its permissions on a Unix machine:![Figure
    12.4: Permission sets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/B14177_12_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.4: Permission sets'
  prefs: []
  type: TYPE_NORMAL
- en: The first dash indicates that this is a file; if it was a `d`, that would indicate
    a directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Octal notation can be used to show multiple permissions types by a single number.
    For example, if you want to show a permission for `read` and `write` using symbolic
    notation, it would be `rw-`. If this was to be represented as an octal number,
    it would be `6`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.5: Permission types'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.5: Permission types'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table presents the numbers and symbols for the different permission
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6: Permission type, octal, and symbolic'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.6: Permission type, octal, and symbolic'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next table is an example of various file permissions for `owner`, `group`,
    and `others`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7: Permissions based on owner, group, and others'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.7: Permissions based on owner, group, and others'
  prefs: []
  type: TYPE_NORMAL
- en: Flags and Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go provides support for creating command-line interface tools. Many times, when
    we are writing Go programs that are executables, they need to accept various inputs.
    These inputs could include the location of a file, a value to run the program
    in the debug state, getting help to run the program, and more. All of this is
    made possible by a package in the Go standard library called `flag`. It is used
    to allow the passing of arguments to the program. A flag is an argument that is
    passed to a Go program. The order of the flags being passed to the Go program
    using the `flag` package does not matter to Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define your `flag`, you must know the `flag` type you will be accepting.
    The `flag` package provides many functions for defining flags. Here is a sample
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters of the preceding functions can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*name*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This parameter is the name of the flag; it is a string type. For example, if
    you pass `file` as an argument, you would access that flag from the command line
    by:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*value*:'
  prefs: []
  type: TYPE_NORMAL
- en: This parameter is the default value that the flag is set to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*usage*:'
  prefs: []
  type: TYPE_NORMAL
- en: This parameter is used to describe the flag's purpose. It will often show up
    on the command line when you incorrectly set the value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing the wrong type for a flag will stop the program and cause an error;
    the usage will be printed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*return value*:'
  prefs: []
  type: TYPE_NORMAL
- en: This is the address of the variable that stores the value of the flag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The following diagram describes the preceding example when using the flag package.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8: flag.Int arguments'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.8: flag.Int arguments'
  prefs: []
  type: TYPE_NORMAL
- en: We will go over the code in the diagram and the previous code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: The variable `v` will reference the value for either `-value` or –`value`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The initial value of `*v` is the default value of `-1` before calling `flag.Parse()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After defining the flags, you must call `flag.Parse()` to parse the command
    line into the defined flags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `flag.Parse()` places the argument for `-value` into `*v`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have called the `flag.Parse() function`, the flags will be available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the command line, execute the following `go build -o exFlag` command and
    you will get the executable in the directory called `exFlag`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.9: Application flag and arguments'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.9: Application flag and arguments'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at using flags of various types in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We define three flags of the `Int`, `String`, and `Bool` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then call the `flag.Parse()` function to place the arguments for those flags
    into their respective reference variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we simply print the values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running the executable with no parameters: `./exFlag`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running without supplying arguments; the values of the reference pointers are
    the default values assigned when we defined our flag types: `./exFlag -h`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running our application with the `-h` flag prints out the usage statement that
    we set when we defined our flags:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./exFlag -name=John –age 42 -married true results`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are times when we might want to make a `flag` necessary for the command-line
    application. Carefully choosing the default value when a flag is required is important.
    You can check and see whether the value of the flag is the default and whether
    it is exiting the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review the code in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The name flag has the default value of an empty string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We check to see whether that is the value of `*n`. If it is, we print a message
    informing the user that `Name` is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then call `flag.PrintDefaults()`; this prints the usage message to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The results of calling the application are `/exFlag --age 42 -married true`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What is a signal? In our context, a signal is an interrupt that is sent to our
    program or to a process by the OS. When a signal is delivered to our program,
    the program will stop what it is doing; either it will handle the signal or, if
    possible, ignore it. We have seen other Go commands that change the flow of the
    program; you may be wondering which one to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use `defer` statements in our applications to perform various cleanup activities,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The release of resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The closing of files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The closing of database connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing the removal of configuration or temporary files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In some use cases, it is imperative that these activities are completed. Using
    a `defer` function will execute it just before returning to the caller. However,
    this does not guarantee that it will always run. There are certain scenarios in
    which the `defer` function won''t execute; for example, an OS interrupt to your
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '`os.Exit(1)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ctrl* + *C*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other instructions from the OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding scenarios indicate where it may warrant using signals. Signals
    can help us control the exit of our program. Depending on the signal, it could
    terminate our program. For example, the application is running and encounters
    an OS interrupt signal after executing `employee.CalculateSalary()`. In this scenario,
    the `defer` function will not run, thus, `employee.DepositCheck()` does not execute
    and the employee does not get paid. A signal can change the flow of the program.
    The following diagram goes over the scenario we discussed previously:![Figure
    12.10: Signal changing the flow of the program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/B14177_12_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.10: Signal changing the flow of the program'
  prefs: []
  type: TYPE_NORMAL
- en: 'Support for handling signals is built into the Go standard library; it is in
    the `os/signal` package. This package will allow us to make our programs more
    resilient. We want to gracefully shut down when we receive certain signals.The
    first thing to do when handling signals in Go is to trap or catch the signal that
    you are interested in. This is done by using the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `Notify()` function accepts an `os.Signal` data type on a channel, `c`.
    The `sig` argument is a variadic variable of `os.Signal`; we specify zero or more
    `os.Signal` data types that we are interested in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example that handles a `syscall.SIGINT` interrupt, which
    is akin to `CTRL-C`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the preceding code snippet in detail:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a channel of the `os.Signal` type. The `Notify` method works by sending
    values of the `os.Signal` type to a channel. The `sigs` channel is used to receive
    these notifications from the `Notify` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `done` channel is used to let us know when the program can exit:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `signal.Notify` method will receive notifications on the `sigs` channel,
    which is of the `syscall.SIGINT` type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We create an anonymous function that is a goroutine. This function currently
    only has a case statement, which is blocking until it gets a `syscall.SIGINT`
    type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will print out various messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We send `true` to our `done` channel to indicate that we received the signal.
    This will stop our channel from blocking:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `<-done` channel will be blocking until our program receives the signal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the results:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exercise 12.01: Simulating Cleanup'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will be catching two signals: `SIGINT` and `SIGTSTP`.
    Once those signals have been caught, we will simulate a cleanup of the files.
    We have not gone over how to remove files yet, so, in this example, we will simply
    create a delay to demonstrate how we can run a function after a signal is caught.
    This is the desired output from this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add to the file the package `main` and the following import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, create a channel of the `os.Signal` type. The `sigs`
    channel is used to receive these notifications from the `Notify` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add a `done` channel. The `done` channel is used to let us know when
    the program can exit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will then add a `signal.Notify` method. The `Notify` method works by sending
    values of the `os.Signal` type to a channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recall that the last parameter of the `signal.Notify` method is a variadic parameter
    of the `os.Signal` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `signal.Notify` method will receive notifications on the channel sigs that
    are of the `syscall.SIGINT` and `syscall.SIGTSTP` types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generally speaking, the `syscall.SIGINT` type can occur when you press *Ctrl*
    + *C*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Generally speaking, the `syscall.SIGTSTP` type can occur when you press *Ctrl*
    + *Z*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an anonymous function as a goroutine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the goroutine, create an infinite loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the infinite loop, we will receive a value from the `sigs` channel and
    store it in the `s` variable, `s := <-sigs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a `switch` statement that evaluates what is received from the channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will have two case statements that will check for the `syscall.SIGINT` and
    `syscall.SIGTSP` types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each case statement will have a message being printed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will also call our `cleanup()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last statement in the case statement is sending `true` to the `done` channel
    to stop the blocking:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a simple function to mimic a process performing a cleanup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can try running this program and pressing *Ctrl + Z* and *Ctrl + C* to
    examine the different results of the program. This only works on Linux and macOS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now run the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.11: Simulating cleanup output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.11: Simulating cleanup output'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have demonstrated the ability to intercept an interrupt
    and perform a task before the application closes. We have the ability to control
    our exit. This is a powerful feature that allows us to perform cleanup actions
    that include removing files, performing a last-minute log, freeing up memory,
    and more. In the next topic, we are going to be creating and writing to files.
    We will be using functions that come from the Go standard package, `os`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Writing to Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go language provides support in various ways to create and write to new
    files. We will examine some of the most common ways in which this is performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `os` package provides a simple way in which to create a file. For those
    who are familiar with the `touch` command from the Unix world, it is similar to
    this. Here is the signature of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The function will create an empty file just like the `touch` command. It is
    important to note that if it already exists, then it will truncate the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Create` function from the `os` package input parameter is the name of
    the file and the location that you want to create. If successful, it will return
    a `File` type. It is worth noting that the `File` type satisfies the `io.Write`
    and `io.Read` interfaces. This is important to know for later in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code simply creates an empty file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It creates a file named test.txt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a file by that name already exists, then it will truncate that file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we did not provide a location for the file, it will create the file in
    the directory of our executable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We then check for errors from the os.Create function. It is a good practice
    to check for errors immediately, because if an error occurred and we did not check
    for the error, this would make debugging in our program difficult later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We panic if there is an error. It is better to panic and then to exit, because
    the defer function will not run if you do an os.Exit(1) with a function that has
    a defer function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If an error did occur, then it would be of the *PathError type. For example,
    say that we gave the os.Create function an incorrect path such as /lol/test.txt.
    We would get the following error:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Creating an empty file is straightforward, but let''s continue with `os.Create`
    and write to the file we just created. Recall that `os.Create` returns an `*os.File`
    type. There are two methods of interest that can be used to write to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Write`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WriteString`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s look at the preceding code in more detail:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `Write` method accepts a slice of bytes and returns the number of bytes
    written and an error if there is any. This method also allows the `os.File` type
    to satisfy the `io.Write` interface:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are taking the `"Using Write function.\n"` string and converting it into
    a slice of bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we are writing it to our `test.txt` file. The `Write` method accepts
    `[]byte`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `WriteString` method behaves the same as the `Write` method, except that
    it takes a string as an input parameter versus a `[]byte` data type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go provides us with the ability to create and write to a file within a single
    command. We will be leveraging the `io/ioutil` package in Go to accomplish this
    task. The `ioutil.WriteFile` method is a very handy method that provides this
    ability:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The method writes the data to the file specified in the filename parameter,
    with the given permissions. It will return an error if one exists. Let''s take
    a look at this in action:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s understand the code in pieces:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `WriteFile` method will write the `[]byte` variable message to the `test.txt`
    file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `test.txt` file does not exist, it will create the `test.txt` file with
    the permissions of `0644`. The owner will have read/write permissions. The group
    and others will have read permissions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the file does exist, it will truncate it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both `os.Create` and `ioutil.WriteFile` will truncate the file if it exists.
    This may not always be the desired behavior. There may be times that we want to
    check to see whether the file exists before we create the file or before we attempt
    to read the file. Lucky for us, Go provides a simple mechanism for checking whether
    a file exists:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the preceding code snippet in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We are calling `os.Stat()` on the `junk.txt` file to check to see whether it
    exists. The `os.Stat()` method will return a `FileInfo` type if the file exists.
    If not, `FileInfo` will be `nil` and an error will be returned instead:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `os.Stat()` method can return multiple errors. We must inspect the error
    to determine whether the error is due to the file not being there. The standard
    library provides `os.IsNotExist(error)`, which can be used to check to see whether
    the error is the result of the file not existing. Here is the result:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The printing of `file(FileInfo)` will be `nil` in this scenario, since `junk.txt`
    does not exist:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `test.txt` file does exist in this scenario, so the `err` will be `nil`
    and the file will contain the `FileInfo` type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are various pieces of information that the `FileInfo` type contains, which
    can be useful to know.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following details on the `FileInfo` interface can be found at [https://golang.org/src/os/types.go?s=479:840#L11](https://golang.org/src/os/types.go?s=479:840#L11):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here are the results of the executed code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.12: os.Stat'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.12: os.Stat'
  prefs: []
  type: TYPE_NORMAL
- en: Reading the Whole File at Once
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this topic, we will look at two methods that read all the contents of the
    file. These two functions are good to use when your file size is small. While
    these two methods are convenient and easy to use, they have one major drawback.
    That is, if the file size is too large, then it could exhaust the memory on the
    system. It is important to keep this in mind and understand the limitations of
    the two methods we will be going over in this topic. Even though these methods
    are one of the quickest and easiest ways to load data, it is important to understand
    that they should be limited to small files and not large ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method we will examine for reading a file is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ReadFile` function reads the contents of the file and returns it as a
    slice of bytes along with any reported errors. We will look at the error return
    when the `ReadFile` method is used:'
  prefs: []
  type: TYPE_NORMAL
- en: A successful call returns `err == nil`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In some of the other read methods for files, EOF is treated as an error. This
    is not the case for functions that read the entire file into memory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this code snippet, I have a `test.txt` file that is located in the same
    location as my executable. It contains the following content:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.13: Example text file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.13: Example text file'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of `text.txt` get assigned as a slice of bytes into the variable
    content. If there are any errors, they will be stored in the `err` variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since this is a slice of bytes, it must be converted into a string format for
    ease of readability. Here are the results of the print statements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.14: Example output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.14: Example output'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function we will look at that reads the entire content into memory
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the `ReadFile` method, `ReadAll` takes `io.Reader` as an argument. That
    is the only real difference in the behavior of `ReadFile` and `ReadAll`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand the code in pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ioutil.ReadAll` method requires `io.Reader` as an argument. The `os.Open`
    method returns an `*os.File` type, which satisfies the `io.Reader` interface:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The content stores the `[]byte` data from the result of the `ioutil.ReadAll(f)`
    method. If there are any errors, they will be stored in the `err` variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since this is a slice of bytes, it must be converted to a string format for
    ease of readability. The results of the print statements are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.15: Example output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.15: Example output'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Since the `ioutil.ReadAll` method accepts an interface, this gives us more flexibility.
    If you recall *Chapter 7, Interfaces*, when using interfaces, it allows for more
    flexibility and uses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are using `strings.NewReader`, which takes a string and returns a `Reader`
    type that implements the `io.Reader` interface. This allows us to use the `ioutil.ReadAll()`
    method without having a file. By doing this, we can perform various tests on the
    data when we have not yet been given the file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can use the `ioutil.Readall` method in the same fashion with the results
    of `strings.Reader()` as we did with `os.Open()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Following are the results of the print statement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 12.16: The strings.NewReader content'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Image74026.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.16: The strings.NewReader content'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen various ways to write to files, create files, and to read from
    files. However, we have yet to see how to append data to a file. There are times
    when you would want to append a file with additional information. The `os.OpenFile()`
    method provides this ability. Most of the time, you will use `Create` or `Open`
    for your open or create processes; however, when you want to append data to a
    file, you will need to use `OpenFile`. The signature of the method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The one parameter that is unique is the `flag` parameter. This is used to determine
    what actions to allow when opening the file; it is not to be confused with the
    `FileMode` type, which is what permission types get to assign to the file itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of flags that can be used to open a file ([http://golang.org/src/pkg/os/file.go](http://golang.org/src/pkg/os/file.go)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'These flags can be used in various combinations when opening a file. Let''s
    take a look at some various examples using the flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at `os.OpenFile` in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Using `os.OpenFile` with the `os.O_CREATE` file mode will create the `junk101.txt`
    file if it does not exist, and then open it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at an example using different file modes for `os.OpenFile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at the preceding code in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `os.OpenFile` with the `os.O_CREATE` flag will create the `junk101.txt`
    file if it does not exist and then open it. If it does exist, it will just open
    the file. It will also allow the reading and writing of the file while it is open
    because of the `os.O_WRONLY` flag:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since we used the `os.O_WRONLY` flag, we can write to the file while it is open.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at an example of how to append data to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `os.OpenFile` with the `os.O_CREATE` flag will create the `junk101.txt`
    file if it does not exist and then open it. If it does exist, it will just open
    the file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will also allow the reading and writing of the file while it is open because
    of the `os.O_WRONLY` flag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`os.O_APPEND` will allow you to append data to the bottom of the file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since we used the `os.O_WRONLY` flag, we can write to the file while it is open.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data will be appended to the bottom of the file and not override the existing
    data since we included the `os.O_APPEND` flag. The following define some common
    permission flag combinations that can be used for `os.OpenFile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**os.O_CREATE**'
  prefs: []
  type: TYPE_NORMAL
- en: If the file does not exist, it will create the file when attempting to open
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**os.O_CREATE | os.O_WRONLY**'
  prefs: []
  type: TYPE_NORMAL
- en: When opening a file, you can now write to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any data that is in the file will be overwritten.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**os.O_CREATE | os.O_WRONLY | os.O_APPEND**'
  prefs: []
  type: TYPE_NORMAL
- en: When writing to the file, it will not overwrite the data but rather append the
    data to the end of the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 12.02: Backing Up Files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Oftentimes, when working with files, we need to back up a file before making
    changes to it. This is for instances where we might make mistakes or want the
    original file for auditing purposes. In this exercise, we will take an existing
    file called `note.txt` and back it up to `backupFile.txt`. We will then open `note.txt`
    and add some additional notes to the end of the file. Our directory will contain
    the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.17: Backing up files to the directory'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.17: Backing up files to the directory'
  prefs: []
  type: TYPE_NORMAL
- en: 'We must first create the `note.txt` file in the same directory as our executable.
    This file can be blank or contain some sample data such as this:![Figure 12.18:
    Example of the notes.txt file content'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_12_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.18: Example of the notes.txt file content'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a Go file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This program will be part of the `main` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Include the imports, as seen in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a custom error that will be used for when the working file (`note.txt`)
    is not found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function that will be performing the backup. This function is responsible
    for taking the working file and storing its content into the `backup` file. This
    function accepts two arguments. The `working` parameter is the file path of the
    file that you currently are working on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside this function, we will need to check to see whether the working file
    exists. It must first exist before we can read its contents and store them in
    our backup file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are able to check to see whether the error is one where the file does not
    exist by using `os.IsNotExist(err)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the file does not exist, we will return with our custom error: `ErrWorkingFileNotFound`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to open the working file and store the `os.File` return by the
    function to the `workFile` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to read the contents of the `workFile`. We will be using the `ioutil.ReadAll`
    method to get all the contents of the `workFile`. The `workFile` is of the `os.File`
    type, which satisfies the `io.Reader` interface; this allows us to pass it to
    `ioutil.ReadFile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check to see whether there is an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `content` variable contains the data of the `workFile` represented as a
    slice of bytes. That data needs to be written to the backup file. We will implement
    the code that will write the data of the `content` variable to the backup file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The content stores the `[]byte` data that gets returned from the function. This
    is the entire content of the file stored in the variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use the `ioutil.Writefile` method. If the backup file does not exist,
    it will create the file. If the backup file does exist, it will overwrite the
    file with the content variable data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to return `nil`, indicating that, at this juncture, we have not encountered
    any errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a function that will append data to our working file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name the function `addNotes`; this will accept the location of our working
    file and a string argument that will be appended to the working file. The function
    will need to return an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `addNotes` function, add a line that will append a new line to each
    note''s string. This will place each note on a separate line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will open the working file and allow for appending to the file. The
    `os.OpenFile()` function will create the file if it does not exist. Check for
    any errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After opening a file and checking for an error, we should make sure that it
    closes when the function exits by using the defer function, `f.Close()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step of the function is to write the contents of the note to the
    `workingFile` variable. We can use the `Write` method to accomplish this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `main()` function, we will initialize three variables; the `backupFile`
    variable contains the name of the file for backing up our `workingFile` variable,
    while the `data` variable is what we will be writing to our `workingFile` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call our `createBackup()` function to back up our `workingFile`. Check for
    errors after calling the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a `for` loop that will iterate `10` times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each iteration we set our `note` variable to the `data` variable plus the `i`
    variable of our loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since our `note` variable is a string and our `i` variable is an `int`, we will
    need to convert `i` to a string using the `strconv.Itoa(i)` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call our `addNotes()` function and pass the `workingFile` and our `note` variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check for any errors returned from the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Evaluate the changes to the files after running the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Following are the results after running the program:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.19: The results of backing up the files'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14177_12_19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.19: The results of backing up the files'
  prefs: []
  type: TYPE_NORMAL
- en: CSV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common ways a file is structured is as a comma-separated value.
    This is a clear text file that contains data, which is basically represented as
    rows and columns. Frequently, these files are used to exchange data. A CSV file
    has a simple structure. Each piece of data is separated by a comma and then a
    new line for another record. An example of a CSV file would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'You will, at some point in your life, come across CSV files as they are very
    common. The Go programming language has a standard library that is used for handling
    CSV files: `encoding/csv`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The following creates a `reader` type and returns it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NewReader` method takes an argument of `io.Reader` and returns a type
    of `Reader` that is used to read the CSV data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are reading in each record one at a time in an infinite loop. After
    each record we read, we check first to see whether it is the end of the file (`io.EOF`);
    if so, we break out of the loop. The `r.Read()` function reads one record; it
    is a slice of strings from the `r` variable. It returns that record as a `[]string`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the result of printing the record:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.20: CSV example output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.20: CSV example output'
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you think there might be a way to access each individual value? Currently,
    we have only looked at printing out of each row. There are instances, however,
    where we might want to access just the age or the first name. The next example
    will show us just how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'We will discuss the new portions of the code in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`header := true`'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `header` variable as a flag. It will aid us in parsing the
    headers of the CSV data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The infinite loop will stop once the end of the file is reached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The `r.Read()` function reads a single record and returns a slice of strings
    that contains the fields of that record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: This breaks out of the infinite loop if it is the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, check to see whether this is the first iteration of the loop. If this
    is the first iteration of the loop, then the first row would be the headers of
    the fields; we do not want to parse the headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Range over the fields in the record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The `switch` statement is used to perform the specific parsing of each field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Initially set to `true`, after the first time through the loop, it can be set
    to `false`. Headers are usually the first row of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.21: Output of parsing CSV fields'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.21: Output of parsing CSV fields'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 12.01: Parsing Bank Transaction Files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we will be ingesting a transaction file from the bank. The
    file is a CSV file. Our bank also includes budget categories for the transactions
    in the file. The file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The aim of this activity is to create a command-line program that will accept
    two flags: the location of the CSV bank transaction file and the location of a
    log file. We will check that the log and bank file location is valid before the
    application starts parsing the CSV file. The program will parse the CSV file and
    log any errors it encounters to the log. Upon each restart of the program, it
    will also delete the previous log file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: We will need to create budget category types for `fuel`, `food`, `mortgage`,
    `repairs`, `insurance`, `utilities`, and `retirement`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a custom error for when a budget category is not found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a struct type transaction that has `ID`, `payee`, `spent`, and `category`
    fields (the type is what we created in the first step).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that will accept the category from the bank transaction file.
    This function will map the transaction categories to our categories. Mappings
    include `fuel` and `gas` maps to `autoFuel`, `food` maps to `food`, `mortgage`
    maps to `mortgage`, `repairs` map to `repairs`, `car` `insurance` and `life` `insurance`
    maps to `insurance`, `utilities` maps to `utilities`, and everything else will
    return the custom error that we created in the previous step. The function will
    return our `budgetCategory` type and an error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `writeErrorToLog(msg string, err error, data string, logfile string)
    error.` function. This will take the `msg`, `err`, and `data` strings and write
    them to the log file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a function with the following signature: `parseBankFile(bankTransactions io.Reader, logFile string) []transaction`.
    This function will iterate over the `bankTransaction` file.As it is looping, use
    a `switch` statement and examine the index of the record.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each `case` statement assigns the value of the index to the respective value
    of the `transaction` struct.When the case statement index matches the category
    of the CSV file, we need to call our `convertToBudgeCategory()`. This will map
    the bank transaction to our budget category.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `main()` function, we need two `c` flags for the transaction file and
    `l` for the location of the log file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The bank transaction file and log file are required, so you must ensure they
    are present before continuing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will then call the `parsBankFile()` function and print the `[]transactions`
    that gets returned from the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.22: Format of the transaction file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.22: Format of the transaction file'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 737.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we created a command-line application that accepted flags.
    We also configured our command-line application to require those flags. In this
    command-line application, we created and modified files. We also parsed a common
    file format used in system programming, the comma-separated value (CSV) file.
    We were able to read from the file and store the data in the file in our various
    struct types. We were able to continue to process the CSV file when we encountered
    an error. When we encountered an error, we wrote to a log file for later debugging.
    This command-line application demonstrated real-world activities that are generally
    done in programming command-line applications (such as accepting flags, requiring
    flags, parsing a file such as CSV, modifying and creating files, and logging).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we gained an understanding of how Go views and uses file permissions.
    We learned that file permissions can be represented as symbolic and octal notations.
    We discovered that the Go standard library has built-in support for opening, reading,
    writing, creating, deleting, and appending data to a file. We looked at the `flag`
    package and how it provides functionality to create command-line applications
    to accept arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `flag` package, we could also print out `usage` statements that pertained
    to our command-line application.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we demonstrated how OS signals can impact our Go program; however, by
    using the Go standard library, we can capture OS signals and, if applicable, control
    how we want to exit our program.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that Go has a standard library for working with CSV files. In
    working with files previously, we saw that we can also work with files that are
    structured as CSV files. That Go CSV package provides the ability to iterate over
    the contents of the file. The CSV file can be viewed as rows and columns similar
    to database tables. In the next chapter, we will look at how to connect to databases
    and execute SQL statements against a database. This will demonstrate the ability
    of Go to be used for applications that require a backend for storing data.
  prefs: []
  type: TYPE_NORMAL
