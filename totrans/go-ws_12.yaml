- en: 12\. Files and Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter aims to give you an understanding of how to interact with the filesystem.
    This includes creating and modifying files. You will also learn how to check whether
    the file exists. We will write to the file and save it on disk. We will then create
    a command-line application that accepts various flags and arguments. We will also
    be able to catch signals and determine what to do with them before we exit the
    program.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will create command-line applications that accept arguments
    and display help content. By the end of the chapter, you will be able to handle
    signals that are sent to the application from the operating system (OS), and control
    the exit from the application when the OS sends a signal to immediately stop the
    application.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how to marshal and unmarshal JSON. We
    were able to set our struct to the JSON key values and place our struct values
    into JSON. The Go programming language has great library support for JSON, just
    like it has good support for the filesystem-type operations (for example, the
    `open`, `create`, and `modify` files).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will interact with the filesystem. The levels we are going
    to be working with the filesystem at are the file, directory, and permission levels.
    We will tackle everyday issues that developers face when working with the filesystem,
    including how to write a command-line application that needs to accept arguments
    from the command line. We will learn how to create a command-line application
    that will read and write files. Along with discussing what happens when we get
    a signal interrupt from the OS, we will demonstrate how to perform cleanup actions
    before our application stops running. We will also handle a scenario of receiving
    an interrupt to our application and handling how the applications exits. There
    are times when your application is running, and a signal comes from the OS to
    shut down the application. In such instances, we may want to log information at
    the time of the shutdown for debugging purposes; this will help us to understand
    why the application shut down. We will look at how we can do that in this chapter.
    However, before we start tackling these issues, let's get a basic understanding
    of the filesystem.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A filesystem controls how data is named, stored, accessed, and retrieved on
    a device such as a hard drive, USB, DVD, or another medium. Each filesystem for
    a specific OS will specify its conventions for naming files, such as the length
    of the filename, the specific characters that can be used, how long the suffix
    or file extension can be, and more. There are some file descriptors or metadata
    about a file that most filesystems contain, such as file size, location, access
    permissions, date created, date modified, and more:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Filesystem metadata for a file'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_12_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.1: Filesystem metadata for a file'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Files are generally placed in some sort of hierarchal structure. This structure
    typically consists of multiple directories and sub-directories. The placement
    of the files within the directories is a way to organize your data and get access
    to the file or directory:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 文件通常被放置在某种层次结构中。这种结构通常由多个目录和子目录组成。文件在目录中的放置是一种组织数据并获得访问文件或目录的方式：
- en: '![Figure 12.2: Filesystem directory structure'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2：文件系统目录结构'
- en: '](img/B14177_12_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_12_02.jpg)'
- en: 'Figure 12.2: Filesystem directory structure'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：文件系统目录结构
- en: As shown in *Figure 12.2*, the top-level directory is `Chapter12`. This has
    sub-directories `ex1`, `ex2`, and `activity1`. In this example, those sub-directories
    organize files according to each of the exercises and activities. The filesystem
    is also responsible for who or what can access the directories and files. In the
    next topic, we will be looking at file permissions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图12.2*所示，顶级目录是`Chapter12`。它包含子目录`ex1`、`ex2`和`activity1`。在这个例子中，这些子目录根据每个练习和活动组织文件。文件系统还负责谁或什么可以访问目录和文件。在下一个主题中，我们将探讨文件权限。
- en: File Permissions
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件权限
- en: Permissions are an important aspect that you need to understand when dealing
    with file creation and modifications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 权限是在处理文件创建和修改时需要理解的重要方面。
- en: We need to look at various permission types that can be assigned to a file.
    We also need to look at how those permission types are represented as a symbolic
    and octal notation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要查看可以分配给文件的多种权限类型。我们还需要查看这些权限类型如何以符号和八进制表示法表示。
- en: Go uses the Unix nomenclature for representing permission types. They are represented
    as symbolic notation or octal notation. The three permission types are *Read*,
    *Write*, and *Execute*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Go使用Unix命名法来表示权限类型。它们以符号表示法或八进制表示法表示。三种权限类型是*读取*、*写入*和*执行*。
- en: 'Each one has a symbolic and octal notation. The following table explains the
    permission type and how it is represented:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 每个权限都有符号和八进制表示法。下表解释了权限类型及其表示方式：
- en: '![Figure 12.3: Permissions'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3：权限'
- en: '](img/B14177_12_03.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_12_03.jpg)'
- en: 'Figure 12.3: Permissions'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：权限
- en: 'For every file, there are three sets of individuals or groups that have their
    permissions specified:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个文件，都有三组个人或组指定了它们的权限：
- en: '*Owner*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*所有者*：'
- en: To an individual, this is a single person such as John Smith or the root user.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于个人来说，这是一个单个人，比如John Smith或root用户。
- en: '*Group*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*组*：'
- en: A group typically consists of multiple individuals or other groups.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个组通常由多个个人或其他组组成。
- en: '*Others*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*其他人*：'
- en: Those that are not in a group or the owner.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那些不属于组或所有者的。
- en: 'The following is an example of a file and its permissions on a Unix machine:![Figure
    12.4: Permission sets'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下面的示例展示了Unix机器上的一个文件及其权限：![图12.4：权限集
- en: '](img/B14177_12_04.jpg)'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14177_12_04.jpg)'
- en: 'Figure 12.4: Permission sets'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：权限集
- en: The first dash indicates that this is a file; if it was a `d`, that would indicate
    a directory.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个短横线表示这是一个文件；如果它是`d`，则表示这是一个目录。
- en: 'Octal notation can be used to show multiple permissions types by a single number.
    For example, if you want to show a permission for `read` and `write` using symbolic
    notation, it would be `rw-`. If this was to be represented as an octal number,
    it would be `6`:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八进制表示法可以用一个数字来显示多个权限类型。例如，如果你想使用符号表示法显示`读取`和`写入`权限，它将是`rw-`。如果这要表示为八进制数字，它将是`6`：
- en: '![Figure 12.5: Permission types'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5：权限类型'
- en: '](img/B14177_12_05.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_12_05.jpg)'
- en: 'Figure 12.5: Permission types'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：权限类型
- en: 'The following table presents the numbers and symbols for the different permission
    types:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下表展示了不同权限类型的数字和符号：
- en: '![Figure 12.6: Permission type, octal, and symbolic'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6：权限类型、八进制和符号'
- en: '](img/B14177_12_06.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_12_06.jpg)'
- en: 'Figure 12.6: Permission type, octal, and symbolic'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：权限类型、八进制和符号
- en: 'The next table is an example of various file permissions for `owner`, `group`,
    and `others`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下表是`所有者`、`组`和`其他人`的文件权限示例：
- en: '![Figure 12.7: Permissions based on owner, group, and others'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7：基于所有者、组和其他人的权限'
- en: '](img/B14177_12_07.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_12_07.jpg)'
- en: 'Figure 12.7: Permissions based on owner, group, and others'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：基于所有者、组和其他人的权限
- en: Flags and Arguments
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标志和参数
- en: Go provides support for creating command-line interface tools. Many times, when
    we are writing Go programs that are executables, they need to accept various inputs.
    These inputs could include the location of a file, a value to run the program
    in the debug state, getting help to run the program, and more. All of this is
    made possible by a package in the Go standard library called `flag`. It is used
    to allow the passing of arguments to the program. A flag is an argument that is
    passed to a Go program. The order of the flags being passed to the Go program
    using the `flag` package does not matter to Go.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了创建命令行界面工具的支持。很多时候，当我们编写可执行Go程序时，它们需要接受各种输入。这些输入可能包括文件位置、以调试状态运行程序的价值、获取运行程序的帮助等等。所有这些都可以通过Go标准库中的一个名为`flag`的包来实现。它用于允许将参数传递给程序。标志是传递给Go程序的参数。使用`flag`包传递给Go程序的标志顺序对Go来说并不重要。
- en: 'To define your `flag`, you must know the `flag` type you will be accepting.
    The `flag` package provides many functions for defining flags. Here is a sample
    list:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义你的`flag`，你必须知道你将接受的`flag`类型。`flag`包提供了许多用于定义标志的函数。以下是一个示例列表：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The parameters of the preceding functions can be explained as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 前述函数的参数可以这样解释：
- en: '*name*:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*名称*：'
- en: 'This parameter is the name of the flag; it is a string type. For example, if
    you pass `file` as an argument, you would access that flag from the command line
    by:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此参数是标志的名称；它是一个字符串类型。例如，如果你传递`file`作为参数，你将可以通过以下方式从命令行访问该标志：
- en: '[PRE1]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*value*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*值*：'
- en: This parameter is the default value that the flag is set to.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此参数是标志默认设置的值。
- en: '*usage*:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*用法*：'
- en: This parameter is used to describe the flag's purpose. It will often show up
    on the command line when you incorrectly set the value.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此参数用于描述标志的目的。当您错误地设置值时，它通常会出现在命令行上。
- en: Passing the wrong type for a flag will stop the program and cause an error;
    the usage will be printed.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为标志传递错误的类型将停止程序并导致错误；将打印用法。
- en: '*return value*:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*返回值*：'
- en: This is the address of the variable that stores the value of the flag.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是存储标志值的变量的地址。
- en: 'Let''s take a look at a simple example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The following diagram describes the preceding example when using the flag package.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表描述了使用标志包时的前一个示例。
- en: '![Figure 12.8: flag.Int arguments'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8：flag.Int参数'
- en: '](img/B14177_12_08.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_12_08.jpg)'
- en: 'Figure 12.8: flag.Int arguments'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：flag.Int参数
- en: We will go over the code in the diagram and the previous code snippet.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾图中的代码和前述代码片段。
- en: The variable `v` will reference the value for either `-value` or –`value`.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量`v`将引用`-value`或–`value`的值。
- en: 'The initial value of `*v` is the default value of `-1` before calling `flag.Parse()`:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用`flag.Parse()`之前，`*v`的初始值是`-1`的默认值：
- en: '[PRE3]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After defining the flags, you must call `flag.Parse()` to parse the command
    line into the defined flags.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义标志之后，你必须调用`flag.Parse()`来将命令行解析到定义的标志中。
- en: Calling `flag.Parse()` places the argument for `-value` into `*v`.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`flag.Parse()`将`-value`的参数放入`*v`中。
- en: Once you have called the `flag.Parse() function`, the flags will be available.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦你调用了`flag.Parse()`函数，标志将可用。
- en: 'On the command line, execute the following `go build -o exFlag` command and
    you will get the executable in the directory called `exFlag`:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令行上执行以下`go build -o exFlag`命令，你将在名为`exFlag`的目录中获得可执行文件：
- en: '![Figure 12.9: Application flag and arguments'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.9：应用程序标志和参数'
- en: '](img/B14177_12_09.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_12_09.jpg)'
- en: 'Figure 12.9: Application flag and arguments'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：应用程序标志和参数
- en: 'Let''s look at using flags of various types in the following code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码片段中各种类型标志的使用：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s analyze the preceding code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析前述代码：
- en: We define three flags of the `Int`, `String`, and `Bool` type.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了三个`Int`、`String`和`Bool`类型的标志。
- en: We then call the `flag.Parse()` function to place the arguments for those flags
    into their respective reference variables.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们随后调用`flag.Parse()`函数，将这些标志的参数放入相应的引用变量中。
- en: Then, we simply print the values.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们简单地打印这些值。
- en: 'Running the executable with no parameters: `./exFlag`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不带参数运行可执行文件：`./exFlag`
- en: '[PRE5]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running without supplying arguments; the values of the reference pointers are
    the default values assigned when we defined our flag types: `./exFlag -h`:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不提供参数运行；引用指针的值是我们定义标志类型时分配的默认值：`./exFlag -h`：
- en: '[PRE6]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Running our application with the `-h` flag prints out the usage statement that
    we set when we defined our flags:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-h` 标志运行我们的应用程序将打印出我们在定义标志时设置的用法说明：
- en: '`./exFlag -name=John –age 42 -married true results`:'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`./exFlag -name=John –age 42 -married true results`：'
- en: '[PRE7]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are times when we might want to make a `flag` necessary for the command-line
    application. Carefully choosing the default value when a flag is required is important.
    You can check and see whether the value of the flag is the default and whether
    it is exiting the program:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们可能需要使 `flag` 对命令行应用程序成为必需。当标志是必需的时，仔细选择默认值很重要。你可以检查标志的值是否为默认值，以及它是否退出程序：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s review the code in detail:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细回顾一下代码：
- en: The name flag has the default value of an empty string.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称标志的默认值为空字符串。
- en: We check to see whether that is the value of `*n`. If it is, we print a message
    informing the user that `Name` is required.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们检查 `*n` 的值是否为该值。如果是，我们打印一条消息通知用户 `Name` 是必需的。
- en: We then call `flag.PrintDefaults()`; this prints the usage message to the user.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们调用 `flag.PrintDefaults()`；这会将使用说明打印给用户。
- en: 'The results of calling the application are `/exFlag --age 42 -married true`:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用应用程序的结果是 `/exFlag --age 42 -married true`：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Signals
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号
- en: What is a signal? In our context, a signal is an interrupt that is sent to our
    program or to a process by the OS. When a signal is delivered to our program,
    the program will stop what it is doing; either it will handle the signal or, if
    possible, ignore it. We have seen other Go commands that change the flow of the
    program; you may be wondering which one to use.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是信号？在我们的上下文中，信号是由操作系统发送到我们的程序或进程的中断。当信号被发送到我们的程序时，程序将停止正在做的事情；要么处理信号，要么如果可能的话，忽略它。我们已经看到了其他改变程序流程的
    Go 命令；你可能想知道该使用哪一个。
- en: 'We use `defer` statements in our applications to perform various cleanup activities,
    such as the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的应用程序中使用 `defer` 语句执行各种清理活动，如下所示：
- en: The release of resources
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源的释放
- en: The closing of files
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的关闭
- en: The closing of database connections
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接的关闭
- en: Performing the removal of configuration or temporary files
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行配置文件或临时文件的删除
- en: 'In some use cases, it is imperative that these activities are completed. Using
    a `defer` function will execute it just before returning to the caller. However,
    this does not guarantee that it will always run. There are certain scenarios in
    which the `defer` function won''t execute; for example, an OS interrupt to your
    program:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些用例中，完成这些活动是强制性的。使用 `defer` 函数将在返回给调用者之前执行它。然而，这并不保证它总是会运行。在某些场景中，`defer`
    函数不会执行；例如，操作系统对程序的干扰：
- en: '`os.Exit(1)`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Exit(1)`'
- en: '*Ctrl* + *C*'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl* + *C*'
- en: Other instructions from the OS
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自操作系统的其他指令
- en: 'The preceding scenarios indicate where it may warrant using signals. Signals
    can help us control the exit of our program. Depending on the signal, it could
    terminate our program. For example, the application is running and encounters
    an OS interrupt signal after executing `employee.CalculateSalary()`. In this scenario,
    the `defer` function will not run, thus, `employee.DepositCheck()` does not execute
    and the employee does not get paid. A signal can change the flow of the program.
    The following diagram goes over the scenario we discussed previously:![Figure
    12.10: Signal changing the flow of the program'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前面的场景表明了可能需要使用信号的情况。信号可以帮助我们控制程序的退出。根据信号的不同，它可能会终止我们的程序。例如，应用程序正在运行，并在执行 `employee.CalculateSalary()`
    后遇到操作系统的中断信号。在这种情况下，`defer` 函数将不会运行，因此，`employee.DepositCheck()` 不会执行，员工将不会收到工资。信号可以改变程序的流程。以下图表概述了我们之前讨论的场景：![图
    12.10：信号改变程序的流程
- en: '](img/B14177_12_10.jpg)'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14177_12_10.jpg)'
- en: 'Figure 12.10: Signal changing the flow of the program'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10：信号改变程序的流程
- en: 'Support for handling signals is built into the Go standard library; it is in
    the `os/signal` package. This package will allow us to make our programs more
    resilient. We want to gracefully shut down when we receive certain signals.The
    first thing to do when handling signals in Go is to trap or catch the signal that
    you are interested in. This is done by using the following:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 标准库内置了对信号处理的支撑；它位于 `os/signal` 包中。这个包将使我们能够使我们的程序更加健壮。当我们收到某些信号时，我们希望优雅地关闭程序。在
    Go 中处理信号的第一件事是拦截或捕获你感兴趣的信号。这是通过以下方式完成的：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `Notify()` function accepts an `os.Signal` data type on a channel, `c`.
    The `sig` argument is a variadic variable of `os.Signal`; we specify zero or more
    `os.Signal` data types that we are interested in.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Notify()`函数接受一个通道上的`os.Signal`数据类型，`c`。`sig`参数是一个可变参数的`os.Signal`；我们指定零个或多个我们感兴趣的`os.Signal`数据类型。'
- en: 'The following is an example that handles a `syscall.SIGINT` interrupt, which
    is akin to `CTRL-C`:'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一个处理`syscall.SIGINT`中断的示例，类似于`CTRL-C`：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s look at the preceding code snippet in detail:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们详细看看前面的代码片段：
- en: '[PRE12]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We create a channel of the `os.Signal` type. The `Notify` method works by sending
    values of the `os.Signal` type to a channel. The `sigs` channel is used to receive
    these notifications from the `Notify` method:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个`os.Signal`类型的通道。`Notify`方法通过向通道发送`os.Signal`类型的值来工作。`sigs`通道用于接收`Notify`方法的通知：
- en: '[PRE13]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `done` channel is used to let us know when the program can exit:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`done`通道用于让我们知道程序何时可以退出：'
- en: '[PRE14]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `signal.Notify` method will receive notifications on the `sigs` channel,
    which is of the `syscall.SIGINT` type:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`signal.Notify`方法将在`syscall.SIGINT`类型的`sigs`通道上接收通知：'
- en: '[PRE15]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We create an anonymous function that is a goroutine. This function currently
    only has a case statement, which is blocking until it gets a `syscall.SIGINT`
    type.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建一个匿名函数，该函数是一个goroutine。这个函数目前只有一个case语句，它会阻塞，直到接收到`syscall.SIGINT`类型。
- en: It will print out various messages.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将打印出各种消息。
- en: 'We send `true` to our `done` channel to indicate that we received the signal.
    This will stop our channel from blocking:'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们向`done`通道发送`true`以指示我们已接收到信号。这将停止通道阻塞：
- en: '[PRE16]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `<-done` channel will be blocking until our program receives the signal.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<-done`通道将阻塞，直到我们的程序接收到信号。'
- en: 'Here are the results:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是结果：
- en: '[PRE17]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Exercise 12.01: Simulating Cleanup'
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.01：模拟清理
- en: 'In this exercise, we will be catching two signals: `SIGINT` and `SIGTSTP`.
    Once those signals have been caught, we will simulate a cleanup of the files.
    We have not gone over how to remove files yet, so, in this example, we will simply
    create a delay to demonstrate how we can run a function after a signal is caught.
    This is the desired output from this exercise:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将捕获两个信号：`SIGINT`和`SIGTSTP`。一旦捕获到这些信号，我们将模拟清理文件。我们还没有讲解如何删除文件，所以在这个例子中，我们将简单地创建一个延迟来演示我们如何在捕获到信号后运行一个函数。这是这个练习期望的输出：
- en: Create a file called `main.go`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件。
- en: 'Add to the file the package `main` and the following import statements:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中添加包`main`和以下导入语句：
- en: '[PRE18]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `main()` function, create a channel of the `os.Signal` type. The `sigs`
    channel is used to receive these notifications from the `Notify` method:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，创建一个`os.Signal`类型的通道。`sigs`通道用于接收`Notify`方法的通知：
- en: '[PRE19]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, add a `done` channel. The `done` channel is used to let us know when
    the program can exit:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个`done`通道。`done`通道用于让我们知道程序何时可以退出：
- en: '[PRE20]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will then add a `signal.Notify` method. The `Notify` method works by sending
    values of the `os.Signal` type to a channel.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将添加一个`signal.Notify`方法。`Notify`方法通过向通道发送`os.Signal`类型的值来工作。
- en: Recall that the last parameter of the `signal.Notify` method is a variadic parameter
    of the `os.Signal` type.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回想一下，`signal.Notify`方法的最后一个参数是可变参数的`os.Signal`类型。
- en: The `signal.Notify` method will receive notifications on the channel sigs that
    are of the `syscall.SIGINT` and `syscall.SIGTSTP` types.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`signal.Notify`方法将在通道`sigs`上接收`syscall.SIGINT`和`syscall.SIGTSTP`类型的通知。'
- en: Generally speaking, the `syscall.SIGINT` type can occur when you press *Ctrl*
    + *C*.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常来说，当您按下*Ctrl* + *C*时，可能会发生`syscall.SIGINT`类型。
- en: 'Generally speaking, the `syscall.SIGTSTP` type can occur when you press *Ctrl*
    + *Z*:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常来说，当您按下*Ctrl* + *Z*时，可能会发生`syscall.SIGTSTP`类型：
- en: '[PRE21]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create an anonymous function as a goroutine:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个匿名函数作为goroutine：
- en: '[PRE22]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Inside the goroutine, create an infinite loop.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在goroutine内部，创建一个无限循环。
- en: 'Inside the infinite loop, we will receive a value from the `sigs` channel and
    store it in the `s` variable, `s := <-sigs`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在无限循环内部，我们将从`sigs`通道接收一个值并将其存储在`s`变量中，`s := <-sigs`：
- en: '[PRE23]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Create a `switch` statement that evaluates what is received from the channel.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`switch`语句来评估从通道接收到的内容。
- en: We will have two case statements that will check for the `syscall.SIGINT` and
    `syscall.SIGTSP` types.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将有两个case语句来检查`syscall.SIGINT`和`syscall.SIGTSP`类型。
- en: Each case statement will have a message being printed.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个case语句都会打印一条消息。
- en: We will also call our `cleanup()` function.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将调用我们的`cleanup()`函数。
- en: 'The last statement in the case statement is sending `true` to the `done` channel
    to stop the blocking:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在case语句中的最后一个语句是将`true`发送到`done`通道以停止阻塞：
- en: '[PRE24]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Create a simple function to mimic a process performing a cleanup:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的函数来模拟执行清理过程的进程：
- en: '[PRE25]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can try running this program and pressing *Ctrl + Z* and *Ctrl + C* to
    examine the different results of the program. This only works on Linux and macOS:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以尝试运行这个程序，然后按*Ctrl + Z*和*Ctrl + C*来检查程序的不同结果。这仅在Linux和macOS上有效：
- en: 'Now run the code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行代码：
- en: '[PRE26]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following is the output:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是对应的输出：
- en: '![Figure 12.11: Simulating cleanup output'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.11：模拟清理输出'
- en: '](img/B14177_12_11.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_12_11.jpg)'
- en: 'Figure 12.11: Simulating cleanup output'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：模拟清理输出
- en: In this exercise, we have demonstrated the ability to intercept an interrupt
    and perform a task before the application closes. We have the ability to control
    our exit. This is a powerful feature that allows us to perform cleanup actions
    that include removing files, performing a last-minute log, freeing up memory,
    and more. In the next topic, we are going to be creating and writing to files.
    We will be using functions that come from the Go standard package, `os`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们展示了拦截中断并在应用程序关闭前执行任务的能力。我们有能力控制我们的退出。这是一个强大的功能，允许我们执行清理操作，包括删除文件、进行最后的日志记录、释放内存等。在下一个主题中，我们将创建并写入文件。我们将使用来自Go标准包`os`的函数。
- en: Creating and Writing to Files
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和写入文件
- en: The Go language provides support in various ways to create and write to new
    files. We will examine some of the most common ways in which this is performed.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言以各种方式提供支持来创建和写入新文件。我们将检查一些最常见的方法。
- en: 'The `os` package provides a simple way in which to create a file. For those
    who are familiar with the `touch` command from the Unix world, it is similar to
    this. Here is the signature of the function:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`包提供了一个简单的方式来创建文件。对于那些熟悉Unix世界中的`touch`命令的人来说，它与此类似。以下是该函数的签名：'
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The function will create an empty file just like the `touch` command. It is
    important to note that if it already exists, then it will truncate the file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将创建一个空文件，就像`touch`命令一样。重要的是要注意，如果它已经存在，那么它将截断该文件。
- en: 'The `Create` function from the `os` package input parameter is the name of
    the file and the location that you want to create. If successful, it will return
    a `File` type. It is worth noting that the `File` type satisfies the `io.Write`
    and `io.Read` interfaces. This is important to know for later in the chapter:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`os`包中的`Create`函数的输入参数是你要创建的文件名和位置。如果成功，它将返回一个`File`类型。值得注意的是，`File`类型满足`io.Write`和`io.Read`接口。这一点在章节的后面很重要：'
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code simply creates an empty file:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述代码只是创建了一个空文件：
- en: '[PRE29]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It creates a file named test.txt.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个名为test.txt的文件。
- en: If a file by that name already exists, then it will truncate that file.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果已经存在同名文件，则它将截断该文件。
- en: 'Since we did not provide a location for the file, it will create the file in
    the directory of our executable:'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们没有提供文件的位置，它将在我们的可执行文件所在的目录中创建文件：
- en: '[PRE30]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We then check for errors from the os.Create function. It is a good practice
    to check for errors immediately, because if an error occurred and we did not check
    for the error, this would make debugging in our program difficult later.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们随后检查`os.Create`函数的错误。立即检查错误是一个好习惯，因为如果发生了错误而我们没有检查错误，这将使我们在程序中稍后调试变得困难。
- en: We panic if there is an error. It is better to panic and then to exit, because
    the defer function will not run if you do an os.Exit(1) with a function that has
    a defer function.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果出现错误，我们会感到恐慌。最好是恐慌后退出，因为如果你在一个带有defer函数的函数中执行os.Exit(1)，defer函数将不会运行。
- en: 'If an error did occur, then it would be of the *PathError type. For example,
    say that we gave the os.Create function an incorrect path such as /lol/test.txt.
    We would get the following error:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果确实发生了错误，那么它将是*PathError类型。例如，假设我们给`os.Create`函数提供了一个错误的路径，比如/lol/test.txt。我们会得到以下错误：
- en: '[PRE31]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Creating an empty file is straightforward, but let''s continue with `os.Create`
    and write to the file we just created. Recall that `os.Create` returns an `*os.File`
    type. There are two methods of interest that can be used to write to the file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空文件很简单，但让我们继续使用`os.Create`并写入我们刚刚创建的文件。回想一下，`os.Create`返回一个`*os.File`类型。有两个感兴趣的方法可以用来写入文件：
- en: '`Write`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Write`'
- en: '`WriteString`:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WriteString`：'
- en: '[PRE32]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s look at the preceding code in more detail:'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们更详细地看看前面的代码：
- en: '[PRE33]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `Write` method accepts a slice of bytes and returns the number of bytes
    written and an error if there is any. This method also allows the `os.File` type
    to satisfy the `io.Write` interface:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Write` 方法接受一个字节数组切片，并在有错误时返回写入的字节数和错误。此方法还允许 `os.File` 类型满足 `io.Write` 接口：'
- en: '[PRE34]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We are taking the `"Using Write function.\n"` string and converting it into
    a slice of bytes.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将字符串 `"Using Write function.\n"` 转换为字节数组切片。
- en: 'Then, we are writing it to our `test.txt` file. The `Write` method accepts
    `[]byte`:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将它写入我们的 `test.txt` 文件。`Write` 方法接受 `[]byte` 类型：
- en: '[PRE35]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `WriteString` method behaves the same as the `Write` method, except that
    it takes a string as an input parameter versus a `[]byte` data type.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WriteString` 方法的行为与 `Write` 方法相同，不同之处在于它接受一个字符串作为输入参数，而不是 `[]byte` 数据类型。'
- en: 'Go provides us with the ability to create and write to a file within a single
    command. We will be leveraging the `io/ioutil` package in Go to accomplish this
    task. The `ioutil.WriteFile` method is a very handy method that provides this
    ability:'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Go 提供了在单个命令中创建和写入文件的能力。我们将利用 Go 的 `io/ioutil` 包来完成此任务。`ioutil.WriteFile` 方法是一个非常方便的方法，它提供了这种能力：
- en: '[PRE36]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The method writes the data to the file specified in the filename parameter,
    with the given permissions. It will return an error if one exists. Let''s take
    a look at this in action:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该方法将数据写入由文件名参数指定的文件，并使用给定的权限。如果存在错误，它将返回错误。让我们看看它是如何工作的：
- en: '[PRE37]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s understand the code in pieces:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们逐部分理解这段代码：
- en: '[PRE38]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `WriteFile` method will write the `[]byte` variable message to the `test.txt`
    file.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WriteFile` 方法会将 `[]byte` 类型的变量消息写入 `test.txt` 文件。'
- en: If the `test.txt` file does not exist, it will create the `test.txt` file with
    the permissions of `0644`. The owner will have read/write permissions. The group
    and others will have read permissions.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `test.txt` 文件不存在，它将以 `0644` 权限创建 `test.txt` 文件。所有者将具有读写权限，组和其他用户将具有读权限。
- en: If the file does exist, it will truncate it.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件存在，它将截断文件。
- en: 'Both `os.Create` and `ioutil.WriteFile` will truncate the file if it exists.
    This may not always be the desired behavior. There may be times that we want to
    check to see whether the file exists before we create the file or before we attempt
    to read the file. Lucky for us, Go provides a simple mechanism for checking whether
    a file exists:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.Create` 和 `ioutil.WriteFile` 都会在文件存在时截断文件。这可能不是我们总是希望的行为。有时我们希望在创建文件或尝试读取文件之前检查文件是否存在。幸运的是，Go
    提供了一个简单的机制来检查文件是否存在：'
- en: Note
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s look at the preceding code snippet in more detail:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看前面的代码片段：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We are calling `os.Stat()` on the `junk.txt` file to check to see whether it
    exists. The `os.Stat()` method will return a `FileInfo` type if the file exists.
    If not, `FileInfo` will be `nil` and an error will be returned instead:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在对 `junk.txt` 文件调用 `os.Stat()` 来检查它是否存在。如果文件存在，`os.Stat()` 方法将返回 `FileInfo`
    类型。如果不存在，`FileInfo` 将是 `nil`，并且将返回错误：
- en: '[PRE41]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `os.Stat()` method can return multiple errors. We must inspect the error
    to determine whether the error is due to the file not being there. The standard
    library provides `os.IsNotExist(error)`, which can be used to check to see whether
    the error is the result of the file not existing. Here is the result:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.Stat()` 方法可以返回多个错误。我们必须检查错误以确定错误是否是由于文件不存在。标准库提供了 `os.IsNotExist(error)`，可以用来检查错误是否是由于文件不存在。以下是结果：'
- en: '[PRE42]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The printing of `file(FileInfo)` will be `nil` in this scenario, since `junk.txt`
    does not exist:'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，打印 `file(FileInfo)` 将会是 `nil`，因为 `junk.txt` 文件不存在：
- en: '[PRE43]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `test.txt` file does exist in this scenario, so the `err` will be `nil`
    and the file will contain the `FileInfo` type:'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，`test.txt` 文件确实存在，所以 `err` 将是 `nil`，并且文件将包含 `FileInfo` 类型：
- en: '[PRE44]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There are various pieces of information that the `FileInfo` type contains, which
    can be useful to know.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileInfo` 类型包含各种信息，了解这些信息可能很有用。'
- en: 'The following details on the `FileInfo` interface can be found at [https://golang.org/src/os/types.go?s=479:840#L11](https://golang.org/src/os/types.go?s=479:840#L11):'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `FileInfo` 接口中可以找到以下详细信息，请参阅 [https://golang.org/src/os/types.go?s=479:840#L11](https://golang.org/src/os/types.go?s=479:840#L11)：
- en: '[PRE45]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here are the results of the executed code:'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里是执行代码的结果：
- en: '![Figure 12.12: os.Stat'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.12: os.Stat'
- en: '](img/B14177_12_12.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_12_12.jpg)'
- en: 'Figure 12.12: os.Stat'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '图 12.12: os.Stat'
- en: Reading the Whole File at Once
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一次性读取整个文件
- en: In this topic, we will look at two methods that read all the contents of the
    file. These two functions are good to use when your file size is small. While
    these two methods are convenient and easy to use, they have one major drawback.
    That is, if the file size is too large, then it could exhaust the memory on the
    system. It is important to keep this in mind and understand the limitations of
    the two methods we will be going over in this topic. Even though these methods
    are one of the quickest and easiest ways to load data, it is important to understand
    that they should be limited to small files and not large ones.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个主题中，我们将探讨两种读取文件所有内容的方法。当文件大小较小时，这两个函数是很好的选择。虽然这两个方法方便且易于使用，但它们有一个主要的缺点。那就是，如果文件大小太大，可能会耗尽系统内存。这一点很重要，需要记住，并理解我们将在这个主题中讨论的两个方法的限制。尽管这些方法是最快和最简单加载数据的方式之一，但重要的是要理解它们应该仅限于小文件，而不是大文件。
- en: 'The first method we will examine for reading a file is the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的第一个读取文件的方法如下：
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `ReadFile` function reads the contents of the file and returns it as a
    slice of bytes along with any reported errors. We will look at the error return
    when the `ReadFile` method is used:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadFile` 函数读取文件内容，并以字节切片的形式返回它，同时报告任何错误。我们将查看当使用 `ReadFile` 方法时的错误返回值：'
- en: A successful call returns `err == nil`.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个成功的调用返回 `err == nil`。
- en: 'In some of the other read methods for files, EOF is treated as an error. This
    is not the case for functions that read the entire file into memory:'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一些其他文件读取方法中，EOF 被视为错误。对于将整个文件读入内存的函数来说，情况并非如此：
- en: '[PRE47]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For this code snippet, I have a `test.txt` file that is located in the same
    location as my executable. It contains the following content:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于这个代码片段，我有一个 `test.txt` 文件，它位于我的可执行文件相同的目录中。它包含以下内容：
- en: '![Figure 12.13: Example text file'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.13：示例文本文件]'
- en: '](img/B14177_12_13.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_12_13.jpg]'
- en: 'Figure 12.13: Example text file'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.13：示例文本文件]'
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The contents of `text.txt` get assigned as a slice of bytes into the variable
    content. If there are any errors, they will be stored in the `err` variable:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text.txt` 的内容被分配为字节切片到变量 `content` 中。如果有任何错误，它们将被存储在 `err` 变量中：'
- en: '[PRE49]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Since this is a slice of bytes, it must be converted into a string format for
    ease of readability. Here are the results of the print statements:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这是一个字节切片，必须将其转换为字符串格式以便于阅读。以下是打印语句的结果：
- en: '![Figure 12.14: Example output'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.14：示例输出]'
- en: '](img/B14177_12_14.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_12_14.jpg]'
- en: 'Figure 12.14: Example output'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.14：示例输出]'
- en: 'The next function we will look at that reads the entire content into memory
    is the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的下一个函数是读取整个内容到内存的以下函数：
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Unlike the `ReadFile` method, `ReadAll` takes `io.Reader` as an argument. That
    is the only real difference in the behavior of `ReadFile` and `ReadAll`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `ReadFile` 方法不同，`ReadAll` 方法接受 `io.Reader` 作为参数。这是 `ReadFile` 和 `ReadAll`
    行为之间唯一的真正区别：
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Let''s understand the code in pieces:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐部分理解代码：
- en: '[PRE52]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `ioutil.ReadAll` method requires `io.Reader` as an argument. The `os.Open`
    method returns an `*os.File` type, which satisfies the `io.Reader` interface:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ioutil.ReadAll` 方法需要一个 `io.Reader` 作为参数。`os.Open` 方法返回一个 `*os.File` 类型，它满足
    `io.Reader` 接口：'
- en: '[PRE53]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The content stores the `[]byte` data from the result of the `ioutil.ReadAll(f)`
    method. If there are any errors, they will be stored in the `err` variable:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容存储了从 `ioutil.ReadAll(f)` 方法结果中获取的 `[]byte` 数据。如果有任何错误，它们将被存储在 `err` 变量中：
- en: '[PRE54]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Since this is a slice of bytes, it must be converted to a string format for
    ease of readability. The results of the print statements are as follows:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这是一个字节切片，必须将其转换为字符串格式以便于阅读。打印语句的结果如下：
- en: '![Figure 12.15: Example output'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.15：示例输出]'
- en: '](img/B14177_12_15.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14177_12_15.jpg]'
- en: 'Figure 12.15: Example output'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.15：示例输出]'
- en: '[PRE55]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Since the `ioutil.ReadAll` method accepts an interface, this gives us more flexibility.
    If you recall *Chapter 7, Interfaces*, when using interfaces, it allows for more
    flexibility and uses.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 `ioutil.ReadAll` 方法接受接口，这为我们提供了更多的灵活性。如果您还记得 *第 7 章，接口*，当使用接口时，它允许更多的灵活性和使用：
- en: 'We are using `strings.NewReader`, which takes a string and returns a `Reader`
    type that implements the `io.Reader` interface. This allows us to use the `ioutil.ReadAll()`
    method without having a file. By doing this, we can perform various tests on the
    data when we have not yet been given the file:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `strings.NewReader`，它接受一个字符串并返回一个实现 `io.Reader` 接口的 `Reader` 类型。这允许我们在没有文件的情况下使用
    `ioutil.ReadAll()` 方法。通过这样做，我们可以在尚未提供文件时对数据进行各种测试：
- en: '[PRE56]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can use the `ioutil.Readall` method in the same fashion with the results
    of `strings.Reader()` as we did with `os.Open()`:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 `ioutil.Readall` 方法以与 `os.Open()` 相同的方式使用 `strings.Reader()` 的结果：
- en: '[PRE57]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Following are the results of the print statement:'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是打印语句的结果：
- en: '![Figure 12.16: The strings.NewReader content'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.16：strings.NewReader 内容'
- en: '](img/Image74026.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Image74026.jpg)'
- en: 'Figure 12.16: The strings.NewReader content'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.16：strings.NewReader 内容
- en: 'We have seen various ways to write to files, create files, and to read from
    files. However, we have yet to see how to append data to a file. There are times
    when you would want to append a file with additional information. The `os.OpenFile()`
    method provides this ability. Most of the time, you will use `Create` or `Open`
    for your open or create processes; however, when you want to append data to a
    file, you will need to use `OpenFile`. The signature of the method is as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了各种写入文件、创建文件和从文件中读取的方法。然而，我们还没有看到如何向文件中追加数据。有时你可能想要向文件追加额外的信息。`os.OpenFile()`
    方法提供了这种能力。大多数时候，你将使用 `Create` 或 `Open` 来进行打开或创建过程；然而，当你想要向文件追加数据时，你需要使用 `OpenFile`。该方法的签名如下：
- en: '[PRE58]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The one parameter that is unique is the `flag` parameter. This is used to determine
    what actions to allow when opening the file; it is not to be confused with the
    `FileMode` type, which is what permission types get to assign to the file itself.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一一个独特的参数是 `flag` 参数。这个参数用于确定打开文件时允许执行的操作；它不要与 `FileMode` 类型混淆，后者是权限类型可以分配给文件本身的。
- en: 'Here is a list of flags that can be used to open a file ([http://golang.org/src/pkg/os/file.go](http://golang.org/src/pkg/os/file.go)):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是可用于打开文件的一些标志列表（[http://golang.org/src/pkg/os/file.go](http://golang.org/src/pkg/os/file.go)）：
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'These flags can be used in various combinations when opening a file. Let''s
    take a look at some various examples using the flags:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标志可以在打开文件时以各种组合使用。让我们看看一些使用标志的例子：
- en: '[PRE60]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s look at `os.OpenFile` in the previous example:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看前一个例子中的 `os.OpenFile`：
- en: '[PRE61]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Using `os.OpenFile` with the `os.O_CREATE` file mode will create the `junk101.txt`
    file if it does not exist, and then open it.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有 `os.O_CREATE` 文件模式的 `os.OpenFile` 将在文件不存在时创建 `junk101.txt` 文件并打开它。
- en: 'Let''s look at an example using different file modes for `os.OpenFile`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 `os.OpenFile` 的不同文件模式的一个例子：
- en: '[PRE62]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Let's look at the preceding code in more detail.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看前面的代码。
- en: '[PRE63]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Using `os.OpenFile` with the `os.O_CREATE` flag will create the `junk101.txt`
    file if it does not exist and then open it. If it does exist, it will just open
    the file. It will also allow the reading and writing of the file while it is open
    because of the `os.O_WRONLY` flag:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有 `os.O_CREATE` 标志的 `os.OpenFile` 将在文件不存在时创建 `junk101.txt` 文件并打开它。如果它已经存在，它将只打开文件。由于
    `os.O_WRONLY` 标志，它还将允许在文件打开时进行读写操作：
- en: '[PRE64]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Since we used the `os.O_WRONLY` flag, we can write to the file while it is open.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们使用了 `os.O_WRONLY` 标志，我们可以在文件打开时写入它。
- en: 'Let''s look at an example of how to append data to a file:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何向文件追加数据的一个例子：
- en: '[PRE65]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Using `os.OpenFile` with the `os.O_CREATE` flag will create the `junk101.txt`
    file if it does not exist and then open it. If it does exist, it will just open
    the file:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用带有 `os.O_CREATE` 标志的 `os.OpenFile` 将在文件不存在时创建 `junk101.txt` 文件并打开它。如果它已经存在，它将只打开文件：
- en: It will also allow the reading and writing of the file while it is open because
    of the `os.O_WRONLY` flag.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 `os.O_WRONLY` 标志，它还将允许在文件打开时进行读写操作。
- en: '`os.O_APPEND` will allow you to append data to the bottom of the file:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`os.O_APPEND` 将允许你将数据追加到文件底部：'
- en: '[PRE66]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Since we used the `os.O_WRONLY` flag, we can write to the file while it is open.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们使用了 `os.O_WRONLY` 标志，我们可以在文件打开时写入它。
- en: 'The data will be appended to the bottom of the file and not override the existing
    data since we included the `os.O_APPEND` flag. The following define some common
    permission flag combinations that can be used for `os.OpenFile`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们包含了 `os.O_APPEND` 标志，数据将被追加到文件底部，而不是覆盖现有数据。以下是一些常见的权限标志组合，可用于 `os.OpenFile`：
- en: '**os.O_CREATE**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**os.O_CREATE**'
- en: If the file does not exist, it will create the file when attempting to open
    it.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件不存在，它将在尝试打开时创建文件。
- en: '**os.O_CREATE | os.O_WRONLY**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**os.O_CREATE | os.O_WRONLY**'
- en: When opening a file, you can now write to it.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当打开文件时，你现在可以写入它。
- en: Any data that is in the file will be overwritten.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件中的任何数据都将被覆盖。
- en: '**os.O_CREATE | os.O_WRONLY | os.O_APPEND**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**os.O_CREATE | os.O_WRONLY | os.O_APPEND**'
- en: When writing to the file, it will not overwrite the data but rather append the
    data to the end of the file.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当写入文件时，它不会覆盖数据，而是将数据追加到文件末尾。
- en: 'Exercise 12.02: Backing Up Files'
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.02：备份文件
- en: 'Oftentimes, when working with files, we need to back up a file before making
    changes to it. This is for instances where we might make mistakes or want the
    original file for auditing purposes. In this exercise, we will take an existing
    file called `note.txt` and back it up to `backupFile.txt`. We will then open `note.txt`
    and add some additional notes to the end of the file. Our directory will contain
    the following files:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文件时，我们通常需要在对其进行更改之前备份文件。这是在可能犯错或需要原始文件进行审计目的的情况下。在本练习中，我们将取一个名为`note.txt`的现有文件，并将其备份到`backupFile.txt`。然后我们将打开`note.txt`并在文件末尾添加一些额外的笔记。我们的目录将包含以下文件：
- en: '![Figure 12.17: Backing up files to the directory'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.17：将文件备份到目录'
- en: '](img/B14177_12_17.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_12_17.jpg)'
- en: 'Figure 12.17: Backing up files to the directory'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17：将文件备份到目录
- en: 'We must first create the `note.txt` file in the same directory as our executable.
    This file can be blank or contain some sample data such as this:![Figure 12.18:
    Example of the notes.txt file content'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须首先在可执行文件相同的目录中创建`note.txt`文件。此文件可以是空的，也可以包含一些示例数据，如下所示：![图12.18：notes.txt文件内容示例
- en: '](img/B14177_12_18.jpg)'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_12_18.jpg)'
- en: 'Figure 12.18: Example of the notes.txt file content'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.18：notes.txt文件内容示例
- en: Create a Go file called `main.go`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的Go文件。
- en: This program will be part of the `main` package.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此程序将是`main`包的一部分。
- en: 'Include the imports, as seen in the following code:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含以下代码中的导入：
- en: '[PRE67]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Create a custom error that will be used for when the working file (`note.txt`)
    is not found:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于当工作文件（`note.txt`）未找到时使用的自定义错误：
- en: '[PRE68]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Create a function that will be performing the backup. This function is responsible
    for taking the working file and storing its content into the `backup` file. This
    function accepts two arguments. The `working` parameter is the file path of the
    file that you currently are working on:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个执行备份操作的函数。此函数负责将工作文件的内容存储到`backup`文件中。此函数接受两个参数。`working`参数是你当前正在工作的文件的文件路径：
- en: '[PRE69]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Inside this function, we will need to check to see whether the working file
    exists. It must first exist before we can read its contents and store them in
    our backup file.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此函数内部，我们需要检查工作文件是否存在。在我们可以读取其内容并将其存储在我们的备份文件中之前，它必须首先存在。
- en: We are able to check to see whether the error is one where the file does not
    exist by using `os.IsNotExist(err)`.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`os.IsNotExist(err)`来检查错误是否是文件不存在的情况。
- en: 'If the file does not exist, we will return with our custom error: `ErrWorkingFileNotFound`:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件不存在，我们将返回我们的自定义错误：`ErrWorkingFileNotFound`：
- en: '[PRE70]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Next, we need to open the working file and store the `os.File` return by the
    function to the `workFile` variable:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要打开工作文件并将函数返回的`os.File`存储到`workFile`变量中：
- en: '[PRE71]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We need to read the contents of the `workFile`. We will be using the `ioutil.ReadAll`
    method to get all the contents of the `workFile`. The `workFile` is of the `os.File`
    type, which satisfies the `io.Reader` interface; this allows us to pass it to
    `ioutil.ReadFile`.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要读取`workFile`的内容。我们将使用`ioutil.ReadAll`方法获取`workFile`的所有内容。`workFile`是`os.File`类型，它满足`io.Reader`接口；这允许我们将其传递给`ioutil.ReadFile`。
- en: 'Check to see whether there is an error:'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查是否有错误：
- en: '[PRE72]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `content` variable contains the data of the `workFile` represented as a
    slice of bytes. That data needs to be written to the backup file. We will implement
    the code that will write the data of the `content` variable to the backup file.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`content`变量包含`workFile`的数据，表示为字节数组。这些数据需要写入备份文件。我们将实现将`content`变量的数据写入备份文件的代码。'
- en: The content stores the `[]byte` data that gets returned from the function. This
    is the entire content of the file stored in the variable.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内容存储从函数返回的`[]byte`数据。这是存储在变量中的整个文件内容。
- en: 'We can use the `ioutil.Writefile` method. If the backup file does not exist,
    it will create the file. If the backup file does exist, it will overwrite the
    file with the content variable data:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`ioutil.Writefile`方法。如果备份文件不存在，它将创建文件。如果备份文件已存在，它将使用`content`变量数据覆盖文件：
- en: '[PRE73]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We need to return `nil`, indicating that, at this juncture, we have not encountered
    any errors:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要返回`nil`，表示在此阶段，我们没有遇到任何错误：
- en: '[PRE74]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Create a function that will append data to our working file.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，用于将数据追加到我们的工作文件中。
- en: 'Name the function `addNotes`; this will accept the location of our working
    file and a string argument that will be appended to the working file. The function
    will need to return an error:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将函数命名为 `addNotes`；这将接受我们的工作文件位置和一个将被追加到工作文件的字符串参数。该函数需要返回一个错误：
- en: '[PRE75]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Inside the `addNotes` function, add a line that will append a new line to each
    note''s string. This will place each note on a separate line:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `addNotes` 函数内部，添加一行代码，将新行追加到每个笔记的字符串中。这将使每个笔记单独占一行：
- en: '[PRE76]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, we will open the working file and allow for appending to the file. The
    `os.OpenFile()` function will create the file if it does not exist. Check for
    any errors:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将打开工作文件并允许向文件追加内容。`os.OpenFile()` 函数将在文件不存在时创建该文件。检查任何错误：
- en: '[PRE77]'
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'After opening a file and checking for an error, we should make sure that it
    closes when the function exits by using the defer function, `f.Close()`:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开文件并检查错误后，我们应该确保使用 `defer` 函数，`f.Close()`，在函数退出时关闭文件：
- en: '[PRE78]'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The final step of the function is to write the contents of the note to the
    `workingFile` variable. We can use the `Write` method to accomplish this:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的最终步骤是将笔记的内容写入 `workingFile` 变量。我们可以使用 `Write` 方法来完成此操作：
- en: '[PRE79]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In the `main()` function, we will initialize three variables; the `backupFile`
    variable contains the name of the file for backing up our `workingFile` variable,
    while the `data` variable is what we will be writing to our `workingFile` variable:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们将初始化三个变量；`backupFile` 变量包含备份我们的 `workingFile` 变量的文件名，而 `data`
    变量是我们将要写入 `workingFile` 变量的内容：
- en: '[PRE80]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Call our `createBackup()` function to back up our `workingFile`. Check for
    errors after calling the function:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用我们的 `createBackup()` 函数来备份我们的 `workingFile`。在调用函数后检查错误：
- en: '[PRE81]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Create a `for` loop that will iterate `10` times.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环，该循环将迭代 `10` 次。
- en: Each iteration we set our `note` variable to the `data` variable plus the `i`
    variable of our loop.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每次迭代中，我们将我们的 `note` 变量设置为 `data` 变量加上我们的循环的 `i` 变量。
- en: Since our `note` variable is a string and our `i` variable is an `int`, we will
    need to convert `i` to a string using the `strconv.Itoa(i)` method.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的 `note` 变量是字符串，而我们的 `i` 变量是 `int` 类型，因此我们需要使用 `strconv.Itoa(i)` 方法将 `i`
    转换为字符串。
- en: Call our `addNotes()` function and pass the `workingFile` and our `note` variables.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用我们的 `addNotes()` 函数，并传递 `workingFile` 和我们的 `note` 变量。
- en: 'Check for any errors returned from the function:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查函数返回的任何错误：
- en: '[PRE82]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Run the program:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序：
- en: '[PRE83]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Evaluate the changes to the files after running the program.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估程序运行后文件的变化。
- en: 'Following are the results after running the program:'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是程序运行后的结果：
- en: '![Figure 12.19: The results of backing up the files'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 12.19：备份文件的结果'
- en: '](img/B14177_12_19.jpg)'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_12_19.jpg)'
- en: 'Figure 12.19: The results of backing up the files'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.19：备份文件的结果
- en: CSV
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSV
- en: 'One of the most common ways a file is structured is as a comma-separated value.
    This is a clear text file that contains data, which is basically represented as
    rows and columns. Frequently, these files are used to exchange data. A CSV file
    has a simple structure. Each piece of data is separated by a comma and then a
    new line for another record. An example of a CSV file would be as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 文件结构最常见的方式之一是逗号分隔值。这是一个包含数据的纯文本文件，基本上表示为行和列。通常，这些文件用于交换数据。CSV 文件具有简单的结构。每条数据由逗号分隔，然后是新的一行用于另一个记录。以下是一个
    CSV 文件的示例：
- en: '[PRE84]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'You will, at some point in your life, come across CSV files as they are very
    common. The Go programming language has a standard library that is used for handling
    CSV files: `encoding/csv`:'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的生活中，你会在某个时候遇到 CSV 文件，因为它们非常常见。Go 编程语言有一个用于处理 CSV 文件的标准化库：`encoding/csv`：
- en: '[PRE85]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The following creates a `reader` type and returns it:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 以下创建了一个 `reader` 类型并返回它：
- en: '[PRE86]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `NewReader` method takes an argument of `io.Reader` and returns a type
    of `Reader` that is used to read the CSV data:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewReader` 方法接受一个 `io.Reader` 参数，并返回一个用于读取 CSV 数据的 `Reader` 类型：'
- en: '[PRE87]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Here, we are reading in each record one at a time in an infinite loop. After
    each record we read, we check first to see whether it is the end of the file (`io.EOF`);
    if so, we break out of the loop. The `r.Read()` function reads one record; it
    is a slice of strings from the `r` variable. It returns that record as a `[]string`
    type.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在无限循环中逐个读取每个记录。在读取每个记录后，我们首先检查它是否是文件的末尾（`io.EOF`）；如果是，则退出循环。`r.Read()`
    函数读取一个记录；它是 `r` 变量的字符串切片。它返回一个 `[]string` 类型的记录。
- en: 'Here is the result of printing the record:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是打印记录的结果：
- en: '![Figure 12.20: CSV example output'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.20：CSV示例输出'
- en: '](img/B14177_12_20.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_12_20.jpg)'
- en: 'Figure 12.20: CSV example output'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20：CSV示例输出
- en: 'Do you think there might be a way to access each individual value? Currently,
    we have only looked at printing out of each row. There are instances, however,
    where we might want to access just the age or the first name. The next example
    will show us just how to do that:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为是否有办法访问每个单独的值？目前，我们只看了如何打印每一行。然而，在某些情况下，我们可能只想访问年龄或名字。下一个示例将展示我们如何做到这一点：
- en: '[PRE88]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'We will discuss the new portions of the code in this example:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本例中讨论代码的新部分：
- en: '`header := true`'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`header := true`'
- en: 'We will use the `header` variable as a flag. It will aid us in parsing the
    headers of the CSV data:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`header`变量作为标志。它将帮助我们解析CSV数据的标题：
- en: '[PRE89]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The infinite loop will stop once the end of the file is reached:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 无限循环将在到达文件末尾时停止：
- en: '[PRE90]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The `r.Read()` function reads a single record and returns a slice of strings
    that contains the fields of that record:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`r.Read()`函数读取单个记录并返回一个包含该记录字段的字符串切片：'
- en: '[PRE91]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: This breaks out of the infinite loop if it is the end of the file.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是文件末尾，则跳出无限循环。
- en: '[PRE92]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Next, check to see whether this is the first iteration of the loop. If this
    is the first iteration of the loop, then the first row would be the headers of
    the fields; we do not want to parse the headers:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，检查这是否是循环的第一个迭代。如果是循环的第一个迭代，那么第一行将是字段的标题；我们不希望解析标题：
- en: '[PRE93]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Range over the fields in the record:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历记录中的字段：
- en: '[PRE94]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The `switch` statement is used to perform the specific parsing of each field:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`switch`语句执行每个字段的特定解析：
- en: '[PRE95]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Initially set to `true`, after the first time through the loop, it can be set
    to `false`. Headers are usually the first row of the file.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 初始设置为`true`，在第一次通过循环后，可以将其设置为`false`。标题通常是文件的第一行。
- en: 'The output is as follows:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 12.21: Output of parsing CSV fields'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.21：解析CSV字段的输出'
- en: '](img/B14177_12_21.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_12_21.jpg)'
- en: 'Figure 12.21: Output of parsing CSV fields'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21：解析CSV字段的输出
- en: 'Activity 12.01: Parsing Bank Transaction Files'
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十二.01：解析银行交易文件
- en: 'In this activity, we will be ingesting a transaction file from the bank. The
    file is a CSV file. Our bank also includes budget categories for the transactions
    in the file. The file is as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将从银行获取交易文件。该文件是一个CSV文件。我们的银行还包括文件中交易的预算类别。文件如下：
- en: '[PRE96]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The aim of this activity is to create a command-line program that will accept
    two flags: the location of the CSV bank transaction file and the location of a
    log file. We will check that the log and bank file location is valid before the
    application starts parsing the CSV file. The program will parse the CSV file and
    log any errors it encounters to the log. Upon each restart of the program, it
    will also delete the previous log file.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的目的是创建一个命令行程序，该程序将接受两个标志：CSV银行交易文件的位置和日志文件的位置。在应用程序开始解析CSV文件之前，我们将检查日志和银行文件位置是否有效。程序将解析CSV文件，并将遇到的任何错误记录到日志中。每次程序重启时，它还将删除之前的日志文件。
- en: 'Follow these steps to complete the activity:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成活动：
- en: We will need to create budget category types for `fuel`, `food`, `mortgage`,
    `repairs`, `insurance`, `utilities`, and `retirement`.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为`fuel`、`food`、`mortgage`、`repairs`、`insurance`、`utilities`和`retirement`创建预算类别类型。
- en: Create a custom error for when a budget category is not found.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个自定义错误，用于当找不到预算类别时。
- en: Create a struct type transaction that has `ID`, `payee`, `spent`, and `category`
    fields (the type is what we created in the first step).
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有`ID`、`payee`、`spent`和`category`字段的结构体类型`transaction`（这是我们在第一步中创建的类型）。
- en: Create a function that will accept the category from the bank transaction file.
    This function will map the transaction categories to our categories. Mappings
    include `fuel` and `gas` maps to `autoFuel`, `food` maps to `food`, `mortgage`
    maps to `mortgage`, `repairs` map to `repairs`, `car` `insurance` and `life` `insurance`
    maps to `insurance`, `utilities` maps to `utilities`, and everything else will
    return the custom error that we created in the previous step. The function will
    return our `budgetCategory` type and an error.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将接受来自银行交易文件的类别的函数。这个函数将交易类别映射到我们的类别。映射包括`fuel`和`gas`映射到`autoFuel`，`food`映射到`food`，`mortgage`映射到`mortgage`，`repairs`映射到`repairs`，`car`
    `insurance`和`life` `insurance`映射到`insurance`，`utilities`映射到`utilities`，其他所有内容将返回我们在上一步中创建的自定义错误。该函数将返回我们的`budgetCategory`类型和一个错误。
- en: Create a `writeErrorToLog(msg string, err error, data string, logfile string)
    error.` function. This will take the `msg`, `err`, and `data` strings and write
    them to the log file.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`writeErrorToLog(msg string, err error, data string, logfile string) error.`函数。这个函数将接受`msg`、`err`和`data`字符串并将它们写入日志文件。
- en: 'Create a function with the following signature: `parseBankFile(bankTransactions io.Reader, logFile string) []transaction`.
    This function will iterate over the `bankTransaction` file.As it is looping, use
    a `switch` statement and examine the index of the record.'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有以下签名的函数：`parseBankFile(bankTransactions io.Reader, logFile string) []transaction`。这个函数将遍历`bankTransaction`文件。在它循环时，使用`switch`语句并检查记录的索引。
- en: Each `case` statement assigns the value of the index to the respective value
    of the `transaction` struct.When the case statement index matches the category
    of the CSV file, we need to call our `convertToBudgeCategory()`. This will map
    the bank transaction to our budget category.
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个`case`语句将索引的值分配给`transaction`结构体中的相应值。当`case`语句的索引与CSV文件的类别匹配时，我们需要调用我们的`convertToBudgetCategory()`。这将把银行交易映射到我们的预算类别。
- en: In the `main()` function, we need two `c` flags for the transaction file and
    `l` for the location of the log file.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们需要两个`c`标志用于交易文件，以及一个`l`标志用于日志文件的位置。
- en: The bank transaction file and log file are required, so you must ensure they
    are present before continuing.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 银行交易文件和日志文件是必需的，因此你必须确保它们在继续之前存在。
- en: You will then call the `parsBankFile()` function and print the `[]transactions`
    that gets returned from the function.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后调用`parseBankFile()`函数并打印从函数返回的`[]transactions`。
- en: 'The following is the output:'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下为输出：
- en: '![Figure 12.22: Format of the transaction file'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.22：交易文件格式](img/B14177_12_22.jpg)'
- en: '](img/B14177_12_22.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_12_22.jpg)'
- en: 'Figure 12.22: Format of the transaction file'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22：交易文件格式
- en: Note
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 737.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可在第737页找到。
- en: In this activity, we created a command-line application that accepted flags.
    We also configured our command-line application to require those flags. In this
    command-line application, we created and modified files. We also parsed a common
    file format used in system programming, the comma-separated value (CSV) file.
    We were able to read from the file and store the data in the file in our various
    struct types. We were able to continue to process the CSV file when we encountered
    an error. When we encountered an error, we wrote to a log file for later debugging.
    This command-line application demonstrated real-world activities that are generally
    done in programming command-line applications (such as accepting flags, requiring
    flags, parsing a file such as CSV, modifying and creating files, and logging).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们创建了一个接受标志的命令行应用程序。我们还配置了我们的命令行应用程序以要求这些标志。在这个命令行应用程序中，我们创建和修改了文件。我们还解析了系统编程中常用的逗号分隔值（CSV）文件格式。我们能够从文件中读取并将数据存储在我们的各种结构类型中。当我们遇到错误时，我们能够继续处理CSV文件。当我们遇到错误时，我们将错误写入日志文件以供后续调试。这个命令行应用程序展示了在编程命令行应用程序中通常进行的实际活动（例如接受标志、要求标志、解析如CSV的文件、修改和创建文件以及记录）。
- en: Summary
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we gained an understanding of how Go views and uses file permissions.
    We learned that file permissions can be represented as symbolic and octal notations.
    We discovered that the Go standard library has built-in support for opening, reading,
    writing, creating, deleting, and appending data to a file. We looked at the `flag`
    package and how it provides functionality to create command-line applications
    to accept arguments.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Go如何查看和使用文件权限。我们学习了文件权限可以用符号和八进制表示。我们发现Go标准库内置了对打开、读取、写入、创建、删除和向文件追加数据的功能的支持。我们探讨了`flag`包以及它是如何提供创建命令行应用程序以接受参数的功能的。
- en: Using the `flag` package, we could also print out `usage` statements that pertained
    to our command-line application.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`flag`包，我们还可以打印出与我们的命令行应用程序相关的`usage`语句。
- en: Then, we demonstrated how OS signals can impact our Go program; however, by
    using the Go standard library, we can capture OS signals and, if applicable, control
    how we want to exit our program.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们演示了OS信号如何影响我们的Go程序；然而，通过使用Go标准库，我们可以捕获OS信号，并在适用的情况下控制我们希望如何退出我们的程序。
- en: We also learned that Go has a standard library for working with CSV files. In
    working with files previously, we saw that we can also work with files that are
    structured as CSV files. That Go CSV package provides the ability to iterate over
    the contents of the file. The CSV file can be viewed as rows and columns similar
    to database tables. In the next chapter, we will look at how to connect to databases
    and execute SQL statements against a database. This will demonstrate the ability
    of Go to be used for applications that require a backend for storing data.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到Go有一个用于处理CSV文件的标准库。在之前处理文件时，我们看到了我们还可以处理结构化为CSV文件的文件。Go CSV包提供了遍历文件内容的能力。CSV文件可以看作是类似于数据库表的行和列。在下一章中，我们将探讨如何连接到数据库并执行针对数据库的SQL语句。这将展示Go在需要后端存储数据的应用程序中的使用能力。
