<html><head></head><body>
		<div>
			<div id="_idContainer223" class="Content">
			</div>
		</div>
		<div id="_idContainer224" class="Content">
			<h1 id="_idParaDest-308"><a id="_idTextAnchor326"/>13. SQL and Databases</h1>
		</div>
		<div id="_idContainer234" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter's aim is to enable you to connect to SQL databases with the help of the Go programming language.</p>
			<p class="callout">You will start by learning to connect to databases, creating tables in a database and insert data into and retrieve data from tables. By the end of this chapter, you will be able to update and delete data in specific tables, and also truncate and drop tables.</p>
			<h1 id="_idParaDest-309"><a id="_idTextAnchor327"/>Introduction</h1>
			<p>In the previous chapter, you learned how to interact with the system your Go app is running on. You learned the importance of exit codes and how to customize your scripts to take arguments, thus adding flexibility to your applications. You also learned the mastery of handling different signals that your application receives.</p>
			<p>In this chapter, you will further master your Go skills by learning how to use SQL and databases in Go. As a developer, it is impossible to get by without a proper understanding of persistent data storage and databases. Our applications process input and produce output, but most of the time, if not in all cases, a database is involved in the process. This database can be in memory (stored in the computer's RAM) or file-based (a single file in a directory), and it can live on local or remote storage. The cloud can provide you with database services; both Azure and AWS can help you with that.</p>
			<p>What we aim to do in this chapter is to make you fluent in talking to these databases and understand the basic concepts of what a database is. Finally, you should extend your skillset to make you a better Go developer as you progress through this chapter.</p>
			<p>Let's say your boss wants you to create a Go app that can communicate with a database. By "communicate", we mean that any transaction that is <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">DELETE</strong>, or <strong class="source-inline">CREATE</strong> can and should be handled by the application. This chapter will show you how to do that.</p>
			<h1 id="_idParaDest-310"><a id="_idTextAnchor328"/>The Database</h1>
			<p>In order to make this chapter more appealing, let's see how you can have a database solution called <strong class="source-inline">Postgres</strong> on your system and configure it for yourself so you can try out the following examples.</p>
			<p>First, we need to grab the installer from <a href="https://packt.live/2RMFPYV">https://packt.live/2RMFPYV</a>. Select the one which is appropriate. The installer is very easy to use, and I suggest you accept the defaults:</p>
			<ol>
				<li>Run the installer:<div id="_idContainer225" class="IMG---Figure"><img src="image/B14177_13_01.jpg" alt="Figure 13.1: Selecting the installation directory&#13;&#10;"/></div><p class="figure-caption">Figure 13.1: Selecting the installation directory</p></li>
				<li>Leave the default components:<div id="_idContainer226" class="IMG---Figure"><img src="image/B14177_13_02.jpg" alt="Figure 13.2: Selecting components to install&#13;&#10;"/></div><p class="figure-caption">Figure 13.2: Selecting components to install</p></li>
				<li>Leave the default data directory:</li>
			</ol>
			<div>
				<div id="_idContainer227" class="IMG---Figure">
					<img src="image/B14177_13_03.jpg" alt="Figure 13.3: Selecting the data directory&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3: Selecting the data directory</p>
			<p>It will ask for a password, which you need to remember because this is the master password for your database. <strong class="source-inline">Start!123</strong> is the password for this example. The database is running on the local port 5432. The <strong class="source-inline">pgAdmin</strong> GUI tool will also be installed, and, once the installer completes, you can start <strong class="source-inline">pgAdmin</strong> to connect to the database.</p>
			<p>In the browser, the following link can be used to access the admin surface: <a href="https://packt.live/2PKWc5w">https://packt.live/2PKWc5w</a>:</p>
			<div>
				<div id="_idContainer228" class="IMG---Figure">
					<img src="image/B14177_13_04.jpg" alt="Figure 13.4: The admin interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4: The admin interface</p>
			<p>Once the installation is complete, we are ready to proceed to the next part and connect to the database via Go.</p>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor329"/>Database API and Drivers</h1>
			<p>In order to work with databases, there is something called the "pure" Go approach, which means Go has an API that allows you to use different drivers to connect to databases. The API comes from the <strong class="source-inline">database/sql</strong> package, and the drivers can be of two types. There is native support for a wide variety of drivers, which can be found on the official GitHub page (<a href="https://packt.live/2LMzcC4">https://packt.live/2LMzcC4</a>), and there are third-party drivers that need additional packages to function, such as the <strong class="source-inline">SQLlite3</strong> package, which requires you to have <strong class="source-inline">GCC</strong> installed because it is a pure C implementation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">GCC is a compiler system produced by the GNU Project. It takes your source code and translates it to machine code so that your computer can run the application.</p>
			<p>Here is a list of a couple of drivers:</p>
			<ul>
				<li><strong class="bold">MySQL</strong> (<a href="https://packt.live/38zk9Fw">https://packt.live/38zk9Fw</a>)</li>
				<li><strong class="bold">Oracle</strong> (<a href="https://packt.live/34cxwrP">https://packt.live/34cxwrP</a>)</li>
				<li><strong class="bold">ODBC</strong> (<a href="https://packt.live/2EfETV8">https://packt.live/2EfETV8</a>)</li>
				<li><strong class="bold">Postgres</strong> (<a href="https://packt.live/35jKEwL">https://packt.live/35jKEwL</a>)</li>
			</ul>
			<p>The idea behind the API and driver approach is that Go provides a unified interface that allows developers to talk to different types of databases. All you need to do is import the API and the necessary driver and you are able to talk to the database. You don't need to learn driver-specific implementations or how that driver works because the API's sole purpose is to create an abstraction layer that accelerates development.</p>
			<p>Let's take an example. Let's say we would like to have a script that queries a database. This database is MySQL. One approach is to take the driver and learn how to code in its language, and then you are good to go. Some time passes by, and you build lots of small scripts that do their job properly. Now the time has come for a management decision that will make you unhappy. They decide that MySQL is not good enough, and they will replace the database with AWS Athena, a cloud-based database. Now, since you wrote your scripts specifically for a certain driver, you will be busy rewriting your scripts in order for them to work properly. The safeguard here is to use a unified API and driver combination. This means writing the scripts against the API and not the driver. The API will translate your wishes for the specific driver. This way, all you need to do is swap out the driver, and the scripts are guaranteed to work. You just saved yourself many hours of scripting and rewriting code, even though the underlying database has been completely replaced.</p>
			<p>When we are working with databases in Go, we differentiate these types of databases:</p>
			<ul>
				<li>Relational databases</li>
				<li>NoSQL databases</li>
				<li>Search and analytic databases</li>
			</ul>
			<h1 id="_idParaDest-312"><a id="_idTextAnchor330"/>Connecting to Databases</h1>
			<p>Connecting to a database is by far the easiest thing to do; however, we need to keep a few things in mind. In order to connect to any database, we need at least four things to be in place. We need a host to connect to, we need a database to connect to that is running on a port, and we need a username and password. The user needs to have appropriate privileges because we not only want to connect but we would like to perform specific operations, such as query, insert, or remove data, create or delete databases, and manage users and views. Let's imagine that connecting to a database is like walking up to a door as a specific person with a specific key. Whether the door opens or not depends on the key, but what we can do after we have crossed the threshold will depend on the person (which is defined by their privileges).</p>
			<p>In most cases, the database server supports multiple databases and the databases hold one or more tables. Imagine that the databases are logical containers that belong together.</p>
			<p>Let's take a look at how we can connect to a database in Go. In order to connect, we need to get the appropriate module from GitHub, which needs internet connectivity. We need to issue the following command to get the package needed to interact with the Postgres instance:</p>
			<p class="source-code">go get github.com/lib/pq</p>
			<p>Once this completes, you are ready to start scripting. First, we will initialize our script:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">import "database/sql"</p>
			<p class="source-code">import _ "github.com/lib/pq"</p>
			<p><strong class="source-inline">import _ &lt;package name&gt;</strong> is a special <strong class="source-inline">import</strong> statement that tells Go to import a package solely for its side effects.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you would like further information, visit <a href="https://packt.live/2PByusw">https://packt.live/2PByusw</a>.</p>
			<p>Now that we have initialized our script, we can actually connect to our database:</p>
			<p class="source-code">db, err := sql.Open("postgres", "user=postgres password=Start!123 host=127.0.0.1 port=5432 dbname=postgres sslmode=disable")</p>
			<p>This topic is special because the API gives us an <strong class="source-inline">Open()</strong> function, which takes a variety of arguments. There are shorthand ways of doing this, but I would like you to know about all the components that are involved in making the connections, so I will use the longer way. Later, you can decide which one to use. The <strong class="source-inline">Postgres</strong> tells the function to use the <strong class="source-inline">Postgres</strong> driver to make the connection. The second argument is a so-called connection string, which holds the <strong class="source-inline">user</strong>, <strong class="source-inline">password</strong>, <strong class="source-inline">host</strong>, <strong class="source-inline">port</strong>, <strong class="source-inline">dbname</strong>, and <strong class="source-inline">sslmode</strong> arguments, which will be used to initialize the connection. In this example, we connect to the localhost marked by <strong class="source-inline">127.0.0.1</strong> on the default port 5432, and we don't use <strong class="source-inline">ssl</strong>. For production systems, people tend to change the default port and enforce encrypted traffic via <strong class="source-inline">ssl</strong> toward the database server, and you should always follow the best practices concerning the type of database you're working with. As you can see, the <strong class="source-inline">Open()</strong> function returns two values. One is for the database connection and the other is for the error, if any occurred during initialization. How do we check whether the initialization was success? Well, we can check whether there were any errors by writing the following code:</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">  panic(err)</p>
			<p class="source-code">}else{</p>
			<p class="source-code">  fmt.Println("The connection to the DB was successfully initialized!")</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">panic()</strong> function in Go is used to indicate that something went wrong unexpectedly, and we are not prepared to handle it gracefully, thus stopping the execution. If the connection succeeds, we print out the <strong class="source-inline">The connection to the DB was successfully initialized!</strong> message. When you have a long-running application, it is worth incorporating a way to check whether the database is still reachable, because due to intermittent network errors you could lose the connection and fail to execute whatever you wanted to execute. This can be checked with the following small code snippet:</p>
			<p class="source-code">connectivity := db.Ping()</p>
			<p class="source-code">if connectivity != nil{</p>
			<p class="source-code">  panic(err)</p>
			<p class="source-code">}else{</p>
			<p class="source-code">  fmt.Println("Good to go!")</p>
			<p class="source-code">}</p>
			<p>In this case, we used the <strong class="source-inline">panic()</strong> function to indicate that the connection has been lost. Finally, once our job is done, we need to terminate our connection to the database in order to remove user sessions and free up resources. In big enterprise environments with thousands of users hitting the same database, it's a wise decision to use the database only when necessary, and once the work is done, close the connections. There are two ways to close the connection:</p>
			<p class="source-code">db.Close()</p>
			<p class="source-code">defer db.Close()</p>
			<p>The difference is the scope. <strong class="source-inline">db.Close()</strong> will terminate the connection to the database once the execution arrives at the specific line, while <strong class="source-inline">defer db.Close()</strong> indicates that the database connection should be executed once the function in which it was called goes out of scope. The idiomatic way to do it is with <strong class="source-inline">defer db.Close()</strong>.</p>
			<p>Now, in order to further demonstrate this, we will create a table.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The official <strong class="source-inline">Postgres</strong> module of Go can be found at <a href="https://packt.live/35jKEwL">https://packt.live/35jKEwL</a>.</p>
			<h1 id="_idParaDest-313"><a id="_idTextAnchor331"/>Creating Tables</h1>
			<p>The act of creating tables aims to make logical containers that persistently hold data that belongs together. Many companies create tables for many reasons, for example, tracking employee attendance, revenue tracking, and statistics. The common goal is to provide a service for applications that make sense of it. How do these database engines control who can access what data? There are basically two approaches. The first one is <strong class="bold">Access Control Lists</strong> (<strong class="bold">ACLs</strong>), which is a simple yet powerful approach. ACL security logic tells us which user has which permissions, such as <strong class="source-inline">CREATE</strong>, <strong class="source-inline">UPDATE</strong>, and <strong class="source-inline">DELETE</strong>. The second approach involves inheritance and roles. This is more robust and is better suited for big enterprises. Before using a database engine, there used to be a precheck to see what the size would be and how many users would use it. There is no point in shooting a sparrow with a shotgun, and there is no shoe size that fits all. It all depends on the situation. <strong class="source-inline">Postgres</strong> uses the second approach, and in this topic, we will see how to create a SQL table and how to create one specifically in <strong class="source-inline">Postgres</strong>.</p>
			<p>The general syntax for table creation looks like this:</p>
			<p class="source-code">CREATE TABLE table_name (</p>
			<p class="source-code">    column1 datatype constrain,</p>
			<p class="source-code">    column2 datatype constrain,</p>
			<p class="source-code">    column3 datatype constrain,</p>
			<p class="source-code">    ....</p>
			<p class="source-code">);</p>
			<p>Before we continue, we need to clarify what SQL is. SQL is a standard that stands for <strong class="bold">Structured Query Language</strong>. This standard specifies how a specific database engine should respond to specific commands from the user. When we talk via SQL to the <strong class="source-inline">Postgres</strong>, <strong class="source-inline">mysql</strong>, or <strong class="source-inline">mssql</strong> server, they all respond in the same way to a <strong class="source-inline">CREATE TABLE</strong> or <strong class="source-inline">INSERT</strong> command because they are SQL compliant. The idea of the standard is not to specify how the engine works internally but how the interaction with it should happen. These database engines usually differ in terms of functionality, speed, and storage approaches; that's where the variety comes from. This is not a full SQL or database engine tutorial. I just wanted to give you a brief explanation so that you understand the commands better. The general command for table creation is <strong class="source-inline">CREATE TABLE</strong>. This command is understood in the context of the database you are connected to. One server can host multiple databases, and connecting to the wrong one can cause headaches when issuing a command that modifies the structure. The command usually takes a column name, which is <strong class="source-inline">column1</strong> in our case, and the type of data in our column, which is <strong class="source-inline">datatype</strong>. Finally, we can set constraints on our columns, which will imbue them with special properties. The supported datatypes for our columns depend on the database engine. </p>
			<p>Here are some common datatypes:</p>
			<ul>
				<li>INT</li>
				<li>DOUBLE</li>
				<li>FLOAT</li>
				<li>VARCHAR, which is a string with a specific length</li>
			</ul>
			<p>The constraints also depend on the database engine, but some of them are as follows:</p>
			<ul>
				<li>NOT NULL</li>
				<li>PRIMARY KEY</li>
				<li>Named function</li>
			</ul>
			<p>The named function is executed every time a new record is inserted or an old one is updated and, based on the evaluation of the transaction, is either allowed or denied.</p>
			<p>We are not only able to create a table, but we can also empty the table, remove all of its contents, or remove the table itself from the database. In order to empty a table, we use the following:</p>
			<p class="source-code">TRUNCATE TABLE table_name</p>
			<p>In order to remove the table, we use:</p>
			<p class="source-code">DROP TABLE table_name</p>
			<p>Now create a new table. In <strong class="source-inline">Postgres</strong>, you have a default database you can use; we are not going to create a separate database for the examples.</p>
			<p>We would like to initialize our script, which you can find in the examples folder, and it's called <strong class="source-inline">DBInit.go</strong>:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">import "database/sql"</p>
			<p class="source-code">import _ "github.com/lib/pq"</p>
			<p>Now we are ready to define our <strong class="source-inline">main()</strong> function:</p>
			<p class="source-code-heading">DBInit.go</p>
			<p class="source-code">5  func main(){</p>
			<p class="source-code">6    db, err := sql.Open("postgres", "user=postgres password=Start!123        host=127.0.0.1 port=5432 dbname=postgres sslmode=disable")</p>
			<p class="source-code">7    if err != nil {</p>
			<p class="source-code">8      panic(err)</p>
			<p class="source-code">9    }else{</p>
			<p class="source-code">10     fmt.Println("The connection to the DB was successfully          initialized!")</p>
			<p class="source-code">11   }</p>
			<p class="source-code">12 DBCreate := `</p>
			<p class="source-code">13   CREATE TABLE public.test</p>
			<p class="source-code">14   (</p>
			<p class="source-code">15     id integer,</p>
			<p class="source-code">16     name character varying COLLATE pg_catalog."default"</p>
			<p class="source-code">17   )</p>
			<p class="source-code">18   WITH (</p>
			<p class="source-code">19     OIDS = FALSE</p>
			<p class="source-code">20   )</p>
			<p class="source-code-link">The full code is available at: <a href="https://packt.live/34Ovy15">https://packt.live/34Ovy15</a></p>
			<p>Let's dissect what is happening here. We initialize our connection to the database without the default username and password that was previously mentioned, and now we have the <strong class="source-inline">db</strong> variable to interact with the database. Unless there was an error upon execution, the following output will be visible on our console:</p>
			<p class="source-code">The connection to the DB was successfully initialized!</p>
			<p class="source-code">The table was successfully created!</p>
			<p>If we were to rerun the script, the following error would occur:</p>
			<div>
				<div id="_idContainer229" class="IMG---Figure">
					<img src="image/B14177_13_05.jpg" alt="Figure 13.5: Output of failure after consecutive execution&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.5: Output of failure after consecutive execution</p>
			<p>This says that the table already exists. We created a multiline string called <strong class="source-inline">DBCreate</strong> that holds all the table creation information. In this, we have a table called <strong class="source-inline">test</strong>, which has an integer column called <strong class="source-inline">id</strong> and a string column called <strong class="source-inline">name</strong>. The rest of it is <strong class="source-inline">Postgres</strong>-specific configuration. The tablespace defines where our table lives. The <strong class="source-inline">_, err</strong> line with <strong class="source-inline">db.Exec()</strong> is responsible for executing the query. </p>
			<p>Since our goal now is to create the table, we only care whether there are any errors; otherwise, we use a throwaway variable to capture the output. If <strong class="source-inline">err</strong> is not <strong class="source-inline">nil</strong>, there was an error, which we saw demonstrated previously. Otherwise, we assume the table was created as expected. Finally, the connection to the database is closed.</p>
			<p>Now that we can connect to the database and we have a table, we can insert some data.</p>
			<h1 id="_idParaDest-314"><a id="_idTextAnchor332"/>Inserting Data</h1>
			<p>Long ago, when the era of web applications backed by SQL databases started to bloom, there were some gutsy people who invented the SQL injection attack. A type of authentication is done via SQL queries against a database and, for example, after converting the password with mathematical magic into hash functions, all the web app did was execute the query with the username and password coming from the input of the form. Many servers executed something like this:</p>
			<p class="source-code">"SELECT password FROM Auth WHERE username=&lt;input from user&gt;"</p>
			<p>Then, the password gets rehashed; if the two hashes match, the password was good for the user.</p>
			<p>The problem with this came from the <strong class="source-inline">&lt;input from user&gt;</strong> part, because if the attacker was smart enough, they could reformulate the query and run additional commands. For example:</p>
			<p class="source-code">"SELECT password FROM Auth WHERE username=&lt;input  from user&gt; OR '1'='1'"</p>
			<p>The problem with this query is that <strong class="source-inline">OR '1' = '1'</strong> always evaluates to <strong class="source-inline">true</strong>, and it does not matter what the username was, all the user's password hash would be returned. This can be further reused to formulate an additional attack. In order to prevent this, Go uses something called the <strong class="source-inline">Prepare()</strong> statement, which provides protection against these attacks.</p>
			<p>Go has two types of substitutions. We either use <strong class="source-inline">WHERE col = $1</strong> in the case of queries, or <strong class="source-inline">VALUES($1,$2)</strong> in the case of inserts or updates.</p>
			<p>Let's add some values to our tables. We are going to initialize our script in the usual way. The script can be found under the examples folder and is called <strong class="source-inline">DBInsert.go</strong>:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">import "database/sql"</p>
			<p class="source-code">import _ "github.com/lib/pq"</p>
			<p>In the <strong class="source-inline">main()</strong> function, we connect to the database as usual:</p>
			<p class="source-code">func main(){</p>
			<p class="source-code">db, err := sql.Open("postgres", "user=postgres password=Start!123 host=127.0.0.1 port=5432 dbname=postgres sslmode=disable")</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">  panic(err)</p>
			<p class="source-code">}else{</p>
			<p class="source-code">  fmt.Println("The connection to the DB was successfully initialized!")</p>
			<p class="source-code">}</p>
			<p class="source-code">insert, err := db.Prepare("INSERT INTO test VALUES ($1, $2)")</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">  panic(err)</p>
			<p class="source-code">}</p>
			<p class="source-code"><strong class="bold">_,err</strong> = insert.Exec(2,"second")</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">  panic(err)</p>
			<p class="source-code">} else{</p>
			<p class="source-code">  fmt.Println("The value was successfully inserted!")</p>
			<p class="source-code">}</p>
			<p class="source-code">db.Close()</p>
			<p class="source-code">}</p>
			<p>Upon successful execution, the output is as follows:</p>
			<p class="source-code">The connection to the DB was successfully initialized!</p>
			<p class="source-code">The vale was successfully inserted!</p>
			<p>Let's see what is happening with the insert part. <strong class="source-inline">db.Prepare()</strong> takes a SQL statement and imbues it with protection against SQL injection attacks. The way this works is that it restricts the values of the variable substitutions. In our case, we have two columns, so for the substitution to work we use $1 and $2. You can use any number of substitutions; you only need to make sure they result in a valid SQL statement when evaluated. When the <strong class="source-inline">insert</strong> variable is initialized without errors, it will be responsible for executing the SQL statement. It finds out how many arguments the prepared statement expects, and its sole purpose is to call the statement and perform the operation. <strong class="source-inline">insert.Exec(2,"second")</strong> inserts a new element with <strong class="source-inline">id=2</strong> and <strong class="source-inline">name='second'</strong>. If we were to check what we have in our database, we would see the results.</p>
			<p>Now that we have some data in our table, we can query it.</p>
			<h2 id="_idParaDest-315"><a id="_idTextAnchor333"/>Exercise 13.01: Creating a Table with Numbers</h2>
			<p>In this exercise, we are going to write a script that is going to create a table called <strong class="source-inline">Numbers</strong>, in which we are going to store numbers. These numbers will be inserted at a later time.</p>
			<p>Create two columns, <strong class="source-inline">Number</strong> and <strong class="source-inline">Property</strong>. The <strong class="source-inline">Number</strong> column will hold numbers, and the <strong class="source-inline">Property</strong> column will be either <strong class="source-inline">Odd</strong> or <strong class="source-inline">Even</strong> at the time of creation. </p>
			<p>Use the default <strong class="source-inline">Postgres</strong> database for the connection. The numbers should range from 0 to 99.</p>
			<p>Perform the following steps in order to complete the exercise:</p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">main.go</strong>.</li>
				<li>Initialize the package with the following lines:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">import "database/sql"</p><p class="source-code">import _ "github.com/lib/pq"</p><p class="source-code">func main(){</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">prop</strong> <strong class="source-inline">string</strong> variable for later use:<p class="source-code">var prop string</p></li>
				<li>Initialize the database connection:<p class="source-code">db, err := sql.Open("postgres", "user=postgres password=Start!123 host=127.0.0.1   port=5432 dbname=postgres sslmode=disable")</p><p class="source-code">if err != nil {</p><p class="source-code">  panic(err)</p><p class="source-code">}else{</p><p class="source-code">  fmt.Println("The connection to the DB was successfully initialized!")</p><p class="source-code">}</p></li>
				<li>Create the multiline string to create the table:<p class="source-code">TableCreate := <strong class="bold">`</strong>	</p><p class="source-code">CREATE TABLE Number</p><p class="source-code">(</p><p class="source-code">  Number integer NOT NULL,</p><p class="source-code">  Property text COLLATE pg_catalog."default" NOT NULL</p><p class="source-code">)</p><p class="source-code">WITH (</p><p class="source-code">  OIDS = FALSE</p><p class="source-code">)</p><p class="source-code">TABLESPACE pg_default;</p><p class="source-code">ALTER TABLE Number</p><p class="source-code">  OWNER to postgres;</p><p class="source-code"><strong class="bold">`</strong></p></li>
				<li>Create the table:<p class="source-code">_,err = db.Exec(TableCreate)</p><p class="source-code">if err != nil {</p><p class="source-code">  panic(err)</p><p class="source-code">} else{</p><p class="source-code">  fmt.Println("The table called Messages was successfully created!")</p><p class="source-code">}</p></li>
				<li>Insert the numbers:<p class="source-code">insert, insertErr := db.Prepare("INSERT INTO Number VALUES($1,$2)")</p><p class="source-code">if insertErr != nil{</p><p class="source-code">  panic(insertErr)</p><p class="source-code">}</p><p class="source-code">for i := 0; i &lt; 100; i++ {</p><p class="source-code">  if i % 2 == 0{</p><p class="source-code">       prop = "Even"</p><p class="source-code">  }else{</p><p class="source-code">    prop = "Odd"</p><p class="source-code">  }</p><p class="source-code">  _, err = insert.Exec(i,prop)</p><p class="source-code">  if err != nil{</p><p class="source-code">    panic(err)</p><p class="source-code">  }else{</p><p class="source-code">    fmt.Println("The number:",i,"is:",prop)</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">insert.Close()</p><p class="source-code">fmt.Println("The numbers are ready.")</p></li>
				<li>Close the database connection:<p class="source-code">db.Close()</p><p>When you execute the script, you should see the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer230" class="IMG---Figure">
					<img src="image/B14177_13_06.jpg" alt="Figure 13.6: Output of the successful property update&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figu<a id="_idTextAnchor334"/>re 13.6: Output of the successful property update</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Part of the output is omitted from <em class="italic">Figure 13.6</em> due to its length.</p>
			<p>In this exercise, we saw how to create a new table in our database and how to insert new records with the help of a <strong class="source-inline">for</strong> loop and a <strong class="source-inline">Prepare()</strong> statement.</p>
			<h1 id="_idParaDest-316"><a id="_idTextAnchor335"/>Retrieving Data</h1>
			<p>SQL injection does not only concern the data being inserted. It also concerns any data that is manipulated in the database. Retrieving data and, most importantly, retrieving it safely is also something we must prioritize and handle with proper caution. When we query data, our results depend on the database we connect to and the table we would like to query. But we must also mention that the security mechanisms implemented by the database engine may also prevent a successful query unless the user has appropriate privileges. We differentiate two types of queries. There are queries that do not take an argument, such as <strong class="source-inline">SELECT * FROM table</strong>, and there are queries that require you to specify filter criteria. Go provides two functions that allow you to query data. One is called the <strong class="source-inline">Query()</strong> function and the other is called the <strong class="source-inline">QueryRow()</strong> function. The availability of these functions depends on the database you are interacting with. As a rule of thumb, you should remember that the <strong class="source-inline">Query()</strong> function is most likely to work. You can also wrap them with the <strong class="source-inline">Prepare()</strong> statement, which will not cover in this topic as it was demonstrated before. Instead, we want to see how these functions work </p>
			<p>Let's create a script for <strong class="source-inline">Query()</strong>.</p>
			<p>We initialize the script as always. It can be found in the examples and is called <strong class="source-inline">DBQuery.go</strong>:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">import "database/sql"</p>
			<p class="source-code">import _ "github.com/lib/pq"</p>
			<p>Our <strong class="source-inline">main()</strong> function will be a little bit different because we would like to introduce the <strong class="source-inline">Scan()</strong> function:</p>
			<p class="source-code">func main(){</p>
			<p class="source-code">var id int</p>
			<p class="source-code">var name string</p>
			<p class="source-code">db, err := sql.Open("postgres", "user=postgres password=Start!123 host=127.0.0.1   port=5432 dbname=postgres sslmode=disable")</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">  panic(err)</p>
			<p class="source-code">}else{</p>
			<p class="source-code">  fmt.Println("The connection to the DB was successfully initialized!")</p>
			<p class="source-code">}</p>
			<p class="source-code">rows, err := db.Query("SELECT * FROM test")</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">  panic(err)</p>
			<p class="source-code">}</p>
			<p class="source-code">for rows.Next() {</p>
			<p class="source-code">  err := rows.Scan(&amp;id, &amp;name)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    panic(err)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  fmt.Println(id, name)</p>
			<p class="source-code">}</p>
			<p class="source-code">err = rows.Err()</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">  panic(err)</p>
			<p class="source-code">}</p>
			<p class="source-code">rows.Close()</p>
			<p class="source-code">db.Close()</p>
			<p class="source-code">}</p>
			<p>The output should look like this:</p>
			<p class="source-code">The connection to the DB was successfully initialized!</p>
			<p class="source-code">2 second</p>
			<p>As we have previously inserted this data to our database, feel free to add some more data based on the previous example. We have defined the <strong class="source-inline">id</strong> and <strong class="source-inline">name</strong> variables, which will help our <strong class="source-inline">Scan()</strong> function. We connect to the database and create our <strong class="source-inline">db</strong> variable. After that, we fill our <strong class="source-inline">rows</strong> variable with the result of the <strong class="source-inline">Query()</strong> function, which will basically hold all the elements from the table. Here comes the tricky part. We use <strong class="source-inline">for rows.Next()</strong> to iterate over the resulting rows. But that is not enough; we would like to assign the results of the query to the corresponding variable, which is returned by <strong class="source-inline">rows.Scan(&amp;id, &amp;name)</strong>. This allows us to refer to the current row's ID and <strong class="source-inline">NAME</strong>, which makes it easier to do whatever we would like to do with the value. Finally, the <strong class="source-inline">rows</strong> and the database connections are gracefully closed.</p>
			<p>Let's query a single row with <strong class="source-inline">Prepare()</strong>.</p>
			<p>The initialization looks the same as before.</p>
			<p class="source-code-heading">DBPrepare.go</p>
			<p class="source-code">1  package main</p>
			<p class="source-code">2  import "fmt"</p>
			<p class="source-code">3  import "database/sql"</p>
			<p class="source-code">4  import _ "github.com/lib/pq"</p>
			<p class="source-code-link">The full code is available at: <a href="https://packt.live/376LxJo">https://packt.live/376LxJo</a><a href="https://github.com/PacktWorkshops/The-Go-Workshop/blob/a48ab5f3a5f8a1e13ee37a15c66cba50ab6b7cfa/Chapter13/Examples/DBPrepare.go#L1-L26 "/></p>
			<p>The main difference is at the beginning of the <strong class="source-inline">main()</strong> function:</p>
			<p class="source-code">func main(){</p>
			<p class="source-code">var name string</p>
			<p class="source-code">var id int</p>
			<p class="source-code">id = 2</p>
			<p class="source-code">db, err := sql.Open("postgres", "user=postgres password=Start!123 host=127.0.0.1   port=5432 dbname=postgres sslmode=disable")</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">  panic(err)</p>
			<p class="source-code">}else{</p>
			<p class="source-code">  fmt.Println("The connection to the DB was successfully initialized!")</p>
			<p class="source-code">}</p>
			<p class="source-code">qryrow, err := db.Prepare("SELECT name FROM test WHERE id=$1")</p>
			<p class="source-code">if err != nil{</p>
			<p class="source-code">  panic(err)</p>
			<p class="source-code">}</p>
			<p class="source-code">err = qryrow.QueryRow(id).Scan(&amp;name)</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">  panic(err)</p>
			<p class="source-code">}</p>
			<p class="source-code">fmt.Println("The name column value is",name,"of the row with id=",id)</p>
			<p class="source-code">qryrow.Close()</p>
			<p class="source-code">db.Close()</p>
			<p class="source-code">}</p>
			<p>The output, if you did everything correctly, should look something like this:</p>
			<p class="source-code">The connection to the DB was successfully initialized!</p>
			<p class="source-code">The name column value is second of the row with id= 2</p>
			<p>Let's inspect our <strong class="source-inline">main</strong> function closely. We defined two variables: the <strong class="source-inline">name</strong> variable will be used when we process the query result, and the <strong class="source-inline">id</strong> variable serves as a flexible input for the query we execute. The usual connection initialization toward our database happens as before. Then comes the <strong class="source-inline">SQL Injection</strong> proof part. We prepare a query that is dynamic in the sense that it accepts a parameter that will be the ID we are looking for. Then, <strong class="source-inline">qryrow</strong> is used to execute the <strong class="source-inline">QueryRow()</strong> function, which in turn takes the <strong class="source-inline">id</strong> variable we specified previously and returns the result in the <strong class="source-inline">name</strong> variable. Then we output the string with an explanation that the value of the column is based on the <strong class="source-inline">id</strong> variable that was specified. At the end, the <strong class="source-inline">qryrow</strong> and <strong class="source-inline">db</strong> resources are closed.</p>
			<p>Now that we know how to retrieve data from the database, we need to see how to update existing data in our database.</p>
			<h1 id="_idParaDest-317"><a id="_idTextAnchor336"/>Updating Existing Data</h1>
			<p>When you are updating a row or multiple rows with Go, you are in trouble. The <strong class="source-inline">sql</strong> package does not provide any function called <strong class="source-inline">Update()</strong>; however, there is the <strong class="source-inline">Exec()</strong> function, which serves as a universal executor for your queries. You can execute <strong class="source-inline">SELECT</strong>, <strong class="source-inline">UPDATE</strong>, <strong class="source-inline">DELETE</strong>, or whatever you need to execute with this function. This topic will show you how you can do it safely.</p>
			<p>We would like to start our script in the usual way. It can be found in the examples folder and is called <strong class="source-inline">DBUpdate.go</strong>:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">import "database/sql"</p>
			<p class="source-code">import _ "github.com/lib/pq"</p>
			<p>Then the magic comes. The idea is to update the <strong class="source-inline">name</strong> column's value for a specific <strong class="source-inline">id</strong> variable that we give as an argument. So, the <strong class="source-inline">main()</strong> function looks like this:</p>
			<p class="source-code">func main(){</p>
			<p class="source-code">db, err := sql.Open("postgres", "user=postgres password=Start!123 host=127.0.0.1 port=5432 dbname=postgres sslmode=disable")</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">  panic(err)</p>
			<p class="source-code">}else{</p>
			<p class="source-code">  fmt.Println("The connection to the DB was successfully initialized!")</p>
			<p class="source-code">}</p>
			<p class="source-code">UpdateStatement :=`</p>
			<p class="source-code">UPDATE test </p>
			<p class="source-code">SET name = $1 </p>
			<p class="source-code">WHERE id = $2</p>
			<p class="source-code">`</p>
			<p class="source-code">UpdateResult, UpdateResultErr := db.Exec(UpdateStatement,"well",2)</p>
			<p class="source-code">if UpdateResultErr != nil {</p>
			<p class="source-code">  panic(UpdateResultErr)</p>
			<p class="source-code">}</p>
			<p class="source-code">UpdatedRecords, UpdatedRecordsErr := UpdateResult.RowsAffected()</p>
			<p class="source-code">if UpdatedRecordsErr != nil {</p>
			<p class="source-code">  panic(UpdatedRecordsErr)</p>
			<p class="source-code">}</p>
			<p class="source-code">fmt.Println("Number of records updated:",UpdatedRecords)</p>
			<p class="source-code">db.Close()</p>
			<p class="source-code">}</p>
			<p>If everything went well, we see the following output:</p>
			<p class="source-code">The connection to the DB was successfully initialized!</p>
			<p class="source-code">Number of records updated: 1</p>
			<p>Note that you can and should experiment with different inputs and see how the script reacts to different problems/errors.</p>
			<p>Let's dissect what is happening here. We initialize our database connection as we did before. We create the <strong class="source-inline">UpdateStatement</strong> variable, which is a multiline string, and it is crafted so that it can be fed to the <strong class="source-inline">Exec()</strong> function, which takes arguments. We want to update the name of the column that has the specified ID. This function either runs the specified statement on its own or can be used to pass arguments that are substituted in the appropriate place. This would be perfectly fine and would do the job for us, but we would like to make sure that the <strong class="source-inline">UPDATE</strong> command actually updates at least one record. To this end, we could use <strong class="source-inline">RowsAffected()</strong>. It will return the number of rows that were updated, and any errors that were faced along the way. Finally, we print to the console how many rows were updated and close the connection.</p>
			<p>The time has come to delete data from our database.</p>
			<h1 id="_idParaDest-318"><a id="_idTextAnchor337"/>Deleting Data</h1>
			<p>The deletion of data can happen for multiple reasons: we don't need the data anymore, we are migrating to another database, or we are replacing the current solution. We are in luck because the current Go facilities provide a very nice way to do it. The analogy is the same as for the <strong class="source-inline">UPDATE</strong> statement of our records. We formulate a <strong class="source-inline">DELETE</strong> statement and execute it; we can technically modify the action of our <strong class="source-inline">UPDATE</strong> script to delete from the database.</p>
			<p>For the sake of simplicity, we only modify the relevant lines.</p>
			<p>Our <strong class="source-inline">DELETE</strong> statement will replace the <strong class="source-inline">UPDATE</strong> statement like this:</p>
			<p class="source-code-heading">DBDelete.go</p>
			<p class="source-code">12 DeleteStatement :=`</p>
			<p class="source-code">13 DELETE FROM test </p>
			<p class="source-code">14 WHERE id = $1</p>
			<p class="source-code">15 `</p>
			<p class="source-code-link">The full code is available at: <a href="https://packt.live/371GoCy">https://packt.live/371GoCy</a><a href="https://github.com/PacktWorkshops/The-Go-Workshop/blob/a48ab5f3a5f8a1e13ee37a15c66cba50ab6b7cfa/Chapter13/Examples/DBDelete.go#L1-L26 "/></p>
			<p>We update the line with the <strong class="source-inline">Exec()</strong> statement:</p>
			<p class="source-code">DeleteResult, DeleteResultErr := db.Exec(DeleteStatement,2)</p>
			<p class="source-code">if DeleteResultErr != nil {</p>
			<p class="source-code">  panic(DeleteResultErr)</p>
			<p class="source-code">}</p>
			<p>Also, we update the line with the calculation of updated records:</p>
			<p class="source-code">DeletedRecords, DeletedRecordsErr := DeleteResult.RowsAffected()</p>
			<p class="source-code">if DeletedRecordsErr != nil {</p>
			<p class="source-code">  panic(DeletedRecordsErr)</p>
			<p class="source-code">}</p>
			<p class="source-code">fmt.Println("Number of records deleted:",DeletedRecords)</p>
			<p>Our result of the execution should look like this:</p>
			<p class="source-code">The connection to the DB was successfully initialized!</p>
			<p class="source-code">Number of records deleted: 1</p>
			<p>Basically, that's it. With a little modification, we have a script that can either update or delete records with verification.</p>
			<p>Now, let's see how we can create a table that holds prime numbers.</p>
			<h2 id="_idParaDest-319"><a id="_idTextAnchor338"/>Exercise 13.02: Holding Prime Numbers in a Database</h2>
			<p>In this exercise, we build on <em class="italic">Exercise 13.01</em>, <em class="italic">Creating a Table with Numbers</em>. We would like to create a script that will do the following: first, it will tell us how many prime numbers are in our table and give them to us in order of appearance. We would like to see the sum of prime numbers in the output. Then we would like to remove every even number from the table and see how many were removed. We would like to add the sum of prime numbers to the remaining odd numbers and update the table with the records, changing the property if necessary. Use the <strong class="source-inline">math/big</strong> package for the primality test.</p>
			<p>Follow these steps:</p>
			<ol>
				<li value="1">Create a script called <strong class="source-inline">main.go</strong>.</li>
				<li>Initialize our script to perform the specific actions:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">import "database/sql"</p><p class="source-code">import _ "github.com/lib/pq"</p><p class="source-code">import "math/big"</p><p class="source-code">func main(){</p><p class="source-code">}</p></li>
				<li>Define four variables for later use:<p class="source-code">var number int64</p><p class="source-code">var prop string</p><p class="source-code">var primeSum int64</p><p class="source-code">var newNumber int64</p></li>
				<li>Initialize the database connection:<p class="source-code">db, err := sql.Open("postgres", "user=postgres password=Start!123 host=127.0.0.1   port=5432 dbname=postgres sslmode=disable")</p><p class="source-code">if err != nil {</p><p class="source-code">  panic(err)</p><p class="source-code">}else{</p><p class="source-code">  fmt.Println("The connection to the DB was successfully initialized!")</p><p class="source-code">}</p></li>
				<li>Get a list of all the prime numbers:<p class="source-code">AllTheNumbers := "SELECT * FROM Number"</p><p class="source-code">Numbers, err := db.Prepare(AllTheNumbers)</p><p class="source-code">if err != nil {</p><p class="source-code">  panic(err)</p><p class="source-code">}</p><p class="source-code">primeSum = 0</p><p class="source-code">result, err := Numbers.Query()</p><p class="source-code">fmt.Println("The list of prime numbers:")</p><p class="source-code">for result.Next(){</p><p class="source-code">    err = result.Scan(&amp;number, &amp;prop)</p><p class="source-code">    if err != nil{</p><p class="source-code">    panic(err)</p><p class="source-code">    }</p><p class="source-code">    if big.NewInt(number).ProbablyPrime(0) {</p><p class="source-code">      primeSum += number</p><p class="source-code">      fmt.Print(" ",number)</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">Numbers.Close()</p></li>
				<li>Print the sum of the prime numbers:<p class="source-code">fmt.Println("\nThe total sum of prime numbers in this range is:",primeSum)</p></li>
				<li>Remove the even numbers:<p class="source-code">Remove := "DELETE FROM Number WHERE Property=$1"</p><p class="source-code">removeResult, err := db.Exec(Remove,"Even")</p><p class="source-code">if err != nil {</p><p class="source-code">  panic(err)</p><p class="source-code">}</p><p class="source-code">ModifiedRecords, err := removeResult.RowsAffected()</p><p class="source-code">fmt.Println("The number of rows removed:",ModifiedRecords)</p><p class="source-code">fmt.Println("Updating numbers...")</p></li>
				<li>Update the remaining records with <strong class="source-inline">primeSum</strong> and print a closing sentence:<p class="source-code">Update := "UPDATE Number SET Number=$1 WHERE Number=$2 AND Property=$3"</p><p class="source-code">AllTheNumbers = "SELECT * FROM Number"</p><p class="source-code">Numbers, err = db.Prepare(AllTheNumbers)</p><p class="source-code">if err != nil {</p><p class="source-code">  panic(err)</p><p class="source-code">} </p><p class="source-code">result, err = Numbers.Query()</p><p class="source-code">for result.Next(){</p><p class="source-code">    err = result.Scan(&amp;number, &amp;prop)</p><p class="source-code">    if err != nil{</p><p class="source-code">    panic(err)</p><p class="source-code">    }</p><p class="source-code">    newNumber = number + primeSum</p><p class="source-code">    _, err = db.Exec(Update,newNumber,number,prop)</p><p class="source-code">    if err != nil {</p><p class="source-code">      panic(err)</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">Numbers.Close()</p><p class="source-code">fmt.Println("The execution is now complete...")</p></li>
				<li>Close the database connection:<p class="source-code">db.Close()</p><p>Once the script is executed, the following output should be visible:</p></li>
			</ol>
			<p> </p>
			<div>
				<div id="_idContainer231" class="IMG---Figure">
					<img src="image/B14177_13_07.jpg" alt="Figure 13.7: Output of the calculations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.7: Output of the calculations</p>
			<p>In this exercise, we saw how to utilize a built-in Go function to find prime numbers. We also manipulated the table by removing numbers, and then we performed update actions.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Closing the database is important because once our job is done, we do want to release unused resources.</p>
			<h1 id="_idParaDest-320"><a id="_idTextAnchor339"/>Truncating and Deleting Table</h1>
			<p>What we would like to achieve in this topic is to empty a table completely and get rid of it. In order to empty the table, we could simply formulate <strong class="source-inline">DELETE</strong> statements that match every record in our table and thus remove every single record from our table. However, there is a more elegant way. We can use the <strong class="source-inline">TRUNCATE TABLE</strong> SQL statement. The result of this statement is a literally empty table. We can use the <strong class="source-inline">Exec()</strong> function from our <strong class="source-inline">sql</strong> package. You already know how to initialize the package with imports. You also know how to connect to the database. This time, we only focus on the statements.</p>
			<p>The following statement will achieve a full <strong class="source-inline">TRUNCATE</strong>:</p>
			<p class="source-code">EmptyTable, EmptyTableErr := db.Exec("TRUNCATE TABLE test")</p>
			<p class="source-code">if EmptyTableErr != nil {</p>
			<p class="source-code">  panic(EmptyTableErr)</p>
			<p class="source-code">}</p>
			<p>The result of this is an empty table called <strong class="source-inline">test</strong>.</p>
			<p>In order to get rid of the table completely, we should modify our statement as follows.</p>
			<p class="source-code">DropTable, DropTableErr := db.Exec("DROP TABLE test")</p>
			<p class="source-code">if DropTableErr != nil {</p>
			<p class="source-code">  panic(DropTableErr)</p>
			<p class="source-code">}</p>
			<p>If we inspect our database engine, we will not find any trace of the table called <strong class="source-inline">test</strong>. This eradicated the whole table from the very face of the database.</p>
			<p>That topic was all about interacting with databases via the Go programming language. Now you have a decent understanding about how to get started.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For further information and extra details, you should check out the official documentation of the SQL API, <a href="https://packt.live/2Pi5oj5">https://packt.live/2Pi5oj5</a>.</p>
			<h2 id="_idParaDest-321"><a id="_idTextAnchor340"/>Activity 13.01: Holding User Data in a Table</h2>
			<p>In this activity, we are going to create a table that is going to hold user information such as <strong class="source-inline">ID</strong>, <strong class="source-inline">Name</strong>, and <strong class="source-inline">Email</strong>. We build on the knowledge you gathered in the <em class="italic">Creating Tables </em>and <em class="italic">Inserting Data</em> sections.</p>
			<p>Follow these steps to complete this activity:</p>
			<ol>
				<li value="1">Create a small script that will create a table called <strong class="source-inline">Users</strong>. This table must have three columns: <strong class="source-inline">ID</strong>, <strong class="source-inline">Name</strong>, and <strong class="source-inline">Email</strong>.</li>
				<li>Add the details of two users with their data into the table. They should have unique names, IDs, and email addresses.</li>
				<li>Then you need to update the email of the first user to user@packt.com and remove the second user. Make sure that none of the fields are <strong class="source-inline">NULL</strong>, and the ID is the primary key, so it needs to be unique.</li>
				<li>When you are inserting, updating, and deleting from the table, please use the <strong class="source-inline">Prepare()</strong> function to protect against SQL injection attacks.</li>
				<li>You should use a struct to store the user information you would like to insert, and when you are inserting, iterate over the struct with a <strong class="source-inline">for</strong> loop.</li>
				<li>Once the <strong class="source-inline">insert</strong>, <strong class="source-inline">update</strong>, and <strong class="source-inline">delete</strong> calls are complete, make sure you use <strong class="source-inline">Close()</strong> when appropriate and finally close the connection to the database.<p>Upon successful completion, you should see the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer232" class="IMG---Figure">
					<img src="image/B14177_13_08.jpg" alt="Figure 13.8: Possible output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.8: Possible output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 745.</p>
			<p>By the end of this activity, you should have learned how to create a new table called <strong class="source-inline">users</strong> and how to insert data into this table.</p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor341"/>Activity 13.02: Finding Messages of Specific Users</h2>
			<p>In this activity, we will build on <em class="italic">Activity 13.01</em>: <em class="italic">Holding User Data in a Table</em>.</p>
			<p>We need to create a new table called <strong class="source-inline">Messages</strong>. This table will have two columns, both of which should have a 280-character limit: one is <strong class="source-inline">UserID</strong> and the other is <strong class="source-inline">Message</strong>.</p>
			<p>When your table is ready, you should add some messages with user IDs. Make sure you add <strong class="source-inline">UserID</strong>, which is not present in the <strong class="source-inline">users</strong> table.</p>
			<p>Once you have added the data, write a query that returns all the messages a specified user has sent. Use the <strong class="source-inline">Prepare()</strong> function to protect against SQL injection.</p>
			<p>If the specified user cannot be found, print <strong class="source-inline">The query returned nothing, no such user: &lt;username&gt;</strong>. You should take the username as input from the keyboard.</p>
			<p>Perform these steps in order to complete the activity:</p>
			<ol>
				<li value="1">Define a <strong class="source-inline">struct</strong> that holds the <strong class="source-inline">userID</strong> and the messages.</li>
				<li>Messages should be inserted with a <strong class="source-inline">for</strong> loop that iterates over the previously defined <strong class="source-inline">struct</strong>.</li>
				<li>When the user input is received, make sure you use the <strong class="source-inline">Prepare()</strong> statement to craft your query.<p>If everything went well, this should be the output, depending on how you fill your database with usernames and messages:</p></li>
			</ol>
			<div>
				<div id="_idContainer233" class="IMG---Figure">
					<img src="image/B14177_13_09.jpg" alt="Figure 13.9: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.9: Expected output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 748.</p>
			<p>If you want, you can tweak the script to not try and recreate the DB on consecutive runs.</p>
			<p>By the end of this activity, you should have learned how to create a new table called <strong class="source-inline">Messages</strong>, then take input from the user and search for related users and messages based on the input.</p>
			<h1 id="_idParaDest-323"><a id="_idTextAnchor342"/>Summary</h1>
			<p>This chapter made you efficient in interacting with SQL databases. You learned how to create, delete, and manipulate database tables. You have also become aware of all the different types of databases Go is suited to interact with. As this chapter was made with the <strong class="source-inline">PostgreSQL</strong> engine in mind, you should familiarize yourself with its Go module too. With this knowledge, you will now be able to take your own steps in the realm of database programming with the Go language and be self-sufficient in the sense that you know where to look for solutions to problems and for extra knowledge. The most common use case for this knowledge is when you must build automated reporting apps that pull data from a database and report it as an email. The other use case is when you have an automated app for pushing data to the database server that processes a CSV file or an XML file. This really depends on the situation you are in.</p>
			<p>In the next chapter, you will learn how to interact with web interfaces via HTTP clients, which is one of the most interesting topics in Go.</p>
		</div>
		<div>
			<div id="_idContainer235" class="Content">
			</div>
		</div>
	</body></html>