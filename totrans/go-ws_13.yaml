- en: 13\. SQL and Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter's aim is to enable you to connect to SQL databases with the help
    of the Go programming language.
  prefs: []
  type: TYPE_NORMAL
- en: You will start by learning to connect to databases, creating tables in a database
    and insert data into and retrieve data from tables. By the end of this chapter,
    you will be able to update and delete data in specific tables, and also truncate
    and drop tables.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to interact with the system your Go
    app is running on. You learned the importance of exit codes and how to customize
    your scripts to take arguments, thus adding flexibility to your applications.
    You also learned the mastery of handling different signals that your application
    receives.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will further master your Go skills by learning how to use
    SQL and databases in Go. As a developer, it is impossible to get by without a
    proper understanding of persistent data storage and databases. Our applications
    process input and produce output, but most of the time, if not in all cases, a
    database is involved in the process. This database can be in memory (stored in
    the computer's RAM) or file-based (a single file in a directory), and it can live
    on local or remote storage. The cloud can provide you with database services;
    both Azure and AWS can help you with that.
  prefs: []
  type: TYPE_NORMAL
- en: What we aim to do in this chapter is to make you fluent in talking to these
    databases and understand the basic concepts of what a database is. Finally, you
    should extend your skillset to make you a better Go developer as you progress
    through this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say your boss wants you to create a Go app that can communicate with a
    database. By "communicate", we mean that any transaction that is `INSERT`, `UPDATE`,
    `DELETE`, or `CREATE` can and should be handled by the application. This chapter
    will show you how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: The Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to make this chapter more appealing, let's see how you can have a database
    solution called `Postgres` on your system and configure it for yourself so you
    can try out the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to grab the installer from [https://packt.live/2RMFPYV](https://packt.live/2RMFPYV).
    Select the one which is appropriate. The installer is very easy to use, and I
    suggest you accept the defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the installer:![Figure 13.1: Selecting the installation directory'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_13_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.1: Selecting the installation directory'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Leave the default components:![Figure 13.2: Selecting components to install'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_13_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.2: Selecting components to install'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Leave the default data directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.3: Selecting the data directory'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_13_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.3: Selecting the data directory'
  prefs: []
  type: TYPE_NORMAL
- en: It will ask for a password, which you need to remember because this is the master
    password for your database. `Start!123` is the password for this example. The
    database is running on the local port 5432\. The `pgAdmin` GUI tool will also
    be installed, and, once the installer completes, you can start `pgAdmin` to connect
    to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the browser, the following link can be used to access the admin surface:
    [https://packt.live/2PKWc5w](https://packt.live/2PKWc5w):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4: The admin interface'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_13_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.4: The admin interface'
  prefs: []
  type: TYPE_NORMAL
- en: Once the installation is complete, we are ready to proceed to the next part
    and connect to the database via Go.
  prefs: []
  type: TYPE_NORMAL
- en: Database API and Drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to work with databases, there is something called the "pure" Go approach,
    which means Go has an API that allows you to use different drivers to connect
    to databases. The API comes from the `database/sql` package, and the drivers can
    be of two types. There is native support for a wide variety of drivers, which
    can be found on the official GitHub page ([https://packt.live/2LMzcC4](https://packt.live/2LMzcC4)),
    and there are third-party drivers that need additional packages to function, such
    as the `SQLlite3` package, which requires you to have `GCC` installed because
    it is a pure C implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: GCC is a compiler system produced by the GNU Project. It takes your source code
    and translates it to machine code so that your computer can run the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of a couple of drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MySQL** ([https://packt.live/38zk9Fw](https://packt.live/38zk9Fw))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Oracle** ([https://packt.live/34cxwrP](https://packt.live/34cxwrP))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ODBC** ([https://packt.live/2EfETV8](https://packt.live/2EfETV8))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Postgres** ([https://packt.live/35jKEwL](https://packt.live/35jKEwL))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea behind the API and driver approach is that Go provides a unified interface
    that allows developers to talk to different types of databases. All you need to
    do is import the API and the necessary driver and you are able to talk to the
    database. You don't need to learn driver-specific implementations or how that
    driver works because the API's sole purpose is to create an abstraction layer
    that accelerates development.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example. Let's say we would like to have a script that queries
    a database. This database is MySQL. One approach is to take the driver and learn
    how to code in its language, and then you are good to go. Some time passes by,
    and you build lots of small scripts that do their job properly. Now the time has
    come for a management decision that will make you unhappy. They decide that MySQL
    is not good enough, and they will replace the database with AWS Athena, a cloud-based
    database. Now, since you wrote your scripts specifically for a certain driver,
    you will be busy rewriting your scripts in order for them to work properly. The
    safeguard here is to use a unified API and driver combination. This means writing
    the scripts against the API and not the driver. The API will translate your wishes
    for the specific driver. This way, all you need to do is swap out the driver,
    and the scripts are guaranteed to work. You just saved yourself many hours of
    scripting and rewriting code, even though the underlying database has been completely
    replaced.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are working with databases in Go, we differentiate these types of databases:'
  prefs: []
  type: TYPE_NORMAL
- en: Relational databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoSQL databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search and analytic databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connecting to a database is by far the easiest thing to do; however, we need
    to keep a few things in mind. In order to connect to any database, we need at
    least four things to be in place. We need a host to connect to, we need a database
    to connect to that is running on a port, and we need a username and password.
    The user needs to have appropriate privileges because we not only want to connect
    but we would like to perform specific operations, such as query, insert, or remove
    data, create or delete databases, and manage users and views. Let's imagine that
    connecting to a database is like walking up to a door as a specific person with
    a specific key. Whether the door opens or not depends on the key, but what we
    can do after we have crossed the threshold will depend on the person (which is
    defined by their privileges).
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, the database server supports multiple databases and the databases
    hold one or more tables. Imagine that the databases are logical containers that
    belong together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can connect to a database in Go. In order to connect,
    we need to get the appropriate module from GitHub, which needs internet connectivity.
    We need to issue the following command to get the package needed to interact with
    the Postgres instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this completes, you are ready to start scripting. First, we will initialize
    our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`import _ <package name>` is a special `import` statement that tells Go to
    import a package solely for its side effects.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you would like further information, visit [https://packt.live/2PByusw](https://packt.live/2PByusw).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have initialized our script, we can actually connect to our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This topic is special because the API gives us an `Open()` function, which
    takes a variety of arguments. There are shorthand ways of doing this, but I would
    like you to know about all the components that are involved in making the connections,
    so I will use the longer way. Later, you can decide which one to use. The `Postgres`
    tells the function to use the `Postgres` driver to make the connection. The second
    argument is a so-called connection string, which holds the `user`, `password`,
    `host`, `port`, `dbname`, and `sslmode` arguments, which will be used to initialize
    the connection. In this example, we connect to the localhost marked by `127.0.0.1`
    on the default port 5432, and we don''t use `ssl`. For production systems, people
    tend to change the default port and enforce encrypted traffic via `ssl` toward
    the database server, and you should always follow the best practices concerning
    the type of database you''re working with. As you can see, the `Open()` function
    returns two values. One is for the database connection and the other is for the
    error, if any occurred during initialization. How do we check whether the initialization
    was success? Well, we can check whether there were any errors by writing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `panic()` function in Go is used to indicate that something went wrong
    unexpectedly, and we are not prepared to handle it gracefully, thus stopping the
    execution. If the connection succeeds, we print out the `The connection to the
    DB was successfully initialized!` message. When you have a long-running application,
    it is worth incorporating a way to check whether the database is still reachable,
    because due to intermittent network errors you could lose the connection and fail
    to execute whatever you wanted to execute. This can be checked with the following
    small code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we used the `panic()` function to indicate that the connection
    has been lost. Finally, once our job is done, we need to terminate our connection
    to the database in order to remove user sessions and free up resources. In big
    enterprise environments with thousands of users hitting the same database, it''s
    a wise decision to use the database only when necessary, and once the work is
    done, close the connections. There are two ways to close the connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The difference is the scope. `db.Close()` will terminate the connection to the
    database once the execution arrives at the specific line, while `defer db.Close()`
    indicates that the database connection should be executed once the function in
    which it was called goes out of scope. The idiomatic way to do it is with `defer
    db.Close()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in order to further demonstrate this, we will create a table.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The official `Postgres` module of Go can be found at [https://packt.live/35jKEwL](https://packt.live/35jKEwL).
  prefs: []
  type: TYPE_NORMAL
- en: Creating Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The act of creating tables aims to make logical containers that persistently
    hold data that belongs together. Many companies create tables for many reasons,
    for example, tracking employee attendance, revenue tracking, and statistics. The
    common goal is to provide a service for applications that make sense of it. How
    do these database engines control who can access what data? There are basically
    two approaches. The first one is `CREATE`, `UPDATE`, and `DELETE`. The second
    approach involves inheritance and roles. This is more robust and is better suited
    for big enterprises. Before using a database engine, there used to be a precheck
    to see what the size would be and how many users would use it. There is no point
    in shooting a sparrow with a shotgun, and there is no shoe size that fits all.
    It all depends on the situation. `Postgres` uses the second approach, and in this
    topic, we will see how to create a SQL table and how to create one specifically
    in `Postgres`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax for table creation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Before we continue, we need to clarify what SQL is. SQL is a standard that stands
    for `Postgres`, `mysql`, or `mssql` server, they all respond in the same way to
    a `CREATE TABLE` or `INSERT` command because they are SQL compliant. The idea
    of the standard is not to specify how the engine works internally but how the
    interaction with it should happen. These database engines usually differ in terms
    of functionality, speed, and storage approaches; that's where the variety comes
    from. This is not a full SQL or database engine tutorial. I just wanted to give
    you a brief explanation so that you understand the commands better. The general
    command for table creation is `CREATE TABLE`. This command is understood in the
    context of the database you are connected to. One server can host multiple databases,
    and connecting to the wrong one can cause headaches when issuing a command that
    modifies the structure. The command usually takes a column name, which is `column1`
    in our case, and the type of data in our column, which is `datatype`. Finally,
    we can set constraints on our columns, which will imbue them with special properties.
    The supported datatypes for our columns depend on the database engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some common datatypes:'
  prefs: []
  type: TYPE_NORMAL
- en: INT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DOUBLE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FLOAT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VARCHAR, which is a string with a specific length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The constraints also depend on the database engine, but some of them are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: NOT NULL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PRIMARY KEY
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The named function is executed every time a new record is inserted or an old
    one is updated and, based on the evaluation of the transaction, is either allowed
    or denied.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not only able to create a table, but we can also empty the table, remove
    all of its contents, or remove the table itself from the database. In order to
    empty a table, we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to remove the table, we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now create a new table. In `Postgres`, you have a default database you can use;
    we are not going to create a separate database for the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to initialize our script, which you can find in the examples
    folder, and it''s called `DBInit.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to define our `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s dissect what is happening here. We initialize our connection to the
    database without the default username and password that was previously mentioned,
    and now we have the `db` variable to interact with the database. Unless there
    was an error upon execution, the following output will be visible on our console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to rerun the script, the following error would occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5: Output of failure after consecutive execution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_13_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.5: Output of failure after consecutive execution'
  prefs: []
  type: TYPE_NORMAL
- en: This says that the table already exists. We created a multiline string called
    `DBCreate` that holds all the table creation information. In this, we have a table
    called `test`, which has an integer column called `id` and a string column called
    `name`. The rest of it is `Postgres`-specific configuration. The tablespace defines
    where our table lives. The `_, err` line with `db.Exec()` is responsible for executing
    the query.
  prefs: []
  type: TYPE_NORMAL
- en: Since our goal now is to create the table, we only care whether there are any
    errors; otherwise, we use a throwaway variable to capture the output. If `err`
    is not `nil`, there was an error, which we saw demonstrated previously. Otherwise,
    we assume the table was created as expected. Finally, the connection to the database
    is closed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can connect to the database and we have a table, we can insert some
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Long ago, when the era of web applications backed by SQL databases started
    to bloom, there were some gutsy people who invented the SQL injection attack.
    A type of authentication is done via SQL queries against a database and, for example,
    after converting the password with mathematical magic into hash functions, all
    the web app did was execute the query with the username and password coming from
    the input of the form. Many servers executed something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Then, the password gets rehashed; if the two hashes match, the password was
    good for the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with this came from the `<input from user>` part, because if the
    attacker was smart enough, they could reformulate the query and run additional
    commands. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this query is that `OR '1' = '1'` always evaluates to `true`,
    and it does not matter what the username was, all the user's password hash would
    be returned. This can be further reused to formulate an additional attack. In
    order to prevent this, Go uses something called the `Prepare()` statement, which
    provides protection against these attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Go has two types of substitutions. We either use `WHERE col = $1` in the case
    of queries, or `VALUES($1,$2)` in the case of inserts or updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some values to our tables. We are going to initialize our script
    in the usual way. The script can be found under the examples folder and is called
    `DBInsert.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main()` function, we connect to the database as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon successful execution, the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's see what is happening with the insert part. `db.Prepare()` takes a SQL
    statement and imbues it with protection against SQL injection attacks. The way
    this works is that it restricts the values of the variable substitutions. In our
    case, we have two columns, so for the substitution to work we use $1 and $2\.
    You can use any number of substitutions; you only need to make sure they result
    in a valid SQL statement when evaluated. When the `insert` variable is initialized
    without errors, it will be responsible for executing the SQL statement. It finds
    out how many arguments the prepared statement expects, and its sole purpose is
    to call the statement and perform the operation. `insert.Exec(2,"second")` inserts
    a new element with `id=2` and `name='second'`. If we were to check what we have
    in our database, we would see the results.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some data in our table, we can query it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.01: Creating a Table with Numbers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we are going to write a script that is going to create a table
    called `Numbers`, in which we are going to store numbers. These numbers will be
    inserted at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: Create two columns, `Number` and `Property`. The `Number` column will hold numbers,
    and the `Property` column will be either `Odd` or `Even` at the time of creation.
  prefs: []
  type: TYPE_NORMAL
- en: Use the default `Postgres` database for the connection. The numbers should range
    from 0 to 99.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps in order to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize the package with the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `prop` `string` variable for later use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the database connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the multiline string to create the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Insert the numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the database connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you execute the script, you should see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.6: Output of the successful property update'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_13_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.6: Output of the successful property update'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Part of the output is omitted from *Figure 13.6* due to its length.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw how to create a new table in our database and how to
    insert new records with the help of a `for` loop and a `Prepare()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL injection does not only concern the data being inserted. It also concerns
    any data that is manipulated in the database. Retrieving data and, most importantly,
    retrieving it safely is also something we must prioritize and handle with proper
    caution. When we query data, our results depend on the database we connect to
    and the table we would like to query. But we must also mention that the security
    mechanisms implemented by the database engine may also prevent a successful query
    unless the user has appropriate privileges. We differentiate two types of queries.
    There are queries that do not take an argument, such as `SELECT * FROM table`,
    and there are queries that require you to specify filter criteria. Go provides
    two functions that allow you to query data. One is called the `Query()` function
    and the other is called the `QueryRow()` function. The availability of these functions
    depends on the database you are interacting with. As a rule of thumb, you should
    remember that the `Query()` function is most likely to work. You can also wrap
    them with the `Prepare()` statement, which will not cover in this topic as it
    was demonstrated before. Instead, we want to see how these functions work
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a script for `Query()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We initialize the script as always. It can be found in the examples and is
    called `DBQuery.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `main()` function will be a little bit different because we would like
    to introduce the `Scan()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we have previously inserted this data to our database, feel free to add some
    more data based on the previous example. We have defined the `id` and `name` variables,
    which will help our `Scan()` function. We connect to the database and create our
    `db` variable. After that, we fill our `rows` variable with the result of the
    `Query()` function, which will basically hold all the elements from the table.
    Here comes the tricky part. We use `for rows.Next()` to iterate over the resulting
    rows. But that is not enough; we would like to assign the results of the query
    to the corresponding variable, which is returned by `rows.Scan(&id, &name)`. This
    allows us to refer to the current row's ID and `NAME`, which makes it easier to
    do whatever we would like to do with the value. Finally, the `rows` and the database
    connections are gracefully closed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's query a single row with `Prepare()`.
  prefs: []
  type: TYPE_NORMAL
- en: The initialization looks the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The main difference is at the beginning of the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, if you did everything correctly, should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s inspect our `main` function closely. We defined two variables: the `name`
    variable will be used when we process the query result, and the `id` variable
    serves as a flexible input for the query we execute. The usual connection initialization
    toward our database happens as before. Then comes the `SQL Injection` proof part.
    We prepare a query that is dynamic in the sense that it accepts a parameter that
    will be the ID we are looking for. Then, `qryrow` is used to execute the `QueryRow()`
    function, which in turn takes the `id` variable we specified previously and returns
    the result in the `name` variable. Then we output the string with an explanation
    that the value of the column is based on the `id` variable that was specified.
    At the end, the `qryrow` and `db` resources are closed.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to retrieve data from the database, we need to see how
    to update existing data in our database.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Existing Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you are updating a row or multiple rows with Go, you are in trouble. The
    `sql` package does not provide any function called `Update()`; however, there
    is the `Exec()` function, which serves as a universal executor for your queries.
    You can execute `SELECT`, `UPDATE`, `DELETE`, or whatever you need to execute
    with this function. This topic will show you how you can do it safely.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to start our script in the usual way. It can be found in the
    examples folder and is called `DBUpdate.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the magic comes. The idea is to update the `name` column''s value for
    a specific `id` variable that we give as an argument. So, the `main()` function
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything went well, we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can and should experiment with different inputs and see how the
    script reacts to different problems/errors.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dissect what is happening here. We initialize our database connection
    as we did before. We create the `UpdateStatement` variable, which is a multiline
    string, and it is crafted so that it can be fed to the `Exec()` function, which
    takes arguments. We want to update the name of the column that has the specified
    ID. This function either runs the specified statement on its own or can be used
    to pass arguments that are substituted in the appropriate place. This would be
    perfectly fine and would do the job for us, but we would like to make sure that
    the `UPDATE` command actually updates at least one record. To this end, we could
    use `RowsAffected()`. It will return the number of rows that were updated, and
    any errors that were faced along the way. Finally, we print to the console how
    many rows were updated and close the connection.
  prefs: []
  type: TYPE_NORMAL
- en: The time has come to delete data from our database.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The deletion of data can happen for multiple reasons: we don''t need the data
    anymore, we are migrating to another database, or we are replacing the current
    solution. We are in luck because the current Go facilities provide a very nice
    way to do it. The analogy is the same as for the `UPDATE` statement of our records.
    We formulate a `DELETE` statement and execute it; we can technically modify the
    action of our `UPDATE` script to delete from the database.'
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, we only modify the relevant lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `DELETE` statement will replace the `UPDATE` statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We update the line with the `Exec()` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we update the line with the calculation of updated records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Our result of the execution should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Basically, that's it. With a little modification, we have a script that can
    either update or delete records with verification.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how we can create a table that holds prime numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.02: Holding Prime Numbers in a Database'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we build on *Exercise 13.01*, *Creating a Table with Numbers*.
    We would like to create a script that will do the following: first, it will tell
    us how many prime numbers are in our table and give them to us in order of appearance.
    We would like to see the sum of prime numbers in the output. Then we would like
    to remove every even number from the table and see how many were removed. We would
    like to add the sum of prime numbers to the remaining odd numbers and update the
    table with the records, changing the property if necessary. Use the `math/big`
    package for the primality test.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a script called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Initialize our script to perform the specific actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define four variables for later use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initialize the database connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get a list of all the prime numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Print the sum of the prime numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remove the even numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the remaining records with `primeSum` and print a closing sentence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the database connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the script is executed, the following output should be visible:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.7: Output of the calculations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_13_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.7: Output of the calculations'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we saw how to utilize a built-in Go function to find prime
    numbers. We also manipulated the table by removing numbers, and then we performed
    update actions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Closing the database is important because once our job is done, we do want to
    release unused resources.
  prefs: []
  type: TYPE_NORMAL
- en: Truncating and Deleting Table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we would like to achieve in this topic is to empty a table completely and
    get rid of it. In order to empty the table, we could simply formulate `DELETE`
    statements that match every record in our table and thus remove every single record
    from our table. However, there is a more elegant way. We can use the `TRUNCATE
    TABLE` SQL statement. The result of this statement is a literally empty table.
    We can use the `Exec()` function from our `sql` package. You already know how
    to initialize the package with imports. You also know how to connect to the database.
    This time, we only focus on the statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following statement will achieve a full `TRUNCATE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The result of this is an empty table called `test`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get rid of the table completely, we should modify our statement
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If we inspect our database engine, we will not find any trace of the table called
    `test`. This eradicated the whole table from the very face of the database.
  prefs: []
  type: TYPE_NORMAL
- en: That topic was all about interacting with databases via the Go programming language.
    Now you have a decent understanding about how to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For further information and extra details, you should check out the official
    documentation of the SQL API, [https://packt.live/2Pi5oj5](https://packt.live/2Pi5oj5).
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 13.01: Holding User Data in a Table'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we are going to create a table that is going to hold user
    information such as `ID`, `Name`, and `Email`. We build on the knowledge you gathered
    in the *Creating Tables* and *Inserting Data* sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a small script that will create a table called `Users`. This table must
    have three columns: `ID`, `Name`, and `Email`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the details of two users with their data into the table. They should have
    unique names, IDs, and email addresses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then you need to update the email of the first user to user@packt.com and remove
    the second user. Make sure that none of the fields are `NULL`, and the ID is the
    primary key, so it needs to be unique.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you are inserting, updating, and deleting from the table, please use the
    `Prepare()` function to protect against SQL injection attacks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should use a struct to store the user information you would like to insert,
    and when you are inserting, iterate over the struct with a `for` loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the `insert`, `update`, and `delete` calls are complete, make sure you
    use `Close()` when appropriate and finally close the connection to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Upon successful completion, you should see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.8: Possible output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_13_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.8: Possible output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 745.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this activity, you should have learned how to create a new table
    called `users` and how to insert data into this table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 13.02: Finding Messages of Specific Users'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we will build on *Activity 13.01*: *Holding User Data in
    a Table*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a new table called `Messages`. This table will have two columns,
    both of which should have a 280-character limit: one is `UserID` and the other
    is `Message`.'
  prefs: []
  type: TYPE_NORMAL
- en: When your table is ready, you should add some messages with user IDs. Make sure
    you add `UserID`, which is not present in the `users` table.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have added the data, write a query that returns all the messages a
    specified user has sent. Use the `Prepare()` function to protect against SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the specified user cannot be found, print `The query returned nothing, no
    such user: <username>`. You should take the username as input from the keyboard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform these steps in order to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a `struct` that holds the `userID` and the messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Messages should be inserted with a `for` loop that iterates over the previously
    defined `struct`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user input is received, make sure you use the `Prepare()` statement
    to craft your query.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If everything went well, this should be the output, depending on how you fill
    your database with usernames and messages:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.9: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_13_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.9: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 748.
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can tweak the script to not try and recreate the DB on consecutive
    runs.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this activity, you should have learned how to create a new table
    called `Messages`, then take input from the user and search for related users
    and messages based on the input.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter made you efficient in interacting with SQL databases. You learned
    how to create, delete, and manipulate database tables. You have also become aware
    of all the different types of databases Go is suited to interact with. As this
    chapter was made with the `PostgreSQL` engine in mind, you should familiarize
    yourself with its Go module too. With this knowledge, you will now be able to
    take your own steps in the realm of database programming with the Go language
    and be self-sufficient in the sense that you know where to look for solutions
    to problems and for extra knowledge. The most common use case for this knowledge
    is when you must build automated reporting apps that pull data from a database
    and report it as an email. The other use case is when you have an automated app
    for pushing data to the database server that processes a CSV file or an XML file.
    This really depends on the situation you are in.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to interact with web interfaces via
    HTTP clients, which is one of the most interesting topics in Go.
  prefs: []
  type: TYPE_NORMAL
