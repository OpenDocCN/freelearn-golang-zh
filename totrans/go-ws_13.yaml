- en: 13\. SQL and Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13. SQL和数据库
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter's aim is to enable you to connect to SQL databases with the help
    of the Go programming language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是帮助你使用Go编程语言连接到SQL数据库。
- en: You will start by learning to connect to databases, creating tables in a database
    and insert data into and retrieve data from tables. By the end of this chapter,
    you will be able to update and delete data in specific tables, and also truncate
    and drop tables.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你将开始学习如何连接到数据库，在数据库中创建表，并将数据插入到表中以及从表中检索数据。到本章结束时，你将能够更新和删除特定表中的数据，还可以截断和删除表。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, you learned how to interact with the system your Go
    app is running on. You learned the importance of exit codes and how to customize
    your scripts to take arguments, thus adding flexibility to your applications.
    You also learned the mastery of handling different signals that your application
    receives.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何与你的Go应用程序运行的系统进行交互。你了解了退出代码的重要性以及如何自定义脚本以接受参数，从而增加应用程序的灵活性。你还学习了如何掌握处理应用程序接收到的不同信号。
- en: In this chapter, you will further master your Go skills by learning how to use
    SQL and databases in Go. As a developer, it is impossible to get by without a
    proper understanding of persistent data storage and databases. Our applications
    process input and produce output, but most of the time, if not in all cases, a
    database is involved in the process. This database can be in memory (stored in
    the computer's RAM) or file-based (a single file in a directory), and it can live
    on local or remote storage. The cloud can provide you with database services;
    both Azure and AWS can help you with that.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将通过学习如何在Go中使用SQL和数据库来进一步提高你的Go技能。作为一个开发者，如果没有对持久数据存储和数据库的适当理解，你将无法胜任。我们的应用程序处理输入并产生输出，但大多数情况下，如果不是所有情况，数据库都会参与到这个过程中。这个数据库可以是内存中的（存储在计算机的RAM中）或基于文件的（目录中的一个文件），它可以存在于本地或远程存储上。云可以为你提供数据库服务；Azure和AWS都可以帮助你实现这一点。
- en: What we aim to do in this chapter is to make you fluent in talking to these
    databases and understand the basic concepts of what a database is. Finally, you
    should extend your skillset to make you a better Go developer as you progress
    through this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中旨在让你能够流利地与这些数据库进行交流，并理解数据库的基本概念。最后，随着你通过本章的学习，你应该扩展你的技能集，以使你成为一个更好的Go开发者。
- en: Let's say your boss wants you to create a Go app that can communicate with a
    database. By "communicate", we mean that any transaction that is `INSERT`, `UPDATE`,
    `DELETE`, or `CREATE` can and should be handled by the application. This chapter
    will show you how to do that.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的老板要求你创建一个可以与数据库通信的Go应用程序。这里的“通信”意味着任何`INSERT`、`UPDATE`、`DELETE`或`CREATE`事务都应该由应用程序处理。本章将向你展示如何做到这一点。
- en: The Database
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库
- en: In order to make this chapter more appealing, let's see how you can have a database
    solution called `Postgres` on your system and configure it for yourself so you
    can try out the following examples.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本章更具吸引力，让我们看看如何在你的系统上安装一个名为`Postgres`的数据库解决方案，并为你进行配置，以便你可以尝试以下示例。
- en: 'First, we need to grab the installer from [https://packt.live/2RMFPYV](https://packt.live/2RMFPYV).
    Select the one which is appropriate. The installer is very easy to use, and I
    suggest you accept the defaults:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从[https://packt.live/2RMFPYV](https://packt.live/2RMFPYV)获取安装程序。选择合适的版本。安装程序非常易于使用，我建议您接受默认设置：
- en: 'Run the installer:![Figure 13.1: Selecting the installation directory'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行安装程序：![图13.1：选择安装目录
- en: '](img/B14177_13_01.jpg)'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14177_13_01.jpg)'
- en: 'Figure 13.1: Selecting the installation directory'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.1：选择安装目录
- en: 'Leave the default components:![Figure 13.2: Selecting components to install'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留默认组件：![图13.2：选择要安装的组件
- en: '](img/B14177_13_02.jpg)'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14177_13_02.jpg)'
- en: 'Figure 13.2: Selecting components to install'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.2：选择要安装的组件
- en: 'Leave the default data directory:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留默认数据目录：
- en: '![Figure 13.3: Selecting the data directory'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.3：选择数据目录'
- en: '](img/B14177_13_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_13_03.jpg)'
- en: 'Figure 13.3: Selecting the data directory'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3：选择数据目录
- en: It will ask for a password, which you need to remember because this is the master
    password for your database. `Start!123` is the password for this example. The
    database is running on the local port 5432\. The `pgAdmin` GUI tool will also
    be installed, and, once the installer completes, you can start `pgAdmin` to connect
    to the database.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 它将要求输入密码，您需要记住这个密码，因为这是您数据库的主密码。`Start!123` 是本例的密码。数据库运行在本地的 5432 端口上。`pgAdmin`
    图形界面工具也将被安装，一旦安装程序完成，您就可以启动 `pgAdmin` 来连接到数据库。
- en: 'In the browser, the following link can be used to access the admin surface:
    [https://packt.live/2PKWc5w](https://packt.live/2PKWc5w):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '在浏览器中，可以使用以下链接访问管理界面：[https://packt.live/2PKWc5w](https://packt.live/2PKWc5w):'
- en: '![Figure 13.4: The admin interface'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.4：管理界面'
- en: '](img/B14177_13_04.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_13_04.jpg)'
- en: 'Figure 13.4: The admin interface'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4：管理界面
- en: Once the installation is complete, we are ready to proceed to the next part
    and connect to the database via Go.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装完成，我们就可以继续进行下一部分，并通过 Go 连接到数据库。
- en: Database API and Drivers
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库 API 和驱动程序
- en: In order to work with databases, there is something called the "pure" Go approach,
    which means Go has an API that allows you to use different drivers to connect
    to databases. The API comes from the `database/sql` package, and the drivers can
    be of two types. There is native support for a wide variety of drivers, which
    can be found on the official GitHub page ([https://packt.live/2LMzcC4](https://packt.live/2LMzcC4)),
    and there are third-party drivers that need additional packages to function, such
    as the `SQLlite3` package, which requires you to have `GCC` installed because
    it is a pure C implementation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与数据库一起工作，有一种称为“纯”Go 方法的东西，这意味着 Go 有一个 API 允许您使用不同的驱动程序连接到数据库。该 API 来自 `database/sql`
    包，驱动程序有两种类型。官方 GitHub 页面提供了对大量驱动程序的本地支持（[https://packt.live/2LMzcC4](https://packt.live/2LMzcC4)），并且还有需要额外包才能运行的第三方驱动程序，例如
    `SQLlite3` 包，它要求您安装 `GCC`，因为它是一个纯 C 实现。
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: GCC is a compiler system produced by the GNU Project. It takes your source code
    and translates it to machine code so that your computer can run the application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: GCC 是由 GNU 项目生产的编译器系统。它将您的源代码转换为机器代码，以便您的计算机可以运行应用程序。
- en: 'Here is a list of a couple of drivers:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些驱动程序的列表：
- en: '**MySQL** ([https://packt.live/38zk9Fw](https://packt.live/38zk9Fw))'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MySQL** ([https://packt.live/38zk9Fw](https://packt.live/38zk9Fw))'
- en: '**Oracle** ([https://packt.live/34cxwrP](https://packt.live/34cxwrP))'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Oracle** ([https://packt.live/34cxwrP](https://packt.live/34cxwrP))'
- en: '**ODBC** ([https://packt.live/2EfETV8](https://packt.live/2EfETV8))'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ODBC** ([https://packt.live/2EfETV8](https://packt.live/2EfETV8))'
- en: '**Postgres** ([https://packt.live/35jKEwL](https://packt.live/35jKEwL))'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Postgres** ([https://packt.live/35jKEwL](https://packt.live/35jKEwL))'
- en: The idea behind the API and driver approach is that Go provides a unified interface
    that allows developers to talk to different types of databases. All you need to
    do is import the API and the necessary driver and you are able to talk to the
    database. You don't need to learn driver-specific implementations or how that
    driver works because the API's sole purpose is to create an abstraction layer
    that accelerates development.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: API 和驱动程序方法背后的理念是，Go 提供了一个统一的接口，允许开发者与不同类型的数据库进行通信。您需要做的就是导入 API 和必要的驱动程序，然后您就可以与数据库进行通信。您不需要学习特定驱动程序的实现或该驱动程序是如何工作的，因为
    API 的唯一目的是创建一个抽象层，以加速开发。
- en: Let's take an example. Let's say we would like to have a script that queries
    a database. This database is MySQL. One approach is to take the driver and learn
    how to code in its language, and then you are good to go. Some time passes by,
    and you build lots of small scripts that do their job properly. Now the time has
    come for a management decision that will make you unhappy. They decide that MySQL
    is not good enough, and they will replace the database with AWS Athena, a cloud-based
    database. Now, since you wrote your scripts specifically for a certain driver,
    you will be busy rewriting your scripts in order for them to work properly. The
    safeguard here is to use a unified API and driver combination. This means writing
    the scripts against the API and not the driver. The API will translate your wishes
    for the specific driver. This way, all you need to do is swap out the driver,
    and the scripts are guaranteed to work. You just saved yourself many hours of
    scripting and rewriting code, even though the underlying database has been completely
    replaced.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。假设我们想要一个查询数据库的脚本。这个数据库是MySQL。一种方法是从驱动程序开始学习如何用其语言编写代码，然后你就可以开始了。过了一段时间，你编写了很多小脚本，它们都能正确地完成工作。现在，是时候做出一个让你不高兴的管理决策了。他们决定MySQL不够好，他们将用基于云的数据库AWS
    Athena来替换数据库。现在，由于你为特定的驱动程序编写了脚本，你将忙于重写脚本以便它们能正常工作。这里的保障是使用统一的API和驱动程序组合。这意味着编写针对API而不是驱动程序的脚本。API将翻译你对特定驱动程序的愿望。这样，你唯一需要做的就是更换驱动程序，脚本就能保证正常工作。你刚刚为自己节省了许多小时编写脚本和重写代码的时间，即使底层数据库已经被完全替换。
- en: 'When we are working with databases in Go, we differentiate these types of databases:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Go中使用数据库时，我们区分以下类型的数据库：
- en: Relational databases
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系型数据库
- en: NoSQL databases
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NoSQL数据库
- en: Search and analytic databases
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索和分析数据库
- en: Connecting to Databases
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: Connecting to a database is by far the easiest thing to do; however, we need
    to keep a few things in mind. In order to connect to any database, we need at
    least four things to be in place. We need a host to connect to, we need a database
    to connect to that is running on a port, and we need a username and password.
    The user needs to have appropriate privileges because we not only want to connect
    but we would like to perform specific operations, such as query, insert, or remove
    data, create or delete databases, and manage users and views. Let's imagine that
    connecting to a database is like walking up to a door as a specific person with
    a specific key. Whether the door opens or not depends on the key, but what we
    can do after we have crossed the threshold will depend on the person (which is
    defined by their privileges).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到数据库是最容易的事情；然而，我们需要记住一些事情。为了连接到任何数据库，我们至少需要四个条件。我们需要一个要连接的主机，我们需要连接到运行在端口的数据库，我们还需要用户名和密码。用户需要具有适当的权限，因为我们不仅想要连接，我们还希望执行特定的操作，例如查询、插入或删除数据，创建或删除数据库，以及管理用户和视图。让我们想象一下，连接到数据库就像作为一个特定的人拿着特定的钥匙走到门前。门是否打开取决于钥匙，但我们越过门槛后能做什么将取决于这个人（由他们的权限定义）。
- en: In most cases, the database server supports multiple databases and the databases
    hold one or more tables. Imagine that the databases are logical containers that
    belong together.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，数据库服务器支持多个数据库，并且数据库包含一个或多个表。想象一下，数据库是相互关联的逻辑容器。
- en: 'Let''s take a look at how we can connect to a database in Go. In order to connect,
    we need to get the appropriate module from GitHub, which needs internet connectivity.
    We need to issue the following command to get the package needed to interact with
    the Postgres instance:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在Go中连接到数据库。为了连接，我们需要从GitHub获取适当的模块，这需要互联网连接。我们需要发出以下命令来获取与Postgres实例交互所需的包：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once this completes, you are ready to start scripting. First, we will initialize
    our script:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成，你就可以开始编写脚本了。首先，我们将初始化我们的脚本：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`import _ <package name>` is a special `import` statement that tells Go to
    import a package solely for its side effects.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`import _ <package name>` 是一个特殊的 `import` 语句，它告诉Go仅为了其副作用而导入一个包。'
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you would like further information, visit [https://packt.live/2PByusw](https://packt.live/2PByusw).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要更多信息，请访问 [https://packt.live/2PByusw](https://packt.live/2PByusw)。
- en: 'Now that we have initialized our script, we can actually connect to our database:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了脚本，我们实际上可以连接到我们的数据库：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This topic is special because the API gives us an `Open()` function, which
    takes a variety of arguments. There are shorthand ways of doing this, but I would
    like you to know about all the components that are involved in making the connections,
    so I will use the longer way. Later, you can decide which one to use. The `Postgres`
    tells the function to use the `Postgres` driver to make the connection. The second
    argument is a so-called connection string, which holds the `user`, `password`,
    `host`, `port`, `dbname`, and `sslmode` arguments, which will be used to initialize
    the connection. In this example, we connect to the localhost marked by `127.0.0.1`
    on the default port 5432, and we don''t use `ssl`. For production systems, people
    tend to change the default port and enforce encrypted traffic via `ssl` toward
    the database server, and you should always follow the best practices concerning
    the type of database you''re working with. As you can see, the `Open()` function
    returns two values. One is for the database connection and the other is for the
    error, if any occurred during initialization. How do we check whether the initialization
    was success? Well, we can check whether there were any errors by writing the following
    code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主题是特殊的，因为 API 给我们提供了一个 `Open()` 函数，它接受各种参数。有简写的方式来完成这个任务，但我希望您了解所有参与建立连接的组件，所以我将使用较长的方法。稍后，您可以决定使用哪一个。`Postgres`
    告诉函数使用 `Postgres` 驱动程序来建立连接。第二个参数是一个所谓的连接字符串，它包含 `user`、`password`、`host`、`port`、`dbname`
    和 `sslmode` 参数，这些参数将用于初始化连接。在这个例子中，我们连接到标记为 `127.0.0.1` 的本地主机上的默认端口 5432，并且我们不使用
    `ssl`。对于生产系统，人们倾向于更改默认端口并通过 `ssl` 对数据库服务器强制加密流量，您应该始终遵循您所使用的数据库类型的相关最佳实践。如您所见，`Open()`
    函数返回两个值。一个是数据库连接，另一个是错误，如果在初始化过程中发生了错误。我们如何检查初始化是否成功？嗯，我们可以通过编写以下代码来检查是否有错误：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `panic()` function in Go is used to indicate that something went wrong
    unexpectedly, and we are not prepared to handle it gracefully, thus stopping the
    execution. If the connection succeeds, we print out the `The connection to the
    DB was successfully initialized!` message. When you have a long-running application,
    it is worth incorporating a way to check whether the database is still reachable,
    because due to intermittent network errors you could lose the connection and fail
    to execute whatever you wanted to execute. This can be checked with the following
    small code snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的 `panic()` 函数用于指示发生了意外的错误，我们无法优雅地处理它，因此停止执行。如果连接成功，我们打印出 `The connection
    to the DB was successfully initialized!` 消息。当您有一个长时间运行的应用程序时，值得加入一种检查数据库是否仍然可访问的方法，因为由于间歇性的网络错误，您可能会丢失连接，无法执行您想要执行的操作。这可以通过以下小代码片段进行检查：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this case, we used the `panic()` function to indicate that the connection
    has been lost. Finally, once our job is done, we need to terminate our connection
    to the database in order to remove user sessions and free up resources. In big
    enterprise environments with thousands of users hitting the same database, it''s
    a wise decision to use the database only when necessary, and once the work is
    done, close the connections. There are two ways to close the connection:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了 `panic()` 函数来指示连接已丢失。最后，一旦我们的工作完成，我们需要终止与数据库的连接，以便删除用户会话并释放资源。在拥有数千用户同时访问同一数据库的大型企业环境中，仅在必要时使用数据库，并在工作完成后关闭连接是一个明智的决定。关闭连接有两种方法：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The difference is the scope. `db.Close()` will terminate the connection to the
    database once the execution arrives at the specific line, while `defer db.Close()`
    indicates that the database connection should be executed once the function in
    which it was called goes out of scope. The idiomatic way to do it is with `defer
    db.Close()`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 差异在于范围。`db.Close()` 会在执行到达特定行时终止与数据库的连接，而 `defer db.Close()` 表示数据库连接应在调用它的函数超出作用域时执行。进行此操作的惯用方法是使用
    `defer db.Close()`。
- en: Now, in order to further demonstrate this, we will create a table.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了进一步演示这一点，我们将创建一个表。
- en: Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The official `Postgres` module of Go can be found at [https://packt.live/35jKEwL](https://packt.live/35jKEwL).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的官方 `Postgres` 模块可以在 [https://packt.live/35jKEwL](https://packt.live/35jKEwL)
    找到。
- en: Creating Tables
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表格
- en: The act of creating tables aims to make logical containers that persistently
    hold data that belongs together. Many companies create tables for many reasons,
    for example, tracking employee attendance, revenue tracking, and statistics. The
    common goal is to provide a service for applications that make sense of it. How
    do these database engines control who can access what data? There are basically
    two approaches. The first one is `CREATE`, `UPDATE`, and `DELETE`. The second
    approach involves inheritance and roles. This is more robust and is better suited
    for big enterprises. Before using a database engine, there used to be a precheck
    to see what the size would be and how many users would use it. There is no point
    in shooting a sparrow with a shotgun, and there is no shoe size that fits all.
    It all depends on the situation. `Postgres` uses the second approach, and in this
    topic, we will see how to create a SQL table and how to create one specifically
    in `Postgres`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表的行为旨在创建逻辑容器，这些容器可以持久地保存属于一起的数据。许多公司出于许多原因创建表，例如跟踪员工出勤、收入跟踪和统计数据。共同的目标是为理解这些数据的应用程序提供服务。这些数据库引擎是如何控制谁可以访问什么数据的？基本上有两种方法。第一种是`CREATE`、`UPDATE`和`DELETE`。第二种方法涉及继承和角色。这种方法更稳健，更适合大型企业。在使用数据库引擎之前，通常会进行预检查以查看大小和预计使用它的用户数量。用猎枪打麻雀是没有意义的，也没有适合所有人的鞋码。一切都取决于具体情况。`Postgres`使用第二种方法，在本主题中，我们将看到如何创建SQL表以及如何在`Postgres`中特别创建一个表。
- en: 'The general syntax for table creation looks like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表创建的一般语法看起来是这样的：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Before we continue, we need to clarify what SQL is. SQL is a standard that stands
    for `Postgres`, `mysql`, or `mssql` server, they all respond in the same way to
    a `CREATE TABLE` or `INSERT` command because they are SQL compliant. The idea
    of the standard is not to specify how the engine works internally but how the
    interaction with it should happen. These database engines usually differ in terms
    of functionality, speed, and storage approaches; that's where the variety comes
    from. This is not a full SQL or database engine tutorial. I just wanted to give
    you a brief explanation so that you understand the commands better. The general
    command for table creation is `CREATE TABLE`. This command is understood in the
    context of the database you are connected to. One server can host multiple databases,
    and connecting to the wrong one can cause headaches when issuing a command that
    modifies the structure. The command usually takes a column name, which is `column1`
    in our case, and the type of data in our column, which is `datatype`. Finally,
    we can set constraints on our columns, which will imbue them with special properties.
    The supported datatypes for our columns depend on the database engine.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要明确什么是SQL。SQL是一个标准，代表`Postgres`、`mysql`或`mssql`服务器，它们都对`CREATE TABLE`或`INSERT`命令以相同的方式响应，因为它们都符合SQL标准。标准的想法不是指定引擎内部的工作方式，而是指定与它的交互应该如何发生。这些数据库引擎通常在功能、速度和存储方法方面有所不同；这就是多样性的来源。这并不是一个完整的SQL或数据库引擎教程。我只是想给你一个简要的解释，以便你更好地理解命令。创建表的通用命令是`CREATE
    TABLE`。这个命令在你连接的数据库的上下文中被理解。一个服务器可以托管多个数据库，连接到错误的数据库在执行修改结构的命令时可能会引起头疼。命令通常需要一个列名，在我们的例子中是`column1`，以及我们列中的数据类型，即`datatype`。最后，我们可以在我们的列上设置约束，这将赋予它们特殊属性。我们列支持的类型取决于数据库引擎。
- en: 'Here are some common datatypes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些常见的数据类型：
- en: INT
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: INT
- en: DOUBLE
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DOUBLE
- en: FLOAT
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FLOAT
- en: VARCHAR, which is a string with a specific length
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VARCHAR，它是一个具有特定长度的字符串
- en: 'The constraints also depend on the database engine, but some of them are as
    follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 约束也取决于数据库引擎，但以下是一些例子：
- en: NOT NULL
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NOT NULL
- en: PRIMARY KEY
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PRIMARY KEY
- en: Named function
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名函数
- en: The named function is executed every time a new record is inserted or an old
    one is updated and, based on the evaluation of the transaction, is either allowed
    or denied.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数在每次插入新记录或更新旧记录时执行，并根据事务的评估，允许或拒绝。
- en: 'We are not only able to create a table, but we can also empty the table, remove
    all of its contents, or remove the table itself from the database. In order to
    empty a table, we use the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅能够创建一个表，还可以清空表，移除其所有内容，或者从数据库中删除该表本身。为了清空一个表，我们使用以下命令：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to remove the table, we use:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了删除表，我们使用：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now create a new table. In `Postgres`, you have a default database you can use;
    we are not going to create a separate database for the examples.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个新的表。在`Postgres`中，您可以使用默认的数据库；我们不会为示例创建单独的数据库。
- en: 'We would like to initialize our script, which you can find in the examples
    folder, and it''s called `DBInit.go`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望初始化脚本，您可以在示例文件夹中找到它，名为`DBInit.go`：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we are ready to define our `main()` function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备定义我们的`main()`函数：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s dissect what is happening here. We initialize our connection to the
    database without the default username and password that was previously mentioned,
    and now we have the `db` variable to interact with the database. Unless there
    was an error upon execution, the following output will be visible on our console:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这里发生了什么。我们初始化数据库连接，没有使用之前提到的默认用户名和密码，现在我们有了`db`变量来与数据库交互。除非执行过程中出现错误，否则以下输出将在我们的控制台上可见：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we were to rerun the script, the following error would occur:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新运行脚本，将出现以下错误：
- en: '![Figure 13.5: Output of failure after consecutive execution'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.5：连续执行后的失败输出'
- en: '](img/B14177_13_05.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_13_05.jpg)'
- en: 'Figure 13.5: Output of failure after consecutive execution'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5：连续执行后的失败输出
- en: This says that the table already exists. We created a multiline string called
    `DBCreate` that holds all the table creation information. In this, we have a table
    called `test`, which has an integer column called `id` and a string column called
    `name`. The rest of it is `Postgres`-specific configuration. The tablespace defines
    where our table lives. The `_, err` line with `db.Exec()` is responsible for executing
    the query.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示表已经存在。我们创建了一个名为`DBCreate`的多行字符串，其中包含所有表创建信息。在这里，我们有一个名为`test`的表，它有一个名为`id`的整数列和一个名为`name`的字符串列。其余的是`Postgres`特定的配置。表空间定义了我们的表所在的位置。`_,
    err`行中的`db.Exec()`负责执行查询。
- en: Since our goal now is to create the table, we only care whether there are any
    errors; otherwise, we use a throwaway variable to capture the output. If `err`
    is not `nil`, there was an error, which we saw demonstrated previously. Otherwise,
    we assume the table was created as expected. Finally, the connection to the database
    is closed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的目标是创建表，我们只关心是否有任何错误；否则，我们使用一个临时变量来捕获输出。如果`err`不是`nil`，则表示出现了错误，这我们在之前已经演示过。否则，我们假设表已按预期创建。最后，关闭数据库连接。
- en: Now that we can connect to the database and we have a table, we can insert some
    data.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以连接到数据库并且有一个表，我们可以插入一些数据。
- en: Inserting Data
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入数据
- en: 'Long ago, when the era of web applications backed by SQL databases started
    to bloom, there were some gutsy people who invented the SQL injection attack.
    A type of authentication is done via SQL queries against a database and, for example,
    after converting the password with mathematical magic into hash functions, all
    the web app did was execute the query with the username and password coming from
    the input of the form. Many servers executed something like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，当支持SQL数据库的Web应用程序时代开始蓬勃发展时，有一些勇敢的人发明了SQL注入攻击。一种身份验证是通过针对数据库的SQL查询完成的，例如，通过数学魔法将密码转换为散列函数后，所有Web应用程序所做的只是执行带有来自表单输入的用户名和密码的查询。许多服务器执行了类似以下操作：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Then, the password gets rehashed; if the two hashes match, the password was
    good for the user.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，密码将被重新散列；如果两个散列匹配，则密码对用户有效。
- en: 'The problem with this came from the `<input from user>` part, because if the
    attacker was smart enough, they could reformulate the query and run additional
    commands. For example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题出在`<用户输入>`部分，因为如果攻击者足够聪明，他们可以重新构造查询并运行额外的命令。例如：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The problem with this query is that `OR '1' = '1'` always evaluates to `true`,
    and it does not matter what the username was, all the user's password hash would
    be returned. This can be further reused to formulate an additional attack. In
    order to prevent this, Go uses something called the `Prepare()` statement, which
    provides protection against these attacks.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询的问题在于`OR '1' = '1'`始终评估为`true`，并且无论用户名是什么，都会返回所有用户的密码散列。这可以进一步用于制定额外的攻击。为了防止这种情况，Go使用了一种称为`Prepare()`语句的方法，它提供了对这些攻击的保护。
- en: Go has two types of substitutions. We either use `WHERE col = $1` in the case
    of queries, or `VALUES($1,$2)` in the case of inserts or updates.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Go有两种替换类型。在查询的情况下，我们使用`WHERE col = $1`，或者在插入或更新的情况下使用`VALUES($1,$2)`。
- en: 'Let''s add some values to our tables. We are going to initialize our script
    in the usual way. The script can be found under the examples folder and is called
    `DBInsert.go`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向我们的表中添加一些值。我们将以通常的方式初始化我们的脚本。该脚本位于示例文件夹中，名为`DBInsert.go`：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `main()` function, we connect to the database as usual:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们像往常一样连接到数据库：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Upon successful execution, the output is as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 执行成功后，输出如下：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's see what is happening with the insert part. `db.Prepare()` takes a SQL
    statement and imbues it with protection against SQL injection attacks. The way
    this works is that it restricts the values of the variable substitutions. In our
    case, we have two columns, so for the substitution to work we use $1 and $2\.
    You can use any number of substitutions; you only need to make sure they result
    in a valid SQL statement when evaluated. When the `insert` variable is initialized
    without errors, it will be responsible for executing the SQL statement. It finds
    out how many arguments the prepared statement expects, and its sole purpose is
    to call the statement and perform the operation. `insert.Exec(2,"second")` inserts
    a new element with `id=2` and `name='second'`. If we were to check what we have
    in our database, we would see the results.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看插入部分发生了什么。`db.Prepare()`接受一个SQL语句，并赋予它防止SQL注入攻击的保护。它是通过限制变量替换的值来工作的。在我们的例子中，我们有两个列，所以为了使替换工作，我们使用$1和$2。你可以使用任意数量的替换；你只需要确保它们在评估时产生一个有效的SQL语句。当`insert`变量初始化且没有错误时，它将负责执行SQL语句。它找出预定义语句期望多少个参数，它的唯一目的是调用语句并执行操作。`insert.Exec(2,"second")`插入一个新元素，`id=2`和`name='second'`。如果我们检查我们的数据库，我们会看到结果。
- en: Now that we have some data in our table, we can query it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们表中已经有了一些数据，我们可以查询它。
- en: 'Exercise 13.01: Creating a Table with Numbers'
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.01：使用数字创建表
- en: In this exercise, we are going to write a script that is going to create a table
    called `Numbers`, in which we are going to store numbers. These numbers will be
    inserted at a later time.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个脚本，该脚本将创建一个名为`Numbers`的表，我们将存储数字。这些数字将在稍后插入。
- en: Create two columns, `Number` and `Property`. The `Number` column will hold numbers,
    and the `Property` column will be either `Odd` or `Even` at the time of creation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个列，`Number`和`Property`。`Number`列将存储数字，而`Property`列在创建时将是`Odd`或`Even`。
- en: Use the default `Postgres` database for the connection. The numbers should range
    from 0 to 99.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认的`Postgres`数据库进行连接。数字应从0到99。
- en: 'Perform the following steps in order to complete the exercise:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤执行以完成练习：
- en: Create a file called `main.go`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的文件。
- en: 'Initialize the package with the following lines:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下行初始化包：
- en: '[PRE17]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a `prop` `string` variable for later use:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于后续使用的`prop` `string`变量：
- en: '[PRE18]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Initialize the database connection:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化数据库连接：
- en: '[PRE19]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create the multiline string to create the table:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个多行字符串来创建表：
- en: '[PRE20]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create the table:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建表：
- en: '[PRE21]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Insert the numbers:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入数字：
- en: '[PRE22]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Close the database connection:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭数据库连接：
- en: '[PRE23]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When you execute the script, you should see the following output:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你执行脚本时，你应该看到以下输出：
- en: '![Figure 13.6: Output of the successful property update'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.6：成功更新属性的输出'
- en: '](img/B14177_13_06.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_13_06.jpg)'
- en: 'Figure 13.6: Output of the successful property update'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.6：成功更新属性的输出
- en: Note
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Part of the output is omitted from *Figure 13.6* due to its length.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于长度原因，*图13.6*中省略了部分输出。
- en: In this exercise, we saw how to create a new table in our database and how to
    insert new records with the help of a `for` loop and a `Prepare()` statement.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何在数据库中创建一个新的表，以及如何使用`for`循环和`Prepare()`语句插入新记录。
- en: Retrieving Data
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取数据
- en: SQL injection does not only concern the data being inserted. It also concerns
    any data that is manipulated in the database. Retrieving data and, most importantly,
    retrieving it safely is also something we must prioritize and handle with proper
    caution. When we query data, our results depend on the database we connect to
    and the table we would like to query. But we must also mention that the security
    mechanisms implemented by the database engine may also prevent a successful query
    unless the user has appropriate privileges. We differentiate two types of queries.
    There are queries that do not take an argument, such as `SELECT * FROM table`,
    and there are queries that require you to specify filter criteria. Go provides
    two functions that allow you to query data. One is called the `Query()` function
    and the other is called the `QueryRow()` function. The availability of these functions
    depends on the database you are interacting with. As a rule of thumb, you should
    remember that the `Query()` function is most likely to work. You can also wrap
    them with the `Prepare()` statement, which will not cover in this topic as it
    was demonstrated before. Instead, we want to see how these functions work
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 注入不仅关注要插入的数据。它还关注在数据库中操纵的任何数据。检索数据，更重要的是，安全地检索数据，也是我们必须优先考虑和处理的事项。当我们查询数据时，我们的结果取决于我们连接的数据库和我们想要查询的表。但我们也必须提到，数据库引擎实施的安全机制也可能阻止成功查询，除非用户具有适当的权限。我们区分两种类型的查询。有一种查询不需要参数，例如
    `SELECT * FROM table`，还有一种查询需要你指定过滤条件。Go 提供了两个允许你查询数据的函数。一个叫做 `Query()` 函数，另一个叫做
    `QueryRow()` 函数。这些函数的可用性取决于你交互的数据库。作为一个经验法则，你应该记住 `Query()` 函数最有可能工作。你还可以用 `Prepare()`
    语句包装它们，但这不是本主题的讨论内容，因为它之前已经演示过了。相反，我们想看看这些函数是如何工作的
- en: Let's create a script for `Query()`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为 `Query()` 函数创建一个脚本。
- en: 'We initialize the script as always. It can be found in the examples and is
    called `DBQuery.go`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像往常一样初始化脚本。它可以在示例中找到，称为 `DBQuery.go`：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Our `main()` function will be a little bit different because we would like
    to introduce the `Scan()` function:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `main()` 函数将略有不同，因为我们想引入 `Scan()` 函数：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output should look like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该看起来像这样：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we have previously inserted this data to our database, feel free to add some
    more data based on the previous example. We have defined the `id` and `name` variables,
    which will help our `Scan()` function. We connect to the database and create our
    `db` variable. After that, we fill our `rows` variable with the result of the
    `Query()` function, which will basically hold all the elements from the table.
    Here comes the tricky part. We use `for rows.Next()` to iterate over the resulting
    rows. But that is not enough; we would like to assign the results of the query
    to the corresponding variable, which is returned by `rows.Scan(&id, &name)`. This
    allows us to refer to the current row's ID and `NAME`, which makes it easier to
    do whatever we would like to do with the value. Finally, the `rows` and the database
    connections are gracefully closed.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们之前已经将此数据插入到我们的数据库中，你可以根据之前的示例添加更多数据。我们定义了 `id` 和 `name` 变量，这将有助于我们的 `Scan()`
    函数。我们连接到数据库并创建我们的 `db` 变量。之后，我们将 `rows` 变量填充为 `Query()` 函数的结果，它基本上将包含表中的所有元素。接下来是难点。我们使用
    `for rows.Next()` 来遍历结果行。但这还不够；我们希望将查询结果分配给相应的变量，该变量由 `rows.Scan(&id, &name)`
    返回。这允许我们引用当前行的 ID 和 `NAME`，这使得我们可以更容易地处理值。最后，我们优雅地关闭 `rows` 和数据库连接。
- en: Let's query a single row with `Prepare()`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 `Prepare()` 查询一行。
- en: The initialization looks the same as before.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化看起来和之前一样。
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The main difference is at the beginning of the `main()` function:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于 `main()` 函数的开始部分：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output, if you did everything correctly, should look something like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切都做对了，输出应该看起来大致像这样：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s inspect our `main` function closely. We defined two variables: the `name`
    variable will be used when we process the query result, and the `id` variable
    serves as a flexible input for the query we execute. The usual connection initialization
    toward our database happens as before. Then comes the `SQL Injection` proof part.
    We prepare a query that is dynamic in the sense that it accepts a parameter that
    will be the ID we are looking for. Then, `qryrow` is used to execute the `QueryRow()`
    function, which in turn takes the `id` variable we specified previously and returns
    the result in the `name` variable. Then we output the string with an explanation
    that the value of the column is based on the `id` variable that was specified.
    At the end, the `qryrow` and `db` resources are closed.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细检查一下我们的`main`函数。我们定义了两个变量：`name`变量将在我们处理查询结果时使用，而`id`变量则作为我们执行的查询的灵活输入。与数据库的常规连接初始化与之前相同。然后是`SQL注入`证明部分。我们准备了一个查询，它在意义上是动态的，因为它接受一个参数，这个参数将是我们要查找的ID。然后，使用`qryrow`来执行`QueryRow()`函数，该函数反过来又使用我们之前指定的`id`变量，并将结果返回到`name`变量中。然后我们输出一个带有解释的字符串，说明列的值是基于指定的`id`变量。最后，关闭`qryrow`和`db`资源。
- en: Now that we know how to retrieve data from the database, we need to see how
    to update existing data in our database.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何从数据库中检索数据，我们需要看看如何更新我们数据库中的现有数据。
- en: Updating Existing Data
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新现有数据
- en: When you are updating a row or multiple rows with Go, you are in trouble. The
    `sql` package does not provide any function called `Update()`; however, there
    is the `Exec()` function, which serves as a universal executor for your queries.
    You can execute `SELECT`, `UPDATE`, `DELETE`, or whatever you need to execute
    with this function. This topic will show you how you can do it safely.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Go更新一行或多行时，你会有麻烦。`sql`包没有提供任何名为`Update()`的函数；然而，有一个`Exec()`函数，它作为你查询的通用执行器。你可以使用这个函数执行`SELECT`、`UPDATE`、`DELETE`或你需要执行的任何操作。这个主题将向你展示你如何安全地做到这一点。
- en: 'We would like to start our script in the usual way. It can be found in the
    examples folder and is called `DBUpdate.go`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想以通常的方式开始我们的脚本。它可以在示例文件夹中找到，并命名为`DBUpdate.go`：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then the magic comes. The idea is to update the `name` column''s value for
    a specific `id` variable that we give as an argument. So, the `main()` function
    looks like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后出现魔法。想法是更新我们作为参数给出的特定`id`变量的`name`列的值。所以，`main()`函数看起来是这样的：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If everything went well, we see the following output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将看到以下输出：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that you can and should experiment with different inputs and see how the
    script reacts to different problems/errors.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以也应该尝试不同的输入，看看脚本如何对不同的问题/错误做出反应。
- en: Let's dissect what is happening here. We initialize our database connection
    as we did before. We create the `UpdateStatement` variable, which is a multiline
    string, and it is crafted so that it can be fed to the `Exec()` function, which
    takes arguments. We want to update the name of the column that has the specified
    ID. This function either runs the specified statement on its own or can be used
    to pass arguments that are substituted in the appropriate place. This would be
    perfectly fine and would do the job for us, but we would like to make sure that
    the `UPDATE` command actually updates at least one record. To this end, we could
    use `RowsAffected()`. It will return the number of rows that were updated, and
    any errors that were faced along the way. Finally, we print to the console how
    many rows were updated and close the connection.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们剖析一下这里发生了什么。我们像之前一样初始化我们的数据库连接。我们创建了一个`UpdateStatement`变量，它是一个多行字符串，并且被设计成可以输入到`Exec()`函数中，该函数接受参数。我们希望更新具有指定ID的列的名称。这个函数要么自己运行指定的语句，或者可以用来传递在适当位置替换的参数。这本来是完全可以的，也会为我们完成任务，但我们想确保`UPDATE`命令实际上至少更新了一条记录。为此，我们可以使用`RowsAffected()`。它将返回更新的行数，以及过程中遇到的任何错误。最后，我们在控制台上打印出更新的行数，并关闭连接。
- en: The time has come to delete data from our database.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候从我们的数据库中删除数据了。
- en: Deleting Data
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除数据
- en: 'The deletion of data can happen for multiple reasons: we don''t need the data
    anymore, we are migrating to another database, or we are replacing the current
    solution. We are in luck because the current Go facilities provide a very nice
    way to do it. The analogy is the same as for the `UPDATE` statement of our records.
    We formulate a `DELETE` statement and execute it; we can technically modify the
    action of our `UPDATE` script to delete from the database.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的删除可能由多个原因引起：我们不再需要这些数据，我们正在迁移到另一个数据库，或者我们正在替换当前解决方案。我们很幸运，因为当前的Go功能提供了一个非常方便的方式来执行它。这个类比与我们的记录`UPDATE`语句相同。我们制定一个`DELETE`语句并执行它；技术上我们可以修改我们的`UPDATE`脚本来从数据库中删除。
- en: For the sake of simplicity, we only modify the relevant lines.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们只修改相关的行。
- en: 'Our `DELETE` statement will replace the `UPDATE` statement like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`DELETE`语句将像这样替换`UPDATE`语句：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We update the line with the `Exec()` statement:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新了带有`Exec()`语句的行：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Also, we update the line with the calculation of updated records:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还更新了计算更新记录的行：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Our result of the execution should look like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行的结果应该看起来像这样：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Basically, that's it. With a little modification, we have a script that can
    either update or delete records with verification.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，就是这样。经过一点修改，我们有一个可以更新或删除记录并验证的脚本。
- en: Now, let's see how we can create a table that holds prime numbers.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何创建一个包含质数的表。
- en: 'Exercise 13.02: Holding Prime Numbers in a Database'
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.02：在数据库中存储质数
- en: 'In this exercise, we build on *Exercise 13.01*, *Creating a Table with Numbers*.
    We would like to create a script that will do the following: first, it will tell
    us how many prime numbers are in our table and give them to us in order of appearance.
    We would like to see the sum of prime numbers in the output. Then we would like
    to remove every even number from the table and see how many were removed. We would
    like to add the sum of prime numbers to the remaining odd numbers and update the
    table with the records, changing the property if necessary. Use the `math/big`
    package for the primality test.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们基于*练习13.01*，*创建数字表*，进行扩展。我们希望创建一个脚本，它将执行以下操作：首先，它会告诉我们表中有多少个质数，并按出现的顺序提供给我们。我们希望看到质数的总和。然后，我们希望从表中删除所有偶数并查看删除了多少个。我们希望将质数的总和添加到剩余的奇数中，并根据需要更新表中的记录，更改属性。使用`math/big`包进行质数测试。
- en: 'Follow these steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Create a script called `main.go`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`main.go`的脚本。
- en: 'Initialize our script to perform the specific actions:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化我们的脚本以执行特定操作：
- en: '[PRE37]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Define four variables for later use:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义四个变量供以后使用：
- en: '[PRE38]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Initialize the database connection:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化数据库连接：
- en: '[PRE39]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Get a list of all the prime numbers:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有质数的列表：
- en: '[PRE40]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Print the sum of the prime numbers:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印质数的总和：
- en: '[PRE41]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Remove the even numbers:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除偶数：
- en: '[PRE42]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Update the remaining records with `primeSum` and print a closing sentence:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`primeSum`更新剩余的记录并打印一个结束语：
- en: '[PRE43]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Close the database connection:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭数据库连接：
- en: '[PRE44]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once the script is executed, the following output should be visible:'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦脚本执行，以下输出应该是可见的：
- en: '![Figure 13.7: Output of the calculations'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.7：计算输出]'
- en: '](img/B14177_13_07.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图13.7：计算输出](img/B14177_13_07.jpg)'
- en: 'Figure 13.7: Output of the calculations'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7：计算输出
- en: In this exercise, we saw how to utilize a built-in Go function to find prime
    numbers. We also manipulated the table by removing numbers, and then we performed
    update actions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看到了如何利用内置的Go函数来查找质数。我们还通过删除数字来操作表，然后执行更新操作。
- en: Note
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Closing the database is important because once our job is done, we do want to
    release unused resources.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭数据库很重要，因为一旦我们的工作完成，我们确实希望释放未使用的资源。
- en: Truncating and Deleting Table
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 截断和删除表
- en: What we would like to achieve in this topic is to empty a table completely and
    get rid of it. In order to empty the table, we could simply formulate `DELETE`
    statements that match every record in our table and thus remove every single record
    from our table. However, there is a more elegant way. We can use the `TRUNCATE
    TABLE` SQL statement. The result of this statement is a literally empty table.
    We can use the `Exec()` function from our `sql` package. You already know how
    to initialize the package with imports. You also know how to connect to the database.
    This time, we only focus on the statements.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本主题中想要实现的是完全清空一个表并删除它。为了清空表，我们可以简单地编写匹配我们表中每条记录的 `DELETE` 语句，从而从表中删除每一条记录。然而，还有一种更优雅的方法。我们可以使用
    `TRUNCATE TABLE` SQL 语句。这个语句的结果是一个字面上为空的表。我们可以使用 `sql` 包中的 `Exec()` 函数。你已经知道如何通过导入来初始化包。你也知道如何连接到数据库。这次，我们只关注语句。
- en: 'The following statement will achieve a full `TRUNCATE`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句将实现完全的 `TRUNCATE`：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The result of this is an empty table called `test`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这样结果是名为 `test` 的空表。
- en: In order to get rid of the table completely, we should modify our statement
    as follows.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全删除表，我们应该将我们的语句修改如下。
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If we inspect our database engine, we will not find any trace of the table called
    `test`. This eradicated the whole table from the very face of the database.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查我们的数据库引擎，我们将找不到名为 `test` 的表的任何痕迹。这从数据库的表面彻底消除了整个表。
- en: That topic was all about interacting with databases via the Go programming language.
    Now you have a decent understanding about how to get started.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 那个主题完全是关于通过 Go 编程语言与数据库交互。现在你对如何入门有了相当的了解。
- en: Note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For further information and extra details, you should check out the official
    documentation of the SQL API, [https://packt.live/2Pi5oj5](https://packt.live/2Pi5oj5).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更多信息及额外细节，你应该查看 SQL API 的官方文档，[https://packt.live/2Pi5oj5](https://packt.live/2Pi5oj5)。
- en: 'Activity 13.01: Holding User Data in a Table'
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十三.01：在表中存储用户数据
- en: In this activity, we are going to create a table that is going to hold user
    information such as `ID`, `Name`, and `Email`. We build on the knowledge you gathered
    in the *Creating Tables* and *Inserting Data* sections.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将创建一个表，该表将存储用户信息，如 `ID`、`Name` 和 `Email`。我们基于你在 *创建表* 和 *插入数据* 部分获得的知识。
- en: 'Follow these steps to complete this activity:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此活动：
- en: 'Create a small script that will create a table called `Users`. This table must
    have three columns: `ID`, `Name`, and `Email`.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个小脚本，用于创建一个名为 `Users` 的表。这个表必须有三个列：`ID`、`Name` 和 `Email`。
- en: Add the details of two users with their data into the table. They should have
    unique names, IDs, and email addresses.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两位用户及其数据详情添加到表中。他们应该有独特的名字、ID 和电子邮件地址。
- en: Then you need to update the email of the first user to user@packt.com and remove
    the second user. Make sure that none of the fields are `NULL`, and the ID is the
    primary key, so it needs to be unique.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后你需要更新第一个用户的电子邮件地址为 user@packt.com 并删除第二个用户。确保所有字段都不是 `NULL`，ID 是主键，因此需要是唯一的。
- en: When you are inserting, updating, and deleting from the table, please use the
    `Prepare()` function to protect against SQL injection attacks.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在表中插入、更新和删除数据时，请使用 `Prepare()` 函数来防止 SQL 注入攻击。
- en: You should use a struct to store the user information you would like to insert,
    and when you are inserting, iterate over the struct with a `for` loop.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该使用一个结构体来存储你想要插入的用户信息，并且在插入时，使用 `for` 循环遍历结构体。
- en: Once the `insert`, `update`, and `delete` calls are complete, make sure you
    use `Close()` when appropriate and finally close the connection to the database.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 `insert`、`update` 和 `delete` 调用完成，确保在适当的时候使用 `Close()`，并最终关闭数据库连接。
- en: 'Upon successful completion, you should see the following output:'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 成功完成后，你应该会看到以下输出：
- en: '![Figure 13.8: Possible output'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.8：可能的输出'
- en: '](img/B14177_13_08.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.8：可能的输出'
- en: 'Figure 13.8: Possible output'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8：可能的输出
- en: Note
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 745.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 745 页找到。
- en: By the end of this activity, you should have learned how to create a new table
    called `users` and how to insert data into this table.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在本活动的结束时，你应该已经学会了如何创建一个名为 `users` 的新表以及如何向该表中插入数据。
- en: 'Activity 13.02: Finding Messages of Specific Users'
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动十三.02：查找特定用户的消息
- en: 'In this activity, we will build on *Activity 13.01*: *Holding User Data in
    a Table*.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们将基于 *活动 13.01*：*在表中存储用户数据* 进行扩展。
- en: 'We need to create a new table called `Messages`. This table will have two columns,
    both of which should have a 280-character limit: one is `UserID` and the other
    is `Message`.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: When your table is ready, you should add some messages with user IDs. Make sure
    you add `UserID`, which is not present in the `users` table.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Once you have added the data, write a query that returns all the messages a
    specified user has sent. Use the `Prepare()` function to protect against SQL injection.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'If the specified user cannot be found, print `The query returned nothing, no
    such user: <username>`. You should take the username as input from the keyboard.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform these steps in order to complete the activity:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Define a `struct` that holds the `userID` and the messages.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Messages should be inserted with a `for` loop that iterates over the previously
    defined `struct`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user input is received, make sure you use the `Prepare()` statement
    to craft your query.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If everything went well, this should be the output, depending on how you fill
    your database with usernames and messages:'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.9: Expected output'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_13_09.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.9: Expected output'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 748.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can tweak the script to not try and recreate the DB on consecutive
    runs.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this activity, you should have learned how to create a new table
    called `Messages`, then take input from the user and search for related users
    and messages based on the input.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter made you efficient in interacting with SQL databases. You learned
    how to create, delete, and manipulate database tables. You have also become aware
    of all the different types of databases Go is suited to interact with. As this
    chapter was made with the `PostgreSQL` engine in mind, you should familiarize
    yourself with its Go module too. With this knowledge, you will now be able to
    take your own steps in the realm of database programming with the Go language
    and be self-sufficient in the sense that you know where to look for solutions
    to problems and for extra knowledge. The most common use case for this knowledge
    is when you must build automated reporting apps that pull data from a database
    and report it as an email. The other use case is when you have an automated app
    for pushing data to the database server that processes a CSV file or an XML file.
    This really depends on the situation you are in.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to interact with web interfaces via
    HTTP clients, which is one of the most interesting topics in Go.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
