<html><head></head><body>
		<div>
			<div id="_idContainer236" class="Content">
			</div>
		</div>
		<div id="_idContainer237" class="Content">
			<h1 id="_idParaDest-324"><a id="_idTextAnchor343"/>14. Using the Go HTTP Client</h1>
		</div>
		<div id="_idContainer247" class="Content">
			<p class="callout-heading"><a id="_idTextAnchor344"/>Overview</p>
			<p class="callout">This chapter will equip you to use the Go HTTP client to talk to other systems over the internet.</p>
			<p class="callout">You will start by learning to use the HTTP client to get data from a web server and to send data to a web server. By the end of the chapter, you will be able to upload a file to a web server and experiment with a custom Go HTTP client to interact with web servers.</p>
			<h1 id="_idParaDest-325"><a id="_idTextAnchor345"/>Introduction</h1>
			<p>In the previous chapter, you looked at SQL and databases. You learned how to execute queries, how to create tables, how to insert data into tables and fetch data, how to update data, and how to delete data within a table.</p>
			<p>In this chapter, you will learn about the Go HTTP client and how to use it. An HTTP client is something that is used to get data from or send data to a web server. Probably the most well-known example of an HTTP client is a web browser (such as Firefox). When you enter a web address into a web browser, it will have an HTTP client built in that sends a request to the server for data. The server will gather the data and send it back to the HTTP client, which will then display the web page in the browser. Similarly, when you fill out a form in a web browser, for example, when you log in to a website, the browser will use its HTTP client to send that form data to the server and then take appropriate action depending on the response.</p>
			<p>This chapter looks at how you can use the Go HTTP client to request data from a web server and send data to a server. You will examine the different ways you can use the HTTP client to interact with a web server and the various use cases for those interactions. The web browser example will be useful in explaining the different interactions. As part of this chapter, you will create your own Go programs that make use of the Go HTTP client to send and receive data from a web server.</p>
			<h1 id="_idParaDest-326"><a id="_idTextAnchor346"/>The Go HTTP Client and Its Uses</h1>
			<p>The Go HTTP client is part of the Go standard library, specifically the <strong class="source-inline">net/http</strong> library. There are two main ways to use it. The first is to use the default HTTP client that is included in the <strong class="source-inline">net/http</strong> library. It's simple to use and allows you to get up and running quickly. The second way is to create your own HTTP client based on the default HTTP client. This allows you to customize the requests and various other things. It takes longer to configure, but it gives you much more freedom and control over the requests you send.</p>
			<p>When using an HTTP client, you can send different types of requests. While there are many types of requests, we will discuss the two main ones, the GET request and the POST request. For instance, if you wanted to retrieve data from a server, you would send a GET request. When you enter a web address in your web browser, it will send a GET request to the server at that address and then display the data it returns. If you wanted to send data to the server, you would send a POST request. If you wanted to log into a website, you would POST your login details to the server.</p>
			<p>In this chapter, there are a few exercises to teach you about the Go HTTP client. They will teach you how to request data from a server in various formats using GET requests. They will also teach you how to POST form data to a web server, similar to how a web browser would send a POST request when you log in to a website. These exercises will also show you how to upload a file to a web server and how to use a customized HTTP client to have more control over the requests you send.</p>
			<h1 id="_idParaDest-327"><a id="_idTextAnchor347"/>Sending a Request to a Server</h1>
			<p>When you want to retrieve data from a web server, you send a GET request to the server. When sending a request, the URL will contain the information on the resource you want data from. The URL can be broken down into a few key parts. These include the protocol, the hostname, the URI, and the query parameters. The format of it looks like this:</p>
			<div>
				<div id="_idContainer238" class="IMG---Figure">
					<img src="image/B14177_14_01.jpg" alt="Figure 14.1: URL format breakdown&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.1: URL format breakdown</p>
			<p>In this example:</p>
			<ul>
				<li>The <strong class="source-inline">Protocol</strong> tells the client how to connect to the server. The two most common protocols are HTTP and HTTPS. In this example, we have used <strong class="source-inline">https</strong>.</li>
				<li>The <strong class="source-inline">Hostname</strong> is the address of the server we want to connect to. In this example, it is <strong class="source-inline">example.com</strong>.</li>
				<li>The <strong class="source-inline">URI</strong> is the <strong class="bold">Uniform Resource Identifier</strong> (<strong class="bold">URI</strong>), and this tells the server the path to the resource we want. In this example, it is <strong class="source-inline">/downloads</strong>.</li>
				<li>The <strong class="source-inline">Query Parameters</strong> tell the server of any additional information it needs. In this example, we have two parameters. These are <strong class="source-inline">filter=latest</strong> and <strong class="source-inline">os=windows</strong>. You will notice they are separated from the URI by <strong class="source-inline">?</strong>. This is so the server can parse them from the request. We join any additional parameters to the end of the URI with the <strong class="source-inline">&amp;</strong> symbol, as seen with the <strong class="source-inline">os</strong> parameter.</li>
			</ul>
			<h2 id="_idParaDest-328">E<a id="_idTextAnchor348"/>xercise 14.01: Sending a Get Request to a Web Server Using the Go HTTP Client</h2>
			<p>In this exercise, you will be getting data from a web server and printing out that data. You will send a GET request to <a href="https://www.google.com">https://www.google.com</a> and display the data the web server returns:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For this topic, you will need to have Go installed and GOPATH set up on your system. You will also need an IDE that you can use to edit <strong class="source-inline">.go</strong> files.</p>
			<ol>
				<li>Open your IDE and create a new directory, <strong class="source-inline">Exercise14.01</strong>, on your GOPATH. Within that directory, create a new Go file called <strong class="source-inline">main.go</strong>.</li>
				<li>As this is a new program, you will want to set the package of the file to the <strong class="source-inline">main() </strong>function. Import the <strong class="source-inline">net/http</strong> library, the <strong class="source-inline">log</strong> library, and the <strong class="source-inline">io/ioutil</strong> library. Type the following code:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">    "io/ioutil"</p><p class="source-code">    "log"</p><p class="source-code">    "net/http"</p><p class="source-code">)<a id="_idTextAnchor349"/></p><p>Now that you have the package set up and the imports you need, you can start creating a function to get data from a web server. The function you are going to create will request data from a web server.</p></li>
				<li>Create a function that returns a string:<p class="source-code">func getDataAndReturnResponse() string {</p></li>
				<li>W<a id="_idTextAnchor350"/>ithin that function, you can then use the default Go HTTP Client to request data from a server. In this exercise, you will request data from <a href="https://www.google.com">https://www.google.com</a>. To request data from the web server, you use the <strong class="source-inline">GET</strong> function in the <strong class="source-inline">http</strong> library, which looks as follows:<p class="source-code">    r, err := http.Get("https://www.google.com")</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p></li>
				<li>The data the server sends back is contained within <strong class="source-inline">r.Body</strong>, so you just to read in that data. To read the data within <strong class="source-inline">r.Body</strong>, you can use the <strong class="source-inline">ReadAll</strong> function within the <strong class="source-inline">io/ioutil</strong> library. The two together would look like this:<p class="source-code">    defer r.Body.Close()</p><p class="source-code">    data, err := ioutil.ReadAll(r.Body)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p></li>
				<li>After you have received the response from the server and read the data, you just need to return that data as a string, which looks like this:<p class="source-code">    return string(data)</p><p class="source-code">}</p><p>T<a id="_idTextAnchor351"/>he function you have now created will now look like this:</p><p class="source-code">func getDataAndReturnResponse() string {</p><p class="source-code">    // send the GET request</p><p class="source-code">    r, err := http.Get("https://www.google.com")</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p><p class="source-code">    // get data from the response body</p><p class="source-code">    defer r.Body.Close()</p><p class="source-code">    data, err := ioutil.ReadAll(r.Body)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p><p class="source-code">    // return the response data</p><p class="source-code">    return string(data)</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">main</strong> function. Within the <strong class="source-inline">main</strong> function, call the <strong class="source-inline">getDataAndReturnResponse</strong> function and log the string it returns:<p class="source-code">func main() {</p><p class="source-code">    data := getDataAndReturnResponse()</p><p class="source-code">    log.Println(data)</p><p class="source-code">}</p></li>
				<li>To run the program, open your terminal and navigate to the directory that you created the <strong class="source-inline">main.go</strong> file in.</li>
				<li>Run <strong class="source-inline">go run main.go</strong> to compile and execute the file:<p class="source-code">go run server.go</p><p>The program will issue a GET request to <a href="https://www.google.com">https://www.google.com</a> and log the response in your terminal.</p><p>While it may look like gibberish, if you were to save that data to a file called <strong class="source-inline">response.html</strong> and open it in your web browser, it would resemble the Google home page. This is what your web browser will do under the hood when you open a web page. It will send a GET request to the server and then display the data it returns. If we do this manually, it will look as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer239" class="IMG---Figure">
					<img src="image/B14177_14_02.jpg" alt="Figure 14.2: Request HTML response when viewed in Firefox&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.2: Request HTML response when viewed in Firefox</p>
			<p>In this exercise, we saw how to send a GET request to a web server and get data back. You created a Go program that sent a request to <a href="https://www.google.com">https://www.google.com</a> and got back the HTML data for the Google home page.</p>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor352"/>Structured Data</h1>
			<p>Once you have requested data from a server, the data returned can come in various formats. For example, if you send a request to <strong class="source-inline">packtpub.com</strong>, it will return HTML data for the Packt website. While HTML data is useful for displaying websites, it isn't ideal for sending machine-readable data. A common data type used in web APIs is JSON. JSON provides a good structure for data that is both machine-readable and human-readable. Later, you will learn how to parse JSON and make use of it using Go.</p>
			<h2 id="_idParaDest-330"><a id="_idTextAnchor353"/>Exercise 14.02: Using the HTTP Client with Structured Data</h2>
			<p>In this exercise, you will parse structured JSON data in Go. The server will return JSON data and you will use the <strong class="source-inline">json.Unmarshal</strong> function to parse the data and put it into a struct:</p>
			<ol>
				<li value="1">Cr<a id="_idTextAnchor354"/>eate a new directory, <strong class="source-inline">Exercise14.02</strong>, on your GOPATH. Within that directory, create two more directories, <strong class="source-inline">server</strong> and <strong class="source-inline">client</strong>. Then, within the <strong class="source-inline">server</strong> directory, create a file called <strong class="source-inline">server.go</strong> and write the following code:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">    "log"</p><p class="source-code">    "net/http"</p><p class="source-code">)</p><p class="source-code">type server struct{}</p><p class="source-code">func (srv server) ServeHTTP(w http.ResponseWriter, r   *http.Request) {</p><p class="source-code">    msg := "{\"message\": \"hello world\"}"</p><p class="source-code">    w.Write([]byte(msg))</p><p class="source-code">}</p><p class="source-code">func main() {</p><p class="source-code">    log.Fatal(http.ListenAndServe(":8080", server{}))</p><p class="source-code">}</p><p>This creates a very basic web server that sends back JSON data. We will explain in more detail how this works in the next chapter. For now, we will just use it as an example.</p></li>
				<li>Once you have created the server, navigate to the client directory and create a file called <strong class="source-inline">main.go</strong>. Add <strong class="source-inline">package main</strong> and import the packages needed for the file:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">    "encoding/json"</p><p class="source-code">    "fmt"</p><p class="source-code">    "io/ioutil"</p><p class="source-code">    "log"</p><p class="source-code">    "net/http"</p><p class="source-code">)</p></li>
				<li>Then, create a struct with a string parameter that can accept the response from the server. Then, add JSON metadata to it so it can be used to unmarshal the JSON <strong class="source-inline">message</strong> parameter:<p class="source-code">type messageData struct {</p><p class="source-code">    Message string `json:"message"`</p><p class="source-code">}</p></li>
				<li>Next, create a function that you can call to get and parse the data from the server. Use the struct you just created as the return value:<p class="source-code">func getDataAndReturnResponse() messageData {</p><p>Wh<a id="_idTextAnchor355"/>en you run the web server, it will listen on <strong class="source-inline">http://localhost:8080</strong>. So, you need to send a GET request to that URL and then read the response body:</p><p class="source-code">    r, err := http.Get("http://localhost:8080")</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p><p class="source-code">    defer r.Body.Close()</p><p class="source-code">    data, err := ioutil.ReadAll(r.Body)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p></li>
				<li>This time, however, you will parse the response instead of simply returning it. To do that, you create an instance of the struct you created, then pass it along with the response data to <strong class="source-inline">json.Unmarshal</strong>:<p class="source-code">    message := messageData{}</p><p class="source-code">    err = json.Unmarshal(data, &amp;message)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p><p>This will populate the <strong class="source-inline">message</strong> variable with the data returned from the server.</p></li>
				<li>You then need to return the struct to complete the function:<p class="source-code">    return message</p></li>
				<li>Fi<a id="_idTextAnchor356"/>nally, call the function you just created from the <strong class="source-inline">main()</strong> function and log the message from the server:<p class="source-code">func main() {</p><p class="source-code">    data := getDataAndReturnResponse()</p><p class="source-code">    fmt.Println(data.Message)</p><p class="source-code">}</p></li>
				<li>To run this, you need to do two steps. The first is navigate to the <strong class="source-inline">server</strong> directory in your terminal and run the following command. This will start the web server:<p class="source-code">go run server.go</p></li>
				<li>In a second terminal window, navigate to the <strong class="source-inline">client</strong> directory and run <strong class="source-inline">go run main.go</strong>. This will start the client and connect to the server. It should output the message from the server:</li>
			</ol>
			<div>
				<div id="_idContainer240" class="IMG---Figure">
					<img src="image/B14177_14_03.jpg" alt="Figure 14.3: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.3: Expected output</p>
			<p>In this exercise, you sent a GET request to the server and got back structured data in JSON format. You then parsed that JSON data to get the message from it.</p>
			<h2 id="_idParaDest-331">Act<a id="_idTextAnchor357"/>ivity 14.01: Requesting Data from a Web Server and Processing the Response</h2>
			<p>Imagine you are interacting with a web API. You send a GET request for data and get back an array of names. You need to count those names to find out how many of each you have. In this activity, you will do just that. You will send a GET request to the server, get back structured JSON data, parse the data, and count how many of each name you got back in the response:</p>
			<ol>
				<li value="1">Create a directory called <strong class="source-inline">Activity14.01</strong>.</li>
				<li>Create two sub-directories, one called <strong class="source-inline">client</strong> and another called <strong class="source-inline">server</strong>.</li>
				<li>In the <strong class="source-inline">server</strong> directory, create a file called <strong class="source-inline">server.go</strong>.</li>
				<li>Add the server code in <strong class="source-inline">server.go</strong>.</li>
				<li>Start the server by calling <strong class="source-inline">go run server.go</strong> in the server directory.</li>
				<li>In the <strong class="source-inline">client</strong> directory, create a file called <strong class="source-inline">main.go</strong>.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the necessary imports.</li>
				<li>Create structs to parse the response data.</li>
				<li>Create a function called <strong class="source-inline">getDataAndParseResponse</strong> that returns two integers.</li>
				<li>Send a <strong class="source-inline">GET </strong>request to the server.</li>
				<li>Parse the response into a struct.</li>
				<li>Loop through the struct and count the occurrences of the names <strong class="source-inline">Electric</strong> and <strong class="source-inline">Boogaloo</strong>.</li>
				<li>Return the counts.</li>
				<li>Print the counts.<p>The expected output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer241" class="IMG---Figure">
					<img src="image/B14177_14_04.jpg" alt="Figure 14.4: Possible output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.4: Possible output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 752.</p>
			<p>In this activity, we have requested data from a web server and processed the data it returned using the Go HTTP client.</p>
			<h1 id="_idParaDest-332"><a id="_idTextAnchor358"/>Sending Data to a Server</h1>
			<p>In addition to requesting data from a server, you will also want to send data to a server. The most common way of doing this is via a POST request. A POST request comes in two main parts: the URL and the body. The body of a POST request is where you put the data you want to send to the server. A common example of this is a login form. When we send a login request, we POST the body to the URL. The web server then checks that the login details within the body are correct and updates our login status. It responds to the request by telling the client whether it succeeded or not. In this chapter, you will learn how to send data to a server using a POST request.</p>
			<h2 id="_idParaDest-333"><a id="_idTextAnchor359"/>Exercise 14.03: Sending a Post Request to a Web Server Using the Go HTTP Client</h2>
			<p>In this exercise, you will send a POST request to a web server containing a message. The web server will then respond with the same message so you can confirm that it received it:</p>
			<ol>
				<li value="1">Create a new directory, <strong class="source-inline">Exercise14.03</strong>, on your GOPATH. Within that directory, create two more directories, <strong class="source-inline">server</strong> and <strong class="source-inline">client</strong>. Then, within the <strong class="source-inline">server</strong> directory, create a file called <strong class="source-inline">server.go</strong> and write the following code:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">    "encoding/json"</p><p class="source-code">    "log"</p><p class="source-code">    "net/http"</p><p class="source-code">)</p><p class="source-code">type server struct{}</p><p class="source-code">type messageData struct {</p><p class="source-code">    Message string `json:"message"`</p><p class="source-code">}</p><p class="source-code">func (srv server) ServeHTTP(w http.ResponseWriter, r   *http.Request) {</p><p class="source-code">    jsonDecoder := json.NewDecoder(r.Body)</p><p class="source-code">    messageData := messageData{}</p><p class="source-code">    err := jsonDecoder.Decode(&amp;messageData)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p><p class="source-code">    jsonBytes, _ := json.Marshal(messageData)</p><p class="source-code">    log.Println(string(jsonBytes))</p><p class="source-code">    w.Write(jsonBytes)</p><p class="source-code">}</p><p class="source-code">func main() {</p><p class="source-code">    log.Fatal(http.ListenAndServe(":8080", server{}))</p><p class="source-code">}</p><p>This creates a very basic web server that receives a JSON POST request and returns the message sent to it back to the client.</p></li>
				<li>Once you have the server created. Navigate to the client directory and create a file called <strong class="source-inline">main.go</strong>. Add <strong class="source-inline">package main</strong> and the imports needed for the file:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">    "bytes"</p><p class="source-code">    "encoding/json"</p><p class="source-code">    "fmt"</p><p class="source-code">    "io/ioutil"</p><p class="source-code">    "log"</p><p class="source-code">    "net/http"</p><p class="source-code">)</p></li>
				<li>Next, you need to create a struct for the data we want to send and receive. This will be the same as the struct used by the server to parse the request:<p class="source-code">type messageData struct {</p><p class="source-code">    Message string `json:"message"`</p><p class="source-code">}</p></li>
				<li>You then need to create the function to POST the data to the server. It should accept a <strong class="source-inline">messageData</strong> struct parameter as well as return a <strong class="source-inline">messageData</strong> struct:<p class="source-code">func postDataAndReturnResponse(msg messageData) messageData {</p></li>
				<li>To P<a id="_idTextAnchor360"/>OST the data to the server, you need to marshal the struct into bytes that the client can send to the server. To do this, you can use the <strong class="source-inline">json.Marshal</strong> function:<p class="source-code">    jsonBytes, _ := json.Marshal(msg)</p></li>
				<li>Now <a id="_idTextAnchor361"/>that you have the bytes, you can use the <strong class="source-inline">http.Post</strong> function to send the POST request. Within the request, you just need to tell the function what URL to post to, what kind of data you are sending, and the data you want to send. In this case, the URL is <strong class="source-inline">http://localhost:8080</strong>. The content you are sending is <strong class="source-inline">application/json</strong> and the data is the <strong class="source-inline">jsonBytes</strong> variable you just created. Together, it looks like this:<p class="source-code">    r, err := http.Post("http://localhost:8080", "application/json", bytes.NewBuffer(jsonBytes))</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p></li>
				<li>After that, the rest of the function is the same as in the previous exercise. You read the response, parse out the data, and then return the data, which looks like this:<p class="source-code">    defer r.Body.Close()</p><p class="source-code">    data, err := ioutil.ReadAll(r.Body)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p><p class="source-code">    message := messageData{}</p><p class="source-code">    err = json.Unmarshal(data, &amp;message)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p><p class="source-code">    return message</p></li>
				<li>Then, you just need to call the <strong class="source-inline">postDataAndReturnResponse</strong> function from your <strong class="source-inline">main</strong> function. This time, however, you need to pass the message you want to send to the function. You just need to create an instance of the <strong class="source-inline">messageData</strong> struct and pass that to the function when you call it, which looks like this:<p class="source-code">func main() {</p><p class="source-code">    msg := messageData{Message: "Hi Server!"}</p><p class="source-code">    data := postDataAndReturnResponse(msg)</p><p class="source-code">    fmt.Println(data.Message)</p><p class="source-code">}</p></li>
				<li>To r<a id="_idTextAnchor362"/>un this exercise, you need to carry out two steps. The first is to navigate to the <strong class="source-inline">server</strong> directory in your terminal and run <strong class="source-inline">go run server.go</strong>. This will start the web server. In a second terminal window, navigate to the <strong class="source-inline">client</strong> directory and run <strong class="source-inline">go run main.go</strong>. This will start the client and connect to the server. It should output the message from the server:</li>
			</ol>
			<div>
				<div id="_idContainer242" class="IMG---Figure">
					<img src="image/B14177_14_05.jpg" alt="Figure 14.5: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.5: Expected output</p>
			<p>In this exercise, you sent a POST request to the server. The server parsed the request and sent the same message back to you. If you change the message sent to the server, you should see the response from the server sending back the new message.</p>
			<h2 id="_idParaDest-334">Uploa<a id="_idTextAnchor363"/>ding Files in a Post Request</h2>
			<p>Another common example of data you might want to POST to a web server is a file from your local computer. This is how websites allow users to upload their photos and so on. As you can imagine, this is a little more complex than sending simple form data. To achieve this, the file needs to be read first, then wrapped in a format that the server can understand. It can then be sent in a POST request to the server in what's called a multipart form. You will learn how to read in a file and upload it to a server using Go.</p>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor364"/>Exercise 14.04: Uploading a File to a Web Server via a Post Request</h2>
			<p>In this exercise, you will read in a local file and then upload it to a web server. You can then check that the web server saved the file you uploaded:</p>
			<ol>
				<li value="1">Create a new directory, <strong class="source-inline">Exercise14.04</strong>, on your GOPATH. Within that directory, create two more directories, <strong class="source-inline">server</strong> and <strong class="source-inline">client</strong>. Then, within the <strong class="source-inline">server</strong> directory, create a file called <strong class="source-inline">server.go</strong> and write the following code:<p class="source-code-heading">server.go</p><p class="source-code">9  func (srv server) ServeHTTP(w http.ResponseWriter, r      *http.Request) {</p><p class="source-code">10     uploadedFile, uploadedFileHeader, err :=          r.FormFile("myFile")</p><p class="source-code">11     if err != nil {</p><p class="source-code">12         log.Fatal(err)</p><p class="source-code">13     }</p><p class="source-code">14     defer uploadedFile.Close()</p><p class="source-code">15     fileContent, err := ioutil.ReadAll(uploadedFile)</p><p class="source-code">16     if err != nil {</p><p class="source-code">17         log.Fatal(err)</p><p class="source-code">18     }</p><p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/2SkeZHW">https://packt.live/2SkeZHW</a></p><p>This creates a very basic web server that receives a multipart form POST request and saves the file within the form.</p></li>
				<li>Once you have created the server, navigate to the client directory and create a file called <strong class="source-inline">main.go</strong>. Add <strong class="source-inline">package main</strong> and the imports needed for the file:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">    "bytes"</p><p class="source-code">    "fmt"</p><p class="source-code">    "io"</p><p class="source-code">    "io/ioutil"</p><p class="source-code">    "log"</p><p class="source-code">    "mime/multipart"</p><p class="source-code">    "net/http"</p><p class="source-code">    "os"</p><p class="source-code">)</p></li>
				<li>You then need to create a function to call that you will give a filename to. The function will read in the file, upload it to the server, and return the server's response:<p class="source-code">func postFileAndReturnResponse(filename string) string {</p></li>
				<li>You n<a id="_idTextAnchor365"/>eed to create a buffer that you can write the file bytes to, then create a writer to allow bytes to write into it:<p class="source-code">    fileDataBuffer := bytes.Buffer{}</p><p class="source-code">    multipartWritter := multipart.NewWriter(&amp;fileDataBuffer)</p></li>
				<li>Open the file from your local computer using the following command:<p class="source-code">    file, err := os.Open(filename)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p></li>
				<li>Once you have opened the local file, you need to create a <strong class="source-inline">formFile</strong>. This wraps the file data in the right format to upload it to the server:<p class="source-code">    formFile, err := multipartWritter.CreateFormFile("myFile",       file.Name())</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p></li>
				<li>Copy the bytes from the local file into the form file, then close the form file writer so that it knows no more data will be added:<p class="source-code">    _, err = io.Copy(formFile, file)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p><p class="source-code">    multipartWritter.Close()</p></li>
				<li>Next, you need to create the POST request you want to send to the server. In the previous exercises, we used shortcut functions such as <strong class="source-inline">http.Post</strong>. However, in this exercise, we need more control over the data being sent. That means we'll need to create an <strong class="source-inline">http.Request</strong>. In this case, you're creating a POST request that you will send to <strong class="source-inline">http://localhost:8080</strong>. As we are uploading a file, the bytes buffer also needs to be included in the request. That looks as follows:<p class="source-code">    req, err := http.NewRequest("POST",       "http://localhost:8080", &amp;fileDataBuffer)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p></li>
				<li>You then need to set the <strong class="source-inline">Content-Type</strong> request header. This tells the server about the content of the file, so it knows how to handle the upload:<p class="source-code">    req.Header.Set("Content-Type",       multipartWritter.FormDataContentType())</p></li>
				<li>Send the request as follows:<p class="source-code">    response, err := http.DefaultClient.Do(req)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p></li>
				<li>After you have sent the request, we can read in the response and return the data within it:<p class="source-code">    defer response.Body.Close()</p><p class="source-code">    data, err := ioutil.ReadAll(response.Body)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p><p class="source-code">    return string(data)</p></li>
				<li>Finally, you just need to call the <strong class="source-inline">postFileAndReturnResponse</strong> function and tell it what file to upload:<p class="source-code">func main() {</p><p class="source-code">    data := postFileAndReturnResponse("./test.txt")</p><p class="source-code">    fmt.Println(data)</p><p class="source-code">}</p></li>
				<li>To ru<a id="_idTextAnchor366"/>n this, you need to carry out two steps. The first is to navigate to the <strong class="source-inline">server</strong> directory in your terminal and run <strong class="source-inline">go run server.go</strong>. This will start the web server:<p class="source-code">go run server.go</p></li>
				<li>Next, in the <strong class="source-inline">client</strong> directory, create a file named <strong class="source-inline">test.txt</strong> and put a few lines of text in it.</li>
				<li>In a second terminal window, navigate to the <strong class="source-inline">client</strong> directory and run <strong class="source-inline">go run main.go</strong>. This will start the client and connect to the server:<p class="source-code">go run server.go</p></li>
				<li>The client will then read in <strong class="source-inline">test.txt</strong> and upload it to the server. The client should give the following output:</li>
			</ol>
			<div>
				<div id="_idContainer243" class="IMG---Figure">
					<img src="image/B14177_14_06.jpg" alt="Figure 14.6: Expected client output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.6: Expected client output</p>
			<p>Then, if you navigate to the <strong class="source-inline">server</strong> directory, you should see that the <strong class="source-inline">test.txt</strong> file has now appeared:</p>
			<div>
				<div id="_idContainer244" class="IMG---Figure">
					<img src="image/B14177_14_07.jpg" alt="Figure 14.7: Expected client output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.7: Expected client output</p>
			<p>In thi<a id="_idTextAnchor367"/>s exercise, you sent a file to a web server using the Go HTTP client. You read in a file from disk, formatted it into a POST request, and sent the data to the server.</p>
			<h2 id="_idParaDest-336">Custom <a id="_idTextAnchor368"/>Request Headers</h2>
			<p>Sometimes there is more to a request than simply requesting or sending data. This information is stored within the request headers. A very common example of this is authorization headers. When you log into a server, it will respond with an authorization token. In all future requests sent to the server, you would include this token in the request's headers so the server knows you are the one making the requests. You will learn how to add an authorization token to requests later.</p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor369"/>Exercise 14.05: Using Custom Headers and Options with the Go HTTP Client</h2>
			<p>In this exercise, you will create your own HTTP client and set custom options on it. You will also set an authorization token in the request headers, so the server knows it is you requesting the data:</p>
			<ol>
				<li value="1">Create <a id="_idTextAnchor370"/>a new directory, <strong class="source-inline">Exercise14.05</strong>, on your GOPATH. Within that directory, create two more directories, <strong class="source-inline">server</strong> and <strong class="source-inline">client</strong>. Then, within the <strong class="source-inline">server</strong> directory, create a file called <strong class="source-inline">server.go</strong> and write the following code:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">    "log"</p><p class="source-code">    "net/http"</p><p class="source-code">    "time"</p><p class="source-code">)</p><p class="source-code">type server struct{}</p><p class="source-code">func (srv server) ServeHTTP(w http.ResponseWriter, r   *http.Request) {</p><p class="source-code">    auth := r.Header.Get("Authorization")</p><p class="source-code">    if auth != "superSecretToken" {</p><p class="source-code">        w.WriteHeader(http.StatusUnauthorized)</p><p class="source-code">        w.Write([]byte("Authorization token not recognized"))</p><p class="source-code">        return</p><p class="source-code">    }</p><p class="source-code">    time.Sleep(10 * time.Second)</p><p class="source-code">    msg := "hello client!"</p><p class="source-code">    w.Write([]byte(msg))</p><p class="source-code">}</p><p class="source-code">func main() {</p><p class="source-code">    log.Fatal(http.ListenAndServe(":8080", server{}))</p><p class="source-code">}</p><p>This creates a very basic web server that receives a request, checks the authorization header is correct, waits 10 seconds, then sends back data.</p></li>
				<li>Once you have created the server, navigate to the client directory and create a file called <strong class="source-inline">main.go</strong>. Add <strong class="source-inline">package main</strong> and the imports needed for the file:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">    "fmt"</p><p class="source-code">    "io/ioutil"</p><p class="source-code">    "log"</p><p class="source-code">    "net/http"</p><p class="source-code">    "time"</p><p class="source-code">)</p></li>
				<li>Then, you need to create a function that will create an HTTP client, set the timeout limitations, and set the authorization header:<p class="source-code">func getDataWithCustomOptionsAndReturnResponse() string {</p></li>
				<li>You nee<a id="_idTextAnchor371"/>d to create your own HTTP client and set the timeout to 11 seconds:<p class="source-code">    client := http.Client{Timeout: 11 * time.Second}</p></li>
				<li>You al<a id="_idTextAnchor372"/>so need to create a request to send it to the server. You should create a GET request with the URL <strong class="source-inline">http://localhost:8080</strong>. No data will be sent in this request, so the data can be set to nil. You can use the <strong class="source-inline">http.NewRequest</strong> function to do this:<p class="source-code">    req, err := http.NewRequest("POST",       "http://localhost:8080", nil)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p></li>
				<li>If you look at the server code again, you will notice that it checks for the <strong class="source-inline">Authorization</strong> request header and it expects its value to be <strong class="source-inline">superSecretToken</strong>. So, you need to set the <strong class="source-inline">Authorization</strong> header in your request as well:<p class="source-code">    req.Header.Set("Authorization", "superSecretToken")</p></li>
				<li>You th<a id="_idTextAnchor373"/>en get the client you created to do the request:<p class="source-code">    resp, err := client.Do(req)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p></li>
				<li>Then, you need to read in the response from the server and return the data:<p class="source-code">    defer resp.Body.Close()</p><p class="source-code">    data, err := ioutil.ReadAll(resp.Body)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p><p class="source-code">    return string(data)</p></li>
				<li>Finally, you need to call the function you just created from the <strong class="source-inline">main</strong> function and log the data it returns:<p class="source-code">func main() {</p><p class="source-code">    data := getDataWithCustomOptionsAndReturnResponse()</p><p class="source-code">    fmt.Println(data)</p><p class="source-code">}</p></li>
				<li>To run this exercise, you need to carry out two steps. The first is navigate to the <strong class="source-inline">server</strong> directory in your terminal and run <strong class="source-inline">go run server.go</strong>. This will start the web server.</li>
				<li>In a second terminal window, navigate to the directory you created the <strong class="source-inline">client</strong> in.</li>
				<li>To execute the client, run the following command:<p class="source-code">go run main.go</p><p>This will start the client and connect to the server. The client will send the request to the server and after 10 seconds it should output the following:</p><div id="_idContainer245" class="IMG---Figure"><img src="image/B14177_14_08.jpg" alt="Figure 14.8: Expected output&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 14.8: Expected output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Change the timeout settings in the client to be under 10 seconds and see what happens. You can also change or remove the authorization header on the request and see what happens.</p>
			<p>In this exercise, you learned how to add custom headers to a request. You learned about the common example of adding an authorization header, which is required by many APIs when you want to interact with them.</p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor374"/>Activity 14.02: Sending Data to a Web Server and Checking Whether the Data Was Received Using POST and GET</h2>
			<p>Imagine you are interacting with a web API and you wish to send data to a web server. You then want to check whether the data was added. In this activity, you will do just that. You will send a POST request to the server, then request the data back using a GET request, parse the data, and print it out.</p>
			<p>Follow these steps to get the desired outcome:</p>
			<ol>
				<li value="1">Create a directory called <strong class="source-inline">Activity14.02</strong>.</li>
				<li>Create two sub-directories, one called <strong class="source-inline">client</strong> and one called <strong class="source-inline">server</strong>.</li>
				<li>In the <strong class="source-inline">server</strong> directory, create a file called <strong class="source-inline">server.go</strong>.</li>
				<li>Add the server code to the <strong class="source-inline">server.go</strong> file.</li>
				<li>Start the server by calling <strong class="source-inline">go run server.go</strong> in the server directory.</li>
				<li>In the <strong class="source-inline">client</strong> directory, create a file called <strong class="source-inline">main.go</strong>.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the necessary imports.</li>
				<li>Create structs to host the request data.</li>
				<li>Create structs to parse the response data.</li>
				<li>Create an <strong class="source-inline">addNameAndParseResponse</strong> function that posts a name to the server.</li>
				<li>Create a <strong class="source-inline">getDataAndParseResponse</strong> function that parses the server response.</li>
				<li>Send a POST request to the server, to add names.</li>
				<li>Send a GET request to the server.</li>
				<li>Parse the response into a struct.</li>
				<li>Loop through the struct and print the names.<p>This is the expected output:</p></li>
			</ol>
			<div>
				<div id="_idContainer246" class="IMG---Figure">
					<img src="image/B14177_14_09.jpg" alt="Figure 14.9: Possible output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.9: Possible output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 754.</p>
			<p>In this activity, you saw how to send data to a web server using a POST request and then how to request data from the server to ensure it was updated using a GET request. Interacting with a server in this way is very common when programming professionally.</p>
			<h1 id="_idParaDest-339"><a id="_idTextAnchor375"/>Summary</h1>
			<p><a id="_idTextAnchor376"/><a id="_idTextAnchor377"/>HTTP clients are used to interact with web servers. They are used to send different types of requests to a server (for example, GET or POST requests) and then react to the response returned by the server. A web browser is a type of HTTP client that will send a GET request to a web server and display the HTML data it returns. In Go, you created your own HTTP client and did the same thing, sending a GET request to <a href="https://www.google.com">https://www.google.com</a> and then logging the response returned by the server. You also learned about the components of a URL and that you can control what you request from a server by changing the URL.</p>
			<p>There is also more to web servers than simply requesting HTML data. You learned that they can return structured data in the form of JSON, which can be parsed and used in your code. Data can also be sent to a server using POST requests, allowing you to send form data to a server. However, the data sent to a server isn't limited to just form data: you can also upload files to a server using a POST request.</p>
			<p>There are also ways to customize the requests you send. You learned about the common example of authorization, where you add a token to the header of HTTP requests so that a server can tell who is making that request.</p>
			<p>In this chapter, you used some basic web servers in the exercises. However, you didn't learn about the details of what they were doing. In the next chapter, you will learn about web servers in more detail.</p>
		</div>
	</body></html>