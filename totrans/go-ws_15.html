<html><head></head><body>
		<div>
			<div id="_idContainer248" class="Content">
			</div>
		</div>
		<div id="_idContainer249" class="Content">
			<h1 id="_idParaDest-340"><a id="_idTextAnchor378"/>15. HTTP Servers</h1>
		</div>
		<div id="_idContainer288" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces you to different ways of creating an HTTP server in order to accept requests from the internet. You will be able to understand how a website can be accessed and how it can respond to a form. You will also learn how to respond to requests from another software program.</p>
			<p class="callout">You'll be able to create an HTTP server rendering a simple message. You will learn how to create an HTTP server rendering complex data structures which serves local static files. Further you will create an HTTP server rendering dynamic pages and work with different ways of routing. By the end of this chapter you will also learn to create a REST service, accept data through a form, and accept JSON data.</p>
			<h1 id="_idParaDest-341"><a id="_idTextAnchor379"/>Introduction</h1>
			<p>In the previous chapter, we saw how to contact a remote server in order to obtain some information, but now we will dig into how the remote server is created, so if you already know how to request information, now you will see how to reply to these requests.</p>
			<p>A web server is a program that uses the HTTP protocol, hence, the HTTP server, to accept requests from any HTTP client (web browser, another program, and so on) and respond to them with an appropriate message. When we browse the internet with our browser, it will be an HTTP server that will send an HTML page to our browser and we will be able to see it. In some other cases, a server will not return an HTML page but a different message, appropriate to the client.</p>
			<p>Some HTTP servers provide an API that can be consumed by another program. Think of when you want to register with a website, and you are asked if you want to sign up through Facebook or Google. This means that the website you want to register with will consume a Google or Facebook API to get your details. These APIs generally respond with a structured text, which is a text representing a complex data structure. The way these servers expect the requests can be different. Some expect the same type of structured messages they return, while some provide what is called a REST API, which is quite strict with the HTTP methods used and expects inputs in the form of URL parameters or values, like the ones in a web form.</p>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor380"/>How to Build a Basic Server</h1>
			<p>The simplest HTTP server that we can create is a Hello World server. This is a server that will return a simple message "Hello World" and will not do anything else. It is not very useful, but it is a starting point to see what Go default packages give us and is the basis for any other more complex server. The aim is to have a server that runs on a specific port on your machine's localhost and accepts any path under it. Accepting any path means that when you test the server with your browser, it will always return the "Hello World" message and a status code of 200. Of course, we could return any other message, but, for historical reasons, the simplest project you learn when you study programming is always some sort of software returning the message "Hello World". In this case, we will see how this can be done and then visualized in a normal browser, before perhaps being put on the internet and shared with billions of users, although users may, in practice, prefer a more useful server. Let's say this is the most basic HTTP server you can create.</p>
			<h1 id="_idParaDest-343"><a id="_idTextAnchor381"/>HTTP Handler</h1>
			<p>In order to react to an HTTP request, we need to write something that, we usually say, handles the request; hence, we call this something a handler. In Go, we have several ways to do that, and one is to implement the handler interface of the http package. This interface has one method that is pretty self-explanatory, and this is as follows:</p>
			<p class="source-code">ServeHTTP(w http.ResponseWriter, r *http.Request)</p>
			<p>So, whenever we need to create a handler for HTTP requests, we can create a struct including this method and we can use it to handle an HTTP request. For example:</p>
			<p class="source-code">type MyHandler struct {}</p>
			<p class="source-code">func(h MyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {}</p>
			<p>This is a valid HTTP handler and you can use it this way:</p>
			<p class="source-code">http.ListenAndServe(":8080", MyHandler{})</p>
			<p>Here, <strong class="source-inline">ListenAndServe()</strong> is a function that will use our handler to serve the requests; any struct implementing the handler interface will be fine. However, we need to let our server do something.</p>
			<p>As you can see, the <strong class="source-inline">ServeHTTP</strong> method accepts a <strong class="source-inline">ResponseWriter</strong> and a <strong class="source-inline">Request</strong> object. You can actually use them in order to capture parameters from the request and write messages to the response. The simplest thing, for example, is to let our server return a message:</p>
			<p class="source-code">func(h MyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {</p>
			<p class="source-code">  w.Write([]byte("HI"))</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">ListenAndServe</strong> method might return an error. If this happens, we most likely would like the execution of our program to halt, so one common practice is to wrap this function call with a fatal log:</p>
			<p class="source-code">log.Fatal(http.ListenAndServe(":8080", MyHandler{}))</p>
			<p>This will halt the execution and print the error message returned by the <strong class="source-inline">ListenAndServe</strong> function.</p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor382"/>Exercise 15.01: Creating a Hello World Server</h2>
			<p>Let's start building a simple Hello World HTTP server on the basis of what you've learned in the previous block.</p>
			<p>The first thing to do is to create a folder called <strong class="source-inline">hello-world-server</strong>. You can do this via the command line or you can create it with your favorite editor. Inside the folder, create a file called <strong class="source-inline">main.go</strong>. We will not use any external library here:</p>
			<ol>
				<li>Add the package name:<p class="source-code">package main</p><p>This tells the compiler that this file is an entry point for a program that can be executed. </p></li>
				<li>Import the necessary packages:<p class="source-code">import (</p><p class="source-code">   "log"</p><p class="source-code">   "net/http"</p><p class="source-code">)</p></li>
				<li>Now, create a <strong class="source-inline">handler</strong>, the struct that will handle the requests:<p class="source-code">type hello struct{}</p><p class="source-code">func(h hello) ServeHTTP(w http.ResponseWriter, r *http.Request) {</p><p class="source-code">   msg := "&lt;h1&gt;Hello World&lt;/h1&gt;"</p><p class="source-code">   w.Write([]byte(msg))</p><p class="source-code">}</p></li>
				<li>Now that we have our handler, create the <strong class="source-inline">main()</strong> function, which will start the server and produce a web page with our message:<p class="source-code">func main() {</p><p class="source-code">   log.Fatal(http.ListenAndServe(":8080", hello{}))</p><p class="source-code">}</p><p>The entire file should look like this:</p><p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">   "log"</p><p class="source-code">   "net/http"</p><p class="source-code">)</p><p class="source-code">type hello struct{}</p><p class="source-code">func(h hello) ServeHTTP(w http.ResponseWriter, r *http.Request) {</p><p class="source-code">   msg := "&lt;h1&gt;Hello World&lt;/h1"</p><p class="source-code">   w.Write([]byte(msg))</p><p class="source-code">}</p><p class="source-code">func main() {</p><p class="source-code">   log.Fatal(http.ListenAndServe(":8080", hello{}))</p><p class="source-code">}</p></li>
				<li>If you now go to your Terminal, inside your <strong class="source-inline">hello-world-server</strong> folder, and type in the following command:<p class="source-code">hello-world-server go run .</p><p>You should just see nothing; the program has started. </p></li>
				<li>If you now open your browser at the following address:<p class="source-code">http://localhost:8080</p><p>You should see a page with a big message:</p></li>
			</ol>
			<div>
				<div id="_idContainer250" class="IMG---Figure">
					<img src="image/B14177_15_01.jpg" alt="Figure 15.01: Hello world server&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.01: Hello world server</p>
			<p>If you now try to change path and go to <em class="italic">/page1</em>, you will again see the following message:</p>
			<div>
				<div id="_idContainer251" class="IMG---Figure">
					<img src="image/B14177_15_02.jpg" alt="Figure 15.02: Hello world server sub-pages&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.02: Hello world server sub-pages</p>
			<p>Congratulations! This is your first HTTP server.</p>
			<p>In this exercise, we have created a basic hello world server, which returns the message "Hello World" in response to any request on any sub-address.</p>
			<h1 id="_idParaDest-345"><a id="_idTextAnchor383"/>Simple Routing</h1>
			<p>The server built just now in the previous exercise does not do much. It just responds with a message and we cannot ask anything else. Before we can make our server more dynamic, let's imagine we want to create an online book and we want to be able to select a chapter just changing the URL. At the moment, if we browse the following pages:</p>
			<p class="source-code">http://localhost:8080</p>
			<p class="source-code">http://localhost:8080/hello</p>
			<p class="source-code">http://localhost:8080/chapter1</p>
			<p>We always see the same message, but we now want to associate different messages with these different paths on our server. We will do this by introducing some simple routing to our server.</p>
			<p>A path is what you see after the <strong class="source-inline">8080</strong> in the URL; it can be one number, a word, a set of numbers or character groups separated by a "/". In order to do this, we will use another function of the net/http package, which is:</p>
			<p class="source-code">HandleFunc(pattern string, handler func(ResponseWriter, *Request))</p>
			<p>Here, the pattern is the path we want to be served by the <strong class="source-inline">handler</strong> function. Note how the <strong class="source-inline">handler</strong> function signature has the exact same parameters as the <strong class="source-inline">ServeHTTP</strong> method, which you added to the <strong class="source-inline">hello</strong> struct in the previous exercise.</p>
			<p>As an example, the server built in <em class="italic">Exercise 15.01</em> is not very useful, but we can transform it into something much more useful with the addition of pages other than the <strong class="source-inline">hello world</strong> one, and, in order to do so, we need to do some basic routing. The aim here is to write a book, and the book must have a welcome page with the title, and a first chapter. The book title is <strong class="source-inline">hello world</strong>, so we can keep what we did before. The first chapter will have a heading stating <strong class="source-inline">Chapter 1</strong>. The book is a work in progress, so it does not matter that the content is still poor; what we require is the ability to select the chapter, and we will then add the content later.</p>
			<h2 id="_idParaDest-346"><a id="_idTextAnchor384"/>Exercise 15.02: Routing Our Server</h2>
			<p>We are now going to modify the code in <em class="italic">Exercise 15.01</em> to support different paths. If you haven't gone through the previous exercise, do it now so that you'll have a basic framework for this exercise:</p>
			<ol>
				<li value="1">Create a new folder and a <strong class="source-inline">main.go</strong> file and add the code from the previous exercise to the definition of the <strong class="source-inline">main</strong> function:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">   "log"</p><p class="source-code">   "net/http"</p><p class="source-code">)</p><p class="source-code">type hello struct{}</p><p class="source-code">func(h hello) ServeHTTP(w http.ResponseWriter, r *http.Request) {</p><p class="source-code">   msg := "&lt;h1&gt;Hello World&lt;/h1"</p><p class="source-code">   w.Write([]byte(msg))</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Then, use <strong class="source-inline">handle</strong> to route "<strong class="source-inline">/chapter1</strong>" through a <strong class="source-inline">handlefunc()</strong> function:<p class="source-code">  http.HandleFunc("/chapter1", func(w http.ResponseWriter, r *http.Request) {</p><p class="source-code">   msg := "Chapter 1"</p><p class="source-code">   w.Write([]byte(msg))</p><p class="source-code">})</p><p>This means that we associate the path, <strong class="source-inline">/chapter1</strong>, with a function that returns a specific message.</p></li>
				<li>Finally, set the server to listen to a port and to run the following command:<p class="source-code">  log.Fatal(http.ListenAndServe(":8080", hello{}))</p><p class="source-code">}</p></li>
				<li>Now, save your file and run the server again with:<p class="source-code">hello-world-server go run main.go</p></li>
				<li>Then, go to your browser and load the following URLs:<p><strong class="source-inline">http://localhost:8080</strong></p><p><strong class="source-inline">http://localhost:8080/chapter1</strong></p><p>The output for the home page is shown in the following screenshot:</p></li>
			</ol>
			<div>
				<div id="_idContainer252" class="IMG---Figure">
					<img src="image/B14177_15_03.jpg" alt="Figure 15.03: Multi-page server – home page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.03: Multi-page server – home page</p>
			<p>And the output for page 1 is shown in the following screenshot:</p>
			<div>
				<div id="_idContainer253" class="IMG---Figure">
					<img src="image/B14177_15_04.jpg" alt="Figure 15.04: Multi-page server – chapter 1&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.04: Multi-page server – chapter 1</p>
			<p>Note that they both still display the same message. This happens because we are setting our <strong class="source-inline">hello</strong> as the handler for our server, and this overrides our specific path. We can modify our code to look like this:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">   http.HandleFunc("/chapter1", func(w http.ResponseWriter, r *http.Request) {</p>
			<p class="source-code">  msg := "&lt;h1&gt;Chapter 1&lt;/h1&gt;"</p>
			<p class="source-code">  w.Write([]byte(msg))</p>
			<p class="source-code">   })</p>
			<p class="source-code">   http.Handle("/", hello{})</p>
			<p class="source-code">   log.Fatal(http.ListenAndServe(":8080", nil))</p>
			<p class="source-code">}</p>
			<p>What happened here is that you removed the <strong class="source-inline">hello</strong> handler from being the main handler for our server and you associated this handler with the main <strong class="source-inline">/</strong> path:</p>
			<p class="source-code">http.Handle("/", hello{})</p>
			<p>Then, you associated a <strong class="source-inline">handler</strong> function with the specific <strong class="source-inline">/chapter1</strong> path:</p>
			<p class="source-code">http.HandleFunc("/chapter1", func(w http.ResponseWriter, r *http.Request) {</p>
			<p class="source-code">   msg := "Chapter 1"</p>
			<p class="source-code">   w.Write([]byte(msg))</p>
			<p class="source-code">})</p>
			<p>Now, if you stop and then run our server again, you will see that the <strong class="source-inline">/chapter1</strong> path now returns the new message:</p>
			<div>
				<div id="_idContainer254" class="IMG---Figure">
					<img src="image/B14177_15_05.jpg" alt="Figure 15.05: Multi-page server repeated – chapter 1&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.05: Multi-page server repeated – chapter 1</p>
			<p>In the meantime, all the other paths return the old <strong class="source-inline">Hello World</strong> message.</p>
			<div>
				<div id="_idContainer255" class="IMG---Figure">
					<img src="image/B14177_15_06.jpg" alt="Figure 15.06: Multi-page server – base page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.06: Multi-page server – base page</p>
			<div>
				<div id="_idContainer256" class="IMG---Figure">
					<img src="image/B14177_15_07.jpg" alt="Figure 15.07: The page that is not set returns the default setting&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.07: The page that is not set returns the default setting</p>
			<h1 id="_idParaDest-347"><a id="_idTextAnchor385"/>Handler versus Handler Function</h1>
			<p>As you may have noticed, we used two different functions before, <strong class="source-inline">http.Handle</strong> and <strong class="source-inline">http.HandleFunc</strong> , both of which have a path as their first parameter, but which differ in terms of the second parameter. These two functions both ensure that a specific path is handled by a function. <strong class="source-inline">http.Handle</strong>, however, expects <strong class="source-inline">http.Handler</strong> to handle the path, while <strong class="source-inline">http.HandleFunc</strong> expects a function to do the same.</p>
			<p>As we've seen before, <strong class="source-inline">http.Handler</strong> is any struct having a method with this signature:</p>
			<p class="source-code">ServeHTTP(w http.ResponseWriter, r *http.Request)</p>
			<p>So, in both cases, there will always be a function with <strong class="source-inline">http.ResponseWriter</strong> and <strong class="source-inline">*http.Request</strong> as parameters that will handle the path. As to when one or the other might be chosen may just be a matter of personal preference in many cases, but it might be important, when creating a complex project, for example, to choose the right method. Doing so will ensure that the structure of the project is optimal. Different routes may appear better organized if handled by handlers belonging to different packages, or might have to perform very few actions, as in our previous case; and a simple function might prove to be the ideal choice.</p>
			<p>In general, for simple projects where you have a handful of simple pages, you may opt for <strong class="source-inline">HandleFunc</strong>. For example, let's say you want to have static pages and there is no complex behavior in each page. In this case, it would be an overkill to use an empty struct just for returning a static text. The handler is more appropriate whenever you need to set some parameters, or if you want to keep track of something. As a general rule, let's say that if you have a counter, a <strong class="source-inline">Handler</strong> is the best choice because you can initialize a <strong class="source-inline">struct</strong> with a count of 0 and then increment it, but we will see this in <em class="italic">Activity 15.01</em>.</p>
			<h2 id="_idParaDest-348">Activit<a id="_idTextAnchor386"/>y 15.01: Adding a Page Counter to an HTML Page</h2>
			<p>Imagine that you own a website with, say, three pages, where you are writing your book. You earn money depending on how many visits your website receives. In order to understand how popular your website is, and how much money you are earning, you need to keep track of the visits.</p>
			<p>In this activity, you will build an HTTP server with three pages, containing some content, and display, in each page, how many visits that page has had so far. You will use the <strong class="source-inline">http.Handler</strong> method, which, in this case, will help you to generalize your counter.</p>
			<p>In order to display the dynamic value, you can use the <strong class="source-inline">fmt.Sprintf</strong> function in the <strong class="source-inline">fmt</strong> package, which prints and formats a message to a string. With this function, you can build a string containing characters and numbers. You can find all the information about this method online in the Go documentation.</p>
			<p>You will use everything you've learned so far, including how a struct is instantiated, how to set attributes of a struct, pointers, how to increase an integer, and, of course, everything you have learned about HTTP servers hitherto.</p>
			<p>Observing the following steps will provide an elegant and effective solution:</p>
			<ol>
				<li value="1">Create a folder called <strong class="source-inline">page-counter</strong>.</li>
				<li>Create a file called <strong class="source-inline">main.go</strong>.</li>
				<li>Add the necessary imports to the <strong class="source-inline">http</strong> and <strong class="source-inline">fmt</strong> packages.</li>
				<li>Define a struct called <strong class="source-inline">PageWithCounter</strong> with a <strong class="source-inline">counter</strong> as an integer attribute, a <strong class="source-inline">content</strong>, and a <strong class="source-inline">heading</strong> as a text attribute.</li>
				<li>Add a <strong class="source-inline">ServeHTTP</strong> method to the struct, capable of displaying the content, the heading, and a message with the total number of views.</li>
				<li>Create your <strong class="source-inline">main</strong> function and, inside, implement the following:</li>
				<li>Instantiate three handlers of the <strong class="source-inline">PageWithCounter</strong> type, with <strong class="source-inline">Hello World</strong>, <strong class="source-inline">Chapter 1</strong>, and <strong class="source-inline">Chapter 2</strong> headings and some content.</li>
				<li>Add the three handlers to the routes <strong class="source-inline">/</strong>, <strong class="source-inline">/chapter1</strong>, and <strong class="source-inline">/chapter2</strong>.</li>
				<li>Run the server on port <strong class="source-inline">8080</strong>.</li>
			</ol>
			<p>When yo<a id="_idTextAnchor387"/>u run the server, you should see the following:</p>
			<div>
				<div id="_idContainer257" class="IMG---Figure">
					<img src="image/B14177_15_08.jpg" alt="Figure 15.08: Output on the browser when you run the server for the first time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.08: Output on the browser when you run the server for the first time</p>
			<p>If you refresh the page, you should see the following:</p>
			<div>
				<div id="_idContainer258" class="IMG---Figure">
					<img src="image/B14177_15_09.jpg" alt="Figure 15.09: Output on the browser when you run the server for the second time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.09: Output on the browser when you run the server for the second time</p>
			<p>Next, navigate to Chapter 1 by typing <strong class="source-inline">localhost:8080/chapter1</strong> in the address bar. You should be able to see something along the lines of the following:</p>
			<div>
				<div id="_idContainer259" class="IMG---Figure">
					<img src="image/B14177_15_10.jpg" alt="Figure 15.10: Output on the browser when you visit the chapter1 page for the first time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.10: Output on the browser when you visit the chapter1 page for the first time</p>
			<p>Similarly, navigate to Chapter 2, and you should be able to see the following increment in terms of the number of views:</p>
			<div>
				<div id="_idContainer260" class="IMG---Figure">
					<img src="image/B14177_15_11.jpg" alt="Figure 15.11: Output on the browser when you visit the chapter2 page for the first time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.11: Output on the browser when you visit the chapter2 page for the first time</p>
			<p>When you revisit Chapter 1, you should see an increase in the number of views as follows:</p>
			<div>
				<div id="_idContainer261" class="IMG---Figure">
					<img src="image/B14177_15_12.jpg" alt="Figure 15.12: Output on the browser when you visit the chapter1 page for the second time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.12: Output on the browser when you visit the chapter1 page for the second time</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 757</p>
			<p>In this activity, you learned how to create a server that responds to different requests on different pages with a specific static text, along with a counter on each page, with each counter independent from the others.</p>
			<h1 id="_idParaDest-349"><a id="_idTextAnchor388"/>Returning Complex Structures</h1>
			<p>What we've seen hitherto is useful when building a website, even though, for this purpose, we still need to see how to better render HTML pages. You might want to use a framework such as <strong class="bold">revel</strong> or <strong class="bold">gin</strong> for this purpose, although plain Go with a few libraries is more than enough for a production-grade website. You will find, however, that HTTP servers are used not only for building websites, but also for building web services, and especially, nowadays, microservices. Although how to build a web service-based project is beyond the scope of this chapter and book, it is important for you to know how to let your HTTP server serve something that will not be consumed by a human through a browser, but by another program. You may already know what a web service is, but even if you do not, you might have to work on an existing project where you have to modify a web service. There are several ways to present a message to another program, which will be referred to as a client, but, in general, they will all involve some sort of structured texts, which can be parsed easily. The format could be an XML string, but the most common and lightweight format now used is JSON. In the next exercise, we will see how to build a data structure and send it to the client (aq browser or another program) in the form of a JSON string.</p>
			<h2 id="_idParaDest-350">Activity 15.<a id="_idTextAnchor389"/>02: Serving a Request with a JSON Payload</h2>
			<p>In this activity, you will create a data structure and you will serve it through an HTTP server. You will make use of what you have already learned about JSON and the encoding/decoding of structs, and you will combine it with what you've learned about HTTP servers. You might have guessed already, but in this exercise, you already have all the knowledge required and you should be able to complete it on your own. Let's now build another book. The title and the chapters are the same, but this time we want to make it accessible to a program that will consume the pages on the server as JSON documents. The document will also include the number of views per chapter, so the code can make use of the one generated in <em class="italic">Activity 15.01</em>. The steps are as follows:</p>
			<ol>
				<li value="1">Create a new folder called <strong class="source-inline">book-api</strong>.</li>
				<li>Create a file called <strong class="source-inline">main.go</strong> in that folder.</li>
				<li>Add the required imports.</li>
				<li>Create a struct called <strong class="source-inline">PageWithCounter</strong> representing a book with a title, content, and a counter, with appropriate JSON tags, if necessary.</li>
				<li>Add a <strong class="source-inline">ServeHTTP</strong> method to the struct, capable of displaying the content, the heading, and a message with the total number of views as a JSON document.</li>
				<li>Create the <strong class="source-inline">main()</strong> function.</li>
				<li>Instantiate three handlers of the <strong class="source-inline">PageWithCounter</strong> type, with <strong class="source-inline">Hello World</strong>, <strong class="source-inline">Chapter 1</strong>, and <strong class="source-inline">Chapter 2</strong> headings and some content.</li>
				<li>Add the three handlers to the routes <strong class="source-inline">/</strong>, <strong class="source-inline">/chapter1</strong>, and <strong class="source-inline">/chapter2</strong>.</li>
				<li>Run the server on port <strong class="source-inline">8080</strong>.</li>
			</ol>
			<p>Running your<a id="_idTextAnchor390"/> server, you should see the following for the assigned routes:</p>
			<div>
				<div id="_idContainer262" class="IMG---Figure">
					<img src="image/B14177_15_13.jpg" alt="Figure 15.13: Expected output when the handler is /&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.13: Expected output when the handler is /</p>
			<div>
				<div id="_idContainer263" class="IMG---Figure">
					<img src="image/B14177_15_14.jpg" alt="Figure 15.14: Expected output when the handler is /chapter1&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.14: Expected output when the handler is /chapter1</p>
			<div>
				<div id="_idContainer264" class="IMG---Figure">
					<img src="image/B14177_15_15.jpg" alt="Figure 15.15: Expected output when the handler is /chapter2&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.15: Expected output when the handler is /chapter2</p>
			<p>In this activity, you've learned how to return complex structures through an HTTP server. Any kind of complex data structure can be served this way, using a standard format such as JSON.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 761</p>
			<h1 id="_idParaDest-351"><a id="_idTextAnchor391"/>Dynamic Content</h1>
			<p>A server that serves only static content is useful, but there is much more that can be done. An HTTP server can deliver content depending on a more granular request, which is done by passing some parameters to the server. There are many ways to do so, but one simple way is to pass parameters to a <strong class="source-inline">querystring</strong>. If the URL of the server is:</p>
			<p class="source-code">http://localhost:8080</p>
			<p>We can then add something like:</p>
			<p class="source-code">http://localhost:8080?name=john</p>
			<p>Here, the part <strong class="source-inline">?name=john</strong> is called a <strong class="source-inline">querystring</strong> as it is a string representing a query. In this case, this <strong class="source-inline">querystring</strong> sets a variable called <strong class="source-inline">name</strong> with a value of <strong class="source-inline">john</strong>. This way of passing parameters is generally used with <strong class="source-inline">GET</strong> requests, while a <strong class="source-inline">POST</strong> request will generally make use of the body of the request in order to send parameters. This does not mean that a <strong class="source-inline">GET</strong> request does not have a body but is not the standard way to pass parameters to a <strong class="source-inline">GET</strong> request. We will begin by looking at how to accept parameters for a <strong class="source-inline">GET</strong> request, as this request is made by simply opening your browser on a specific address. We will see later how to handle a <strong class="source-inline">POST</strong> request through a form.</p>
			<p>In the next exercise, you will be able to return different texts as responses to HTTP requests, where the text depends on what values the user puts in the <strong class="source-inline">querystring</strong> in the address bar.</p>
			<h2 id="_idParaDest-352"><a id="_idTextAnchor392"/>Exercise 15.03: Personalized Welcome</h2>
			<p>In this exercise, we will again create an HTTP server that is able to cheer us, but instead of a general "<strong class="source-inline">hello world</strong>" message, we will provide a message depending on our name. The idea is that, by opening the browser on the server's URL and adding a parameter called <strong class="source-inline">name</strong>, the server will welcome us with the message "<strong class="source-inline">hello</strong> ", followed by the value of the <strong class="source-inline">name</strong> parameter. The server is very simple and does not have sub-pages, but contains this dynamic element that constitutes a starting point for more complex situations:</p>
			<ol>
				<li value="1">Create a new folder called <strong class="source-inline">personalised-welcome</strong> and, inside the folder, create a file called <strong class="source-inline">main.go</strong>. Inside the file, add the package name:<p class="source-code">package main</p></li>
				<li>Then, add the required imports:<p class="source-code">import (</p><p class="source-code">   "fmt"</p><p class="source-code">   "log"</p><p class="source-code">   "net/http"</p><p class="source-code">   "strings"</p><p class="source-code">)</p></li>
				<li>They are all the same imports used in the previous exercises and activities, no there is nothing new. We will not use handlers in this exercise as it is much smaller, but we will make use of the <strong class="source-inline">http.handleFunc</strong> function.</li>
				<li>Now, add the following code after the imports:<p class="source-code">func Hello(w http.ResponseWriter, r *http.Request) {</p></li>
				<li>This is the definition of a function that can be used as a handling function for an HTTP path. </li>
				<li>Now, save the query to a variable using the <strong class="source-inline">Query</strong> method URL from the request:<p class="source-code">   vl := r.URL.Query()</p></li>
				<li>The <strong class="source-inline">Query</strong> method on the <strong class="source-inline">URL</strong> object of the request returns a <strong class="source-inline">map[string][]string</strong> with all the parameters sent through the <strong class="source-inline">querystring</strong> in the URL. We then assign this map to a variable, <strong class="source-inline">vl</strong>.</li>
				<li>At this point, we need to get the value of a specific parameter called <strong class="source-inline">name</strong>, so we get the value from the <strong class="source-inline"> name</strong>  parameter:<p class="source-code">name, ok := vl["name"]</p></li>
				<li>As you can see, we have an assignment to two variables, but only one value comes from <strong class="source-inline">vl["name"]</strong>. The second variable, <strong class="source-inline">ok</strong>, is a Boolean that tells us whether the "<strong class="source-inline">name</strong>" key exists. </li>
				<li>If the <strong class="source-inline">name</strong> parameter has not been passed and we want an error message to appear, add it if the variable is not found, in other words, if the <strong class="source-inline">ok</strong> variable is false:<p class="source-code">if !ok {</p><p class="source-code">   w.WriteHeader(400)</p><p class="source-code">   w.Write([]byte("Missing name"))</p><p class="source-code">   return</p><p class="source-code">}</p></li>
				<li>The conditional code gets called if the key does not exist in the slice, and it writes a <strong class="source-inline">400</strong> code (bad request) to the header, as well as a message to the response writer stating that the name has not been sent as a parameter. We stop the execution with a <strong class="source-inline">return</strong> statement to prevent further actions. </li>
				<li>At this point, write the valid message to the response writer:<p class="source-code">w.Write([]byte(fmt.Sprintf("Hello %s", strings.Join(name, ","))))</p><p class="source-code">}</p></li>
				<li>This code formats a string and injects the name into it. The <strong class="source-inline">fmt.Sprintf</strong> function is used to format, while <strong class="source-inline">strings.Join</strong> is used in order to transform the <strong class="source-inline">name</strong> slice into a string. Notice that the <strong class="source-inline">name</strong> variable is set to the value of <strong class="source-inline">vl["name"]</strong>, but <strong class="source-inline">vl</strong> is a <strong class="source-inline">map[string][]string</strong>, which means that it is a map with string keys whose values are slices of strings; hence, <strong class="source-inline">vl["name"]</strong> is a slice of strings and needs to be transformed into a single string. The <strong class="source-inline">strings.Join</strong> function takes all the elements of the slice and builds a single string using <strong class="source-inline">","</strong> as a separator. Other characters could also have been used as separators.</li>
				<li>The last part of the file you have to write is:<p class="source-code">func main() {</p><p class="source-code">   http.HandleFunc("/", Hello)</p><p class="source-code">   log.Fatal(http.ListenAndServe(":8080", nil))</p><p class="source-code">}</p></li>
				<li>As always, a <strong class="source-inline">main()</strong> function is created, and then the <strong class="source-inline">Hello</strong> function is associated with the path <strong class="source-inline">"/"</strong> and the server started. Here is the output of three different URLs, two valid ones, and one with a missing parameter:</li>
			</ol>
			<div>
				<div id="_idContainer265" class="IMG---Figure">
					<img src="image/B14177_15_16.jpg" alt="Figure 15.16: Server output when requesting the page with the name john&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.16: Server output when requesting the page with the name john</p>
			<div>
				<div id="_idContainer266" class="IMG---Figure">
					<img src="image/B14177_15_17.jpg" alt="Figure 15.17: Server output when requesting the page with the name will&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.17: Server output when requesting the page with the name will</p>
			<div>
				<div id="_idContainer267" class="IMG---Figure">
					<img src="image/B14177_15_18.jpg" alt="Figure 15.18: Server outputting an error message when requesting a page without a name&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.18: Server outputting an error message when requesting a page without a name</p>
			<h1 id="_idParaDest-353"><a id="_idTextAnchor393"/>Templating</h1>
			<p>Although JSON can be the best choice when complex data structures have to be shared across software programs, this is not the case, in general, when the HTTP server is supposed to be consumed by humans. In the previous exercises and activities, the chosen way to format a text has been the <strong class="source-inline">fmt.Sprintf</strong> function, which is good for formatting texts, but is simply insufficient when a more dynamic and complex text is required. As you will have noticed in the previous exercise, the message returned in case a name was passed as a parameter to the URL observed a specific pattern, and this is where a new concept comes in – the template. A template is a skeleton from which complex entities can be developed. Essentially, a template is like a text with some blanks, and a template engine will take some values and fill the blanks, as you can see in the following diagram:</p>
			<div>
				<div id="_idContainer268" class="IMG---Figure">
					<img src="image/B14177_15_19.jpg" alt="Figure 15.19: Templating example&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.19: Templating example</p>
			<p>As you can see, <strong class="source-inline">{{name}}</strong> is a placeholder and, when a value is passed through to the engine, the placeholder is modified with that value.</p>
			<p>We see templates everywhere. We have templates for Word documents, where we just fill in what is missing to produce new documents that all differ from one another. A teacher might have some templates for their lessons and will develop different lessons from that same template. Go provides two different templating packages, one for texts and one for HTML. As we are working with HTTP servers and we want to produce a web page, we will use the HTML templating package, but the interface is the same for the text template library. Although the templating packages are good enough for any real-world application, there are also several other external packages that can be used in order to improve performance. One of these is the <strong class="source-inline">hero</strong> template engine, which is much faster than the standard Go templating package.</p>
			<p>The Go templating package provides a placeholder language where we can use things such as:</p>
			<p class="source-code">{{name}}</p>
			<p>A simple search and replace block, but more complex situations can be handled via conditionals:</p>
			<p class="source-code">{{if age}} Hello {{else}} bye {{end}}</p>
			<p>Here, if an <strong class="source-inline">age</strong> parameter is not null, the template will have <strong class="source-inline">Hello</strong>; otherwise it has <strong class="source-inline">bye</strong>. Each conditional needs an <strong class="source-inline">{{end}}</strong> placeholder to determine its ending.</p>
			<p>Variables in a template, however, do not need to be simple numbers or strings; they can be objects. In this case, if we have a struct with a field called <strong class="source-inline">ID</strong>, we can reference this field in the template this way:</p>
			<p class="source-code">{{.ID}}</p>
			<p>This is very handy, meaning that we can pass a struct to the template instead of many single parameters.</p>
			<p>In the next exercise, you will see how to use the basic templating functionalities of Go to create pages with custom messages, like you've done before, but just in a more elegant way.</p>
			<h2 id="_idParaDest-354"><a id="_idTextAnchor394"/>Exercise 15.04: Templating Our Pages</h2>
			<p>The aim of this exercise is to build a more structured web page, use a template, and fill it with parameters from the URL's <strong class="source-inline">querystring</strong>. In this scenario, we want to display basic information for a customer and hide some information when the data is missing. A customer has an <strong class="source-inline">id</strong>, <strong class="source-inline">name</strong>, <strong class="source-inline">surname</strong>, and <strong class="source-inline">age</strong> and if any of these items of data are missing, they will not be displayed. Unless the data is the <strong class="source-inline">id</strong>, as in this case, an error message will be displayed:</p>
			<ol>
				<li value="1">Begin by creating a <strong class="source-inline">server-template</strong> folder with a <strong class="source-inline">main.go</strong> file as usual, and then add the usual package and some imports:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">   "html/template"</p><p class="source-code">   "log"</p><p class="source-code">   "net/http"</p><p class="source-code">   "strconv"</p><p class="source-code">   "strings"</p><p class="source-code">)</p></li>
				<li>Here, we use two new imports, "<strong class="source-inline">html/template</strong>" for our templating, and "<strong class="source-inline">strconv</strong>" to convert strings into numbers (this package could also work the other way around, but there are better solutions for formatting text).</li>
				<li>Now, write the following:<p class="source-code">var tplStr = `</p><p class="source-code">&lt;html&gt;</p><p class="source-code">  &lt;h1&gt;Customer {{.ID}}</p><p class="source-code">  {{if .ID }}</p><p class="source-code">   &lt;p&gt;Details:&lt;/p&gt;</p><p class="source-code">   &lt;ul&gt;</p><p class="source-code">   {{if .Name}}&lt;li&gt;Name: {{.Name}}&lt;/li&gt;{{end}}</p><p class="source-code">   {{if .Surname}}&lt;li&gt;Surname: {{.Surname}}&lt;/li&gt;{{end}}</p><p class="source-code">   {{if .Age}}&lt;li&gt;Age: {{.Age}}&lt;/li&gt;{{end}}</p><p class="source-code">   &lt;/ul&gt;</p><p class="source-code">  {{else}}</p><p class="source-code">  &lt;p&gt;Data not available&lt;/p&gt;</p><p class="source-code">  {{end}}</p><p class="source-code">&lt;/html&gt;</p><p class="source-code">`</p></li>
				<li>This is a raw string that contains some HTML and templating code, which is wrapped by <strong class="source-inline">{{}}</strong> and which we will analyze now.</li>
				<li><strong class="source-inline">{{.ID}}</strong> is essentially a placeholder that tells the template engine that wherever this code is found, it will be substituted by a struct's attribute called <strong class="source-inline">ID</strong>. The Go templating engine works with structs, so essentially, a struct will be passed to the engine and its attributes' values will be used to fill the placeholders. <strong class="source-inline">{{if .ID}}</strong> is a conditional that tells the template that what happens next will depend on the value of <strong class="source-inline">ID</strong>. In this case, if <strong class="source-inline">ID</strong> is not an empty string, the template will display the customer's details, otherwise it will display the message <strong class="source-inline">&lt;p&gt;Data not available&lt;/p&gt;</strong>, which is wrapped between the placeholders <strong class="source-inline">{{else}}</strong> and <strong class="source-inline">{{end}}</strong>. As you can see, there are many more conditionals nested inside the first one. At each list item, there is a <strong class="source-inline">&lt;li&gt;</strong> tag, which is wrapped, for example, by <strong class="source-inline">{{if .Name}}</strong> and terminated with <strong class="source-inline">{{end}}</strong>.</li>
				<li>Now that we have a string template, let's create a struct with the correct attributes. To fill in the template, write the following:<p class="source-code">type Customer struct {</p><p class="source-code">   ID int</p><p class="source-code">   Name string</p><p class="source-code">   Surname string</p><p class="source-code">   Age int</p><p class="source-code">}</p><p>This struct is self-explanatory. It contains all the attributes needed by the template. </p></li>
				<li>Define the handler function and set a variable to the map of values in the <strong class="source-inline">querystring</strong>:<p class="source-code">func Hello(w http.ResponseWriter, r *http.Request) {</p><p class="source-code">   vl := r.URL.Query()</p></li>
				<li>Instantiate a <strong class="source-inline">cust</strong> variable of the <strong class="source-inline">Customer</strong> type:<p class="source-code">cust := Customer{}</p></li>
				<li>The variable now has all its attributes set to the default values, and we need to grab the passed values from the URL. In order to do so, write:<p class="source-code">id, ok := vl["id"]</p><p class="source-code">if ok {</p><p class="source-code">   cust.ID, _ = strconv.Atoi(strings.Join(id, ","))</p><p class="source-code">}</p><p class="source-code">name, ok := vl["name"]</p><p class="source-code">if ok {</p><p class="source-code">   cust.Name = strings.Join(name, ",")</p><p class="source-code">}</p><p class="source-code">surname, ok := vl["surname"]</p><p class="source-code">if ok {</p><p class="source-code">   cust.Surname = strings.Join(surname, ",")</p><p class="source-code">}</p><p class="source-code">age, ok := vl["age"]</p><p class="source-code">if ok {</p><p class="source-code">   cust.Age, _ = strconv.Atoi(strings.Join(age, ""))</p><p class="source-code">}</p></li>
				<li>As you can see, the parameters are taken as they are from the values map, and if they exist, they are used to set the value of the related <strong class="source-inline">cust</strong> attribute. In order to check whether these parameters exist, we again used the <strong class="source-inline">ok</strong> variable, which is set to a Boolean with a value of <strong class="source-inline">true</strong> in case the map contains the requested key. The last attribute, <strong class="source-inline">Age</strong>, is handled slightly differently:<p class="source-code">cust.Age, _ = strconv.Atoi(strings.Join(age, ""))</p></li>
				<li>This is because <strong class="source-inline">strconv.Atoi</strong> returns an error in case the parameter passed is not really a number. In general, we should handle the errors but, in this case, we just ignore it and we won't display any age-related information if the age provided is not a number. </li>
				<li>Next, write:<p class="source-code">tmpl, _ := template.New("test").Parse(tplStr)</p></li>
				<li>This creates a template object with the name "<strong class="source-inline">test</strong>" and with the content of the string that you created at the outset. We again ignore the error as we are sure that the template we've written is a valid one. In production, however, all the errors should be dealt with. </li>
				<li>You can now finish writing the function with:<p class="source-code">   tmpl.Execute(w, cust)</p><p class="source-code">}</p></li>
				<li>Here, the template is actually executed using the <strong class="source-inline">cust</strong> struct and the content is sent directly to <strong class="source-inline">w</strong> <strong class="source-inline">ResponseWriter</strong> without needing to call the <strong class="source-inline">Write</strong> method manually.</li>
				<li>What is missing now is the <strong class="source-inline">main</strong> method, which is fairly simple. Write the following:<p class="source-code">func main() {</p><p class="source-code">   http.HandleFunc("/", Hello)</p><p class="source-code">   log.Fatal(http.ListenAndServe(":8080", nil))</p><p class="source-code">}</p></li>
				<li>Here, simply speaking, the main path is associated with the <strong class="source-inline">Hello</strong> function and the server is then started.</li>
				<li>The performance of this code is not very high as we create a template in every request. The template could be created in the <strong class="source-inline">main</strong> and then passed to a handler, which could have a <strong class="source-inline">ServeHTTP</strong> method like the <strong class="source-inline">Hello</strong> function you've just written. The code has been kept simple here in order to focus on templating.</li>
				<li>If you now start the server and visit the following pages, you should see some output similar to the following:</li>
			</ol>
			<div>
				<div id="_idContainer269" class="IMG---Figure">
					<img src="image/B14177_15_20.jpg" alt="Figure 15.20: Templated response with blank parameters&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.20: Templated response with blank parameters</p>
			<p>Now, you can add a query parameter called <strong class="source-inline">id</strong> and put it equal to <strong class="source-inline">1</strong> in the URL visiting this address: <strong class="source-inline">localhost:8080/?id=1</strong>:</p>
			<div>
				<div id="_idContainer270" class="IMG---Figure">
					<img src="image/B14177_15_21.jpg" alt="Figure 15.21: Templated response with just the ID specified&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.21: Templated response with just the ID specified</p>
			<p>Then, you can also add a value for the name parameter going to the address <strong class="source-inline">localhost:8080/?id=1&amp;<a id="_idTextAnchor395"/>name=John</strong>:</p>
			<div>
				<div id="_idContainer271" class="IMG---Figure">
					<img src="image/B14177_15_22.jpg" alt="Figure 15.22: Templated response with the ID and name specified&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.22: Templated response with the ID and name specified</p>
			<p>And finally, you can also add an age going to the address <strong class="source-inline">localhost:8080/?id=1&amp;name=John&amp;age=40</strong>:</p>
			<div>
				<div id="_idContainer272" class="IMG---Figure">
					<img src="image/B14177_15_23.jpg" alt="Figure 15.23: Templated response with the ID, name, and age specified&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.23: Templated response with the ID, name, and age specified</p>
			<p>Here, each parameter in the <strong class="source-inline">querystring</strong> is displayed, if valid, in the web application.</p>
			<h1 id="_idParaDest-355"><a id="_idTextAnchor396"/>Static Resources</h1>
			<p>Everything you've learned so far in this book, up to the last exercise, is sufficient in order to build web applications and dynamic websites; you just need to put all the pieces together. What you've been doing in this chapter is returning messages that are different in nature, but that are all hardcoded as strings. Even dynamic messages have been based on templates hardcoded in the source file of the exercises and activities. Let's now consider something. In the case of the first "<strong class="source-inline">hello world</strong>" server, the message never changed. If we wanted to modify the message and return a "<strong class="source-inline">Hello galaxy</strong>" message, we would have to change the text in the code and then recompile and/or run the server again. What if you wanted to sell your simple "hello" server and give the option to everybody to specify a custom message? Of course, you should give the source code to everybody so that they could recompile and run the server. Although you might want to embrace open source code, this might not be the ideal way to distribute an application, and we need to find a better way to separate the message from the server. A solution to that is to serve static files, which are files loaded by your program as external resources. These files do not change and do not get compiled but are loaded and manipulated by your program. One such example may be templates, as seen before, because they are just text and you can use template files instead of adding the templates as text to your code. Another simple example of static resources are images that you want to include in your web page, or styling files such as CSS. You will see in the following exercises and activities how to do that. You'll be able to serve a specific file or a specific folder, and then you'll see how to serve dynamic files with a static template.</p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor397"/>Exercise 15.05: Creating a Hello World Server Using a Static File</h2>
			<p>In this exercise, you will again create your hello world server but with the use of a static HTML file. What we want is to have a simple server with one handler function that looks for a specific file with a specific name, which will be served as the output for every path. In this case, you will need to create multiple files in your project:</p>
			<ol>
				<li value="1">Create a folder called <strong class="source-inline">static-file</strong> and, inside it, create a file called <strong class="source-inline">index.html</strong>. Then, insert inside this file the following code for a pretty simple HTML file with a title and an <strong class="source-inline">h1</strong> tag with our welcome message:<p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html lang="en"&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">  &lt;meta charset="UTF-8"&gt;</p><p class="source-code">  &lt;title&gt;Welcome&lt;/title&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code">  &lt;h1&gt;Hello World&lt;/h1&gt;</p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>Now, create a file called <strong class="source-inline">main.go</strong> and start writing the necessary imports:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">   "log"</p><p class="source-code">   "net/http"</p><p class="source-code">)</p></li>
				<li>Now, write the <strong class="source-inline">main</strong> function:<p class="source-code">func main() {</p></li>
				<li>Now, write the <strong class="source-inline">handler</strong> function:<p class="source-code">   http.HandleFunc("/", func (w http.ResponseWriter, r *http.Request) {</p><p class="source-code">  http.ServeFile(w, r, "./index.html")</p><p class="source-code">   })</p></li>
				<li>This is where the magic happens. You can see a normal <strong class="source-inline">http.HandleFunc</strong> called with a <strong class="source-inline">"/"</strong> path as the first parameter, and then a handler function is passed, which contains a single instruction:<p class="source-code">http.ServeFile(w, r, "./index.html")</p></li>
				<li>This essentially sends to <strong class="source-inline">ResponseWriter</strong> the content of the "<strong class="source-inline">index.html</strong>" file. </li>
				<li>Now, write the last part:<p class="source-code">   log.Fatal(http.ListenAndServe(":8080", nil))</p><p class="source-code">}</p></li>
				<li>As is always the case, this starts the server, logs in case of an error, and exits the program.</li>
				<li>If you now save the file and you run the program with:<p class="source-code">  go run main.go</p><p>And then you open your browser on the <strong class="source-inline">localhost:8080</strong> page, you should see the following:</p><div id="_idContainer273" class="IMG---Figure"><img src="image/B14177_15_24.jpg" alt="Figure 15.24: Hello world with a static template file&#13;&#10;"/></div><p class="figure-caption">Figure 15.24: Hello world with a static template file</p></li>
				<li>But now, without stopping your server, just change the HTML file, <strong class="source-inline">index.html</strong>, and modify line <strong class="source-inline">8</strong> where you see:<p class="source-code">  &lt;h1&gt;Hello World&lt;/h1&gt;</p></li>
				<li>Change the text in the <strong class="source-inline">&lt;h1&gt;</strong> tag:<p class="source-code">  &lt;h1&gt;Hello Galaxy&lt;/h1&gt;</p></li>
				<li>Save the <strong class="source-inline">index.html</strong> file and, without touching the terminal and without restarting your server, just refresh your browser on the same page, and you should now see the following:<div id="_idContainer274" class="IMG---Figure"><img src="image/B14177_15_25.jpg" alt="Figure 15.25: Hello world server with the static template file modified&#13;&#10;"/></div><p class="figure-caption">Figure 15.25: Hello world server with the static template file modified</p></li>
				<li>So, even if the server is running, it will pick up the new version of the file.<p>In this exercise, you've seen how to use a static HTML file to serve a web page, and how detaching the static resources from your application makes you able to change your served page without restarting your application.</p></li>
			</ol>
			<h1 id="_idParaDest-357"><a id="_idTextAnchor398"/>Getting Some Style</h1>
			<p>Up to now, you've seen how to serve one static page and you might consider serving a few pages with the same method, maybe creating a handler struct with the name of the file to serve as an attribute. This might be impractical for large numbers of pages, although, in some cases, it is necessary. A web page, however, does not include just HTML code, but also images and styles, and some frontend code. It is not within the scope of this book to teach how to build HTML pages, and even less how to write JavaScript code or CSS style sheets, but you need to know how to serve these documents as we use a small CSS file to build our example. Serving static files and putting templates in different files, or generally using external resources, is a good way to separate concerns on our projects, and makes our projects more manageable and maintainable, so you should try to follow this approach in all your projects.</p>
			<p>In order to add a style sheet to your HTML pages, you need to add a tag like this:</p>
			<p class="source-code">&lt;link rel="stylesheet" href="file.css"&gt;</p>
			<p>This injects the CSS file into the page as a "stylesheet", but this is reported here just by way of an example, in case you are interested in learning how to write HTML.</p>
			<p>You have also seen that we have served files, reading them from the filesystem one by one, but Go provides us with an easy function to do the job for us:</p>
			<p class="source-code">http.FileServer(http.Dir("./public"))</p>
			<p>Essentially, <strong class="source-inline">http.FileServer</strong> creates what the name says: a server serving external files, and it takes them from the directory defined in <strong class="source-inline">http.Dir</strong>. Whatever file we put inside the "<strong class="source-inline">./public</strong>" directory will be automatically accessible, adding in the address bar:</p>
			<p class="source-code">http://localhost:8080/public/myfile.css</p>
			<p>This seems good enough. However, in a real-world scenario, you do not want to expose your folder names and you want to specify a different name for your static resources. This is achieved as follows:</p>
			<p class="source-code">http.StripPrefix(</p>
			<p class="source-code">  "/statics/",</p>
			<p class="source-code">  http.FileServer(http.Dir("./public")),</p>
			<p class="source-code">   )</p>
			<p>You may notice that the <strong class="source-inline">http.FileServer</strong> function is wrapped by an <strong class="source-inline">http.StripPrefix</strong> function that we use in order to associate the requested path with the correct files on the filesystem. Essentially, we want a path of the <strong class="source-inline">/statics</strong> form to be available and to bind it to the content of the <strong class="source-inline">public</strong> folder. The <strong class="source-inline">StripePrefix</strong> function will remove the <strong class="source-inline">"/statics/"</strong> prefix from the request and will pass it to the file server, which will just get the name of the file to serve and will search for it in the <strong class="source-inline">public</strong> folder. It is not necessary, if you do not want to change the name of the path and folder, to use these wrappers, but this solution is general and works everywhere, so you can utilize it in other projects without having to worry. </p>
			<h2 id="_idParaDest-358"><a id="_idTextAnchor399"/>Exercise 15.06: A Stylish Welcome</h2>
			<p>The aim of this exercise is to display a welcome page, making use of some external static resources. We will adopt the same approach as in <em class="italic">Exercise 15.05</em>, but we will add some extra files and code. We will place some stylesheets in a <strong class="source-inline">static</strong> folder, and we will serve them so that they can be used by other pages served by the same server: </p>
			<ol>
				<li value="1">By way of a first step, create a folder called <strong class="source-inline">stylish-welcome</strong> and, inside this folder, add a file called <strong class="source-inline">index.html</strong> and incorporate the following content:<p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html lang="en"&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">  &lt;meta charset="UTF-8"&gt;</p><p class="source-code">  &lt;title&gt;Welcome&lt;/title&gt;</p><p class="source-code">  &lt;link rel="stylesheet" href="/statics/body.css"&gt;</p><p class="source-code">  &lt;link rel="stylesheet" href="/statics/header.css"&gt;</p><p class="source-code">  &lt;link rel="stylesheet" href="/statics/text.css"&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code">  &lt;h1&gt;Hello World&lt;/h1&gt;</p><p class="source-code">  &lt;p&gt;May I give you a warm welcome&lt;/p&gt;</p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>As you can see, there are few differences compared with the previous HTML; we have a paragraph with some more text, wrapped by the <strong class="source-inline">&lt;p&gt;</strong> tag, and, inside the <strong class="source-inline">&lt;head&gt;</strong> tag, we include three links to external resources.</li>
				<li>Now, create a folder called <strong class="source-inline">public</strong> inside your <strong class="source-inline">stylish-welcome</strong> folder and create three files therein with these names and content:<p><strong class="source-inline">header.css</strong></p><p class="source-code">h1 {</p><p class="source-code">  color: brown;</p><p class="source-code">}</p><p><strong class="source-inline">body.css</strong></p><p class="source-code">body {</p><p class="source-code">  background-color: beige;</p><p class="source-code">}</p><p><strong class="source-inline">text.css</strong></p><p class="source-code">p {</p><p class="source-code">  color: coral;</p><p class="source-code">}</p></li>
				<li>Now, go back to your main project folder, <strong class="source-inline">stylish-welcome</strong>, and create the <strong class="source-inline">main.go</strong> file. The content at the start corresponds exactly to that in one of the previous exercises:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">   "log"</p><p class="source-code">   "net/http"</p><p class="source-code">)</p><p class="source-code">func main() {</p><p class="source-code">   http.HandleFunc("/", func (w http.ResponseWriter, r *http.Request) {</p><p class="source-code">  http.ServeFile(w, r, "./index.html")</p><p class="source-code">   })</p></li>
				<li>Now, add the following code to handle the static files:<p class="source-code">http.Handle(</p><p class="source-code">   "/statics/",</p><p class="source-code">   http.StripPrefix(</p><p class="source-code">  "/statics/",</p><p class="source-code">  http.FileServer(http.Dir("./public")),</p><p class="source-code">   ),</p><p class="source-code">)</p></li>
				<li>This code adds a handler to the "<strong class="source-inline">/statics/</strong>" path and it does so through an <strong class="source-inline">http.FileServer</strong> function, which returns a static file handler. </li>
				<li>This function requires a directory to scrape, and we pass one to it as a parameter: <p class="source-code">http.Dir("./public")</p></li>
				<li>This reads the local "<strong class="source-inline">public</strong>" folder that you created previously.</li>
				<li>Now, add this final part to the file:<p class="source-code">log.Fatal(http.ListenAndServe(":8080", nil))</p><p class="source-code">}</p></li>
				<li>Here again, the server gets created and the <strong class="source-inline">main()</strong> function is closed. If you now run your server, again with:<p class="source-code">  go run main.go</p></li>
				<li>You will now see the following:<div id="_idContainer275" class="IMG---Figure"><img src="image/B14177_15_26.jpg" alt="Figure 15.26: Styled home page&#13;&#10;"/></div><p class="figure-caption">Figure 15.26: Styled home page</p><p>So somehow, the HTML file is now getting the style from the style sheets you created at the beginning.</p></li>
				<li>Let's now examine how the files are injected. If you look back at the <strong class="source-inline">index.html</strong> file, you will see these lines:<p class="source-code">&lt;link rel="stylesheet" href="/statics/body.css"&gt;</p><p class="source-code">&lt;link rel="stylesheet" href="/statics/header.css"&gt;</p><p class="source-code">&lt;link rel="stylesheet" href="/statics/text.css"&gt;</p></li>
				<li>So essentially, we are looking for files under the path <strong class="source-inline">"/statics/"</strong>. Hence, you can go to these addresses and you will see:<div id="_idContainer276" class="IMG---Figure"><img src="image/B14177_15_27.jpg" alt="Figure 15.27: body CSS file &#13;&#10;"/></div><p class="figure-caption">Figure 15.27: body CSS file </p><div id="_idContainer277" class="IMG---Figure"><img src="image/B14177_15_28.jpg" alt="Figure 15.28: header CSS file &#10;"/></div><p class="figure-caption">Figure 15.28: header CSS file </p><div id="_idContainer278" class="IMG---Figure"><img src="image/B14177_15_29.jpg" alt="Figure 15.29: text CSS file &#13;&#10;"/></div><p class="figure-caption">Figure 15.29: text CSS file </p></li>
				<li>So, all the style sheets are served. Furthermore, you can even go here:<div id="_idContainer279" class="IMG---Figure"><img src="image/B14177_15_30.jpg" alt="Figure 15.30: Static folder content visible in the browser &#13;&#10;"/></div><p class="figure-caption">Figure 15.30: Static folder content visible in the browser </p></li>
				<li>And see all the files inside the <strong class="source-inline">public</strong> folder, served under the <strong class="source-inline">/statics/</strong> path. You can see that if you are looking for a simple static files server, Go allows you, with the help of a few lines of code, to create one, and, with a few more lines, you can make it production-ready.</li>
				<li>If you use Chrome, you can inspect with your mouse by right-clicking, or with any browser if you have a developer tool, and you will see something similar to this:</li>
			</ol>
			<div>
				<div id="_idContainer280" class="IMG---Figure">
					<img src="image/B14177_15_31.jpg" alt="Figure 15.31: Developer tools showing loaded scripts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.31: Developer tools showing loaded scripts</p>
			<p>You can see that the files have been loaded and that the styles are shown as computed from the stylesheet on the right.</p>
			<h1 id="_idParaDest-359"><a id="_idTextAnchor400"/>Getting Dynamic</h1>
			<p>Static assets are generally served as they are, but when you want to create a dynamic page, you might want to make use of an external template, which you can use on the fly, so that you can change the template without having to restart your server, or that you can load on startup, which means you will have to restart your server following any change (this is not strictly true, but we need some concepts of concurrent programming in order to make it happen). Loading a file at startup is executed simply for performance reasons. Filesystem operations are always the slowest, and even if Go is a fairly fast language, you might want to take performance into account when you want to serve your pages, especially if you have many requests from multiple clients.</p>
			<p>As you will recall from a previous topic, we used the standard Go templates to make dynamic pages. Now, we can use the template as an external resource and put our template code in an HTML file and load it. The template engine can parse it and then fill the blanks with the passed parameters. To do this, we can use the <strong class="source-inline">html/template</strong> function:</p>
			<p class="source-code">func ParseFiles(filenames ...string) (*Template, error)</p>
			<p>This can be called, for example, with:</p>
			<p class="source-code">template.ParseFiles("mytemplate.html")</p>
			<p>In addition, the template is loaded in memory and is ready to be used.</p>
			<p>Up to this point, you have been the sole user of your HTTP servers, but in an actual scenario, that is certainly not the case. In the following examples, we will look at performance and will use a resource loaded at startup.</p>
			<h2 id="_idParaDest-360">Activity 15.03: External Templa<a id="_idTextAnchor401"/>te</h2>
			<p>In this activity, you will create a welcome server, like the ones you created before, and you will have to use the template package, as you've done before. In this activity, however, we do not want you to create your template from a hardcoded string but from an HTML file, which will contain all the template placeholders.</p>
			<p>You should be able to complete this activity, making use of what you've learned so far in this chapter and in the previous one.</p>
			<p>This activity returns a pointer to a <strong class="source-inline">template</strong> and an error from a list of filenames. The error gets returned if any of the files do not exist or if the format of the template is wrong. In any case, do not concern yourself with the possibility of adding multiple files. Stick with one.</p>
			<p>Here are the steps to complete the activity:</p>
			<ol>
				<li value="1">Create a folder for your project.</li>
				<li>Create a template with a name such as <strong class="source-inline">index.html</strong> and fill it with standard HTML code, with a welcome message and a placeholder for the name. Make sure that if the name is empty, the message inserts the word <strong class="source-inline">visitor</strong> where the name is supposed to be.</li>
				<li>Create your <strong class="source-inline">main.go</strong> file and add to it the right package and imports.</li>
				<li>In the <strong class="source-inline">main.go</strong> file, create a <strong class="source-inline">struct</strong> holding a name that can be passed to a template.</li>
				<li>Create a template from a file using your <strong class="source-inline">index.html</strong> file.</li>
				<li>Create something that's able to handle the HTTP requests and use the <strong class="source-inline">querystring</strong> to receive parameters and display the data through the template created previously.</li>
				<li>Set all the paths to the server to use the function or handler created in the previous step and then create the server.</li>
				<li>Run the server and check the result.<p>The output will be as follows:</p></li>
			</ol>
			<p><a id="_idTextAnchor402"/></p>
			<div>
				<div id="_idContainer281" class="IMG---Figure">
					<img src="image/B14177_15_32.jpg" alt="Figure 15.32: Anonymous visitor page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.32: Anonymous visitor page</p>
			<p>And the visitor page including the name will look something like the following screenshot:</p>
			<div>
				<div id="_idContainer282" class="IMG---Figure">
					<img src="image/B14177_15_33.jpg" alt="Figure 15.33: Visitor page with the name &quot;Will&quot;&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.33: Visitor page with the name "Will"</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The solution for this activity can be found on page 763</p>
			<p>In this activity, you learned how to create a templated HTTP handler as a struct that can be initialized with any external template. You can now create multiple pages, instantiating the same struct with different templates of your choice.</p>
			<h1 id="_idParaDest-361"><a id="_idTextAnchor403"/>HTTP Methods</h1>
			<p>Up to this point, you've checked the results of your exercises and activities through your web browser, just visiting an address, your localhost, and getting some results back in the form of a web page. This way of consuming an HTTP server utilizes what is known as the <strong class="source-inline">GET</strong> method. You have seen the methods when you worked with the HTTP clients, which are the only way to use anything other than <strong class="source-inline">GET</strong> or <strong class="source-inline">POST</strong>. Through your web browser, however, you can also use the <strong class="source-inline">POST</strong> method, which is often used in order to send form data. It is possible to send form data through <strong class="source-inline">GET</strong>, but this method pollutes the URL with parameters and has some limitations in terms of the size of the data that can be sent. </p>
			<p>There are other methods that are often used, these being <strong class="source-inline">PUT</strong> and <strong class="source-inline">DELETE</strong>, but you need a specific client to utilize them. That is why a set of these four methods is used in order to build what is called a <strong class="source-inline">REST</strong> API. There are other methods, but it is beyond the scope of this book to dig into all the HTTP methods, focusing instead on the ones that are most commonly used. A <strong class="source-inline">REST</strong> API  is essentially a set of <em class="italic">paths</em> and methods that respond to specific requests. An HTTP server exposing a <strong class="source-inline">REST</strong> API is called a <strong class="source-inline">REST server</strong>. In order to understand why different methods are available, you need to understand how are they used. If you need to request some data, you are trying to get this data back, hence, the <strong class="source-inline">GET</strong> method is the most appropriate. If, instead, you want to modify a resource you are already familiar with, you want to put some specific values in a known location, you will use the <strong class="source-inline">PUT</strong> method, which essentially changes the state of the server in a known place. If you need to somehow modify the state of the server, you need to search for the resources to modify. For example, if you do not know their IDs, you will use the <strong class="source-inline">POST</strong> method. This is why you will often find online that the most common explanation for when to use <strong class="source-inline">POST</strong> and <strong class="source-inline">PUT</strong> is that the former is used to add resources, while the latter is used to update resources. Although this is most often true, it is not always the case, as you may also perform updates with the <strong class="source-inline">POST</strong> method.</p>
			<p>In the next exercise, you will see how to use the different methods, <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong>, to do different things with the same function. Note that in general, you might use more sophisticated external libraries to have more elegant code, but here, we are looking at how to do the basics and show how the standard Go library already offers us much in terms of helping us to do our work.</p>
			<h2 id="_idParaDest-362"><a id="_idTextAnchor404"/>Exercise 15.07: Completing a Questionnaire</h2>
			<p>In this exercise, you will build a form and you will send the data to another page. The form will contain questions such as your name, surname, and age, and this data will be sent to another page, which will display them. You will make use of what you've already learned, plus you'll see how to grab <strong class="source-inline">posted</strong> parameters from your <strong class="source-inline">HTTP</strong> request.</p>
			<ol>
				<li value="1">First of all, create a folder ca<a id="_idTextAnchor405"/>lled <strong class="source-inline">questionnaire</strong> and, inside this folder, incorporate a file called <strong class="source-inline">index.html</strong> with the following content:<p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html lang="en"&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">  &lt;meta charset="UTF-8"&gt;</p><p class="source-code">  &lt;title&gt;Welcome&lt;/title&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code">  &lt;h1&gt;Details&lt;/h1&gt;</p><p class="source-code">  &lt;ul&gt;</p><p class="source-code">  &lt;li&gt;Name: {{.Name}}&lt;/li&gt;</p><p class="source-code">  &lt;li&gt;Surname: {{.Surname}}&lt;/li&gt;</p><p class="source-code">  &lt;li&gt;Age: {{.Age}}&lt;/li&gt;</p><p class="source-code">  &lt;/ul&gt;</p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>This is a normal template displaying items of personal information. If any data is missing, we simply display it as empty strings without hiding them.</li>
				<li>Now, create a file called <strong class="source-inline">form.html</strong> and add the following content:<p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html lang="en"&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">  &lt;meta charset="UTF-8"&gt;</p><p class="source-code">  &lt;title&gt;Form&lt;/title&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code">  &lt;form method="post" action="/"&gt;</p><p class="source-code">  &lt;ul&gt;</p><p class="source-code">   &lt;li&gt;Name: &lt;input type="text" name="name"&gt;&lt;/li&gt;</p><p class="source-code">  &lt;li&gt;Surname: &lt;input type="text" name="surname"&gt;&lt;/li&gt;</p><p class="source-code">  &lt;li&gt;Age: &lt;input type="text" name="age"&gt;&lt;/li&gt;</p><p class="source-code">  &lt;li&gt;&lt;input type="submit" name="send" value="send"&gt;&lt;/li&gt;</p><p class="source-code">  &lt;/ul&gt;</p><p class="source-code">  &lt;/form&gt;</p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>This is another page inside a form, with three text inputs and a button. The input fields represent the details we want to send. Note that the form has the action set to <strong class="source-inline">"/", </strong>which means that when clicking the button, the page gets redirected to the main path, but will transport the dataset in the form. The method attribute is set to <strong class="source-inline">post,</strong> which is the HTTP method discussed earlier.</li>
				<li>You now have to create the actual server in Go. Create a <strong class="source-inline">main.go</strong> file and add the following:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">   "html/template"</p><p class="source-code">   "log"</p><p class="source-code">   "net/http"</p><p class="source-code">)</p></li>
				<li>Then, create the struct for the template:<p class="source-code">type Visitor struct {</p><p class="source-code">   Name string</p><p class="source-code">   Surname string</p><p class="source-code">   Age string</p><p class="source-code">}</p><p>This holds all the attributes required for the template.</p></li>
				<li>Then, execute the following command:<p class="source-code">type Hello struct {</p><p class="source-code">   tpl *template.Template</p><p class="source-code">}</p><p>This holds the template, as seen previously.</p></li>
				<li>At this point, you need to create the <strong class="source-inline">handler</strong> function for the handler, so add the following:<p class="source-code">func (h Hello) ServeHTTP(w http.ResponseWriter, r *http.Request) {</p><p class="source-code">   vst := Visitor{}</p><p>Here, a new empty visitor is created.</p></li>
				<li>Check whether the request is a <strong class="source-inline">Post</strong> request, so you need to add:<p class="source-code">if r.Method == http.MethodPost {</p><p>This checks the method against a constant provided by the Go <strong class="source-inline">http</strong> package.</p></li>
				<li>Parse the form:<p class="source-code">   err := r.ParseForm()</p><p class="source-code">   if err != nil {</p><p class="source-code">  w.WriteHeader(400)</p><p class="source-code">  return</p><p class="source-code">   }</p></li>
				<li>If an error occurs when parsing the form, we return with a <strong class="source-inline">400</strong> code, which is a bad request.</li>
				<li>If the form gets parsed correctly, we can proceed, so add the following:<p class="source-code">   vst.Name =  r.Form.Get("name")</p><p class="source-code">   vst.Surname = r.Form.Get("surname")</p><p class="source-code">   vst.Age = r.Form.Get("age")</p><p class="source-code">}</p><p>Here, all the parameters from the form get assigned to the visitor's attribute. We then close the <strong class="source-inline">if</strong> statement and go to the common part of the handler function.</p></li>
				<li>As we have a visitor, empty or not depending on whether the form has been posted and with what values, we can finally return the page, so write:<p class="source-code">   h.tpl.Execute(w, vst)</p><p class="source-code">}</p></li>
				<li>We need to have a way to create the handler, so, as you've done before, add the following function:<p class="source-code">func NewHello(tplPath string) (*Hello, error){</p><p class="source-code">   tmpl, err := template.ParseFiles(tplPath)</p><p class="source-code">   if err != nil {</p><p class="source-code">  return nil, err</p><p class="source-code">   }</p><p class="source-code">   return &amp;Hello{tmpl}, nil</p><p class="source-code">}</p></li>
				<li>At this point, you can write the <strong class="source-inline">main()</strong> function, which creates the handler, assigns it to the main path, and then assigns the static <strong class="source-inline">form.html </strong>file to the <strong class="source-inline">/form</strong> path:<p class="source-code">func main() {</p><p class="source-code">   hello, err := NewHello("./index.html")</p><p class="source-code">   if err != nil {</p><p class="source-code">  log.Fatal(err)</p><p class="source-code">   }</p><p class="source-code">   http.Handle("/", hello)</p><p class="source-code">   http.HandleFunc("/form", func(writer http.ResponseWriter, request *http.Request) {</p><p class="source-code">  http.ServeFile(writer, request, "./form.html")</p><p class="source-code">   })</p><p class="source-code">   log.Fatal(http.ListenAndServe(":8080", nil))</p><p class="source-code">}</p></li>
				<li>Run your server, you will see the following by going to the main page:<div id="_idContainer283" class="IMG---Figure"><img src="image/B14177_15_34.jpg" alt="Figure 15.34: Empty details page&#13;&#10;"/></div><p class="figure-caption">Figure 15.34: Empty details page</p></li>
				<li>If you go to the <strong class="source-inline">/form</strong> path, you'll see:<div id="_idContainer284" class="IMG---Figure"><img src="image/B14177_15_35.jpg" alt="Figure 15.35: Empty form page&#13;&#10;"/></div><p class="figure-caption">Figure 15.35: Empty form page</p></li>
				<li>And if you fill the data:<div id="_idContainer285" class="IMG---Figure"><img src="image/B14177_15_36.jpg" alt="Figure 15.36: Filled form page&#13;&#10;"/></div><p class="figure-caption">Figure 15.36: Filled form page</p></li>
				<li>And then press the <strong class="source-inline">send</strong> button, you will be redirected to this page:</li>
			</ol>
			<div>
				<div id="_idContainer286" class="IMG---Figure">
					<img src="image/B14177_15_37.jpg" alt="Figure 15.37: Page with details added&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.37: Page with details added</p>
			<p>This, again, is the main page with the details set via the parameters you put into the form.</p>
			<h1 id="_idParaDest-363"><a id="_idTextAnchor406"/>JSON loads</h1>
			<p>Not all HTTP servers are meant to be used by a browser and a human user. Very often, we have different software programs communicating with each other. These programs need to send messages to one another through a commonly accepted format, one of these being JSON. This stands for JavaScript Object Notation, which essentially means that it mimics how objects are created directly in JavaScript (another programming language). It is a simple format, not particularly verbose, and is easy to parse by a piece of software and easy to read for a human. As a user, however, you can use any one of the many tools to send and receive JSON payloads, two of the most common ones being <strong class="bold">Insomnia</strong> and <strong class="bold">Postman</strong>, which you can easily find online at <a href="https://packt.live/2RY13Dt">https://packt.live/2RY13Dt</a> and <a href="https://packt.live/2RY13Dt">https://packt.live/2RY13Dt</a>.</p>
			<p>They are both free and available for different platforms. You could also use <strong class="source-inline">curl</strong> as a command-line tool, but this becomes more complicated.</p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor407"/>Exercise 15.08: Building a Server That Accepts JSON Requests</h2>
			<p>In this exercise, you will build a server that accepts a JSON message and will respond with another JSON message. You will not be able to use your browser to test it, but you can do it with a client such as <strong class="bold">Insomnia</strong> or <strong class="bold">Postman</strong>. The example screenshots will be provided using <strong class="bold">Insomnia</strong>, so it would be good for you to use the same. The server you will build accepts a message with a name and surname, and returns a message with some personalized greetings:</p>
			<ol>
				<li value="1">Create a folder called <strong class="source-inline">json-server</strong> and add a file to it called <strong class="source-inline">main.go</strong>. Start adding packages and imports to the file:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">   "encoding/json"</p><p class="source-code">   "fmt"</p><p class="source-code">   "log"</p><p class="source-code">   "net/http"</p><p class="source-code">)</p><p>Here, the packages imported are customary for HTTP programming, for logging, for formatting strings, and, of course, for JSON encoding. </p></li>
				<li>After this, you need to create models for the incoming and outcoming messages, so write the following:<p class="source-code">type Request struct {</p><p class="source-code">   Name string</p><p class="source-code">   Surname string</p><p class="source-code">}</p><p class="source-code">type Response struct {</p><p class="source-code">   Greeting string</p><p class="source-code">}</p><p>These are pretty straightforward structs, including only what we need.</p></li>
				<li>Now, add the <strong class="source-inline">main</strong> function:<p class="source-code">func main() {</p></li>
				<li>And now set the function to handle the JSON messages:<p class="source-code">   http.HandleFunc("/", func(wr http.ResponseWriter, req *http.Request) {</p><p class="source-code">  decoder := json.NewDecoder(req.Body)</p><p>As you can see, the first thing inside the function is to create a JSON decoder, which will decode the request's body.</p></li>
				<li>As a next step, write the following:<p class="source-code">var data Request</p><p class="source-code">err := decoder.Decode(&amp;data)</p><p class="source-code">if err != nil {</p><p class="source-code">   wr.WriteHeader(400)</p><p class="source-code">   return</p><p class="source-code">}</p></li>
				<li>Here, we define a data variable of the <strong class="source-inline">Request</strong> type and we decode the body of the HTTP request into it. In case of any error, we return a <strong class="source-inline">400</strong> code for a bad request.</li>
				<li>Once the data has been decoded correctly, you can now use this data to create the response:<p class="source-code">rsp := Response{Greeting: fmt.Sprintf("Hello %s %s", data.Name, data.Surname)}</p></li>
				<li>Here, the name and surname from the request are combined in a personalized greeting message.</li>
				<li>All that is now left is to send the message back to the requester:<p class="source-code">   bts, err := json.Marshal(rsp)</p><p class="source-code">   if err != nil {</p><p class="source-code">  wr.WriteHeader(400)</p><p class="source-code">  return</p><p class="source-code">   }</p><p class="source-code">   wr.Write(bts)</p><p class="source-code">})</p></li>
				<li>Here, the response is encoded into a JSON string and is sent, writing it as a slice of bytes into the response writer. You can now run the server and open <strong class="source-inline">Insomnia</strong>:</li>
				<li>Now, create the <strong class="source-inline">main()</strong> function to serve the pages:<p class="source-code">func main() {</p><p class="source-code">  http.HandleFunc("/", Hello)</p><p class="source-code">  log.Fatal(http.ListenAndServe(":8080", nil))</p><p class="source-code">}</p><p>Running the preceding code produces the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer287" class="IMG---Figure">
					<img src="image/B14177_15_38.jpg" alt="Figure 15.38: Insomnia response&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.38: Insomnia response</p>
			<p>As you can see, you can make a <strong class="source-inline">post</strong> request with Insomnia and send a JSON string to your server. On the right, you will see the response as a JSON document.</p>
			<h1 id="_idParaDest-365"><a id="_idTextAnchor408"/>Summary</h1>
			<p>In this chapter, you've been introduced to the server side of web programming. You've learned how to accept requests from HTTP clients and respond in an appropriate manner. You've learned how to separate the possible requests into different areas of an HTTP server via paths and sub-paths. For this, you used a simple routing mechanism with the standard <strong class="source-inline">Go HTTP</strong> package. You've seen how to return your response in order to suit different consumers: JSON responses for synthetic clients, and HTML pages for human access. You've seen how to use templates in order to format your plain text and HTML messages, using the standard templating package. You've learned how to serve and use static resources, serving them directly through a default file server or through a template object. You've also learned what a <strong class="source-inline">REST</strong> service is, and although we have not built one together, you have all the knowledge necessary to create one, provided you follow the description you've been given. At this stage, you know all the basics for building production-grade HTTP servers, although you might want to use some external libraries to facilitate your hello world example, facilitating better routing by using something such as <strong class="source-inline">gorilla mux</strong> or, generally, the entire <strong class="source-inline">gorilla</strong> package, which is a low-level abstraction on top of the <strong class="source-inline">http</strong> package. You could use <strong class="source-inline">hero</strong> as a template engine to make your page rendering faster. One thing to mention is that you can make pretty much stateless services with what you've learned in this chapter, but you cannot create a production-grade stateful server at the moment as you do not know how to handle concurrent requests. This means that our <strong class="source-inline">views counter</strong> is not suitable for a production server yet, but this will be the subject of another chapter.</p>
			<p>In the next chapter, you will see how Go leverages the system of Goroutines to handle multiple work at the same time. This feature is very important, and you can apply it to HTTP servers and other types of projects where you have many concurrent users or whenever you want to do a lot of things at the same time.</p>
		</div>
	</body></html>