- en: 15\. HTTP Servers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15. HTTP 服务器
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to different ways of creating an HTTP server in
    order to accept requests from the internet. You will be able to understand how
    a website can be accessed and how it can respond to a form. You will also learn
    how to respond to requests from another software program.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍创建 HTTP 服务器以接受来自互联网的请求的不同方法。您将能够理解网站是如何被访问的，以及它如何响应一个表单。您还将学习如何响应来自另一个软件程序的请求。
- en: You'll be able to create an HTTP server rendering a simple message. You will
    learn how to create an HTTP server rendering complex data structures which serves
    local static files. Further you will create an HTTP server rendering dynamic pages
    and work with different ways of routing. By the end of this chapter you will also
    learn to create a REST service, accept data through a form, and accept JSON data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您将能够创建一个渲染简单消息的 HTTP 服务器。您将学习如何创建一个渲染复杂数据结构并服务于本地静态文件的 HTTP 服务器。进一步，您将创建一个渲染动态页面并处理不同路由方式的
    HTTP 服务器。到本章结束时，您还将学习如何创建 REST 服务，通过表单接收数据，以及接收 JSON 数据。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we saw how to contact a remote server in order to obtain
    some information, but now we will dig into how the remote server is created, so
    if you already know how to request information, now you will see how to reply
    to these requests.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何联系远程服务器以获取一些信息，但现在我们将深入了解远程服务器是如何创建的，所以如果你已经知道如何请求信息，现在你将看到如何回复这些请求。
- en: A web server is a program that uses the HTTP protocol, hence, the HTTP server,
    to accept requests from any HTTP client (web browser, another program, and so
    on) and respond to them with an appropriate message. When we browse the internet
    with our browser, it will be an HTTP server that will send an HTML page to our
    browser and we will be able to see it. In some other cases, a server will not
    return an HTML page but a different message, appropriate to the client.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器是一个使用 HTTP 协议的程序，因此，HTTP 服务器用于接受来自任何 HTTP 客户端（网页浏览器、另一个程序等）的请求，并以适当的消息响应它们。当我们用浏览器浏览互联网时，它将是一个
    HTTP 服务器，它会向我们的浏览器发送一个 HTML 页面，我们就能看到它。在某些其他情况下，服务器不会返回一个 HTML 页面，而是返回一个适合客户端的不同消息。
- en: Some HTTP servers provide an API that can be consumed by another program. Think
    of when you want to register with a website, and you are asked if you want to
    sign up through Facebook or Google. This means that the website you want to register
    with will consume a Google or Facebook API to get your details. These APIs generally
    respond with a structured text, which is a text representing a complex data structure.
    The way these servers expect the requests can be different. Some expect the same
    type of structured messages they return, while some provide what is called a REST
    API, which is quite strict with the HTTP methods used and expects inputs in the
    form of URL parameters or values, like the ones in a web form.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 HTTP 服务器提供了一个可以被另一个程序使用的 API。想想当你想要注册一个网站时，你会被问是否想要通过 Facebook 或 Google 注册。这意味着你想要注册的网站将消耗一个
    Google 或 Facebook API 来获取你的详细信息。这些 API 通常会以结构化文本的形式响应，这是一种表示复杂数据结构的文本。这些服务器期望请求的方式可能不同。有些期望返回相同类型的结构化消息，而有些提供所谓的
    REST API，它对使用的 HTTP 方法非常严格，并期望以 URL 参数或值的形式输入，就像网页表单中的那些。
- en: How to Build a Basic Server
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何构建基本服务器
- en: The simplest HTTP server that we can create is a Hello World server. This is
    a server that will return a simple message "Hello World" and will not do anything
    else. It is not very useful, but it is a starting point to see what Go default
    packages give us and is the basis for any other more complex server. The aim is
    to have a server that runs on a specific port on your machine's localhost and
    accepts any path under it. Accepting any path means that when you test the server
    with your browser, it will always return the "Hello World" message and a status
    code of 200\. Of course, we could return any other message, but, for historical
    reasons, the simplest project you learn when you study programming is always some
    sort of software returning the message "Hello World". In this case, we will see
    how this can be done and then visualized in a normal browser, before perhaps being
    put on the internet and shared with billions of users, although users may, in
    practice, prefer a more useful server. Let's say this is the most basic HTTP server
    you can create.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建的最简单的HTTP服务器就是一个Hello World服务器。这是一个将返回简单消息“Hello World”且不会做其他任何事情的服务器。它并不非常实用，但它是了解Go默认包提供的内容的起点，也是任何更复杂服务器的基石。目标是创建一个在您的机器的localhost上的特定端口运行的服务器，并接受其下的任何路径。接受任何路径意味着当您用浏览器测试服务器时，它总是会返回“Hello
    World”消息和状态码200。当然，我们可以返回任何其他消息，但出于历史原因，您在学习编程时学习的最简单的项目总是某种返回“Hello World”消息的软件。在这种情况下，我们将看到如何实现并在普通浏览器中可视化，然后可能将其放在互联网上并与数十亿用户分享，尽管在实践中，用户可能更喜欢一个更有用的服务器。让我们说这是您可以创建的最基本的HTTP服务器。
- en: HTTP Handler
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP处理器
- en: 'In order to react to an HTTP request, we need to write something that, we usually
    say, handles the request; hence, we call this something a handler. In Go, we have
    several ways to do that, and one is to implement the handler interface of the
    http package. This interface has one method that is pretty self-explanatory, and
    this is as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了响应HTTP请求，我们需要编写一些通常所说的处理请求的内容；因此，我们称这个内容为处理器。在Go语言中，我们有几种实现处理器接口的方法，其中之一是实现http包的处理器接口。这个接口有一个相当直观的方法，如下所示：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'So, whenever we need to create a handler for HTTP requests, we can create a
    struct including this method and we can use it to handle an HTTP request. For
    example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次我们需要为HTTP请求创建一个处理器时，我们都可以创建一个包含此方法的struct，并可以使用它来处理HTTP请求。例如：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is a valid HTTP handler and you can use it this way:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的HTTP处理器，您可以使用它这样：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `ListenAndServe()` is a function that will use our handler to serve the
    requests; any struct implementing the handler interface will be fine. However,
    we need to let our server do something.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ListenAndServe()`是一个函数，它将使用我们的处理器来处理请求；任何实现了处理器接口的结构体都是可以的。然而，我们需要让我们的服务器做些事情。
- en: 'As you can see, the `ServeHTTP` method accepts a `ResponseWriter` and a `Request`
    object. You can actually use them in order to capture parameters from the request
    and write messages to the response. The simplest thing, for example, is to let
    our server return a message:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`ServeHTTP`方法接受一个`ResponseWriter`和一个`Request`对象。您实际上可以使用它们来从请求中捕获参数并将消息写入响应。例如，最简单的事情就是让我们的服务器返回一条消息：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `ListenAndServe` method might return an error. If this happens, we most
    likely would like the execution of our program to halt, so one common practice
    is to wrap this function call with a fatal log:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListenAndServe`方法可能会返回一个错误。如果发生这种情况，我们很可能希望程序执行停止，因此一个常见的做法是将这个函数调用用致命日志包装起来：'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will halt the execution and print the error message returned by the `ListenAndServe`
    function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使执行停止并打印出`ListenAndServe`函数返回的错误信息。
- en: 'Exercise 15.01: Creating a Hello World Server'
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.01：创建一个Hello World服务器
- en: Let's start building a simple Hello World HTTP server on the basis of what you've
    learned in the previous block.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从之前的学习内容出发，开始构建一个简单的Hello World HTTP服务器。
- en: 'The first thing to do is to create a folder called `hello-world-server`. You
    can do this via the command line or you can create it with your favorite editor.
    Inside the folder, create a file called `main.go`. We will not use any external
    library here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的事情是创建一个名为`hello-world-server`的文件夹。您可以通过命令行或使用您喜欢的编辑器创建它。在文件夹内，创建一个名为`main.go`的文件。在这里，我们不会使用任何外部库：
- en: 'Add the package name:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加包名：
- en: '[PRE5]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This tells the compiler that this file is an entry point for a program that
    can be executed.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这告诉编译器该文件是一个程序的入口点，可以执行。
- en: 'Import the necessary packages:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的包：
- en: '[PRE6]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, create a `handler`, the struct that will handle the requests:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个`handler`，这个结构将处理请求：
- en: '[PRE7]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we have our handler, create the `main()` function, which will start
    the server and produce a web page with our message:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了我们的`handler`，创建`main()`函数，它将启动服务器并生成带有我们消息的网页：
- en: '[PRE8]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The entire file should look like this:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 整个文件应该看起来像这样：
- en: '[PRE9]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you now go to your Terminal, inside your `hello-world-server` folder, and
    type in the following command:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在进入你的终端，在你的`hello-world-server`文件夹内，并输入以下命令：
- en: '[PRE10]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You should just see nothing; the program has started.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该什么也看不到；程序已经开始运行。
- en: 'If you now open your browser at the following address:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你现在在以下地址打开你的浏览器：
- en: '[PRE11]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see a page with a big message:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该看到一个带有大消息的页面：
- en: '![Figure 15.01: Hello world server'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.01：Hello world服务器'
- en: '](img/B14177_15_01.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_01.jpg)'
- en: 'Figure 15.01: Hello world server'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.01：Hello world服务器
- en: 'If you now try to change path and go to */page1*, you will again see the following
    message:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试更改路径并访问*/page1*，你将再次看到以下信息：
- en: '![Figure 15.02: Hello world server sub-pages'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.02：Hello world服务器子页面'
- en: '](img/B14177_15_02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_02.jpg)'
- en: 'Figure 15.02: Hello world server sub-pages'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.02：Hello world服务器子页面
- en: Congratulations! This is your first HTTP server.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！这是你的第一个HTTP服务器。
- en: In this exercise, we have created a basic hello world server, which returns
    the message "Hello World" in response to any request on any sub-address.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建了一个基本的hello world服务器，它对任何子地址上的任何请求都返回“Hello World”消息。
- en: Simple Routing
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单路由
- en: 'The server built just now in the previous exercise does not do much. It just
    responds with a message and we cannot ask anything else. Before we can make our
    server more dynamic, let''s imagine we want to create an online book and we want
    to be able to select a chapter just changing the URL. At the moment, if we browse
    the following pages:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中刚刚构建的服务器并不做什么。它只是响应一条消息，我们无法询问其他任何内容。在我们能够使我们的服务器更加动态之前，让我们想象我们想要创建一个在线书籍，并且我们想要能够通过更改URL来选择章节。目前，如果我们浏览以下页面：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We always see the same message, but we now want to associate different messages
    with these different paths on our server. We will do this by introducing some
    simple routing to our server.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是看到相同的信息，但现在我们想要将不同的消息与服务器上的不同路径关联起来。我们将通过向服务器引入一些简单的路由来实现这一点。
- en: 'A path is what you see after the `8080` in the URL; it can be one number, a
    word, a set of numbers or character groups separated by a "/". In order to do
    this, we will use another function of the net/http package, which is:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 路径是你看到URL中的`8080`之后的内容；它可以是单个数字、一个单词、一组由斜杠分隔的数字或字符组。为了做到这一点，我们将使用net/http包的另一个函数，它是：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the pattern is the path we want to be served by the `handler` function.
    Note how the `handler` function signature has the exact same parameters as the
    `ServeHTTP` method, which you added to the `hello` struct in the previous exercise.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，模式是我们想要由`handler`函数服务的路径。注意`handler`函数签名与你在上一个练习中添加到`hello`结构中的`ServeHTTP`方法具有完全相同的参数。
- en: As an example, the server built in *Exercise 15.01* is not very useful, but
    we can transform it into something much more useful with the addition of pages
    other than the `hello world` one, and, in order to do so, we need to do some basic
    routing. The aim here is to write a book, and the book must have a welcome page
    with the title, and a first chapter. The book title is `hello world`, so we can
    keep what we did before. The first chapter will have a heading stating `Chapter
    1`. The book is a work in progress, so it does not matter that the content is
    still poor; what we require is the ability to select the chapter, and we will
    then add the content later.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*练习15.01*中构建的服务器并不很有用，但我们可以通过添加除了`hello world`之外的其他页面来将其转变为更有用的东西，为了做到这一点，我们需要做一些基本的路由。这里的目的是写一本书，这本书必须有一个带有标题的欢迎页面，以及第一章。书名是`hello
    world`，所以我们可以保留之前所做的工作。第一章将有一个标题声明`第一章`。这本书还在进行中，所以内容仍然很贫乏并不重要；我们需要的是能够选择章节的能力，然后我们将在稍后添加内容。
- en: 'Exercise 15.02: Routing Our Server'
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.02：路由我们的服务器
- en: 'We are now going to modify the code in *Exercise 15.01* to support different
    paths. If you haven''t gone through the previous exercise, do it now so that you''ll
    have a basic framework for this exercise:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将修改*练习15.01*中的代码以支持不同的路径。如果你还没有完成前面的练习，现在就做，这样你将有一个这个练习的基本框架：
- en: 'Create a new folder and a `main.go` file and add the code from the previous
    exercise to the definition of the `main` function:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中创建一个 `main.go` 文件并将之前练习中的代码添加到 `main` 函数的定义中：
- en: '[PRE14]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create the `main()` function:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main()` 函数：
- en: '[PRE15]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, use `handle` to route "`/chapter1`" through a `handlefunc()` function:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 `handle` 将 "`/chapter1`" 通过一个 `handlefunc()` 函数路由：
- en: '[PRE16]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This means that we associate the path, `/chapter1`, with a function that returns
    a specific message.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着我们将路径 `/chapter1` 与返回特定信息的函数关联起来。
- en: 'Finally, set the server to listen to a port and to run the following command:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将服务器设置为监听端口并运行以下命令：
- en: '[PRE17]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, save your file and run the server again with:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，保存您的文件并再次使用以下命令运行服务器：
- en: '[PRE18]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, go to your browser and load the following URLs:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到您的浏览器并加载以下URL：
- en: '`http://localhost:8080`'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8080`'
- en: '`http://localhost:8080/chapter1`'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/chapter1`'
- en: 'The output for the home page is shown in the following screenshot:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图显示了主页的输出：
- en: '![Figure 15.03: Multi-page server – home page'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.03：多页服务器 – 主页'
- en: '](img/B14177_15_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_03.jpg)'
- en: 'Figure 15.03: Multi-page server – home page'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.03：多页服务器 – 主页
- en: 'And the output for page 1 is shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 页面1的输出如下截图所示：
- en: '![Figure 15.04: Multi-page server – chapter 1'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.04：多页服务器 – 第1章'
- en: '](img/B14177_15_04.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_04.jpg)'
- en: 'Figure 15.04: Multi-page server – chapter 1'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.04：多页服务器 – 第1章
- en: 'Note that they both still display the same message. This happens because we
    are setting our `hello` as the handler for our server, and this overrides our
    specific path. We can modify our code to look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它们仍然显示相同的信息。这是因为我们将我们的 `hello` 设置为服务器的处理器，这覆盖了我们的特定路径。我们可以修改我们的代码如下：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What happened here is that you removed the `hello` handler from being the main
    handler for our server and you associated this handler with the main `/` path:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 发生在这里的是，您从我们的服务器的主要处理器中移除了 `hello` 处理器，并将其与主要的 `/` 路径关联起来：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, you associated a `handler` function with the specific `/chapter1` path:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您将一个 `handler` 函数与特定的 `/chapter1` 路径关联：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, if you stop and then run our server again, you will see that the `/chapter1`
    path now returns the new message:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您停止并再次运行我们的服务器，您将看到 `/chapter1` 路径现在返回新的信息：
- en: '![Figure 15.05: Multi-page server repeated – chapter 1'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.05：多页服务器重复 – 第1章'
- en: '](img/B14177_15_05.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_05.jpg)'
- en: 'Figure 15.05: Multi-page server repeated – chapter 1'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.05：多页服务器重复 – 第1章
- en: In the meantime, all the other paths return the old `Hello World` message.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，所有其他路径都返回旧的 `Hello World` 信息。
- en: '![Figure 15.06: Multi-page server – base page'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.06：多页服务器 – 基础页面'
- en: '](img/B14177_15_06.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_06.jpg)'
- en: 'Figure 15.06: Multi-page server – base page'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.06：多页服务器 – 基础页面
- en: '![Figure 15.07: The page that is not set returns the default setting'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.07：未设置的页面返回默认设置'
- en: '](img/B14177_15_07.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_07.jpg)'
- en: 'Figure 15.07: The page that is not set returns the default setting'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.07：未设置的页面返回默认设置
- en: Handler versus Handler Function
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器与处理器函数
- en: As you may have noticed, we used two different functions before, `http.Handle`
    and `http.HandleFunc` , both of which have a path as their first parameter, but
    which differ in terms of the second parameter. These two functions both ensure
    that a specific path is handled by a function. `http.Handle`, however, expects
    `http.Handler` to handle the path, while `http.HandleFunc` expects a function
    to do the same.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已注意到的，我们之前使用了两个不同的函数，`http.Handle` 和 `http.HandleFunc`，这两个函数都以路径作为它们的第一个参数，但在第二个参数方面有所不同。这两个函数都确保特定的路径由一个函数处理。然而，`http.Handle`
    期望 `http.Handler` 处理路径，而 `http.HandleFunc` 期望一个函数来做同样的事情。
- en: 'As we''ve seen before, `http.Handler` is any struct having a method with this
    signature:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，`http.Handler` 是任何具有此签名的结构体：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So, in both cases, there will always be a function with `http.ResponseWriter`
    and `*http.Request` as parameters that will handle the path. As to when one or
    the other might be chosen may just be a matter of personal preference in many
    cases, but it might be important, when creating a complex project, for example,
    to choose the right method. Doing so will ensure that the structure of the project
    is optimal. Different routes may appear better organized if handled by handlers
    belonging to different packages, or might have to perform very few actions, as
    in our previous case; and a simple function might prove to be the ideal choice.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在两种情况下，都始终会有一个以 `http.ResponseWriter` 和 `*http.Request` 为参数的函数来处理路径。至于何时选择其中一个，在很多情况下可能只是个人偏好的问题，但在创建复杂项目时，例如，选择正确的方法可能很重要。这样做将确保项目的结构是最优的。不同的路由如果由属于不同包的处理程序处理，可能会显得更有组织，或者可能需要执行非常少的操作，就像我们之前的例子一样；而一个简单的函数可能就是理想的选择。
- en: In general, for simple projects where you have a handful of simple pages, you
    may opt for `HandleFunc`. For example, let's say you want to have static pages
    and there is no complex behavior in each page. In this case, it would be an overkill
    to use an empty struct just for returning a static text. The handler is more appropriate
    whenever you need to set some parameters, or if you want to keep track of something.
    As a general rule, let's say that if you have a counter, a `Handler` is the best
    choice because you can initialize a `struct` with a count of 0 and then increment
    it, but we will see this in *Activity 15.01*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于只有几个简单页面的简单项目，你可以选择 `HandleFunc`。例如，假设你想要有静态页面，并且每个页面没有复杂的行为。在这种情况下，仅仅为了返回静态文本而使用一个空的空结构体将是过度设计。当需要设置一些参数或想要跟踪某些内容时，处理程序更为合适。作为一个一般规则，如果我们说，如果你有一个计数器，`Handler`
    是最佳选择，因为你可以用一个计数为 0 的 `struct` 来初始化，然后增加它，但我们将这在 *活动 15.01* 中看到。
- en: 'Activity 15.01: Adding a Page Counter to an HTML Page'
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 15.01：向 HTML 页面添加页面计数器
- en: Imagine that you own a website with, say, three pages, where you are writing
    your book. You earn money depending on how many visits your website receives.
    In order to understand how popular your website is, and how much money you are
    earning, you need to keep track of the visits.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你拥有一个网站，比如有三个页面，你在上面写你的书。你的收入取决于你的网站访问量。为了了解你的网站有多受欢迎，以及你赚了多少钱，你需要跟踪访问量。
- en: In this activity, you will build an HTTP server with three pages, containing
    some content, and display, in each page, how many visits that page has had so
    far. You will use the `http.Handler` method, which, in this case, will help you
    to generalize your counter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将构建一个包含三个页面、一些内容的 HTTP 服务器，并在每个页面上显示该页面迄今为止的访问次数。你将使用 `http.Handler`
    方法，在这种情况下，这将帮助你泛化计数器。
- en: In order to display the dynamic value, you can use the `fmt.Sprintf` function
    in the `fmt` package, which prints and formats a message to a string. With this
    function, you can build a string containing characters and numbers. You can find
    all the information about this method online in the Go documentation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示动态值，你可以使用 `fmt` 包中的 `fmt.Sprintf` 函数，该函数将打印并格式化一条消息到字符串中。使用此函数，你可以构建包含字符和数字的字符串。你可以在
    Go 文档中找到有关此方法的所有信息。
- en: You will use everything you've learned so far, including how a struct is instantiated,
    how to set attributes of a struct, pointers, how to increase an integer, and,
    of course, everything you have learned about HTTP servers hitherto.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用迄今为止所学的一切，包括如何实例化结构体、如何设置结构体的属性、指针、如何增加一个整数，以及当然，你迄今为止所学的关于 HTTP 服务器的所有内容。
- en: 'Observing the following steps will provide an elegant and effective solution:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 观察以下步骤将提供一种优雅而有效的解决方案：
- en: Create a folder called `page-counter`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `page-counter` 的文件夹。
- en: Create a file called `main.go`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `main.go` 的文件。
- en: Add the necessary imports to the `http` and `fmt` packages.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `http` 和 `fmt` 包添加必要的导入。
- en: Define a struct called `PageWithCounter` with a `counter` as an integer attribute,
    a `content`, and a `heading` as a text attribute.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为 `PageWithCounter` 的结构体，其中包含一个整型属性 `counter`，一个 `content`，以及一个文本属性 `heading`。
- en: Add a `ServeHTTP` method to the struct, capable of displaying the content, the
    heading, and a message with the total number of views.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向结构体添加一个 `ServeHTTP` 方法，能够显示内容、标题以及总访问次数的消息。
- en: 'Create your `main` function and, inside, implement the following:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建你的 `main` 函数，并在其中实现以下内容：
- en: Instantiate three handlers of the `PageWithCounter` type, with `Hello World`,
    `Chapter 1`, and `Chapter 2` headings and some content.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化三个`PageWithCounter`类型的处理器，分别带有`Hello World`、`Chapter 1`和`Chapter 2`的标题和一些内容。
- en: Add the three handlers to the routes `/`, `/chapter1`, and `/chapter2`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三个处理器添加到路由`/`、`/chapter1`和`/chapter2`。
- en: Run the server on port `8080`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在端口`8080`上运行服务器。
- en: 'When you run the server, you should see the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行服务器时，你应该看到以下内容：
- en: '![Figure 15.08: Output on the browser when you run the server for the first
    time'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.08：第一次运行服务器时的浏览器输出'
- en: '](img/B14177_15_08.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_15_08.jpg)'
- en: 'Figure 15.08: Output on the browser when you run the server for the first time'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.08：第一次运行服务器时的浏览器输出
- en: 'If you refresh the page, you should see the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刷新页面，你应该看到以下内容：
- en: '![Figure 15.09: Output on the browser when you run the server for the second
    time'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.09：第二次运行服务器时的浏览器输出'
- en: '](img/B14177_15_09.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_15_09.jpg)'
- en: 'Figure 15.09: Output on the browser when you run the server for the second
    time'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.09：第二次运行服务器时的浏览器输出
- en: 'Next, navigate to Chapter 1 by typing `localhost:8080/chapter1` in the address
    bar. You should be able to see something along the lines of the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在地址栏中输入`localhost:8080/chapter1`以导航到第1章。你应该能看到以下类似的内容：
- en: '![Figure 15.10: Output on the browser when you visit the chapter1 page for
    the first time'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.10：第一次访问chapter1页面时的浏览器输出'
- en: '](img/B14177_15_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_15_10.jpg)'
- en: 'Figure 15.10: Output on the browser when you visit the chapter1 page for the
    first time'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.10：第一次访问chapter1页面时的浏览器输出
- en: 'Similarly, navigate to Chapter 2, and you should be able to see the following
    increment in terms of the number of views:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，导航到第2章，你应该能看到以下查看次数的增加：
- en: '![Figure 15.11: Output on the browser when you visit the chapter2 page for
    the first time'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.11：第一次访问chapter2页面时的浏览器输出'
- en: '](img/B14177_15_11.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_15_11.jpg)'
- en: 'Figure 15.11: Output on the browser when you visit the chapter2 page for the
    first time'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.11：第一次访问chapter2页面时的浏览器输出
- en: 'When you revisit Chapter 1, you should see an increase in the number of views
    as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你再次访问第1章时，你应该看到如下所示的查看次数增加：
- en: '![Figure 15.12: Output on the browser when you visit the chapter1 page for
    the second time'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.12：第二次访问chapter1页面时的浏览器输出'
- en: '](img/B14177_15_12.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14177_15_12.jpg)'
- en: 'Figure 15.12: Output on the browser when you visit the chapter1 page for the
    second time'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.12：第二次访问chapter1页面时的浏览器输出
- en: Note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 757
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第757页找到
- en: In this activity, you learned how to create a server that responds to different
    requests on different pages with a specific static text, along with a counter
    on each page, with each counter independent from the others.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你学习了如何创建一个服务器，该服务器能够对不同页面上的不同请求做出特定静态文本的响应，并在每个页面上都有一个计数器，每个计数器与其他计数器独立。
- en: Returning Complex Structures
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回复杂数据结构
- en: What we've seen hitherto is useful when building a website, even though, for
    this purpose, we still need to see how to better render HTML pages. You might
    want to use a framework such as **revel** or **gin** for this purpose, although
    plain Go with a few libraries is more than enough for a production-grade website.
    You will find, however, that HTTP servers are used not only for building websites,
    but also for building web services, and especially, nowadays, microservices. Although
    how to build a web service-based project is beyond the scope of this chapter and
    book, it is important for you to know how to let your HTTP server serve something
    that will not be consumed by a human through a browser, but by another program.
    You may already know what a web service is, but even if you do not, you might
    have to work on an existing project where you have to modify a web service. There
    are several ways to present a message to another program, which will be referred
    to as a client, but, in general, they will all involve some sort of structured
    texts, which can be parsed easily. The format could be an XML string, but the
    most common and lightweight format now used is JSON. In the next exercise, we
    will see how to build a data structure and send it to the client (aq browser or
    another program) in the form of a JSON string.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们所看到的内容在构建网站时是有用的，尽管，为了这个目的，我们仍然需要了解如何更好地渲染HTML页面。你可能想使用像 **revel** 或
    **gin** 这样的框架来完成这个任务，尽管纯Go加上几个库对于生产级别的网站来说已经足够了。然而，你会发现HTTP服务器不仅用于构建网站，还用于构建网络服务，尤其是现在，微服务。尽管如何构建基于网络服务的项目超出了本章和本书的范围，但了解如何让你的HTTP服务器为不会通过浏览器由人类消费，而是由另一个程序消费的内容提供服务是很重要的。你可能已经知道什么是网络服务，即使你不知道，你也可能需要在需要修改网络服务的现有项目上工作。有几种方式可以向另一个程序（称为客户端）传递消息，但通常，它们都将涉及某种形式的结构化文本，这些文本可以很容易地被解析。格式可以是XML字符串，但现在最常见且轻量级的格式是JSON。在下一个练习中，我们将看到如何构建一个数据结构并将其以JSON字符串的形式发送给客户端（无论是浏览器还是另一个程序）。
- en: 'Activity 15.02: Serving a Request with a JSON Payload'
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动15.02：使用JSON有效负载处理请求
- en: 'In this activity, you will create a data structure and you will serve it through
    an HTTP server. You will make use of what you have already learned about JSON
    and the encoding/decoding of structs, and you will combine it with what you''ve
    learned about HTTP servers. You might have guessed already, but in this exercise,
    you already have all the knowledge required and you should be able to complete
    it on your own. Let''s now build another book. The title and the chapters are
    the same, but this time we want to make it accessible to a program that will consume
    the pages on the server as JSON documents. The document will also include the
    number of views per chapter, so the code can make use of the one generated in
    *Activity 15.01*. The steps are as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将创建一个数据结构，并通过HTTP服务器提供服务。你将利用你已经学到的关于JSON和结构体的编码/解码的知识，并将其与关于HTTP服务器的知识结合起来。你可能已经猜到了，但在这个练习中，你已经拥有了完成它所需的所有知识，你应该能够独立完成它。现在让我们再建一本书。标题和章节都是相同的，但这次我们希望让它能够被一个程序访问，该程序将作为JSON文档消费服务器上的页面。该文档还将包括每个章节的查看次数，以便代码可以利用在
    *活动15.01* 中生成的代码。步骤如下：
- en: Create a new folder called `book-api`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹名为 `book-api`。
- en: Create a file called `main.go` in that folder.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件夹中创建一个名为 `main.go` 的文件。
- en: Add the required imports.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加所需的导入。
- en: Create a struct called `PageWithCounter` representing a book with a title, content,
    and a counter, with appropriate JSON tags, if necessary.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PageWithCounter` 的结构体，表示一个具有标题、内容和计数器的书籍，如果需要，可以添加适当的JSON标签。
- en: Add a `ServeHTTP` method to the struct, capable of displaying the content, the
    heading, and a message with the total number of views as a JSON document.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向结构体添加一个 `ServeHTTP` 方法，能够以JSON文档的形式显示内容、标题以及包含总查看次数的消息。
- en: Create the `main()` function.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `main()` 函数。
- en: Instantiate three handlers of the `PageWithCounter` type, with `Hello World`,
    `Chapter 1`, and `Chapter 2` headings and some content.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例化三个 `PageWithCounter` 类型的处理器，标题分别为 `Hello World`、`Chapter 1` 和 `Chapter 2`，并包含一些内容。
- en: Add the three handlers to the routes `/`, `/chapter1`, and `/chapter2`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三个处理器添加到路由 `/`、`/chapter1` 和 `/chapter2`。
- en: Run the server on port `8080`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在端口 `8080` 上运行服务器。
- en: 'Running your server, you should see the following for the assigned routes:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的服务器，你应该能看到分配的以下路由：
- en: '![Figure 15.13: Expected output when the handler is /'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.13：当处理器为/时的预期输出](img/B14177_15_13.jpg)'
- en: '](img/B14177_15_13.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: 'Figure 15.13: Expected output when the handler is /'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.13：当处理器为 / 时的预期输出
- en: '![Figure 15.14: Expected output when the handler is /chapter1'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.14：当处理器为 /chapter1 时的预期输出'
- en: '](img/B14177_15_14.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_14.jpg)'
- en: 'Figure 15.14: Expected output when the handler is /chapter1'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.14：当处理器为 /chapter1 时的预期输出
- en: '![Figure 15.15: Expected output when the handler is /chapter2'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.15：当处理器为 /chapter2 时的预期输出'
- en: '](img/B14177_15_15.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14177_15_15.jpg)'
- en: 'Figure 15.15: Expected output when the handler is /chapter2'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.15：当处理器为 /chapter2 时的预期输出
- en: In this activity, you've learned how to return complex structures through an
    HTTP server. Any kind of complex data structure can be served this way, using
    a standard format such as JSON.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你学习了如何通过HTTP服务器返回复杂结构。任何类型的复杂数据结构都可以通过这种方式提供，使用标准的格式，如JSON。
- en: Note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 761
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第761页找到
- en: Dynamic Content
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态内容
- en: 'A server that serves only static content is useful, but there is much more
    that can be done. An HTTP server can deliver content depending on a more granular
    request, which is done by passing some parameters to the server. There are many
    ways to do so, but one simple way is to pass parameters to a `querystring`. If
    the URL of the server is:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 仅提供静态内容的服务器是有用的，但可以做更多的事情。HTTP服务器可以根据更细粒度的请求提供内容，这是通过向服务器传递一些参数来完成的。有很多种方法可以做到这一点，但一种简单的方法是将参数传递给
    `querystring`。如果服务器的URL是：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can then add something like:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以添加如下内容：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, the part `?name=john` is called a `querystring` as it is a string representing
    a query. In this case, this `querystring` sets a variable called `name` with a
    value of `john`. This way of passing parameters is generally used with `GET` requests,
    while a `POST` request will generally make use of the body of the request in order
    to send parameters. This does not mean that a `GET` request does not have a body
    but is not the standard way to pass parameters to a `GET` request. We will begin
    by looking at how to accept parameters for a `GET` request, as this request is
    made by simply opening your browser on a specific address. We will see later how
    to handle a `POST` request through a form.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`?name=john` 这部分被称为 `querystring`，因为它是一个表示查询的字符串。在这种情况下，这个 `querystring`
    设置了一个名为 `name` 的变量，其值为 `john`。这种方式通常用于 `GET` 请求中传递参数，而 `POST` 请求通常使用请求体来发送参数。这并不意味着
    `GET` 请求没有请求体，但不是向 `GET` 请求传递参数的标准方式。我们将首先查看如何接受 `GET` 请求的参数，因为这种请求只需在特定地址上打开浏览器即可完成。我们将在稍后看到如何通过表单处理
    `POST` 请求。
- en: In the next exercise, you will be able to return different texts as responses
    to HTTP requests, where the text depends on what values the user puts in the `querystring`
    in the address bar.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将能够返回不同的文本作为对HTTP请求的响应，其中文本取决于用户在地址栏中的 `querystring` 中输入的值。
- en: 'Exercise 15.03: Personalized Welcome'
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习15.03：个性化欢迎
- en: 'In this exercise, we will again create an HTTP server that is able to cheer
    us, but instead of a general "`hello world`" message, we will provide a message
    depending on our name. The idea is that, by opening the browser on the server''s
    URL and adding a parameter called `name`, the server will welcome us with the
    message "`hello` ", followed by the value of the `name` parameter. The server
    is very simple and does not have sub-pages, but contains this dynamic element
    that constitutes a starting point for more complex situations:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将再次创建一个HTTP服务器，它能够为我们欢呼，但与一般的 "`hello world`" 消息不同，我们将提供一个根据我们的名字的消息。想法是，通过在服务器的URL上打开浏览器并添加一个名为
    `name` 的参数，服务器将用消息 "`hello` " 欢迎我们，后面跟着 `name` 参数的值。服务器非常简单，没有子页面，但包含这个动态元素，它是更复杂情况的一个起点：
- en: 'Create a new folder called `personalised-welcome` and, inside the folder, create
    a file called `main.go`. Inside the file, add the package name:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `personalised-welcome` 的新文件夹中创建一个名为 `main.go` 的文件。在文件中，添加包名：
- en: '[PRE25]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, add the required imports:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加所需的导入：
- en: '[PRE26]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: They are all the same imports used in the previous exercises and activities,
    no there is nothing new. We will not use handlers in this exercise as it is much
    smaller, but we will make use of the `http.handleFunc` function.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们都是之前练习和活动中使用的相同导入，没有新的内容。在这个练习中，我们不会使用处理器，因为它很小，但我们将使用 `http.handleFunc` 函数。
- en: 'Now, add the following code after the imports:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在导入之后添加以下代码：
- en: '[PRE27]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is the definition of a function that can be used as a handling function
    for an HTTP path.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是定义一个可以作为HTTP路径处理函数使用的函数。
- en: 'Now, save the query to a variable using the `Query` method URL from the request:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `Query` method on the `URL` object of the request returns a `map[string][]string`
    with all the parameters sent through the `querystring` in the URL. We then assign
    this map to a variable, `vl`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, we need to get the value of a specific parameter called `name`,
    so we get the value from the `name` parameter:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, we have an assignment to two variables, but only one value comes
    from `vl["name"]`. The second variable, `ok`, is a Boolean that tells us whether
    the "`name`" key exists.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the `name` parameter has not been passed and we want an error message to
    appear, add it if the variable is not found, in other words, if the `ok` variable
    is false:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The conditional code gets called if the key does not exist in the slice, and
    it writes a `400` code (bad request) to the header, as well as a message to the
    response writer stating that the name has not been sent as a parameter. We stop
    the execution with a `return` statement to prevent further actions.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, write the valid message to the response writer:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code formats a string and injects the name into it. The `fmt.Sprintf` function
    is used to format, while `strings.Join` is used in order to transform the `name`
    slice into a string. Notice that the `name` variable is set to the value of `vl["name"]`,
    but `vl` is a `map[string][]string`, which means that it is a map with string
    keys whose values are slices of strings; hence, `vl["name"]` is a slice of strings
    and needs to be transformed into a single string. The `strings.Join` function
    takes all the elements of the slice and builds a single string using `","` as
    a separator. Other characters could also have been used as separators.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last part of the file you have to write is:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As always, a `main()` function is created, and then the `Hello` function is
    associated with the path `"/"` and the server started. Here is the output of three
    different URLs, two valid ones, and one with a missing parameter:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.16: Server output when requesting the page with the name john'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_16.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.16: Server output when requesting the page with the name john'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.17: Server output when requesting the page with the name will'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_17.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.17: Server output when requesting the page with the name will'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.18: Server outputting an error message when requesting a page without
    a name'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_18.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.18: Server outputting an error message when requesting a page without
    a name'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Templating
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although JSON can be the best choice when complex data structures have to be
    shared across software programs, this is not the case, in general, when the HTTP
    server is supposed to be consumed by humans. In the previous exercises and activities,
    the chosen way to format a text has been the `fmt.Sprintf` function, which is
    good for formatting texts, but is simply insufficient when a more dynamic and
    complex text is required. As you will have noticed in the previous exercise, the
    message returned in case a name was passed as a parameter to the URL observed
    a specific pattern, and this is where a new concept comes in – the template. A
    template is a skeleton from which complex entities can be developed. Essentially,
    a template is like a text with some blanks, and a template engine will take some
    values and fill the blanks, as you can see in the following diagram:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.19: Templating example'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_19.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.19: Templating example'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `{{name}}` is a placeholder and, when a value is passed through
    to the engine, the placeholder is modified with that value.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: We see templates everywhere. We have templates for Word documents, where we
    just fill in what is missing to produce new documents that all differ from one
    another. A teacher might have some templates for their lessons and will develop
    different lessons from that same template. Go provides two different templating
    packages, one for texts and one for HTML. As we are working with HTTP servers
    and we want to produce a web page, we will use the HTML templating package, but
    the interface is the same for the text template library. Although the templating
    packages are good enough for any real-world application, there are also several
    other external packages that can be used in order to improve performance. One
    of these is the `hero` template engine, which is much faster than the standard
    Go templating package.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go templating package provides a placeholder language where we can use
    things such as:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A simple search and replace block, but more complex situations can be handled
    via conditionals:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, if an `age` parameter is not null, the template will have `Hello`; otherwise
    it has `bye`. Each conditional needs an `{{end}}` placeholder to determine its
    ending.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables in a template, however, do not need to be simple numbers or strings;
    they can be objects. In this case, if we have a struct with a field called `ID`,
    we can reference this field in the template this way:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is very handy, meaning that we can pass a struct to the template instead
    of many single parameters.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will see how to use the basic templating functionalities
    of Go to create pages with custom messages, like you've done before, but just
    in a more elegant way.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.04: Templating Our Pages'
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to build a more structured web page, use a template,
    and fill it with parameters from the URL''s `querystring`. In this scenario, we
    want to display basic information for a customer and hide some information when
    the data is missing. A customer has an `id`, `name`, `surname`, and `age` and
    if any of these items of data are missing, they will not be displayed. Unless
    the data is the `id`, as in this case, an error message will be displayed:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating a `server-template` folder with a `main.go` file as usual,
    and then add the usual package and some imports:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we use two new imports, "`html/template`" for our templating, and "`strconv`"
    to convert strings into numbers (this package could also work the other way around,
    but there are better solutions for formatting text).
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, write the following:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is a raw string that contains some HTML and templating code, which is wrapped
    by `{{}}` and which we will analyze now.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{{.ID}}` is essentially a placeholder that tells the template engine that
    wherever this code is found, it will be substituted by a struct''s attribute called
    `ID`. The Go templating engine works with structs, so essentially, a struct will
    be passed to the engine and its attributes'' values will be used to fill the placeholders.
    `{{if .ID}}` is a conditional that tells the template that what happens next will
    depend on the value of `ID`. In this case, if `ID` is not an empty string, the
    template will display the customer''s details, otherwise it will display the message
    `<p>Data not available</p>`, which is wrapped between the placeholders `{{else}}`
    and `{{end}}`. As you can see, there are many more conditionals nested inside
    the first one. At each list item, there is a `<li>` tag, which is wrapped, for
    example, by `{{if .Name}}` and terminated with `{{end}}`.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have a string template, let''s create a struct with the correct
    attributes. To fill in the template, write the following:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This struct is self-explanatory. It contains all the attributes needed by the
    template.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the handler function and set a variable to the map of values in the
    `querystring`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Instantiate a `cust` variable of the `Customer` type:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The variable now has all its attributes set to the default values, and we need
    to grab the passed values from the URL. In order to do so, write:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see, the parameters are taken as they are from the values map, and
    if they exist, they are used to set the value of the related `cust` attribute.
    In order to check whether these parameters exist, we again used the `ok` variable,
    which is set to a Boolean with a value of `true` in case the map contains the
    requested key. The last attribute, `Age`, is handled slightly differently:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is because `strconv.Atoi` returns an error in case the parameter passed
    is not really a number. In general, we should handle the errors but, in this case,
    we just ignore it and we won't display any age-related information if the age
    provided is not a number.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, write:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This creates a template object with the name "`test`" and with the content of
    the string that you created at the outset. We again ignore the error as we are
    sure that the template we've written is a valid one. In production, however, all
    the errors should be dealt with.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now finish writing the function with:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, the template is actually executed using the `cust` struct and the content
    is sent directly to `w` `ResponseWriter` without needing to call the `Write` method
    manually.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What is missing now is the `main` method, which is fairly simple. Write the
    following:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, simply speaking, the main path is associated with the `Hello` function
    and the server is then started.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The performance of this code is not very high as we create a template in every
    request. The template could be created in the `main` and then passed to a handler,
    which could have a `ServeHTTP` method like the `Hello` function you've just written.
    The code has been kept simple here in order to focus on templating.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you now start the server and visit the following pages, you should see some
    output similar to the following:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.20: Templated response with blank parameters'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_20.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.20: Templated response with blank parameters'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can add a query parameter called `id` and put it equal to `1` in the
    URL visiting this address: `localhost:8080/?id=1`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.21: Templated response with just the ID specified'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_21.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.21: Templated response with just the ID specified'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can also add a value for the name parameter going to the address
    `localhost:8080/?id=1&name=John`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.22: Templated response with the ID and name specified'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_22.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.22: Templated response with the ID and name specified'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, you can also add an age going to the address `localhost:8080/?id=1&name=John&age=40`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.23: Templated response with the ID, name, and age specified'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_23.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.23: Templated response with the ID, name, and age specified'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Here, each parameter in the `querystring` is displayed, if valid, in the web
    application.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Static Resources
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything you've learned so far in this book, up to the last exercise, is sufficient
    in order to build web applications and dynamic websites; you just need to put
    all the pieces together. What you've been doing in this chapter is returning messages
    that are different in nature, but that are all hardcoded as strings. Even dynamic
    messages have been based on templates hardcoded in the source file of the exercises
    and activities. Let's now consider something. In the case of the first "`hello
    world`" server, the message never changed. If we wanted to modify the message
    and return a "`Hello galaxy`" message, we would have to change the text in the
    code and then recompile and/or run the server again. What if you wanted to sell
    your simple "hello" server and give the option to everybody to specify a custom
    message? Of course, you should give the source code to everybody so that they
    could recompile and run the server. Although you might want to embrace open source
    code, this might not be the ideal way to distribute an application, and we need
    to find a better way to separate the message from the server. A solution to that
    is to serve static files, which are files loaded by your program as external resources.
    These files do not change and do not get compiled but are loaded and manipulated
    by your program. One such example may be templates, as seen before, because they
    are just text and you can use template files instead of adding the templates as
    text to your code. Another simple example of static resources are images that
    you want to include in your web page, or styling files such as CSS. You will see
    in the following exercises and activities how to do that. You'll be able to serve
    a specific file or a specific folder, and then you'll see how to serve dynamic
    files with a static template.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.05: Creating a Hello World Server Using a Static File'
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will again create your hello world server but with the
    use of a static HTML file. What we want is to have a simple server with one handler
    function that looks for a specific file with a specific name, which will be served
    as the output for every path. In this case, you will need to create multiple files
    in your project:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called `static-file` and, inside it, create a file called `index.html`.
    Then, insert inside this file the following code for a pretty simple HTML file
    with a title and an `h1` tag with our welcome message:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, create a file called `main.go` and start writing the necessary imports:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, write the `main` function:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, write the `handler` function:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This is where the magic happens. You can see a normal `http.HandleFunc` called
    with a `"/"` path as the first parameter, and then a handler function is passed,
    which contains a single instruction:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This essentially sends to `ResponseWriter` the content of the "`index.html`"
    file.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, write the last part:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: As is always the case, this starts the server, logs in case of an error, and
    exits the program.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you now save the file and you run the program with:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And then you open your browser on the `localhost:8080` page, you should see
    the following:'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.24: Hello world with a static template file'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14177_15_24.jpg)'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.24: Hello world with a static template file'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'But now, without stopping your server, just change the HTML file, `index.html`,
    and modify line `8` where you see:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Change the text in the `<h1>` tag:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Save the `index.html` file and, without touching the terminal and without restarting
    your server, just refresh your browser on the same page, and you should now see
    the following:![Figure 15.25: Hello world server with the static template file
    modified'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_15_25.jpg)'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.25: Hello world server with the static template file modified'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, even if the server is running, it will pick up the new version of the file.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, you've seen how to use a static HTML file to serve a web page,
    and how detaching the static resources from your application makes you able to
    change your served page without restarting your application.
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting Some Style
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to now, you've seen how to serve one static page and you might consider serving
    a few pages with the same method, maybe creating a handler struct with the name
    of the file to serve as an attribute. This might be impractical for large numbers
    of pages, although, in some cases, it is necessary. A web page, however, does
    not include just HTML code, but also images and styles, and some frontend code.
    It is not within the scope of this book to teach how to build HTML pages, and
    even less how to write JavaScript code or CSS style sheets, but you need to know
    how to serve these documents as we use a small CSS file to build our example.
    Serving static files and putting templates in different files, or generally using
    external resources, is a good way to separate concerns on our projects, and makes
    our projects more manageable and maintainable, so you should try to follow this
    approach in all your projects.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add a style sheet to your HTML pages, you need to add a tag like
    this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This injects the CSS file into the page as a "stylesheet", but this is reported
    here just by way of an example, in case you are interested in learning how to
    write HTML.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'You have also seen that we have served files, reading them from the filesystem
    one by one, but Go provides us with an easy function to do the job for us:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Essentially, `http.FileServer` creates what the name says: a server serving
    external files, and it takes them from the directory defined in `http.Dir`. Whatever
    file we put inside the "`./public`" directory will be automatically accessible,
    adding in the address bar:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This seems good enough. However, in a real-world scenario, you do not want
    to expose your folder names and you want to specify a different name for your
    static resources. This is achieved as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You may notice that the `http.FileServer` function is wrapped by an `http.StripPrefix`
    function that we use in order to associate the requested path with the correct
    files on the filesystem. Essentially, we want a path of the `/statics` form to
    be available and to bind it to the content of the `public` folder. The `StripePrefix`
    function will remove the `"/statics/"` prefix from the request and will pass it
    to the file server, which will just get the name of the file to serve and will
    search for it in the `public` folder. It is not necessary, if you do not want
    to change the name of the path and folder, to use these wrappers, but this solution
    is general and works everywhere, so you can utilize it in other projects without
    having to worry.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.06: A Stylish Welcome'
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to display a welcome page, making use of some external
    static resources. We will adopt the same approach as in *Exercise 15.05*, but
    we will add some extra files and code. We will place some stylesheets in a `static`
    folder, and we will serve them so that they can be used by other pages served
    by the same server:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'By way of a first step, create a folder called `stylish-welcome` and, inside
    this folder, add a file called `index.html` and incorporate the following content:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, there are few differences compared with the previous HTML; we
    have a paragraph with some more text, wrapped by the `<p>` tag, and, inside the
    `<head>` tag, we include three links to external resources.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create a folder called `public` inside your `stylish-welcome` folder and
    create three files therein with these names and content:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`header.css`'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`body.css`'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`text.css`'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, go back to your main project folder, `stylish-welcome`, and create the
    `main.go` file. The content at the start corresponds exactly to that in one of
    the previous exercises:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, add the following code to handle the static files:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This code adds a handler to the "`/statics/`" path and it does so through an
    `http.FileServer` function, which returns a static file handler.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This function requires a directory to scrape, and we pass one to it as a parameter:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This reads the local "`public`" folder that you created previously.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add this final part to the file:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here again, the server gets created and the `main()` function is closed. If
    you now run your server, again with:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You will now see the following:![Figure 15.26: Styled home page'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_15_26.jpg)'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.26: Styled home page'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So somehow, the HTML file is now getting the style from the style sheets you
    created at the beginning.
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s now examine how the files are injected. If you look back at the `index.html`
    file, you will see these lines:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'So essentially, we are looking for files under the path `"/statics/"`. Hence,
    you can go to these addresses and you will see:![Figure 15.27: body CSS file'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_15_27.jpg)'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.27: body CSS file'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.28: header CSS file'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14177_15_28.jpg)'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.28: header CSS file'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.29: text CSS file'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14177_15_29.jpg)'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.29: text CSS file'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So, all the style sheets are served. Furthermore, you can even go here:![Figure
    15.30: Static folder content visible in the browser'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_15_30.jpg)'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.30: Static folder content visible in the browser'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And see all the files inside the `public` folder, served under the `/statics/`
    path. You can see that if you are looking for a simple static files server, Go
    allows you, with the help of a few lines of code, to create one, and, with a few
    more lines, you can make it production-ready.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you use Chrome, you can inspect with your mouse by right-clicking, or with
    any browser if you have a developer tool, and you will see something similar to
    this:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.31: Developer tools showing loaded scripts'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_31.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.31: Developer tools showing loaded scripts'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the files have been loaded and that the styles are shown as
    computed from the stylesheet on the right.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Getting Dynamic
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static assets are generally served as they are, but when you want to create
    a dynamic page, you might want to make use of an external template, which you
    can use on the fly, so that you can change the template without having to restart
    your server, or that you can load on startup, which means you will have to restart
    your server following any change (this is not strictly true, but we need some
    concepts of concurrent programming in order to make it happen). Loading a file
    at startup is executed simply for performance reasons. Filesystem operations are
    always the slowest, and even if Go is a fairly fast language, you might want to
    take performance into account when you want to serve your pages, especially if
    you have many requests from multiple clients.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will recall from a previous topic, we used the standard Go templates
    to make dynamic pages. Now, we can use the template as an external resource and
    put our template code in an HTML file and load it. The template engine can parse
    it and then fill the blanks with the passed parameters. To do this, we can use
    the `html/template` function:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This can be called, for example, with:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In addition, the template is loaded in memory and is ready to be used.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, you have been the sole user of your HTTP servers, but in an
    actual scenario, that is certainly not the case. In the following examples, we
    will look at performance and will use a resource loaded at startup.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 15.03: External Template'
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will create a welcome server, like the ones you created
    before, and you will have to use the template package, as you've done before.
    In this activity, however, we do not want you to create your template from a hardcoded
    string but from an HTML file, which will contain all the template placeholders.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to complete this activity, making use of what you've learned
    so far in this chapter and in the previous one.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: This activity returns a pointer to a `template` and an error from a list of
    filenames. The error gets returned if any of the files do not exist or if the
    format of the template is wrong. In any case, do not concern yourself with the
    possibility of adding multiple files. Stick with one.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to complete the activity:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder for your project.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a template with a name such as `index.html` and fill it with standard
    HTML code, with a welcome message and a placeholder for the name. Make sure that
    if the name is empty, the message inserts the word `visitor` where the name is
    supposed to be.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create your `main.go` file and add to it the right package and imports.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main.go` file, create a `struct` holding a name that can be passed to
    a template.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a template from a file using your `index.html` file.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create something that's able to handle the HTTP requests and use the `querystring`
    to receive parameters and display the data through the template created previously.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set all the paths to the server to use the function or handler created in the
    previous step and then create the server.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the server and check the result.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.32: Anonymous visitor page'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_32.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.32: Anonymous visitor page'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'And the visitor page including the name will look something like the following
    screenshot:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.33: Visitor page with the name "Will"'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_33.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.33: Visitor page with the name "Will"'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 763
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you learned how to create a templated HTTP handler as a struct
    that can be initialized with any external template. You can now create multiple
    pages, instantiating the same struct with different templates of your choice.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Methods
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, you've checked the results of your exercises and activities
    through your web browser, just visiting an address, your localhost, and getting
    some results back in the form of a web page. This way of consuming an HTTP server
    utilizes what is known as the `GET` method. You have seen the methods when you
    worked with the HTTP clients, which are the only way to use anything other than
    `GET` or `POST`. Through your web browser, however, you can also use the `POST`
    method, which is often used in order to send form data. It is possible to send
    form data through `GET`, but this method pollutes the URL with parameters and
    has some limitations in terms of the size of the data that can be sent.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: There are other methods that are often used, these being `PUT` and `DELETE`,
    but you need a specific client to utilize them. That is why a set of these four
    methods is used in order to build what is called a `REST` API. There are other
    methods, but it is beyond the scope of this book to dig into all the HTTP methods,
    focusing instead on the ones that are most commonly used. A `REST` API is essentially
    a set of *paths* and methods that respond to specific requests. An HTTP server
    exposing a `REST` API is called a `REST server`. In order to understand why different
    methods are available, you need to understand how are they used. If you need to
    request some data, you are trying to get this data back, hence, the `GET` method
    is the most appropriate. If, instead, you want to modify a resource you are already
    familiar with, you want to put some specific values in a known location, you will
    use the `PUT` method, which essentially changes the state of the server in a known
    place. If you need to somehow modify the state of the server, you need to search
    for the resources to modify. For example, if you do not know their IDs, you will
    use the `POST` method. This is why you will often find online that the most common
    explanation for when to use `POST` and `PUT` is that the former is used to add
    resources, while the latter is used to update resources. Although this is most
    often true, it is not always the case, as you may also perform updates with the
    `POST` method.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will see how to use the different methods, `GET` and
    `POST`, to do different things with the same function. Note that in general, you
    might use more sophisticated external libraries to have more elegant code, but
    here, we are looking at how to do the basics and show how the standard Go library
    already offers us much in terms of helping us to do our work.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.07: Completing a Questionnaire'
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will build a form and you will send the data to another
    page. The form will contain questions such as your name, surname, and age, and
    this data will be sent to another page, which will display them. You will make
    use of what you've already learned, plus you'll see how to grab `posted` parameters
    from your `HTTP` request.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, create a folder called `questionnaire` and, inside this folder,
    incorporate a file called `index.html` with the following content:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This is a normal template displaying items of personal information. If any data
    is missing, we simply display it as empty strings without hiding them.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create a file called `form.html` and add the following content:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This is another page inside a form, with three text inputs and a button. The
    input fields represent the details we want to send. Note that the form has the
    action set to `"/",` which means that when clicking the button, the page gets
    redirected to the main path, but will transport the dataset in the form. The method
    attribute is set to `post,` which is the HTTP method discussed earlier.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You now have to create the actual server in Go. Create a `main.go` file and
    add the following:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, create the struct for the template:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This holds all the attributes required for the template.
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, execute the following command:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This holds the template, as seen previously.
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, you need to create the `handler` function for the handler, so
    add the following:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Here, a new empty visitor is created.
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check whether the request is a `Post` request, so you need to add:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This checks the method against a constant provided by the Go `http` package.
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Parse the form:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: If an error occurs when parsing the form, we return with a `400` code, which
    is a bad request.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the form gets parsed correctly, we can proceed, so add the following:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Here, all the parameters from the form get assigned to the visitor's attribute.
    We then close the `if` statement and go to the common part of the handler function.
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As we have a visitor, empty or not depending on whether the form has been posted
    and with what values, we can finally return the page, so write:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We need to have a way to create the handler, so, as you''ve done before, add
    the following function:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'At this point, you can write the `main()` function, which creates the handler,
    assigns it to the main path, and then assigns the static `form.html` file to the
    `/form` path:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Run your server, you will see the following by going to the main page:![Figure
    15.34: Empty details page'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_15_34.jpg)'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.34: Empty details page'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you go to the `/form` path, you''ll see:![Figure 15.35: Empty form page'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_15_35.jpg)'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.35: Empty form page'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And if you fill the data:![Figure 15.36: Filled form page'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_15_36.jpg)'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.36: Filled form page'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And then press the `send` button, you will be redirected to this page:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.37: Page with details added'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_37.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.37: Page with details added'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: This, again, is the main page with the details set via the parameters you put
    into the form.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: JSON loads
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all HTTP servers are meant to be used by a browser and a human user. Very
    often, we have different software programs communicating with each other. These
    programs need to send messages to one another through a commonly accepted format,
    one of these being JSON. This stands for JavaScript Object Notation, which essentially
    means that it mimics how objects are created directly in JavaScript (another programming
    language). It is a simple format, not particularly verbose, and is easy to parse
    by a piece of software and easy to read for a human. As a user, however, you can
    use any one of the many tools to send and receive JSON payloads, two of the most
    common ones being **Insomnia** and **Postman**, which you can easily find online
    at [https://packt.live/2RY13Dt](https://packt.live/2RY13Dt) and [https://packt.live/2RY13Dt](https://packt.live/2RY13Dt).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: They are both free and available for different platforms. You could also use
    `curl` as a command-line tool, but this becomes more complicated.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.08: Building a Server That Accepts JSON Requests'
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will build a server that accepts a JSON message and will
    respond with another JSON message. You will not be able to use your browser to
    test it, but you can do it with a client such as **Insomnia** or **Postman**.
    The example screenshots will be provided using **Insomnia**, so it would be good
    for you to use the same. The server you will build accepts a message with a name
    and surname, and returns a message with some personalized greetings:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called `json-server` and add a file to it called `main.go`.
    Start adding packages and imports to the file:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Here, the packages imported are customary for HTTP programming, for logging,
    for formatting strings, and, of course, for JSON encoding.
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After this, you need to create models for the incoming and outcoming messages,
    so write the following:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: These are pretty straightforward structs, including only what we need.
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, add the `main` function:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'And now set the function to handle the JSON messages:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As you can see, the first thing inside the function is to create a JSON decoder,
    which will decode the request's body.
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As a next step, write the following:'
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Here, we define a data variable of the `Request` type and we decode the body
    of the HTTP request into it. In case of any error, we return a `400` code for
    a bad request.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the data has been decoded correctly, you can now use this data to create
    the response:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Here, the name and surname from the request are combined in a personalized greeting
    message.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All that is now left is to send the message back to the requester:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here, the response is encoded into a JSON string and is sent, writing it as
    a slice of bytes into the response writer. You can now run the server and open
    `Insomnia`:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create the `main()` function to serve the pages:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Running the preceding code produces the following output:'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.38: Insomnia response'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_38.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.38: Insomnia response'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you can make a `post` request with Insomnia and send a JSON
    string to your server. On the right, you will see the response as a JSON document.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you''ve been introduced to the server side of web programming.
    You''ve learned how to accept requests from HTTP clients and respond in an appropriate
    manner. You''ve learned how to separate the possible requests into different areas
    of an HTTP server via paths and sub-paths. For this, you used a simple routing
    mechanism with the standard `Go HTTP` package. You''ve seen how to return your
    response in order to suit different consumers: JSON responses for synthetic clients,
    and HTML pages for human access. You''ve seen how to use templates in order to
    format your plain text and HTML messages, using the standard templating package.
    You''ve learned how to serve and use static resources, serving them directly through
    a default file server or through a template object. You''ve also learned what
    a `REST` service is, and although we have not built one together, you have all
    the knowledge necessary to create one, provided you follow the description you''ve
    been given. At this stage, you know all the basics for building production-grade
    HTTP servers, although you might want to use some external libraries to facilitate
    your hello world example, facilitating better routing by using something such
    as `gorilla mux` or, generally, the entire `gorilla` package, which is a low-level
    abstraction on top of the `http` package. You could use `hero` as a template engine
    to make your page rendering faster. One thing to mention is that you can make
    pretty much stateless services with what you''ve learned in this chapter, but
    you cannot create a production-grade stateful server at the moment as you do not
    know how to handle concurrent requests. This means that our `views counter` is
    not suitable for a production server yet, but this will be the subject of another
    chapter.'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will see how Go leverages the system of Goroutines
    to handle multiple work at the same time. This feature is very important, and
    you can apply it to HTTP servers and other types of projects where you have many
    concurrent users or whenever you want to do a lot of things at the same time.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
