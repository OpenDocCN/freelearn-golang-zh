- en: 15\. HTTP Servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces you to different ways of creating an HTTP server in
    order to accept requests from the internet. You will be able to understand how
    a website can be accessed and how it can respond to a form. You will also learn
    how to respond to requests from another software program.
  prefs: []
  type: TYPE_NORMAL
- en: You'll be able to create an HTTP server rendering a simple message. You will
    learn how to create an HTTP server rendering complex data structures which serves
    local static files. Further you will create an HTTP server rendering dynamic pages
    and work with different ways of routing. By the end of this chapter you will also
    learn to create a REST service, accept data through a form, and accept JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how to contact a remote server in order to obtain
    some information, but now we will dig into how the remote server is created, so
    if you already know how to request information, now you will see how to reply
    to these requests.
  prefs: []
  type: TYPE_NORMAL
- en: A web server is a program that uses the HTTP protocol, hence, the HTTP server,
    to accept requests from any HTTP client (web browser, another program, and so
    on) and respond to them with an appropriate message. When we browse the internet
    with our browser, it will be an HTTP server that will send an HTML page to our
    browser and we will be able to see it. In some other cases, a server will not
    return an HTML page but a different message, appropriate to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Some HTTP servers provide an API that can be consumed by another program. Think
    of when you want to register with a website, and you are asked if you want to
    sign up through Facebook or Google. This means that the website you want to register
    with will consume a Google or Facebook API to get your details. These APIs generally
    respond with a structured text, which is a text representing a complex data structure.
    The way these servers expect the requests can be different. Some expect the same
    type of structured messages they return, while some provide what is called a REST
    API, which is quite strict with the HTTP methods used and expects inputs in the
    form of URL parameters or values, like the ones in a web form.
  prefs: []
  type: TYPE_NORMAL
- en: How to Build a Basic Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest HTTP server that we can create is a Hello World server. This is
    a server that will return a simple message "Hello World" and will not do anything
    else. It is not very useful, but it is a starting point to see what Go default
    packages give us and is the basis for any other more complex server. The aim is
    to have a server that runs on a specific port on your machine's localhost and
    accepts any path under it. Accepting any path means that when you test the server
    with your browser, it will always return the "Hello World" message and a status
    code of 200\. Of course, we could return any other message, but, for historical
    reasons, the simplest project you learn when you study programming is always some
    sort of software returning the message "Hello World". In this case, we will see
    how this can be done and then visualized in a normal browser, before perhaps being
    put on the internet and shared with billions of users, although users may, in
    practice, prefer a more useful server. Let's say this is the most basic HTTP server
    you can create.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to react to an HTTP request, we need to write something that, we usually
    say, handles the request; hence, we call this something a handler. In Go, we have
    several ways to do that, and one is to implement the handler interface of the
    http package. This interface has one method that is pretty self-explanatory, and
    this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'So, whenever we need to create a handler for HTTP requests, we can create a
    struct including this method and we can use it to handle an HTTP request. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a valid HTTP handler and you can use it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ListenAndServe()` is a function that will use our handler to serve the
    requests; any struct implementing the handler interface will be fine. However,
    we need to let our server do something.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the `ServeHTTP` method accepts a `ResponseWriter` and a `Request`
    object. You can actually use them in order to capture parameters from the request
    and write messages to the response. The simplest thing, for example, is to let
    our server return a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ListenAndServe` method might return an error. If this happens, we most
    likely would like the execution of our program to halt, so one common practice
    is to wrap this function call with a fatal log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will halt the execution and print the error message returned by the `ListenAndServe`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.01: Creating a Hello World Server'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start building a simple Hello World HTTP server on the basis of what you've
    learned in the previous block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is to create a folder called `hello-world-server`. You
    can do this via the command line or you can create it with your favorite editor.
    Inside the folder, create a file called `main.go`. We will not use any external
    library here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the package name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This tells the compiler that this file is an entry point for a program that
    can be executed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Import the necessary packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a `handler`, the struct that will handle the requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we have our handler, create the `main()` function, which will start
    the server and produce a web page with our message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire file should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you now go to your Terminal, inside your `hello-world-server` folder, and
    type in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should just see nothing; the program has started.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you now open your browser at the following address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see a page with a big message:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.01: Hello world server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.01: Hello world server'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you now try to change path and go to */page1*, you will again see the following
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.02: Hello world server sub-pages'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.02: Hello world server sub-pages'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! This is your first HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have created a basic hello world server, which returns
    the message "Hello World" in response to any request on any sub-address.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The server built just now in the previous exercise does not do much. It just
    responds with a message and we cannot ask anything else. Before we can make our
    server more dynamic, let''s imagine we want to create an online book and we want
    to be able to select a chapter just changing the URL. At the moment, if we browse
    the following pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We always see the same message, but we now want to associate different messages
    with these different paths on our server. We will do this by introducing some
    simple routing to our server.
  prefs: []
  type: TYPE_NORMAL
- en: 'A path is what you see after the `8080` in the URL; it can be one number, a
    word, a set of numbers or character groups separated by a "/". In order to do
    this, we will use another function of the net/http package, which is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, the pattern is the path we want to be served by the `handler` function.
    Note how the `handler` function signature has the exact same parameters as the
    `ServeHTTP` method, which you added to the `hello` struct in the previous exercise.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, the server built in *Exercise 15.01* is not very useful, but
    we can transform it into something much more useful with the addition of pages
    other than the `hello world` one, and, in order to do so, we need to do some basic
    routing. The aim here is to write a book, and the book must have a welcome page
    with the title, and a first chapter. The book title is `hello world`, so we can
    keep what we did before. The first chapter will have a heading stating `Chapter
    1`. The book is a work in progress, so it does not matter that the content is
    still poor; what we require is the ability to select the chapter, and we will
    then add the content later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.02: Routing Our Server'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are now going to modify the code in *Exercise 15.01* to support different
    paths. If you haven''t gone through the previous exercise, do it now so that you''ll
    have a basic framework for this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder and a `main.go` file and add the code from the previous
    exercise to the definition of the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, use `handle` to route "`/chapter1`" through a `handlefunc()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This means that we associate the path, `/chapter1`, with a function that returns
    a specific message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, set the server to listen to a port and to run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, save your file and run the server again with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, go to your browser and load the following URLs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8080`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`http://localhost:8080/chapter1`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The output for the home page is shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.03: Multi-page server – home page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.03: Multi-page server – home page'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the output for page 1 is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.04: Multi-page server – chapter 1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.04: Multi-page server – chapter 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that they both still display the same message. This happens because we
    are setting our `hello` as the handler for our server, and this overrides our
    specific path. We can modify our code to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'What happened here is that you removed the `hello` handler from being the main
    handler for our server and you associated this handler with the main `/` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you associated a `handler` function with the specific `/chapter1` path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you stop and then run our server again, you will see that the `/chapter1`
    path now returns the new message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.05: Multi-page server repeated – chapter 1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.05: Multi-page server repeated – chapter 1'
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, all the other paths return the old `Hello World` message.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.06: Multi-page server – base page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.06: Multi-page server – base page'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.07: The page that is not set returns the default setting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.07: The page that is not set returns the default setting'
  prefs: []
  type: TYPE_NORMAL
- en: Handler versus Handler Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may have noticed, we used two different functions before, `http.Handle`
    and `http.HandleFunc` , both of which have a path as their first parameter, but
    which differ in terms of the second parameter. These two functions both ensure
    that a specific path is handled by a function. `http.Handle`, however, expects
    `http.Handler` to handle the path, while `http.HandleFunc` expects a function
    to do the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''ve seen before, `http.Handler` is any struct having a method with this
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So, in both cases, there will always be a function with `http.ResponseWriter`
    and `*http.Request` as parameters that will handle the path. As to when one or
    the other might be chosen may just be a matter of personal preference in many
    cases, but it might be important, when creating a complex project, for example,
    to choose the right method. Doing so will ensure that the structure of the project
    is optimal. Different routes may appear better organized if handled by handlers
    belonging to different packages, or might have to perform very few actions, as
    in our previous case; and a simple function might prove to be the ideal choice.
  prefs: []
  type: TYPE_NORMAL
- en: In general, for simple projects where you have a handful of simple pages, you
    may opt for `HandleFunc`. For example, let's say you want to have static pages
    and there is no complex behavior in each page. In this case, it would be an overkill
    to use an empty struct just for returning a static text. The handler is more appropriate
    whenever you need to set some parameters, or if you want to keep track of something.
    As a general rule, let's say that if you have a counter, a `Handler` is the best
    choice because you can initialize a `struct` with a count of 0 and then increment
    it, but we will see this in *Activity 15.01*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 15.01: Adding a Page Counter to an HTML Page'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that you own a website with, say, three pages, where you are writing
    your book. You earn money depending on how many visits your website receives.
    In order to understand how popular your website is, and how much money you are
    earning, you need to keep track of the visits.
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you will build an HTTP server with three pages, containing
    some content, and display, in each page, how many visits that page has had so
    far. You will use the `http.Handler` method, which, in this case, will help you
    to generalize your counter.
  prefs: []
  type: TYPE_NORMAL
- en: In order to display the dynamic value, you can use the `fmt.Sprintf` function
    in the `fmt` package, which prints and formats a message to a string. With this
    function, you can build a string containing characters and numbers. You can find
    all the information about this method online in the Go documentation.
  prefs: []
  type: TYPE_NORMAL
- en: You will use everything you've learned so far, including how a struct is instantiated,
    how to set attributes of a struct, pointers, how to increase an integer, and,
    of course, everything you have learned about HTTP servers hitherto.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observing the following steps will provide an elegant and effective solution:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `page-counter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the necessary imports to the `http` and `fmt` packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a struct called `PageWithCounter` with a `counter` as an integer attribute,
    a `content`, and a `heading` as a text attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `ServeHTTP` method to the struct, capable of displaying the content, the
    heading, and a message with the total number of views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create your `main` function and, inside, implement the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiate three handlers of the `PageWithCounter` type, with `Hello World`,
    `Chapter 1`, and `Chapter 2` headings and some content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the three handlers to the routes `/`, `/chapter1`, and `/chapter2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the server on port `8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you run the server, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.08: Output on the browser when you run the server for the first
    time'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.08: Output on the browser when you run the server for the first time'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you refresh the page, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.09: Output on the browser when you run the server for the second
    time'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.09: Output on the browser when you run the server for the second
    time'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, navigate to Chapter 1 by typing `localhost:8080/chapter1` in the address
    bar. You should be able to see something along the lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10: Output on the browser when you visit the chapter1 page for
    the first time'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.10: Output on the browser when you visit the chapter1 page for the
    first time'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, navigate to Chapter 2, and you should be able to see the following
    increment in terms of the number of views:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11: Output on the browser when you visit the chapter2 page for
    the first time'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.11: Output on the browser when you visit the chapter2 page for the
    first time'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you revisit Chapter 1, you should see an increase in the number of views
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.12: Output on the browser when you visit the chapter1 page for
    the second time'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.12: Output on the browser when you visit the chapter1 page for the
    second time'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 757
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you learned how to create a server that responds to different
    requests on different pages with a specific static text, along with a counter
    on each page, with each counter independent from the others.
  prefs: []
  type: TYPE_NORMAL
- en: Returning Complex Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we've seen hitherto is useful when building a website, even though, for
    this purpose, we still need to see how to better render HTML pages. You might
    want to use a framework such as **revel** or **gin** for this purpose, although
    plain Go with a few libraries is more than enough for a production-grade website.
    You will find, however, that HTTP servers are used not only for building websites,
    but also for building web services, and especially, nowadays, microservices. Although
    how to build a web service-based project is beyond the scope of this chapter and
    book, it is important for you to know how to let your HTTP server serve something
    that will not be consumed by a human through a browser, but by another program.
    You may already know what a web service is, but even if you do not, you might
    have to work on an existing project where you have to modify a web service. There
    are several ways to present a message to another program, which will be referred
    to as a client, but, in general, they will all involve some sort of structured
    texts, which can be parsed easily. The format could be an XML string, but the
    most common and lightweight format now used is JSON. In the next exercise, we
    will see how to build a data structure and send it to the client (aq browser or
    another program) in the form of a JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 15.02: Serving a Request with a JSON Payload'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, you will create a data structure and you will serve it through
    an HTTP server. You will make use of what you have already learned about JSON
    and the encoding/decoding of structs, and you will combine it with what you''ve
    learned about HTTP servers. You might have guessed already, but in this exercise,
    you already have all the knowledge required and you should be able to complete
    it on your own. Let''s now build another book. The title and the chapters are
    the same, but this time we want to make it accessible to a program that will consume
    the pages on the server as JSON documents. The document will also include the
    number of views per chapter, so the code can make use of the one generated in
    *Activity 15.01*. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `book-api`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `main.go` in that folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the required imports.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a struct called `PageWithCounter` representing a book with a title, content,
    and a counter, with appropriate JSON tags, if necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `ServeHTTP` method to the struct, capable of displaying the content, the
    heading, and a message with the total number of views as a JSON document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `main()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instantiate three handlers of the `PageWithCounter` type, with `Hello World`,
    `Chapter 1`, and `Chapter 2` headings and some content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the three handlers to the routes `/`, `/chapter1`, and `/chapter2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the server on port `8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Running your server, you should see the following for the assigned routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.13: Expected output when the handler is /'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.13: Expected output when the handler is /'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.14: Expected output when the handler is /chapter1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.14: Expected output when the handler is /chapter1'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.15: Expected output when the handler is /chapter2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.15: Expected output when the handler is /chapter2'
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you've learned how to return complex structures through an
    HTTP server. Any kind of complex data structure can be served this way, using
    a standard format such as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 761
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A server that serves only static content is useful, but there is much more
    that can be done. An HTTP server can deliver content depending on a more granular
    request, which is done by passing some parameters to the server. There are many
    ways to do so, but one simple way is to pass parameters to a `querystring`. If
    the URL of the server is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, the part `?name=john` is called a `querystring` as it is a string representing
    a query. In this case, this `querystring` sets a variable called `name` with a
    value of `john`. This way of passing parameters is generally used with `GET` requests,
    while a `POST` request will generally make use of the body of the request in order
    to send parameters. This does not mean that a `GET` request does not have a body
    but is not the standard way to pass parameters to a `GET` request. We will begin
    by looking at how to accept parameters for a `GET` request, as this request is
    made by simply opening your browser on a specific address. We will see later how
    to handle a `POST` request through a form.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will be able to return different texts as responses
    to HTTP requests, where the text depends on what values the user puts in the `querystring`
    in the address bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.03: Personalized Welcome'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will again create an HTTP server that is able to cheer
    us, but instead of a general "`hello world`" message, we will provide a message
    depending on our name. The idea is that, by opening the browser on the server''s
    URL and adding a parameter called `name`, the server will welcome us with the
    message "`hello` ", followed by the value of the `name` parameter. The server
    is very simple and does not have sub-pages, but contains this dynamic element
    that constitutes a starting point for more complex situations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder called `personalised-welcome` and, inside the folder, create
    a file called `main.go`. Inside the file, add the package name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the required imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: They are all the same imports used in the previous exercises and activities,
    no there is nothing new. We will not use handlers in this exercise as it is much
    smaller, but we will make use of the `http.handleFunc` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add the following code after the imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the definition of a function that can be used as a handling function
    for an HTTP path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, save the query to a variable using the `Query` method URL from the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Query` method on the `URL` object of the request returns a `map[string][]string`
    with all the parameters sent through the `querystring` in the URL. We then assign
    this map to a variable, `vl`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, we need to get the value of a specific parameter called `name`,
    so we get the value from the `name` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we have an assignment to two variables, but only one value comes
    from `vl["name"]`. The second variable, `ok`, is a Boolean that tells us whether
    the "`name`" key exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the `name` parameter has not been passed and we want an error message to
    appear, add it if the variable is not found, in other words, if the `ok` variable
    is false:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The conditional code gets called if the key does not exist in the slice, and
    it writes a `400` code (bad request) to the header, as well as a message to the
    response writer stating that the name has not been sent as a parameter. We stop
    the execution with a `return` statement to prevent further actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, write the valid message to the response writer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code formats a string and injects the name into it. The `fmt.Sprintf` function
    is used to format, while `strings.Join` is used in order to transform the `name`
    slice into a string. Notice that the `name` variable is set to the value of `vl["name"]`,
    but `vl` is a `map[string][]string`, which means that it is a map with string
    keys whose values are slices of strings; hence, `vl["name"]` is a slice of strings
    and needs to be transformed into a single string. The `strings.Join` function
    takes all the elements of the slice and builds a single string using `","` as
    a separator. Other characters could also have been used as separators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last part of the file you have to write is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As always, a `main()` function is created, and then the `Hello` function is
    associated with the path `"/"` and the server started. Here is the output of three
    different URLs, two valid ones, and one with a missing parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.16: Server output when requesting the page with the name john'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.16: Server output when requesting the page with the name john'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.17: Server output when requesting the page with the name will'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.17: Server output when requesting the page with the name will'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.18: Server outputting an error message when requesting a page without
    a name'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.18: Server outputting an error message when requesting a page without
    a name'
  prefs: []
  type: TYPE_NORMAL
- en: Templating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although JSON can be the best choice when complex data structures have to be
    shared across software programs, this is not the case, in general, when the HTTP
    server is supposed to be consumed by humans. In the previous exercises and activities,
    the chosen way to format a text has been the `fmt.Sprintf` function, which is
    good for formatting texts, but is simply insufficient when a more dynamic and
    complex text is required. As you will have noticed in the previous exercise, the
    message returned in case a name was passed as a parameter to the URL observed
    a specific pattern, and this is where a new concept comes in – the template. A
    template is a skeleton from which complex entities can be developed. Essentially,
    a template is like a text with some blanks, and a template engine will take some
    values and fill the blanks, as you can see in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.19: Templating example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.19: Templating example'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `{{name}}` is a placeholder and, when a value is passed through
    to the engine, the placeholder is modified with that value.
  prefs: []
  type: TYPE_NORMAL
- en: We see templates everywhere. We have templates for Word documents, where we
    just fill in what is missing to produce new documents that all differ from one
    another. A teacher might have some templates for their lessons and will develop
    different lessons from that same template. Go provides two different templating
    packages, one for texts and one for HTML. As we are working with HTTP servers
    and we want to produce a web page, we will use the HTML templating package, but
    the interface is the same for the text template library. Although the templating
    packages are good enough for any real-world application, there are also several
    other external packages that can be used in order to improve performance. One
    of these is the `hero` template engine, which is much faster than the standard
    Go templating package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go templating package provides a placeholder language where we can use
    things such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple search and replace block, but more complex situations can be handled
    via conditionals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, if an `age` parameter is not null, the template will have `Hello`; otherwise
    it has `bye`. Each conditional needs an `{{end}}` placeholder to determine its
    ending.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables in a template, however, do not need to be simple numbers or strings;
    they can be objects. In this case, if we have a struct with a field called `ID`,
    we can reference this field in the template this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is very handy, meaning that we can pass a struct to the template instead
    of many single parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will see how to use the basic templating functionalities
    of Go to create pages with custom messages, like you've done before, but just
    in a more elegant way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.04: Templating Our Pages'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to build a more structured web page, use a template,
    and fill it with parameters from the URL''s `querystring`. In this scenario, we
    want to display basic information for a customer and hide some information when
    the data is missing. A customer has an `id`, `name`, `surname`, and `age` and
    if any of these items of data are missing, they will not be displayed. Unless
    the data is the `id`, as in this case, an error message will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating a `server-template` folder with a `main.go` file as usual,
    and then add the usual package and some imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we use two new imports, "`html/template`" for our templating, and "`strconv`"
    to convert strings into numbers (this package could also work the other way around,
    but there are better solutions for formatting text).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a raw string that contains some HTML and templating code, which is wrapped
    by `{{}}` and which we will analyze now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{{.ID}}` is essentially a placeholder that tells the template engine that
    wherever this code is found, it will be substituted by a struct''s attribute called
    `ID`. The Go templating engine works with structs, so essentially, a struct will
    be passed to the engine and its attributes'' values will be used to fill the placeholders.
    `{{if .ID}}` is a conditional that tells the template that what happens next will
    depend on the value of `ID`. In this case, if `ID` is not an empty string, the
    template will display the customer''s details, otherwise it will display the message
    `<p>Data not available</p>`, which is wrapped between the placeholders `{{else}}`
    and `{{end}}`. As you can see, there are many more conditionals nested inside
    the first one. At each list item, there is a `<li>` tag, which is wrapped, for
    example, by `{{if .Name}}` and terminated with `{{end}}`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have a string template, let''s create a struct with the correct
    attributes. To fill in the template, write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This struct is self-explanatory. It contains all the attributes needed by the
    template.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the handler function and set a variable to the map of values in the
    `querystring`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instantiate a `cust` variable of the `Customer` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The variable now has all its attributes set to the default values, and we need
    to grab the passed values from the URL. In order to do so, write:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, the parameters are taken as they are from the values map, and
    if they exist, they are used to set the value of the related `cust` attribute.
    In order to check whether these parameters exist, we again used the `ok` variable,
    which is set to a Boolean with a value of `true` in case the map contains the
    requested key. The last attribute, `Age`, is handled slightly differently:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is because `strconv.Atoi` returns an error in case the parameter passed
    is not really a number. In general, we should handle the errors but, in this case,
    we just ignore it and we won't display any age-related information if the age
    provided is not a number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, write:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates a template object with the name "`test`" and with the content of
    the string that you created at the outset. We again ignore the error as we are
    sure that the template we've written is a valid one. In production, however, all
    the errors should be dealt with.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now finish writing the function with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the template is actually executed using the `cust` struct and the content
    is sent directly to `w` `ResponseWriter` without needing to call the `Write` method
    manually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What is missing now is the `main` method, which is fairly simple. Write the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, simply speaking, the main path is associated with the `Hello` function
    and the server is then started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The performance of this code is not very high as we create a template in every
    request. The template could be created in the `main` and then passed to a handler,
    which could have a `ServeHTTP` method like the `Hello` function you've just written.
    The code has been kept simple here in order to focus on templating.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you now start the server and visit the following pages, you should see some
    output similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.20: Templated response with blank parameters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.20: Templated response with blank parameters'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can add a query parameter called `id` and put it equal to `1` in the
    URL visiting this address: `localhost:8080/?id=1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.21: Templated response with just the ID specified'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.21: Templated response with just the ID specified'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can also add a value for the name parameter going to the address
    `localhost:8080/?id=1&name=John`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.22: Templated response with the ID and name specified'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.22: Templated response with the ID and name specified'
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, you can also add an age going to the address `localhost:8080/?id=1&name=John&age=40`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.23: Templated response with the ID, name, and age specified'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.23: Templated response with the ID, name, and age specified'
  prefs: []
  type: TYPE_NORMAL
- en: Here, each parameter in the `querystring` is displayed, if valid, in the web
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Static Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything you've learned so far in this book, up to the last exercise, is sufficient
    in order to build web applications and dynamic websites; you just need to put
    all the pieces together. What you've been doing in this chapter is returning messages
    that are different in nature, but that are all hardcoded as strings. Even dynamic
    messages have been based on templates hardcoded in the source file of the exercises
    and activities. Let's now consider something. In the case of the first "`hello
    world`" server, the message never changed. If we wanted to modify the message
    and return a "`Hello galaxy`" message, we would have to change the text in the
    code and then recompile and/or run the server again. What if you wanted to sell
    your simple "hello" server and give the option to everybody to specify a custom
    message? Of course, you should give the source code to everybody so that they
    could recompile and run the server. Although you might want to embrace open source
    code, this might not be the ideal way to distribute an application, and we need
    to find a better way to separate the message from the server. A solution to that
    is to serve static files, which are files loaded by your program as external resources.
    These files do not change and do not get compiled but are loaded and manipulated
    by your program. One such example may be templates, as seen before, because they
    are just text and you can use template files instead of adding the templates as
    text to your code. Another simple example of static resources are images that
    you want to include in your web page, or styling files such as CSS. You will see
    in the following exercises and activities how to do that. You'll be able to serve
    a specific file or a specific folder, and then you'll see how to serve dynamic
    files with a static template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.05: Creating a Hello World Server Using a Static File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will again create your hello world server but with the
    use of a static HTML file. What we want is to have a simple server with one handler
    function that looks for a specific file with a specific name, which will be served
    as the output for every path. In this case, you will need to create multiple files
    in your project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called `static-file` and, inside it, create a file called `index.html`.
    Then, insert inside this file the following code for a pretty simple HTML file
    with a title and an `h1` tag with our welcome message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create a file called `main.go` and start writing the necessary imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, write the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, write the `handler` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is where the magic happens. You can see a normal `http.HandleFunc` called
    with a `"/"` path as the first parameter, and then a handler function is passed,
    which contains a single instruction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This essentially sends to `ResponseWriter` the content of the "`index.html`"
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, write the last part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As is always the case, this starts the server, logs in case of an error, and
    exits the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you now save the file and you run the program with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And then you open your browser on the `localhost:8080` page, you should see
    the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.24: Hello world with a static template file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14177_15_24.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.24: Hello world with a static template file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'But now, without stopping your server, just change the HTML file, `index.html`,
    and modify line `8` where you see:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the text in the `<h1>` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the `index.html` file and, without touching the terminal and without restarting
    your server, just refresh your browser on the same page, and you should now see
    the following:![Figure 15.25: Hello world server with the static template file
    modified'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_15_25.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.25: Hello world server with the static template file modified'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, even if the server is running, it will pick up the new version of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this exercise, you've seen how to use a static HTML file to serve a web page,
    and how detaching the static resources from your application makes you able to
    change your served page without restarting your application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting Some Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to now, you've seen how to serve one static page and you might consider serving
    a few pages with the same method, maybe creating a handler struct with the name
    of the file to serve as an attribute. This might be impractical for large numbers
    of pages, although, in some cases, it is necessary. A web page, however, does
    not include just HTML code, but also images and styles, and some frontend code.
    It is not within the scope of this book to teach how to build HTML pages, and
    even less how to write JavaScript code or CSS style sheets, but you need to know
    how to serve these documents as we use a small CSS file to build our example.
    Serving static files and putting templates in different files, or generally using
    external resources, is a good way to separate concerns on our projects, and makes
    our projects more manageable and maintainable, so you should try to follow this
    approach in all your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add a style sheet to your HTML pages, you need to add a tag like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This injects the CSS file into the page as a "stylesheet", but this is reported
    here just by way of an example, in case you are interested in learning how to
    write HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have also seen that we have served files, reading them from the filesystem
    one by one, but Go provides us with an easy function to do the job for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Essentially, `http.FileServer` creates what the name says: a server serving
    external files, and it takes them from the directory defined in `http.Dir`. Whatever
    file we put inside the "`./public`" directory will be automatically accessible,
    adding in the address bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems good enough. However, in a real-world scenario, you do not want
    to expose your folder names and you want to specify a different name for your
    static resources. This is achieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that the `http.FileServer` function is wrapped by an `http.StripPrefix`
    function that we use in order to associate the requested path with the correct
    files on the filesystem. Essentially, we want a path of the `/statics` form to
    be available and to bind it to the content of the `public` folder. The `StripePrefix`
    function will remove the `"/statics/"` prefix from the request and will pass it
    to the file server, which will just get the name of the file to serve and will
    search for it in the `public` folder. It is not necessary, if you do not want
    to change the name of the path and folder, to use these wrappers, but this solution
    is general and works everywhere, so you can utilize it in other projects without
    having to worry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.06: A Stylish Welcome'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this exercise is to display a welcome page, making use of some external
    static resources. We will adopt the same approach as in *Exercise 15.05*, but
    we will add some extra files and code. We will place some stylesheets in a `static`
    folder, and we will serve them so that they can be used by other pages served
    by the same server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By way of a first step, create a folder called `stylish-welcome` and, inside
    this folder, add a file called `index.html` and incorporate the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, there are few differences compared with the previous HTML; we
    have a paragraph with some more text, wrapped by the `<p>` tag, and, inside the
    `<head>` tag, we include three links to external resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create a folder called `public` inside your `stylish-welcome` folder and
    create three files therein with these names and content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`header.css`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`body.css`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`text.css`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, go back to your main project folder, `stylish-welcome`, and create the
    `main.go` file. The content at the start corresponds exactly to that in one of
    the previous exercises:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the following code to handle the static files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code adds a handler to the "`/statics/`" path and it does so through an
    `http.FileServer` function, which returns a static file handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This function requires a directory to scrape, and we pass one to it as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This reads the local "`public`" folder that you created previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, add this final part to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here again, the server gets created and the `main()` function is closed. If
    you now run your server, again with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will now see the following:![Figure 15.26: Styled home page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_15_26.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.26: Styled home page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So somehow, the HTML file is now getting the style from the style sheets you
    created at the beginning.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s now examine how the files are injected. If you look back at the `index.html`
    file, you will see these lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'So essentially, we are looking for files under the path `"/statics/"`. Hence,
    you can go to these addresses and you will see:![Figure 15.27: body CSS file'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_15_27.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.27: body CSS file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.28: header CSS file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14177_15_28.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.28: header CSS file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.29: text CSS file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14177_15_29.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.29: text CSS file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So, all the style sheets are served. Furthermore, you can even go here:![Figure
    15.30: Static folder content visible in the browser'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_15_30.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.30: Static folder content visible in the browser'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And see all the files inside the `public` folder, served under the `/statics/`
    path. You can see that if you are looking for a simple static files server, Go
    allows you, with the help of a few lines of code, to create one, and, with a few
    more lines, you can make it production-ready.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you use Chrome, you can inspect with your mouse by right-clicking, or with
    any browser if you have a developer tool, and you will see something similar to
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.31: Developer tools showing loaded scripts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.31: Developer tools showing loaded scripts'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the files have been loaded and that the styles are shown as
    computed from the stylesheet on the right.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Dynamic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static assets are generally served as they are, but when you want to create
    a dynamic page, you might want to make use of an external template, which you
    can use on the fly, so that you can change the template without having to restart
    your server, or that you can load on startup, which means you will have to restart
    your server following any change (this is not strictly true, but we need some
    concepts of concurrent programming in order to make it happen). Loading a file
    at startup is executed simply for performance reasons. Filesystem operations are
    always the slowest, and even if Go is a fairly fast language, you might want to
    take performance into account when you want to serve your pages, especially if
    you have many requests from multiple clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will recall from a previous topic, we used the standard Go templates
    to make dynamic pages. Now, we can use the template as an external resource and
    put our template code in an HTML file and load it. The template engine can parse
    it and then fill the blanks with the passed parameters. To do this, we can use
    the `html/template` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be called, for example, with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In addition, the template is loaded in memory and is ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, you have been the sole user of your HTTP servers, but in an
    actual scenario, that is certainly not the case. In the following examples, we
    will look at performance and will use a resource loaded at startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 15.03: External Template'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will create a welcome server, like the ones you created
    before, and you will have to use the template package, as you've done before.
    In this activity, however, we do not want you to create your template from a hardcoded
    string but from an HTML file, which will contain all the template placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to complete this activity, making use of what you've learned
    so far in this chapter and in the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: This activity returns a pointer to a `template` and an error from a list of
    filenames. The error gets returned if any of the files do not exist or if the
    format of the template is wrong. In any case, do not concern yourself with the
    possibility of adding multiple files. Stick with one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder for your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a template with a name such as `index.html` and fill it with standard
    HTML code, with a welcome message and a placeholder for the name. Make sure that
    if the name is empty, the message inserts the word `visitor` where the name is
    supposed to be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create your `main.go` file and add to it the right package and imports.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main.go` file, create a `struct` holding a name that can be passed to
    a template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a template from a file using your `index.html` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create something that's able to handle the HTTP requests and use the `querystring`
    to receive parameters and display the data through the template created previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set all the paths to the server to use the function or handler created in the
    previous step and then create the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the server and check the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.32: Anonymous visitor page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.32: Anonymous visitor page'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the visitor page including the name will look something like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.33: Visitor page with the name "Will"'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.33: Visitor page with the name "Will"'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 763
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, you learned how to create a templated HTTP handler as a struct
    that can be initialized with any external template. You can now create multiple
    pages, instantiating the same struct with different templates of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, you've checked the results of your exercises and activities
    through your web browser, just visiting an address, your localhost, and getting
    some results back in the form of a web page. This way of consuming an HTTP server
    utilizes what is known as the `GET` method. You have seen the methods when you
    worked with the HTTP clients, which are the only way to use anything other than
    `GET` or `POST`. Through your web browser, however, you can also use the `POST`
    method, which is often used in order to send form data. It is possible to send
    form data through `GET`, but this method pollutes the URL with parameters and
    has some limitations in terms of the size of the data that can be sent.
  prefs: []
  type: TYPE_NORMAL
- en: There are other methods that are often used, these being `PUT` and `DELETE`,
    but you need a specific client to utilize them. That is why a set of these four
    methods is used in order to build what is called a `REST` API. There are other
    methods, but it is beyond the scope of this book to dig into all the HTTP methods,
    focusing instead on the ones that are most commonly used. A `REST` API is essentially
    a set of *paths* and methods that respond to specific requests. An HTTP server
    exposing a `REST` API is called a `REST server`. In order to understand why different
    methods are available, you need to understand how are they used. If you need to
    request some data, you are trying to get this data back, hence, the `GET` method
    is the most appropriate. If, instead, you want to modify a resource you are already
    familiar with, you want to put some specific values in a known location, you will
    use the `PUT` method, which essentially changes the state of the server in a known
    place. If you need to somehow modify the state of the server, you need to search
    for the resources to modify. For example, if you do not know their IDs, you will
    use the `POST` method. This is why you will often find online that the most common
    explanation for when to use `POST` and `PUT` is that the former is used to add
    resources, while the latter is used to update resources. Although this is most
    often true, it is not always the case, as you may also perform updates with the
    `POST` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will see how to use the different methods, `GET` and
    `POST`, to do different things with the same function. Note that in general, you
    might use more sophisticated external libraries to have more elegant code, but
    here, we are looking at how to do the basics and show how the standard Go library
    already offers us much in terms of helping us to do our work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.07: Completing a Questionnaire'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will build a form and you will send the data to another
    page. The form will contain questions such as your name, surname, and age, and
    this data will be sent to another page, which will display them. You will make
    use of what you've already learned, plus you'll see how to grab `posted` parameters
    from your `HTTP` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, create a folder called `questionnaire` and, inside this folder,
    incorporate a file called `index.html` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a normal template displaying items of personal information. If any data
    is missing, we simply display it as empty strings without hiding them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create a file called `form.html` and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is another page inside a form, with three text inputs and a button. The
    input fields represent the details we want to send. Note that the form has the
    action set to `"/",` which means that when clicking the button, the page gets
    redirected to the main path, but will transport the dataset in the form. The method
    attribute is set to `post,` which is the HTTP method discussed earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You now have to create the actual server in Go. Create a `main.go` file and
    add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create the struct for the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This holds all the attributes required for the template.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This holds the template, as seen previously.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, you need to create the `handler` function for the handler, so
    add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, a new empty visitor is created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check whether the request is a `Post` request, so you need to add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This checks the method against a constant provided by the Go `http` package.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Parse the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If an error occurs when parsing the form, we return with a `400` code, which
    is a bad request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the form gets parsed correctly, we can proceed, so add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, all the parameters from the form get assigned to the visitor's attribute.
    We then close the `if` statement and go to the common part of the handler function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As we have a visitor, empty or not depending on whether the form has been posted
    and with what values, we can finally return the page, so write:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to have a way to create the handler, so, as you''ve done before, add
    the following function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, you can write the `main()` function, which creates the handler,
    assigns it to the main path, and then assigns the static `form.html` file to the
    `/form` path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run your server, you will see the following by going to the main page:![Figure
    15.34: Empty details page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_15_34.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.34: Empty details page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you go to the `/form` path, you''ll see:![Figure 15.35: Empty form page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_15_35.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.35: Empty form page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And if you fill the data:![Figure 15.36: Filled form page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_15_36.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 15.36: Filled form page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And then press the `send` button, you will be redirected to this page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 15.37: Page with details added'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.37: Page with details added'
  prefs: []
  type: TYPE_NORMAL
- en: This, again, is the main page with the details set via the parameters you put
    into the form.
  prefs: []
  type: TYPE_NORMAL
- en: JSON loads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all HTTP servers are meant to be used by a browser and a human user. Very
    often, we have different software programs communicating with each other. These
    programs need to send messages to one another through a commonly accepted format,
    one of these being JSON. This stands for JavaScript Object Notation, which essentially
    means that it mimics how objects are created directly in JavaScript (another programming
    language). It is a simple format, not particularly verbose, and is easy to parse
    by a piece of software and easy to read for a human. As a user, however, you can
    use any one of the many tools to send and receive JSON payloads, two of the most
    common ones being **Insomnia** and **Postman**, which you can easily find online
    at [https://packt.live/2RY13Dt](https://packt.live/2RY13Dt) and [https://packt.live/2RY13Dt](https://packt.live/2RY13Dt).
  prefs: []
  type: TYPE_NORMAL
- en: They are both free and available for different platforms. You could also use
    `curl` as a command-line tool, but this becomes more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 15.08: Building a Server That Accepts JSON Requests'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will build a server that accepts a JSON message and will
    respond with another JSON message. You will not be able to use your browser to
    test it, but you can do it with a client such as **Insomnia** or **Postman**.
    The example screenshots will be provided using **Insomnia**, so it would be good
    for you to use the same. The server you will build accepts a message with a name
    and surname, and returns a message with some personalized greetings:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called `json-server` and add a file to it called `main.go`.
    Start adding packages and imports to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the packages imported are customary for HTTP programming, for logging,
    for formatting strings, and, of course, for JSON encoding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After this, you need to create models for the incoming and outcoming messages,
    so write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are pretty straightforward structs, including only what we need.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, add the `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And now set the function to handle the JSON messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the first thing inside the function is to create a JSON decoder,
    which will decode the request's body.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As a next step, write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we define a data variable of the `Request` type and we decode the body
    of the HTTP request into it. In case of any error, we return a `400` code for
    a bad request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the data has been decoded correctly, you can now use this data to create
    the response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the name and surname from the request are combined in a personalized greeting
    message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All that is now left is to send the message back to the requester:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, the response is encoded into a JSON string and is sent, writing it as
    a slice of bytes into the response writer. You can now run the server and open
    `Insomnia`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create the `main()` function to serve the pages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running the preceding code produces the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 15.38: Insomnia response'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_15_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.38: Insomnia response'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you can make a `post` request with Insomnia and send a JSON
    string to your server. On the right, you will see the response as a JSON document.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you''ve been introduced to the server side of web programming.
    You''ve learned how to accept requests from HTTP clients and respond in an appropriate
    manner. You''ve learned how to separate the possible requests into different areas
    of an HTTP server via paths and sub-paths. For this, you used a simple routing
    mechanism with the standard `Go HTTP` package. You''ve seen how to return your
    response in order to suit different consumers: JSON responses for synthetic clients,
    and HTML pages for human access. You''ve seen how to use templates in order to
    format your plain text and HTML messages, using the standard templating package.
    You''ve learned how to serve and use static resources, serving them directly through
    a default file server or through a template object. You''ve also learned what
    a `REST` service is, and although we have not built one together, you have all
    the knowledge necessary to create one, provided you follow the description you''ve
    been given. At this stage, you know all the basics for building production-grade
    HTTP servers, although you might want to use some external libraries to facilitate
    your hello world example, facilitating better routing by using something such
    as `gorilla mux` or, generally, the entire `gorilla` package, which is a low-level
    abstraction on top of the `http` package. You could use `hero` as a template engine
    to make your page rendering faster. One thing to mention is that you can make
    pretty much stateless services with what you''ve learned in this chapter, but
    you cannot create a production-grade stateful server at the moment as you do not
    know how to handle concurrent requests. This means that our `views counter` is
    not suitable for a production server yet, but this will be the subject of another
    chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will see how Go leverages the system of Goroutines
    to handle multiple work at the same time. This feature is very important, and
    you can apply it to HTTP servers and other types of projects where you have many
    concurrent users or whenever you want to do a lot of things at the same time.
  prefs: []
  type: TYPE_NORMAL
