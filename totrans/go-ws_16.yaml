- en: 16\. Concurrent Work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces you to the Go features that will allow you to perform
    concurrent work, or, in other words, achieve concurrency. The first feature you
    will learn is called a Goroutine. You'll learn what a Goroutine is and how you
    can use it to achieve concurrency. Then, you'll learn how to utilize WaitGroups
    to synchronize the execution of several Goroutines. You will also learn how to
    implement synchronized and thread-safe changes to variables shared across different
    Goroutines using atomic changes. To synchronize more complex changes, you will
    work with mutexes.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the chapter, you will experiment with the functionalities of channels
    and use message tracking to track the completion of a task.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is software that's meant to be used by a single user, and most of what
    you've learned so far in this book allows you to develop such applications. There
    is other software, however, that is meant to be used by several users at the same
    time. An example of this is a web server. You created web servers in *Chapter
    15, HTTP Servers*. They are designed to serve websites or web applications that
    are generally used by thousands of users at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: When multiple users are accessing a web server, it sometimes needs to perform
    a series of actions that are totally independent and whose result is the only
    thing that matters to the final output. All these situations call for a type of
    programming in which different tasks can be executed at the same time, independently
    from each other. Some languages allow parallel computation, where tasks are computed
    simultaneously. However, in some languages, such as Go, tasks are accomplished
    by the machine one piece per task; that is, each task, or process, is split into
    small pieces, and the program will execute a small piece of task at a time, until
    all the tasks are completed. This is known as concurrent programming.
  prefs: []
  type: TYPE_NORMAL
- en: In concurrent programming, when a task starts, all the other tasks start as
    well, but instead of completing them one by one, the machine performs a bit of
    each task at the same time. While Go allows concurrent programming, tasks can
    also be performed in parallel when the machine has multiple cores. From the perspective
    of the programmer, however, this distinction is not that important, as the tasks
    are created with the idea that they will be performed in parallel, and in whatever
    way the machine will perform them. Let's find out more in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Goroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine several people have some nails to hammer into a wall. Each person has
    a different number of nails and a different area of the wall, but there is only
    one hammer. Each person uses the hammer for one nail, then passes the hammer to
    the next person, and so on. The person with the fewest nails will finish earlier
    but they will all share the same hammer; this is how Goroutines work.
  prefs: []
  type: TYPE_NORMAL
- en: Using Goroutines, Go allows multiple tasks to run at the same time (they are
    also called coroutines). These are routines (read tasks) that can co-run inside
    the same process but are totally concurrent. Goroutines do not share memory, which
    is why they are different from threads. However, we will see how easy it is to
    pass variables across them in your code, and how this might lead to some unexpected
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Goroutine is nothing special; they are just normal functions. Actually,
    each function can easily become a Goroutine; all we have to do is to write the
    word `go` before calling the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a function called `hello`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to call our function as a Goroutine, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The function will run as a Goroutine. What this means can be understood better
    through the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code starts by printing `Start`, then it calls the `hello()` function. Then,
    the execution goes straight to printing `End` without waiting for the `hello()`
    function to complete. No matter how long it takes to run the `hello()` function,
    the `main()` function will not care about the `hello()` function as these functions
    will run independently. In order to better understand how this works, let's do
    some exercises.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to remember is that Go is not a parallel language, but concurrent,
    which means that Goroutines do not work in an independent manner, but each Goroutine
    is split into smaller parts and each Goroutine runs one of its subparts at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.01: Using Concurrent Routines'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's imagine we want to make two calculations. First, we sum all the numbers
    from `1` to `10`, then the numbers from `1` to `100`. In order to save time, we
    want to make both of these calculations happen independently and see both results
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder in your filesystem, and, inside it, create a `main.go`
    file and write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a function to sum two numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This accepts two integers as extremes (the minimum and maximum of an interval)
    and returns the sum of all the numbers in the range between these two extremes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the `main()` function, which sums the numbers `1` and `100`, then print
    the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s introduce some concurrency. Modify the `main()` function to look
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are running an anonymous function that assigns the value `s1` to the
    sum as before, but, if we run the code, the result will be `0`. If you try to
    remove the term `go` before the `func()` part, you will see that the result is
    `5050`. In this case, the anonymous function will run and start summing the numbers,
    but then there is a call to `fmt.Println`, which prints the value of `s1`. Here,
    the program waits for the `sum()` function to end before printing the value of
    `s1`, hence returning the correct result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we call the function and prepend the `go` word, the program prints the current
    value of `s1` while the function is still computing the sum, which is still `0`,
    and terminates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s call the `sum` function twice with two different ranges. Modify the
    `main()` function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you run this program, it will print the numbers `0` and `55`. This is because
    the concurrent function, `go func()`, does not have the time to return the result.
    The `main()` function is faster as it just has to count to `55` and not `5050`,
    so the program terminates before the concurrent function is finished.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To solve this problem, we want to find a way to wait for the *concurrent* function
    to finish. There are some correct ways to do this but, for now, let''s do something
    quite crude but effective, which is to wait for a fixed amount of time. In order
    to do so, just add this line before the `fmt.Println` command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If your IDE does not do it for you, modify the `import` section, just below
    the `package main` instruction, to look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you run your program now, you should see `5050 55` printed on the screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `main()` function, write code for the log to be printed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run your program now, you will see the same output again, `5050` `55`,
    but prepended by a timestamp representing when you ran the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the calculations have happened concurrently, and we have received
    both the outputs at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The full code for this exercise is available at: [https://packt.live/2Qek69K](https://packt.live/2Qek69K)'
  prefs: []
  type: TYPE_NORMAL
- en: WaitGroup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous exercise, we used a not-so-elegant method to ensure that the
    Goroutine ends by making the main routine wait for a second. The important thing
    to understand is that even if a program does not explicitly use Goroutines via
    the `go` call, it still uses one Goroutine, which is the main routine. When we
    run our program and create a new Goroutine, we are running two Goroutines: the
    main one and the one we just created. In order to synchronize these two Goroutines,
    Go gives us a function called `WaitGroup`. You can define a WaitGroup using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'WaitGroup needs the `sync` package to be imported. A typical code using the
    WaitGroup will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a pointer to a new WaitGroup, then we mention that we are adding
    an asynchronous operation that adds 1 to the group using `wg.Add(1)`. This is
    essentially a counter holding the number of all the concurrent routines that are
    running. Later, we add the code that will actually run the concurrent call. At
    the end, we tell the WaitGroup to wait for the Goroutines to end using `wg.Wait()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does the wait group know that the routines are complete? Well, we need
    to explicitly tell the WaitGroup about it inside the Goroutine with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This must be inside the main Goroutine function, which means it needs a reference
    to the WaitGroup. We will see this in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.02: Experimenting with WaitGroup'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say we calculate the addition in *Exercise 16.01*, *Using Concurrent Routines*,
    again using a Goroutine that runs concurrently with the main process. However,
    this time, we want to use a `WaitGroup` to synchronize the results. We have a
    few changes to make. Essentially, the `sum()` function needs to accept a new parameter
    for the `WaitGroup`, and there is no need to use the `time` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder and a `main.go` file inside it. The package and import
    parts of your file will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we just define the package as the `main` package, and then we import the
    `log` and `sync` packages. `log` will be used again to print out messages and
    `sync` will be used for the `WaitGroup`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, write the `sum` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we add a parameter called `wg` with a pointer to the `sync.WaitGroup` along
    with the result parameter. In the previous exercise, we wrapped the `sum` function
    with an anonymous function that ran as a Goroutine. Here, we want to avoid that,
    but we need to somehow get the result of the `sum` function. Hence, we pass an
    extra parameter as a pointer that will return the correct value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a loop to increment the `sum` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we set the value of what is held by the `res` pointer to `0`, then we
    just use the same loop that we saw earlier, but again associating the `sum` with
    the value pointed by the `res` parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now complete this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we tell the `WaitGroup` that this Goroutine is completed and then we return.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s write the `main()` function, which will set up the variables and
    then run the Goroutine that calculates the `sum`. We will then wait for the Goroutine
    to finish and display the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `main()` function is defined, and then a variable called `s1` is set
    to `0`. Also, a pointer to the WaitGroup is created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add one to the count of the WaitGroup and then run the Goroutine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code notifies the WaitGroup that there is one Goroutine running and then
    creates a new Goroutine calculating the `sum`. The `sum()` function will call
    the`.Done()` method to notify the `WaitGroup` of its completion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to wait for the Goroutine to finish. To do so, write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This also logs the result to the standard output.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the log output for the function using WaitGroups, as follows,
    with the timestamp:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this exercise, we have explored the functionality of `WaitGroup` by synchronizing
    Goroutines in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Race Conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One important thing to consider is that whenever we run multiple functions
    concurrently, we have no guarantee in what order each instruction in each function
    will be performed. In many architectures, this is not a problem. Some functions
    are not connected in any way with other functions, and whatever a function does
    in its routine does not affect the actions performed in other routines. This is,
    however, not always true. The first situation we can think of is when some functions
    need to share the same parameter. Some functions will just read from this parameter,
    while others will write to this parameter. As we do not know which operation will
    run first, there is a high likelihood that one function will override the value
    updated by another function. Let''s see an example that explains this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes a pointer to an integer as a parameter. It is a pointer
    because we want to run several Goroutines with the `next` function and update
    `v`. If we run the following code, we would expect that `a` will hold the value
    3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This is perfectly fine. However, what if we run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we might see that `a` holds 3, or 2, or 1\. Why would this happen?
    Because when a function executes the following statement, the value of `v` might
    be 0 for all the functions running in independent Goroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If this happens, then each function will set `v` to `c+1`, which means none
    of the routines are aware of what the other routines are doing and override any
    changes made by another routine. This problem is called a *race condition* and
    happens every time we work with shared resources without taking precautions. Fortunately,
    we have several ways to prevent this situation and to make sure that the same
    change is made only once. We will look at these solutions in the next sections,
    and we will explore the situation we just described in more detail, with a proper
    solution and race detection.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's imagine we want to run independent functions again. However, in this case,
    we want to modify the value held by a variable. We still want to sum the numbers
    from 1 to 100, but we want to split the work into two concurrent Goroutines. We
    can sum the numbers from 1 to 50 in one routine and the numbers from 51 to 100
    in another routine. At the end, we will need still to receive the value of 5050,
    but two different routines can add a number at the same time to the same variable.
    Let's see an example with only 4 numbers where we want to sum 1, 2, 3, and 4,
    and the result is 10\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of it like having a variable called `s:=0` and then making a loop where
    the value of `s` becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we could also have the following loop. In this case, the order in
    which the numbers are summed is different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, this is just the commutative property of the sum, but this gives
    us a hint that we can actually split the sum into two or more concurrent calls.
    The problem that arises here is that all the functions need to manipulate the
    same variable, `s`, which can lead to *race conditions* and incorrect final values.
    A *race condition* happens when two processes change the same variable and one
    process overrides the changes made by another process without taking into account
    the previous change. Thankfully, we have a package called *atomic*, which allows
    us to safely modify variables across Goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take a look at how this package works soon, but, for now, all you need
    to know is that this package has some functions for executing simple concurrent
    safe operations on variables. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This code takes a pointer to `int32` and modifies it by adding the value it
    points at to the value of `delta`. If `addr` holds a value of 2 and `delta` is
    4, after calling this function, `addr` will hold 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.03: An Atomic Change'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we want to calculate the sum of all the numbers between 1
    and 100 but with more concurrent Goroutines, let's say 4\. So, we have one function
    summing in the range of 1-25, one in the range of 26-50, then 51-75, and finally
    76-100\. We will use what we've learned about atomic operations and WaitGroups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder and a `main.go` file. Inside it, write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will import the same packages used for the previous exercises, in addition
    to the `sync/atomic` package.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to refactor the `sum` function from *Exercise 16.02*, *Experimenting
    with WaitGroup*, to use the `atomic` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we just changed `res` from `int` to `*int32`. The reason for this is that
    the `atomic` operations available specifically for arithmetic operations only
    work on `int32/64` and relative `uint32/64`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, write a loop to add each number to the total:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, instead of assigning the value of `res` as `0`, we are now adding
    `i` to the total value held by `res`. The rest of the code is unchanged.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to write the `main()` function to calculate the `sum` in four
    different Goroutines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we set `s1` to an `int32` type rather than `int` so we can send it as
    a parameter to the `sum` function. Then we create the pointer to WaitGroup.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, tell the WaitGroup that we will have four Goroutines running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run four Goroutines performing the sum over four ranges: 1-25, 26-50,
    51-75, and 76-100:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the code that waits for the routines to complete and print the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if you run the code with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The actual date will be different because it depends on when you run this code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s test the code. We will use it in order to show you what it means
    to have a race condition, and why we use this atomic package, and what concurrency
    safety is. Here is the test code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will run the same test 10,000 times.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run your test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result of the test on atomic changes is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And now add the `race` flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output when running these tests with the `race` flag is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, everything is fine so far.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s now remove the `sync/atomic` import and modify the `sum` function where
    you see this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run your program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The log output for a non-atomic change stays the same when using pointers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'But if you try running the test multiple times, you may see some different
    results, even though, in this case, that is quite unlikely. At this point, however,
    try running the tests with the `-race` flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 16.1: Race conditions arise when using the pointer here'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14177_16_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 16.1: Race conditions arise when using the pointer here'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''GCC'' must be installed in order to run this code.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s run the code without the `race` flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 16.2: Stack trace with racing conditions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_16_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.2: Stack trace with racing conditions'
  prefs: []
  type: TYPE_NORMAL
- en: By running the code several times, you can see different results because each
    routine can change the value of `s1` at any time and in any order, which we cannot
    know in advance.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you've learned how to use the atomic package to safely modify
    variables shared by multiple Goroutines. You've learned how direct access to the
    same variable from different Goroutines can be dangerous and how to use the atomic
    package to avoid this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The full code for this exercise is available at [https://packt.live/35UXbqD](https://packt.live/35UXbqD).
  prefs: []
  type: TYPE_NORMAL
- en: Invisible Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen in the previous exercise, the effects of concurrency through race
    conditions, but we want to see them in practice. It is easy to understand that
    concurrency problems are difficult to visualize as they do not manifest in the
    same way every time we run a program. That's why we are focusing on finding ways
    to synchronize concurrent work. One easy way to visualize it, however, but that
    is difficult to use in tests, is to print out each concurrent routine and see
    the order in which these routines are called. In the previous exercise, for example,
    we could have sent another parameter with a name and printed the name of the function
    at each iteration in the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to see the effects of concurrency and still be able to test it,
    we could use the atomic package again, this time with strings so that we can build
    a string containing a message from each Goroutine. For this scenario, we will
    use the `sync` package again, but we will not make use of the atomic operations.
    Instead, we will use a new struct called the `mutex`. Mutex is short for "mutual
    exclusion" and is essentially a way to stop all the routines, run the code in
    one, and then carry on with the concurrent code. Let''s see how we can use it.
    First of all, it needs the `sync` package to be imported. Then, we create a mutex
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'But most of the time we want to pass a mutex across several functions, so we''d
    better create a pointer to a mutex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This ensures we use the same mutex everywhere. It is important to use the same
    mutex, but the reason why the mutex has to be only one will be clear after analyzing
    the methods in the Mutex struct; consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet will lock the execution of all the routines, except
    the one that will change the variable. At this point, we will add 5 to the current
    value of `s`. After this, we release the lock using the following command so that
    any other routine can modify the value of `s`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: From now on, any following code will run concurrently. We will see later some
    better ways to ensure safety when we modify a variable, but, for now, do not worry
    about adding much code between the lock/unlock part. The more code there is between
    these constructs, the less concurrent your code will be. So, you should lock the
    execution of the program, add only the logic required to ensure safety, and unlock
    and then carry on with the execution of the rest of the code, which does not touch
    the shared variables.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to notice is that the order of asynchronously performed
    code can change. This is because Goroutines run independently and you cannot know
    which one runs first. However, each routine runs completely before letting another
    one run. You should then not rely on Goroutines to order things correctly; you
    might need to order your results afterward if you need a specific order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 16.01: Listing Numbers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, you will need to build a string with all the numbers from
    1 to 100\. However, instead of using a single loop, you need to split the work
    across four loops, like in *Exercise 16.03*. Moreover, each loop will add the
    numbers in its own loop. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder and a `main.go` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that takes a range in its parameters and a string to which
    you will add all the numbers in its range (also as strings).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrap each number with the character `"|"`, for example, `|4|`, so that the list
    will have the form `|4||10|`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `main()` function where you will create four Goroutines, each one
    having a range of 25 numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure all the routines modify the same string safely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the `main()` function will wait for the completion of the routines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the final string and run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should be able to complete this activity using everything you've studied
    so far in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run your program, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.3: First output when listing numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_16_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.3: First output when listing numbers'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you run it again multiple times, you will most likely see a different
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14177_16_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.4: Second attempt of listing numbers returns with a different order'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 766.
  prefs: []
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen how to create concurrent code via Goroutines, how to synchronize
    it with WaitGroup, how to perform atomic operations, and how to temporarily stop
    the concurrency in order to synchronize access to shared variables. We will now
    introduce a different concept, the channel, which is typical of Go. A channel
    is what the name essentially suggests â€“ it''s something where messages can be
    piped, and any routine can send or receive messages through a channel. Similar
    to a slice, a channel is created the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, it is possible to instantiate the channel directly with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like with slices, we can also do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, a channel is created with a buffer of 10 items.
  prefs: []
  type: TYPE_NORMAL
- en: A channel can be of any type, such as `integer`, `Boolean`, `float`, and any
    `struct` that can be defined, and even slices and pointers, though the last two
    are generally used less frequently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Channels can be passed as parameters to functions, and that''s how different
    Goroutines can share content. Let''s see how to send a message to a channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we send the value of 2 to the `ch` channel, which is a channel
    of integers. Of course, trying to send something else than an integer to an integer
    channel will cause an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'After sending a message, we need to be able to receive a message from a channel.
    To do that, we can just do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing this ensures that the message is received; however, the message is not
    stored. It might seem useless to lose the message, but we will see that it might
    actually make sense. Nevertheless, we might want to keep the value received from
    the channel, and we can do so by storing the value into a new variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see a simple program that shows us how to use what we''ve learned so
    far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'This program essentially creates a new channel, pipes the integer 1 in, then
    reads it, and finally prints out the value of `i`, which should be 1\. This code
    is not that useful in practice, but with a small change we can see something interesting.
    Let''s make the channel unbuffered by changing the channel definition to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the code, you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The message may be different depending on the version of Go you are using.
    Also, some errors like these have been introduced in newer versions. In older
    versions, though, the compiler was more permissive. In this specific case, the
    problem is simple: if we do not know how big the channel is, the routines wait
    indefinitely, and this is called a deadlock. This does not mean we cannot handle
    unbuffered channels. We will see later how to handle them, as they require more
    than one routine running. With only one routine, after we send the message, we
    block the execution and there is no other routine able to receive the message;
    hence, we have a deadlock.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go further, let''s see one more characteristic of the channels, which
    is that they can be closed. Channels need to be closed when the task they have
    been created for is finished. In order to close a channel, type in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can defer the closing, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In this case, after the `return` statement, the channel is closed as the closing
    is deferred to run after the `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.04: Exchange Greeting Messages via Channels'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will use a Goroutine to send a greeting message and then
    we will receive the greeting in the main process. The exercise is very simple
    and does not need concurrency, but it is a starting point to understand how message
    passing works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder. In it, create a `main.go` file with the `main` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create the `greeter()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function just sends a `Hello` message to a channel and ends.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now create the `main()` function where you instantiate a channel and pass it
    to the `greeter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, only a channel of strings is created and passed as a parameter to the
    call to a new routine called `greet`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now print the result and complete the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we are printing whatever comes from the channel. The following part of
    the code returns a value, which is passed straight to the `Println` function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we can see that the message has been delivered to the `main` function through
    the channel.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, you have seen how to use channels to make different Goroutines
    communicate with each other and to synchronize their computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.05: Two-Way Message Exchange with Channels'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we want now is to send messages from the main routine to the second routine
    and then get a message back as a response. We will base our code on the previous
    one and expand it. The main routine will send a `"Hello John"` message, while
    the second routine will return "`Thanks`" for the message received, stating it
    in full, and will then add a message: `"Hello David"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder. In it, create a `main.go` file with the main package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the necessary imports, we will use the `fmt` package to manipulate the
    strings.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a `greet()` function to return the expected messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `greet()` function signature has not changed. However, now before sending
    a message, it will first wait for a message and then reply. After receiving the
    message, this function sends a message back thanking for the greeting, and then
    sends its own greeting.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now create the `main()` function and call the `greet()` function as a Goroutine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the main function is created and a string channel is instantiated. Then,
    the second Goroutine is started. Next, we need to send the first message from
    the main routine to the second, which is currently waiting.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, to send the message "`Hello John`" to the channel, write the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, add the code that waits for the messages to come back before printing
    them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can see that you need to log twice as you expect two messages to come back.
    In many cases, you will use a loop to retrieve all the messages, which we will
    see in the next exercise. For now, try to run your code, and you will see something
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the output, you can see that both the messages have been received through
    the channel.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you have learned how a goroutine can both send and receive
    messages through the same channel and that two goroutines can exchange messages
    through the same channel in both directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.06: Sum Numbers from Everywhere'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine you want to add a few numbers but the numbers come from several sources.
    They might come from a feed or from a database; we just do not know which numbers
    we are going to add and where they come from. However, we need to add them all
    in one place. In this exercise, we will have four Goroutines sending numbers in
    particular ranges, and the main routine, which will calculate their sum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new folder and the main file. After you''ve done
    that, write the package and imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we also include the `time` package, which we will use to do a small trick
    that will help us to better visualize the effects of concurrency.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now write the `push` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sends all the numbers in the `from, to` range to the channel. After each
    message is sent, the routine sleeps for a microsecond so that another routine
    will pick up the work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now write the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code creates a variable for the final sum, `s1`, and one for the channel,
    `ch`, which has a buffer of 100.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now create the four `go` routines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, we need to gather all the numbers to add, so we create a loop
    of 100 cycles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then read the number from the channel like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also want to see which number came from which Goroutine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we calculate the sum and show the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we have the truncated output once you run the program:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, based on the results, we can easily guess which number comes from which
    routine. The last line displays the sum of all numbers. If you run your program
    multiple times, you will see that the order of the numbers changes as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, we saw how we can split some computational work across several
    concurrent routines and then gather all the computation in a single routine. Each
    routine performs a task. In this case, one sends numbers, while another receives
    the numbers and performs a sum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.07: Request to Goroutines'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will solve the same problem mentioned in *Exercise 16.06*,
    *Sum Numbers from Everywhere*, but in a different way. Instead of receiving numbers
    as the routines send them, we will make the main routine ask for the numbers from
    the other routines. We will play with channel operations and experiment with their
    blocking nature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder and a `main.go` file with the main package. Then, add the following
    import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then write the signature of the `push` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, there are two channels, a Boolean one called `in`, which represents the
    incoming requests, and `out`, which will be used to send back messages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now write a loop for sending numbers when a request comes in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the loop is still for a fixed number of items. Before sending
    anything, it waits for a request from the `in` channel. When it receives a request,
    it sends a number.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now create the `main()` function, where you call the `push` function in four
    different goroutines, each one sending a subset of the numbers 1 to 100:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is pretty similar to the previous exercise, but it creates the extra channel,
    `in`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now create a loop to request a number, print it, and add it to the total:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this case, the loop first requests a number, then waits to receive another
    number. Here, we do not need to sleep for a microsecond because after we receive
    a number, the next request will go to any active Goroutine. If you run the program,
    you will again see something similar to what you saw in the previous exercise.
    Here, we have the truncated output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can see that each number is printed in the order it is received. Then, the
    sum of all numbers is printed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you've learned how you can use channels to request other goroutines
    to perform some actions. A channel can be used to send some trigger messages and
    not only to exchange content and values.
  prefs: []
  type: TYPE_NORMAL
- en: The Importance of Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've seen how to use concurrency to split the work over several Goroutines,
    but in all these exercises concurrency was not really needed. In fact, you do
    not save much time doing what we did, nor do you have any other advantage. Concurrency
    is important when you need to perform several tasks that are logically independent
    from each other, and the easiest case to understand is a web server. You saw in
    *Chapter 15,* *HTTP Servers*, that several clients will most likely connect to
    the same server and all these connections will result in the server performing
    some actions. Also, these actions are all independent; that's where concurrency
    is important, as you do not want one of your users to have to wait for all the
    other HTTP requests to be completed before their request gets handled. Another
    case for concurrency is when you have different data sources to gather data and
    you can actually gather that data in different routines and combine the result
    at the end. We will see now some more complex applications for concurrency and
    learn how to use it for HTTP servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.08: Equally Splitting the Work between Routines'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will see how we can perform our sum of numbers in a predefined
    number of routines for them to gather the result at the end. Essentially, we want
    to create a function that adds numbers and receives the numbers from a channel.
    When no more numbers are received by the function, we will send the sum to the
    main function through the channel.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note here is that the function performing the sum does not know
    in advance how many numbers it will receive, which means we cannot have a fixed
    `from, to` range. So, we have to find another solution. We need to be able to
    split the work in any number of Goroutines and not be bound by a `from, to` range.
    Also, we do not want to do the addition in the main function. Instead, we want
    to create a function that will split the work over several routines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder and a `main.go` file with the main package and write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s write the function to do a partial addition. We will call it `worker()`
    as we will have a fixed set of routines running this same function, waiting for
    numbers to arrive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we have an `in` channel and an `out` channel of integers. Then,
    we instantiate the `sum` variable, which will store the sum of all the numbers
    sent to this worker.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we have a loop that ranges over the channel. This is interesting
    because we do not use `in` directly as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We, instead, rely only on the range to get the numbers in. In the loop, we just
    add `i` to the total and, at the end, we send the partial sum back. Even if we
    do not know how many items are going to be sent to the channel, we can still loop
    over the range without a problem. We rely on the fact that when no more items
    are sent, the `in` channel will be closed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now create the `sum()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the actual `sum` function that has the number of workers and the usual
    range for the numbers to add.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now write a loop to run the requested number of workers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This creates the two `in`/`out` channels and runs the number of workers set
    by the `workers` parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then create a loop to send all the numbers to the `in` channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This sends all the numbers to be summed to the channel, which will distribute
    the numbers across all the routines. If you were to print out the numbers received
    across with the index of the worker, you could see how the numbers are distributed
    uniformly across the routines, which does not mean an exact split, but at least
    it's a fair one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As we sent all the numbers, we now need to receive the partial sums back, but
    before that we need to notify the function that the numbers to sum are finished,
    so add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And then perform the sum of the partials:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, finally, close the `out` channel and return the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, we need to somehow execute this function. So, let''s write a
    simple main function to do that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This simply outputs a sum from a function that makes use of concurrency, and
    then prints out the result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you run your program, you should see the log output of the sum of numbers
    split into different routines as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, after splitting the computation across multiple goroutines,
    the result is synchronized into one single result.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you've learned how to make use of concurrency to split your
    computation across several concurrent goroutines and then combine all these computations
    into one single result.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way we organize our concurrent work is pretty much the same in every application.
    We will look at one common pattern that is called a *pipeline*, where we have
    a source, and then messages are sent from one routine to another until the end
    of the line, until all the routines in the pipeline have been utilized. Another
    pattern is the *fan out*/ *fan in* pattern where, as in the previous exercise,
    the work is sent to several routines reading from the same channel. All these
    patterns, however, are generally made of a *source* stage, which is the first
    stage of the pipeline and the one that gathers, or sources, the data, then some
    internal steps, and at the end a *sink*, which is the final stage where the results
    of the process from all the other routines get merged. It is known as a sink because
    all the data sinks into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 16.02: Source Files'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you will create a program that will read two files at the
    same time containing some numbers. You will need to pipe those numbers to a function
    that will split them into even and odd based on their values. It will then send
    the odd numbers to one routine, even numbers to another. It will then write the
    addition of all the even and odd numbers to another file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need two files with numbers that you will use as the sources. Then,
    you will produce one file with the sum of all the odd numbers in one row and then
    the sum of all the even numbers in the row below. The high-level steps for this
    activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create two input files. You could use more, but the suggested code will use
    two.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add some numbers in your input files, one number per line and nothing else.
    You need an empty line at the end of each file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create your main program and start with your imports.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to read a file and pipe each line to a channel. Be careful
    here, though; you may need to add a WaitGroup or something else to avoid any deadlocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to receive the numbers and pipe the odd numbers to one channel
    and the even numbers to another channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to sum the numbers and pipe the result to a new channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a merging function to read from the odd and even channels and write to
    a file called `result.txt`. Each line in this file should contain the word "Odd"
    or "Even," depending on the value, followed by the sum.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the main function to run all the Goroutines and handle the WaitGroups,
    if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you run your program, you should see nothing in the console, but a file
    called `result.txt` should have been created. Depending on the numbers in your
    input files, you will find that the content of the output file is something similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 768.
  prefs: []
  type: TYPE_NORMAL
- en: Buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ve seen in the previous exercises that there are channels with a defined
    length and channels with an undetermined length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how we can make use of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'A buffer is like a container that needs to be filled with some content, so
    you prepare it when you expect to receive that content. We said that operations
    on channels are blocking operations, which means the execution of the routine
    will stop and wait whenever you try to read a message from the channel. Let''s
    try to understand what this means in practice with an example. Let''s say we have
    the following code in a Goroutine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: We know that before we can carry on with the execution of the code, we need
    to receive a message. However, there is something more about this blocking behavior.
    If the channel does not have a buffer, the Goroutine is blocked as well. It is
    not possible to write to a channel, nor to receive a channel. We'll get a better
    idea of this with an example, and we will show how to use unbuffered channels
    to achieve the same result, so you will get a better understanding of what you've
    seen in the previous exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'If you put this code inside a function, you will see that it works perfectly
    and will display something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if you add an extra read? Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, you will see an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'This happens because the routine running this code is blocked after the buffer
    of size 2 is filled with a data size of 2 coming from the read operations (commonly
    referred to as reads), which result in the buffer being filled with data, which,
    in this case, has 2 data and the buffer has a size of 2\. We can increase the
    buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: And it will work again; we are just not displaying the third number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see what happens if we remove the buffer. Try, and again you will
    see the previous error. This happens because the buffer is always full and the
    routine is blocked. An unbuffered channel is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve used unbuffered channels without any issues. Let''s see an example of
    how to use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this program, you should see something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'But there is a chance you could see fewer numbers. If you run this on the Go
    Playground, you should see this result, but if you run it in your machine, you
    might see fewer numbers. Try sending more numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'At each addition, run your program; you might not see all the numbers. Basically,
    there are two routines: one is reading messages from an unbuffered channel, and
    the main routine is sending these messages through the same channel. Due to this,
    there is no deadlock. This shows that we can make use of unbuffered channels for
    read and write operations flawlessly by using two routines. We still have, however,
    an issue with not all numbers showing up, which we can fix in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Here, we iterate over the channel inside the Goroutine, and we stop as soon
    as the channel gets closed. This is because when the channel gets closed, the
    range stops iterating. The channel gets closed in the main routine after everything
    is sent. We make use of a WaitGroup here to know that everything is completed.
    If we were not closing the channel in the main function, we would be in the main
    routine, which will terminate before the second routine would print all the numbers.
    There is another way, however, to wait for the execution of the second routine
    to be completed, and this is with explicit notification, which we will see in
    the next exercise. One thing to notice is that even though we close the channel,
    the messages still all arrive at the receiving routine. This is because the channel
    is closed only after all the messages are received by the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.09: Notifying When Computation Has Finished'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we want to have one routine to send messages and another one
    to print them. Moreover, we want to know when the sender has finished sending
    the messages. The code will be similar to the previous example, with some modifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file and import the necessary packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then define the function that will first receive the strings and print them
    later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then create the loop over the channel until the channel is closed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, send the notification saying that the processing has finished:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s build the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we've also set the `log` flags to `0` so we do not see anything other
    than the strings we send.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create the necessary channels and use them to spin up the Goroutine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a set of strings and loop over them, sending each string to the
    channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After that, close the channel you used to send the messages and wait for the
    done signal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run your program, you will see the log output of code using a `done`
    channel:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We see that the main function has received all the messages from the Goroutine
    and has printed them. The main function terminates only when it has been notified
    that all the incoming messages have been sent.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, you've learned how you can make a Goroutine notify another
    Goroutine that the work has finished by passing a message through a channel without
    needing WaitGroup.
  prefs: []
  type: TYPE_NORMAL
- en: Some More Common Practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In all these examples, we''ve created channels and passed them through, but
    functions can also return channels and can also spin up new routines. Here is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we can actually have the following in our `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: We do not need to call the `doSomething` function as a Goroutine because it
    will actually spin up a new one by itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some functions can also return or accept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: This makes clear what the function does with the channels. In fact, you could
    try to specify the direction in all the exercises we've done so far and see what
    happens if you specify an incorrect one.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've seen how to build HTTP servers in *Chapter 15, HTTP Servers*, but you
    might remember that there was something that's difficult to handle with HTTP servers,
    and this was the application's state. Essentially, an HTTP server runs as a single
    program and listens to requests in the main routine. However, when a new HTTP
    request is made by one of the clients, a new routine is created that handles that
    specific request. You have not done it manually, nor have you managed the server's
    channels, but this is how it works internally. You do not actually need to send
    anything across the different Goroutines because each routine and each request
    is independent since they have been made by different people.
  prefs: []
  type: TYPE_NORMAL
- en: However, what you must think of is how to not create race conditions when you
    want to keep a state. Most HTTP servers are stateless, especially if you're building
    a microservice environment. However, you might want to keep track of things with
    a counter, or you might actually work with TCP servers or a gaming server or a
    chat app where you need to keep the state and gather information from all the
    peers. The techniques you've learned in this chapter allow you to do so. You can
    use a mutex to make sure a counter is thread-safe, or better, routine-safe, across
    all the requests. I'd suggest you go back to your code for the HTTP server and
    ensure safety with mutexes.
  prefs: []
  type: TYPE_NORMAL
- en: Methods as Routines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you've only seen functions used as Goroutines, but methods are simple
    functions with a receiver; hence, they can be used asynchronously too. This can
    be useful if you want to share some properties of your struct, such as for your
    counter in an HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: With this technique, you can encapsulate the channels you use across several
    routines belonging to the same instance of a struct without having to pass these
    channels everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example of how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: But let's see how to apply this in an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.10: A Structured Work'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will calculate a sum using several workers. A worker is
    essentially a function, and we will be organizing these workers into a single
    struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create your folder and `main` file. In it, add the required imports and define
    a `Worker` struct with two channels â€“ `in` and `out`. Ensure that you add a mutex
    as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To create its methods, write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we create a method and increment the number of `subworkers`. Sub-workers
    are basically identical routines that split the work that needs to be done. Note
    that the function is meant to be used directly and not as a Goroutine, as it itself
    creates a new Goroutine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, build the content of the spawned routine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is pretty similar to what you''ve done before; now comes the tricky part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we've locked the routine, reduced the counter on the sub-workers safely,
    and then, in case all the workers have terminated, we've closed the output channel.
    Then we've unlocked the execution to allow the program to carry on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we need to make a function that''s able to return the sum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we create a total, then a Waitgroup, and we add 1 to it as we will spawn
    only one routine whose content is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we have looped until the out channel is closed by one of the
    sub-workers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we can wait for the routine to finish and return the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The main code just sets up the variables for the worker and its sub-workers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now create a loop where you call the `readThem()` method `wrNum` times. This
    will create some sub-workers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now send the numbers to be summed to the channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Close the channel to notify that all the numbers have been sent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then wait for the result and print it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run the program, you will see the log output of a sum made using structs
    to organize our work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, you've learned how to use a method of a struct to create a
    new Goroutine. The method can just be called like any function, but the result
    will be a new anonymous goroutine being created.
  prefs: []
  type: TYPE_NORMAL
- en: Go Context Package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen how to run concurrent code and run it until it has finished, waiting
    for the completion of some processing through WaitGroup or channel reads. You
    might have seen in some Go code, especially code related to HTTP calls, some parameters
    from the `context` package, and you might have wondered what it is and why it
    is used. All the code we''ve written here is running in our machines and does
    not pass through the internet, so we hardly have any delay due to latency; however,
    in situations involving HTTP calls, we might encounter servers that do not respond
    and get stuck. In such cases, how do we stop our call if the server does not respond
    after a while? How do we stop the execution of a routine that runs independently
    when an event occurs? Well, we have several ways, but a standard one is to use
    contexts, and we will see now how they work. A context is a variable that is passed
    through a series of calls and might hold some values or may be empty. It is a
    container, but it is not used in order to send values across functions; you can
    use normal integers, strings, and so on for this purpose. A `context` is passed
    through in order to get back control of what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are several calls, and `c` is passed through but we do
    not do anything with it. However, it can contain data, and it contains functions
    that we can use in order to stop the execution of the current routine. We will
    see how it works in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.11: Managing Routines with Context'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will start a Goroutine with an infinite loop counting from
    zero until we decide to stop it. We will make use of the context to notify the
    routine to stop and a sleeping function to make sure we know how many iterations
    we do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create your folder and a `main.go` file, then write the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the usual imports, we have `logs` and `time`, which we've already seen,
    plus the `context` package.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s write a function that counts every 100 milliseconds from 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `v` is the value we count from zero. The `c` variable is the context,
    while the `r` variable is the channel returning the result. Then, we start defining
    the loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we start an infinite loop, but inside it we will have `select`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this `select` group, we have a case where we check whether the context is
    `done`, and if it is, we just break the loop and return the value we have counted
    so far.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the context is not `done`, we need to keep counting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we sleep for 100 milliseconds and then we increment the value by 1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is to write a `main()` function that makes use of this counter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We create an integer channel to pass to the counter and a `context`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to be able to cancel the context, so we extend this simple context
    with a cancellable context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we also finally call the counting routine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, we need a way to break the loop, so we will use the `stop()`
    function returned by `context.WithCancel`, but we will do that inside another
    Goroutine. This will stop the context after 300 milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And at this point, we just need to wait for the message with the count to be
    received and log it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After 300 milliseconds have passed, the counter will return 3 since, due to
    context manipulation, the routine stopped at the third iteration:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that even though the loop is infinite, the execution stops
    after three iterations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, you've learned how you can use the context to stop the execution
    of a routine. This is very useful in many cases, such as when performing long
    tasks that you want to stop after a maximum amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to mention is that, in this exercise, we did something that in some
    situations could lead to problems. What we did was create a channel in one Goroutine,
    but close it in another one. This is not wrong; in some cases, it might be useful,
    but try to avoid it as it could lead to problems when somebody looks at the code,
    or when you look at the code after several months, because it is difficult to
    track where a channel is closed across several functions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've learned how to create production-ready concurrent code,
    how to handle race conditions, and how to make sure that your code is concurrent-safe.
    You've learned how to use channels to make your goroutines communicate with each
    other and how to stop their executions using the context.
  prefs: []
  type: TYPE_NORMAL
- en: You've worked on several techniques to handle concurrent computation. In many
    real-life scenarios, you might just use functions and methods that handle concurrency
    for you, especially if you're doing web programming, but there are cases where
    you have to handle the work coming from some different sources by yourself. You
    need to match requests with your response through different channels. You might
    need to gather different data into one single routine from different ones. With
    what you've learned here, you'll be able to do all that. You'll be able to ensure
    you do not lose data by waiting for all the Goroutines to finish. You'll be able
    to modify the same variable from different routines, making sure you do not override
    a value if it is not what you want. You've also learned how to avoid deadlocks
    and how to use channels in order to share information. One of the Go mottos is
    "share by communicating, do not communicate by sharing." This means that the preferred
    way to share values is to send them via a channel and not rely on mutexes if not
    strictly necessary. You now know how to do all that.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn to make your code more professional. Essentially,
    you will learn what you are expected to do as a professional in a real working
    environment, which is testing and checking your code, making sure, essentially,
    that your code works and is valid.
  prefs: []
  type: TYPE_NORMAL
