<html><head></head><body>
		<div>
			<div id="_idContainer296" class="Content">
			</div>
		</div>
		<div id="_idContainer297" class="Content">
			<h1 id="_idParaDest-395"><a id="_idTextAnchor441"/>17. Using Go Tools</h1>
		</div>
		<div id="_idContainer308" class="Content">
			<p class="callout-heading"><a id="_idTextAnchor442"/>Overview</p>
			<p class="callout">This chapter will teach you how to make use of the Go toolkit to improve and build your code. It will also help you build and improve your code using Go tools and create binaries using <strong class="source-inline">go build</strong>. It will show you how to clean up library imports using <strong class="source-inline">goimports</strong>, detect suspicious constructs with <strong class="source-inline">go vet</strong>, and identify race conditions in your code using the Go race detector.</p>
			<p class="callout">By the end of this chapter, you will be able to run code with <strong class="source-inline">go run</strong>, format code with <strong class="source-inline">gofmt</strong>, automatically generate documentation using <strong class="source-inline">go doc</strong>, and download third-party packages using <strong class="source-inline">go get</strong>.</p>
			<h1 id="_idParaDest-396"><a id="_idTextAnchor443"/>Introduction</h1>
			<p>In the previous chapter, you've learned how to produce concurrent code. Although Go makes the task of creating concurrent code much easier compared to other languages, concurrent code is intrinsically complex. This is when learning to use tools to write better code that will simplify the complexity comes handy.</p>
			<p>In this chapter, you will learn about Go tools. <a id="_idTextAnchor444"/>Go comes with several tools to help you write better code. For example, in the previous chapters, you came across <strong class="source-inline">go build</strong>, which you used to build your code into an executable. You will also have come across <strong class="source-inline">go test</strong>, which you used to test your code. There are also a few more tools that help in different ways. For example, the <strong class="source-inline">goimports</strong> tool will check if you have all the import statements required for your code to work and if not, it will add them. It can also check if any of your import statements are no longer needed and remove them. While this seems like a very simple thing, it means you no longer need to worry about the imports and can instead focus on the code you are writing. Alternatively, you can use the Go race detect<a id="_idTextAnchor445"/>or to find race conditions hidden in your code. This is an extremely valuable tool when you start writing concurrent code.</p>
			<p>The tools provided with the Go language are one of the reasons for its popularity. They provide a standard way to check code for formatting issues, mistakes, and race conditions, which is very useful when you are developing software in a professional setting. The exercises in this chapter provide practical examples of how to use these tools to improve your code.</p>
			<h1 id="_idParaDest-397"><a id="_idTextAnchor446"/>The go build Tool</h1>
			<p>The <strong class="source-inline">go build</strong> tool takes Go source code and compiles it so it can be executed. When creating software, you write code in a human-readable programming language. Then, the code needs to be translated into a machine-readable format to execute. This is done by a compiler that compiles the machine instructions from the source code. To do this with Go code, you would use <strong class="source-inline">go build</strong>.</p>
			<h2 id="_idParaDest-398"><a id="_idTextAnchor447"/>Exercise 17.01: Using the go build Tool</h2>
			<p>In this exercise, you will learn about the <strong class="source-inline">go build</strong> tool. This will take your Go source code and compile it into a binary. To use it, run the <strong class="source-inline">go build</strong> tool on the command line, as follows:</p>
			<p class="source-code">go build -o name_of_the_binary_to_create source_file.go</p>
			<p>Let's get started:</p>
			<ol>
				<li>Create a new directory called <strong class="source-inline">Exercise17.01</strong> on your GOPATH. Within that directory, create a new file called <strong class="source-inline">main.go</strong>:</li>
				<li>Add the following code to the file to create a simple <strong class="source-inline">Hello World</strong> program:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">func main() {</p><p class="source-code">  fmt.Println("Hello World")</p><p class="source-code">}</p></li>
				<li>To run the program, you need to open your Terminal and navigate to the directory that you created the <strong class="source-inline">main.go</strong> file in. Then, run the <strong class="source-inline">go build</strong> tool by writing the following:<p class="source-code">go build -o hello_world main.go</p></li>
				<li>This will create an executable called <strong class="source-inline">hello_world</strong> that you can execute the binary in by running it on the command line:<p class="source-code">&gt; ./hello_world</p><p>The output will look as follows:</p><p class="source-code">Hello World</p></li>
			</ol>
			<p>In this exercise, you used the <strong class="source-inline">go build</strong> tool to compile your code into a binary and execute it.</p>
			<h1 id="_idParaDest-399"><a id="_idTextAnchor448"/>The go run Tool</h1>
			<p>The <strong class="source-inline">go run</strong> tool is similar to <strong class="source-inline">go build</strong> in that it compiles your Go code. However, the subtle difference is that <strong class="source-inline">go build</strong> will output a binary file that you can execute, whereas the <strong class="source-inline">go run</strong> tool doesn't create a binary file that you need to execute. It compiles the code and runs it in a single step, with no binary file output in the end. This can be useful if you want to quickly check that your code does what you expect it to do without the need to create and run a binary file. This would be commonly used when you're testing your code so that you can run it quickly without needing to create a binary to execute.</p>
			<h2 id="_idParaDest-400"><a id="_idTextAnchor449"/>Exercise 17.02: Using the go run Tool</h2>
			<p>In this exercise, you will learn about the <strong class="source-inline">go run</strong> tool. This is used as a shortcut to compile and run your code in a single step, which is useful if you want to quickly check that your code works. To use it, run the <strong class="source-inline">go run</strong> tool on the command line in the following format:</p>
			<p class="source-code">go run source_file.go</p>
			<p>Perform the following steps:</p>
			<ol>
				<li value="1">Create a new directory called <strong class="source-inline">Exercise17.02</strong> on your <strong class="source-inline">GOPATH</strong>. Within that directory, create a new file called <strong class="source-inline">main.go</strong>.</li>
				<li>Add the following code to the file to create a simple <strong class="source-inline">Hello Packt</strong> program:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">func main() {</p><p class="source-code">  fmt.Println("Hello Packt")</p><p class="source-code">}</p></li>
				<li>Now, you can run the program using the <strong class="source-inline">go run</strong> tool:<p class="source-code">go run main.go</p><p>This will execute the code and run it all in one step, giving you the following output:</p><p class="source-code">Hello Packt</p></li>
			</ol>
			<p><a id="_idTextAnchor450"/>In this exercise, you used the <strong class="source-inline">go run</strong> tool to compile and run a simple Go program in a single step. This is useful to quickly check whether your code does what you expect.</p>
			<h1 id="_idParaDest-401"><a id="_idTextAnchor451"/>The gofmt Tool</h1>
			<p>The <strong class="source-inline">gofmt</strong> tool is used to keep your code neat and consistently styled. When working on a large software project, an important, but often overlooked factor is code style. Having a consistent code style throughout your project is important for readability. When you have to read someone else's code, or even your own code months after writing it, having it in a consistent style makes you focus on the logic without much effort. Having to parse differing styles when reading code is just one more thing to worry about and leads to mistakes. To overcome this issue, Go comes with a tool to automatically format your code in a consistent way called <strong class="source-inline">gofmt</strong>. This means that, across your project, and even across other Go projects that use the <strong class="source-inline">gofmt</strong> tool, the code will be consistent. So, it will fix the formatting of the code by correcting the spacing and indentation, as well as trying to align the sections of your code.</p>
			<h2 id="_idParaDest-402"><a id="_idTextAnchor452"/>Exercise 17.03: Using the gofmt Tool</h2>
			<p>In this exercise, you'll learn how to use the <strong class="source-inline">gofmt</strong> tool to format your code. When you run the <strong class="source-inline">gofmt</strong> tool, it will display how it thinks the file should look with the correct formatting, but it won't change the file. If you would like <strong class="source-inline">gofmt</strong> to automatically change the file to the correct format, you can run <strong class="source-inline">gofmt</strong> with the <strong class="source-inline">-w</strong> option, which will update the file and save the changes. Let's get started:</p>
			<ol>
				<li value="1">Create a new directory called <strong class="source-inline">Exercise17.03</strong> on your GOPATH. Within that directory, create a new Go file called <strong class="source-inline">main.go</strong>.</li>
				<li>Add the following code to the file to create a badly formatted <strong class="source-inline">Hello Packt</strong> program:<p class="source-code">package main</p><p class="source-code">    import "fmt"</p><p class="source-code">func</p><p class="source-code">main(){</p><p class="source-code">  firstVar := 1</p><p class="source-code">       secondVar :=    2</p><p class="source-code">  fmt.Println(firstVar)</p><p class="source-code">                  fmt.Println(secondVar)</p><p class="source-code">  fmt.    Println("Hello Packt")</p><p class="source-code">                    }</p></li>
				<li>Then, in your Terminal, run <strong class="source-inline">gofmt</strong> to see what the file will look like:<p class="source-code">gofmt main.go</p><p>This will display how the file should be formatted to make it correct. The following is the expected output:</p><div id="_idContainer298" class="IMG---Figure"><img src="image/B14177_17_01.jpg" alt="Figure 17.1: Expected output for gofmt&#13;&#10;"/></div><p class="figure-caption">Figure 17.1: Expected output for gofmt</p><p>However, this only shows the changes it would make; it doesn't change the file. This is so you can confirm you are happy with the changes it will make.</p></li>
				<li>To actually change the file and save those changes, you need to add the <strong class="source-inline">-w</strong> option:<p class="source-code">gofmt <strong class="bold">-w</strong> main.go</p><p>This will update the file and save the changes. Then, when you look at the file, it should look like this:</p><p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">func main() {</p><p class="source-code">  firstVar := 1</p><p class="source-code">  secondVar := 2</p><p class="source-code">  fmt.Println(firstVar)</p><p class="source-code">  fmt.Println(secondVar)</p><p class="source-code">  fmt.Println("Hello Packt")</p><p class="source-code">}</p></li>
			</ol>
			<p>You may observe that the badly formatted code has been realigned after using the <strong class="source-inline">gofmt</strong> tool. The spacing and indentation have been fixed, and the new line between <strong class="source-inline">func</strong> and <strong class="source-inline">main()</strong> has been removed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Many <strong class="bold">Integrated Development Environments</strong> (<strong class="bold">IDEs</strong>) come with a built-in way to use <strong class="source-inline">gofmt</strong> on your code when you save. It is worth researching how to do this with your chosen IDE so that the <strong class="source-inline">gofmt</strong> tool will run automatically and fix any spacing or indentation mistakes in your code.</p>
			<p>In this exercise, you used the <strong class="source-inline">gofmt</strong> tool to reformat a badly formatted file into a neat state. This can seem pointless and annoying when you first start coding. However, as your skills improve and you start working on larger projects, you will start to appreciate the importance of a neat and consistent code style.</p>
			<h1 id="_idParaDest-403">T<a id="_idTextAnchor453"/>he goimports Tool</h1>
			<p>Another useful tool that comes with Go is <strong class="source-inline">goimports</strong>, which automatically adds the imports that are needed in your file. A key part of software engineering is not reinventing the wheel and reusing other people's code. In Go, you do this by importing the libraries at the start of your file, in the <strong class="source-inline">import</strong> section. It can, however, be tedious to add these imports each time you need to use them. You can also accidentally leave in unused imports, which can pose a security risk. A better way to do this is to use <strong class="source-inline">goimports</strong> to automatically add the imports for you. It will also remove unused imports and reorder the remaining imports into alphabetical order for better readability.</p>
			<h2 id="_idParaDest-404"><a id="_idTextAnchor454"/>Exercise 17.04: Using the goimports Tool</h2>
			<p>In this exercise, you will learn how to use <strong class="source-inline">goimports</strong> to manage the imports in a simple Go program. When you run the <strong class="source-inline">goimports</strong> tool, it will output how it thinks the file should look with the imports fixed. Alternatively, you can run <strong class="source-inline">goimports</strong> with the <strong class="source-inline">-w</strong> option, which automatically updates the imports in the file and saves the changes. Let's get started:</p>
			<ol>
				<li value="1">Create a new directory called <strong class="source-inline">Exercise17.04</strong> on your GOPATH. Within that directory, create a new file called <strong class="source-inline">main.go</strong>.</li>
				<li>Add the following code to the file to create a simple <strong class="source-inline">Hello Packt</strong> program with incorrect imports:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "net/http"</p><p class="source-code">  "fmt"</p><p class="source-code">)</p><p class="source-code">func main() {</p><p class="source-code">  fmt.Println("Hello")</p><p class="source-code">  log.Println("Packt")</p><p class="source-code">}</p><p>You will notice that the <strong class="source-inline">log</strong> library has not been imported and that the <strong class="source-inline">net/http</strong> import is unused.</p></li>
				<li>In your Terminal, run the <strong class="source-inline">goimports</strong> tool against your file to see how the imports change:<p class="source-code">goimports main.go</p><p>This will display the changes it would make to the file to correct it. The following is the expected output:</p><div id="_idContainer299" class="IMG---Figure"><img src="image/B14177_17_02.jpg" alt="Figure 17.2: Expected output for goimports&#13;&#10;"/></div><p class="figure-caption">Figure 17.2: Expected output for goimports</p><p>This won't have changed the file but shows what the file will be changed to. As you can see, the <strong class="source-inline">net/http</strong> import has been removed and the <strong class="source-inline">log</strong> import has been added.</p></li>
				<li>To write these changes to the file, add the <strong class="source-inline">-w</strong> option:<p class="source-code">goimports -w main.go</p></li>
				<li>This will update the file and make it look as follows:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "log"</p><p class="source-code">)</p><p class="source-code">func main() {</p><p class="source-code">  fmt.Println("Hello")</p><p class="source-code">  log.Println("Packt")</p><p class="source-code">}</p><p>Many IDEs come with a built-in way to turn on <strong class="source-inline">goimports</strong> so that when you save your file, it will automatically correct the imports for you.</p></li>
			</ol>
			<p>In this exercise, you learned how to use the <strong class="source-inline">goimports</strong> tool. You can use this tool to detect incorrect and unused import statements and automatically correct them.</p>
			<h1 id="_idParaDest-405">Th<a id="_idTextAnchor455"/>e go vet Tool</h1>
			<p>The <strong class="source-inline">go vet</strong> tool is used for static analysis of your Go code. While the Go compiler can find and inform you of mistakes you may have made, there are certain things it will miss. For this reason, the <strong class="source-inline">go vet</strong> tool was created. This might sound trivial, but some of these issues could go unnoticed for a long time after the code has been deployed, the most common of which is passing the wrong number of arguments when using the <strong class="source-inline">Prinf</strong> function. It will also check for useless assignments, for example, if you set a variable and then never use that variable. Another particularly useful thing it detects is when a non-pointer interface is passed to an "unmarshal" function. The compiler won't notice this as it is valid; however, the unmarshal function will be unable to write the data to the interface. This can be troublesome to debug but using the <strong class="source-inline">go vet</strong> tool allows you to catch it early and remediate the issue before it becomes a problem.</p>
			<h2 id="_idParaDest-406"><a id="_idTextAnchor456"/>Exercise 17.05: Using the go vet Tool</h2>
			<p>In this exercise, you will use the <strong class="source-inline">go vet</strong> tool to find a common mistake that's made when using the <strong class="source-inline">Printf</strong> function. You will use it to detect when the wrong number of arguments are being passed to a <strong class="source-inline">Printf</strong> function. Let's get started:</p>
			<ol>
				<li value="1">Create a new directory called <strong class="source-inline">Exercise17.05</strong> on your GOPATH. Within that directory, create a new go file called <strong class="source-inline">main.go</strong>:</li>
				<li>Add the following code to the file to create a simple <strong class="source-inline">Hello Packt</strong> program:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">func main() {</p><p class="source-code">  helloString := "Hello"</p><p class="source-code">  packtString := "Packt"</p><p class="source-code">  jointString := fmt.Sprintf("%s", helloString, packtString)</p><p class="source-code">  fmt.Println(jointString)</p><p class="source-code">}</p><p>As you can see, the <strong class="source-inline">jointString</strong> variable makes use of <strong class="source-inline">fmt.Sprintf</strong> to join two strings into one. However, the <strong class="source-inline">%s</strong> format string is incorrect and only formats one of the input strings. When you build this code, it will compile into a binary without any errors. However, when you run the program, the output will not be as expected. Luckily, the <strong class="source-inline">go vet</strong> tool was created for this exact reason.</p></li>
				<li>Run the <strong class="source-inline">go vet</strong> tool against the file you created:<p class="source-code">go vet main.go</p></li>
				<li>This will display any issues it finds in the code:<div id="_idContainer300" class="IMG---Figure"><img src="image/B14177_17_03.jpg" alt="Figure 17.3: Expected output of go vet&#13;&#10;"/></div><p class="figure-caption">Figure 17.3: Expected output of go vet</p><p>As you can see, <strong class="source-inline">go vet</strong> has identified an issue on line 9 of the file. The <strong class="source-inline">Sprintf</strong> call needs <strong class="source-inline">1</strong> argument, but we have given it <strong class="source-inline">2</strong>.</p></li>
				<li>Update the <strong class="source-inline">Sprintf</strong> call so that it can handle both arguments we want to send:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">func main() {</p><p class="source-code">  helloString := "Hello"</p><p class="source-code">  packtString := "Packt"</p><p class="source-code">  jointString := fmt.Sprintf("<strong class="bold">%s &amp;s</strong>", helloString, packtString)</p><p class="source-code">  fmt.Println(jointString)</p><p class="source-code">}</p></li>
				<li>Now, you can run <strong class="source-inline">go vet</strong> again and check that there are no more issues:<p class="source-code">go vet</p><p>It should return nothing, letting you know the file has no more issues. </p></li>
				<li>Now, run the program:<p class="source-code">go run main.go</p><p>The output after making corrections is the string we want, as follows:</p><p class="source-code">Hello Packt</p></li>
			</ol>
			<p>In <a id="_idTextAnchor457"/>this exercise, you learned how to use the <strong class="source-inline">go vet</strong> tool to detect issues that the compiler might miss. While this is a very basic example, <strong class="source-inline">go vet</strong> can detect mistakes such as passing a non-pointer to unmarshal functions or detecting unreachable code. It is encouraged to run <strong class="source-inline">go vet</strong> as part of your build process to catch these issues before they make it into your program.</p>
			<h1 id="_idParaDest-407"><a id="_idTextAnchor458"/>The Go Race Detector</h1>
			<p>The Go race detector was added to Go to be able to detect race conditions. As we mentioned in <em class="italic">Chapter 16</em>, <em class="italic">Concurrent Work</em>, you can use goroutines to run parts of your code concurrently. However, even experienced programmers might make a mistake that allows different goroutines to access the same resource at the same time. This is called a race condition. A race condition is problematic because one goroutine can edit the resource in the middle of another reading it, meaning the resource could be corrupted. While Go has made concurrency a first-class citizen in the language, the mechanisms for concurrent code do not prevent race conditions. Also, due to the inherent nature of concurrency, a race condition might stay hidden until long after your code has been deployed. This also means they tend to be transient, making them devilishly difficult to debug and fix. This is why the Go race detector was created. </p>
			<p>This tool works by using an algorithm that detects asynchronous memory access, but a drawback of this is that it can only do so when the code executes. So, you need to run the code to be able to detect race conditions. Luckily, it has been integrated into the Go toolchain, so we can use it to do this for us.</p>
			<h2 id="_idParaDest-408">Exe<a id="_idTextAnchor459"/>rcise 17.06: Using the Go Race Detector</h2>
			<p>In this exercise, you will create a basic program that contains a race condition. You will use the Go race detector on the program to find the race condition. You will learn how to identify where the problem lies and then learn ways to mitigate the race condition. Let's get started:</p>
			<ol>
				<li value="1">Create a new directory called <strong class="source-inline">Exercise17.06</strong> on your GOPATH. Within that directory, create a new file called <strong class="source-inline">main.go</strong>.</li>
				<li>Add the following code to the file to create a simple program with race conditions:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">func main() {</p><p class="source-code">  finished := make(chan bool)</p><p class="source-code">  names := []string{"Packt"}</p><p class="source-code">  go func() {</p><p class="source-code">    names = append(names, "Electric")</p><p class="source-code">    names = append(names, "Boogaloo")</p><p class="source-code">    finished &lt;- true</p><p class="source-code">  }()</p><p class="source-code">  for _, name := range names {</p><p class="source-code">    fmt.Println(name)</p><p class="source-code">  }</p><p class="source-code">  &lt;-finished</p><p class="source-code">}</p><p>As you can see, there is an array called <strong class="source-inline">names</strong> with one item in it. A goroutine then starts appending more names to it. At the same time, the main goroutine is attempting to print out all the items in the array. So, both goroutines are accessing the same resource at the same time, which is a race condition.</p></li>
				<li>Run the code with the <strong class="source-inline">race</strong> flag activated:<p class="source-code">go run <strong class="bold">--race</strong> main.go</p><p>Running this command will give us the following output:</p><div id="_idContainer301" class="IMG---Figure"><img src="image/B14177_17_04.jpg" alt="Figure 17.4: Expected output when using the Go race detector&#13;&#10;"/></div><p class="figure-caption">Figure 17.4: Expected output when using the Go race detector</p></li>
				<li>In the preceding screenshot, you can see a warning, informing you about the race condition. It tells you that the same resource was read and written in the code on lines <strong class="source-inline">main.go:10</strong> and <strong class="source-inline">main.go:15</strong>, which look as follows:<p class="source-code">  names = append(names, "Electric")</p><p>and</p><p class="source-code">  for _, name := range names {</p><p>As you can see, in both cases, it is the <strong class="source-inline">names</strong> array that is being accessed, so that is where the problem lies. The reason this happens is that the program starts to print the <strong class="source-inline">names</strong> before it waits for the <strong class="source-inline">finished</strong> channel.</p></li>
				<li>A solution could be to wait for the <strong class="source-inline">finished</strong> channel before printing the items:<p class="source-code">  &lt;-finished</p><p class="source-code">  for _, name := range names {</p><p class="source-code">    fmt.Println(name)</p><p class="source-code">  }</p></li>
				<li>This means the items will have all been added to the array before you start to print them out. You can confirm this solution by running the program again with the race flag activated:<p class="source-code">go run <strong class="bold">--race</strong> main.go</p></li>
				<li>This should run the program as normal and show no race condition warnings. The expected output after the corrections have been made is as follows:<p class="source-code">Packt</p><p class="source-code">Electric</p><p class="source-code">Boogaloo</p><p>The final program with the race condition now fixed would look as follows:</p><p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">func main() {</p><p class="source-code">  finished := make(chan bool)</p><p class="source-code">  names := []string{"Packt"}</p><p class="source-code">  go func() {</p><p class="source-code">    names = append(names, "Electric")</p><p class="source-code">    names = append(names, "Boogaloo")</p><p class="source-code">    finished &lt;- true</p><p class="source-code">  }()</p><p class="source-code">  &lt;-finished</p><p class="source-code">  for _, name := range names {</p><p class="source-code">    fmt.Println(name)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>While the program in this exercise was quite simple, as was the solution, you are encouraged to return to <em class="italic">Chapter 16</em>, <em class="italic">Concurrent Work</em>, and use the <strong class="source-inline">race</strong> flag in the activities there. This will provide a better working example of how the Go race detector can help you.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Go race detector is often used by professional software developers to confirm that their solution doesn't contain any hidden race conditions.</p>
			<h1 id="_idParaDest-409"><a id="_idTextAnchor460"/>The go doc Tool</h1>
			<p>The <strong class="source-inline">go doc</strong> tool is used to generate documentation for packages and functions in Go. An often-neglected part of many software projects is the documentation. This is because it can be tedious to write and even more tedious to keep up to date. So, Go comes with a tool to automatically generate documentation for package declarations and functions in your code. You simply need to add comments to the start of functions and packages. Then, these will be picked up and combined with the function header. </p>
			<p>This can then be shared with others to help them understand how to use your code. To generate the documentation for a package and its function, you can use the <strong class="source-inline">go doc</strong> tool. Documentation like this helps when you are working on a large project and other people need to make use of your code. Often, in a professional setting, different teams will be working on different parts of a program; each team will need to communicate to the other teams about what functions are available in a package and how to call them. To do this, they could use <strong class="source-inline">go doc</strong> to generate the documentation for the code they've written and share it with other teams.</p>
			<h2 id="_idParaDest-410">Exer<a id="_idTextAnchor461"/>cise 17.07: Implementing the go doc Tool</h2>
			<p>In this exercise, you will learn about the <strong class="source-inline">go doc</strong> tool and how it can be used to generate documentation for your code. Let's get started:</p>
			<ol>
				<li value="1">Create a new directory called <strong class="source-inline">Exercise17.07</strong> on your GOPATH. Within that directory, create a new file called <strong class="source-inline">main.go</strong>.</li>
				<li>Add the following code to the <strong class="source-inline">main.go</strong> file you created:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">// Add returns the total of two integers added together</p><p class="source-code">func Add(a, b int) int {</p><p class="source-code">  return a + b</p><p class="source-code">}</p><p class="source-code">// Multiply returns the total of one integers multiplied the other</p><p class="source-code">func Multiply(a, b int) int {</p><p class="source-code">  return a * b</p><p class="source-code">}</p><p class="source-code">func main() {</p><p class="source-code">  fmt.Println(Add(1, 1))</p><p class="source-code">  fmt.Println(Multiply(2, 2))</p><p class="source-code">}</p><p>This creates a simple program that contains two functions: one called <strong class="source-inline">Add</strong>, which adds two numbers, and one called <strong class="source-inline">Multiply</strong>, which multiplies two numbers.</p></li>
				<li>Run the following command to compile and execute the file:<p class="source-code">go run main.go</p></li>
				<li>The output will look as follows:<p class="source-code">2</p><p class="source-code">4</p></li>
				<li>You will notice that both functions have comments above them that begin with the name of the function. This is a Go convention to let you know that these comments can be used as documentation. What this means is that you can use the <strong class="source-inline">go doc</strong> tool to create documentation for the code. In the same directory as your <strong class="source-inline">main.go</strong> file, run the following:<p class="source-code"><strong class="bold">go doc</strong> -all</p></li>
				<li>This will generate documentation for the code and output it, as follows:</li>
			</ol>
			<div>
				<div id="_idContainer302" class="IMG---Figure">
					<img src="image/B14177_17_05.jpg" alt="Figure 17.5: Expected output from go doc&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.5: Expected output from go doc</p>
			<p>In this exercise. you learned how to use the <strong class="source-inline">go doc</strong> tool to generate documentation on the Go package you created, as well as its functions. You can use this for other packages you have created and share the documentation with others if they would like to make use of your code.</p>
			<h1 id="_idParaDest-411"><a id="_idTextAnchor462"/>The go get Tool</h1>
			<p>The <strong class="source-inline">g<a id="_idTextAnchor463"/>o get</strong> tool allows you to download and use different libraries. While Go comes with a wide range of packages by default, it is dwarfed by the number of third-party packages that are available. These provide extra functionality that you can use in your own code to enhance it. However, for your code to make use of these packages, you need to have them on your computer so that the compiler can include them when compiling your code. To download these packages, you can use the <strong class="source-inline">go get</strong> tool.</p>
			<h2 id="_idParaDest-412"><a id="_idTextAnchor464"/>Exercise 17.08: Implementing the go get Tool</h2>
			<p>In this exercise, you will learn how to download a third-party package using <strong class="source-inline">go get</strong>. Let's get started:</p>
			<ol>
				<li value="1">Create a new directory called <strong class="source-inline">Exercise17.08</strong> on your GOPATH. Within that directory, create a new file called <strong class="source-inline">main.go</strong>.</li>
				<li>Add the following code to the <strong class="source-inline">main.go</strong> file you created:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "log"</p><p class="source-code">  "net/http"</p><p class="source-code">  "github.com/gorilla/mux"</p><p class="source-code">)</p><p class="source-code">func exampleHandler(w http.ResponseWriter, r *http.Request) {</p><p class="source-code">  w.WriteHeader(http.StatusOK)</p><p class="source-code">  fmt.Fprintf(w, "Hello Packt")</p><p class="source-code">}</p><p class="source-code">func main() {</p><p class="source-code">  r := mux.NewRouter()</p><p class="source-code">  r.HandleFunc("/", exampleHandler)</p><p class="source-code">  log.Fatal(http.ListenAndServe(":8888", r))</p><p class="source-code">}</p></li>
				<li>This is a simple web server that you can start by running the following command:<p class="source-code">go run main.go</p></li>
				<li>However, the web server uses a third-party package called "<strong class="source-inline">mux</strong>." In the import section, you will see that it has been imported from "<strong class="source-inline">github.com/gorilla/mux</strong>." However, since we don't have this package stored locally, an error will occur when we try to run the program:<div id="_idContainer303" class="IMG---Figure"><img src="image/B14177_17_06.jpg" alt="Figure 17.6: Expected error message&#13;&#10;"/></div><p class="figure-caption">Figure 17.6: Expected error message</p></li>
				<li>To get the third-party package, you can use <strong class="source-inline">go get</strong>. This will download it locally so that our Go code can make use of it:<p class="source-code"><strong class="bold">go get</strong> github.com/gorilla/mux</p></li>
				<li>Now that you have downloaded the package, you can run the web server again:<p class="source-code">go run main.go</p><p>This time, it should run without any errors:</p><div id="_idContainer304" class="IMG---Figure"><img src="image/B14177_17_07.jpg" alt="Figure 17.7: Expected output when running the web server&#13;&#10;"/></div><p class="figure-caption">Figure 17.7: Expected output when running the web server</p></li>
				<li>While the web server is running, you can open <strong class="source-inline">http://localhost:8888</strong> in your web browser and check that it works:</li>
			</ol>
			<div>
				<div id="_idContainer305" class="IMG---Figure">
					<img src="image/B14177_17_08.jpg" alt="Figure 17.8: Web server output when viewed in Firefox&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.8: Web server output when viewed in Firefox</p>
			<p>In this <a id="_idTextAnchor465"/>exercise, you learned how to download third-party packages using the <strong class="source-inline">go get</strong> tool. This allows the use of tools and packages beyond what comes as a standard package in Go.</p>
			<h2 id="_idParaDest-413">Activity<a id="_idTextAnchor466"/> 17.01: Using gofmt, goimport, go vet, and go get to Correct a File</h2>
			<p>Imagine you are working on a project with poorly written code. The file contains a badly formatted file, missing imports, and a log message in the wrong place. You want to use the Go tools you've learned about in this chapter to correct the file and find any issues with it. In this activity, you will use <strong class="source-inline">gofmt</strong>, <strong class="source-inline">goimport</strong>, <strong class="source-inline">go vet</strong>, and <strong class="source-inline">go get</strong> to fix the file and find any issues within it. The steps for this activity are as follows:</p>
			<ol>
				<li value="1">Create a directory called <strong class="source-inline">Activity 17.01</strong>.</li>
				<li>Create a file called <strong class="source-inline">main.go</strong>.</li>
				<li>Add the example code to <strong class="source-inline">main.go</strong>.</li>
				<li>Fix any formatting issues.</li>
				<li>Fix any missing imports from <strong class="source-inline">main.go</strong>.</li>
				<li>Check for any issues the compiler may miss by using <strong class="source-inline">go vet</strong>.</li>
				<li>Ensure the third-party package, "<strong class="source-inline">gorilla/mux</strong>", has been downloaded to your local computer.<p>The following is the expected output:</p></li>
			</ol>
			<div>
				<div id="_idContainer306" class="IMG---Figure">
					<img src="image/B14177_17_09.jpg" alt="Figure 17.9: Expected output when running the code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.9: Expected output when running the code</p>
			<p>You can check this worked by going to <strong class="source-inline">http://localhost:8888</strong> in your web browser:</p>
			<div>
				<div id="_idContainer307" class="IMG---Figure">
					<img src="image/B14177_17_10.jpg" alt="Figure 17.10: Expected output when accessing the web server through Firefox&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.10: Expected output when accessing the web server through Firefox</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 775.</p>
			<p>The following is the example code to correct:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "log"</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "github.com/gorilla/mux"</p>
			<p class="source-code">)</p>
			<p class="source-code">// ExampleHandler handles the http requests send to this webserver</p>
			<p class="source-code">func </p>
			<p class="source-code">ExampleHandler(w http.ResponseWriter, r *http.Request) {</p>
			<p class="source-code">  w.WriteHeader(http.StatusOK)</p>
			<p class="source-code">fmt.Fprintf(w, "Hello Packt")</p>
			<p class="source-code">  return</p>
			<p class="source-code">  log.Println("completed")</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  r := mux.NewRouter()</p>
			<p class="source-code">  r.HandleFunc("/", ExampleHandler)</p>
			<p class="source-code">  log.Fatal(http.ListenAndServe(":8888", r))</p>
			<p class="source-code">}</p>
			<h1 id="_idParaDest-414"><a id="_idTextAnchor467"/>Summary</h1>
			<p>Go<a id="_idTextAnchor468"/><a id="_idTextAnchor469"/> tools are invaluable to a programmer when they're writing code. In this chapter, you learned about <strong class="source-inline">go build</strong> and how to compile your code into executables. Then, you learned how consistent neat code is important when working on a project and how you can use <strong class="source-inline">gofmt</strong> to automatically neaten up the code for you. This can be further improved with <strong class="source-inline">goimports</strong>, which can remove unnecessary imports for better security and automatically add imports you may have forgotten to add yourself.</p>
			<p>After, you looked at <strong class="source-inline">go vet</strong> and how it can be used to help you find any mistakes that the compiler may have missed. You also learned how to use the Go race detector to find race conditions hidden in your code. Then, you learned how to generate documentation for your code, which makes for easier collaboration when working on larger projects. Finally, you looked at downloading third-party packages using the <strong class="source-inline">go get</strong> tool, which allows you to make use of numerous Go packages that are available online to enhance your own code.</p>
			<p>In the next chapter, you will learn about security. You will learn how to prevent your code from being exploited and learn how to guard it against common attack vectors.</p>
		</div>
	</body></html>