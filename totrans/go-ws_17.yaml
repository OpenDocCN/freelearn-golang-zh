- en: 17\. Using Go Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will teach you how to make use of the Go toolkit to improve and
    build your code. It will also help you build and improve your code using Go tools
    and create binaries using `go build`. It will show you how to clean up library
    imports using `goimports`, detect suspicious constructs with `go vet`, and identify
    race conditions in your code using the Go race detector.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to run code with `go run`, format
    code with `gofmt`, automatically generate documentation using `go doc`, and download
    third-party packages using `go get`.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you've learned how to produce concurrent code. Although
    Go makes the task of creating concurrent code much easier compared to other languages,
    concurrent code is intrinsically complex. This is when learning to use tools to
    write better code that will simplify the complexity comes handy.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about Go tools. Go comes with several tools
    to help you write better code. For example, in the previous chapters, you came
    across `go build`, which you used to build your code into an executable. You will
    also have come across `go test`, which you used to test your code. There are also
    a few more tools that help in different ways. For example, the `goimports` tool
    will check if you have all the import statements required for your code to work
    and if not, it will add them. It can also check if any of your import statements
    are no longer needed and remove them. While this seems like a very simple thing,
    it means you no longer need to worry about the imports and can instead focus on
    the code you are writing. Alternatively, you can use the Go race detector to find
    race conditions hidden in your code. This is an extremely valuable tool when you
    start writing concurrent code.
  prefs: []
  type: TYPE_NORMAL
- en: The tools provided with the Go language are one of the reasons for its popularity.
    They provide a standard way to check code for formatting issues, mistakes, and
    race conditions, which is very useful when you are developing software in a professional
    setting. The exercises in this chapter provide practical examples of how to use
    these tools to improve your code.
  prefs: []
  type: TYPE_NORMAL
- en: The go build Tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `go build` tool takes Go source code and compiles it so it can be executed.
    When creating software, you write code in a human-readable programming language.
    Then, the code needs to be translated into a machine-readable format to execute.
    This is done by a compiler that compiles the machine instructions from the source
    code. To do this with Go code, you would use `go build`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 17.01: Using the go build Tool'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn about the `go build` tool. This will take
    your Go source code and compile it into a binary. To use it, run the `go build`
    tool on the command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory called `Exercise17.01` on your GOPATH. Within that directory,
    create a new file called `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the file to create a simple `Hello World` program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To run the program, you need to open your Terminal and navigate to the directory
    that you created the `main.go` file in. Then, run the `go build` tool by writing
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will create an executable called `hello_world` that you can execute the
    binary in by running it on the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, you used the `go build` tool to compile your code into a binary
    and execute it.
  prefs: []
  type: TYPE_NORMAL
- en: The go run Tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `go run` tool is similar to `go build` in that it compiles your Go code.
    However, the subtle difference is that `go build` will output a binary file that
    you can execute, whereas the `go run` tool doesn't create a binary file that you
    need to execute. It compiles the code and runs it in a single step, with no binary
    file output in the end. This can be useful if you want to quickly check that your
    code does what you expect it to do without the need to create and run a binary
    file. This would be commonly used when you're testing your code so that you can
    run it quickly without needing to create a binary to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 17.02: Using the go run Tool'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn about the `go run` tool. This is used as a
    shortcut to compile and run your code in a single step, which is useful if you
    want to quickly check that your code works. To use it, run the `go run` tool on
    the command line in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `Exercise17.02` on your `GOPATH`. Within that
    directory, create a new file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the file to create a simple `Hello Packt` program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can run the program using the `go run` tool:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will execute the code and run it all in one step, giving you the following
    output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, you used the `go run` tool to compile and run a simple Go
    program in a single step. This is useful to quickly check whether your code does
    what you expect.
  prefs: []
  type: TYPE_NORMAL
- en: The gofmt Tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `gofmt` tool is used to keep your code neat and consistently styled. When
    working on a large software project, an important, but often overlooked factor
    is code style. Having a consistent code style throughout your project is important
    for readability. When you have to read someone else's code, or even your own code
    months after writing it, having it in a consistent style makes you focus on the
    logic without much effort. Having to parse differing styles when reading code
    is just one more thing to worry about and leads to mistakes. To overcome this
    issue, Go comes with a tool to automatically format your code in a consistent
    way called `gofmt`. This means that, across your project, and even across other
    Go projects that use the `gofmt` tool, the code will be consistent. So, it will
    fix the formatting of the code by correcting the spacing and indentation, as well
    as trying to align the sections of your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 17.03: Using the gofmt Tool'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you''ll learn how to use the `gofmt` tool to format your
    code. When you run the `gofmt` tool, it will display how it thinks the file should
    look with the correct formatting, but it won''t change the file. If you would
    like `gofmt` to automatically change the file to the correct format, you can run
    `gofmt` with the `-w` option, which will update the file and save the changes.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `Exercise17.03` on your GOPATH. Within that directory,
    create a new Go file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the file to create a badly formatted `Hello Packt`
    program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in your Terminal, run `gofmt` to see what the file will look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display how the file should be formatted to make it correct. The
    following is the expected output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 17.1: Expected output for gofmt'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14177_17_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 17.1: Expected output for gofmt'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: However, this only shows the changes it would make; it doesn't change the file.
    This is so you can confirm you are happy with the changes it will make.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To actually change the file and save those changes, you need to add the `-w`
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will update the file and save the changes. Then, when you look at the
    file, it should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You may observe that the badly formatted code has been realigned after using
    the `gofmt` tool. The spacing and indentation have been fixed, and the new line
    between `func` and `main()` has been removed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Many `gofmt` on your code when you save. It is worth researching how to do this
    with your chosen IDE so that the `gofmt` tool will run automatically and fix any
    spacing or indentation mistakes in your code.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you used the `gofmt` tool to reformat a badly formatted file
    into a neat state. This can seem pointless and annoying when you first start coding.
    However, as your skills improve and you start working on larger projects, you
    will start to appreciate the importance of a neat and consistent code style.
  prefs: []
  type: TYPE_NORMAL
- en: The goimports Tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another useful tool that comes with Go is `goimports`, which automatically adds
    the imports that are needed in your file. A key part of software engineering is
    not reinventing the wheel and reusing other people's code. In Go, you do this
    by importing the libraries at the start of your file, in the `import` section.
    It can, however, be tedious to add these imports each time you need to use them.
    You can also accidentally leave in unused imports, which can pose a security risk.
    A better way to do this is to use `goimports` to automatically add the imports
    for you. It will also remove unused imports and reorder the remaining imports
    into alphabetical order for better readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 17.04: Using the goimports Tool'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn how to use `goimports` to manage the imports
    in a simple Go program. When you run the `goimports` tool, it will output how
    it thinks the file should look with the imports fixed. Alternatively, you can
    run `goimports` with the `-w` option, which automatically updates the imports
    in the file and saves the changes. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `Exercise17.04` on your GOPATH. Within that directory,
    create a new file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the file to create a simple `Hello Packt` program
    with incorrect imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will notice that the `log` library has not been imported and that the `net/http`
    import is unused.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In your Terminal, run the `goimports` tool against your file to see how the
    imports change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display the changes it would make to the file to correct it. The
    following is the expected output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 17.2: Expected output for goimports'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14177_17_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 17.2: Expected output for goimports'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This won't have changed the file but shows what the file will be changed to.
    As you can see, the `net/http` import has been removed and the `log` import has
    been added.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To write these changes to the file, add the `-w` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will update the file and make it look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Many IDEs come with a built-in way to turn on `goimports` so that when you save
    your file, it will automatically correct the imports for you.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, you learned how to use the `goimports` tool. You can use this
    tool to detect incorrect and unused import statements and automatically correct
    them.
  prefs: []
  type: TYPE_NORMAL
- en: The go vet Tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `go vet` tool is used for static analysis of your Go code. While the Go
    compiler can find and inform you of mistakes you may have made, there are certain
    things it will miss. For this reason, the `go vet` tool was created. This might
    sound trivial, but some of these issues could go unnoticed for a long time after
    the code has been deployed, the most common of which is passing the wrong number
    of arguments when using the `Prinf` function. It will also check for useless assignments,
    for example, if you set a variable and then never use that variable. Another particularly
    useful thing it detects is when a non-pointer interface is passed to an "unmarshal"
    function. The compiler won't notice this as it is valid; however, the unmarshal
    function will be unable to write the data to the interface. This can be troublesome
    to debug but using the `go vet` tool allows you to catch it early and remediate
    the issue before it becomes a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 17.05: Using the go vet Tool'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use the `go vet` tool to find a common mistake that''s
    made when using the `Printf` function. You will use it to detect when the wrong
    number of arguments are being passed to a `Printf` function. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory called `Exercise17.05` on your GOPATH. Within that directory,
    create a new go file called `main.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the file to create a simple `Hello Packt` program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the `jointString` variable makes use of `fmt.Sprintf` to join
    two strings into one. However, the `%s` format string is incorrect and only formats
    one of the input strings. When you build this code, it will compile into a binary
    without any errors. However, when you run the program, the output will not be
    as expected. Luckily, the `go vet` tool was created for this exact reason.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the `go vet` tool against the file you created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will display any issues it finds in the code:![Figure 17.3: Expected output
    of go vet'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_17_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 17.3: Expected output of go vet'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, `go vet` has identified an issue on line 9 of the file. The
    `Sprintf` call needs `1` argument, but we have given it `2`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the `Sprintf` call so that it can handle both arguments we want to send:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can run `go vet` again and check that there are no more issues:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It should return nothing, letting you know the file has no more issues.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output after making corrections is the string we want, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, you learned how to use the `go vet` tool to detect issues
    that the compiler might miss. While this is a very basic example, `go vet` can
    detect mistakes such as passing a non-pointer to unmarshal functions or detecting
    unreachable code. It is encouraged to run `go vet` as part of your build process
    to catch these issues before they make it into your program.
  prefs: []
  type: TYPE_NORMAL
- en: The Go Race Detector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go race detector was added to Go to be able to detect race conditions. As
    we mentioned in *Chapter 16*, *Concurrent Work*, you can use goroutines to run
    parts of your code concurrently. However, even experienced programmers might make
    a mistake that allows different goroutines to access the same resource at the
    same time. This is called a race condition. A race condition is problematic because
    one goroutine can edit the resource in the middle of another reading it, meaning
    the resource could be corrupted. While Go has made concurrency a first-class citizen
    in the language, the mechanisms for concurrent code do not prevent race conditions.
    Also, due to the inherent nature of concurrency, a race condition might stay hidden
    until long after your code has been deployed. This also means they tend to be
    transient, making them devilishly difficult to debug and fix. This is why the
    Go race detector was created.
  prefs: []
  type: TYPE_NORMAL
- en: This tool works by using an algorithm that detects asynchronous memory access,
    but a drawback of this is that it can only do so when the code executes. So, you
    need to run the code to be able to detect race conditions. Luckily, it has been
    integrated into the Go toolchain, so we can use it to do this for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 17.06: Using the Go Race Detector'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a basic program that contains a race condition.
    You will use the Go race detector on the program to find the race condition. You
    will learn how to identify where the problem lies and then learn ways to mitigate
    the race condition. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `Exercise17.06` on your GOPATH. Within that directory,
    create a new file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the file to create a simple program with race conditions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, there is an array called `names` with one item in it. A goroutine
    then starts appending more names to it. At the same time, the main goroutine is
    attempting to print out all the items in the array. So, both goroutines are accessing
    the same resource at the same time, which is a race condition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code with the `race` flag activated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Running this command will give us the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 17.4: Expected output when using the Go race detector'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14177_17_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 17.4: Expected output when using the Go race detector'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, you can see a warning, informing you about the
    race condition. It tells you that the same resource was read and written in the
    code on lines `main.go:10` and `main.go:15`, which look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: and
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, in both cases, it is the `names` array that is being accessed,
    so that is where the problem lies. The reason this happens is that the program
    starts to print the `names` before it waits for the `finished` channel.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A solution could be to wait for the `finished` channel before printing the
    items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This means the items will have all been added to the array before you start
    to print them out. You can confirm this solution by running the program again
    with the race flag activated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should run the program as normal and show no race condition warnings.
    The expected output after the corrections have been made is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final program with the race condition now fixed would look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While the program in this exercise was quite simple, as was the solution, you
    are encouraged to return to *Chapter 16*, *Concurrent Work*, and use the `race`
    flag in the activities there. This will provide a better working example of how
    the Go race detector can help you.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Go race detector is often used by professional software developers to confirm
    that their solution doesn't contain any hidden race conditions.
  prefs: []
  type: TYPE_NORMAL
- en: The go doc Tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `go doc` tool is used to generate documentation for packages and functions
    in Go. An often-neglected part of many software projects is the documentation.
    This is because it can be tedious to write and even more tedious to keep up to
    date. So, Go comes with a tool to automatically generate documentation for package
    declarations and functions in your code. You simply need to add comments to the
    start of functions and packages. Then, these will be picked up and combined with
    the function header.
  prefs: []
  type: TYPE_NORMAL
- en: This can then be shared with others to help them understand how to use your
    code. To generate the documentation for a package and its function, you can use
    the `go doc` tool. Documentation like this helps when you are working on a large
    project and other people need to make use of your code. Often, in a professional
    setting, different teams will be working on different parts of a program; each
    team will need to communicate to the other teams about what functions are available
    in a package and how to call them. To do this, they could use `go doc` to generate
    the documentation for the code they've written and share it with other teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 17.07: Implementing the go doc Tool'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn about the `go doc` tool and how it can be
    used to generate documentation for your code. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `Exercise17.07` on your GOPATH. Within that directory,
    create a new file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `main.go` file you created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This creates a simple program that contains two functions: one called `Add`,
    which adds two numbers, and one called `Multiply`, which multiplies two numbers.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the following command to compile and execute the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will notice that both functions have comments above them that begin with
    the name of the function. This is a Go convention to let you know that these comments
    can be used as documentation. What this means is that you can use the `go doc`
    tool to create documentation for the code. In the same directory as your `main.go`
    file, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will generate documentation for the code and output it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.5: Expected output from go doc'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_17_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17.5: Expected output from go doc'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise. you learned how to use the `go doc` tool to generate documentation
    on the Go package you created, as well as its functions. You can use this for
    other packages you have created and share the documentation with others if they
    would like to make use of your code.
  prefs: []
  type: TYPE_NORMAL
- en: The go get Tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `go get` tool allows you to download and use different libraries. While
    Go comes with a wide range of packages by default, it is dwarfed by the number
    of third-party packages that are available. These provide extra functionality
    that you can use in your own code to enhance it. However, for your code to make
    use of these packages, you need to have them on your computer so that the compiler
    can include them when compiling your code. To download these packages, you can
    use the `go get` tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 17.08: Implementing the go get Tool'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will learn how to download a third-party package using
    `go get`. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `Exercise17.08` on your GOPATH. Within that directory,
    create a new file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the `main.go` file you created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is a simple web server that you can start by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, the web server uses a third-party package called "`mux`." In the import
    section, you will see that it has been imported from "`github.com/gorilla/mux`."
    However, since we don''t have this package stored locally, an error will occur
    when we try to run the program:![Figure 17.6: Expected error message'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_17_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 17.6: Expected error message'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To get the third-party package, you can use `go get`. This will download it
    locally so that our Go code can make use of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that you have downloaded the package, you can run the web server again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, it should run without any errors:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 17.7: Expected output when running the web server'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14177_17_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 17.7: Expected output when running the web server'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While the web server is running, you can open `http://localhost:8888` in your
    web browser and check that it works:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 17.8: Web server output when viewed in Firefox'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_17_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17.8: Web server output when viewed in Firefox'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you learned how to download third-party packages using the
    `go get` tool. This allows the use of tools and packages beyond what comes as
    a standard package in Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 17.01: Using gofmt, goimport, go vet, and go get to Correct a File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine you are working on a project with poorly written code. The file contains
    a badly formatted file, missing imports, and a log message in the wrong place.
    You want to use the Go tools you''ve learned about in this chapter to correct
    the file and find any issues with it. In this activity, you will use `gofmt`,
    `goimport`, `go vet`, and `go get` to fix the file and find any issues within
    it. The steps for this activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a directory called `Activity 17.01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the example code to `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix any formatting issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix any missing imports from `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for any issues the compiler may miss by using `go vet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the third-party package, "`gorilla/mux`", has been downloaded to your
    local computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the expected output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 17.9: Expected output when running the code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_17_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17.9: Expected output when running the code'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check this worked by going to `http://localhost:8888` in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.10: Expected output when accessing the web server through Firefox'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_17_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17.10: Expected output when accessing the web server through Firefox'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 775.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the example code to correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go tools are invaluable to a programmer when they're writing code. In this chapter,
    you learned about `go build` and how to compile your code into executables. Then,
    you learned how consistent neat code is important when working on a project and
    how you can use `gofmt` to automatically neaten up the code for you. This can
    be further improved with `goimports`, which can remove unnecessary imports for
    better security and automatically add imports you may have forgotten to add yourself.
  prefs: []
  type: TYPE_NORMAL
- en: After, you looked at `go vet` and how it can be used to help you find any mistakes
    that the compiler may have missed. You also learned how to use the Go race detector
    to find race conditions hidden in your code. Then, you learned how to generate
    documentation for your code, which makes for easier collaboration when working
    on larger projects. Finally, you looked at downloading third-party packages using
    the `go get` tool, which allows you to make use of numerous Go packages that are
    available online to enhance your own code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about security. You will learn how to prevent
    your code from being exploited and learn how to guard it against common attack
    vectors.
  prefs: []
  type: TYPE_NORMAL
