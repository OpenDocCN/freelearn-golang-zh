<html><head></head><body>
		<div>
			<div id="_idContainer309" class="Content">
			</div>
		</div>
		<div id="_idContainer310" class="Content">
			<h1 id="_idParaDest-415"><a id="_idTextAnchor470"/>18. Security</h1>
		</div>
		<div id="_idContainer323" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter aims to equip you with the basic skills to protect your code from attacks and vulnerabilities. You will be able to evaluate the workings of major attack vectors, implement crypto libraries for the encryption and decryption of data and implement communication security by using TLS certificates.</p>
			<p class="callout">By the end of the chapter, you will be equipped to  identify common issues with code that could lead to security loopholes, and refactor code to make it more secure.</p>
			<h1 id="_idParaDest-416"><a id="_idTextAnchor471"/>Introduction</h1>
			<p>In the previous chapter, we learned about Go tools such as <strong class="source-inline">fmt</strong>, <strong class="source-inline">vet</strong>, and <strong class="source-inline">race</strong>, which are designed to help you with your code development. Let's now look at how to secure your code by looking at examples of common vulnerabilities. We'll also look at the packages in the standard library that can help you to store your data securely.</p>
			<p>Security cannot be an afterthought. It should be part of your code kata, something that you practice every day. Most vulnerabilities in applications stem from the developer not knowing about potential security attacks and from not having a security review of the application before it gets deployed.</p>
			<p>If you look at any websites dealing with sensitive data, for example, banking websites, they will have basic security in place, such as the use of a signed SSL certificate. It is always better to design your application with security in mind than to add security layers later, so as to avoid refactoring or redesigning your application. In this chapter, we will cover some major attack vectors and best practices that will guide you in securing your application. The following basic sanity checks in your code will guarantee that you are protected by default from most vulnerabilities and attacks.</p>
			<h1 id="_idParaDest-417"><a id="_idTextAnchor472"/>Application Security</h1>
			<p>During the development of your application, you will not be able to anticipate all the possible ways in which it could be compromised. However, you can always try to safeguard the application by following safe coding practices, such as the encryption of data in transit and at rest. It is a well-known fact that if we protect an application from well-known attack vectors such as SQL injection, we will be able to ward off most attacks. We will cover topics such as the use of digital certificates and hashing sensitive data to protect it from attackers.</p>
			<p>One of the major attack vectors of a software application is the command or SQL injection, in which malicious user input can change the behavior of a command or query. This can happen with poorly constructed queries in SQL, HTTP URLs, or in OS commands.</p>
			<p>Let's look at SQL injection and command injection in detail.</p>
			<h2 id="_idParaDest-418"><a id="_idTextAnchor473"/>SQL Injection</h2>
			<p><a id="_idTextAnchor474"/>If you are working on an application that needs to store data, you will most likely be using a database.</p>
			<p>SQL injection is a way of injecting malicious code into your database query. Although unintentional, this could have a drastic impact on your application, such as the loss of data or the leaking of sensitive information.</p>
			<p>Let's look at some examples to understand what exactly the SQL injection is and how it works.</p>
			<p>The following function takes a <strong class="source-inline">userID</strong> parameter and uses it to query the database to return the card number that belongs to the user:</p>
			<p class="source-code">func GetCardNumber(db *sql.DB, userID string) (resp string, err error) {</p>
			<p class="source-code">  query := `SELECT CARD_NUMBER FROM USER_DETAILS WHERE USER_ID = ` + userID</p>
			<p class="source-code">  row := db.QueryRow(query)</p>
			<p class="source-code">  switch err = row.Scan(&amp;resp); err {</p>
			<p class="source-code">  case sql.ErrNoRows:</p>
			<p class="source-code">    return resp, fmt.Errorf("no rows returned")</p>
			<p class="source-code">  case nil:</p>
			<p class="source-code">    return resp, err</p>
			<p class="source-code">  default:</p>
			<p class="source-code">    return resp, err</p>
			<p class="source-code">  }</p>
			<p class="source-code">  return</p>
			<p class="source-code">}</p>
			<p>If the user input is <strong class="source-inline">795001</strong>, the query string will resolve to:</p>
			<p class="source-code">query := `SELECT CARD_NUMBER FROM USER_DETAILS WHERE USER_ID = 795001`</p>
			<p>However, it is possible for a malicious user to construct an input string that will cause the function to retrieve information that does not belong to the user. For example, they could pass in the following input to the function:</p>
			<p class="source-code">"" OR '1' == '1'</p>
			<p>This user input would generate a query that would return the <strong class="source-inline">CARD_NUMBER</strong> of all users:</p>
			<p class="source-code">`SELECT CARD_NUMBER FROM USER_DETAILS WHERE USER_ID = "" OR '1' == '1'</p>
			<p>As you can see, it is very easy to make a mistake when defining a database query.</p>
			<p>Along with getting unauthorized access to data, <a id="_idTextAnchor475"/>SQL injection can also be used to corrupt or even delete data.</p>
			<p>So, what is the idiomatic way of defining a query? We should never construct a query by concatenating user input to form a query string. Instead, use a prepared statement to define a query, in which a placeholder is used to pass the user parameter, as shown in the following example:</p>
			<p class="source-code">func GetCardNumberSecure(db *sql.DB, userID string) (resp string, err error){</p>
			<p class="source-code">  stmt, err := db.Prepare(`SELECT CARD_NUMBER FROM USER_DETAILS WHERE USER_ID =     ?`)</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    return resp, err</p>
			<p class="source-code">  }</p>
			<p class="source-code">  defer stmt.Close()</p>
			<p class="source-code">  row := stmt.QueryRow(userID)</p>
			<p class="source-code">  switch err = row.Scan(&amp;resp); err {</p>
			<p class="source-code">  case sql.ErrNoRows:</p>
			<p class="source-code">    return resp, fmt.Errorf("no rows returned")</p>
			<p class="source-code">  case nil:</p>
			<p class="source-code">    return resp, err</p>
			<p class="source-code">  default:</p>
			<p class="source-code">    return resp, err}</p>
			<p class="source-code">  }</p>
			<p class="source-code">  return</p>
			<p class="source-code">}</p>
			<p>By using placeholders for the user input, we have mitigated potential SQL injection attacks.</p>
			<h2 id="_idParaDest-419"><a id="_idTextAnchor476"/>Command Injection</h2>
			<p><a id="_idTextAnchor477"/>Command injection is another possible injection attack vector that you should be aware of. The injection aims to execute OS commands on the application server, which could allow the attacker to get sensitive data, delete files, or even execute malicious scripts on the server. This type of attack can happen when the user input is not sanitized.</p>
			<p>We will see how this works by looking at the following example. Consider this function, which takes a string as input and uses it to list files:</p>
			<p class="source-code">func listFiles(path string) (string, error) {</p>
			<p class="source-code">  cmd := exec.Command("bash", "-c", "ls"+path)</p>
			<p class="source-code">  var out bytes.Buffer</p>
			<p class="source-code">  cmd.Stdout = &amp;out</p>
			<p class="source-code">  err := cmd.Run()</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    return "", err</p>
			<p class="source-code">  }</p>
			<p class="source-code">  return out.String(), nil</p>
			<p class="source-code">}</p>
			<p>There are a few things wrong here:</p>
			<ul>
				<li>The user input is not sanitized.</li>
				<li>The user could pass in any string as a path.</li>
				<li>Along with <strong class="source-inline">path string</strong>, the user could add other commands that could run on the server.</li>
			</ul>
			<p>Let's test this by running a unit test on the function. The following test run should prove all the issues previously listed:</p>
			<p class="source-code">package command_injection</p>
			<p class="source-code">import "testing"</p>
			<p class="source-code">func TestListFiles(t *testing.T) {</p>
			<p class="source-code">  out, err := listFiles(" .; cat /etc/hosts")</p>
			<p class="source-code">  if err != nil {</p>
			<p class="source-code">    t.Error(err)</p>
			<p class="source-code">  } else {</p>
			<p class="source-code">    t.Log(out)</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>You should get the following output when you run the test using the preceding command:</p>
			<p class="source-code">go test -v ./...</p>
			<div>
				<div id="_idContainer311" class="IMG---Figure">
					<img src="image/B14177_18_01.jpg" alt="Figure 19.1: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 18.1: Expected output</p>
			<p>A<a id="_idTextAnchor478"/>s you can see, instead of passing a valid filename, the user passed a string that made the function return the files in the directory as well as reading the <strong class="source-inline">/etc/hosts</strong> file on the server.</p>
			<h2 id="_idParaDest-420">E<a id="_idTextAnchor479"/>xercise 18.01: Handling SQL Injection</h2>
			<p>I<a id="_idTextAnchor480"/>n this exercise, we will be enabling a function to prevent an SQL injection attack.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In this exercise, we will be using a lightweight database called <strong class="source-inline">Sqlite</strong>, which can run in-memory on your local machine. To use the database, we will need to import a third-party Go library that uses <strong class="source-inline">cgo</strong> under the hood.</p>
			<p class="callout"><a href="https://packt.live/38Bjl3a">https://packt.live/38Bjl3a</a></p>
			<p class="callout">If you are on a Windows machine, you will need to have GCC installed and included in your path. You can use the instructions on this website to install GCC for windows: https://packt.live/38Bjl3a.</p>
			<p>T<a id="_idTextAnchor481"/>he following steps will help you with the solution:</p>
			<ol>
				<li>Create <strong class="source-inline">injection.go</strong> and import the following packages:<p class="source-code">package exercise1</p><p class="source-code">import (</p><p class="source-code">  "database/sql"</p><p class="source-code">  "fmt"</p><p class="source-code">  "strings"</p><p class="source-code">)</p></li>
				<li>Define a function, <strong class="source-inline">UpdatePhone()</strong>, that takes a <strong class="source-inline">sql.DB</strong> object and some user information such as an ID and a phone number as a <strong class="source-inline">string</strong>:<p class="source-code">func UpdatePhone(db *sql.DB, Id string, phone string) error {</p><p class="source-code">  var builder strings.Builder</p><p class="source-code">  builder.WriteString("UPDATE USER_DETAILS SET PHONE=")</p><p class="source-code">  builder.WriteString(phone)</p><p class="source-code">  builder.WriteString(" WHERE USER_ID=")</p><p class="source-code">  builder.WriteString(Id)</p><p class="source-code">  fmt.Printf("Running query: %s\n", builder.String())</p><p class="source-code">  _, err := db.Exec(builder.String())</p><p class="source-code">  if err != nil {</p><p class="source-code">    return err</p><p class="source-code">  }</p><p class="source-code">  return nil</p><p class="source-code">}</p><p>The <strong class="source-inline">UpdatePhone()</strong> function inserts a user ID and a phone number into the table by concatenating the data from the input parameters.</p><p>The query string in the <strong class="source-inline">UpdatePhone()</strong> function is vulnerable to SQL injection. For example, if an input is passed with the following values:</p><p class="source-code">ID: "19853011 OR USER_ID=1007007"</p><p>This will update the record not only for user ID <strong class="source-inline">"19853011"</strong>, but also for <strong class="source-inline">"1007007"</strong>. This is a simple example. However, there could be worse things that could happen, such as dropping tables in the database.</p></li>
				<li>Create another function called <strong class="source-inline">UpdatePhoneSecure()</strong>, which will update the user details securely. Instead of concatenating inputs to form the query, use placeholders for the parameters to pass into the query:<p class="source-code-heading">injection.go</p><p class="source-code">20 func UpdatePhoneSecure(db *sql.DB, Id string, phone string) error {</p><p class="source-code">21   stmt, err := db.Prepare(`UPDATE USER_DETAILS SET PHONE=? WHERE        USER_ID=?`)</p><p class="source-code">22   if err != nil {</p><p class="source-code">23     return err</p><p class="source-code">24   }</p><p class="source-code">25   defer stmt.Close()</p><p class="source-code">26   result, err := stmt.Exec(phone, Id)</p><p class="source-code">27   if err != nil {</p><p class="source-code">28     return err</p><p class="source-code">29   }</p><p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/34QWP31">https://packt.live/34QWP31</a><a href="https://github.com/PacktWorkshops/The-Go-Workshop/blob/db08f8b51a54c3ced6b6eb5f1a075322919fe947/Chapter19/Exercise19.01/injection.go#L20-L41 "/></p></li>
				<li>Define a helper function called <strong class="source-inline">initializeDB()</strong> to set up the database and load some test data:<p class="source-code">func initializeDB(db *sql.DB) error {</p><p class="source-code">  _, err := db.Exec(`CREATE TABLE IF NOT EXISTS USER_DETAILS (USER_ID TEXT,     PHONE TEXT, ADDRESS TEXT)`)</p><p class="source-code">  if err != nil {</p><p class="source-code">    return err</p><p class="source-code">  }</p><p class="source-code">  stmt, err := db.Prepare(`INSERT INTO USER_DETAILS (USER_ID, PHONE,     ADDRESS) VALUES (?, ?, ?)`)</p><p class="source-code">  if err != nil {</p><p class="source-code">    return err</p><p class="source-code">  }</p><p class="source-code">  for _, user := range testData {</p><p class="source-code">    _, err := stmt.Exec(user.Id, user.CardNumber, user.Address)</p><p class="source-code">    if err != nil {</p><p class="source-code">      return err</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">  return nil</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">It is good practice to clean up after every test.</p></li>
				<li>Define a function called <strong class="source-inline">tearDownDB()</strong> to help you clear the database:<p class="source-code">func tearDownDB(db *sql.DB) error {</p><p class="source-code">  _, err := db.Exec("DROP TABLE USER_DETAILS")</p><p class="source-code">  if err != nil {</p><p class="source-code">    return err</p><p class="source-code">  }</p><p class="source-code">  return nil</p><p class="source-code">}</p></li>
				<li>We will also need a function to help with the setting up of the database connection. Define a function called <strong class="source-inline">getConnection()</strong>, which returns a <strong class="source-inline">*sql.DB</strong> object:<p class="source-code">func getConnection() (*sql.DB, error) {</p><p class="source-code">  conn, err := sql.Open("sqlite3", "test.DB")</p><p class="source-code">  if err != nil {</p><p class="source-code">    return nil, fmt.Errorf("could not open db connection %v", err)</p><p class="source-code">  }</p><p class="source-code">  return conn, nil</p><p class="source-code">}</p></li>
				<li>Define a <strong class="source-inline">TestMain()</strong> function that executes the setup of the test data and then runs the test. This function will also need to call the <strong class="source-inline">tearDownDB()</strong> function to clean up the test data:<p class="source-code">func TestMain(m *testing.M) {</p><p class="source-code">  var err error</p><p class="source-code">  db, err = getConnection()</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p><p class="source-code">  err = initializeDB(db)</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p><p class="source-code">  defer tearDownDB(db)</p><p class="source-code">  if m.Run() != 0 {</p><p class="source-code">    fmt.Println("error running tests")</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Finally, define the <strong class="source-inline">TestUpdatePhoneSecure()</strong> function to help you run a test against the <strong class="source-inline">UpdatePhoneSecure()</strong> function:<p class="source-code-heading">injection_test.go</p><p class="source-code">77 func TestUpdatePhoneSecure(t *testing.T) {</p><p class="source-code">78   var tests = []struct {</p><p class="source-code">79     ID    string</p><p class="source-code">80     Phone string</p><p class="source-code">81     err   string</p><p class="source-code">82   }{</p><p class="source-code">83     {</p><p class="source-code">84       ID:    "1",</p><p class="source-code">85       Phone: "1234",</p><p class="source-code">86       err:   "",</p><p class="source-code">87     },</p><p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/34MEJze">https://packt.live/34MEJze</a></p></li>
				<li>Run the test using the following command:<p class="source-code">go test -v ./...</p><p>You should get the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer312" class="IMG---Figure">
					<img src="image/B14177_18_02.jpg" alt="Figure 19.2: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 18.2: Expected output</p>
			<p>SQL and command injection can occur when user input is not correctly sanitized. Generally, we should avoid passing user input directly into SQL or OS commands.</p>
			<p>In this exercise, we have learned how to securely code SQL code to protect an application from SQL injection.</p>
			<h1 id="_idParaDest-421">Cr<a id="_idTextAnchor482"/>oss-Site Scripting</h1>
			<p>Cross-Site Scripting, or XS<a id="_idTextAnchor483"/>S, is another major attack type that is frequently listed in the OWASP (<strong class="bold">Open Web Application Security Project</strong>) of top ten application vulnerabilities. Similar to SQL injection, this vulnerability is also caused by non-sanitized user input, but in this case, rather than modifying the behavior of a database, it injects scripts into a web page.</p>
			<p>Web pages are constructed using html tags. Every html page contains some content bracketed by the html tag, like this:</p>
			<p class="source-code">&lt;html&gt;</p>
			<p class="source-code">  Hello World!</p>
			<p class="source-code">&lt;/html&gt;</p>
			<p>One such html tag is the <strong class="source-inline">&lt;script&gt;</strong> tag, which is used to embed executable content – usually, JavaScript code. This tag is used to run client-side code execution on the browser, for example, to generate dynamic content or manipulate data and images.</p>
			<p>Th<a id="_idTextAnchor484"/>e code inside the <strong class="source-inline">&lt;script&gt;</strong> tag is not visible on the web page and, as such, it generally goes unnoticed. This feature of the <strong class="source-inline">&lt;script&gt;</strong> tag can be manipulated by attackers to run malicious scripts to steal sensitive data, monitor activity, or perform other unauthorized actions. So, how does the malicious script get injected in the first place? If user data entered through a browser is not sanitized, an attacker can input/inject a malicious script to the web server, which can then be stored on the database. </p>
			<p>When a victim visits the page, the script gets loaded onto their browser.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">OWASP is an organization that provides useful information to secure your application. They provide rankings for the common application security vulnerabilities such as the OWASP top 10:</p>
			<p class="callout"><a href="https://packt.live/36t6RbU">https://packt.live/36t6RbU</a></p>
			<p class="callout">You can find more information about OWASP here:</p>
			<p class="callout"><a href="https://packt.live/34ioCsZ">https://packt.live/34ioCsZ</a></p>
			<h2 id="_idParaDest-422">Ex<a id="_idTextAnchor485"/>ercise 18.02: Handling XSS Attacks</h2>
			<p>In this exercise, we will see how an XSS attack can be carried out on a web page, and then we will fix the issue with the code to make it safe from this type of attack:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">main.go</strong> file and import the following packages:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "net/http"</p><p class="source-code">  "text/template"</p><p class="source-code">)</p></li>
				<li>Define a sample HTML template that can be used to load a web page. For multiline text assignment to a variable, you can use the string enclosed by backticks(<strong class="source-inline">`</strong>):<p class="source-code">var content = <strong class="bold">`</strong>&lt;html&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">&lt;title&gt;My Blog&lt;/title&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;</p><p class="source-code">  &lt;h1&gt;My Blog Site&lt;/h1&gt;</p><p class="source-code">  &lt;h2&gt; Comments &lt;/h2&gt;</p><p class="source-code">  {{.Comment}}</p><p class="source-code">  &lt;formaction="/" method="post"&gt;</p><p class="source-code">    Add Comment:&lt;input type="text"name="input"&gt;</p><p class="source-code">    &lt;input type="submit" value="Submit"&gt;</p><p class="source-code">  &lt;/form&gt;</p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;<strong class="bold">`</strong></p></li>
				<li>Create a <strong class="source-inline">struct</strong> called <strong class="source-inline">input</strong>, which contains a field called <strong class="source-inline">Comment</strong> as a <strong class="source-inline">string</strong> value. This <strong class="source-inline">struct</strong> will be used to wrap a user comment:<p class="source-code">type input struct {</p><p class="source-code">  Comment string</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">handler()</strong> function to return the response of an HTTP request:<p class="source-code">func handler(w http.ResponseWriter, r *http.Request) {</p><p class="source-code">  var userInput = &amp;input{</p><p class="source-code">    Comment: r.FormValue("input"),</p><p class="source-code">  }</p><p class="source-code">  t := template.Must(template.New("test").Parse(content))</p><p class="source-code">  err := t.Execute(w, userInput)</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Define the <strong class="source-inline">main()</strong> function to run an HTTP server:<p class="source-code">funcmain() {</p><p class="source-code">  http.HandleFunc("/", handler)</p><p class="source-code">  http.ListenAndServe(":8080", nil)</p><p class="source-code">}</p></li>
				<li>Run the code:<p class="source-code">go run main.go</p></li>
				<li>Open <strong class="source-inline">http://localhost:8080</strong> on the browser. You should be able to see the following page:<div id="_idContainer313" class="IMG---Figure"><img src="image/B14177_18_03.jpg" alt="Figure 19.3: HTTP server landing page&#13;&#10;"/></div><p class="figure-caption">Figure 18.3: HTTP server landing page</p><p>In a normal scenario, users would input text comments that would get populated on the page. However, if a malicious user wanted to inject an executable script into the page, they could do so by submitting the following input:</p><p class="source-code">&lt;script&gt;alert("Hello")&lt;/script&gt;</p><p>This is what you will see:</p><div id="_idContainer314" class="IMG---Figure"><img src="image/B14177_18_04.jpg" alt="Figure 19.4: XSS execution&#13;&#10;"/></div><p class="figure-caption">Figure 18.4: XSS execution</p></li>
				<li>Let's fix our web application to make it safe from XXS attacks. In this case, the solution is as simple as updating from <strong class="source-inline">text/template</strong> to use the <strong class="source-inline">html/template</strong> package:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "net/http"</p><p class="source-code">  "html/template"</p><p class="source-code">)</p><p>If you run the server again and then submit the same input, your output will be escaped by the <strong class="source-inline">html/template</strong> library and, thus, will not be treated as a script:</p></li>
			</ol>
			<div>
				<div id="_idContainer315" class="IMG---Figure">
					<img src="image/B14177_18_05.jpg" alt="Figure 19.5: XSS escaped output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 18.5: XSS escaped output</p>
			<p>In this exercise, we learned about the proper use of templating in code to protect an application from cross-site scripting attacks.</p>
			<h1 id="_idParaDest-423">Crypt<a id="_idTextAnchor486"/>ography</h1>
			<p>Go has a very comprehensive crypt<a id="_idTextAnchor487"/>o library included as part of the standard library, which covers hashing algorithms, PKI certificates, and symmetric and asymmetric encryption algorithms.</p>
			<p>While it is convenient to have a collection of different ciphers' encry<a id="_idTextAnchor488"/>ption and hashing libraries available for us to use, it is important for us to be aware of vulnerabilities in these algorithms, so we can choose the most appropriate algorithm for our use case.</p>
			<p>For example, the MD5 and SHA-1 hashing algorithms are not considered safe to use for encrypting data, as they are easily brute-forced. However, they are commonly used by file servers to provide file checksums for error checking.</p>
			<h2 id="_idParaDest-424">Hashi<a id="_idTextAnchor489"/>ng Libraries</h2>
			<p>Hashi<a id="_idTextAnchor490"/>ng is the process of converting plaintext data into an encrypted format by implementing an algorithm to produce the encrypted text. The output of such a process is supposed to be unique and the probability of a hash collision, which is two different inputs producing the same output, is extremely unlikely. Hashing functions are routinely used in databases and in the secure transmission of messages.</p>
			<p>We can use the checksum functions to produce a one-way hash. For example, to produce an MD5 checksum, we can use the <strong class="source-inline">Sum()</strong> function, which takes in a <strong class="source-inline">byte</strong> array and returns a <strong class="source-inline">byte</strong> array:</p>
			<p class="source-code">Sum(in []byte) []byte</p>
			<p>For SHA256, the checksum function definition is very similar:</p>
			<p class="source-code">Sum256(data []byte) [Size]byte</p>
			<p>Apart<a id="_idTextAnchor491"/> from MD5, the standard library for Go contains implementations for SHA1, SHA256, and SHA512. We will see how to use them in the upcoming exercise.</p>
			<h2 id="_idParaDest-425">Exerc<a id="_idTextAnchor492"/>ise 18.03: Using Different Hashing Libraries</h2>
			<p>In this exercise, we will learn how to use different hashing libraries in Go:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">main.go</strong> file and import the following crypto hashing libraries:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "crypto/md5"</p><p class="source-code">  "crypto/sha256"</p><p class="source-code">  "crypto/sha512"</p><p class="source-code">  "fmt"</p><p class="source-code">  "golang.org/x/crypto/blake2b"</p><p class="source-code">  "golang.org/x/crypto/blake2s"</p><p class="source-code">  "golang.org/x/crypto/sha3"</p><p class="source-code">)</p></li>
				<li>Define a utility function called <strong class="source-inline">getHash()</strong> that takes in an input string to be hashed and the type of hash library to use. Define a <strong class="source-inline">switch</strong> statement that uses the <strong class="source-inline">hashType</strong> input string to decide which type of hashing library to use:<p class="source-code">func getHash(input string, hashType string) string {</p></li>
				<li>Inside the <strong class="source-inline">switch</strong> statement, add cases for using MD5, SHA256, SHA512, and SHA3_512. The <strong class="source-inline">switch</strong> cases should return the hash of the input string using the corresponding hashing libraries:<p class="source-code">  switch hashType {</p><p class="source-code">  case "MD5":</p><p class="source-code">    return fmt.Sprintf("%x", md5.Sum([]byte(input)))</p><p class="source-code">  case "SHA256":</p><p class="source-code">    return fmt.Sprintf("%x", sha256.Sum256([]byte(input)))</p><p class="source-code">  case "SHA512":</p><p class="source-code">    return fmt.Sprintf("%x", sha512.Sum512([]byte(input)))</p><p class="source-code">  case "SHA3_512":</p><p class="source-code">    return fmt.Sprintf("%x", sha3.Sum512([]byte(input)))</p><p class="source-code">  default:</p><p class="source-code">    return fmt.Sprintf("%x", sha256.Sum256([]byte(input)))</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Add some other hashing libraries that are not available in the standard library:<p class="source-code">  // from "golang.org/x/crypto/blake2s"</p><p class="source-code">  case "BLAKE2s_256":</p><p class="source-code">    return fmt.Sprintf("%x", blake2s.Sum256([]byte(input)))</p><p class="source-code">  // from "golang.org/x/crypto/blake2b"</p><p class="source-code">  case "BLAKE2b_512":</p><p class="source-code">    return fmt.Sprintf("%x", blake2b.Sum512([]byte(input)))</p><p class="source-code"> }</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">Apart from the <strong class="source-inline">blake</strong> libraries mentioned, you can also find packages for MD4 and SHA3 under <a href="https://packt.live/2PiwlmH">https://packt.live/2PiwlmH</a>.</p></li>
				<li>Define the <strong class="source-inline">main()</strong> function and call the <strong class="source-inline">getHashutility()</strong> function defined previously:<p class="source-code">func main() {</p><p class="source-code">  fmt.Println("MD5:", getHash("Hello World!", "MD5"))</p><p class="source-code">  fmt.Println("SHA256:", getHash("Hello World!", "SHA256"))</p><p class="source-code">  fmt.Println("SHA512:", getHash("Hello World!", "SHA512"))</p><p class="source-code">  fmt.Println("SHA3_512:", getHash("Hello World!", "SHA3_512"))</p><p class="source-code">  fmt.Println("BLAKE2s_256:", getHash("Hello World!", "BLAKE2s_256"))</p><p class="source-code">  fmt.Println("BLAKE2b_512:", getHash("Hello World!", "BLAKE2b_512"))</p><p class="source-code">}</p></li>
				<li>Run the program:<p class="source-code">go run main.go</p><p>You should get the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer316" class="IMG---Figure">
					<img src="image/B14177_18_06.jpg" alt="Figure 19.6: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 18.6: Expected output</p>
			<p>In this exercise, we have learned how to generate ciphertext using different hashing packages available in Go.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In the preceding example, we imported some hashing libraries, such as <a href="https://packt.live/2ryy9Ps">https://packt.live/2ryy9Ps</a>.</p>
			<p class="callout">The packages under <strong class="source-inline">golang.org/x/</strong> are still developed as part of the Go project. However, they remain outside of the main installation, so you will have to run <strong class="source-inline">go get</strong> to install them.</p>
			<p class="callout">You can find a list of these packages here: <a href="https://packt.live/2tbThv7">https://packt.live/2tbThv7</a>.</p>
			<h1 id="_idParaDest-426">Encryp<a id="_idTextAnchor493"/>tion</h1>
			<p>Encryption is the process of converting data into a format in which it cannot be read by an unintended recipient.</p>
			<p>When dealing with sensitive data, it is always best practice to encrypt it. The nature of the data will determine the sensitivity. For example, credit card information from your customers can be considered as highly sensitive data, whereas the item being bought could be considered as not very sensitive.</p>
			<p>You will probably come across the terms encryption at rest and encryption in transit, referring to how data should be encrypted before being stored (for example, in a database) or transmitted (for example, over a network). We will touch on encryption in transit in a later topic (HTTP/TLS).</p>
			<p>In this topic, we will focus on the underlying encryption mechanisms.</p>
			<p>Since (good) encryption algorithms are complicated by nature, the general advice is to always use existing encryption algorithms and not invent your own. The strength of an encryption algorithm should lie in the mathematical complexity of the problem, rather than in the secrecy of how the encryption algorithm works. As such, 'safe' encryption algorithms are all public.</p>
			<p>Go provides both symmetric and asymmetric encryption libraries. Let's look at the example implementations of both these encryption types.</p>
			<h2 id="_idParaDest-427">Symmet<a id="_idTextAnchor494"/>ric Encryption</h2>
			<p>With symmetric encryption, the same key is used for encryption and decryption. The Go standard library has implementations of common symmetric encryption algorithms such as AES and DES under <strong class="source-inline">crypto/aes</strong> and <strong class="source-inline">crypto/des</strong>.</p>
			<p>The basic steps to encrypt an input byte array using a string key (for example, a password) are as follows:</p>
			<p>To create the ciphertext in Go, we can use the <strong class="source-inline">Seal()</strong> function. We also use a <strong class="source-inline">nonce</strong>, which is a single-use random sequence. The <strong class="source-inline">dst</strong> input variable here is a byte array used to store the encrypted data:</p>
			<p class="source-code">Seal(dst, nonce, plaintext, additionalData []byte) []byte</p>
			<p>To decrypt the ciphertext, we need to again use the <strong class="source-inline">crypto/cipher</strong> library to make use of the GCM wrappers:</p>
			<p class="source-code">func (g *gcm) Open(dst, nonce, ciphertext, data []byte) ([]byte, error)</p>
			<h2 id="_idParaDest-428">Exerci<a id="_idTextAnchor495"/>se 18.04: Symmetric Encryption and Decryption</h2>
			<p>In this exercise, we are going to make use of the Go crypto libraries for symmetric encryption and learn how to encrypt and decrypt data:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">main.go</strong> file and import the following package:<p><strong class="source-inline">crypto/cipher</strong>: For block cipher implementation.</p><p><strong class="source-inline">crypto/aes</strong>: AES is an encryption specification, and <strong class="source-inline">crypto/aes</strong> is the Go implementation.</p><p><strong class="source-inline">crypto/rand</strong>: Used for random number generation.</p><p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "crypto/aes"</p><p class="source-code">  "crypto/cipher"</p><p class="source-code">  "crypto/rand"</p><p class="source-code">  "fmt"</p><p class="source-code">)</p></li>
				<li>Define a function to encrypt data using the <strong class="source-inline">crypto/aes</strong> and <strong class="source-inline">crypto/cipher</strong> libraries. The following function accepts input data in the form of a byte array and a key string, which is typically a secret passphrase. It returns the encrypted data:<p class="source-code">func encrypt(data []byte, key string) (resp []byte, err error) {</p><p class="source-code">  block, err := aes.NewCipher([]byte(key))</p><p class="source-code">  if err != nil {</p><p class="source-code">    return resp, err</p><p class="source-code">  }</p><p class="source-code">gcm, err := cipher.NewGCM(block)</p><p class="source-code">  if err != nil {</p><p class="source-code">    return resp, err</p><p class="source-code">  }</p><p class="source-code">  nonce := make([]byte, gcm.NonceSize())</p><p class="source-code">  if _, err := rand.Read(nonce); err != nil {</p><p class="source-code">    return resp, err</p><p class="source-code">  }</p><p class="source-code">  return gcm.Seal(dst, nonce, data, []byte("test")), nil</p><p class="source-code">}</p><p>The nonce needs to be stored for decryption. There are many ways of doing this. In the preceding implementation, we do this by passing in the nonce in the first input to the <strong class="source-inline">Seal()</strong> function, which is a byte array, <strong class="source-inline">dst</strong>. Since the <strong class="source-inline">Seal()</strong> function appends the encrypted data to the input byte array, the resulting ciphertext will be appended to the nonce and returned as a one-byte array. If you pass in additional data, the value must match when you decrypt the resulting ciphertext.</p></li>
				<li>Define a function to decrypt data. It should accept the encrypted data in the form of a byte array and the passphrase as a string. It should return the decrypted data:<p class="source-code">func decrypt(data []byte, key string) (resp []byte, err error) {</p><p class="source-code">  block, err := aes.NewCipher([]byte(key))</p><p class="source-code">  if err != nil {</p><p class="source-code">    return resp, err</p><p class="source-code">  }</p><p class="source-code">gcm, err := cipher.NewGCM(block)</p><p class="source-code">  if err != nil {</p><p class="source-code">    return resp, err</p><p class="source-code">  }</p><p class="source-code">  ciphertext := data[gcm.NonceSize():]</p><p class="source-code">  nonce := data[:gcm.NonceSize()]</p><p class="source-code">  resp, err = gcm.Open(nil, nonce, ciphertext, []byte("test"))</p><p class="source-code">  if err != nil {</p><p class="source-code">    return resp, fmt.Errorf("error decrypting data: %v", err)</p><p class="source-code">  }</p><p class="source-code">  return resp, nil</p><p class="source-code">}</p></li>
				<li>Define the <strong class="source-inline">main()</strong> function to test the <strong class="source-inline">encrypt</strong> and <strong class="source-inline">decrypt</strong> functions:<p class="source-code">func main() {</p><p class="source-code">  const key = "mysecurepassword"</p><p class="source-code">  encrypted, err := encrypt([]byte("Hello World!"), key)</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">  }</p><p class="source-code">fmt.Println("Encrypted Text: ", string(encrypted))</p><p class="source-code">  decrypted, err := decrypt(encrypted, key)</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">  }</p><p class="source-code">  fmt.Println("Decrypted Text: ", string(decrypted))</p><p class="source-code">}</p></li>
				<li>Run the program by using the following command:<p class="source-code">go run main.go</p><p>You should get the following output.</p></li>
			</ol>
			<div>
				<div id="_idContainer317" class="IMG---Figure">
					<img src="image/B14177_18_07.jpg" alt="Figure 19.7: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 18.7: Expected output</p>
			<p>In this<a id="_idTextAnchor496"/> exercise, we have learned how to perform symmetric encryption and decryption.</p>
			<h2 id="_idParaDest-429">Asymmet<a id="_idTextAnchor497"/>ric Encryption</h2>
			<p>Asymmetric encryption is also known as public-<a id="_idTextAnchor498"/>key cryptography. This encryption mechanism makes use of a pair of keys, a public key and a private key. The public key can be freely distributed to other partners who are willing to exchange data with you. If a partner wants to send encrypted data, they will use your public key to encrypt their data. This encrypted data can be decrypted by you using your private key.</p>
			<p>The Go standard library has support for common asymmetric encryption algorithms such as RSA and DSA. </p>
			<p>For example, the <strong class="source-inline">rsa.EncryptOAEP()</strong> function is used to encrypt data using the public key:</p>
			<p class="source-code">EncryptOAEP(hash hash.Hash,randomio.Reader,pub *PublicKey,msg []byte,label   []byte)([]byte,error)</p>
			<p>The <strong class="source-inline">rsa.DecryptOAEP()</strong> function is used to decrypt the ciphertext using the private key:</p>
			<p class="source-code">DecryptOAEP(hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext   []byte, label []byte) ([]byte, error)</p>
			<p>The enc<a id="_idTextAnchor499"/>ryption operation takes in <strong class="source-inline">rsa.PublicKey</strong>, and the decryption operation takes <strong class="source-inline">rsa.PrivateKey</strong>. The key pair can be generated using the <strong class="source-inline">rsa.GenerateKey()</strong> function:</p>
			<p class="source-code">GenerateKey(random io.Reader, bits int) (*PrivateKey, error)</p>
			<h2 id="_idParaDest-430">Exercis<a id="_idTextAnchor500"/>e 18.05: Asymmetric Encryption and Decryption</h2>
			<p>In this exercise, we will see the encrypt and decrypt operations in action:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">main.go</strong> file and import the following packages:<p><strong class="source-inline">crypto/rand</strong>: The <strong class="source-inline">rand.Reader</strong> from this package will be used to seed the generation of the <strong class="source-inline">rsa.PrivateKey</strong>.</p><p><strong class="source-inline">crypto/rsa</strong>: This package is required to generate the private key and for the <strong class="source-inline">encrypt/decrypt</strong> operation.</p><p><strong class="source-inline">crypto/sha256</strong>: The symmetric hash function will be used to seed the generation of the <strong class="source-inline">rsa.PrivateKey</strong>.</p><p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "crypto/rand"</p><p class="source-code">  "crypto/rsa"</p><p class="source-code">  "crypto/sha256"</p><p class="source-code">  "fmt"</p><p class="source-code">  "os"</p><p class="source-code">)</p></li>
				<li>Define the <strong class="source-inline">main()</strong> function and generate an <strong class="source-inline">rsa</strong> key pair:<p class="source-code">func main() {</p><p class="source-code">privateKey, err := rsa.GenerateKey(rand.Reader, 1024)</p><p class="source-code">  if err != nil {</p><p class="source-code">fmt.Printf("error generating rsa key: %v", err)</p><p class="source-code">  }</p><p class="source-code">publicKey := privateKey.PublicKey</p><p class="source-code">text := []byte("My Secret Text")</p></li>
				<li>Encrypt the data using <strong class="source-inline">publicKey</strong>:<p class="source-code">  ciphertext, err := rsa.EncryptOAEP(sha256.New(), rand.Reader, &amp;publicKey,     text, nil)</p><p class="source-code">  if err != nil {</p><p class="source-code">fmt.Printf("error encrypting data: %v", err)</p><p class="source-code">os.Exit(1)</p><p class="source-code">  }</p><p class="source-code">fmt.Println("Encrypted ciphertext: ", string(ciphertext)</p></li>
				<li>Use <strong class="source-inline">privateKey</strong> to decrypt the ciphertext from <em class="italic">step 3</em>:<p class="source-code">decrypted, err := rsa.DecryptOAEP(sha256.New(), rand.Reader, privateKey,   ciphertext, nil)</p><p class="source-code">  if err != nil {</p><p class="source-code">fmt.Printf("error decrypting data: %v", err)</p><p class="source-code">os.Exit(1)</p><p class="source-code">  }</p><p class="source-code">  fmt.Println("Decrypted text: ", string(decrypted))</p><p class="source-code">}</p></li>
				<li>Run the program using the following command:<p class="source-code">go run main.go</p><p>You should get the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer318" class="IMG---Figure">
					<img src="image/B14177_18_08.jpg" alt="Figure 19.8: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 18.8: Expected output</p>
			<p>We have now learned how to create an RSA public key and use it to encrypt and decrypt data.</p>
			<h1 id="_idParaDest-431">Random G<a id="_idTextAnchor501"/>enerators</h1>
			<p>The Go standard library provides utility libraries to create random number generators. The implementations are provided in the <strong class="source-inline">crypto/rand</strong> and <strong class="source-inline">math/rand</strong> packages. The <strong class="source-inline">math/rand</strong> library can be used to generate random integers; however, randomness cannot be guaranteed. Therefore, this library should only be used in cases where the number can be generally random and is not security-sensitive.</p>
			<p>Otherwise, you should always use <strong class="source-inline">crypto/rand</strong>. As a side note, the <strong class="source-inline">crypto/rand</strong> package relies on OS randomness – for example, on Linux it uses <strong class="source-inline">/dev/urandom</strong>. Therefore, it is generally slower than the math library implementation.</p>
			<p>To produce a random integer between 0 and a user-defined number using the <strong class="source-inline">crypto/rand</strong> library, we can use the following function:</p>
			<p class="source-code">funcInt(rand io.Reader, max *big.Int) (n *big.Int, err error)</p>
			<p>There ar<a id="_idTextAnchor502"/>e many scenarios where we might want to generate a secure random number, for example, when generating unique session IDs. It is important that random numbers used in these scenarios are genuinely random, and do not follow a pattern that can be inferred. For example, if an attacker can infer the next <strong class="source-inline">sessionID</strong> by looking at the last few session IDs, they could potentially gain unauthenticated access to that session.</p>
			<p>Let's learn how to generate random numbers using both the <strong class="source-inline">crypto/rand</strong> and <strong class="source-inline">math/rand</strong> libraries.</p>
			<h2 id="_idParaDest-432"><a id="_idTextAnchor503"/>Exercise 18.06: Random Generators</h2>
			<p>Random number generation is a common activity when trying to introduce some entropy to encrypt data. In this exercise, we will see how random numbers can be generated using the <strong class="source-inline">math/rand</strong> and <strong class="source-inline">crypto/rand</strong> packages:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">main.go</strong> file and import the following packages:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "crypto/rand"</p><p class="source-code">  "fmt"</p><p class="source-code">  "math/big"</p><p class="source-code">  math "math/rand"</p><p class="source-code">)</p><p><strong class="source-inline">math "math/rand"</strong>: We add the <strong class="source-inline">math</strong> namespace to differentiate it from the <strong class="source-inline">crypto/rand</strong> package.</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, create a <strong class="source-inline">for</strong> loop that runs 10 times and prints a random integer between 0 and 1000, generated using the <strong class="source-inline">rand.Int()</strong> function of the <strong class="source-inline">crypto/rand</strong> library:<p class="source-code">func main() {</p><p class="source-code">  fmt.Println("Crypto random")</p><p class="source-code">  for i := 1; i&lt;=10; i++ {</p><p class="source-code">    data, _:= rand.Int(rand.Reader,big.NewInt(1000))</p><p class="source-code">    fmt.Println(data)</p><p class="source-code">  }</p></li>
				<li>Create another similar <strong class="source-inline">for</strong> loop using the <strong class="source-inline">math/rand</strong> package:<p class="source-code">  fmt.Println("Math random")</p><p class="source-code">  for i := 1; i&lt;=10; i++ {</p><p class="source-code">    fmt.Println(math.Intn(1000))</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Run the program using the following command:<p class="source-code">go run main.go</p><p>You should get the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer319" class="IMG---Figure">
					<img src="image/B14177_18_09.jpg" alt="Figure 19.9: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 18.9: Expected output</p>
			<p>While the outputs for the two implementations may appear similar, the underlying mechanism of number generation is important when using random numbers for security purposes.</p>
			<p>In this exercise, we have seen how to generate random numbers using the <strong class="source-inline">math/rand</strong> and <strong class="source-inline">crypto/rand</strong> packages.</p>
			<h1 id="_idParaDest-433">HTTPS/TLS<a id="_idTextAnchor504"/></h1>
			<p>When you are developing a web application, it is important to know how to secure your information in transit. This is achieved by using a <strong class="bold">Transport Layer Security Protocol</strong>, commonly known as TLS. The standard Go library provides a TLS implementation under the <strong class="source-inline">crypto/tls</strong> package. The TLS protocol ensures:</p>
			<p><strong class="bold">Identity</strong>: Provides both client and server identification using digital certificates.</p>
			<p><strong class="bold">Integrity</strong>: Makes sure that data is not tampered with in transit by calculating a message digest.</p>
			<p><strong class="bold">Authentication</strong>: Both client and server can be required to be authenticated using Public-Key Cryptography.</p>
			<p><strong class="bold">Confidentiality</strong>: The message is encrypted during transit, thus protecting it from any unintended recipient.</p>
			<p>In the following topic, we'll see how to use certificates to encrypt traffic between a client and a server.</p>
			<p>The first step to encrypting traffic between a client and a server is to generate a digital certificate.</p>
			<p>In the next exercise, we will generate a self-signed x509 certificate and a matching RSA private key. This certificate can be used as either a client or server certificate.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You might come across the term CA, which stands for Certificate Authority. The CA is the one who signs certificates and distributes them to users who require a signed certificate.</p>
			<h2 id="_idParaDest-434"><a id="_idTextAnchor505"/>Exercise 18.07: Generating a Certificate and Private Key</h2>
			<p>In this exercise, we will learn how to generate a self-signed certificate and a matching private key for the certificate, which can be used in client-server communication:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">main.go</strong> file and import the following packages:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "crypto/rand"</p><p class="source-code">  "crypto/rsa"</p><p class="source-code">  "crypto/tls"</p><p class="source-code">  "crypto/x509"</p><p class="source-code">  "crypto/x509/pkix"</p><p class="source-code">  "encoding/pem"</p><p class="source-code">  "fmt"</p><p class="source-code">  "io/ioutil"</p><p class="source-code">  "math/big"</p><p class="source-code">  "net"</p><p class="source-code">  "net/http"</p><p class="source-code">  "os"</p><p class="source-code">  "time"</p><p class="source-code">)</p><p>The crypto packages will be used to generate x509 certificates.</p></li>
				<li>To generate the certificate, we first create a template. In the template, we can define criteria for the certificate; for example, the expiry of the certificate is set to a year. The template needs a random seed, which can be generated using the <strong class="source-inline">rand.Int()</strong> function:<p class="source-code-heading">main.go</p><p class="source-code">28 func generate() (cert []byte, privateKey []byte, err error) {</p><p class="source-code">29   serialNumber, err := rand.Int(rand.Reader, big.NewInt(27))</p><p class="source-code">30   if err != nil {</p><p class="source-code">31     return cert, privateKey, err</p><p class="source-code">32   }</p><p class="source-code">33   notBefore := time.Now()</p><p class="source-code">// Create Certificate template</p><p class="source-code">34   ca := &amp;x509.Certificate{</p><p class="source-code">35     SerialNumber: serialNumber,</p><p class="source-code">36     Subject: pkix.Name{</p><p class="source-code">37       Organization: []string{"example.com"},</p><p class="source-code">38     },</p><p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/34N7jjT">https://packt.live/34N7jjT</a></p></li>
				<li>Create <strong class="source-inline">privateKey</strong>, which will be used to sign the certificate:<p class="source-code">  rsaKey, err := rsa.GenerateKey(rand.Reader, 2048)</p><p class="source-code">  if err != nil {</p><p class="source-code">    return cert, privateKey, err</p><p class="source-code">  }</p></li>
				<li>Create a self-signed <strong class="source-inline">DER</strong> (binary encrypted) certificate:<p class="source-code">  DER, err := x509.CreateCertificate(rand.Reader, ca, ca, &amp;rsaKey.PublicKey,     rsaKey)</p><p class="source-code">  if err != nil {</p><p class="source-code">    return cert, privateKey, err</p><p class="source-code">  }</p></li>
				<li>Convert the binary encoded <strong class="source-inline">DER</strong> cert to an ASCII encoded PEM cert. PEM (<strong class="bold">Privacy Enhanced Mail</strong>) is a digital certificate format:<p class="source-code">  b := pem.Block{</p><p class="source-code">    Type:  "CERTIFICATE",</p><p class="source-code">    Bytes: DER,</p><p class="source-code">  }</p><p class="source-code">  cert = pem.EncodeToMemory(&amp;b)</p><p class="source-code">  privateKey = pem.EncodeToMemory(</p><p class="source-code">    &amp;pem.Block{</p><p class="source-code">      Type:  "RSA PRIVATE KEY",</p><p class="source-code">      Bytes: x509.MarshalPKCS1PrivateKey(rsaKey),</p><p class="source-code">    })</p><p class="source-code">  return cert, privateKey, nil</p><p class="source-code">}</p></li>
				<li>Define the <strong class="source-inline">main()</strong> function to call the <strong class="source-inline">generate</strong> function and print the output:<p class="source-code">func main() {</p><p class="source-code">  serverCert, serverKey, err := generate()</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Printf("error generating server certificate: %v", err)</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p><p class="source-code">  fmt.Println("Server Certificate:")</p><p class="source-code">  fmt.Printf("%s\n", serverCert)</p><p class="source-code">  fmt.Println("Server Key:")</p><p class="source-code">  fmt.Printf("%s\n", serverKey)</p><p class="source-code">}</p><p>You should get an output similar to the following:</p></li>
			</ol>
			<div>
				<div id="_idContainer320" class="IMG---Figure">
					<img src="image/B14177_18_10.jpg" alt="Figure 19.10: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 18.10: Expected output</p>
			<p>Thus, we have successfully generated a self-signed certificate and a private key for the application. In the output above, the "Server Certificate" is the public certificate, and the "Server Key" is the private key. This can be used to encrypt data between the client and the server. They are particularly useful when there is sensitive data in transit, such as on a banking website.</p>
			<h2 id="_idParaDest-435"><a id="_idTextAnchor506"/>Exercise 18.08: Running an HTTPS Server</h2>
			<p>In the fol<a id="_idTextAnchor507"/>lowing exercise, we'll learn how to use certificates to encrypt traffic between a client and server.</p>
			<p>We will learn how to create a public-key certificate. The certificate will be used to encode data between a client and a server:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">main.go</strong> file and import the following packages:<p><strong class="source-inline">crypto/rand</strong>: For random number generation.</p><p><strong class="source-inline">crypto/rsa</strong>: Provides a wrapper for RSA certificates.</p><p><strong class="source-inline">crypto/tls</strong>: Provides a wrapper for Transport Layer Security (TLS) protocol.</p><p><strong class="source-inline">crypto.x509</strong>: Provides a wrapper for X509 digital certificates.</p><p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">    "crypto/rand"</p><p class="source-code">    "crypto/rsa"</p><p class="source-code">    "crypto/tls"</p><p class="source-code">    "crypto/x509"</p><p class="source-code">    "crypto/x509/pkix"</p><p class="source-code">    "encoding/pem"</p><p class="source-code">    "fmt"</p><p class="source-code">    "io/ioutil"</p><p class="source-code">    "log"</p><p class="source-code">    "math/big"</p><p class="source-code">    "net"</p><p class="source-code">    "net/http"</p><p class="source-code">    "os"</p><p class="source-code">    "time"</p><p class="source-code">)</p></li>
				<li>Define a function called <strong class="source-inline">runServer()</strong> to run an HTTP server with a TLS configuration. The function should take in the paths of the certificate file, a private key file, and a PEM encoded client certificate. In our TLS configuration, we require both server and client certificates. The server certificate is used by the client to validate the authenticity of the server. The client certificate is verified by the server to validate the client:<p class="source-code-heading">main.go</p><p class="source-code">117 func runServer(certFile string, key string, clientCert []byte) (err error) {</p><p class="source-code">118   fmt.Println("starting HTTP server")</p><p class="source-code">119   http.HandleFunc("/", hello)</p><p class="source-code">120   server := &amp;http.Server{</p><p class="source-code">121     Addr:    ":443",</p><p class="source-code">122     Handler: nil,</p><p class="source-code">123   }</p><p class="source-code">124   cert, err := tls.LoadX509KeyPair(certFile, key)</p><p class="source-code">125   if err != nil {</p><p class="source-code">126     return err</p><p class="source-code">127   }</p><p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/39hG58K">https://packt.live/39hG58K</a></p></li>
				<li>Define the <strong class="source-inline">hello()</strong> function, which is passed as a handler function when we start the HTTP server. This function will respond with some text whenever the server receives a request:<p class="source-code">func hello(w http.ResponseWriter, r *http.Request) {</p><p class="source-code">  fmt.Printf("%s: Ping\n", time.Now().Format(time.Stamp))</p><p class="source-code">  fmt.Fprintf(w, "Pong\n")</p><p class="source-code">}</p></li>
				<li>Now that the server side is done, let's implement the client side:<p class="source-code-heading">main.go</p><p class="source-code">95  func client(caCert []byte, ClientCerttls.Certificate) (err error) {</p><p class="source-code">96    certPool := x509.NewCertPool()</p><p class="source-code">97    certPool.AppendCertsFromPEM(caCert)</p><p class="source-code">98    client := &amp;http.Client{</p><p class="source-code">99      Transport: &amp;http.Transport{</p><p class="source-code">100       TLSClientConfig: &amp;tls.Config{</p><p class="source-code">101         RootCAs:      certPool,</p><p class="source-code">102         Certificates: []tls.Certificate{ClientCert},</p><p class="source-code">103       },</p><p class="source-code">104     },</p><p class="source-code">105   }</p><p class="source-code">106   resp, err := client.Get("https://127.0.0.1:443")</p><p class="source-code">107   if err != nil {</p><p class="source-code">108     return err</p><p class="source-code">109   }</p><p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/2PS72Z2">https://packt.live/2PS72Z2</a></p><p>This defines an HTTP client using the TLS implementation. It takes in the certificate of the CA as a parameter to verify the authenticity of the server. In our case, we used a self-signed certificate, so the server certificate will serve the purpose of a CA certificate. The function would also take the client's certificate so that the client can authenticate with the server.</p></li>
				<li>Let's now tie these functions and run a client and server handshake.<p>First, we generate certificates and keys for both the client and the server. The server is started using a <strong class="source-inline">goroutine</strong> and waits for a request from the client. The client is also started in a <strong class="source-inline">goroutine</strong> and calls the server every 3 seconds:</p></li>
			</ol>
			<p class="source-code-heading">main.go</p>
			<p class="source-code">18 func main() {</p>
			<p class="source-code">19   serverCert, serverKey, err := generate()</p>
			<p class="source-code">20   if err != nil {</p>
			<p class="source-code">21     fmt.Printf("error generating server certificate: %v", err)</p>
			<p class="source-code">22     os.Exit(1)</p>
			<p class="source-code">23   }</p>
			<p class="source-code">24   ioutil.WriteFile("private.key", serverKey, 0600)</p>
			<p class="source-code">25   ioutil.WriteFile("cert.pem", serverCert, 0777)</p>
			<p class="source-code">26   clientCert, clientKey, err := generate()</p>
			<p class="source-code">27   if err != nil {</p>
			<p class="source-code">28     fmt.Printf("error generating client certificate: %v", err)</p>
			<p class="source-code">29     os.Exit(1)</p>
			<p class="source-code">30   }</p>
			<p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/2t0IXpW">https://packt.live/2t0IXpW</a></p>
			<p>We can now run the <strong class="source-inline">main()</strong> function. You should see the following output in your console:</p>
			<p class="source-code">$ cd../exercise8/</p>
			<p class="source-code">$ go run main.go</p>
			<p class="source-code">starting HTTP server</p>
			<p class="source-code">Oct 17 22:22:28: Ping</p>
			<p class="source-code">Oct 17 22:22:28: Pong</p>
			<p class="source-code">Oct 17 22:22:31: Ping</p>
			<p class="source-code">Oct 17 22:22:31: Pong</p>
			<p>In this exercise, we demonstrated how a client and server communication could be secured using the TLS protocol. We have learned how to generate digital certificates and used them in the TLS configuration for the client and server.</p>
			<h1 id="_idParaDest-436">Password M<a id="_idTextAnchor508"/>anagement</h1>
			<p>If you are managing user accounts on your website, one common way of verifying user identity is through a combination of usernames and passwords. This authentication mechanism has the risk that, if not properly managed, user credentials can be leaked. This has happened to many of the major websites around the world and remains a surprisingly common security incident.</p>
			<p>The main rule of thumb regarding password management is to never store passwords in plaintext (either in memory or in a database). Instead, implement an approved hash algorithm to create a one-way hash of the password so that you can confirm the identity through the hash. However, it is not possible to retrieve the password from the hash. We can see this in action with an example.</p>
			<p>The following code shows how to create a one-way hash from a plaintext string. We are using the <strong class="source-inline">bcrypt</strong> package to generate the hash. We then perform a comparison of the password with the hash to verify the match:</p>
			<p class="source-code">package ma<a id="_idTextAnchor509"/>in</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "golang.org/x/crypto/bcrypt"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  password := "mysecretpassword"</p>
			<p class="source-code">  encrypted, _ := bcrypt.GenerateFromPassword([]byte(password), 10)</p>
			<p class="source-code">  fmt.Println("Plain Text Password:", password)</p>
			<p class="source-code">  fmt.Println("Hashed Password:    ", string(encrypted))</p>
			<p class="source-code">  err := bcrypt.CompareHashAndPassword([]byte(encrypted), []byte(password))</p>
			<p class="source-code">  if err == nil {</p>
			<p class="source-code">    fmt.Println("Password matched")</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The following is the expected output:</p>
			<div>
				<div id="_idContainer321" class="IMG---Figure">
					<img src="image/B14177_18_11.jpg" alt="Figure 19.11: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 18.11: Expected output</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="bold">Elliptic Curve Digital Signature Algorithm</strong> (ECDSA) is a cryptographic algorithm that is used to verify the authenticity of data by providing a mechanism to sign and verify data using a public and private key pair.</p>
			<h2 id="_idParaDest-437"><a id="_idTextAnchor510"/>Activity 18.01: Authenticating Users on the Application Using Hashed Passwords</h2>
			<p>You are working on a web application and you need to authenticate users by using hashed passwords.</p>
			<p>Create a database with user passwords that are stored as a hash. Define a function to take in a user password as an input and authenticate the user using the stored password in the database. Make sure the SQL query defined to query the database is safe from SQL injection. You can follow these steps to get the desired output.</p>
			<ol>
				<li value="1">Create a function to load data into the database.</li>
				<li>Create a function to update a password in the database. Use the <strong class="source-inline">crypto/sha512</strong> library to encrypt the input password before updating the database.</li>
				<li>Create a function to retrieve the password from the database and confirm whether it matches the hash.</li>
				<li>In the main function of the program, initialize the database with some test data.</li>
				<li>Perform the update of the user password using the function defined in <em class="italic">step 2</em>.<p>You should get the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer322" class="IMG---Figure">
					<img src="image/B14177_18_12.jpg" alt="Figure 19.12: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 18.12: Expected output</p>
			<p>Here, we securely store user passwords in a database using a hashing library and then verify a user's id<a id="_idTextAnchor511"/>entity using a hashed password. You can use this in scenarios where there is sensitive data that needs to be stored.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 777.</p>
			<h2 id="_idParaDest-438">Activity 18.<a id="_idTextAnchor512"/>02: Creating CA Signed Certificates Using Crypto Libraries</h2>
			<p>A Certificate Authority(CA) needs to be created to sign certificates. When a new leaf certificate is created, it should be signed using the CA certificate and private key. You will need to define a function to generate ECDSA-encrypted keys using the <strong class="source-inline">crypto/ecdsa</strong> library. The function needs to support the creation of CA certificates as well as leaf certificates. Finally, you will need to verify the newly created leaf certificate.</p>
			<p>The aim here is to generate x509 certificates. You can follow these steps to get the desired output:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">generateCert()</strong> function to generate an ECDSA certificate and private key using the <strong class="source-inline">crypto/ecdsa</strong> library. It should take in a common name string, a CA certificate, and a CA private key.<p>The function should have the following definition:</p><p class="source-code">generateCert(cn string, caCert *x509.Certificate, caPrivcrypto.PrivateKey)   (cert *x509.Certificate, privateKeycrypto.PrivateKey, err error)</p></li>
				<li>Create an ECDSA key using the <strong class="source-inline">ecdsa.GenerateKey()</strong> function.</li>
				<li>Use the key to generate an x509 certificate.</li>
				<li>Return the generated certificate and private key.</li>
				<li>In the <strong class="source-inline">main()</strong> function, generate a CA certificate and private key, as well as a leaf certificate and private key.</li>
				<li>Verify the leaf certificate generated.<p>The output should appear as follows:</p><p class="source-code">$ go run main.go</p><p class="source-code">ca certificate generated successfully</p><p class="source-code">leaf certificate generated successfully</p><p class="source-code">leaf certificate successfully verified</p></li>
			</ol>
			<p>Here, we generate x509 public key certificates. We also saw how using a root certificate to generate a leaf certificate can be handy when you are trying to implement your own PKI server.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 780.</p>
			<h1 id="_idParaDest-439"><a id="_idTextAnchor513"/>Summary</h1>
			<p>In t<a id="_idTextAnchor514"/>his chap<a id="_idTextAnchor515"/>ter, we have looked at several types of attacks that could be used to compromise an application. We have also covered strategies to mitigate those issues, along with worked examples.</p>
			<p>We have presented the use of crypto libraries for the encryption and decryption of data, both at rest and in transit. We have covered hashing libraries, and how they can be used to securely store user credentials. We have also shown how TLS configuration can be used to secure communication between clients and servers. With these tools in mind, you can now start writing secure applications.</p>
			<p>In the next chapter, we will be learning about some lesser-known packages in Go, such as reflection and unsafe.</p>
		</div>
		<div>
			<div id="_idContainer324" class="Content">
			</div>
		</div>
	</body></html>