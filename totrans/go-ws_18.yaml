- en: 18\. Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter aims to equip you with the basic skills to protect your code from
    attacks and vulnerabilities. You will be able to evaluate the workings of major
    attack vectors, implement crypto libraries for the encryption and decryption of
    data and implement communication security by using TLS certificates.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be equipped to identify common issues with
    code that could lead to security loopholes, and refactor code to make it more
    secure.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about Go tools such as `fmt`, `vet`, and
    `race`, which are designed to help you with your code development. Let's now look
    at how to secure your code by looking at examples of common vulnerabilities. We'll
    also look at the packages in the standard library that can help you to store your
    data securely.
  prefs: []
  type: TYPE_NORMAL
- en: Security cannot be an afterthought. It should be part of your code kata, something
    that you practice every day. Most vulnerabilities in applications stem from the
    developer not knowing about potential security attacks and from not having a security
    review of the application before it gets deployed.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at any websites dealing with sensitive data, for example, banking
    websites, they will have basic security in place, such as the use of a signed
    SSL certificate. It is always better to design your application with security
    in mind than to add security layers later, so as to avoid refactoring or redesigning
    your application. In this chapter, we will cover some major attack vectors and
    best practices that will guide you in securing your application. The following
    basic sanity checks in your code will guarantee that you are protected by default
    from most vulnerabilities and attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Application Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the development of your application, you will not be able to anticipate
    all the possible ways in which it could be compromised. However, you can always
    try to safeguard the application by following safe coding practices, such as the
    encryption of data in transit and at rest. It is a well-known fact that if we
    protect an application from well-known attack vectors such as SQL injection, we
    will be able to ward off most attacks. We will cover topics such as the use of
    digital certificates and hashing sensitive data to protect it from attackers.
  prefs: []
  type: TYPE_NORMAL
- en: One of the major attack vectors of a software application is the command or
    SQL injection, in which malicious user input can change the behavior of a command
    or query. This can happen with poorly constructed queries in SQL, HTTP URLs, or
    in OS commands.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at SQL injection and command injection in detail.
  prefs: []
  type: TYPE_NORMAL
- en: SQL Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are working on an application that needs to store data, you will most
    likely be using a database.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection is a way of injecting malicious code into your database query.
    Although unintentional, this could have a drastic impact on your application,
    such as the loss of data or the leaking of sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some examples to understand what exactly the SQL injection is
    and how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function takes a `userID` parameter and uses it to query the
    database to return the card number that belongs to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user input is `795001`, the query string will resolve to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it is possible for a malicious user to construct an input string that
    will cause the function to retrieve information that does not belong to the user.
    For example, they could pass in the following input to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This user input would generate a query that would return the `CARD_NUMBER`
    of all users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is very easy to make a mistake when defining a database query.
  prefs: []
  type: TYPE_NORMAL
- en: Along with getting unauthorized access to data, SQL injection can also be used
    to corrupt or even delete data.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what is the idiomatic way of defining a query? We should never construct
    a query by concatenating user input to form a query string. Instead, use a prepared
    statement to define a query, in which a placeholder is used to pass the user parameter,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By using placeholders for the user input, we have mitigated potential SQL injection
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Command Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Command injection is another possible injection attack vector that you should
    be aware of. The injection aims to execute OS commands on the application server,
    which could allow the attacker to get sensitive data, delete files, or even execute
    malicious scripts on the server. This type of attack can happen when the user
    input is not sanitized.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see how this works by looking at the following example. Consider this
    function, which takes a string as input and uses it to list files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things wrong here:'
  prefs: []
  type: TYPE_NORMAL
- en: The user input is not sanitized.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user could pass in any string as a path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along with `path string`, the user could add other commands that could run on
    the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s test this by running a unit test on the function. The following test
    run should prove all the issues previously listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output when you run the test using the preceding
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 19.1: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_18_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.1: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, instead of passing a valid filename, the user passed a string
    that made the function return the files in the directory as well as reading the
    `/etc/hosts` file on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 18.01: Handling SQL Injection'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be enabling a function to prevent an SQL injection
    attack.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we will be using a lightweight database called `Sqlite`, which
    can run in-memory on your local machine. To use the database, we will need to
    import a third-party Go library that uses `cgo` under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.live/38Bjl3a](https://packt.live/38Bjl3a)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are on a Windows machine, you will need to have GCC installed and included
    in your path. You can use the instructions on this website to install GCC for
    windows: https://packt.live/38Bjl3a.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you with the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `injection.go` and import the following packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function, `UpdatePhone()`, that takes a `sql.DB` object and some user
    information such as an ID and a phone number as a `string`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `UpdatePhone()` function inserts a user ID and a phone number into the table
    by concatenating the data from the input parameters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The query string in the `UpdatePhone()` function is vulnerable to SQL injection.
    For example, if an input is passed with the following values:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will update the record not only for user ID `"19853011"`, but also for
    `"1007007"`. This is a simple example. However, there could be worse things that
    could happen, such as dropping tables in the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create another function called `UpdatePhoneSecure()`, which will update the
    user details securely. Instead of concatenating inputs to form the query, use
    placeholders for the parameters to pass into the query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a helper function called `initializeDB()` to set up the database and
    load some test data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is good practice to clean up after every test.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a function called `tearDownDB()` to help you clear the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also need a function to help with the setting up of the database connection.
    Define a function called `getConnection()`, which returns a `*sql.DB` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `TestMain()` function that executes the setup of the test data and
    then runs the test. This function will also need to call the `tearDownDB()` function
    to clean up the test data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, define the `TestUpdatePhoneSecure()` function to help you run a test
    against the `UpdatePhoneSecure()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the test using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 19.2: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_18_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.2: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: SQL and command injection can occur when user input is not correctly sanitized.
    Generally, we should avoid passing user input directly into SQL or OS commands.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have learned how to securely code SQL code to protect an
    application from SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Scripting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cross-Site Scripting, or XSS, is another major attack type that is frequently
    listed in the OWASP (**Open Web Application Security Project**) of top ten application
    vulnerabilities. Similar to SQL injection, this vulnerability is also caused by
    non-sanitized user input, but in this case, rather than modifying the behavior
    of a database, it injects scripts into a web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web pages are constructed using html tags. Every html page contains some content
    bracketed by the html tag, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: One such html tag is the `<script>` tag, which is used to embed executable content
    – usually, JavaScript code. This tag is used to run client-side code execution
    on the browser, for example, to generate dynamic content or manipulate data and
    images.
  prefs: []
  type: TYPE_NORMAL
- en: The code inside the `<script>` tag is not visible on the web page and, as such,
    it generally goes unnoticed. This feature of the `<script>` tag can be manipulated
    by attackers to run malicious scripts to steal sensitive data, monitor activity,
    or perform other unauthorized actions. So, how does the malicious script get injected
    in the first place? If user data entered through a browser is not sanitized, an
    attacker can input/inject a malicious script to the web server, which can then
    be stored on the database.
  prefs: []
  type: TYPE_NORMAL
- en: When a victim visits the page, the script gets loaded onto their browser.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'OWASP is an organization that provides useful information to secure your application.
    They provide rankings for the common application security vulnerabilities such
    as the OWASP top 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.live/36t6RbU](https://packt.live/36t6RbU)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information about OWASP here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.live/34ioCsZ](https://packt.live/34ioCsZ)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 18.02: Handling XSS Attacks'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will see how an XSS attack can be carried out on a web
    page, and then we will fix the issue with the code to make it safe from this type
    of attack:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `main.go` file and import the following packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a sample HTML template that can be used to load a web page. For multiline
    text assignment to a variable, you can use the string enclosed by backticks(``
    ` ``):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `struct` called `input`, which contains a field called `Comment` as
    a `string` value. This `struct` will be used to wrap a user comment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `handler()` function to return the response of an HTTP request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `main()` function to run an HTTP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open `http://localhost:8080` on the browser. You should be able to see the
    following page:![Figure 19.3: HTTP server landing page'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14177_18_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is what you will see:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 19.4: XSS execution'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14177_18_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 18.4: XSS execution'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s fix our web application to make it safe from XXS attacks. In this case,
    the solution is as simple as updating from `text/template` to use the `html/template`
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you run the server again and then submit the same input, your output will
    be escaped by the `html/template` library and, thus, will not be treated as a
    script:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 19.5: XSS escaped output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_18_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.5: XSS escaped output'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned about the proper use of templating in code to protect
    an application from cross-site scripting attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Cryptography
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go has a very comprehensive crypto library included as part of the standard
    library, which covers hashing algorithms, PKI certificates, and symmetric and
    asymmetric encryption algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: While it is convenient to have a collection of different ciphers' encryption
    and hashing libraries available for us to use, it is important for us to be aware
    of vulnerabilities in these algorithms, so we can choose the most appropriate
    algorithm for our use case.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the MD5 and SHA-1 hashing algorithms are not considered safe to
    use for encrypting data, as they are easily brute-forced. However, they are commonly
    used by file servers to provide file checksums for error checking.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hashing is the process of converting plaintext data into an encrypted format
    by implementing an algorithm to produce the encrypted text. The output of such
    a process is supposed to be unique and the probability of a hash collision, which
    is two different inputs producing the same output, is extremely unlikely. Hashing
    functions are routinely used in databases and in the secure transmission of messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the checksum functions to produce a one-way hash. For example, to
    produce an MD5 checksum, we can use the `Sum()` function, which takes in a `byte`
    array and returns a `byte` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For SHA256, the checksum function definition is very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Apart from MD5, the standard library for Go contains implementations for SHA1,
    SHA256, and SHA512\. We will see how to use them in the upcoming exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 18.03: Using Different Hashing Libraries'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will learn how to use different hashing libraries in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `main.go` file and import the following crypto hashing libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a utility function called `getHash()` that takes in an input string
    to be hashed and the type of hash library to use. Define a `switch` statement
    that uses the `hashType` input string to decide which type of hashing library
    to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `switch` statement, add cases for using MD5, SHA256, SHA512, and
    SHA3_512\. The `switch` cases should return the hash of the input string using
    the corresponding hashing libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add some other hashing libraries that are not available in the standard library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Apart from the `blake` libraries mentioned, you can also find packages for MD4
    and SHA3 under [https://packt.live/2PiwlmH](https://packt.live/2PiwlmH).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the `main()` function and call the `getHashutility()` function defined
    previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 19.6: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_18_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.6: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have learned how to generate ciphertext using different
    hashing packages available in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we imported some hashing libraries, such as [https://packt.live/2ryy9Ps](https://packt.live/2ryy9Ps).
  prefs: []
  type: TYPE_NORMAL
- en: The packages under `golang.org/x/` are still developed as part of the Go project.
    However, they remain outside of the main installation, so you will have to run
    `go get` to install them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find a list of these packages here: [https://packt.live/2tbThv7](https://packt.live/2tbThv7).'
  prefs: []
  type: TYPE_NORMAL
- en: Encryption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encryption is the process of converting data into a format in which it cannot
    be read by an unintended recipient.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with sensitive data, it is always best practice to encrypt it.
    The nature of the data will determine the sensitivity. For example, credit card
    information from your customers can be considered as highly sensitive data, whereas
    the item being bought could be considered as not very sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: You will probably come across the terms encryption at rest and encryption in
    transit, referring to how data should be encrypted before being stored (for example,
    in a database) or transmitted (for example, over a network). We will touch on
    encryption in transit in a later topic (HTTP/TLS).
  prefs: []
  type: TYPE_NORMAL
- en: In this topic, we will focus on the underlying encryption mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Since (good) encryption algorithms are complicated by nature, the general advice
    is to always use existing encryption algorithms and not invent your own. The strength
    of an encryption algorithm should lie in the mathematical complexity of the problem,
    rather than in the secrecy of how the encryption algorithm works. As such, 'safe'
    encryption algorithms are all public.
  prefs: []
  type: TYPE_NORMAL
- en: Go provides both symmetric and asymmetric encryption libraries. Let's look at
    the example implementations of both these encryption types.
  prefs: []
  type: TYPE_NORMAL
- en: Symmetric Encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With symmetric encryption, the same key is used for encryption and decryption.
    The Go standard library has implementations of common symmetric encryption algorithms
    such as AES and DES under `crypto/aes` and `crypto/des`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic steps to encrypt an input byte array using a string key (for example,
    a password) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the ciphertext in Go, we can use the `Seal()` function. We also use
    a `nonce`, which is a single-use random sequence. The `dst` input variable here
    is a byte array used to store the encrypted data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To decrypt the ciphertext, we need to again use the `crypto/cipher` library
    to make use of the GCM wrappers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 18.04: Symmetric Encryption and Decryption'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to make use of the Go crypto libraries for symmetric
    encryption and learn how to encrypt and decrypt data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `main.go` file and import the following package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`crypto/cipher`: For block cipher implementation.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`crypto/aes`: AES is an encryption specification, and `crypto/aes` is the Go
    implementation.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`crypto/rand`: Used for random number generation.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function to encrypt data using the `crypto/aes` and `crypto/cipher`
    libraries. The following function accepts input data in the form of a byte array
    and a key string, which is typically a secret passphrase. It returns the encrypted
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The nonce needs to be stored for decryption. There are many ways of doing this.
    In the preceding implementation, we do this by passing in the nonce in the first
    input to the `Seal()` function, which is a byte array, `dst`. Since the `Seal()`
    function appends the encrypted data to the input byte array, the resulting ciphertext
    will be appended to the nonce and returned as a one-byte array. If you pass in
    additional data, the value must match when you decrypt the resulting ciphertext.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a function to decrypt data. It should accept the encrypted data in the
    form of a byte array and the passphrase as a string. It should return the decrypted
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `main()` function to test the `encrypt` and `decrypt` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should get the following output.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 19.7: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_18_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.7: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have learned how to perform symmetric encryption and decryption.
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric Encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asymmetric encryption is also known as public-key cryptography. This encryption
    mechanism makes use of a pair of keys, a public key and a private key. The public
    key can be freely distributed to other partners who are willing to exchange data
    with you. If a partner wants to send encrypted data, they will use your public
    key to encrypt their data. This encrypted data can be decrypted by you using your
    private key.
  prefs: []
  type: TYPE_NORMAL
- en: The Go standard library has support for common asymmetric encryption algorithms
    such as RSA and DSA.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `rsa.EncryptOAEP()` function is used to encrypt data using
    the public key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rsa.DecryptOAEP()` function is used to decrypt the ciphertext using the
    private key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The encryption operation takes in `rsa.PublicKey`, and the decryption operation
    takes `rsa.PrivateKey`. The key pair can be generated using the `rsa.GenerateKey()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 18.05: Asymmetric Encryption and Decryption'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will see the encrypt and decrypt operations in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `main.go` file and import the following packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`crypto/rand`: The `rand.Reader` from this package will be used to seed the
    generation of the `rsa.PrivateKey`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`crypto/rsa`: This package is required to generate the private key and for
    the `encrypt/decrypt` operation.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`crypto/sha256`: The symmetric hash function will be used to seed the generation
    of the `rsa.PrivateKey`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `main()` function and generate an `rsa` key pair:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Encrypt the data using `publicKey`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `privateKey` to decrypt the ciphertext from *step 3*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 19.8: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_18_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.8: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned how to create an RSA public key and use it to encrypt and
    decrypt data.
  prefs: []
  type: TYPE_NORMAL
- en: Random Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go standard library provides utility libraries to create random number generators.
    The implementations are provided in the `crypto/rand` and `math/rand` packages.
    The `math/rand` library can be used to generate random integers; however, randomness
    cannot be guaranteed. Therefore, this library should only be used in cases where
    the number can be generally random and is not security-sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, you should always use `crypto/rand`. As a side note, the `crypto/rand`
    package relies on OS randomness – for example, on Linux it uses `/dev/urandom`.
    Therefore, it is generally slower than the math library implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To produce a random integer between 0 and a user-defined number using the `crypto/rand`
    library, we can use the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There are many scenarios where we might want to generate a secure random number,
    for example, when generating unique session IDs. It is important that random numbers
    used in these scenarios are genuinely random, and do not follow a pattern that
    can be inferred. For example, if an attacker can infer the next `sessionID` by
    looking at the last few session IDs, they could potentially gain unauthenticated
    access to that session.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn how to generate random numbers using both the `crypto/rand` and
    `math/rand` libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 18.06: Random Generators'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Random number generation is a common activity when trying to introduce some
    entropy to encrypt data. In this exercise, we will see how random numbers can
    be generated using the `math/rand` and `crypto/rand` packages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `main.go` file and import the following packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`math "math/rand"`: We add the `math` namespace to differentiate it from the
    `crypto/rand` package.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `main()` function, create a `for` loop that runs 10 times and prints
    a random integer between 0 and 1000, generated using the `rand.Int()` function
    of the `crypto/rand` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create another similar `for` loop using the `math/rand` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 19.9: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_18_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.9: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: While the outputs for the two implementations may appear similar, the underlying
    mechanism of number generation is important when using random numbers for security
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we have seen how to generate random numbers using the `math/rand`
    and `crypto/rand` packages.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS/TLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are developing a web application, it is important to know how to secure
    your information in transit. This is achieved by using a `crypto/tls` package.
    The TLS protocol ensures:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identity**: Provides both client and server identification using digital
    certificates.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integrity**: Makes sure that data is not tampered with in transit by calculating
    a message digest.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: Both client and server can be required to be authenticated
    using Public-Key Cryptography.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Confidentiality**: The message is encrypted during transit, thus protecting
    it from any unintended recipient.'
  prefs: []
  type: TYPE_NORMAL
- en: In the following topic, we'll see how to use certificates to encrypt traffic
    between a client and a server.
  prefs: []
  type: TYPE_NORMAL
- en: The first step to encrypting traffic between a client and a server is to generate
    a digital certificate.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will generate a self-signed x509 certificate and a
    matching RSA private key. This certificate can be used as either a client or server
    certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You might come across the term CA, which stands for Certificate Authority. The
    CA is the one who signs certificates and distributes them to users who require
    a signed certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 18.07: Generating a Certificate and Private Key'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will learn how to generate a self-signed certificate and
    a matching private key for the certificate, which can be used in client-server
    communication:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `main.go` file and import the following packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The crypto packages will be used to generate x509 certificates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To generate the certificate, we first create a template. In the template, we
    can define criteria for the certificate; for example, the expiry of the certificate
    is set to a year. The template needs a random seed, which can be generated using
    the `rand.Int()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `privateKey`, which will be used to sign the certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a self-signed `DER` (binary encrypted) certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Convert the binary encoded `DER` cert to an ASCII encoded PEM cert. PEM (**Privacy
    Enhanced Mail**) is a digital certificate format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `main()` function to call the `generate` function and print the
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get an output similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 19.10: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_18_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.10: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we have successfully generated a self-signed certificate and a private
    key for the application. In the output above, the "Server Certificate" is the
    public certificate, and the "Server Key" is the private key. This can be used
    to encrypt data between the client and the server. They are particularly useful
    when there is sensitive data in transit, such as on a banking website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 18.08: Running an HTTPS Server'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following exercise, we'll learn how to use certificates to encrypt traffic
    between a client and server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn how to create a public-key certificate. The certificate will
    be used to encode data between a client and a server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `main.go` file and import the following packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`crypto/rand`: For random number generation.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`crypto/rsa`: Provides a wrapper for RSA certificates.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`crypto/tls`: Provides a wrapper for Transport Layer Security (TLS) protocol.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`crypto.x509`: Provides a wrapper for X509 digital certificates.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function called `runServer()` to run an HTTP server with a TLS configuration.
    The function should take in the paths of the certificate file, a private key file,
    and a PEM encoded client certificate. In our TLS configuration, we require both
    server and client certificates. The server certificate is used by the client to
    validate the authenticity of the server. The client certificate is verified by
    the server to validate the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the `hello()` function, which is passed as a handler function when we
    start the HTTP server. This function will respond with some text whenever the
    server receives a request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the server side is done, let''s implement the client side:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This defines an HTTP client using the TLS implementation. It takes in the certificate
    of the CA as a parameter to verify the authenticity of the server. In our case,
    we used a self-signed certificate, so the server certificate will serve the purpose
    of a CA certificate. The function would also take the client's certificate so
    that the client can authenticate with the server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's now tie these functions and run a client and server handshake.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we generate certificates and keys for both the client and the server.
    The server is started using a `goroutine` and waits for a request from the client.
    The client is also started in a `goroutine` and calls the server every 3 seconds:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run the `main()` function. You should see the following output in
    your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we demonstrated how a client and server communication could
    be secured using the TLS protocol. We have learned how to generate digital certificates
    and used them in the TLS configuration for the client and server.
  prefs: []
  type: TYPE_NORMAL
- en: Password Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are managing user accounts on your website, one common way of verifying
    user identity is through a combination of usernames and passwords. This authentication
    mechanism has the risk that, if not properly managed, user credentials can be
    leaked. This has happened to many of the major websites around the world and remains
    a surprisingly common security incident.
  prefs: []
  type: TYPE_NORMAL
- en: The main rule of thumb regarding password management is to never store passwords
    in plaintext (either in memory or in a database). Instead, implement an approved
    hash algorithm to create a one-way hash of the password so that you can confirm
    the identity through the hash. However, it is not possible to retrieve the password
    from the hash. We can see this in action with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to create a one-way hash from a plaintext string.
    We are using the `bcrypt` package to generate the hash. We then perform a comparison
    of the password with the hash to verify the match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 19.11: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_18_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.11: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**Elliptic Curve Digital Signature Algorithm** (ECDSA) is a cryptographic algorithm
    that is used to verify the authenticity of data by providing a mechanism to sign
    and verify data using a public and private key pair.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 18.01: Authenticating Users on the Application Using Hashed Passwords'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are working on a web application and you need to authenticate users by using
    hashed passwords.
  prefs: []
  type: TYPE_NORMAL
- en: Create a database with user passwords that are stored as a hash. Define a function
    to take in a user password as an input and authenticate the user using the stored
    password in the database. Make sure the SQL query defined to query the database
    is safe from SQL injection. You can follow these steps to get the desired output.
  prefs: []
  type: TYPE_NORMAL
- en: Create a function to load data into the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to update a password in the database. Use the `crypto/sha512`
    library to encrypt the input password before updating the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to retrieve the password from the database and confirm whether
    it matches the hash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the main function of the program, initialize the database with some test
    data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform the update of the user password using the function defined in *step
    2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 19.12: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_18_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 18.12: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we securely store user passwords in a database using a hashing library
    and then verify a user's identity using a hashed password. You can use this in
    scenarios where there is sensitive data that needs to be stored.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 777.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 18.02: Creating CA Signed Certificates Using Crypto Libraries'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Certificate Authority(CA) needs to be created to sign certificates. When a
    new leaf certificate is created, it should be signed using the CA certificate
    and private key. You will need to define a function to generate ECDSA-encrypted
    keys using the `crypto/ecdsa` library. The function needs to support the creation
    of CA certificates as well as leaf certificates. Finally, you will need to verify
    the newly created leaf certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim here is to generate x509 certificates. You can follow these steps to
    get the desired output:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `generateCert()` function to generate an ECDSA certificate and private
    key using the `crypto/ecdsa` library. It should take in a common name string,
    a CA certificate, and a CA private key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The function should have the following definition:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create an ECDSA key using the `ecdsa.GenerateKey()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the key to generate an x509 certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the generated certificate and private key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `main()` function, generate a CA certificate and private key, as well
    as a leaf certificate and private key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the leaf certificate generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output should appear as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we generate x509 public key certificates. We also saw how using a root
    certificate to generate a leaf certificate can be handy when you are trying to
    implement your own PKI server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 780.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at several types of attacks that could be used
    to compromise an application. We have also covered strategies to mitigate those
    issues, along with worked examples.
  prefs: []
  type: TYPE_NORMAL
- en: We have presented the use of crypto libraries for the encryption and decryption
    of data, both at rest and in transit. We have covered hashing libraries, and how
    they can be used to securely store user credentials. We have also shown how TLS
    configuration can be used to secure communication between clients and servers.
    With these tools in mind, you can now start writing secure applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be learning about some lesser-known packages in
    Go, such as reflection and unsafe.
  prefs: []
  type: TYPE_NORMAL
