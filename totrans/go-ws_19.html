<html><head></head><body>
		<div>
			<div id="_idContainer325" class="Content">
			</div>
		</div>
		<div id="_idContainer326" class="Content">
			<h1 id="_idParaDest-440"><a id="_idTextAnchor516"/>19. Special Features</h1>
		</div>
		<div id="_idContainer331" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we will look at some special features in Go that can be helpful during your application development.</p>
			<p class="callout">This chapter will first introduce you to use build constraints, to write programs that work on multiple operating systems and architecture and also use command-line options to build Go programs. You will use reflection to inspect objects at runtime. By the end of the chapter you will be able to define build-time behavior for your application and use the <strong class="source-inline">unsafe</strong> package to access runtime memory in Go.</p>
			<h1 id="_idParaDest-441"><a id="_idTextAnchor517"/>Introduction</h1>
			<p>In the previous chapter, we learned about vulnerabilities that could affect your application and how to mitigate them. We learned how to secure communication and safely store data.</p>
			<p>We will now learn some features in Go that are not obvious and can be hard to find out about. You might come across these features if you are going through the standard library. Knowing about these features will help you to understand what is going on during the execution, as some of these properties are implicitly embedded into the language.</p>
			<p>As Go is portable across multiple <strong class="bold">operating systems</strong> (<strong class="bold">OSes</strong>) and CPU architectures, Go supports configuring these parameters to build the application. Using these build parameters, you will be able to do things such as cross-compilation, which is very rare in other programming languages.</p>
			<p>Concepts such as memory management are hard to master, so the Go runtime manages all memory allocation and deallocation, relieving the coder of the overhead of managing the memory footprint of the application. For rare cases where the coder does need to access memory, Go provides some flexibility by providing a package called <strong class="source-inline">unsafe</strong>, which we will learn about in this chapter.</p>
			<h1 id="_idParaDest-442"><a id="_idTextAnchor518"/>Build Constraints</h1>
			<p>Go programs can run on different OSes and different CPU architectures. When you build a Go program, the compilation of your program is done for your current machine's OS and architecture. By using the build constraints, you can set conditions on which a file will be considered for compilation. If you have a function that needs to be overridden for different OSes, you can use build constraints to have multiple definitions of the same function.</p>
			<p>You can see lots of examples of this happening in the Go standard library.</p>
			<p>The following links are implementations of the same function in darwin and on Linux from the <strong class="source-inline">os</strong> package in the standard library:</p>
			<ul>
				<li><a href="https://packt.live/2RKfydP">https://packt.live/2RKfydP</a></li>
				<li><a href="https://packt.live/2PJN957">https://packt.live/2PJN957</a></li>
			</ul>
			<p>If you happen to come across a similar requirement, the Go language provides build constraints that can be used to define build conditions.</p>
			<h2 id="_idParaDest-443"><a id="_idTextAnchor519"/>Build Tags</h2>
			<p>There are two ways to use build constraints. The first method is to define build tags and the second method is to use filename suffixes.</p>
			<p>Build tags should appear before the package clause in your source file. These tags are analyzed at build time and decide whether or not the file is included for the compilation.</p>
			<p>Let's take a look at how the tags are evaluated. The following tag means that the source file will only be considered for <strong class="source-inline">build</strong> on Linux machines. So, this file will not be compiled on a Windows machine:</p>
			<p class="source-code">// +build linux</p>
			<p>We can have multiple build constraints defined using build tags:</p>
			<p class="source-code">// +build amd64,darwin 386,!gccgo</p>
			<p>This evaluates to the following:</p>
			<p class="source-code">( amd64 AND darwin ) OR (386 AND (NOT gccgo))</p>
			<p>Note that in the preceding example, we also use negation to avoid certain conditions.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Make sure that there is an empty line between the build constraints and the start of the code, which is the package name.</p>
			<p>At build time, Go compares the build tags with the Go environment variables and decides what to do with the tags.</p>
			<p>By default, Go will read specific environment variables to set the build and runtime behavior. You can see what these variables are by running the following command:</p>
			<p class="source-code">go env</p>
			<div>
				<div id="_idContainer327" class="IMG---Figure">
					<img src="image/B14177_19_01.jpg" alt="Figure 20.1: The go env output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 19.1: The go env output</p>
			<p>The most commonly used variables are <strong class="source-inline">GOOS</strong>, which is the variable for the OS, and <strong class="source-inline">GOARCH</strong>, which is the variable for the CPU architecture. You can cross-compile your application by setting your <strong class="source-inline">GOOS</strong> variable to something other than your current OS. Example values of the <strong class="source-inline">GOOS</strong> variable are Windows, darwin, and Linux.</p>
			<p>Let's look at a simple hello world program and use the build tags in action. The following program has a <strong class="source-inline">build</strong> tag that makes the <strong class="source-inline">go build</strong> command ignore the file:</p>
			<p class="source-code">// +build ignore</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  fmt.Println("Hello World!")</p>
			<p class="source-code">}</p>
			<p>If you run <strong class="source-inline">go build</strong> in the current directory, you will see the following error output:</p>
			<p class="source-code">$ go build</p>
			<p class="source-code">build .: cannot find module for path .</p>
			<p>If you remove the <strong class="source-inline">build</strong> tag from the file and then run <strong class="source-inline">build</strong> again, it should produce a binary without any errors, as follows:</p>
			<p class="source-code">$ go run main.go</p>
			<p class="source-code">Hello World!</p>
			<p>Let's look at another example of the <strong class="source-inline">build</strong> tag using the <strong class="source-inline">GOOS</strong> variable. We will demonstrate how a combination of <strong class="source-inline">build</strong> tags and environment variables can affect the compilation of your application.</p>
			<p>My current operating <strong class="source-inline">GOOS</strong> variable is <strong class="source-inline">darwin</strong>. Replace <strong class="source-inline">darwin</strong> with your own <strong class="source-inline">GOOS</strong> value.</p>
			<p>To get your current <strong class="source-inline">GOOS</strong> variable, run the following command:</p>
			<p class="source-code">go env GOOS</p>
			<p>Next:</p>
			<p class="source-code">// +build darwin</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  fmt.Println("Hello World!")</p>
			<p class="source-code">}</p>
			<p>If we <strong class="source-inline">build</strong> this file, it should produce an executable binary as follows:</p>
			<p class="source-code">$go build -o good</p>
			<p class="source-code">$./goos</p>
			<p class="source-code">Hello World!</p>
			<p>Now, set your <strong class="source-inline">GOOS</strong> variable to another value other than your own; the build should fail:</p>
			<p class="source-code">$GOOS=linux go build -o goos</p>
			<p class="source-code">Build .: cannot find module for path .</p>
			<p>In this example, we learned how to use <strong class="source-inline">GOOS</strong> values as build constraints.</p>
			<h2 id="_idParaDest-444">F<a id="_idTextAnchor520"/>ilenames</h2>
			<p>As mentioned earlier, the second method to use build constraints is to use suffixes in the filename to define the constraints.</p>
			<p>Using this method, you could define constraints on the OS or CPU architecture or both.</p>
			<p>For example, the following files are from the <strong class="source-inline">syscall</strong> package in the standard library. You can see constraints defined on the OS:</p>
			<p class="source-code">syscall_linux.go</p>
			<p class="source-code">syscall_windows.go</p>
			<p class="source-code">syscall_darwin.go</p>
			<p>Another example of using both the OS and CPU architecture can be found in the runtime package:</p>
			<p class="source-code">signal_darwin_amd64.go</p>
			<p class="source-code">signal_darwin_arm.go</p>
			<p class="source-code">signal_darwin_386.go</p>
			<p>To utilize this method, the suffixes have to be of the following form:</p>
			<p class="source-code">*_GOOS</p>
			<p class="source-code">*_GOARCH</p>
			<p class="source-code">*_GOOS_GOARCH</p>
			<p>You can find examples of this naming scheme in the standard library as well:</p>
			<p class="source-code">stat_aix.go</p>
			<p class="source-code">source_windows_amd64.go</p>
			<p class="source-code">syscall_linux_386.go</p>
			<p>Let's look at an example of using filenames to define build constraints. We will define build constraints by CPU architecture. We will use this with the <strong class="source-inline">GOARCH</strong> environment variable to control the build.</p>
			<p>We have a file with a suffix of the current <strong class="source-inline">GOARCH</strong>. My current <strong class="source-inline">GOARCH</strong> is <strong class="source-inline">amd64</strong>, so the filename will be <strong class="source-inline">main_amd64.go</strong>. Replace this value for your filename. To get your current <strong class="source-inline">GOARCH</strong>, run the following command:</p>
			<p class="source-code">go env GOARCH</p>
			<p>This will display the following:</p>
			<p class="source-code">$go env GOARCH</p>
			<p class="source-code">amd64</p>
			<p>The filename on my machine will be as follows:</p>
			<p class="source-code">main_amd64.go</p>
			<p>Inside the file, we will define a simple <strong class="source-inline">"Hello World"</strong> program:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  fmt.Println("Hello World!")</p>
			<p class="source-code">}</p>
			<p>The output will be as follows:</p>
			<p class="source-code">$ls</p>
			<p class="source-code">main_amd64.go</p>
			<p class="source-code">$go build -o goarch</p>
			<p class="source-code">$./goarch</p>
			<p class="source-code">Hello World!</p>
			<p>To confirm that the constraint works, we can use another <strong class="source-inline">GOARCH</strong> value to try and check whether the build fails:</p>
			<p class="source-code">$ls</p>
			<p class="source-code">main_amd64.go</p>
			<p class="source-code">$GOARCH=386 go build -o goarch</p>
			<p class="source-code">build .: cannot find module for path .</p>
			<p>In the preceding example, we learned how to use CPU architecture as a build constraint to restrict building files on specific CPU architecture.</p>
			<h1 id="_idParaDest-445">R<a id="_idTextAnchor521"/>eflection</h1>
			<p>Reflection is the mechanism of inspecting code at runtime. Reflection is useful when you do not know or cannot guarantee the type of input for a function. In cases such as this, reflection can be used to inspect the type of the object and manipulate values of objects.</p>
			<p>The Go <strong class="source-inline">reflect</strong> package gives you features to inspect and manipulate an object at runtime. It can be used not only for basic types such as <strong class="source-inline">int</strong> and <strong class="source-inline">string</strong>, but for inspecting slices, arrays, and structs as well.</p>
			<p>Let's create a simple <strong class="source-inline">print()</strong> function to demonstrate how we can use reflection. We define a utility print function called <strong class="source-inline">MyPrint()</strong> that can print different types of objects. This is done by having an interface as an input to the function. Then, inside the function, we make use of the <strong class="source-inline">reflect</strong> package to alter the behavior according to the type of the input. Consider the following code:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "reflect"</p>
			<p class="source-code">)</p>
			<p class="source-code">type Animal struct {</p>
			<p class="source-code">  Name string</p>
			<p class="source-code">}</p>
			<p class="source-code">type Object struct {</p>
			<p class="source-code">  Type string</p>
			<p class="source-code">}</p>
			<p class="source-code">type Person struct {</p>
			<p class="source-code">  Name string</p>
			<p class="source-code">}</p>
			<p class="source-code">func MyPrint(input interface{}) {</p>
			<p class="source-code">  t := reflect.TypeOf(input)</p>
			<p class="source-code">  v := reflect.ValueOf(input)</p>
			<p class="source-code">  switch {</p>
			<p class="source-code">  case t.Name() == "Animal":</p>
			<p class="source-code">    fmt.Println("I am a ", v.FieldByName("Name"))</p>
			<p class="source-code">  case t.Name() == "Object":</p>
			<p class="source-code">    fmt.Println("I am a ", v.FieldByName("Type"))</p>
			<p class="source-code">  default:</p>
			<p class="source-code">    fmt.Println("I got an unknown entity")</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  table := Object{Type: "Chair"}</p>
			<p class="source-code">  MyPrint(table)</p>
			<p class="source-code">  tiger := Animal{Name: "Tiger"}</p>
			<p class="source-code">  MyPrint(tiger)</p>
			<p class="source-code">  gobin := Person{Name: "Gobin"}</p>
			<p class="source-code">  MyPrint(gobin)</p>
			<p class="source-code">}</p>
			<p>Running the preceding program, we get the following output:</p>
			<p class="source-code">$go run main.go</p>
			<p class="source-code">I am a Chair</p>
			<p class="source-code">I am a Tiger</p>
			<p class="source-code">I got an unknown entity</p>
			<p>You can find examples of reflection being used in packages such as <strong class="source-inline">encoding/json</strong> and <strong class="source-inline">fmt</strong>.</p>
			<p>Let's look at how to use reflection using some common utility functions in the <strong class="source-inline">reflect</strong> package.</p>
			<h1 id="_idParaDest-446">T<a id="_idTextAnchor522"/>ypeOf and ValueOf</h1>
			<p>To use reflection, you will need to get familiar with two types defined in the <strong class="source-inline">reflect</strong> package:</p>
			<p class="source-code">reflect.Type</p>
			<p class="source-code">reflect.Value</p>
			<p>Both of these types provide utility functions that give you access to the dynamic runtime information of the object.</p>
			<p>These two functions give you a handle on the <strong class="source-inline">Type</strong> and <strong class="source-inline">Value</strong> of the object:</p>
			<p class="source-code">func TypeOf( interface{}) Type</p>
			<p class="source-code">func ValueOf( interface{}) Value</p>
			<p>The following program uses the two functions to print the <strong class="source-inline">Type</strong> and <strong class="source-inline">Value</strong> of the object being passed:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  var x = 5</p>
			<p class="source-code">  Print(x)</p>
			<p class="source-code">  var y = []string{"test"}</p>
			<p class="source-code">  Print(y)</p>
			<p class="source-code">  var z = map[string]string{"a": "b"}</p>
			<p class="source-code">  Print(z)</p>
			<p class="source-code">}</p>
			<p class="source-code">func Print(a interface{}) {</p>
			<p class="source-code">  fmt.Println("Type: ", reflect.TypeOf(a))</p>
			<p class="source-code">  fmt.Println("Value: ", reflect.ValueOf(a))</p>
			<p class="source-code">}</p>
			<p>The output of the preceding program should print the <strong class="source-inline">Type</strong> of <strong class="source-inline">x</strong>:</p>
			<p class="source-code">$ go run main.go</p>
			<p class="source-code">Type: int</p>
			<p class="source-code">Value 5</p>
			<p class="source-code">Type: []string</p>
			<p class="source-code">Value: [test]</p>
			<p class="source-code">Type: map[string]string</p>
			<p class="source-code">Value: map[a:b]</p>
			<p>In this example, we observed how two functions are used to print the <strong class="source-inline">Type</strong> and <strong class="source-inline">Value</strong> of the object passed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is important to make sure that you use the reflection package carefully. Using the type conversion incorrectly or calling a method on an object that does not support the method will cause the program to panic.</p>
			<h2 id="_idParaDest-447"><a id="_idTextAnchor523"/>Exercise 19.01: Using Reflection</h2>
			<p>In this exercise, we will use the reflection package to inspect objects at runtime:</p>
			<ol>
				<li>Create a file named <strong class="source-inline">main.go</strong>.</li>
				<li>Import the following packages:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "math"</p><p class="source-code">  "reflect"</p><p class="source-code">)</p></li>
				<li>Define a <strong class="source-inline">struct</strong> called <strong class="source-inline">circle</strong> with the <strong class="source-inline">radius</strong> as one of its fields:<p class="source-code">type circle struct {</p><p class="source-code">  radius float64</p><p class="source-code">}</p></li>
				<li>Define another <strong class="source-inline">struct</strong> called <strong class="source-inline">rectangle</strong> with <strong class="source-inline">length</strong> and <strong class="source-inline">breadth</strong> as its fields:<p class="source-code">type rectangle struct {</p><p class="source-code">  length  float64</p><p class="source-code">  breadth float64</p><p class="source-code">}</p></li>
				<li>Define a function called <strong class="source-inline">area()</strong> that can calculate the area of different shapes. It should take <strong class="source-inline">interface</strong> as its input:<p class="source-code">func area(input interface{}) float64 {</p><p class="source-code">  inputType := reflect.TypeOf(input)</p><p class="source-code">  if inputType.Name() == "circle" {</p><p class="source-code">    val := reflect.ValueOf(input)</p><p class="source-code">    radius := val.FieldByName("radius")</p><p class="source-code">    return math.Pi * math.Pow(radius.Float(), 2)</p><p class="source-code">  }</p><p class="source-code">  if inputType.Name() == "rectangle" {</p><p class="source-code">    val := reflect.ValueOf(input)</p><p class="source-code">    length := val.FieldByName("length")</p><p class="source-code">    breadth := val.FieldByName("breadth")</p><p class="source-code">    return length.Float() * breadth.Float()</p><p class="source-code">  }</p><p class="source-code">  return 0</p><p class="source-code">}</p><p>In this function, we use <strong class="source-inline">reflect.TypeOf()</strong> to get a <strong class="source-inline">reflect.Type</strong> object from the input. We then use the <strong class="source-inline">Type.Name()</strong> function to get the name of the <strong class="source-inline">struct</strong>, which, in our case, could be either a circle or a rectangle.</p><p>To retrieve the value of the fields in the struct, we first use the <strong class="source-inline">reflect.ValueOf()</strong> function to get a <strong class="source-inline">reflect.Value</strong> object. Then we use <strong class="source-inline">Val.FieldByName()</strong> to get the field value.</p></li>
				<li>Define a <strong class="source-inline">main()</strong> function and call the <strong class="source-inline">area()</strong> function:<p class="source-code">func main() {</p><p class="source-code">  fmt.Printf("area of circle with radius 3 is : %f\n", area(circle{radius: </p><p class="source-code">    3}))</p><p class="source-code">  fmt.Printf("area of rectangle with length 3 and breadth 7 is : %f\n", </p><p class="source-code">    area(rectangle{length: 3, breadth: 7}))</p><p class="source-code">}</p></li>
				<li>Run the program using the following command:<p class="source-code">go run main.go</p><p>You should get the following output when you run the program:</p><p class="source-code">$ go run main.go</p><p class="source-code">area of circle with radius 3 is : 28.274334</p><p class="source-code">area of rectangle with length 3 and breadth 7 is : 21.000000</p></li>
			</ol>
			<p>In this exercise, we learned how to use reflection to define the different implementations of a function, in this case, by inspecting the input object to determine what object is being passed in.</p>
			<h2 id="_idParaDest-448"><a id="_idTextAnchor524"/>Activity 19.01: Defining Build Constraints Using Filenames</h2>
			<p>You have to define a function that behaves differently depending on the OS and CPU architecture. Use build constraints on a filename to achieve this behavior. One file should be set with the OS constraint set to <strong class="source-inline">darwin</strong> and another with the CPU architecture set to <strong class="source-inline">386</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Substitute <strong class="source-inline">darwin</strong> with your current OS and <strong class="source-inline">386</strong> with another architecture that is not your current machine's architecture.</p>
			<p>Perform the following steps:</p>
			<ol>
				<li value="1">Create a package called <strong class="source-inline">custom</strong>.</li>
				<li>Create a <strong class="source-inline">print_darwin.go</strong> file and define a function called <strong class="source-inline">Print()</strong> inside the package. It should print the following text: <strong class="source-inline">I am running on a darwin machine</strong>.</li>
				<li>Create another file in the same package called <strong class="source-inline">print_386.go</strong> and define a function called <strong class="source-inline">Print()</strong> that prints the following text: <strong class="source-inline">Hello I am running on a 386 machine</strong>.</li>
				<li>Define a <strong class="source-inline">main()</strong> function and import the <strong class="source-inline">custom</strong> package. Call the <strong class="source-inline">Print()</strong> function from the custom package in the <strong class="source-inline">main()</strong> function.</li>
			</ol>
			<p>By the end of the activity, you should see the following output:</p>
			<p class="source-code">$go run main.go</p>
			<p class="source-code">Hello I am running on a darwin machine.</p>
			<p>In this activity, we implemented overriding a function using build constraints with filenames. You should be able to see a similar implementation in the Go standard library.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 782.</p>
			<h1 id="_idParaDest-449"><a id="_idTextAnchor525"/>DeepEqual</h1>
			<p>The <strong class="source-inline">reflect.DeepEqual()</strong> requires a mention if we are talking about the <strong class="source-inline">reflect</strong> package.</p>
			<p>Basic data types in Go can be compared using the <strong class="source-inline">==</strong> or <strong class="source-inline">!=</strong> operator, but slices and maps are not comparable using this method.</p>
			<p>The <strong class="source-inline">reflect.DeepEqual()</strong> function can be used in scenarios when the types are incomparable. For example, it can be used for comparing slices and maps. Here is an example that compares maps and slices using <strong class="source-inline">DeepEqual</strong>:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">  "fmt"</p>
			<p class="source-code">  "reflect"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  runDeepEqual(nil, nil)</p>
			<p class="source-code">  runDeepEqual(make([]int, 10), make([]int, 10))</p>
			<p class="source-code">  runDeepEqual([3]int{1, 2, 3}, [3]int{1, 2, 3})</p>
			<p class="source-code">  runDeepEqual(map[int]string{1: "one", 2: "two"}, map[int]string{2:     "two", 1: "one"})</p>
			<p class="source-code">}</p>
			<p class="source-code">func runDeepEqual(a, b interface{}) {</p>
			<p class="source-code">  fmt.Printf("%v DeepEqual %v : %v\n", a, b, reflect.DeepEqual(a, b))</p>
			<p class="source-code">}</p>
			<p>In the preceding example, we compare different data types using <strong class="source-inline">reflect.DeepEqual()</strong>.</p>
			<p>The following are the comparisons done:</p>
			<ul>
				<li>Two nil objects.</li>
				<li>Two empty slices with the same size. The size is important here.</li>
				<li>Two slices with the same data in the same order. Values in a different order will give a different output.</li>
				<li>Two maps with the same data. The order of keys does not matter here as maps are always unordered.</li>
			</ul>
			<p>If you run the program, you should get the following output:</p>
			<div>
				<div id="_idContainer328" class="IMG---Figure">
					<img src="image/B14177_19_02.jpg" alt="Figure 20.2: DeepEqual output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 19.2: DeepEqual output</p>
			<h1 id="_idParaDest-450">Wi<a id="_idTextAnchor526"/>ldcard Pattern</h1>
			<p>The <strong class="source-inline">go</strong> tool has a number of commands to help you with your code development. For example, the <strong class="source-inline">go list</strong> command helps you list Go files in your current directory, and the <strong class="source-inline">go test</strong> command helps you run test files in your current directory.</p>
			<p>Your project may be structured in multiple subdirectories to help organize your code logically. If you wanted to use the <strong class="source-inline">go</strong> tool to run commands over your whole codebase at once, it supports a wildcard pattern that helps you do just that.</p>
			<p>To list all the <strong class="source-inline">.go</strong> files in your current directory and its subdirectories, you can use the following relative pattern:</p>
			<p class="source-code">go list ./...</p>
			<p>Similarly, if you wanted to run all the tests in your current directory and subdirectories, the same pattern can be used:</p>
			<p class="source-code">go test ./...</p>
			<p>If you are still using vendor directories, the good thing is that this pattern will ignore the <strong class="source-inline">./vendor</strong> directories.</p>
			<p>Let's try the wildcard patterns on the Go workshop repository.</p>
			<p>To list all the <strong class="source-inline">.go</strong> files in the project, you can run the <strong class="source-inline">list</strong> command with the wildcard:</p>
			<p class="source-code">go list -f {{.GoFiles}}{{.Dir}} ./...</p>
			<p>You should get an output similar to the following:</p>
			<div>
				<div id="_idContainer329" class="IMG---Figure">
					<img src="image/B14177_19_03.jpg" alt="Figure 20.3: Wildcard pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 19.3: Wildcard pattern</p>
			<h1 id="_idParaDest-451"><a id="_idTextAnchor527"/>The unsafe Package</h1>
			<p>Go is a statically typed language, and it has its own runtime that does memory allocation and garbage collection. So, unlike C, all the work related to memory management is taken care of by the runtime. Unless you have some special requirements, you would never have to deal with memory directly in your code. When there is a requirement, though, the <strong class="source-inline">unsafe</strong> package in the standard library gives you features to let you peek into the memory of an object.</p>
			<p>As the name suggests, it is normally not considered safe to use this package in your code. Another thing to note is that the <strong class="source-inline">unsafe</strong> package does not come with Go 1 compatibility guidelines, which means that functionalities could stop working in future versions of Go.</p>
			<p>The simplest example you can find of using the <strong class="source-inline">unsafe</strong> package can be found in the <strong class="source-inline">math</strong> package:</p>
			<p class="source-code">func Float32bits(f float32) uint32</p>
			<p class="source-code">{</p>
			<p class="source-code">  return *(*uint32)(unsafe.Pointer(&amp;f))</p>
			<p class="source-code">}</p>
			<p>This takes a <strong class="source-inline">float32</strong> as input and returns <strong class="source-inline">uint32</strong>. The <strong class="source-inline">float32</strong> number is converted to an <strong class="source-inline">unsafe.Pointer</strong> object and then dereferenced to convert it to a <strong class="source-inline">uint32</strong>.</p>
			<p>The reverse conversion on the preceding function can also be found in the <strong class="source-inline">math</strong> package:</p>
			<p class="source-code">func Float32frombits(b uint32) float32 {</p>
			<p class="source-code">  return *(*float32)(unsafe.Pointer(&amp;b))</p>
			<p class="source-code">}</p>
			<p>Another example of using the <strong class="source-inline">unsafe</strong> package, which you can find in the standard library is when calling C programs from your Go code. This is formally known as <strong class="source-inline">cgo</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">To get <strong class="source-inline">cgo</strong> to work on Windows, you need to have the <strong class="source-inline">gcc</strong> compiler installed on your machine. You can use 'Minimalist GNU for Windows' (<a href="https://packt.live/2EbOKuZ">https://packt.live/2EbOKuZ</a>).</p>
			<p>There are some special functions provided in the pseudo C package that convert Go data types to C data or vice versa, for example:</p>
			<p class="source-code">// Converts Go string to C string</p>
			<p class="source-code">func C.CString(string) *C.char</p>
			<p class="source-code">// C data with explicit length to Go []byte</p>
			<p class="source-code">func C.GoBytes(unsafe.Pointer, C.int) []byte</p>
			<p>You<a id="_idTextAnchor528"/> can write your program as normal Go code and call functions written in C, as shown in the following example:</p>
			<p class="source-code">package main</p>
			<p class="source-code">//#include &lt;stdio.h&gt;</p>
			<p class="source-code">//#include &lt;stdlib.h&gt;</p>
			<p class="source-code">//static void myprint(char* s) {</p>
			<p class="source-code">//  printf("%s\n", s);</p>
			<p class="source-code">//}</p>
			<p class="source-code">import "C"</p>
			<p class="source-code">import "unsafe"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">  cs := C.CString("Hello World!")</p>
			<p class="source-code">  C.myprint(cs)</p>
			<p class="source-code">  C.free(unsafe.Pointer(cs))</p>
			<p class="source-code">}</p>
			<p>You can define functions in C in the following format. To use functions in the standard library, the <strong class="source-inline">import</strong> statement is preceded by a comment, which is treated as the header section of your C code:</p>
			<p class="source-code">// #include &lt;stdio.h&gt;</p>
			<p class="source-code">// #include &lt;stdlib.h&gt;</p>
			<p class="source-code">//</p>
			<p class="source-code">// static void myprint(char* s) {</p>
			<p class="source-code">//   printf("%s\n", s);</p>
			<p class="source-code">// }</p>
			<p>The preceding function prints the input to the console. To be able to use the C code, we need to import the pseudo package called <strong class="source-inline">C</strong>. In the <strong class="source-inline">main</strong> function, we can call the <strong class="source-inline">myprint()</strong> function using the C package.</p>
			<p>Running this program should get you the following output:</p>
			<p class="source-code">$ go run main.go</p>
			<p class="source-code">Hello World!</p>
			<h2 id="_idParaDest-452">Exe<a id="_idTextAnchor529"/>rcise 19.02: Using cgo with unsafe</h2>
			<p>In this exercise, we will learn how to use the <strong class="source-inline">unsafe</strong> package to get hold of the underlying memory of a string:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">main.go</strong> file and make the following imports. The C pseudo-package is needed to use the C libraries:<p class="source-code">package main</p><p class="source-code">// #include &lt;stdlib.h&gt;</p><p class="source-code">import "C"</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "unsafe"</p><p class="source-code">)</p></li>
				<li>Define a <strong class="source-inline">main()</strong> function and declare a <strong class="source-inline">C</strong> string:<p class="source-code">func main() {</p><p class="source-code">  var cString *C.char</p></li>
				<li>Set the value of the <strong class="source-inline">cString</strong> variable with the text <strong class="source-inline">Hello World!\n</strong>. It is always a good practice to clean up allocated memory when dealing with <strong class="source-inline">C</strong>, so add the <strong class="source-inline">C.free()</strong> function call to perform the cleanup:<p class="source-code">cString = C.CString("Hello World!\n")</p><p class="source-code">  defer C.free(unsafe.Pointer(cString))</p></li>
				<li>Declare a variable, <strong class="source-inline">b</strong>, as a byte array to store the output of converting the <strong class="source-inline">CString</strong> into a Go <strong class="source-inline">byte</strong> array:<p class="source-code">var b []byte</p><p class="source-code">b = C.GoBytes(unsafe.Pointer(cString), C.int(14))</p><p>The <strong class="source-inline">C.GoBytes()</strong> function converts an <strong class="source-inline">unsafe</strong>.<strong class="source-inline">Pointer</strong> object into a Go <strong class="source-inline">byte</strong> array.</p></li>
				<li>Print the <strong class="source-inline">byte</strong> array to the console:<p class="source-code">fmt.Print(string(b))</p><p class="source-code">}</p></li>
				<li>Run the program using the following command:<p class="source-code">go run main.go</p><p>You should get the following output:</p><p class="source-code">$ go run main.go</p><p class="source-code">Hellow World!</p></li>
			</ol>
			<p>In this exercise, we learned how to use <strong class="source-inline">Cgo</strong> and create C objects in Go. We then used the <strong class="source-inline">unsafe</strong> package to convert a <strong class="source-inline">CString</strong> object into an <strong class="source-inline">unsafe.Pointer</strong>, which maps directly to the memory of the <strong class="source-inline">CString</strong>.</p>
			<h2 id="_idParaDest-453">Act<a id="_idTextAnchor530"/><a id="_idTextAnchor531"/>ivity 19.02: Using Wildcard with Go Test</h2>
			<p>You have a project with multiple test files and multiple test cases defined inside them. Create multiple packages and define tests inside them. Using the wildcard pattern, run all test cases in the project with a single command. Make sure that all the unit tests are being run using the command.</p>
			<p>Perform the following steps:</p>
			<ol>
				<li value="1">Create a package called <strong class="source-inline">package1</strong>.</li>
				<li>Create a file called <strong class="source-inline">run_test.go</strong> and define a unit test called <strong class="source-inline">TestPackage1</strong>.</li>
				<li>Create a package called <strong class="source-inline">package2</strong>.</li>
				<li>Create a file called <strong class="source-inline">run_test.go</strong> and define a unit test called <strong class="source-inline">TestPackage2</strong>.</li>
				<li>Print the results of <strong class="source-inline">TestPackage1</strong> and <strong class="source-inline">TestPackage2</strong> using the wildcard pattern:</li>
			</ol>
			<div>
				<div id="_idContainer330" class="IMG---Figure">
					<img src="image/B14177_19_04.jpg" alt="Figure 20.4: Recursive test with wildcard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 19.4: Recursive test with wildcard</p>
			<p>In this activity, we have learned how to use the wildcard pattern to recursively run tests on all test files inside a project. This will come in handy when you want to automate running tests in your continuous integration pipeline.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 782.</p>
			<h1 id="_idParaDest-454">Summ<a id="_idTextAnchor532"/><a id="_idTextAnchor533"/>ary</h1>
			<p>In this chapter, we learned about the special features in Go that are not so obvious.</p>
			<p>We covered the use of build constraints and how they can be used to control the behavior of your application build. Build constraints can be used to perform conditional compilation using the <strong class="source-inline">GOOS</strong> and <strong class="source-inline">GOARCH</strong> variables. They can also be used to ignore a file during compilation. Another common use of <strong class="source-inline">build</strong> tags is to add tags to files that contain integration tests.</p>
			<p>We have seen use cases for the <strong class="source-inline">reflect</strong> package and the functions that can be used to access the type and value of objects at runtime. Reflection is a good way to solve scenarios where we can only determine the data type of a variable at runtime.</p>
			<p>We also demonstrated how wildcards can be used to perform lists and tests on multiple packages in your project. We also learned the use of the <strong class="source-inline">unsafe</strong> package to access runtime memory in Go. The <strong class="source-inline">unsafe</strong> package is commonly used when using C libraries.</p>
			<p>Over the course of the book, we have covered the basics of Go with variables and various type declarations. We have seen the special behavior of interfaces and errors in Go. The book also covered chapters focused on application development. Handling files and JSON data is very common in any application's development, especially web applications. The chapters on databases and HTTP servers delve into how you can manage the communication and storage of data. We also looked at how to easily perform concurrent operations using goroutines. Finally, in the last topic of the book, we covered how to improve your code quality by focusing on testing and securing your application. Last but not least, we explored special features in Go such as build constraints and the use of the <strong class="source-inline">unsafe</strong> package.</p>
		</div>
		<div>
			<div id="_idContainer332" class="Content">
			</div>
		</div>
	</body></html>