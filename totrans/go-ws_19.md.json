["```go\n// +build linux\n```", "```go\n// +build amd64,darwin 386,!gccgo\n```", "```go\n( amd64 AND darwin ) OR (386 AND (NOT gccgo))\n```", "```go\ngo env\n```", "```go\n// +build ignore\npackage main\nimport \"fmt\"\nfunc main() {\n  fmt.Println(\"Hello World!\")\n}\n```", "```go\n$ go build\nbuild .: cannot find module for path .\n```", "```go\n$ go run main.go\nHello World!\n```", "```go\ngo env GOOS\n```", "```go\n// +build darwin\npackage main\nimport \"fmt\"\nfunc main() {\n  fmt.Println(\"Hello World!\")\n}\n```", "```go\n$go build -o good\n$./goos\nHello World!\n```", "```go\n$GOOS=linux go build -o goos\nBuild .: cannot find module for path .\n```", "```go\nsyscall_linux.go\nsyscall_windows.go\nsyscall_darwin.go\n```", "```go\nsignal_darwin_amd64.go\nsignal_darwin_arm.go\nsignal_darwin_386.go\n```", "```go\n*_GOOS\n*_GOARCH\n*_GOOS_GOARCH\n```", "```go\nstat_aix.go\nsource_windows_amd64.go\nsyscall_linux_386.go\n```", "```go\ngo env GOARCH\n```", "```go\n$go env GOARCH\namd64\n```", "```go\nmain_amd64.go\n```", "```go\npackage main\nimport \"fmt\"\nfunc main() {\n  fmt.Println(\"Hello World!\")\n}\n```", "```go\n$ls\nmain_amd64.go\n$go build -o goarch\n$./goarch\nHello World!\n```", "```go\n$ls\nmain_amd64.go\n$GOARCH=386 go build -o goarch\nbuild .: cannot find module for path .\n```", "```go\npackage main\nimport (\n  \"fmt\"\n  \"reflect\"\n)\ntype Animal struct {\n  Name string\n}\ntype Object struct {\n  Type string\n}\ntype Person struct {\n  Name string\n}\nfunc MyPrint(input interface{}) {\n  t := reflect.TypeOf(input)\n  v := reflect.ValueOf(input)\n  switch {\n  case t.Name() == \"Animal\":\n    fmt.Println(\"I am a \", v.FieldByName(\"Name\"))\n  case t.Name() == \"Object\":\n    fmt.Println(\"I am a \", v.FieldByName(\"Type\"))\n  default:\n    fmt.Println(\"I got an unknown entity\")\n  }\n}\nfunc main() {\n  table := Object{Type: \"Chair\"}\n  MyPrint(table)\n  tiger := Animal{Name: \"Tiger\"}\n  MyPrint(tiger)\n  gobin := Person{Name: \"Gobin\"}\n  MyPrint(gobin)\n}\n```", "```go\n$go run main.go\nI am a Chair\nI am a Tiger\nI got an unknown entity\n```", "```go\nreflect.Type\nreflect.Value\n```", "```go\nfunc TypeOf( interface{}) Type\nfunc ValueOf( interface{}) Value\n```", "```go\nfunc main() {\n  var x = 5\n  Print(x)\n  var y = []string{\"test\"}\n  Print(y)\n  var z = map[string]string{\"a\": \"b\"}\n  Print(z)\n}\nfunc Print(a interface{}) {\n  fmt.Println(\"Type: \", reflect.TypeOf(a))\n  fmt.Println(\"Value: \", reflect.ValueOf(a))\n}\n```", "```go\n$ go run main.go\nType: int\nValue 5\nType: []string\nValue: [test]\nType: map[string]string\nValue: map[a:b]\n```", "```go\n    package main\n    import (\n      \"fmt\"\n      \"math\"\n      \"reflect\"\n    )\n    ```", "```go\n    type circle struct {\n      radius float64\n    }\n    ```", "```go\n    type rectangle struct {\n      length  float64\n      breadth float64\n    }\n    ```", "```go\n    func area(input interface{}) float64 {\n      inputType := reflect.TypeOf(input)\n      if inputType.Name() == \"circle\" {\n        val := reflect.ValueOf(input)\n        radius := val.FieldByName(\"radius\")\n        return math.Pi * math.Pow(radius.Float(), 2)\n      }\n      if inputType.Name() == \"rectangle\" {\n        val := reflect.ValueOf(input)\n        length := val.FieldByName(\"length\")\n        breadth := val.FieldByName(\"breadth\")\n        return length.Float() * breadth.Float()\n      }\n      return 0\n    }\n    ```", "```go\n    func main() {\n      fmt.Printf(\"area of circle with radius 3 is : %f\\n\", area(circle{radius: \n        3}))\n      fmt.Printf(\"area of rectangle with length 3 and breadth 7 is : %f\\n\", \n        area(rectangle{length: 3, breadth: 7}))\n    }\n    ```", "```go\n    go run main.go\n    ```", "```go\n    $ go run main.go\n    area of circle with radius 3 is : 28.274334\n    area of rectangle with length 3 and breadth 7 is : 21.000000\n    ```", "```go\n$go run main.go\nHello I am running on a darwin machine.\n```", "```go\npackage main\nimport (\n  \"fmt\"\n  \"reflect\"\n)\nfunc main() {\n  runDeepEqual(nil, nil)\n  runDeepEqual(make([]int, 10), make([]int, 10))\n  runDeepEqual([3]int{1, 2, 3}, [3]int{1, 2, 3})\n  runDeepEqual(map[int]string{1: \"one\", 2: \"two\"}, map[int]string{2:     \"two\", 1: \"one\"})\n}\nfunc runDeepEqual(a, b interface{}) {\n  fmt.Printf(\"%v DeepEqual %v : %v\\n\", a, b, reflect.DeepEqual(a, b))\n}\n```", "```go\ngo list ./...\n```", "```go\ngo test ./...\n```", "```go\ngo list -f {{.GoFiles}}{{.Dir}} ./...\n```", "```go\nfunc Float32bits(f float32) uint32\n{\n  return *(*uint32)(unsafe.Pointer(&f))\n}\n```", "```go\nfunc Float32frombits(b uint32) float32 {\n  return *(*float32)(unsafe.Pointer(&b))\n}\n```", "```go\n// Converts Go string to C string\nfunc C.CString(string) *C.char\n// C data with explicit length to Go []byte\nfunc C.GoBytes(unsafe.Pointer, C.int) []byte\n```", "```go\npackage main\n//#include <stdio.h>\n//#include <stdlib.h>\n//static void myprint(char* s) {\n//  printf(\"%s\\n\", s);\n//}\nimport \"C\"\nimport \"unsafe\"\nfunc main() {\n  cs := C.CString(\"Hello World!\")\n  C.myprint(cs)\n  C.free(unsafe.Pointer(cs))\n}\n```", "```go\n// #include <stdio.h>\n// #include <stdlib.h>\n//\n// static void myprint(char* s) {\n//   printf(\"%s\\n\", s);\n// }\n```", "```go\n$ go run main.go\nHello World!\n```", "```go\n    package main\n    // #include <stdlib.h>\n    import \"C\"\n    import (\n      \"fmt\"\n      \"unsafe\"\n    )\n    ```", "```go\n    func main() {\n      var cString *C.char\n    ```", "```go\n    cString = C.CString(\"Hello World!\\n\")\n      defer C.free(unsafe.Pointer(cString))\n    ```", "```go\n    var b []byte\n    b = C.GoBytes(unsafe.Pointer(cString), C.int(14))\n    ```", "```go\n    fmt.Print(string(b))\n    }\n    ```", "```go\n    go run main.go\n    ```", "```go\n    $ go run main.go\n    Hellow World!\n    ```"]