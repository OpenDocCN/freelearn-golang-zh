- en: 19\. Special Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at some special features in Go that can be helpful
    during your application development.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will first introduce you to use build constraints, to write programs
    that work on multiple operating systems and architecture and also use command-line
    options to build Go programs. You will use reflection to inspect objects at runtime.
    By the end of the chapter you will be able to define build-time behavior for your
    application and use the `unsafe` package to access runtime memory in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about vulnerabilities that could affect
    your application and how to mitigate them. We learned how to secure communication
    and safely store data.
  prefs: []
  type: TYPE_NORMAL
- en: We will now learn some features in Go that are not obvious and can be hard to
    find out about. You might come across these features if you are going through
    the standard library. Knowing about these features will help you to understand
    what is going on during the execution, as some of these properties are implicitly
    embedded into the language.
  prefs: []
  type: TYPE_NORMAL
- en: As Go is portable across multiple **operating systems** (**OSes**) and CPU architectures,
    Go supports configuring these parameters to build the application. Using these
    build parameters, you will be able to do things such as cross-compilation, which
    is very rare in other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Concepts such as memory management are hard to master, so the Go runtime manages
    all memory allocation and deallocation, relieving the coder of the overhead of
    managing the memory footprint of the application. For rare cases where the coder
    does need to access memory, Go provides some flexibility by providing a package
    called `unsafe`, which we will learn about in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Build Constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go programs can run on different OSes and different CPU architectures. When
    you build a Go program, the compilation of your program is done for your current
    machine's OS and architecture. By using the build constraints, you can set conditions
    on which a file will be considered for compilation. If you have a function that
    needs to be overridden for different OSes, you can use build constraints to have
    multiple definitions of the same function.
  prefs: []
  type: TYPE_NORMAL
- en: You can see lots of examples of this happening in the Go standard library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following links are implementations of the same function in darwin and
    on Linux from the `os` package in the standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.live/2RKfydP](https://packt.live/2RKfydP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://packt.live/2PJN957](https://packt.live/2PJN957)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you happen to come across a similar requirement, the Go language provides
    build constraints that can be used to define build conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Build Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to use build constraints. The first method is to define build
    tags and the second method is to use filename suffixes.
  prefs: []
  type: TYPE_NORMAL
- en: Build tags should appear before the package clause in your source file. These
    tags are analyzed at build time and decide whether or not the file is included
    for the compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how the tags are evaluated. The following tag means that
    the source file will only be considered for `build` on Linux machines. So, this
    file will not be compiled on a Windows machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can have multiple build constraints defined using build tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This evaluates to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the preceding example, we also use negation to avoid certain conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that there is an empty line between the build constraints and the
    start of the code, which is the package name.
  prefs: []
  type: TYPE_NORMAL
- en: At build time, Go compares the build tags with the Go environment variables
    and decides what to do with the tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Go will read specific environment variables to set the build and
    runtime behavior. You can see what these variables are by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 20.1: The go env output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_19_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 19.1: The go env output'
  prefs: []
  type: TYPE_NORMAL
- en: The most commonly used variables are `GOOS`, which is the variable for the OS,
    and `GOARCH`, which is the variable for the CPU architecture. You can cross-compile
    your application by setting your `GOOS` variable to something other than your
    current OS. Example values of the `GOOS` variable are Windows, darwin, and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simple hello world program and use the build tags in action.
    The following program has a `build` tag that makes the `go build` command ignore
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run `go build` in the current directory, you will see the following
    error output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you remove the `build` tag from the file and then run `build` again, it
    should produce a binary without any errors, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at another example of the `build` tag using the `GOOS` variable.
    We will demonstrate how a combination of `build` tags and environment variables
    can affect the compilation of your application.
  prefs: []
  type: TYPE_NORMAL
- en: My current operating `GOOS` variable is `darwin`. Replace `darwin` with your
    own `GOOS` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get your current `GOOS` variable, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we `build` this file, it should produce an executable binary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, set your `GOOS` variable to another value other than your own; the build
    should fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we learned how to use `GOOS` values as build constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Filenames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, the second method to use build constraints is to use suffixes
    in the filename to define the constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Using this method, you could define constraints on the OS or CPU architecture
    or both.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following files are from the `syscall` package in the standard
    library. You can see constraints defined on the OS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example of using both the OS and CPU architecture can be found in the
    runtime package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To utilize this method, the suffixes have to be of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find examples of this naming scheme in the standard library as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at an example of using filenames to define build constraints. We
    will define build constraints by CPU architecture. We will use this with the `GOARCH`
    environment variable to control the build.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a file with a suffix of the current `GOARCH`. My current `GOARCH` is
    `amd64`, so the filename will be `main_amd64.go`. Replace this value for your
    filename. To get your current `GOARCH`, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The filename on my machine will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the file, we will define a simple `"Hello World"` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To confirm that the constraint works, we can use another `GOARCH` value to
    try and check whether the build fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we learned how to use CPU architecture as a build
    constraint to restrict building files on specific CPU architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection is the mechanism of inspecting code at runtime. Reflection is useful
    when you do not know or cannot guarantee the type of input for a function. In
    cases such as this, reflection can be used to inspect the type of the object and
    manipulate values of objects.
  prefs: []
  type: TYPE_NORMAL
- en: The Go `reflect` package gives you features to inspect and manipulate an object
    at runtime. It can be used not only for basic types such as `int` and `string`,
    but for inspecting slices, arrays, and structs as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple `print()` function to demonstrate how we can use reflection.
    We define a utility print function called `MyPrint()` that can print different
    types of objects. This is done by having an interface as an input to the function.
    Then, inside the function, we make use of the `reflect` package to alter the behavior
    according to the type of the input. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding program, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can find examples of reflection being used in packages such as `encoding/json`
    and `fmt`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how to use reflection using some common utility functions in the
    `reflect` package.
  prefs: []
  type: TYPE_NORMAL
- en: TypeOf and ValueOf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use reflection, you will need to get familiar with two types defined in
    the `reflect` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Both of these types provide utility functions that give you access to the dynamic
    runtime information of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'These two functions give you a handle on the `Type` and `Value` of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following program uses the two functions to print the `Type` and `Value`
    of the object being passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program should print the `Type` of `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we observed how two functions are used to print the `Type`
    and `Value` of the object passed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to make sure that you use the reflection package carefully.
    Using the type conversion incorrectly or calling a method on an object that does
    not support the method will cause the program to panic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 19.01: Using Reflection'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will use the reflection package to inspect objects at
    runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `main.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the following packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `struct` called `circle` with the `radius` as one of its fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define another `struct` called `rectangle` with `length` and `breadth` as its
    fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a function called `area()` that can calculate the area of different
    shapes. It should take `interface` as its input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this function, we use `reflect.TypeOf()` to get a `reflect.Type` object from
    the input. We then use the `Type.Name()` function to get the name of the `struct`,
    which, in our case, could be either a circle or a rectangle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To retrieve the value of the fields in the struct, we first use the `reflect.ValueOf()`
    function to get a `reflect.Value` object. Then we use `Val.FieldByName()` to get
    the field value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a `main()` function and call the `area()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get the following output when you run the program:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we learned how to use reflection to define the different implementations
    of a function, in this case, by inspecting the input object to determine what
    object is being passed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 19.01: Defining Build Constraints Using Filenames'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have to define a function that behaves differently depending on the OS and
    CPU architecture. Use build constraints on a filename to achieve this behavior.
    One file should be set with the OS constraint set to `darwin` and another with
    the CPU architecture set to `386`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Substitute `darwin` with your current OS and `386` with another architecture
    that is not your current machine's architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a package called `custom`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `print_darwin.go` file and define a function called `Print()` inside
    the package. It should print the following text: `I am running on a darwin machine`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create another file in the same package called `print_386.go` and define a
    function called `Print()` that prints the following text: `Hello I am running
    on a 386 machine`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a `main()` function and import the `custom` package. Call the `Print()`
    function from the custom package in the `main()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By the end of the activity, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this activity, we implemented overriding a function using build constraints
    with filenames. You should be able to see a similar implementation in the Go standard
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 782.
  prefs: []
  type: TYPE_NORMAL
- en: DeepEqual
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `reflect.DeepEqual()` requires a mention if we are talking about the `reflect`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Basic data types in Go can be compared using the `==` or `!=` operator, but
    slices and maps are not comparable using this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `reflect.DeepEqual()` function can be used in scenarios when the types
    are incomparable. For example, it can be used for comparing slices and maps. Here
    is an example that compares maps and slices using `DeepEqual`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we compare different data types using `reflect.DeepEqual()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the comparisons done:'
  prefs: []
  type: TYPE_NORMAL
- en: Two nil objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two empty slices with the same size. The size is important here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two slices with the same data in the same order. Values in a different order
    will give a different output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two maps with the same data. The order of keys does not matter here as maps
    are always unordered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you run the program, you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.2: DeepEqual output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_19_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 19.2: DeepEqual output'
  prefs: []
  type: TYPE_NORMAL
- en: Wildcard Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `go` tool has a number of commands to help you with your code development.
    For example, the `go list` command helps you list Go files in your current directory,
    and the `go test` command helps you run test files in your current directory.
  prefs: []
  type: TYPE_NORMAL
- en: Your project may be structured in multiple subdirectories to help organize your
    code logically. If you wanted to use the `go` tool to run commands over your whole
    codebase at once, it supports a wildcard pattern that helps you do just that.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list all the `.go` files in your current directory and its subdirectories,
    you can use the following relative pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if you wanted to run all the tests in your current directory and
    subdirectories, the same pattern can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If you are still using vendor directories, the good thing is that this pattern
    will ignore the `./vendor` directories.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try the wildcard patterns on the Go workshop repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list all the `.go` files in the project, you can run the `list` command
    with the wildcard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 20.3: Wildcard pattern'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_19_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 19.3: Wildcard pattern'
  prefs: []
  type: TYPE_NORMAL
- en: The unsafe Package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go is a statically typed language, and it has its own runtime that does memory
    allocation and garbage collection. So, unlike C, all the work related to memory
    management is taken care of by the runtime. Unless you have some special requirements,
    you would never have to deal with memory directly in your code. When there is
    a requirement, though, the `unsafe` package in the standard library gives you
    features to let you peek into the memory of an object.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, it is normally not considered safe to use this package
    in your code. Another thing to note is that the `unsafe` package does not come
    with Go 1 compatibility guidelines, which means that functionalities could stop
    working in future versions of Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest example you can find of using the `unsafe` package can be found
    in the `math` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This takes a `float32` as input and returns `uint32`. The `float32` number is
    converted to an `unsafe.Pointer` object and then dereferenced to convert it to
    a `uint32`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reverse conversion on the preceding function can also be found in the `math`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Another example of using the `unsafe` package, which you can find in the standard
    library is when calling C programs from your Go code. This is formally known as
    `cgo`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To get `cgo` to work on Windows, you need to have the `gcc` compiler installed
    on your machine. You can use 'Minimalist GNU for Windows' ([https://packt.live/2EbOKuZ](https://packt.live/2EbOKuZ)).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some special functions provided in the pseudo C package that convert
    Go data types to C data or vice versa, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can write your program as normal Go code and call functions written in
    C, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can define functions in C in the following format. To use functions in
    the standard library, the `import` statement is preceded by a comment, which is
    treated as the header section of your C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function prints the input to the console. To be able to use the
    C code, we need to import the pseudo package called `C`. In the `main` function,
    we can call the `myprint()` function using the C package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this program should get you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 19.02: Using cgo with unsafe'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will learn how to use the `unsafe` package to get hold
    of the underlying memory of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `main.go` file and make the following imports. The C pseudo-package
    is needed to use the C libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a `main()` function and declare a `C` string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set the value of the `cString` variable with the text `Hello World!\n`. It
    is always a good practice to clean up allocated memory when dealing with `C`,
    so add the `C.free()` function call to perform the cleanup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare a variable, `b`, as a byte array to store the output of converting
    the `CString` into a Go `byte` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `C.GoBytes()` function converts an `unsafe`.`Pointer` object into a Go `byte`
    array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Print the `byte` array to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the program using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we learned how to use `Cgo` and create C objects in Go. We
    then used the `unsafe` package to convert a `CString` object into an `unsafe.Pointer`,
    which maps directly to the memory of the `CString`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 19.02: Using Wildcard with Go Test'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a project with multiple test files and multiple test cases defined
    inside them. Create multiple packages and define tests inside them. Using the
    wildcard pattern, run all test cases in the project with a single command. Make
    sure that all the unit tests are being run using the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a package called `package1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `run_test.go` and define a unit test called `TestPackage1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a package called `package2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a file called `run_test.go` and define a unit test called `TestPackage2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Print the results of `TestPackage1` and `TestPackage2` using the wildcard pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 20.4: Recursive test with wildcard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14177_19_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 19.4: Recursive test with wildcard'
  prefs: []
  type: TYPE_NORMAL
- en: In this activity, we have learned how to use the wildcard pattern to recursively
    run tests on all test files inside a project. This will come in handy when you
    want to automate running tests in your continuous integration pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 782.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the special features in Go that are not so
    obvious.
  prefs: []
  type: TYPE_NORMAL
- en: We covered the use of build constraints and how they can be used to control
    the behavior of your application build. Build constraints can be used to perform
    conditional compilation using the `GOOS` and `GOARCH` variables. They can also
    be used to ignore a file during compilation. Another common use of `build` tags
    is to add tags to files that contain integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen use cases for the `reflect` package and the functions that can
    be used to access the type and value of objects at runtime. Reflection is a good
    way to solve scenarios where we can only determine the data type of a variable
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: We also demonstrated how wildcards can be used to perform lists and tests on
    multiple packages in your project. We also learned the use of the `unsafe` package
    to access runtime memory in Go. The `unsafe` package is commonly used when using
    C libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of the book, we have covered the basics of Go with variables
    and various type declarations. We have seen the special behavior of interfaces
    and errors in Go. The book also covered chapters focused on application development.
    Handling files and JSON data is very common in any application's development,
    especially web applications. The chapters on databases and HTTP servers delve
    into how you can manage the communication and storage of data. We also looked
    at how to easily perform concurrent operations using goroutines. Finally, in the
    last topic of the book, we covered how to improve your code quality by focusing
    on testing and securing your application. Last but not least, we explored special
    features in Go such as build constraints and the use of the `unsafe` package.
  prefs: []
  type: TYPE_NORMAL
