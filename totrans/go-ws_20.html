<html><head></head><body>
		<div>
			<div id="_idContainer333" class="Content">
			</div>
		</div>
		<div id="_idContainer334" class="Content">
			<h1 id="_idParaDest-455"><a id="_idTextAnchor534"/>Appendix</h1>
		</div>
		<div id="_idContainer374" class="Content">
			<h2>About</h2>
			<p>This section is included to assist the students to perform the activities present in the book. It includes detailed steps that are to be performed by the students to complete and achieve the objectives of the book.</p>
			<h1 id="_idParaDest-456"><a id="_idTextAnchor535"/>Chapter 1: Variables and Operators</h1>
			<h2 id="_idParaDest-457"><a id="_idTextAnchor536"/>Activity 1.01 Defining and Printing</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li>Define the package name:<p class="source-code">package main</p></li>
				<li> Import the required packages:<p class="source-code">import "fmt"</p></li>
				<li> Create a <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Declare and initialize a string variable for the given name:<p class="source-code">  firstName := "Bob"</p></li>
				<li>Declare and initialize a string variable for the family name:<p class="source-code">  familyName := "Smith" </p></li>
				<li>Declare and initialize an <strong class="source-inline">int</strong> variable for <strong class="source-inline">age</strong>:<p class="source-code">  age := 34 </p></li>
				<li>Declare and initialize a <strong class="source-inline">bool</strong> variable for <strong class="source-inline">peanutAllergy</strong>:<p class="source-code">  peanutAllergy := false</p></li>
				<li> Print each variable to the console:<p class="source-code">  fmt.Println(firstName)</p><p class="source-code">  fmt.Println(familyName)</p><p class="source-code">  fmt.Println(age)</p><p class="source-code">  fmt.Println(pean</p><p class="source-code">utAllergy)</p></li>
				<li>Close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p><p>The following is the expected output:</p></li>
			</ol>
			<div>
				<div id="_idContainer335" class="IMG---Figure">
					<img src="image/B14177_01_24.jpg" alt="Figure 1.24: Expected output after assigning the variables&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.24: Expected output after assigning the variables</p>
			<h2 id="_idParaDest-458"><a id="_idTextAnchor537"/>Activity 1.02: Pointer Value Swap</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Let's start the exercise with the following code:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">func main() {</p><p class="source-code">  a, b := 5, 10</p></li>
				<li>You need to get the pointers from <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> to pass to swap using <strong class="source-inline">&amp;</strong>:<p class="source-code">  swap(&amp;a, &amp;b)</p><p class="source-code">  fmt.Println(a == 10, b == 5)</p><p class="source-code">}</p><p class="source-code">func swap(a *int, b *int) {</p></li>
				<li>You need to dereference the values first using <strong class="source-inline">*</strong>. You can swap without temporary values by using Go's ability to do multiple assignments. The right-hand side resolves before the left-hand side does:<p class="source-code">  *a, *b = *b, *a</p><p class="source-code">}</p><p>The following is the expected output:</p><p class="source-code">true true</p></li>
			</ol>
			<h2 id="_idParaDest-459"><a id="_idTextAnchor538"/>Activity 1.03: Message Bug</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create <strong class="source-inline">package</strong> <strong class="source-inline">main</strong> and add the necessary imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">func main() {</p><p class="source-code">  count := 5</p></li>
				<li>Define the <strong class="source-inline">message</strong> before the <strong class="source-inline">if</strong> statement:<p class="source-code">  var message string</p><p class="source-code">  if count &gt; 5 {</p></li>
				<li>Define a <strong class="source-inline">message</strong> that would update the <strong class="source-inline">message</strong> in step 2:<p class="source-code">  message = "Greater than 5"</p><p class="source-code">  } else {</p></li>
				<li>Define a <strong class="source-inline">message</strong> that would update the message in step 3:<p class="source-code">  message = "Not greater than 5"</p><p class="source-code">  }</p><p class="source-code">  fmt.Println(message)</p><p class="source-code">}</p><p>The following is the expected output:</p><p class="source-code">Not greater than 5</p></li>
			</ol>
			<h2 id="_idParaDest-460"><a id="_idTextAnchor539"/>Activity 1.04: Bad Count Bug</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Let's start the exercise with the following code:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">func main() {</p><p class="source-code">  count := 0</p><p class="source-code">  if count &lt; 5 {</p></li>
				<li>The assignment here caused the preceding <strong class="source-inline">count</strong> to be shadowed:<p class="source-code">    count = 10</p><p class="source-code">    count++</p><p class="source-code">  }</p><p class="source-code">  fmt.Println(count == 11)</p><p class="source-code">}</p><p>The following is the expected output:</p><p class="source-code">true</p></li>
			</ol>
			<h1 id="_idParaDest-461"><a id="_idTextAnchor540"/>Chapter 2: Logic and Loops</h1>
			<h2 id="_idParaDest-462"><a id="_idTextAnchor541"/>Activity 2.01: Implementing FizzBuzz</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Define <strong class="source-inline">package</strong> and include <strong class="source-inline">import</strong>:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "strconv"</p><p class="source-code">)</p></li>
				<li>Create the <strong class="source-inline">main</strong> function:<p class="source-code">func main() {</p></li>
				<li>Create a <strong class="source-inline">for</strong> <strong class="source-inline">i</strong> loop that starts at 1 and loops until <strong class="source-inline">i</strong> gets to 99:<p class="source-code">  for i := 1; i &lt;= 100; i++{</p></li>
				<li>Initialize a string variable that will hold the output:<p class="source-code">  out := ""</p></li>
				<li>Using module logic to check for divisibility, <strong class="source-inline">if</strong> <strong class="source-inline">i</strong> is divisible by 3, then add <strong class="source-inline">"Fizz"</strong> to the <strong class="source-inline">out</strong> string:<p class="source-code">  if i%3 == 0 {</p><p class="source-code">  out += "Fizz"</p><p class="source-code">  }</p></li>
				<li>If divisible by 5, add <strong class="source-inline">"Buzz"</strong> to the string:<p class="source-code">  if i%5 == 0 {</p><p class="source-code">  out += "Buzz"</p><p class="source-code">  }</p></li>
				<li>If neither, convert the number to a string and then add it to the output string:<p class="source-code">  if out == "" {</p><p class="source-code">  out = strconv.Itoa(i)</p><p class="source-code">  }</p></li>
				<li>Print the output variable:<p class="source-code">  fmt.Println(out)</p></li>
				<li>Close the loop and <strong class="source-inline">main</strong>:<p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>In the folder you create your code, run:<p class="source-code">go run main.go</p><p>The expected output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer336" class="IMG---Figure">
					<img src="image/B14177_02_03.jpg" alt="Figure 2.03: The FizzBuzz output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.03: The FizzBuzz output</p>
			<h2 id="_idParaDest-463"><a id="_idTextAnchor542"/>Activity 2.02: Looping Over Map Data Using range</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Load the <strong class="source-inline">main</strong> package:<p class="source-code">package main</p></li>
				<li>Import the <strong class="source-inline">fmt</strong> package:<p class="source-code">import "fmt"</p></li>
				<li>Create the <strong class="source-inline">main</strong> function:<p class="source-code">func main() {</p></li>
				<li>Initialize the <strong class="source-inline">words</strong> map:<p class="source-code">  words := map[string]int{</p><p class="source-code">    "Gonna": 3,</p><p class="source-code">    "You":   3,</p><p class="source-code">    "Give":  2,</p><p class="source-code">    "Never": 1,</p><p class="source-code">    "Up":    4,</p><p class="source-code">  }</p></li>
				<li>Initialize the <strong class="source-inline">topWord</strong> variable to an empty string and the <strong class="source-inline">topCount</strong> variable to 0:<p class="source-code">  topWord := ""</p><p class="source-code">  topCount := 0</p></li>
				<li>Create a <strong class="source-inline">for</strong> loop that uses <strong class="source-inline">range</strong> to get the key and value of each element:<p class="source-code">  for key, value := range words {</p></li>
				<li>Check whether the current <strong class="source-inline">map</strong> element has a larger count than the top count:<p class="source-code">    if value &gt; topCount {</p></li>
				<li>If it does, then update the top values with the values from the current element:<p class="source-code">      topCount = value</p><p class="source-code">      topWord = key</p></li>
				<li>Close the <strong class="source-inline">if</strong> statement:<p class="source-code">    }</p></li>
				<li>Close the loop:<p class="source-code">  }</p></li>
				<li>After the loop is done, you have your result. Print it to the console:<p class="source-code">  fmt.Println("Most popular word:", topWord)</p><p class="source-code">  fmt.Println("With a count of  :", topCount)</p><p class="source-code">}</p></li>
				<li>In the folder you created the code, run:<p class="source-code">go run main.go</p><p>The following is the expected output displaying the most popular word with its count value:</p><p class="source-code">Most popular word: Up</p><p class="source-code">With a count of  : 4</p></li>
			</ol>
			<h2 id="_idParaDest-464"><a id="_idTextAnchor543"/>Activity 2.03: Bubble Sort</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Define the package and add the imported package:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create <strong class="source-inline">main</strong>:<p class="source-code">func main() {</p></li>
				<li>Define a slice of integers and initialize it with unsorted numbers:<p class="source-code">  nums := []int{5, 8, 2, 4, 0, 1, 3, 7, 9, 6}</p></li>
				<li>Print the slice before sorting it:<p class="source-code">  fmt.Println("Before:", nums)</p></li>
				<li>Create a <strong class="source-inline">for</strong> loop; in the <strong class="source-inline">initial</strong> statement, define a Boolean with the initial value of <strong class="source-inline">true</strong>. In the condition, check that Boolean. Leave the <strong class="source-inline">post</strong> statement empty:<p class="source-code">  for swapped := true; swapped; {</p></li>
				<li>Set the Boolean variable to <strong class="source-inline">false</strong>:<p class="source-code">    swapped = false</p></li>
				<li>Create a nested <strong class="source-inline">for</strong> <strong class="source-inline">i</strong> loop that steps over the whole slice of <strong class="source-inline">int</strong> values. Start the loop from the second element:<p class="source-code">    for i := 1; i &lt; len(nums); i++ {</p></li>
				<li>Check whether the previous element is bigger than the current element:<p class="source-code">      if nums[i-1] &gt; nums[i] {</p></li>
				<li>If the previous element is bigger, swap the values of the elements:<p class="source-code">        nums[i], nums[i-1] = nums[i-1], nums[i]</p></li>
				<li>Set our Boolean to <strong class="source-inline">true</strong> to indicate that we did a swap and we'll need to keep going:<p class="source-code">        swapped = true</p></li>
				<li>Close the <strong class="source-inline">if</strong> statement and the two loops:<p class="source-code">      }</p><p class="source-code">    }</p><p class="source-code">  }</p></li>
				<li>Print the now sorted slice and close <strong class="source-inline">main</strong>:<p class="source-code">  fmt.Println("After :", nums)</p><p class="source-code">}</p></li>
				<li>In the folder you create the code, run:<p class="source-code">go run main.go</p><p>The following is the expected output:</p><p class="source-code">Before: [5, 8, 2, 4, 0, 1, 3, 7, 9, 6]</p><p class="source-code">After : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</p></li>
			</ol>
			<h1 id="_idParaDest-465"><a id="_idTextAnchor544"/>Chapter 3: Core Types</h1>
			<h2 id="_idParaDest-466"><a id="_idTextAnchor545"/>Activity 3.01: Sales Tax Calculator</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a new folder and add a <strong class="source-inline">main.go</strong> file.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the <strong class="source-inline">main</strong> package name to the top of the file:<p class="source-code">package main</p></li>
				<li>Now add the imports we'll use in this file:<p class="source-code">import "fmt"</p></li>
				<li>Create a function that takes two floating-point arguments and returns a floating-point:<p class="source-code">func salesTax(cost float64, taxRate float64) float64 {</p></li>
				<li>Multiply the two arguments together and return the result:<p class="source-code">  return cost * taxRate</p></li>
				<li>Close the function:<p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Declare a variable to be a floating-point:<p class="source-code">  taxTotal := .0</p></li>
				<li>Add <strong class="source-inline">cake</strong> to the <strong class="source-inline">taxTotal</strong>:<p class="source-code">  // Cake</p><p class="source-code">  taxTotal += salesTax(.99, .075)</p></li>
				<li>Add <strong class="source-inline">milk</strong> to the <strong class="source-inline">taxTotal</strong>:<p class="source-code">  // Milk</p><p class="source-code">  taxTotal += salesTax(2.75, .015)</p></li>
				<li>Add <strong class="source-inline">butter</strong> to the <strong class="source-inline">taxTotal</strong>:<p class="source-code">  // Butter</p><p class="source-code">  taxTotal += salesTax(.87, .02)</p></li>
				<li>Print the <strong class="source-inline">taxTotal</strong> to the console:<p class="source-code">  // Total</p><p class="source-code">  fmt.Println("Sales Tax Total: ", taxTotal)</p></li>
				<li>Close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p></li>
				<li>Save the file, and from within the folder you created run the following:<p class="source-code">go run main.go</p><p>Running the preceding code shows the following output:</p><p class="source-code">Sales Tax Total: 0.1329</p></li>
			</ol>
			<h2 id="_idParaDest-467"><a id="_idTextAnchor546"/>Activity 3.02: Loan Calculator</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Define the package:<p class="source-code">package main</p></li>
				<li>Import the necessary packages:<p class="source-code">import (</p><p class="source-code">  "errors"</p><p class="source-code">  "fmt"</p><p class="source-code">)</p></li>
				<li>Define constants for the scores and ratios:<p class="source-code">const (</p><p class="source-code">  goodScore      = 450</p><p class="source-code">  lowScoreRatio  = 10</p><p class="source-code">  goodScoreRatio = 20</p><p class="source-code">)</p></li>
				<li>Pre-define the errors:<p class="source-code">var (</p><p class="source-code">  ErrCreditScore = errors.New("invalid credit score")</p><p class="source-code">  ErrIncome      = errors.New("income invalid")</p><p class="source-code">  ErrLoanAmount  = errors.New("loan amount invalid")</p><p class="source-code">  ErrLoanTerm    = errors.New("loan term not a multiple of 12")</p><p class="source-code">)</p></li>
				<li>Create a function to check the loan details. This function will accept a <strong class="source-inline">creditScore</strong>, an <strong class="source-inline">income</strong>, a <strong class="source-inline">loanAmount</strong>, and a <strong class="source-inline">loanTerm</strong>, and return an error:<p class="source-code">func checkLoan(creditScore int, income float64, loanAmount float64, loanTerm   float64) error {</p></li>
				<li>Set a base <strong class="source-inline">interest</strong> rate:<p class="source-code">  interest := 20.0</p></li>
				<li>A good <strong class="source-inline">creditScore</strong> gets a better rate:<p class="source-code">  if creditScore &gt;= goodScore {</p><p class="source-code">    interest = 15.0</p><p class="source-code">  }</p></li>
				<li>Validate the <strong class="source-inline">creditScore</strong> and return an error if it's bad:<p class="source-code">  if creditScore &lt; 1 {</p><p class="source-code">    return ErrCreditScore</p><p class="source-code">  }</p></li>
				<li>Validate the <strong class="source-inline">income</strong> and return an error if it's bad:<p class="source-code">  if income &lt; 1 {</p><p class="source-code">    return ErrIncome</p><p class="source-code">  }</p></li>
				<li>Validate the <strong class="source-inline">loanAmount</strong> and return an error if it's bad:<p class="source-code">  if loanAmount &lt; 1 {</p><p class="source-code">    return ErrLoanAmount</p><p class="source-code">  }</p></li>
				<li>Validate the <strong class="source-inline">loanTerm</strong> and return an error if it's bad:<p class="source-code">  if loanTerm &lt; 1 || int(loanTerm)%12 != 0 {</p><p class="source-code">    return ErrLoanTerm</p><p class="source-code">  }</p></li>
				<li>Convert the interest rate into something we can use in calculations:<p class="source-code">  rate := interest / 100</p></li>
				<li>Calculate the payment by multiplying the <strong class="source-inline">loanAmount</strong> by the loan <strong class="source-inline">rate</strong>. Then divide that by the <strong class="source-inline">loanTerm</strong>. Now divide the <strong class="source-inline">loanAmount</strong> by the <strong class="source-inline">loanTerm</strong>.<p>Finally, add those two amounts together:</p><p class="source-code">  payment := ((loanAmount * rate) / loanTerm) + (loanAmount / loanTerm)</p></li>
				<li>Calculate the total cost of the loan by multiplying the payments by the <strong class="source-inline">loanTerm</strong> and then subtracting the <strong class="source-inline">loanAmount</strong>:<p class="source-code">  totalInterest := (payment * loanTerm) - loanAmount</p></li>
				<li>Declare a variable for <strong class="source-inline">approval</strong>:<p class="source-code">  approved := false</p></li>
				<li>Add a condition to check that the income is more than the payment:<p class="source-code">  if income &gt; payment {</p></li>
				<li>Calculate the percentage of their <strong class="source-inline">income</strong> that will be taken up by the payment:<p class="source-code">    ratio := (payment / income) * 100</p></li>
				<li>If they have a good <strong class="source-inline">creditScore</strong>, allow a higher ratio:<p class="source-code">    if creditScore &gt;= goodScore &amp;&amp; ratio &lt; goodScoreRation {</p><p class="source-code">      approved = true</p><p class="source-code">    } else if ratio &lt; lowScoreRation {</p><p class="source-code">      approved = true</p><p class="source-code">    }</p><p class="source-code">  }</p></li>
				<li>Print out all the details of the application to the console:<p class="source-code">  fmt.Println("Credit Score    :", creditScore)</p><p class="source-code">  fmt.Println("Income          :", income)</p><p class="source-code">  fmt.Println("Loan Amount     :", loanAmount)</p><p class="source-code">  fmt.Println("Loan Term       :", loanTerm)</p><p class="source-code">  fmt.Println("Monthly Payment :", payment)</p><p class="source-code">  fmt.Println("Rate            :", interest)</p><p class="source-code">  fmt.Println("Total Cost      :", totalInterest)</p><p class="source-code">  fmt.Println("Approved        :", approved)</p><p class="source-code">  fmt.Println("")</p></li>
				<li>Return with no error and close the function:<p class="source-code">  return nil</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Create an example that will be approved:<p class="source-code">  // Approved</p><p class="source-code">  fmt.Println("Applicant 1")</p><p class="source-code">  fmt.Println("-----------")</p><p class="source-code">  err := checkLoan(500, 1000, 1000, 24)</p></li>
				<li>Print out any errors, if found:<p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println("Error:", err)</p><p class="source-code">    return</p><p class="source-code">  }</p></li>
				<li>Create an example that will be denied:<p class="source-code">  // Denied</p><p class="source-code">  fmt.Println("Applicant 2")</p><p class="source-code">  fmt.Println("-----------")</p><p class="source-code">  err = checkLoan(350, 1000, 10000, 12)</p></li>
				<li>Print out any errors, if found:<p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println("Error:", err)</p><p class="source-code">    return</p><p class="source-code">  }</p></li>
				<li>Close the <strong class="source-inline">main()</strong> function:<p class="source-code">}</p></li>
				<li>In the folder you wrote the code in, run the following:<p class="source-code">go run main.go</p><p>Following is the expected output:</p></li>
			</ol>
			<div>
				<div id="_idContainer337" class="IMG---Figure">
					<img src="image/B14177_03_15.jpg" alt="Figure 3.15: Output of loan calculator&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15: Output of loan calculator</p>
			<h1 id="_idParaDest-468"><a id="_idTextAnchor547"/>Chapter 4: Complex Types</h1>
			<h2 id="_idParaDest-469"><a id="_idTextAnchor548"/>Activity 4.01: Filling an Array</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create a function that returns an array:<p class="source-code">func getArr() [10]int {</p></li>
				<li>Define an array variable:<p class="source-code">  var arr [10]int</p></li>
				<li>Use a <strong class="source-inline">for i</strong> loop to operate on each element of the array:<p class="source-code">  for i := 0; i &lt; 10; i++ {</p></li>
				<li>Use <strong class="source-inline">i</strong>, plus a bit of math, to set the correct value:<p class="source-code">  arr[i] = i + 1</p><p class="source-code">  }</p></li>
				<li>Return the array variable and close the function:<p class="source-code">  return arr</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, call the function and print the returned value to the console:<p class="source-code">func main() {</p><p class="source-code">  fmt.Println(getArr())</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run .</p><p>Running the preceding code will produce the following output:</p><p class="source-code">[1 2 3 4 5 6 7 8 9 10]</p></li>
			</ol>
			<h2 id="_idParaDest-470"><a id="_idTextAnchor549"/>Activity 4.02: Printing a User's Name Based on User Input</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "os"</p><p class="source-code">)</p></li>
				<li>Define the <strong class="source-inline">map</strong> of user data:<p class="source-code">var users = map[string]string{</p><p class="source-code">  "305": "Sue",</p><p class="source-code">  "204": "Bob",</p><p class="source-code">  "631": "Jake",</p><p class="source-code">  "073": "Tracy",</p><p class="source-code">}</p></li>
				<li>Create a function that returns the user's name and whether it exists:<p class="source-code">func getName(id string) (string, bool) {</p><p class="source-code">  name, exists := users[id]</p><p class="source-code">  return name, exists</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">main()</strong> function, check the passed arguments. Call the function, print if there's an error, and exit if the user doesn't exist. Print a greeting to the user if they do exist:<p class="source-code">func main() {</p><p class="source-code">  if len(os.Args) &lt; 2 {</p><p class="source-code">    fmt.Println("User ID not passed")</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p><p class="source-code">  name, exists := getName(os.Args[1])</p><p class="source-code">  if !exists {</p><p class="source-code">    fmt.Printf("error: user (%v) not found", os.Args[1])</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p><p class="source-code">  fmt.Println("Hi,", name)</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p><p class="source-code">Hi, Tracy</p></li>
			</ol>
			<h2 id="_idParaDest-471"><a id="_idTextAnchor550"/>Activity 4.03: Creating a Locale Checker</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "os"</p><p class="source-code">  "strings"</p><p class="source-code">)</p></li>
				<li>Define a <strong class="source-inline">locale</strong> <strong class="source-inline">struct</strong> with a <strong class="source-inline">language</strong> and a <strong class="source-inline">territory</strong>, both of which will be strings:<p class="source-code">type locale struct {</p><p class="source-code">  language string</p><p class="source-code">  territory string</p><p class="source-code">}</p></li>
				<li>Create a function that returns the test data:<p class="source-code">func getLocales() map[locale]struct{} {</p><p class="source-code">  supportedLocales := make(map[locale]struct{}, 5)</p><p class="source-code">  supportedLocales[locale{"en", "US"}] = struct{}{}</p><p class="source-code">  supportedLocales[locale{"en", "CN"}] = struct{}{}</p><p class="source-code">  supportedLocales[locale{"fr", "CN"}] = struct{}{}</p><p class="source-code">  supportedLocales[locale{"fr", "FR"}] = struct{}{}</p><p class="source-code">  supportedLocales[locale{"ru", "RU"}] = struct{}{}</p><p class="source-code">  return supportedLocales</p><p class="source-code">}</p></li>
				<li>Create a function that uses a passed local struct to check the sample data to see if a locale exists:<p class="source-code">func localeExists(l locale) bool {</p><p class="source-code">  _, exists := getLocales()[l]</p><p class="source-code">  return exists</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Check that an argument has been passed:<p class="source-code">  if len(os.Args) &lt; 2 {</p><p class="source-code">    fmt.Println("No locale passed")</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>Process the passed argument to make sure it's in a valid format:<p class="source-code">  localeParts := strings.Split(os.Args[1], "_")</p><p class="source-code">  if len(localeParts) != 2 {</p><p class="source-code">    fmt.Printf("Invalid locale passed: %v\n", os.Args[1])</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>Create a local struct value using the passed argument data:<p class="source-code">  passedLocale := locale{</p><p class="source-code">    territory: localeParts[1],</p><p class="source-code">    language:  localeParts[0],</p><p class="source-code">  }</p></li>
				<li>Call the function and print an error message if it doesn't exist; otherwise, print that the locale is supported:<p class="source-code">  if !localeExists(passedLocale) {</p><p class="source-code">    fmt.Printf("Locale not supported: %v\n", os.Args[1])</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p><p class="source-code">  fmt.Println("Locale passed is supported")</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer338" class="IMG---Figure">
					<img src="image/B14177_04_17.jpg" alt="Figure 4.17: Locale checking result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.17: Locale checking result</p>
			<h2 id="_idParaDest-472"><a id="_idTextAnchor551"/>Activity 4.04: Slicing the Week</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create a function that returns a slice of strings:<p class="source-code">func getWeek() []string {</p></li>
				<li>Define a slice and initialize it with the days of the week, starting on Monday:<p class="source-code">  week := []string{"Monday", "Tuesday", "Wednesday", "Thursday", "Friday",     "Saturday", "Sunday"}</p></li>
				<li>Create a range that starts at index 6 and goes to the end of the slice. Then, create a slice range that starts at the beginning of the slice and goes up to index 6. Use <strong class="source-inline">append</strong> to add the second range to the first range. Capture the value from append:<p class="source-code">  week = append(week[6:], week[:6]...)</p></li>
				<li>Return the result and close the function:<p class="source-code">  return week</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">main</strong>, call the function and print the result to the console:<p class="source-code">func main() {</p><p class="source-code">  fmt.Println(getWeek())</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run .</p><p>Running the preceding code produces the following output:</p><p class="source-code">[Sunday Monday Tuesday Wednesday Thursday Friday Saturday]</p></li>
			</ol>
			<h2 id="_idParaDest-473"><a id="_idTextAnchor552"/>Activity 4.05: Removing an Element from a Slice</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a new folder and add a file named <strong class="source-inline">main.go</strong> to it.</li>
				<li>In <strong class="source-inline">main.go</strong>, add the package and imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create a function that returns a slice of strings:<p class="source-code">func removeBad() []string {</p></li>
				<li>Define a slice of strings with the <strong class="source-inline">Good</strong> and <strong class="source-inline">Bad</strong> data:<p class="source-code">  sli := []string{"Good", "Good", "Bad", "Good", "Good"}</p></li>
				<li>Create a slice range from the beginning of the slice up until the <strong class="source-inline">Bad</strong> index. Create another slice range that starts from one index after the <strong class="source-inline">Bad</strong> data and goes until the end of the slice. Append the second slice to the first and capture the result:<p class="source-code">  sli = append(sli[:2], sli[3:]...)</p></li>
				<li>Return the slice and close the function:<p class="source-code">  return sli</p><p class="source-code">}</p></li>
				<li>In <strong class="source-inline">main</strong>, call the function and print the result to the console:<p class="source-code">func main() {</p><p class="source-code">  fmt.Println(removeBad())</p><p class="source-code">}</p></li>
				<li>Save the file. Then, in the folder you created in <em class="italic">step 1</em>, run the code using the following command:<p class="source-code">go run .</p><p>The expected output is as follows:</p><p class="source-code">[Good Good Good Good]</p></li>
			</ol>
			<h2 id="_idParaDest-474"><a id="_idTextAnchor553"/>Activity 4.06: Type Checker</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Define the package:<p class="source-code">package main</p></li>
				<li>Import the required libraries:<p class="source-code">import "fmt"</p></li>
				<li>Create a function that returns a slice of <strong class="source-inline">interface{}</strong>  values. This will hold our example values:<p class="source-code">func getData() []interface{} {</p><p class="source-code">  return []interface{}{</p><p class="source-code">    1,</p><p class="source-code">    3.14,</p><p class="source-code">    "hello",</p><p class="source-code">    true,</p><p class="source-code">    struct{}{},</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Create a function that accepts a single <strong class="source-inline">interface{}</strong> value and returns a <strong class="source-inline">string</strong>:<p class="source-code">func getTypeName(v interface{}) string {</p></li>
				<li>Use a type <strong class="source-inline">switch</strong>:<p class="source-code">  switch v.(type) {</p></li>
				<li>Add a <strong class="source-inline">case</strong> for all <strong class="source-inline">int</strong> types:<p class="source-code">  case int, int32, int64:</p></li>
				<li>Return a string that represents them:<p class="source-code">    return "int"</p></li>
				<li>Add a <strong class="source-inline">case</strong> for the floats and return a string for them:<p class="source-code">  case float64, float32:</p><p class="source-code">    return "float"</p></li>
				<li>Add a <strong class="source-inline">case</strong> for the Boolean type and return a string for it:<p class="source-code">  case bool:</p><p class="source-code">    return "bool"</p></li>
				<li>Then, add a case for strings:<p class="source-code">  case string:</p><p class="source-code">    return "string"</p></li>
				<li>Add a default case that says you don't know the type:<p class="source-code">  default:</p><p class="source-code">    return "unknown"</p></li>
				<li>Close the <strong class="source-inline">switch</strong> statement and the function:<p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p></li>
				<li>Get the example data and assign it to a variable:<p class="source-code">  data := getData()</p></li>
				<li>Use a <strong class="source-inline">for i</strong> loop to step over the example values one by one:<p class="source-code">  for i := 0; i &lt; len(data); i++ {</p></li>
				<li>Pass each example value to the preceding function and print the result to the console:<p class="source-code">    fmt.Printf("%v is %v\n", data[i], getTypeName(data[i]))</p></li>
				<li>Close the loop and the function:<p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>In the folder you created the code in, run the following command:<p class="source-code">go run .</p><p>Running the preceding code will produce the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer339" class="IMG---Figure">
					<img src="image/B14177_04_18.jpg" alt="Figure 4.18: Output displaying types&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.18: Output displaying types</p>
			<h1 id="_idParaDest-475"><a id="_idTextAnchor554"/>Chapter 5: Functions</h1>
			<h2 id="_idParaDest-476"><a id="_idTextAnchor555"/>Activity 5.01: Calculating the Working Hours of Employees</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>All directories and files should be created inside your <strong class="source-inline">$GOPATH</strong>:</p>
			<ol>
				<li value="1">Create a directory called <strong class="source-inline">Activity5.01</strong>.</li>
				<li>Create a file called <strong class="source-inline">main.go</strong> inside <strong class="source-inline">Activity5.01</strong>.</li>
				<li>Inside <strong class="source-inline">Activity5.01/main.go</strong>, declare the <strong class="source-inline">main</strong> package and its imports:<p class="source-code">package main</p><p class="source-code">import "fmt"</p></li>
				<li>Create a <strong class="source-inline">Developer</strong> type. Notice the <strong class="source-inline">WorkWeek</strong> is an array of <strong class="source-inline">7</strong>. This is because the week consists of 7 days and we use an array to ensure the fixed size:<p class="source-code">type Developer struct {</p><p class="source-code">  Individual Employee</p><p class="source-code">  HourlyRate int</p><p class="source-code">  WorkWeek   [7]int</p><p class="source-code">}</p></li>
				<li>Create an <strong class="source-inline">Employee</strong> type:<p class="source-code">type Employee struct {</p><p class="source-code">  Id        int</p><p class="source-code">  FirstName string</p><p class="source-code">  LastName  string</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">Weekday</strong> of type <strong class="source-inline">int</strong>:<p class="source-code">type Weekday int</p></li>
				<li>Create a constant of type <strong class="source-inline">Weekday</strong>. This is an enumeration of the weekdays:<p class="source-code">const (</p><p class="source-code">  Sunday Weekday = iota //starts at zero</p><p class="source-code">  Monday</p><p class="source-code">  Tuesday</p><p class="source-code">  Wednesday</p><p class="source-code">  Thursday</p><p class="source-code">  Friday</p><p class="source-code">  Saturday</p><p class="source-code">)</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, include the following code; initialize <strong class="source-inline">Developer</strong> with the following details:<p class="source-code">func main() {</p><p class="source-code">  d := Developer{Individual:Employee{Id: 1, FirstName: "Tony", LastName:     "Stark"}, HourlyRate: 10}</p></li>
				<li>Next, call the <strong class="source-inline">LogHours</strong> method:<p class="source-code">  d.LogHours(Monday, 8)</p><p class="source-code">  d.LogHours(Tuesday, 10)</p></li>
				<li>Print out the workweek and the hours worked for the week:<p class="source-code">  fmt.Println("Hours worked on Monday:  " ,d.WorkWeek[Monday])</p><p class="source-code">  fmt.Println("Hours worked on Tuesday:  " ,d.WorkWeek[Tuesday])</p><p class="source-code">  fmt.Printf("Hours worked this week:  %d",d.HoursWorked())</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">LogHours</strong> method; it is a pointer receiver method. It takes as input a custom type called <strong class="source-inline">Weekday</strong> and an <strong class="source-inline">int</strong>. The method assigns the <strong class="source-inline">WorkWeek</strong> field to the day of the week for hours worked that day. <strong class="source-inline">WorkWeek</strong> is an array with a fixed size of <strong class="source-inline">7</strong>, because there are <strong class="source-inline">7</strong> days in a week:<p class="source-code">func (d *Developer) LogHours(day Weekday, hours int) {</p><p class="source-code">  d.WorkWeek[day] = hours</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">HoursWorked</strong> method that will return an <strong class="source-inline">int</strong>. The <strong class="source-inline">HoursWorked</strong> function ranges over <strong class="source-inline">WorkWeek</strong>, adding the hours for the day to <strong class="source-inline">total</strong>:<p class="source-code">func (d *Developer) HoursWorked() int {</p><p class="source-code">  total := 0</p><p class="source-code">  for _, v := range d.WorkWeek {</p><p class="source-code">    total += v</p><p class="source-code">  }</p><p class="source-code">  return total</p><p class="source-code">}</p><p>The following is the expected output:</p><p class="source-code">Hours worked on Monday:  8</p><p class="source-code">Hours worked on Tuesday:  10</p><p class="source-code">Hours worked this week:  18</p></li>
			</ol>
			<h2 id="_idParaDest-477"><a id="_idTextAnchor556"/>Activity 5.02: Calculating Payable Amount for Employees Based on Working Hours</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a directory called <strong class="source-inline">Activity5.02</strong>.</li>
				<li>Create a file called <strong class="source-inline">main.go()</strong> in the directory in step 1.</li>
				<li>Copy the following code following into <strong class="source-inline">Activity5.02/main.go</strong>. This is the same code from steps 3-7 of <em class="italic">Activity5.01,</em> <em class="italic">Calculating the Working Hours of Employees</em>; see those steps for a description of the code:<p class="source-code-heading">main.go</p><p class="source-code">3  type Developer struct {</p><p class="source-code">4    Individual Employee</p><p class="source-code">5    HourlyRate int</p><p class="source-code">6    WorkWeek   [7]int</p><p class="source-code">7  }</p><p class="source-code">8  type Employee struct {</p><p class="source-code">9    Id        int</p><p class="source-code">10   FirstName string</p><p class="source-code">11   LastName  string</p><p class="source-code">12 }</p><p class="source-code">13 type Weekday int</p><p class="source-code">14 const (</p><p class="source-code">15   Sunday Weekday = iota //starts at zero</p><p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/34NsT7T">https://packt.live/34NsT7T</a></p></li>
				<li>In the <strong class="source-inline">main()</strong> function, place the following code. Assign <strong class="source-inline">x</strong> to the return value of <strong class="source-inline">nonLoggedHours()</strong>. As you may recall, the return value is <strong class="source-inline">func(int)int</strong>. The following three prints pass a value to <strong class="source-inline">x</strong> <strong class="source-inline">func</strong>. Each time <strong class="source-inline">x</strong> <strong class="source-inline">func</strong> is called, it adds the value passed to the total:<p class="source-code">func main() {</p><p class="source-code">  d := Developer{Individual: Employee{Id: 1, FirstName: "Tony", LastName:     "Stark"}, HourlyRate: 10}</p><p class="source-code">  x := nonLoggedHours()</p><p class="source-code">  fmt.Println("Tracking hours worked thus far today: ", x(2))</p><p class="source-code">  fmt.Println("Tracking hours worked thus far today: ", x(3))</p><p class="source-code">  fmt.Println("Tracking hours worked thus far today: ", x(5))</p><p class="source-code">  fmt.Println()</p><p class="source-code">  d.LogHours(Monday, 8)</p><p class="source-code">  d.LogHours(Tuesday, 10)</p><p class="source-code">  d.LogHours(Wednesday, 10)</p><p class="source-code">  d.LogHours(Thursday, 10)</p><p class="source-code">  d.LogHours(Friday, 6)</p><p class="source-code">  d.LogHours(Saturday, 8)</p><p class="source-code">  d.PayDetails()</p><p class="source-code">}</p></li>
				<li> The <strong class="source-inline">LogHours</strong> and <strong class="source-inline">HoursWorked</strong> remain unchanged:<p class="source-code">func (d *Developer) LogHours(day Weekday, hours int) {</p><p class="source-code">  d.WorkWeek[day] = hours</p><p class="source-code">}</p><p class="source-code">func (d *Developer) HoursWorked() int {</p><p class="source-code">  total := 0</p><p class="source-code">  for _, v := range d.WorkWeek {</p><p class="source-code">    total += v</p><p class="source-code">  }</p><p class="source-code">  return total</p><p class="source-code">}</p></li>
				<li>Create a method called <strong class="source-inline">PayDay()</strong> that returns an <strong class="source-inline">int</strong> and a <strong class="source-inline">bool</strong>. The method evaluates whether <strong class="source-inline">HoursWorked</strong> is greater than <strong class="source-inline">40</strong>. If it is, then it calculates <strong class="source-inline">hoursOver</strong> as overtime pay. It returns the total pay and <strong class="source-inline">true</strong> if the pay includes overtime:<p class="source-code">func (d *Developer) PayDay() (int, bool) {</p><p class="source-code">  if d.HoursWorked() &gt; 40 {</p><p class="source-code">    hoursOver := d.HoursWorked() - 40</p><p class="source-code">    overTime := hoursOver * 2</p><p class="source-code">    regularPay := d.HoursWorked() * d.HourlyRate</p><p class="source-code">    return regularPay + overTime, true</p><p class="source-code">  }</p><p class="source-code">  return d.HoursWorked() * d.HourlyRate, false</p><p class="source-code">}</p></li>
				<li>Create a function called <strong class="source-inline">nonLoggedHours()</strong>. This is a function that has a return type of <strong class="source-inline">func(int)int</strong>. The function is a closure, it encloses the anonymous function. Each time the function is called, it adds the int that is passed into the running total and returns the total:<p class="source-code">func nonLoggedHours() func(int) int {</p><p class="source-code">  total := 0</p><p class="source-code">  return func(i int) int {</p><p class="source-code">    total += i</p><p class="source-code">    return total</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Create a method called <strong class="source-inline">PayDetails</strong>. Inside the <strong class="source-inline">PayDetails</strong> method, it iterates over <strong class="source-inline">d.WorkWeek</strong>. It assigns the <strong class="source-inline">i</strong> value to the index of the slice and <strong class="source-inline">v</strong> to the value stored in the slice. The <strong class="source-inline">i</strong> switch is the index of the slice; it represents the day of the week. The <strong class="source-inline">case</strong> statement evaluates <strong class="source-inline">i</strong> and based on the value, it prints the day and the hours for that day.</li>
				<li>The function also prints the hours worked for the week, the pay for the week, and if the pay was overtime pay.</li>
				<li>The first <strong class="source-inline">print</strong> statement prints out the hours worked.</li>
				<li><strong class="source-inline">pay</strong> and <strong class="source-inline">overtime</strong> get assigned the values returned from <strong class="source-inline">d.Payday()</strong>.</li>
				<li>The following <strong class="source-inline">pay</strong> statements print out the pay, whether it was overtime, and a blank line:</li>
			</ol>
			<p class="source-code-heading">main.go</p>
			<p class="source-code">64 func (d *Developer) PayDetails() {</p>
			<p class="source-code">65   for i, v := range d.WorkWeek {</p>
			<p class="source-code">66     switch i {</p>
			<p class="source-code">67     case 0:</p>
			<p class="source-code">68       fmt.Println("Sunday hours: ", v)</p>
			<p class="source-code">69     case 1:</p>
			<p class="source-code">70       fmt.Println("Monday hours: ", v)</p>
			<p class="source-code">71     case 2:</p>
			<p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/2QeUNEF">https://packt.live/2QeUNEF</a></p>
			<p>The results of this activity being run are as follows:</p>
			<div>
				<div id="_idContainer340" class="IMG---Figure">
					<img src="image/B14177_05_14.jpg" alt="Figure 5.14: Output for payable amount activity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14: Output for payable amount activity</p>
			<h1 id="_idParaDest-478"><a id="_idTextAnchor557"/>Chapter 6: Errors</h1>
			<h2 id="_idParaDest-479"><a id="_idTextAnchor558"/>Activity 6.01: Creating a Custom Error Message for a Banking Application</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a directory called <em class="italic">Activity6.01</em> inside your <strong class="source-inline">$GOPATH</strong>.</li>
				<li>Save a file inside of the directory created in <em class="italic">step 1</em> called <strong class="source-inline">main.go</strong>.</li>
				<li>Define <strong class="source-inline">package main</strong> and import two packages, <strong class="source-inline">errors</strong> and <strong class="source-inline">fmt</strong>:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  «errors»</p><p class="source-code">  «fmt»</p><p class="source-code">)</p></li>
				<li>Next, define our custom error that will return an error that displays <strong class="source-inline">"invalid last name"</strong>:<p class="source-code">var ErrInvalidLastName = errors.New("invalid last name")</p></li>
				<li>We need one more custom error that will return an error that displays <strong class="source-inline">"invalid routing number"</strong>:<p class="source-code">var ErrInvalidRoutingNum = errors.New("invalid routing number")</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, we will print each of the errors:<p class="source-code">func main() {</p><p class="source-code">  fmt.Println(ErrInvalidLastName)</p><p class="source-code">  fmt.Println(ErrInvalidRoutingNum)</p><p class="source-code">}</p></li>
				<li>At the command line, navigate to the directory created in <em class="italic">step 1</em>.</li>
				<li>At the command line, type the following:<p class="source-code">go build</p><p>The <strong class="source-inline">go build</strong> command will compile your program and create an executable named after the directory you created in <em class="italic">step 1</em>.</p></li>
				<li>Type the name of the file created in <em class="italic">step 8</em> and hit <em class="italic">Enter</em> to run the executable.<p>The expected output is as follows:</p></li>
			</ol>
			<p class="source-code">invalid last name</p>
			<p class="source-code">invalid routing number</p>
			<h2 id="_idParaDest-480"><a id="_idTextAnchor559"/>Activity 6.02: Validating a Bank Customer's Direct Deposit Submission</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a directory called <em class="italic">Activity6.02</em> inside <strong class="source-inline">$GOPATH</strong>.</li>
				<li>Save a file inside the directory created in <em class="italic">step 1</em> called <strong class="source-inline">main.go</strong>.</li>
				<li>Define <strong class="source-inline">package main</strong> and add the following imports for this application:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "errors"</p><p class="source-code">  "fmt"</p><p class="source-code">  "strings"</p><p class="source-code">)</p></li>
				<li>Define the struct and fields that are mentioned in the activity description:<p class="source-code">type directDeposit struct {</p><p class="source-code">  lastName      string</p><p class="source-code">  firstName     string</p><p class="source-code">  bankName      string</p><p class="source-code">  routingNumber int</p><p class="source-code">  accountNumber int</p><p class="source-code">}</p></li>
				<li>Define two errors that will be used by the <strong class="source-inline">directDeposit</strong> method later:<p class="source-code">var ErrInvalidLastName = errors.New("invalid last name")</p><p class="source-code">var ErrInvalidRoutingNum = errors.New("invalid routing number")</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, assign a variable of the <strong class="source-inline">directDeposit</strong> type and set its fields:<p class="source-code">func main() {</p><p class="source-code">  dd := directDeposit{</p><p class="source-code">    lastName:      "  ",</p><p class="source-code">    firstName:     "Abe",</p><p class="source-code">    bankName:      "XYZ Inc",</p><p class="source-code">    routingNumber: 17,</p><p class="source-code">    accountNumber: 1809,</p><p class="source-code">  }</p></li>
				<li>Assign a variable named <strong class="source-inline">err</strong> to the <strong class="source-inline">directDeposit</strong>, <strong class="source-inline">validateRoutingNumber</strong>, and <strong class="source-inline">validateLastName</strong> methods. If an error is returned, print the error:<p class="source-code">  err := dd.validateRoutingNumber()</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">  }</p><p class="source-code">  err = dd.validateLastName()</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">  }</p></li>
				<li>Call the <strong class="source-inline">report()</strong> method to print out the field's values:<p class="source-code">  dd.report()</p><p class="source-code">}</p></li>
				<li>Create a method that is used to check whether <strong class="source-inline">routingNumber</strong> is less than 100. If that condition is <strong class="source-inline">true</strong>, it will return the custom error, <strong class="source-inline">ErrInvalidRoutingNum</strong>, else it will return <strong class="source-inline">nil</strong>:<p class="source-code">func (dd *directDeposit) validateRoutingNumber() error {</p><p class="source-code">  if dd.routingNumber &lt; 100 {</p><p class="source-code">    return ErrInvalidRoutingNum</p><p class="source-code">  }</p><p class="source-code">  return nil</p><p class="source-code">}</p></li>
				<li>Now we are going to add the <strong class="source-inline">validateLastName</strong> method. This method removes all trailing spaces from <strong class="source-inline">lastName</strong> and checks to see whether the <strong class="source-inline">lastName</strong> length equals zero. If the <strong class="source-inline">lastName</strong> length equals zero, the method will return the error, <strong class="source-inline">ErrInvalidLasName</strong>. If <strong class="source-inline">lastName</strong> is not equal to zero, then it will return <strong class="source-inline">nil</strong>:<p class="source-code">func (dd *directDeposit) validateLastName() error {</p><p class="source-code">  dd.lastName = strings.TrimSpace(dd.lastName)</p><p class="source-code">  if len(dd.lastName) == 0 {</p><p class="source-code">    return ErrInvalidLastName</p><p class="source-code">  }</p><p class="source-code">  return nil</p><p class="source-code">}</p></li>
				<li>The next <strong class="source-inline">report()</strong> method will print each of the <strong class="source-inline">directDeposit</strong> field's values:<p class="source-code">func (dd *directDeposit) report() {</p><p class="source-code">  fmt.Println(strings.Repeat("*", 80))</p><p class="source-code">  fmt.Println("Last Name: ", dd.lastName)</p><p class="source-code">  fmt.Println("First Name: ", dd.firstName)</p><p class="source-code">  fmt.Println("Bank Name: ", dd.bankName)</p><p class="source-code">  fmt.Println("Routing Number: ", dd.routingNumber)</p><p class="source-code">  fmt.Println("Account Number: ", dd.accountNumber)</p><p class="source-code">}</p></li>
				<li>At the command line, navigate to the directory created in <em class="italic">step 1</em>.</li>
				<li>At the command line, type the following:<p class="source-code">go build</p><p>The <strong class="source-inline">go build</strong> command will compile your program and create an executable named after the directory you created in <em class="italic">step 1</em>.</p></li>
				<li>Type the name of the file created in <em class="italic">step 13</em> and hit <em class="italic">Enter</em> to run the executable.<p>The expected output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer341" class="IMG---Figure">
					<img src="image/B14177_06_14.jpg" alt="Figure 6.14: Validating a bank customer's direct deposit submission&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.14: Validating a bank customer's direct deposit submission</p>
			<h2 id="_idParaDest-481"><a id="_idTextAnchor560"/>Activity 6.03: Panic on Invalid Data Submission</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Navigate to the directory used in <em class="italic">step 1</em> of <em class="italic">Activity 6.02</em>, <em class="italic">Validating a Bank's Customers Direct Deposit Submission</em>.</li>
				<li>Change the return <strong class="source-inline">ErrInvalidRoutingNum</strong> to panic with <strong class="source-inline">ErrInvalidRoutingNum</strong> passed to the <strong class="source-inline">panic()</strong> function:<p class="source-code">func (dd *directDeposit) validateRoutingNumber() error {</p><p class="source-code">  if dd.routingNumber &lt; 100 {</p><p class="source-code">    panic(ErrInvalidRoutingNum)</p><p class="source-code">  }</p><p class="source-code">  return nil</p><p class="source-code">}</p></li>
				<li>At the command line, navigate to the directory used in <em class="italic">step 1</em>.</li>
				<li>At the command line, type the following:<p class="source-code">go build</p><p>The <strong class="source-inline">go build</strong> command will compile your program and create an executable named after the directory you used in <em class="italic">step 1</em>.</p></li>
				<li>Type the name of the file created in <em class="italic">step 4</em> and hit <em class="italic">Enter</em> to run the executable.<p>The expected output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer342" class="IMG---Figure">
					<img src="image/B14177_06_15.jpg" alt="Figure 6.15: Panic on invalid routing number&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.15: Panic on invalid routing number</p>
			<h2 id="_idParaDest-482"><a id="_idTextAnchor561"/>Activity 6.04: Preventing a Panic from Crashing the App</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Navigate to the directory used in <em class="italic">step 1</em> of <em class="italic">Activity 6.03</em>, <em class="italic">Panic on Invalid Data Submission</em>.</li>
				<li>Add a <strong class="source-inline">defer</strong> function to the <strong class="source-inline">validateRoutingNumber</strong> method.</li>
				<li>Inside the <strong class="source-inline">defer</strong> function, check for an error being returned from the <strong class="source-inline">recover()</strong> function.</li>
				<li>If there is an error, print the error from the <strong class="source-inline">recover()</strong> function.<p>The only change is adding a deferred function:</p><p class="source-code">func (dd *directDeposit) validateRoutingNumber() error {</p><p class="source-code">  <strong class="bold">defer func()</strong> {</p><p class="source-code">    if r:= recover(); r != nil {</p><p class="source-code">      fmt.Println(r)</p><p class="source-code">    }</p><p class="source-code">  }()</p><p class="source-code">  if dd.routingNumber &lt; 100 {</p><p class="source-code">    panic(ErrInvalidRoutingNum)</p><p class="source-code">  }</p><p class="source-code">  return nil</p><p class="source-code">}</p></li>
				<li>At the command line, navigate to the directory used in <em class="italic">step 1</em>.</li>
				<li>At the command line, type the following:<p class="source-code">go build</p><p>The <strong class="source-inline">go build</strong> command will compile your program and create an executable named after the directory you used in <em class="italic">step 1</em>.</p></li>
				<li>Type the name of the file created in <em class="italic">step 6</em> and hit <em class="italic">Enter</em> to run the executable.<p>The expected output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer343" class="IMG---Figure">
					<img src="image/B14177_06_16.jpg" alt="Figure 6.16: Recovering from panic on an invalid routing number&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.16: Recovering from panic on an invalid routing number</p>
			<h1 id="_idParaDest-483"><a id="_idTextAnchor562"/>Chapter 7: Interfaces</h1>
			<h2 id="_idParaDest-484"><a id="_idTextAnchor563"/>Activity 7.01: Calculating Pay and Performance Review</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a <strong class="source-inline">main.go</strong> file.</li>
				<li>Inside the <strong class="source-inline">main.go</strong> file, we have a <strong class="source-inline">main</strong> package and we need to import the <strong class="source-inline">errors</strong>, <strong class="source-inline">fmt</strong>, and <strong class="source-inline">os</strong> packages:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "errors"</p><p class="source-code">  "fmt"</p><p class="source-code">  "os"</p><p class="source-code">)</p></li>
				<li>Create the <strong class="source-inline">Employee</strong> struct as follows:<p class="source-code">type Employee struct {</p><p class="source-code">  Id        int</p><p class="source-code">  FirstName string</p><p class="source-code">  LastName  string</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">Developer</strong> struct. The <strong class="source-inline">Developer</strong> struct has the <strong class="source-inline">Employee</strong> struct embedded into it:<p class="source-code">type Developer struct {</p><p class="source-code">  Individual        Employee</p><p class="source-code">  HourlyRate        float64</p><p class="source-code">  HoursWorkedInYear float64</p><p class="source-code">  Review            map[string]interface{}</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">Manager</strong> struct; it will have the <strong class="source-inline">Employee</strong> struct embedded into it as well:  <p class="source-code">type Manager struct {</p><p class="source-code">  Individual     Employee</p><p class="source-code">  Salary         float64</p><p class="source-code">  CommissionRate float64</p><p class="source-code">}</p></li>
				<li>The <strong class="source-inline">Pay</strong> interface will be used by both the <strong class="source-inline">Manager</strong> and <strong class="source-inline">Developer</strong> types to calculate their pay:<p class="source-code">type Payer interface {</p><p class="source-code">  Pay() (string, float64)</p><p class="source-code">}</p></li>
				<li>Add a <strong class="source-inline">FullName()</strong> method to the <strong class="source-inline">Developer</strong> struct. This is used to concatenate the developer's <strong class="source-inline">FirstName</strong> and <strong class="source-inline">LastName</strong> and return it:<p class="source-code">func (d Developer) FullName() string {</p><p class="source-code">  fullName := d.Individual.FirstName + " " + d.Individual.LastName</p><p class="source-code">  return fullName</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">Pay()</strong> method for the developer that will implement the <strong class="source-inline">Payer</strong> interface.<p>The <strong class="source-inline">Developer</strong> struct satisfies the <strong class="source-inline">Payer</strong> interface by having a method called <strong class="source-inline">Pay</strong> that returns a string and a float64. The <strong class="source-inline">Developer Pay()</strong> method returns <strong class="source-inline">fullName</strong> of the developer and returns the year's pay by calculating <strong class="source-inline">Developer HourlRate * HoursWorkedInYear</strong>:</p><p class="source-code">func (d Developer) Pay() (string, float64) {</p><p class="source-code">  fullName := d.FullName()</p><p class="source-code">  return fullName, d.HourlyRate * d.HoursWorkedInYear</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">Pay()</strong> method for the <strong class="source-inline">Manager</strong> struct that will implement the <strong class="source-inline">Payer</strong> interface.</li>
				<li>The <strong class="source-inline">Manager</strong> struct satisfies the <strong class="source-inline">Payer{}</strong> interface by having a method called <strong class="source-inline">Pay()</strong> that returns a string and a <strong class="source-inline">float64</strong>. The <strong class="source-inline">Manager Pay</strong> method returns <strong class="source-inline">fullName</strong> of the <strong class="source-inline">Manager</strong> struct and returns the year's pay by calculating the <strong class="source-inline">Manager</strong> salary plus the <strong class="source-inline">Manager</strong> salary times the manager's <strong class="source-inline">CommissionRate</strong>:<p class="source-code">func (m Manager) Pay() (string, float64) {</p><p class="source-code">  fullName := m.Individual.FirstName + " " + m.Individual.LastName</p><p class="source-code">  return fullName, m.Salary + (m.Salary * m.CommissionRate)</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">payDetails()</strong> function, which accepts a <strong class="source-inline">Payer{}</strong> interface. It will call the <strong class="source-inline">Pay()</strong> method of the type that is passed in; the <strong class="source-inline">Pay()</strong> method is required for the <strong class="source-inline">Payer</strong> interface. Print <strong class="source-inline">fullName</strong> and <strong class="source-inline">yearPay</strong> that gets returned from the <strong class="source-inline">Pay()</strong> method:<p class="source-code">func payDetails(p Payer) {</p><p class="source-code">  fullName, yearPay := p.Pay()</p><p class="source-code">  fmt.Printf("%s got paid %.2f for the year\n", fullName, yearPay)</p><p class="source-code">}</p><p>The <strong class="source-inline">payDetails()</strong> function accepts a <strong class="source-inline">Payer{}</strong> interface. It then prints <strong class="source-inline">fullName</strong> and <strong class="source-inline">yearPay</strong>, which get returned from the <strong class="source-inline">Pay()</strong> method.</p></li>
				<li>Inside the <strong class="source-inline">main</strong> function, we need to create a <strong class="source-inline">Developer</strong> type and <strong class="source-inline">Manager</strong> type and set their field values:<p class="source-code">  d := Developer{Individual: Employee{Id: 1, FirstName: "Eric", LastName: "Davis"}, HourlyRate: 35, HoursWorkedInYear: 2400, Review: employeeReview}</p><p class="source-code">  m := Manager{Individual: Employee{Id: 2, FirstName: "Mr.", LastName: "Boss"}, Salary: 150000, CommissionRate: .07}</p></li>
				<li>Call <strong class="source-inline">payDetails()</strong> and pass the developer and manager as arguments. Since <strong class="source-inline">Developer</strong> and <strong class="source-inline">Manager</strong> both satisfy the <strong class="source-inline">Payer{}</strong> interface, we can pass them to the <strong class="source-inline">payDetails()</strong> function.<p>In the <strong class="source-inline">main</strong> function, we initialize <strong class="source-inline">d</strong> as a struct literal of <strong class="source-inline">Developer</strong> and <strong class="source-inline">m</strong> as a struct literal of <strong class="source-inline">Manager</strong>:</p><p class="source-code">  payDetails(d)</p><p class="source-code">  payDetails(m)</p></li>
				<li>We now need to create the data for the employee review for the developer. We will make a map with a key of string and an interface for the value. As you may recall, different managers can use a numeric value or a string value for the rating to be assigned to the category:<p class="source-code">  employeeReview := make(map[string]interface{})</p><p class="source-code">  employeeReview["WorkQuality"] = 5</p><p class="source-code">  employeeReview["TeamWork"] = 2</p><p class="source-code">  employeeReview["Communication"] = "Poor"</p><p class="source-code">  employeeReview["Problem-solving"] = 4</p><p class="source-code">  employeeReview["Dependability"] = "Unsatisfactory"</p></li>
				<li>For the review rating, we need to be able to convert the string rating for the category to an integer version of the category. We will create the <strong class="source-inline">convertReviewToInt()</strong> function to perform this conversion by using a <strong class="source-inline">switch case</strong> statement. The <strong class="source-inline">switch</strong> statement on the string looks at the different string versions of the rating and returns the integer version of the rating. If the string version of the rating is not found, the default clause is executed and returns an error:<p class="source-code">func convertReviewToInt(str string) (int, error) {</p><p class="source-code">  switch str {</p><p class="source-code">  case "Excellent":</p><p class="source-code">    return 5, nil</p><p class="source-code">  case "Good":</p><p class="source-code">    return 4, nil</p><p class="source-code">  case "Fair":</p><p class="source-code">    return 3, nil</p><p class="source-code">  case "Poor":</p><p class="source-code">    return 2, nil</p><p class="source-code">  case "Unsatisfactory":</p><p class="source-code">    return 1, nil</p><p class="source-code">  default:</p><p class="source-code">    return 0, errors.New("invalid rating: " + str)</p><p class="source-code">  }</p><p class="source-code">}</p><p>We need to create a function called <strong class="source-inline">OverallReview()</strong> that accepts an interface and returns an integer and an error.</p><p>Recall that our review process provides strings and integers for the rating; that is why this function accepts an interface so that we can evaluate either type.</p><p>We use the switch type code structure to determine the interface concrete type. The <strong class="source-inline">v</strong> variable gets assigned the concrete type of <strong class="source-inline">i</strong>.</p><p>The only valid types for the rating are <strong class="source-inline">int</strong> and a <strong class="source-inline">string</strong>. Anything else is considered invalid and causes the default statement to be executed. The default statement will return an error if the type is not found in the <strong class="source-inline">case</strong> statements.</p></li>
				<li>If the type is <strong class="source-inline">int</strong>, it will simply return it as an <strong class="source-inline">int</strong>. If the interface concrete type is a string, the code in the <strong class="source-inline">case</strong> <strong class="source-inline">string</strong> will execute. It will pass the string to the <strong class="source-inline">convertReviewToInt(v)</strong> function. This function, as explained earlier, will do a lookup of the string version of the rating and return the integer correspondent:<p class="source-code">func OverallReview(i interface{}) (int, error) {</p><p class="source-code">  switch v := i.(type) {</p><p class="source-code">  case int:</p><p class="source-code">    return v, nil</p><p class="source-code">  case string:</p><p class="source-code">    rating, err := convertReviewToInt(v)</p><p class="source-code">    if err != nil {</p><p class="source-code">      return 0, err</p><p class="source-code">    }</p><p class="source-code">    return rating, nil</p><p class="source-code">  default:</p><p class="source-code">    return 0, errors.New("unknown type")</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Next, create the <strong class="source-inline">ReviewRating()</strong> method to perform the calculation for the developer rating. The <strong class="source-inline">Developer</strong> <strong class="source-inline">ReviewRating()</strong> method performs the calculation for the <strong class="source-inline">Review</strong>. It loops over the <strong class="source-inline">d.Review</strong> field that is of the <strong class="source-inline">map[string]interface{}</strong> type. It passes each interface value to the <strong class="source-inline">OverallReview(v)</strong> function to get the integer value of the rating. Each loop iteration adds that rating to a total variable. It then calculates the average of the review and prints the results. Here are the results of the performance rating:<p class="source-code">func (d Developer) ReviewRating() error {</p><p class="source-code">  total := 0</p><p class="source-code">  for _, v := range d.Review {</p><p class="source-code">    rating, err := OverallReview(v)</p><p class="source-code">    if err != nil {</p><p class="source-code">      return err</p><p class="source-code">    }</p><p class="source-code">    total += rating</p><p class="source-code">  }</p><p class="source-code">  averageRating := float64(total) / float64(len(d.Review))</p><p class="source-code">  fmt.Printf("%s got a review rating of %.2f\n",d.FullName(),averageRating)</p><p class="source-code">  return nil</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, call <strong class="source-inline">ReviewRating()</strong> and print any errors:<p class="source-code">err := d.ReviewRating()</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>Next, call the <strong class="source-inline">payDetails()</strong> function for the <strong class="source-inline">Developer</strong> type and the <strong class="source-inline">Manager</strong> type:<p class="source-code">    payDetails(d)</p><p class="source-code">    payDetails(m)</p><p class="source-code">}</p></li>
				<li>Build the program by running <strong class="source-inline">go build</strong> at the command line:<p class="source-code">go build</p></li>
				<li>Run the program by typing in the name of the executable at the command line.<p>The expected output is as follows:</p></li>
			</ol>
			<p class="source-code">Eric Davis got a review rating of 2.80</p>
			<p class="source-code">Eric Davis got paid 84000.00 for the year</p>
			<p class="source-code">Mr. Boss got paid 160500.00 for the year</p>
			<h1 id="_idParaDest-485"><a id="_idTextAnchor564"/>Chapter 8: Packages</h1>
			<h2 id="_idParaDest-486"><a id="_idTextAnchor565"/>Activity 8.01: Creating a Function to Calculate Payroll and Performance Review</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>All directories and files should be created inside of <strong class="source-inline">$GOPATH</strong>:</p>
			<ol>
				<li value="1">Create a directory called <strong class="source-inline">Activity8.01</strong>.</li>
				<li>Create a directory called <strong class="source-inline">pay</strong> and <strong class="source-inline">payroll</strong> inside <strong class="source-inline">Activity8.01</strong>.</li>
				<li>Create a file called <strong class="source-inline">main.go</strong> inside <strong class="source-inline">Chapter08/Activity8.01/pay</strong>.</li>
				<li>Create the following files: <strong class="source-inline">developer.go</strong>, <strong class="source-inline">employee.go</strong>, and <strong class="source-inline">manager.go</strong> inside <strong class="source-inline">payroll</strong>.</li>
				<li>The directory structure and files should look similar to the following screenshot:<div id="_idContainer344" class="IMG---Figure"><img src="image/B14177_08_16.jpg" alt="Figure 8.16: Program directory structure&#13;&#10;"/></div><p class="figure-caption">Figure 8.16: Program directory structure</p></li>
				<li>Inside <strong class="source-inline">Chapter08/Activity8.01/payroll/developer.go</strong>, declare the package as <strong class="source-inline">payroll</strong>:<p class="source-code">package payroll</p><p class="source-code">import (</p><p class="source-code">  "errors"</p><p class="source-code">  "fmt"</p><p class="source-code">)</p></li>
				<li>The <strong class="source-inline">Developer</strong> type, and the following methods, <strong class="source-inline">Pay()</strong> and <strong class="source-inline">ReviewRating()</strong>, will all be exportable, so the first letter needs to be capitalized. This means that they are visible to other packages outside of <strong class="source-inline">payroll</strong>.</li>
				<li>From <a href="https://packt.live/2YNnfS6">https://packt.live/2YNnfS6</a>, move the code that relates to the developer type and methods to the <strong class="source-inline">Chapter08/Activity8.01/payroll/developer.go</strong> file. It should look like the following code snippet:<p class="source-code-heading">developer.go</p><p class="source-code">1  package payroll</p><p class="source-code">2  import (</p><p class="source-code">3    "errors"</p><p class="source-code">4    "fmt"</p><p class="source-code">5  )</p><p class="source-code">6  type Developer struct {</p><p class="source-code">7    Individual        Employee</p><p class="source-code">8    HourlyRate        float64</p><p class="source-code">9    HoursWorkedInYear float64</p><p class="source-code">10   Review            map[string]interface{}</p><p class="source-code">11 }</p><p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/34NTAtn">https://packt.live/34NTAtn</a></p></li>
				<li>Inside <strong class="source-inline">Chapter08/Activity8.01/payroll/employee.go</strong>, declare the package as <strong class="source-inline">payroll</strong>:<p class="source-code">package payroll</p><p class="source-code">import "fmt"</p></li>
				<li>The <strong class="source-inline">Employee</strong> type, <strong class="source-inline">Payer</strong> interface, and its methods will all be exportable, so the first letter needs to be capitalized. This means that they are visible to other packages outside of <strong class="source-inline">payroll</strong>.</li>
				<li>From <a href="https://packt.live/2YNnfS6">https://packt.live/2YNnfS6</a>, move the code that relates to the employee type and methods to <strong class="source-inline">Chapter08/Activity8.01/payroll/employee.go file</strong>. It should look like the following code snippet:<p class="source-code">package payroll</p><p class="source-code">import "fmt"</p><p class="source-code">type Payer interface {</p><p class="source-code">  Pay() (string, float64)</p><p class="source-code">}</p><p class="source-code">type Employee struct {</p><p class="source-code">  Id        int</p><p class="source-code">  FirstName string</p><p class="source-code">  LastName  string</p><p class="source-code">}</p><p class="source-code">func PayDetails(p Payer) {</p><p class="source-code">  fullName, yearPay := p.Pay()</p><p class="source-code">  fmt.Printf("%s got paid %.2f for the year\n", fullName, yearPay)</p><p class="source-code">}</p></li>
				<li>Inside <strong class="source-inline">Chapter08/Activity8.01/payroll/manager.go</strong>, declare <strong class="source-inline">package</strong> as <strong class="source-inline">payroll</strong>:<p class="source-code">package payroll</p></li>
				<li>In <strong class="source-inline">manager.go</strong>, the <strong class="source-inline">Manager</strong> type and its methods will be exportable. All the types and methods are exportable because the first letter is capitalized. This means that they are visible to other packages outside of <strong class="source-inline">payroll</strong>.</li>
				<li>From <a href="https://packt.live/2YNnfS6">https://packt.live/2YNnfS6</a>, move the code that relates to the employee type and methods to <strong class="source-inline">Chapter08/Activity8.01/payroll/manager.go file</strong>. It should look like the following code snippet:<p class="source-code">package payroll</p><p class="source-code">type Manager struct {</p><p class="source-code">  Individual     Employee</p><p class="source-code">  Salary         float64</p><p class="source-code">  CommissionRate float64</p><p class="source-code">}</p><p class="source-code">func (m Manager) Pay() (string, float64) {</p><p class="source-code">  fullName := m.Individual.FirstName + " " + m.Individual.LastName</p><p class="source-code">  return fullName, m.Salary + (m.Salary * m.CommissionRate)</p><p class="source-code">}</p><p>The <strong class="source-inline">developer.go</strong>, <strong class="source-inline">employee.go</strong>, and <strong class="source-inline">manager.go</strong> files make up the <strong class="source-inline">payroll</strong> package. Even though the <strong class="source-inline">payroll</strong> package is split up between three files: <strong class="source-inline">developer.go</strong>, <strong class="source-inline">employee.go</strong>, and <strong class="source-inline">manager.go</strong>, they are all accessible across files in the <strong class="source-inline">payroll</strong> package. Every file in this directory belongs to the <strong class="source-inline">payroll</strong> package.</p></li>
				<li>Next, in the <strong class="source-inline">Chapter08/Activity8.01/pay/main.go</strong> file, by looking at the <strong class="source-inline">package</strong> declaration, we can see this is an executable package. This is because any package that is the main package is an executable. We also know that since this is the main package, it will have a <strong class="source-inline">main()</strong> function:<p class="source-code">package main</p></li>
				<li>We know from the initialization process that the packages will have their variables and <strong class="source-inline">init()</strong> functions initialized first. In the <strong class="source-inline">import</strong> declaration, we are importing our <strong class="source-inline">payroll</strong> package. The <strong class="source-inline">payroll</strong> package is also going to be aliased as <strong class="source-inline">pr</strong>:<p class="source-code">import (</p><p class="source-code">  "fmt"</p><p class="source-code">  "os"</p><p class="source-code">  <strong class="bold">pr </strong>"github.com/PacktWorkshops/Get-Ready-To-Go/Chapter08/Activity8.01/payroll"</p><p class="source-code">)</p></li>
				<li>The <strong class="source-inline">main</strong> package <strong class="source-inline">employeeReview</strong> variable will be initialized next, after the <strong class="source-inline">import</strong> items:<p class="source-code">var <strong class="bold">employeeReview</strong> = make(map[string]interface{})</p></li>
				<li>Next, create the <strong class="source-inline">init()</strong> function. It will run before the other functions in the <strong class="source-inline">main</strong> package. It will greet users with a message:<p class="source-code">func init() {</p><p class="source-code">  fmt.Println("Welcome to the Employee Pay and Performance Review")</p><p class="source-code">  fmt.Println("++++++++++++++++++++++++++++++++++++++++++++++++++")</p><p class="source-code">}</p></li>
				<li>This is our second <strong class="source-inline">init()</strong> function in the <strong class="source-inline">main</strong> package and it will run next. It initializes the <strong class="source-inline">employeeReview</strong> variables to values that will be used in this package:<p class="source-code">func init() {</p><p class="source-code">  fmt.Println("Initializing variables")</p><p class="source-code">  employeeReview["WorkQuality"] = 5</p><p class="source-code">  employeeReview["TeamWork"] = 2</p><p class="source-code">  employeeReview["Communication"] = "Poor"</p><p class="source-code">  employeeReview["Problem-solving"] = 4</p><p class="source-code">  employeeReview["Dependability"] = "Unsatisfactory"</p><p class="source-code">}</p></li>
				<li>We now get to the <strong class="source-inline">main()</strong> function. Every main package has a <strong class="source-inline">main()</strong> function. This is the entry point to our executable:<p class="source-code">func main() {</p></li>
				<li>We alias our payroll in the <strong class="source-inline">import</strong> declaration with <strong class="source-inline">pr</strong>. We initialize our exportable <strong class="source-inline">Developer</strong> type through the <strong class="source-inline">payroll</strong> alias of <strong class="source-inline">pr</strong>. Since <strong class="source-inline">Developer</strong> in the <strong class="source-inline">payroll</strong> package is exportable, we will have visibility of it from the <strong class="source-inline">main</strong> package. This is also true for the <strong class="source-inline">Employee</strong> type:<p class="source-code">  d := pr.Developer{Individual: pr.Employee{Id: 1, FirstName: "Eric", LastName: "Davis"}, HourlyRate: 35, HoursWorkedInYear: 2400, Review: employeeReview}</p></li>
				<li>We alias our payroll in the <strong class="source-inline">import</strong> declaration with <strong class="source-inline">pr</strong>. We initialize our exportable <strong class="source-inline">Manager</strong> type through the <strong class="source-inline">payroll</strong> alias of <strong class="source-inline">pr</strong>. Since <strong class="source-inline">Manager</strong> in the <strong class="source-inline">payroll</strong> package is exportable, we have visibility of it from the <strong class="source-inline">main</strong> package. This is also true for the <strong class="source-inline">Employee</strong> type:<p class="source-code">  m := pr.Manager{Individual: pr.Employee{Id: 2, FirstName: "Mr.", LastName: "Boss"}, Salary: 150000, CommissionRate: .07}</p></li>
				<li>The <strong class="source-inline">Developer</strong> method, <strong class="source-inline">ReviewRating()</strong> is also exportable. This allows us to call that method from the <strong class="source-inline">payroll</strong> package:<p class="source-code">  err := d.ReviewRating()</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>The <strong class="source-inline">PayDetails</strong> function is exportable, and we can also invoke the function in the <strong class="source-inline">payroll</strong> package. We call it with the alias of <strong class="source-inline">pr</strong>:<p class="source-code">  pr.PayDetails(d)</p><p class="source-code">  pr.PayDetails(m)</p><p class="source-code">}</p></li>
				<li>At the command line, go to the <strong class="source-inline">/Exercise8.01/Activity8.01/pay</strong> directory structure.</li>
				<li>At the command line, type the following:<p class="source-code">go build</p></li>
				<li>The <strong class="source-inline">go build</strong> command will compile your program and create an executable named after the <strong class="source-inline">dir</strong> area.</li>
				<li>Type the executable name and hit <em class="italic">Enter</em>:<p class="source-code">./pay</p><p>The result should be as follows:</p><p class="source-code">Welcome to the Employee Pay and Performance Review</p><p class="source-code">++++++++++++++++++++++++++++++++++++++++++++++++++</p><p class="source-code">Initializing variables</p><p class="source-code">Eric Davis got a review rating of 2.80</p><p class="source-code">Eric Davis got paid 84000.00 for the year</p><p class="source-code">Mr. Boss got paid 160500.00 for the year</p></li>
			</ol>
			<h1 id="_idParaDest-487"><a id="_idTextAnchor566"/>Chapter 9: Basic Debugging</h1>
			<h2 id="_idParaDest-488"><a id="_idTextAnchor567"/>Activity 9.01: Building a Program to Validate Social Security Numbers</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>All directories and files created should be within your <strong class="source-inline">$GOPATH</strong>:</p>
			<ol>
				<li value="1">Create a directory called <strong class="source-inline">Activity9.01</strong> inside the <strong class="source-inline">Chapter09</strong> directory.</li>
				<li>Create a file called <strong class="source-inline">main.go</strong> inside the <strong class="source-inline">Chapter09/Activity9.01/</strong> directory.</li>
				<li>Using Visual Studio Code, open the <strong class="source-inline">main.go</strong> file.</li>
				<li>Add the following code to <strong class="source-inline">main.go</strong>.<p>Here is the <strong class="source-inline">main</strong> function to build from:</p><p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">    "errors"</p><p class="source-code">    "fmt"</p><p class="source-code">    "log"</p><p class="source-code">    "strconv"</p><p class="source-code">    "strings"</p><p class="source-code">)</p></li>
				<li>Add the following custom error types. The custom errors that we will be using to log in to our program. These custom errors will be returned by their respective functions. They will appear in the log where applicable:<p class="source-code">var (</p><p class="source-code">    ErrInvalidSSNLength     = errors.New("ssn is not nine characters long")</p><p class="source-code">    ErrInvalidSSNNumbers    = errors.New("ssn has non-numeric digits")</p><p class="source-code">    ErrInvalidSSNPrefix     = errors.New("ssn has three zeros as a prefix")</p><p class="source-code">    ErrInvalidSSNDigitPlace = errors.New("ssn starts with a 9 requires 7 or       9 in the fourth place")</p><p class="source-code">)</p></li>
				<li>Create a function that will check to see whether the SSN length is valid. If the length is not 9, return an error to include the details of which SSN caused the custom error, <strong class="source-inline">ErrInvalidSSNLength</strong>:<p class="source-code">func validLength(ssn string) error {</p><p class="source-code">    ssn = strings.TrimSpace(ssn)</p><p class="source-code">    if len(ssn) != 9 {</p><p class="source-code">        return fmt.Errorf("the value of %s caused an error: %v\n", ssn,           ErrInvalidSSNLength)</p><p class="source-code">    }</p><p class="source-code">    return nil</p><p class="source-code">}</p></li>
				<li>Create a function that will check to see whether all the characters in the SSN are numbers. If the SSN is invalid, return an error to include the details of which SSN caused the custom error, <strong class="source-inline">ErrInvalidSSNNumbers</strong>:<p class="source-code">func isNumber(ssn string) error {</p><p class="source-code">    _, err := strconv.Atoi(ssn)</p><p class="source-code">    if err != nil {</p><p class="source-code">        return fmt.Errorf("the value of %s caused an error: %v\n", ssn,           ErrInvalidSSNNumbers)</p><p class="source-code">    }</p><p class="source-code">    return nil</p><p class="source-code">}</p></li>
				<li>Create a function that will check to see whether the SSN starts with 000. If the SSN is invalid, return an error to include the details of which SSN caused the custom error, <strong class="source-inline">ErrInvalidSSNPrefix</strong>:<p class="source-code">func isPrefixValid(ssn string) error {</p><p class="source-code">    if strings.HasPrefix(ssn, "000") {</p><p class="source-code">        return fmt.Errorf("the value of %s caused an error: %v\n", ssn,           ErrInvalidSSNPrefix)</p><p class="source-code">    }</p><p class="source-code">    return nil</p><p class="source-code">}</p></li>
				<li>Create a function that will check that if the SSN starts with a 9, then the fourth digit of an SSN should be a 7 or a 9. If the SSN is invalid, return an error to include the details of which SSN caused the custom error, <strong class="source-inline">ErrInvalidSSNDigitPlace</strong>:<p class="source-code">func validDigitPlace(ssn string) error {</p><p class="source-code">    if string(ssn[0]) == "9" &amp;&amp; (string(ssn[3]) != "9" &amp;&amp; string(ssn[3]) !=       "7") {</p><p class="source-code">        return fmt.Errorf("the value of %s caused an error: %v\n", ssn,           ErrInvalidSSNDigitPlace)</p><p class="source-code">    }</p><p class="source-code">    return nil</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">main()</strong> function, set the flags for our logging:<p class="source-code">func main() {</p><p class="source-code">    log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile)</p></li>
				<li>Initialize our <strong class="source-inline">validateSSN</strong> slice to contain various SSN numbers that we will be validating:<p class="source-code">    validateSSN := []string{"123-45-6789", "012-8-678", "000-12-0962", "999-      33-3333", "087-65-4321","123-45-zzzz"}</p></li>
				<li>Print the Go representation of the <strong class="source-inline">validateSSN</strong> variable using <strong class="source-inline">%#v</strong>:<p class="source-code">    log.Printf("Checking data %#v",validateSSN)</p></li>
				<li>Next, create a <strong class="source-inline">for</strong> loop that will iterate over the slice of SSNs using a <strong class="source-inline">range</strong> clause:<p class="source-code">    for idx,ssn := range validateSSN {</p></li>
				<li>In the <strong class="source-inline">for</strong> loop, for each SSN, we want to print some details about the <strong class="source-inline">ssn</strong>. We want to print the current entry order of the SSN in the slice that we are validating using the <strong class="source-inline">%d</strong> verb. Finally, we need to print the total number of items in the slice using the <strong class="source-inline">%d</strong> verb:<p class="source-code">        log.Printf("Validate data %#v %d of %d ",ssn,idx+1,len(validateSSN))</p></li>
				<li>Remove any dashes from our SSN:<p class="source-code">        ssn = strings.Replace(ssn, "-", "", -1)</p></li>
				<li>Call each of the functions we are using for validating the SSN. Log the error that gets returned from the function:<p class="source-code">        Err := isNumber(ssn)</p><p class="source-code">        if err != nil {</p><p class="source-code">            log.Print(err)</p><p class="source-code">        }</p><p class="source-code">        err = validLength(ssn)</p><p class="source-code">        if err != nil {</p><p class="source-code">            log.Print(err)</p><p class="source-code">        }</p><p class="source-code">        err = isPrefixValid(ssn)</p><p class="source-code">        if err != nil {</p><p class="source-code">            log.Print(err)</p><p class="source-code">        }</p><p class="source-code">        err = validDigitPlace(ssn)</p><p class="source-code">        if err != nil {</p><p class="source-code">            log.Print(err)</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>At the command line, change the directory using the following code:<p class="source-code">cd Chapter09/Exercise9.02/ </p></li>
				<li>In <em class="italic">Exercise 9.02</em>, <em class="italic">Printing Decimal, Binary, and Hex Values</em>, directory, type the following command:<p class="source-code">go build</p><p>Type the executable that was created from the <strong class="source-inline">go build</strong> command and press <em class="italic">Enter</em>.</p><p>The expected output is as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer345" class="IMG---Figure">
					<img src="image/B14177_09_14.jpg" alt="Figure 9.15: Validating the SSN output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.15: Validating the SSN output</p>
			<h1 id="_idParaDest-489"><a id="_idTextAnchor568"/>Chapter 10: About Time</h1>
			<h2 id="_idParaDest-490"><a id="_idTextAnchor569"/>Activity 10.01: Formatting a Date According to User Requirements</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">Chapter_10_Activity_1.go</strong> and initialize it with the following code:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">import "time"</p><p class="source-code">import "strconv"</p><p class="source-code">func main(){</p></li>
				<li>Capture the following values: <strong class="source-inline">date</strong>, <strong class="source-inline">day</strong>, <strong class="source-inline">month</strong>, <strong class="source-inline">year</strong>, <strong class="source-inline">hour</strong>, <strong class="source-inline">minute</strong>, and <strong class="source-inline">second</strong>:<p class="source-code">  date := time.Now()</p><p class="source-code">  day := strconv.Itoa(date.Day())</p><p class="source-code">  month := strconv.Itoa(int(date.Month()))</p><p class="source-code">  year := strconv.Itoa(date.Year())</p><p class="source-code">  hour := strconv.Itoa(date.Hour())</p><p class="source-code">  minute := strconv.Itoa(date.Minute())</p><p class="source-code">  second := strconv.Itoa(date.Second())</p></li>
				<li>Print the concatenated output:<p class="source-code">  fmt.Println(hour + ":" + minute + ":" + second + " " + year + "/" + month   + "/" + day)</p><p class="source-code">}</p><p>The expected output is as follows (note that this depends on when you run the code):</p><p class="source-code">15:32:30 2019/10/17</p></li>
			</ol>
			<h2 id="_idParaDest-491"><a id="_idTextAnchor570"/>Activity 10.02: Enforcing a Specific Format of Date and Time</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">Chapter_10_Activity_2.go</strong> and initialize the script as follows:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">import "time"</p><p class="source-code">import "strconv"</p><p class="source-code">func main(){</p></li>
				<li>Capture the following values: <strong class="source-inline">date</strong>, <strong class="source-inline">day</strong>, <strong class="source-inline">month</strong>, <strong class="source-inline">year</strong>, <strong class="source-inline">hour</strong>, <strong class="source-inline">minute</strong>, and <strong class="source-inline">second</strong>:<p class="source-code">  date := time.Date(2019, 1, 31, 2, 49, 21, 324359102, time.UTC)</p><p class="source-code">  day := strconv.Itoa(date.Day())</p><p class="source-code">  month := strconv.Itoa(int(date.Month()))</p><p class="source-code">  year := strconv.Itoa(date.Year())</p><p class="source-code">  hour := strconv.Itoa(date.Hour())</p><p class="source-code">  minute := strconv.Itoa(date.Minute())</p><p class="source-code">  second := strconv.Itoa(date.Second())</p></li>
				<li>Print the concatenated output:<p class="source-code">fmt.Println(hour + ":" + minute + ":" + second + " " + year + "/" + month +   "/" + day)</p><p class="source-code">}</p><p>The expected output is as follows:</p><p class="source-code">2:49:21 2019/1/31</p></li>
			</ol>
			<h2 id="_idParaDest-492"><a id="_idTextAnchor571"/>Activity 10.03: Measuring Elapsed Time</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">Chapter_10_Activity_3.go</strong> and initialize it in the following way:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">import "time"</p><p class="source-code">func main(){</p></li>
				<li>Capture the <strong class="source-inline">start</strong> time of execution in a variable, and sleep for 2 seconds:<p class="source-code">  start := time.Now()</p><p class="source-code">  time.Sleep(2 * time.Second)</p></li>
				<li>Capture the end of execution in a variable and calculate the length:<p class="source-code">  end := time.Now()</p><p class="source-code">  length := end.Sub(start)</p></li>
				<li>Print out how long it took to execute <strong class="source-inline">sleep</strong>:<p class="source-code">fmt.Println("The execution took exactly",length.Seconds(),"seconds!")</p><p class="source-code">}</p><p>The expected output is as follows:</p><p class="source-code">The execution took exactly 2.0016895 seconds!</p></li>
			</ol>
			<h2 id="_idParaDest-493"><a id="_idTextAnchor572"/>Activity 10.04: Calculating the Future Date and Time</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">Chapter_10_Activity_4.go</strong> and initialize it in the following way:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">import "time"</p><p class="source-code">func main(){</p></li>
				<li>Capture and print the <strong class="source-inline">current</strong> time:<p class="source-code">  Current := time.Now()</p><p class="source-code">  fmt.Println("The current time is:",Current.Format(time.ANSIC))</p></li>
				<li>Calculate the specified duration and create a variable called <strong class="source-inline">Future</strong>:<p class="source-code">  SSS := time.Duration(21966 * time.Second)</p><p class="source-code">  Future := Current.Add(SSS)</p></li>
				<li>Print out the time value of <strong class="source-inline">Future</strong> in ANSIC format:<p class="source-code">fmt.Println("6 hours, 6 minutes and 6 seconds from now the time will be:   ",Future.Format(time.ANSIC))</p><p class="source-code">}</p><p>The expected output is as follows:</p><p class="source-code">The current time: Thu Oct 17 15:16:48 2019</p><p class="source-code">6 hours, 6 minutes and 6 seconds from now the time will be:  Thu Oct 17 21:22:54 2019</p></li>
			</ol>
			<h2 id="_idParaDest-494"><a id="_idTextAnchor573"/>Activity 10.05: Printing the Local Time in Different Time Zones</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a file called <strong class="source-inline">Chapter_10_Activity_5.go</strong> and initialize it the following way:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">import "time"</p><p class="source-code">func main(){</p></li>
				<li>Capture the following values: <strong class="source-inline">Current</strong>, <strong class="source-inline">NYtime</strong>, and <strong class="source-inline">LA</strong>:<p class="source-code">Current := time.Now()</p><p class="source-code">  NYtime, _ := time.LoadLocation("America/New_York")</p><p class="source-code">  LA, _ := time.LoadLocation("America/Los_Angeles")</p></li>
				<li>Print out the values with the following format:<p class="source-code">fmt.Println("The local current time is:",Current.Format(time.ANSIC))</p><p class="source-code">  fmt.Println("The time in New York is:     ",Current.In(NYtime).Format(time.ANSIC))</p><p class="source-code">  fmt.Println("The time in Los Angeles is:     ",Current.In(LA).Format(time.ANSIC))</p><p class="source-code">}</p><p>The expected output is as follows:</p><p class="source-code">The local current time is: Thu Oct 17 15:16:13 2019</p><p class="source-code">The time in New York is: Thu Oct 17 09:16:13 2019</p><p class="source-code">The time in Los Angeles is: Thu Oct 17 06:16:13 2019</p></li>
			</ol>
			<h1 id="_idParaDest-495"><a id="_idTextAnchor574"/>Chapter 11: Encoding and Decoding (JSON)</h1>
			<h2 id="_idParaDest-496"><a id="_idTextAnchor575"/>Activity 11.01: Mimicking a Customer Order Using JSON</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>All directories and files created need to be created within your <strong class="source-inline">$GOPATH</strong>:</p>
			<ol>
				<li value="1">Create a directory called <strong class="source-inline">Activity11.01</strong> within a directory called <strong class="source-inline">Chapter11</strong>.</li>
				<li>Create a file called <strong class="source-inline">main.go</strong> inside <strong class="source-inline">Chapter11/Activity11.01</strong>.</li>
				<li>Using Visual Studio Code, open the newly created <strong class="source-inline">main.go</strong> file.</li>
				<li>Add the following package name and import statements:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "encoding/json"</p><p class="source-code">  "fmt"</p><p class="source-code">  "os"</p><p class="source-code">)</p></li>
				<li>Add the following <strong class="source-inline">customer</strong> <strong class="source-inline">struct</strong> with the JSON tags set accordingly:<p class="source-code">type customer struct {</p><p class="source-code">  UserName      string  `json:"username"`</p><p class="source-code">  Password      string  `json:"-"`</p><p class="source-code">  Token         string  `json:"-"`</p><p class="source-code">  ShipTo        address `json:"shipto"`</p><p class="source-code">  PurchaseOrder order   `json:"order"`</p><p class="source-code">}</p></li>
				<li>Add the following <strong class="source-inline">order</strong> <strong class="source-inline">struct</strong> with the JSON tags set accordingly:<p class="source-code">type order struct {</p><p class="source-code">  TotalPrice  int    `json:"total"`</p><p class="source-code">  IsPaid      bool   `json:"paid"`</p><p class="source-code">  Fragile     bool   `json:",omitempty"`</p><p class="source-code">  OrderDetail []item `json:"orderdetail"`</p><p class="source-code">}</p></li>
				<li>Add the following <strong class="source-inline">item</strong> <strong class="source-inline">struct</strong> with the JSON tags set accordingly:<p class="source-code">type item struct {</p><p class="source-code">  Name        string `json:"itemname"`</p><p class="source-code">  Description string `json:"desc,omitempty"`</p><p class="source-code">  Quantity    int    `json:"qty"`</p><p class="source-code">  Price       int    `json:"price"`</p><p class="source-code">}</p></li>
				<li>Add the following <strong class="source-inline">address</strong> <strong class="source-inline">struct</strong> with the JSON tags set accordingly:<p class="source-code">type address struct {</p><p class="source-code">  Street  string `json:"street"`</p><p class="source-code">  City    string `json:"city"`</p><p class="source-code">  State   string `json:"state"`</p><p class="source-code">  ZipCode int    `json:"zipcode"`</p><p class="source-code">}</p></li>
				<li>Create a method on the customer type called <strong class="source-inline">Total()</strong>. This method will calculate the <strong class="source-inline">TotalPrice</strong> of the <strong class="source-inline">PurchaseOrder</strong> for the customer type. The calculation is, for each item, <strong class="source-inline">Quantity * price</strong>:<p class="source-code">func (c *customer) Total() {</p><p class="source-code">  price := 0</p><p class="source-code">  for _, item := range c.PurchaseOrder.OrderDetail {</p><p class="source-code">    price += item.Quantity * item.Price</p><p class="source-code">  }</p><p class="source-code">  c.PurchaseOrder.TotalPrice = price</p><p class="source-code">}</p></li>
				<li>Add a <strong class="source-inline">main()</strong> function with <strong class="source-inline">jsonData []byte</strong>:<p class="source-code">func main() {</p><p class="source-code">  jsonData := []byte(`</p><p class="source-code">  {</p><p class="source-code">    "username" :"blackhat",</p><p class="source-code">    "shipto":  </p><p class="source-code">      {</p><p class="source-code">          "street": "Sulphur Springs Rd",</p><p class="source-code">          "city": "Park City",</p><p class="source-code">          "state": "VA",</p><p class="source-code">          "zipcode": 12345</p><p class="source-code">      },</p><p class="source-code">    "order":</p><p class="source-code">      {</p><p class="source-code">        "paid":false,</p><p class="source-code">        "orderdetail" : </p><p class="source-code">           [{</p><p class="source-code">            "itemname":"A Guide to the World of zeros and ones",</p><p class="source-code">            "desc": "book",</p><p class="source-code">            "qty": 3,</p><p class="source-code">            "price": 50</p><p class="source-code">          }]</p><p class="source-code">      }</p><p class="source-code">  }</p><p class="source-code">  `)</p></li>
				<li>Next, we need to validate that <strong class="source-inline">jsonData</strong> is valid JSON. If it is not, print a message and exit the application:<p class="source-code">  if !json.Valid(jsonData) {</p><p class="source-code">    fmt.Printf("JSON is not valid: %s", jsonData)</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>Declare a variable of the customer type:<p class="source-code">  var c customer</p></li>
				<li>Unmarshal <strong class="source-inline">jsonData</strong> into the customer variable. Check for any errors, and if there is an error, print the error and exit the application:<p class="source-code">  err := json.Unmarshal(jsonData, &amp;c)</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>Declare a variable of the <strong class="source-inline">item{}</strong> type and set all the fields:<p class="source-code">  game := item{}</p><p class="source-code">  game.Name = "Final Fantasy The Zodiac Age"</p><p class="source-code">  game.Description = "Nintendo Switch Game"</p><p class="source-code">  game.Quantity = 1</p><p class="source-code">  game.Price = 50</p></li>
				<li>Declare another variable of the <strong class="source-inline">item{}</strong> type and set all the fields, except for the <strong class="source-inline">Description</strong> field:<p class="source-code">  glass := item{}</p><p class="source-code">  glass.Name = "Crystal Drinking Glass"</p><p class="source-code">  glass.Quantity = 11</p><p class="source-code">  glass.Price = 25</p></li>
				<li>Add the two newly created items to the customer order's <strong class="source-inline">OrderDetail</strong>:<p class="source-code">  c.PurchaseOrder.OrderDetail = append(c.PurchaseOrder.OrderDetail, game)</p><p class="source-code">  c.PurchaseOrder.OrderDetail = append(c.PurchaseOrder.OrderDetail, glass)</p></li>
				<li>Now that we have all of our items, we can now calculate the price by calling the <strong class="source-inline">c.Total()</strong> function:<p class="source-code">  c.Total()</p></li>
				<li>Set some <strong class="source-inline">PurchaseOrder</strong> fields:<p class="source-code">  c.PurchaseOrder.IsPaid = true</p><p class="source-code">  c.PurchaseOrder.Fragile = true</p></li>
				<li>Marshal the customer into JSON. Properly set the indention so that the JSON can be easily read. Check for any errors and if there is an error, print the message, and then exit the application:<p class="source-code">  customerOrder, err := json.MarshalIndent(c, "", "    ")</p><p class="source-code">  if err != nil {</p><p class="source-code">    fmt.Println(err)</p><p class="source-code">    os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>Print the JSON:<p class="source-code">  fmt.Println(string(customerOrder))</p><p class="source-code">}</p></li>
				<li>Build the program by running <strong class="source-inline">go build</strong> at the command line:<p class="source-code">go build</p></li>
				<li>Run the executable by typing in the name of the executable and then hitting <em class="italic">Enter</em>.<p>The results are as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer346" class="IMG---Figure">
					<img src="image/B14177_11_22.jpg" alt="Figure 11.22: Customer order printout&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.22: Customer order printout</p>
			<h1 id="_idParaDest-497"><a id="_idTextAnchor576"/>Chapter 12: Files and Systems</h1>
			<h2 id="_idParaDest-498"><a id="_idTextAnchor577"/>Activity 12.01: Parsing Bank Transaction Files</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>All directories and files created should be inside your <strong class="source-inline">$GOPATH</strong>.</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">Chapter12/Activity12.01/</strong> directory.</li>
				<li>Inside <strong class="source-inline">Chapter12/Activity12.01/</strong>, create a <strong class="source-inline">main.go</strong> file.</li>
				<li>Add the following code to the <strong class="source-inline">main.go</strong> file:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "encoding/csv"</p><p class="source-code">  "errors"</p><p class="source-code">  "flag"</p><p class="source-code">  "fmt"</p><p class="source-code">  "io"</p><p class="source-code">  "log"</p><p class="source-code">  "os"</p><p class="source-code">  "strconv"</p><p class="source-code">  "strings"</p><p class="source-code">)</p></li>
				<li>Create budget category types for fuel, food, mortgage, repairs, insurance, utilities, and retirement:<p class="source-code">type budgetCategory string</p><p class="source-code">const (</p><p class="source-code">  autoFuel   budgetCategory = "fuel"</p><p class="source-code">  food     budgetCategory = "food"</p><p class="source-code">  mortgage   budgetCategory = "mortgage"</p><p class="source-code">  repairs  budgetCategory = "repairs"</p><p class="source-code">  insurance  budgetCategory = "insurance"</p><p class="source-code">  utilities  budgetCategory = "utilities"</p><p class="source-code">  retirement budgetCategory = "retirement"</p><p class="source-code">)</p></li>
				<li>Create our custom error type for when the budget category cannot be found:<p class="source-code">var (</p><p class="source-code">  ErrInvalidBudgetCategory = errors.New("budget category not found")</p><p class="source-code">)</p></li>
				<li>Create our <strong class="source-inline">transaction</strong> <strong class="source-inline">struct</strong> that will hold the data from our bank's transaction file:<p class="source-code">type transaction struct {</p><p class="source-code">  id     int</p><p class="source-code">  payee  string</p><p class="source-code">  spent  float64</p><p class="source-code">  category budgetCategory</p><p class="source-code">}</p></li>
				<li>Inside the <strong class="source-inline">main()</strong> function, we need to create two flags. The first flag to create is <strong class="source-inline">bankFile</strong>. The <strong class="source-inline">bankFile</strong> variable is the CSV transaction file. Define our flags for the <strong class="source-inline">bankFile</strong> variable. The flag type is a string. The CLI will have <strong class="source-inline">-c</strong>; this is used to store the location of the CSV <strong class="source-inline">bankFile</strong>. The default value is an empty string, so if the flag does not get set, the value for it will be an empty string. The <strong class="source-inline">bankFile</strong> variable is the address that stores the value of the flag:<p class="source-code">func main() {</p><p class="source-code">  bankFile := flag.String("c", "", "location of the bank transaction csv file")</p><p class="source-code">//…</p><p class="source-code">}</p></li>
				<li>The next flag will be for our <strong class="source-inline">logFile</strong>. This is the file that will be used for logging errors. Define our flags for the log file. The flag type is a string. The CLI will have <strong class="source-inline">-l</strong>; this is used to store the location of the <strong class="source-inline">logFile</strong> variable. The default value is an empty string, so if the flag does not get set, the value for it will be an empty string. The <strong class="source-inline">logFile</strong> variable is the address that stores the value of the flag:<p class="source-code">  logFile := flag.String("l", "", "logging of errors")</p></li>
				<li>After defining the flags, you must call <strong class="source-inline">flag.Parse()</strong> to parse the command line into the defined flags.  Calling <strong class="source-inline">flag.Parse()</strong> places the argument for <strong class="source-inline">-value</strong> into <strong class="source-inline">*bankFile</strong> and <strong class="source-inline">*logFile</strong>. Once you have called <strong class="source-inline">flag.Parse()</strong>, the flags will be available:<p class="source-code">  flag.Parse()</p></li>
				<li>Our <strong class="source-inline">bankFile</strong> variable is required, so we need to ensure it was provided. When we define our flags, we set the default value to an empty string. If the value of <strong class="source-inline">*bankFile</strong> is an empty string, we know that it was not properly set. If <strong class="source-inline">*bankFile</strong> was not provided, we print a message that the field is required along with the <strong class="source-inline">usage</strong> statement. Then, exit the program:<p class="source-code">  if *bankFile == "" {</p><p class="source-code">  fmt.Println("csvFile is required.")</p><p class="source-code">  flag.PrintDefaults()</p><p class="source-code">  os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>If the CSV file was not provided, you should get the following message:<div id="_idContainer347" class="IMG---Figure"><img src="image/B14177_12_23.jpg" alt="Figure 12.23: The csvFile is required message&#13;&#10;"/></div><p class="figure-caption">Figure 12.23: The csvFile is required message</p></li>
				<li>The <strong class="source-inline">logfile</strong> variable is required and we need to ensure it was provided. Implement the same code you performed in the previous step except for <strong class="source-inline">logfile</strong>:<p class="source-code">  if *logFile == "" {</p><p class="source-code">  fmt.Println("logFile is required.")</p><p class="source-code">  flag.PrintDefaults()</p><p class="source-code">  os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>Implement code to check and see whether the <strong class="source-inline">bankFile</strong> variable exists. We are calling <strong class="source-inline">os.Stat()</strong> on the <strong class="source-inline">*bankFile</strong> file to check to see whether it exists. The <strong class="source-inline">os.Stat()</strong> method will return a <strong class="source-inline">FileInfo</strong> if the file exists. If not, <strong class="source-inline">FileInfo</strong> will be <strong class="source-inline">nil</strong> and an error will be returned instead.</li>
				<li>The <strong class="source-inline">os.Stat()</strong> method can return multiple errors. We must inspect the error to determine whether the error is due to the file not being there. The standard library provides <strong class="source-inline">os.IsNotExist(error)</strong>, which can be used to check to see whether the error is the result of the file not existing:<p class="source-code">  _, err := os.Stat(*bankFile)</p><p class="source-code">  if os.IsNotExist((err)) {</p><p class="source-code">  fmt.Println("BankFile does not exist: ", *bankFile)</p><p class="source-code">  os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>Likewise, check to see whether the log file exists. If it does, we need to delete it:<p class="source-code">  _, err = os.Stat(*logFile)</p><p class="source-code">  if !os.IsNotExist((err)) {</p><p class="source-code">  os.Remove(*logFile)</p><p class="source-code">  }</p></li>
				<li>Next, open the <strong class="source-inline">bankFile</strong> variable. Upon opening <strong class="source-inline">bankFile</strong>, the <strong class="source-inline">os.Open</strong> function returns an <strong class="source-inline">*os.File</strong> type that satisfies the <strong class="source-inline">io.Reader</strong> interface, which will allow us to pass it to the next function.</li>
				<li>As always, check to see whether an error was returned. If so, display the error and exit the program:<p class="source-code">  csvFile, err := os.Open(*bankFile)</p><p class="source-code">  if err != nil {</p><p class="source-code">  fmt.Println("Error opening file: ", *bankFile)</p><p class="source-code">  os.Exit(1)</p><p class="source-code">  }</p></li>
				<li>We will call the <strong class="source-inline">parseBankFile()</strong> function; this is where the bulk of the work occurs. It will transform the CSV file into our transaction struct. We then need to iterate over the slice of transactions and print the data from the transaction:<p class="source-code">  trxs := parseBankFile(csvFile, *logFile)</p><p class="source-code">    fmt.Println()</p><p class="source-code">    for _, trx := range trxs {</p><p class="source-code">    fmt.Printf("%v\n", trx)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Create a function called <strong class="source-inline">parseBankFile(bankTransaction io.Reader, logFile string) []transaction</strong>:<p class="source-code">func parseBankFile(bankTransactions io.Reader, logFile string) []transaction {</p><p class="source-code">/…</p><p class="source-code">}</p></li>
				<li>Create a reader for the CSV data. The <strong class="source-inline">NewReader</strong> method takes an argument of <strong class="source-inline">io.Reader</strong> and returns a type of <strong class="source-inline">Reader</strong> that is used to read the CSV data.</li>
				<li>Create a variable of type slice of <strong class="source-inline">transaction</strong>.</li>
				<li>Create a variable to detect the header of the CSV file:<p class="source-code">  r := csv.NewReader(bankTransactions)</p><p class="source-code">  trxs := []transaction{}</p><p class="source-code">  header := true</p></li>
				<li>Implement code that reads each record in one at a time in an infinite loop.  </li>
				<li>After each record we read, we check first to see whether it is the end of the file (<strong class="source-inline">io.EOF</strong>). We need to perform this check to allow us to break out of our infinite loop when it reaches the EOF.</li>
				<li>The <strong class="source-inline">r.Read()</strong> method reads one record; this is a slice of fields from the <strong class="source-inline">r</strong> variable. It returns that record as <strong class="source-inline">[]string</strong>:<p class="source-code">for {</p><p class="source-code">  trx := transaction{}</p><p class="source-code">  record, err := r.Read()</p><p class="source-code">  if err == io.EOF {</p><p class="source-code">    break</p><p class="source-code">  }</p><p class="source-code">  if err != nil {</p><p class="source-code">    log.Fatal(err)</p><p class="source-code">  }</p></li>
				<li>We will use the <strong class="source-inline">header</strong> variable as a flag. When header fields are provided, they are typically the first row of the file. We do not need to process the column headers:<p class="source-code">if !header</p></li>
				<li>Currently, our first loop iterates over the CSV file, but we also need a loop that iterates over each column in the record. The record is a slice of fields. <strong class="source-inline">idx</strong> is the position of the field in the slice:<p class="source-code">for idx, value := range record {</p></li>
				<li>We will use a <strong class="source-inline">switch</strong> statement on the <strong class="source-inline">idx</strong> (index) of the slice to identify the data that is stored at that position:<p class="source-code">switch idx {</p><p class="source-code">// id</p><p class="source-code">case 0:</p><p class="source-code">// payee</p><p class="source-code">case 1:</p><p class="source-code">// spent</p><p class="source-code">case 2:</p><p class="source-code">// category</p><p class="source-code">} </p></li>
				<li>Data from the CSV file is in string format; we need to perform various conversions for the fields in the CSV file. The first field is the ID. We need to ensure that there are no trailing spaces in the field. </li>
				<li>We need to convert the field from a string to an <strong class="source-inline">int</strong>, since our struct is of the integer type for the <strong class="source-inline">id</strong> field:<p class="source-code">// id</p><p class="source-code">case 0:</p><p class="source-code">value = strings.TrimSpace(value)</p><p class="source-code">trx.id, err = strconv.Atoi(value)</p></li>
				<li>The second index value is <strong class="source-inline">1</strong>. This column contains the data for the <strong class="source-inline">payee</strong>:<p class="source-code">// payee</p><p class="source-code">case 1:</p><p class="source-code">  value = strings.TrimSpace(value)</p><p class="source-code">  trx.payee = value</p><p>The third index value is <strong class="source-inline">2</strong>. This column contains the data for the spent column in the <strong class="source-inline">bankFile</strong> file.</p></li>
				<li><strong class="source-inline">spent</strong> is of the <strong class="source-inline">float</strong> type, so we are converting the <strong class="source-inline">string</strong> type from the <strong class="source-inline">spent</strong> column to a <strong class="source-inline">float</strong> type:<p class="source-code">// spent</p><p class="source-code">case 2:</p><p class="source-code">  value = strings.TrimSpace(value)</p><p class="source-code">  trx.spent, err = strconv.ParseFloat(value, 64)</p><p class="source-code">  if err != nil {</p><p class="source-code">  log.Fatal(err)</p><p class="source-code">  }</p><p>The third index value is <strong class="source-inline">3</strong>. This column contains the data for the category provided by the bank.</p></li>
				<li>We need to convert the CSV file category column to our <strong class="source-inline">budgetCategory</strong> type.</li>
				<li>Inside the case statement for the category, we check for any errors returned from the <strong class="source-inline">convertToBudgetCategory</strong> function.</li>
				<li>If there is an error, we do not want to stop processing the CSV bank file, so we write the error to a log via the <strong class="source-inline">writeErrorToLog</strong> function:<p class="source-code">// category</p><p class="source-code">  case 3:</p><p class="source-code">  trx.category, err = convertToBudgetCategory(value)</p><p class="source-code">  if err != nil {</p><p class="source-code">    s := strings.Join(record, ", ")</p><p class="source-code">    writeErrorToLog("error converting csv category column - ", err, s, logFile)</p><p class="source-code">  }</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>We are at the end of the loop for the fields in the record. We now need to append our transaction to the slice of transactions:<p class="source-code">trxs = append(trxs, trx)</p><p class="source-code">}</p></li>
				<li><strong class="source-inline">header</strong> was <strong class="source-inline">true</strong> at the start of the function; we will set it to <strong class="source-inline">false</strong>, which indicates that in the rest of the CSV file, we will be parsing the data and not the <strong class="source-inline">header </strong>information:<p class="source-code">    header = false</p><p class="source-code">  }</p></li>
				<li>We have completed parsing the CSV file. We now need to return the slice of transactions:<p class="source-code">  return trxs</p><p class="source-code">}</p></li>
				<li>Create a function named <strong class="source-inline">convertToBudgetCategory(value string)(budgetCategory)</strong>. This function is responsible for mapping the bank categories to our defined categories. If a category is not found, it will return the <strong class="source-inline">ErrInvalidBudgetCategory</strong> error.</li>
				<li>Use a <strong class="source-inline">switch</strong> statement that evaluates each value. When it matches, return the respective <strong class="source-inline">budgetCategory</strong> type:<p class="source-code">func convertToBudgetCategory(value string) (budgetCategory, error) {</p><p class="source-code">  value = strings.TrimSpace(strings.ToLower(value))</p><p class="source-code">  switch value {</p><p class="source-code">  case "fuel", "gas":</p><p class="source-code">  return autoFuel, nil</p><p class="source-code">  case "food":</p><p class="source-code">  return food, nil</p><p class="source-code">  case "mortgage":</p><p class="source-code">  return mortgage, nil</p><p class="source-code">  case "repairs":</p><p class="source-code">  return repairs, nil</p><p class="source-code">  case "car insurance", "life insurance":</p><p class="source-code">  return insurance, nil</p><p class="source-code">  case "utilities":</p><p class="source-code">  return utilities, nil</p><p class="source-code">  default:</p><p class="source-code">  return "", ErrInvalidBudgetCategory</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Create a <strong class="source-inline">writeErrorToLog(msg string, err error, data string, logFile string) error</strong> function. This function will write a message to the log file.</li>
				<li>Then, it will need to format the data about the error to include the <strong class="source-inline">msg</strong>, <strong class="source-inline">error</strong>, and the <strong class="source-inline">data</strong>:<p class="source-code">func writeErrorToLog(msg string, err error, data string, logFile string) error {</p><p class="source-code">  msg += "\n" + err.Error() + "\nData: " + data + "\n\n"</p><p class="source-code">  f, err := os.OpenFile(logFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)</p><p class="source-code">  if err != nil {</p><p class="source-code">  return err</p><p class="source-code">  }</p><p class="source-code">  defer f.Close()</p><p class="source-code">  if _, err := f.WriteString(msg); err != nil {</p><p class="source-code">  return err</p><p class="source-code">  }</p><p class="source-code">  return nil</p><p class="source-code">}</p></li>
				<li>Run the program:<p class="source-code">go run main.go -c bank.csv -l log.log</p><p>Here is a possible output from the application:</p></li>
			</ol>
			<div>
				<div id="_idContainer348" class="IMG---Figure">
					<img src="image/B14177_12_24.jpg" alt="Figure 12.24: Activity output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.24: Activity output</p>
			<p>The possible contents of the <strong class="source-inline">log.log</strong> file are as follows:</p>
			<div>
				<div id="_idContainer349" class="IMG---Figure">
					<img src="image/B14177_12_25.jpg" alt="Figure 12.25: The log.log content&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.25: The log.log content</p>
			<h1 id="_idParaDest-499"><a id="_idTextAnchor578"/>Chapter 13: SQL and Databases</h1>
			<h2 id="_idParaDest-500"><a id="_idTextAnchor579"/>Activity 13.1: Holding User Data in a Table</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Initialize your script with the appropriate imports. Let's call it <strong class="source-inline">main.go</strong>. Prepare an empty <strong class="source-inline">main()</strong> function:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">import "database/sql"</p><p class="source-code">import _ "github.com/lib/pq"</p><p class="source-code">func main(){</p><p class="source-code">}</p></li>
				<li>Let's define the <strong class="source-inline">struct</strong> that will hold the users:<p class="source-code">type Users struct {</p><p class="source-code">    id int</p><p class="source-code">    name string</p><p class="source-code">    email string</p><p class="source-code">}</p></li>
				<li>Now the time has come to create two users:<p class="source-code">users := []Users{</p><p class="source-code">  {1,"Szabo Daniel","daniel@packt.com"},</p><p class="source-code">  {2,"Szabo Florian","florian@packt.com"},</p><p class="source-code">}</p></li>
				<li>Let's open the connection to our <strong class="source-inline">Postgres</strong> server:<p class="source-code">db, err := sql.Open("postgres", "user=postgres password=Start!123   host=127.0.0.1 port=5432 dbname=postgres sslmode=disable")</p><p class="source-code">if err != nil {</p><p class="source-code">  panic(err)</p><p class="source-code">}else{</p><p class="source-code">  fmt.Println("The connection to the DB was successfully initialized!")</p><p class="source-code">}</p></li>
				<li>We should use the <strong class="source-inline">Ping()</strong> function to see whether the connectivity is OK:<p class="source-code">connectivity := db.Ping()</p><p class="source-code">if connectivity != nil{</p><p class="source-code">  panic(connectivity)</p><p class="source-code">}else{</p><p class="source-code">  fmt.Println("Good to go!")</p><p class="source-code">}</p></li>
				<li>Now we can create a multiline string for our table:<p class="source-code">TableCreate := `</p><p class="source-code">CREATE TABLE users</p><p class="source-code">(</p><p class="source-code">  ID integer NOT NULL,</p><p class="source-code">  Name text COLLATE pg_catalog."default" NOT NULL,</p><p class="source-code">  Email text COLLATE pg_catalog."default" NOT NULL,</p><p class="source-code">  CONSTRAINT "Users_pkey" PRIMARY KEY (ID)</p><p class="source-code">)</p><p class="source-code">WITH (</p><p class="source-code">  OIDS = FALSE</p><p class="source-code">)</p><p class="source-code">TABLESPACE pg_default;</p><p class="source-code">ALTER TABLE users</p><p class="source-code">  OWNER to postgres;</p><p class="source-code">`</p></li>
				<li>Once the string is ready, we should create our table:<p class="source-code">_,err = db.Exec(TableCreate)</p><p class="source-code">if err != nil {</p><p class="source-code">  panic(err)</p><p class="source-code">} else{</p><p class="source-code">  fmt.Println("The table called Users was successfully created!")</p><p class="source-code">}</p></li>
				<li>With the <strong class="source-inline">users</strong> struct, we can construct a <strong class="source-inline">for</strong> loop to insert the users:<p class="source-code">insert, insertErr := db.Prepare("INSERT INTO users VALUES($1,$2,$3)")</p><p class="source-code">if insertErr != nil{</p><p class="source-code">  panic(insertErr)</p><p class="source-code">}</p><p class="source-code">for _, u := range users{</p><p class="source-code">  _, err = insert.Exec(u.id,u.name,u.email)</p><p class="source-code">  if err != nil{</p><p class="source-code">    panic(err)</p><p class="source-code">  }else{</p><p class="source-code">    fmt.Println("The user with name:",u.name,"and email:",u.email,"was   successfully added!")</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">insert.Close()</p></li>
				<li>Now with the users in the database, we can update the appropriate field:<p class="source-code">update, updateErr := db.Prepare("UPDATE users SET Email=$1 WHERE ID=$2")</p><p class="source-code">if updateErr != nil{</p><p class="source-code">  panic(updateErr)</p><p class="source-code">}</p><p class="source-code">_, err = update.Exec("user@packt.com",1)</p><p class="source-code">if err != nil{</p><p class="source-code">  panic(err)</p><p class="source-code">} else{</p><p class="source-code">  fmt.Println("The user's email address was successfully updated!")</p><p class="source-code">}</p><p class="source-code">update.Close()</p></li>
				<li>The last task is to remove the <strong class="source-inline">user</strong> with <strong class="source-inline">ID=2</strong>:<p class="source-code">remove, removeErr := db.Prepare("DELETE FROM users WHERE ID=$1")</p><p class="source-code">if removeErr != nil{</p><p class="source-code">  panic(removeErr)</p><p class="source-code">}</p><p class="source-code">_,err = remove.Exec(2)</p><p class="source-code">if err != nil{</p><p class="source-code">  panic(err)</p><p class="source-code">}else{</p><p class="source-code">  fmt.Println("The second user was successfully removed!")</p><p class="source-code">}</p><p class="source-code">remove.Close()</p></li>
				<li>Since our job is done, we should close the connection to the database:<p class="source-code">db.Close()</p></li>
			</ol>
			<p>Upon successful completion, you should see the following output:</p>
			<div>
				<div id="_idContainer350" class="IMG---Figure">
					<img src="image/B14177_13_10.jpg" alt="Figure 13.10: Possible output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.10: Possible output</p>
			<h2 id="_idParaDest-501"><a id="_idTextAnchor580"/>Activity 13.2: Finding Messages of Specific Users</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Initialize your script with the appropriate imports. Let's call it <strong class="source-inline">main.go</strong>. Prepare an empty <strong class="source-inline">main()</strong> function:<p class="source-code">package main</p><p class="source-code">import "fmt"</p><p class="source-code">import "bufio"</p><p class="source-code">import "os"</p><p class="source-code">import "strings"</p><p class="source-code">import "database/sql"</p><p class="source-code">import _ "github.com/lib/pq"</p><p class="source-code">func main(){</p><p class="source-code">}</p></li>
				<li>Let's define a <strong class="source-inline">struct</strong> that will hold the messages we want to insert:<p class="source-code">type Messages struct {</p><p class="source-code">  UserID int</p><p class="source-code">  Message string</p><p class="source-code">}</p></li>
				<li>We will need four variables that will be used later:<p class="source-code">var toLookFor string</p><p class="source-code">var message string</p><p class="source-code">var email string</p><p class="source-code">var name string</p></li>
				<li>Create a <strong class="source-inline">reader</strong> function that will acquire the input from the user when the time comes:<p class="source-code">reader := bufio.NewReader(os.Stdin)</p></li>
				<li>Now, create the actual messages:<p class="source-code">messages := []Messages{</p><p class="source-code">  {1,"Hi Florian, when are you coming home?"},</p><p class="source-code">  {1,"Can you send some cash?"},</p><p class="source-code">  {2,"Hi can you bring some bread and milk?"},</p><p class="source-code">  {7,"Well..."},</p><p class="source-code">}</p></li>
				<li>Connect to the database:<p class="source-code">db, err := sql.Open("postgres", "user=postgres password=Start!123   host=127.0.0.1 port=5432 dbname=postgres sslmode=disable")</p><p class="source-code">if err != nil {</p><p class="source-code">  panic(err)</p><p class="source-code">}else{</p><p class="source-code">  fmt.Println("The connection to the DB was successfully initialized!")</p><p class="source-code">}</p></li>
				<li>Check the connectivity to the database:<p class="source-code">connectivity := db.Ping()</p><p class="source-code">if connectivity != nil{</p><p class="source-code">  panic(connectivity)</p><p class="source-code">}else{</p><p class="source-code">  fmt.Println("Good to go!")</p><p class="source-code">}</p></li>
				<li>If the connection is fine, we can craft our table creation script:<p class="source-code">TableCreate := `</p><p class="source-code">CREATE TABLE public.messages</p><p class="source-code">(</p><p class="source-code">    UserID integer NOT NULL,</p><p class="source-code">    Message character varying(280) COLLATE pg_catalog."default" NOT NULL</p><p class="source-code">)</p><p class="source-code">WITH (</p><p class="source-code">    OIDS = FALSE</p><p class="source-code">)</p><p class="source-code">TABLESPACE pg_default;</p><p class="source-code">ALTER TABLE public.messages</p><p class="source-code">    OWNER to postgres;</p><p class="source-code">`</p></li>
				<li>Create the table to hold the messages:<p class="source-code">_,err = db.Exec(TableCreate)</p><p class="source-code">if err != nil {</p><p class="source-code">  panic(err)</p><p class="source-code">} else{</p><p class="source-code">  fmt.Println("The table called Messages was successfully created!")</p><p class="source-code">}</p></li>
				<li>Once the table is ready, insert the messages:<p class="source-code">insertMessages, insertErr := db.Prepare("INSERT INTO messages   VALUES($1,$2)")</p><p class="source-code">if insertErr != nil{</p><p class="source-code">  panic(insertErr)</p><p class="source-code">}</p><p class="source-code">for _, u := range messages{</p><p class="source-code">  _, err = insertMessages.Exec(u.UserID,u.Message)</p><p class="source-code">  if err != nil{</p><p class="source-code">    panic(err)</p><p class="source-code">  }else{</p><p class="source-code">    fmt.Println("The UserID:",u.UserID,"with message:",u.Message,"was   successfully added!")</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">insertMessages.Close()</p></li>
				<li>Now that you have messages, you can ask for the user's name to look for when filtering the messages:<p class="source-code">fmt.Print("Give me the user's name: ")</p><p class="source-code">toLookFor, err = reader.ReadString('\n')</p><p class="source-code">toLookFor = strings.TrimRight(toLookFor, "\r\n")</p><p class="source-code">if err != nil{</p><p class="source-code">  panic(err)</p><p class="source-code">} else {</p><p class="source-code">  fmt.Println("Looking for all the messages of user with   name:",toLookFor,"##")</p><p class="source-code">}</p></li>
				<li>The following query will give us the desired result:<p class="source-code">UserMessages := "SELECT users.Name, users.Email, messages.Message FROM   messages INNER JOIN users ON users.ID=messages.UserID WHERE users.Name     LIKE $1"</p></li>
				<li>Now execute the filter query and check how many records were returned:<p class="source-code">usersMessages, err := db.Prepare(UserMessages)</p><p class="source-code">if err != nil {</p><p class="source-code">  panic(err)</p><p class="source-code">}</p><p class="source-code">result, err := usersMessages.Query(toLookFor)</p><p class="source-code">numberof := 0</p><p class="source-code">for result.Next(){</p><p class="source-code">  numberof++</p><p class="source-code">}</p></li>
				<li>Based on the number of results, print the appropriate messages:<p class="source-code">if numberof == 0 {</p><p class="source-code">   fmt.Println("The query returned nothing, no such user:",toLookFor)</p><p class="source-code">}else{</p><p class="source-code">  fmt.Println("There are a total of",numberof,"messages from the     user:",toLookFor)</p><p class="source-code">  result, err := usersMessages.Query(toLookFor)</p><p class="source-code">  for result.Next(){</p><p class="source-code">    err = result.Scan(&amp;name, &amp;email, &amp;message)</p><p class="source-code">    if err != nil{</p><p class="source-code">    panic(err)</p><p class="source-code">    }</p><p class="source-code">    fmt.Println("The user:",name,"with email:",email,"has sent the following       message:",message)</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">usersMessages.Close()</p></li>
				<li>Finally, close the database connection:<p class="source-code">db.Close()</p><p>This should be the output, depending on how you fill your database with usernames and messages:</p></li>
			</ol>
			<div>
				<div id="_idContainer351" class="IMG---Figure">
					<img src="image/B14177_13_09.jpg" alt="Figure 13.11: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.11: Expected output</p>
			<h1 id="_idParaDest-502"><a id="_idTextAnchor581"/>Chapter 14: Using the Go HTTP Client</h1>
			<h2 id="_idParaDest-503"><a id="_idTextAnchor582"/>Activity 14.01: Requesting Data from a Web Server and Processing the Response</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Add the necessary<a id="_idTextAnchor583"/><a id="_idTextAnchor584"/> imports:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">    "encoding/json"</p><p class="source-code">    "fmt"</p><p class="source-code">    "io/ioutil"</p><p class="source-code">    "log"</p><p class="source-code">    "net/http"</p><p class="source-code">)</p><p>Here, <strong class="source-inline">encoding/json</strong> is used to parse the response and marshal it into the structs. <strong class="source-inline">fmt</strong> is used to print out the counts and <strong class="source-inline">io/ioutil</strong> is used to read in the response body. <strong class="source-inline">log</strong> is used if something goes wrong to output the error. <strong class="source-inline">net/http</strong> is what we use to do the GET request.</p></li>
				<li>Create structs to parse the data:<p class="source-code">type Names struct {</p><p class="source-code">    Names []string `json:"names"`</p><p class="source-code">}</p></li>
				<li>Create a function called <strong class="source-inline">getDataAndParseResponse()</strong> that returns two integers:<p class="source-code">func getDataAndParseResponse() (int, int) {</p></li>
				<li>Send a <strong class="source-inline">GET</strong> reques<a id="_idTextAnchor585"/>t to the server:<p class="source-code">    r, err := http.Get("http://localhost:8080")</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p></li>
				<li>Parse the response data:<p class="source-code">    defer r.Body.Close()</p><p class="source-code">    data, err := ioutil.ReadAll(r.Body)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p><p class="source-code">    names := Names{}</p><p class="source-code">    err = json.Unmarshal(data, &amp;names)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p></li>
				<li>Loop through the names and count the occurrences of each:<p class="source-code">    electricCount := 0</p><p class="source-code">    boogalooCount := 0</p><p class="source-code">    for _, name := range names.Names {</p><p class="source-code">        if name == "Electric" {</p><p class="source-code">            electricCount++</p><p class="source-code">        } else if name == "Boogaloo" {</p><p class="source-code">            boogalooCount++</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>Return the counts:<p class="source-code">    return electricCount, boogalooCount</p></li>
				<li>Print the counts:<a id="_idTextAnchor586"/><p class="source-code">func main() {</p><p class="source-code">    electricCount, boogalooCount := getDataAndParseResponse()</p><p class="source-code">    fmt.Println("Electric Count: ", electricCount)</p><p class="source-code">    fmt.Println("Boogaloo Count: ", boogalooCount)</p><p class="source-code">}</p></li>
				<li>Here is the code <a id="_idTextAnchor587"/><a id="_idTextAnchor588"/>for the server of this activity:</li>
			</ol>
			<p class="source-code-heading">server.go</p>
			<p class="source-code">12 func (srv server) ServeHTTP(w http.ResponseWriter, r      *http.Request) {</p>
			<p class="source-code">13     names := Names{}</p>
			<p class="source-code">14     // Generate random number of 'Electric' names</p>
			<p class="source-code">15     for i := 0; i &lt; rand.Intn(5)+1; i++ {</p>
			<p class="source-code">16         names.Names = append(names.Names, "Electric")</p>
			<p class="source-code">17     }</p>
			<p class="source-code">18     // Generate random number of 'Boogaloo' names</p>
			<p class="source-code">19     for i := 0; i &lt; rand.Intn(5)+1; i++ {</p>
			<p class="source-code">20         names.Names = append(names.Names, "Boogaloo")</p>
			<p class="source-code">21     }</p>
			<p class="source-code">22     // convert struct to bytes</p>
			<p class="source-code">23     jsonBytes, _ := json.Marshal(names)</p>
			<p class="source-code">24     log.Println(string(jsonBytes))</p>
			<p class="source-code">25     w.Write(jsonBytes)</p>
			<p class="source-code">26 }</p>
			<p class="source-code-link">The full code is available at: <a href="https://packt.live/2sfnWaR">https://packt.live/2sfnWaR</a></p>
			<p>Add this code to the <strong class="source-inline">server.go</strong> file you created and run it. This will create a server you can connect your client to. Once you have created it, you should be able to run it and see a similar output to this:</p>
			<div>
				<div id="_idContainer352" class="IMG---Figure">
					<img src="image/B14177_14_10.jpg" alt="Figure 14.10: Possible output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.10: Possible output</p>
			<h2 id="_idParaDest-504"><a id="_idTextAnchor589"/>Activity 14.02: Sending Data to a Web Server and Checking Whether the Data Was Received Using POST and GET</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Add all the requir<a id="_idTextAnchor590"/><a id="_idTextAnchor591"/>ed imports:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">    "bytes"</p><p class="source-code">    "encoding/json"</p><p class="source-code">    "errors"</p><p class="source-code">    "fmt"</p><p class="source-code">    "io/ioutil"</p><p class="source-code">    "log"</p><p class="source-code">    "net/http"</p><p class="source-code">)</p></li>
				<li>Create the structs needed to send requests and receive responses:<p class="source-code">var url = "http://localhost:8088"</p><p class="source-code">type Name struct {</p><p class="source-code">    Name string `json:"name"`</p><p class="source-code">}</p><p class="source-code">type Names struct {</p><p class="source-code">    Names []string `json:"names"`</p><p class="source-code">}</p><p class="source-code">type Resp struct {</p><p class="source-code">    OK bool `json:"ok"`</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">addNameAndParseResponse</strong> function:<p class="source-code">func addNameAndParseResponse(nameToAdd string) error {</p></li>
				<li>Create a <strong class="source-inline">name</strong> str<a id="_idTextAnchor592"/>uct, <strong class="source-inline">Marshal</strong> it to <strong class="source-inline">json</strong>, and POST it to the URL:<p class="source-code">    name := Name{Name: nameToAdd}</p><p class="source-code">    nameBytes, err := json.Marshal(name)</p><p class="source-code">    if err != nil {</p><p class="source-code">        return err</p><p class="source-code">    }</p><p class="source-code">    r, err := http.Post(fmt.Sprintf("%s/addName", url),      "text/json", bytes.NewReader(nameBytes))</p><p class="source-code">    if err != nil {</p><p class="source-code">        return err</p><p class="source-code">    }</p></li>
				<li>Parse the response from the POST request:<p class="source-code">    defer r.Body.Close()</p><p class="source-code">    data, err := ioutil.ReadAll(r.Body)</p><p class="source-code">    if err != nil {</p><p class="source-code">        return err</p><p class="source-code">    }</p><p class="source-code">    resp := Resp{}</p><p class="source-code">    err = json.Unmarshal(data, &amp;resp)</p><p class="source-code">    if err != nil {</p><p class="source-code">        return err</p><p class="source-code">    }</p></li>
				<li>Check that the response returns OK:<p class="source-code">    if !resp.OK {</p><p class="source-code">        return errors.New("response not ok")</p><p class="source-code">    }</p><p class="source-code">    return nil</p></li>
				<li>Create the <strong class="source-inline">getDataAndParseResponse</strong> function:<p class="source-code">func getDataAndParseResponse() []string {</p></li>
				<li>Send a GET request<a id="_idTextAnchor593"/> to the server and read the body:<p class="source-code">    r, err := http.Get(fmt.Sprintf("%s/", url))</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p><p class="source-code">    // get data from the response body</p><p class="source-code">    defer r.Body.Close()</p><p class="source-code">    data, err := ioutil.ReadAll(r.Body)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p></li>
				<li>Unmarshal the response into the <strong class="source-inline">Names</strong> struct and return the <strong class="source-inline">names</strong> array:<p class="source-code">    names := Names{}</p><p class="source-code">    err = json.Unmarshal(data, &amp;names)</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p><p class="source-code">    // return the data</p><p class="source-code">    return names.Names</p></li>
				<li>Create a <strong class="source-inline">main</strong> function to add names, request the names from the server, and print them out:<p class="source-code">func main() {</p><p class="source-code">    err := addNameAndParseResponse("Electric")</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p><p class="source-code">    err = addNameAndParseResponse("Boogaloo")</p><p class="source-code">    if err != nil {</p><p class="source-code">        log.Fatal(err)</p><p class="source-code">    }</p><p class="source-code">    names := getDataAndParseResponse()</p><p class="source-code">    for _, name := range names {</p><p class="source-code">        log.Println(name)</p><p class="source-code">    }</p><p class="source-code">}</p><p>The server code is as follows:</p></li>
			</ol>
			<p class="source-code-heading">server.go</p>
			<p class="source-code">1 package main</p>
			<p class="source-code">2 import (</p>
			<p class="source-code">3     "encoding/json"</p>
			<p class="source-code">4     "log"</p>
			<p class="source-code">5     "net/http"</p>
			<p class="source-code">6 )</p>
			<p class="source-code">7 var names []string</p>
			<p class="source-code">8 type Name struct {</p>
			<p class="source-code">9     Name string `json:"name"`</p>
			<p class="source-code">10 }</p>
			<p class="source-code">11 type Names struct {</p>
			<p class="source-code">12     Names []string `json:"names"`</p>
			<p class="source-code">13 }</p>
			<p class="source-code">14 type Resp struct {</p>
			<p class="source-code">15     OK bool `json:"ok"`</p>
			<p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/2Qg5dE8">https://packt.live/2Qg5dE8</a></p>
			<p>Start the server and run your client. The client's output should be similar to the following:</p>
			<div>
				<div id="_idContainer353" class="IMG---Figure">
					<img src="image/B14177_14_11.jpg" alt="Figure 14.11: Possible output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.11: Possible output</p>
			<h1 id="_idParaDest-505"><a id="_idTextAnchor594"/>Chapter 15: HTTP Servers</h1>
			<h2 id="_idParaDest-506"><a id="_idTextAnchor595"/>Activity 15.01: Adding a Page Counter to an HTML Page</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">First, we import the necessary packages:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">"fmt"</p><p class="source-code">"log"</p><p class="source-code">"net/http"</p><p class="source-code">)</p></li>
				<li>Here, "<strong class="source-inline">net/http</strong>" is the usual package for http communication, "<strong class="source-inline">log</strong>" is the package for logging (in this case to the standard output), and "<strong class="source-inline">fmt</strong>" is the package used to format input and output. This can be used to send messages to the standard output, but we use it here just as a message formatter.</li>
				<li>We define here a type called <strong class="source-inline">PageWithCounter</strong>, which represents our handler, can count visits, and has a heading and some content for the page. The counter will increase every time the page loads:<p class="source-code">type PageWithCounter struct{</p><p class="source-code">counter int</p><p class="source-code">heading string</p><p class="source-code">content string</p><p class="source-code">}</p><p class="source-code">func(h *PageWithCounter) ServeHTTP(w http.ResponseWriter, r *http.Request)   {</p><p>This is the standard handler function for any struct implementing the <strong class="source-inline">http.Handler</strong> interface. Note first the <strong class="source-inline">*</strong> in the method receiver. In this method, we want to modify a struct's attribute to increment the counter. In order to do so, we need to specify that our method is received by a pointer so that we modify the counter permanently. Without the pointer receiver, we would always see <strong class="source-inline">1</strong> in the page (you can try to modify this and see for yourself).</p></li>
				<li>Next, increase the counter, and then we format a string with some HTML tags. The <strong class="source-inline">fmt.Sprintf</strong> function injects the variables on the right in the place where the placeholders, <strong class="source-inline">%s</strong> and <strong class="source-inline">%d</strong>, are located. The first placeholder expects a string, while the second expects a number. After that, we write, as usual, the whole string as a slice of bytes in relation to the response:<p class="source-code">   h.counter++</p><p class="source-code">   msg := fmt.Sprintf("&lt;h1&gt;%s&lt;/h1&gt;\n&lt;p&gt;%s&lt;p&gt;\n&lt;p&gt;Views: %d&lt;/p&gt;", h.heading,   h.content, h.counter)</p><p class="source-code">   w.Write([]byte(msg))</p><p class="source-code">}</p></li>
				<li>Here, we create the <strong class="source-inline">main()</strong> function and we set up three handlers, one with the heading <strong class="source-inline">hello world</strong> and some content, while the other two handlers represent the first two chapters of your book, so are instantiated accordingly. Note that the counter is not explicitly set since any integer will default to <strong class="source-inline">0</strong>, which is where our counter starts:<p class="source-code">func main() {</p><p class="source-code">  hello := PageWithCounter{heading: "Hello World",content:"This is the main   page"}</p><p class="source-code">  cha1 := PageWithCounter{heading: "Chapter 1",content:"This is the first   chapter"}</p><p class="source-code">  cha2 := PageWithCounter{heading: "Chapter 2",content:"This is the second   chapter"}</p></li>
				<li>Add the three handlers to the routes, <strong class="source-inline">/</strong>, <strong class="source-inline">/chapter1</strong>, and <strong class="source-inline">/chapter2</strong>, setting them to use the handlers created previously. Note that we need to pass references with <strong class="source-inline">&amp;</strong> as the <strong class="source-inline">ServeHTTP</strong> method has a pointer receiver:<p class="source-code">http.Handle("/", &amp;hello)</p><p class="source-code">http.Handle("/chapter1", &amp;cha1)</p><p class="source-code">http.Handle("/chapter2", &amp;cha2)</p></li>
				<li>Now, complete the code listening to a port:<p class="source-code">  log.Fatal(http.ListenAndServe(":8080", nil))</p><p class="source-code">}</p></li>
			</ol>
			<p>When you run the server, you should see the following:</p>
			<div>
				<div id="_idContainer354" class="IMG---Figure">
					<img src="image/B14177_15_39.jpg" alt="Figure 15.39: Output on the browser when you run the server for the first time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.39: Output on the browser when you run the server for the first time</p>
			<p>If you refresh the page, you should see the following:</p>
			<div>
				<div id="_idContainer355" class="IMG---Figure">
					<img src="image/B14177_15_40.jpg" alt="Figure 15.40: Output on the browser when you run the server for the second time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.40: Output on the browser when you run the server for the second time</p>
			<p>Next, navigate to <strong class="source-inline">chapter 1</strong> by typing <strong class="source-inline">localhost:8080/chapter1</strong> in the address bar. You should be able to see something along the lines of the following:</p>
			<div>
				<div id="_idContainer356" class="IMG---Figure">
					<img src="image/B14177_15_41.jpg" alt="Figure 15.41: Output on the browser when you visit the chapter1 page for the first time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.41: Output on the browser when you visit the chapter1 page for the first time</p>
			<p>Similarly, navigate to <em class="italic">chapter 2</em>, and you should be able to see the following increment in terms of the number of views:</p>
			<div>
				<div id="_idContainer357" class="IMG---Figure">
					<img src="image/B14177_15_42.jpg" alt="Figure 15.42: Output on the browser when you visit the chapter2 page for the first time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.42: Output on the browser when you visit the chapter2 page for the first time</p>
			<p>When you revisit <em class="italic">chapter 1</em>, you should see an increase in the number of views as follows:</p>
			<div>
				<div id="_idContainer358" class="IMG---Figure">
					<img src="image/B14177_15_43.jpg" alt="Figure 15.43: Output on the browser when you visit the chapter1 page for the second time&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.43: Output on the browser when you visit the chapter1 page for the second time</p>
			<h2 id="_idParaDest-507"><a id="_idTextAnchor596"/>Activity 15.02: Serving a Request with a JSON Payload</h2>
			<p><strong class="bold">Solution:</strong></p>
			<p>Although your browser may show the JSON document differently, the full solution to this activity is as follows:</p>
			<ol>
				<li value="1">We create the package and add the necessary imports, where "<strong class="source-inline">encoding/json</strong>" is the one used for formatting our document as a JSON string:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">   "encoding/json"</p><p class="source-code">   "log"</p><p class="source-code">   "net/http"</p><p class="source-code">)</p></li>
				<li>We create the <strong class="source-inline">PageWithCounter</strong> struct, which looks exactly like the one in <strong class="source-inline">Activity 1</strong>. However, some JSON tags need to be added. These tags ensure that when converting the struct into a JSON string, the attributes assume a specific name. <strong class="source-inline">Content</strong> will become <strong class="source-inline">content</strong>, but <strong class="source-inline">Heading</strong> will become <strong class="source-inline">title</strong> and <strong class="source-inline">Counter</strong> will become <strong class="source-inline">views</strong>. Note that all the attributes are now capitalized. As you already know, capitalizing the attributes makes them exported, meaning that every other package can see, and hence use, them:<p class="source-code">type PageWithCounter struct{</p><p class="source-code">   Counter int `json:"views"`</p><p class="source-code">   Heading string `json:"title"`</p><p class="source-code">   Content string `json:"content"`</p><p class="source-code">}</p></li>
				<li>We create the usual handler method to serve the page:<p class="source-code">func(h *PageWithCounter) ServeHTTP(w http.ResponseWriter, r *http.Request) {</p></li>
				<li>We increase the counter:<p class="source-code">   h.Counter++</p></li>
				<li>Now, we marshal the struct itself, <strong class="source-inline">h</strong>, into JSON through the <strong class="source-inline">json.Marshal</strong> method, which returns an array of bytes representing the JSON document and an error. Here is where the exported attributes are important. The marshaling function could not otherwise see the attributes and could not convert them, resulting in a JSON string representing an empty document:<p class="source-code">   bts, err := json.Marshal(h)</p></li>
				<li>We check for an error and, in case there is one, we write the code <strong class="source-inline">400</strong> to the response header. This means that you would not see the actual page in case of a marshaling error, but an error message:<p class="source-code">   if err!=nil {</p><p class="source-code">  w.WriteHeader(400)</p><p class="source-code">  return</p><p class="source-code">   }</p></li>
				<li>Finally, if there is no error, we write the JSON-encoded struct to the response writer:<p class="source-code">   w.Write([]byte(bts))</p><p class="source-code">}</p></li>
				<li>The remainder of the code is almost identical to that in <em class="italic">Activity 15.01</em>, the only difference being that the <strong class="source-inline">PageWithCounter</strong> structs are instantiated with capitalized attributes, given that they are now all exported:<p class="source-code">func main() {</p><p class="source-code">   hello :=PageWithCounter{Heading: "Hello World",Content:"This is the main   page"}</p><p class="source-code">   cha1 := PageWithCounter{Heading: "Chapter 1",Content:"This is the first   chapter"}</p><p class="source-code">   cha2 := PageWithCounter{Heading: "Chapter 2",Content:"This is the second   chapter"}</p><p class="source-code">   http.Handle("/", &amp;hello)</p><p class="source-code">   http.Handle("/chapter1", &amp;cha1)</p><p class="source-code">   http.Handle("/chapter2", &amp;cha2)</p><p class="source-code">   log.Fatal(http.ListenAndServe(":8080", nil))</p><p class="source-code">}</p><p>Running your server, you should see the following for the assigned routes:</p></li>
			</ol>
			<div>
				<div id="_idContainer359" class="IMG---Figure">
					<img src="image/B14177_15_44.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.44: Expected output when the handler is /</p>
			<div>
				<div id="_idContainer360" class="IMG---Figure">
					<img src="image/B14177_15_45.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.45: Expected output when the handler is /chapter1</p>
			<div>
				<div id="_idContainer361" class="IMG---Figure">
					<img src="image/B14177_15_46.jpg" alt="Figure 15.46: Expected output when the handler is /chapter2&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.46: Expected output when the handler is /chapter2</p>
			<h2 id="_idParaDest-508"><a id="_idTextAnchor597"/>Activity 15.03: External Template</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create an HTML file called <strong class="source-inline">index.html</strong>:<p class="source-code">&lt;!DOCTYPE html&gt;</p><p class="source-code">&lt;html lang="en"&gt;</p><p class="source-code">&lt;head&gt;</p><p class="source-code">  &lt;meta charset="UTF-8"&gt;</p><p class="source-code">  &lt;title&gt;Welcome&lt;/title&gt;</p><p class="source-code">&lt;/head&gt;</p><p class="source-code">&lt;body&gt;</p></li>
				<li>In the body, now add the template tags for the header:<p class="source-code">  &lt;h1&gt;Hello {{if .Name}}{{.Name}}{{else}}visitor{{end}}&lt;/h1&gt;</p><p>You can see that there is an <strong class="source-inline">if</strong> statement that displays the <strong class="source-inline">Name</strong> attribute if it is not empty, otherwise it displays the <strong class="source-inline">visitor</strong> string.</p></li>
				<li>Now, complete the HTML file with a welcome message and the closing tags:<p class="source-code">  &lt;p&gt;May I give you a warm welcome&lt;/p&gt;</p><p class="source-code">&lt;/body&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>Now, create a <strong class="source-inline">main.go</strong> file and start adding the package and imports:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">   "html/template"</p><p class="source-code">   "log"</p><p class="source-code">   "net/http"</p><p class="source-code">   "strings"</p><p class="source-code">)</p></li>
				<li>Now, create the <strong class="source-inline">Visitor</strong> struct, which is a struct used as a model for our template. It only includes the <strong class="source-inline">Name</strong> field, as this is the only thing we care about. Note that we have been using structs up to this point as they are safer, but you could pass a <strong class="source-inline">map[string]string</strong> to your templates directly and it would work. Structs, however, allow us to perform better sanitization. Write the following:<p class="source-code">type Visitor struct {</p><p class="source-code">   Name string</p><p class="source-code">}</p></li>
				<li>Now, create a handler. This is just a struct holding a pointer to a template:<p class="source-code">type Hello struct {</p><p class="source-code">   tpl *template.Template</p><p class="source-code">}</p></li>
				<li>This now needs to implement the handler interface:<p class="source-code">func (h Hello) ServeHTTP(w http.ResponseWriter, r *http.Request) {</p></li>
				<li>Now, we need to get the requests in the querystring, so write the following:<p class="source-code">   vl := r.URL.Query()</p></li>
				<li>We now need to create a visitor for this request, so execute the following command:<p class="source-code">   cust := Visitor{}</p><p class="source-code">   name, ok := vl["name"]</p></li>
				<li>If the name exists, then implode the content to have a string in case we have multiple names:<p class="source-code">   if ok {</p><p class="source-code">  cust.Name = strings.Join(name, ",")</p><p class="source-code">   }</p></li>
				<li>Now, execute the template to get the full page and pass it to the response writer to serve the file template:<p class="source-code">   h.tpl.Execute(w, cust)</p><p class="source-code">}</p></li>
				<li>Now, create a function to instantiate a new page with a specific template file, returning a <strong class="source-inline">Hello</strong> template pointer:<p class="source-code">// NewHello returns a new Hello handler</p><p class="source-code">func NewHello(tplPath string) (*Hello, error){</p></li>
				<li>Parse the template and assign a variable to it:<p class="source-code">   tmpl, err := template.ParseFiles(tplPath)</p><p class="source-code">   if err != nil {</p><p class="source-code">  return nil, err</p><p class="source-code">   }</p></li>
				<li>Return the <strong class="source-inline">Hello</strong> template with the template file set for it:<p class="source-code">   return &amp;Hello{tmpl}, nil</p><p class="source-code">}</p></li>
				<li>Create the <strong class="source-inline">main()</strong> function to run:<p class="source-code">func main() {</p></li>
				<li>Now, use the <strong class="source-inline">NewHello</strong> function to create a page for the <strong class="source-inline">index.html</strong> template:<p class="source-code">   hello, err := NewHello("./index.html")</p><p class="source-code">   if err != nil {</p><p class="source-code">  log.Fatal(err)</p><p class="source-code">   }</p></li>
				<li>Handle the base path with the instantiated template:<p class="source-code">   http.Handle("/", hello)</p></li>
				<li>Run the server on your favorite port and exit in the event of an error:<p class="source-code">   log.Fatal(http.ListenAndServe(":8080", nil))</p><p class="source-code">}</p><p>The output will be as follows:</p></li>
			</ol>
			<div>
				<div id="_idContainer362" class="IMG---Figure">
					<img src="image/B14177_15_47.jpg" alt="Figure 15.47: Anonymous visitor page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.47: Anonymous visitor page</p>
			<p>And the visitor page including the name will look something like the following screenshot:</p>
			<div>
				<div id="_idContainer363" class="IMG---Figure">
					<img src="image/B14177_15_48.jpg" alt="Figure 15.48: Visitor page with the name &quot;Will&quot;&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.48: Visitor page with the name "Will"</p>
			<h1 id="_idParaDest-509"><a id="_idTextAnchor598"/>Chapter 16: Concurrent Work</h1>
			<h2 id="_idParaDest-510"><a id="_idTextAnchor599"/>Activity 16.01: Listing Numbers</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create the <strong class="source-inline">main.go</strong> file and import the necessary packages:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">    "fmt"</p><p class="source-code">    "log"</p><p class="source-code">    "sync"</p><p class="source-code">)</p></li>
				<li>Define a function called <strong class="source-inline">sum()</strong>, which will use a pointer to a string to hold the result:<p class="source-code">func sum(from,to int, wg *sync.WaitGroup, res *string, mtx *sync.Mutex) {</p><p class="source-code">    for i:=from;i&lt;=to; i++ {</p><p class="source-code">        mtx.Lock()</p><p class="source-code">        *res = fmt.Sprintf("%s|%d|",*res, i)</p><p class="source-code">        mtx.Unlock()</p><p class="source-code">    }</p><p class="source-code">    wg.Done()</p><p class="source-code">    return</p><p class="source-code">}</p></li>
				<li>Create then the <strong class="source-inline">main()</strong> function to perform the sums:<p class="source-code">func main() {</p><p class="source-code">    s1 := ""</p><p class="source-code">    mtx := &amp;sync.Mutex{}</p><p class="source-code">    wg := &amp;sync.WaitGroup{}</p><p class="source-code">    wg.Add(4)</p><p class="source-code">    go sum(1,25, wg,&amp;s1, mtx)</p><p class="source-code">    go sum(26,50, wg, &amp;s1, mtx)</p><p class="source-code">    go sum(51,75, wg, &amp;s1, mtx)</p><p class="source-code">    go sum(76,100, wg, &amp;s1, mtx)</p><p class="source-code">    wg.Wait()</p><p class="source-code">    log.Println(s1)</p><p class="source-code">}</p><p>Let's analyze the code in steps:</p></li>
			</ol>
			<ol>
				<li value="1">Let's look at the <strong class="source-inline">sum()</strong> funct<a id="_idTextAnchor600"/>ion:<p class="source-code">func sum(from,to int, wg *sync.WaitGroup, res *string, mtx *sync.Mutex) {</p><p class="source-code">    for i:=from;i&lt;=to; i++ {</p><p>Here, we create a function whose signature contains a range, <strong class="source-inline">from</strong>, <strong class="source-inline">to int</strong>, and then a WaitGroup, a string pointer that is going to be used to modify the value of the shared string, and finally a pointer to a mutex to synchronize the work on the string. After that, we create a loop in the defined range.</p></li>
				<li>The next step is:<p class="source-code">        mtx.Lock()</p><p class="source-code">        *res = fmt.Sprintf("%s|%d|",*res, i)</p><p class="source-code">        mtx.Unlock()</p><p class="source-code">    }</p><p>Here, we lock the execution and add the current value of <strong class="source-inline">i</strong> as string at the end of the current value of <strong class="source-inline">s</strong>. Then, we unlock the process and end the loop.</p></li>
				<li>At this point, we tell the WaitGroup that the routine has finished its computation and that it terminates here:<p class="source-code">    wg.Done()</p><p class="source-code">    return</p><p class="source-code">}</p></li>
				<li>Next, we define the <strong class="source-inline">main()</strong> function:<p class="source-code">func main() {</p><p class="source-code">    s1 := ""</p><p class="source-code">    mtx := &amp;sync.Mutex{}</p><p class="source-code">    wg := &amp;sync.WaitGroup{}</p><p>We set a starting string to <strong class="source-inline">""</strong>, then we instantiate a <strong class="source-inline">mutex</strong> and a WaitGroup. The code is then pretty similar to what you've seen in the previous exercises, which is running the four Goroutines and logging the result.</p></li>
				<li>When you run your program you should see something like this:<div id="_idContainer364" class="IMG---Figure"><img src="image/B14177_16_05.jpg" alt="Figure 16.5: First output when listing numbers&#13;&#10;"/></div><p class="figure-caption">Figure 16.5: First output when listing numbers</p></li>
				<li>However, if you run it again multiple times, you will see that most likely you will have a different result. This is due to concurrency because the order of execution by the machine is uncertain:</li>
			</ol>
			<div>
				<div id="_idContainer365" class="IMG---Figure">
					<img src="image/B14177_16_06.jpg" alt="Figure 16.6: Second attempt of listing numbers returns with a different order&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.6: Second attempt of listing numbers returns with a different order</p>
			<h2 id="_idParaDest-511"><a id="_idTextAnchor601"/>Activity 16.02: Source Files</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create the <strong class="source-inline">main</strong> package with the following imports:<p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">    "bufio"</p><p class="source-code">    "fmt"</p><p class="source-code">    "os"</p><p class="source-code">    "strconv"</p><p class="source-code">    "strings"</p><p class="source-code">    "sync"</p><p class="source-code">)</p></li>
				<li>Create the <strong class="source-inline">source()</strong> function to read numbers from a file and send them to a channel:<p class="source-code">func source(filename string, out chan int, wg *sync.WaitGroup)  {</p><p class="source-code">    f, err :=  os.Open(filename)</p><p class="source-code">    if err != nil {</p><p class="source-code">        panic(err)</p><p class="source-code">    }</p><p class="source-code">    rd := bufio.NewReader(f)</p><p class="source-code">    for {</p><p class="source-code">        str, err := rd.ReadString('\n')</p><p class="source-code">        if err != nil {</p><p class="source-code">            if err.Error() == "EOF" {</p><p class="source-code">                wg.Done()</p><p class="source-code">                return</p><p class="source-code">            } else {</p><p class="source-code">                panic(err)</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">        iStr := strings.ReplaceAll(str, "\n", "")</p><p class="source-code">        i, err := strconv.Atoi(iStr)</p><p class="source-code">        if err != nil {</p><p class="source-code">            panic(err)</p><p class="source-code">        }</p><p class="source-code">        out &lt;- i</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Now create the <strong class="source-inline">splitter()</strong> function to receive the numbers and then send them to two different channels, one for <strong class="source-inline">odd</strong> numbers and one for <strong class="source-inline">even</strong> numbers:<p class="source-code">func splitter(in, odd, even chan int, wg *sync.WaitGroup)  {</p><p class="source-code">    for i := range in {</p><p class="source-code">        switch i%2 {</p><p class="source-code">        case 0:</p><p class="source-code">            even &lt;- i</p><p class="source-code">        case 1:</p><p class="source-code">            odd &lt;- i</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    close(even)</p><p class="source-code">    close(odd)</p><p class="source-code">    wg.Done()</p><p class="source-code">)</p></li>
				<li>Now write a function to sum the numbers coming in and send the <strong class="source-inline">sum</strong> to an outbound channel:<p class="source-code">func sum(in, out chan int, wg *sync.WaitGroup) {</p><p class="source-code">    sum := 0</p><p class="source-code">    for i := range in {</p><p class="source-code">        sum += i</p><p class="source-code">    }</p><p class="source-code">    out &lt;- sum</p><p class="source-code">    wg.Done()</p><p class="source-code">}</p></li>
				<li>Now create a <strong class="source-inline">merger()</strong> function that will output the <strong class="source-inline">sum</strong> of the even and odd numbers:<p class="source-code">func merger(even, odd chan int, wg *sync.WaitGroup, resultFile string) {</p><p class="source-code">    rs, err := os.Create(resultFile)</p><p class="source-code">    if err != nil {</p><p class="source-code">        panic(err)</p><p class="source-code">    }</p><p class="source-code">    for i:= 0; i&lt; 2; i++{</p><p class="source-code">        select {</p><p class="source-code">        case i:= &lt;- even:</p><p class="source-code">            rs.Write([]byte(fmt.Sprintf("Even %d\n", i)))</p><p class="source-code">        case i:= &lt;- odd:</p><p class="source-code">            rs.Write([]byte(fmt.Sprintf("Odd %d\n", i)))</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    wg.Done()</p><p class="source-code">}</p></li>
				<li>Now create the <strong class="source-inline">main()</strong> function, where you initialize all the channels and call all the functions you created earlier in order to produce the <strong class="source-inline">sum</strong>:<p class="source-code">func main() {</p><p class="source-code">    wg := &amp;sync.WaitGroup{}</p><p class="source-code">    wg.Add(2)</p><p class="source-code">    wg2 := &amp;sync.WaitGroup{}</p><p class="source-code">    wg2.Add(4)</p><p class="source-code">    odd := make(chan int)</p><p class="source-code">    even := make(chan int)</p><p class="source-code">    out := make(chan int)</p><p class="source-code">    sumodd := make(chan int)</p><p class="source-code">    sumeven := make(chan int)</p><p class="source-code">    go source("./input1.dat", out, wg)</p><p class="source-code">    go source("./input2.dat", out, wg)</p><p class="source-code">    go splitter(out, odd, even, wg2)</p><p class="source-code">    go sum(even, sumeven, wg2)</p><p class="source-code">    go sum(odd, sumodd,wg2)</p><p class="source-code">    go merger(sumeven, sumodd, wg2, "./result.txt")</p><p class="source-code">    wg.Wait()</p><p class="source-code">    close(out)</p><p class="source-code">    wg2.Wait()</p><p class="source-code">}</p><p>Let's analyze the code in a bit more detail.</p></li>
				<li>In the <strong class="source-inline">source</strong> function, we have a filename for the input file to open, a channel to pipe messages in, and a WaitGroup to notify the end of the process. This function will run as two Goroutines, one per input file. Inside this function, we read from the file line by line. You should have already learned how to read from files, and there are several optimized ways to do that. Here, we just read line by line with:<p class="source-code">rd := bufio.NewReader(f)</p><p class="source-code">    for {</p><p class="source-code">        str, err := rd.ReadString('\n')</p><p>So, we are creating a buffered reader on the file <strong class="source-inline">f</strong> and then looping the <strong class="source-inline">ReadString</strong> function with the newline character <strong class="source-inline">'\n'</strong> as the delimiter. Be mindful that it has to be with single quotes and not <strong class="source-inline">"\n"</strong> because the delimiter is a character and not a string.</p></li>
				<li>After that, we handle the errors, and if an end of file error (<strong class="source-inline">EOF)</strong> occurs, we just terminate the function. Note that if we don't do this, the code just panics:<p class="source-code">if err.Error() == "EOF" {</p><p class="source-code">                wg.Done()</p><p class="source-code">                return</p><p class="source-code">            }</p></li>
				<li>We also need to strip the line so that we just have the number:<p class="source-code">iStr := strings.ReplaceAll(str, "\n", "")</p><p class="source-code">        i, err := strconv.Atoi(iStr)</p><p class="source-code">        if err != nil {</p><p class="source-code">            panic(err)</p><p class="source-code">        }</p><p class="source-code">        out &lt;- i</p><p class="source-code">    }</p><p class="source-code">}</p><p>Here, we replace the last part of the string, <strong class="source-inline">"\n"</strong>, with an empty string. After that we convert the text to an integer and if it is not an integer, we panic again. At the end, we just pipe out the number and complete the function.</p></li>
				<li>Next step is to create a splitting function:<p class="source-code">func splitter(in, odd, even chan int, wg *sync.WaitGroup)  {</p></li>
				<li>This function has a channel to get numbers from the sources and two channels to pipe numbers to; one for the even numbers and one for the odd numbers. A Waitgroup is used again to notify the main routine of completion. The purpose of this function is to split the numbers so we can loop over the channel:<p class="source-code">    for i := range in {</p></li>
				<li>Inside the for loop, we can identify the odd and even numbers using <strong class="source-inline">switch</strong>:<p class="source-code">        switch i%2 {</p><p class="source-code">        case 0:</p><p class="source-code">            even &lt;- i</p><p class="source-code">        case 1:</p><p class="source-code">            odd &lt;- i</p><p class="source-code">        }</p><p class="source-code">    }</p><p>This code splits the numbers depending on the remainder of division by 2. If the remainder is 0, the number is even and is piped to the even channel, odd otherwise.</p></li>
				<li>We close the channels to notify the next process in the line:<p class="source-code">    close(even)</p><p class="source-code">    close(odd)</p><p class="source-code">    wg.Done()</p><p class="source-code">}</p></li>
				<li>We now have the splitter, but we need to sum the messages piped in, and this is done with a function that's similar to what you've seen in the previous exercises:<p class="source-code">func sum(in, out chan int, wg *sync.WaitGroup) {</p><p class="source-code">    sum := 0</p><p class="source-code">    for i := range in {</p><p class="source-code">        sum += i</p><p class="source-code">    }</p><p class="source-code">    out &lt;- sum</p><p class="source-code">    wg.Done()</p><p class="source-code">}</p></li>
				<li> At this point, we need to merge all the results, so we use a merger:<p class="source-code">func merger(even, odd chan int, wg *sync.WaitGroup, resultFile string) {</p><p>This function holds the two channels for even and odd numbers, a Waitgroup to handle completion, and a name for the result file.</p></li>
				<li>We then begin creating the <strong class="source-inline">results.txt</strong> file:<p class="source-code">    rs, err := os.Create(resultFile)</p><p class="source-code">    if err != nil {</p><p class="source-code">        panic(err)</p><p class="source-code">    }</p></li>
				<li>We loop over the two channels for odd and even numbers:<p class="source-code">    for i:= 0; i&lt; 2; i++{</p></li>
				<li>And then we write the code to choose the channel based on the type of number:<p class="source-code">        select {</p><p class="source-code">        case i:= &lt;- even:</p><p class="source-code">            rs.Write([]byte(fmt.Sprintf("Even %d\n", i)))</p><p class="source-code">        case i:= &lt;- odd:</p><p class="source-code">            rs.Write([]byte(fmt.Sprintf("Odd %d\n", i)))</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    wg.Done()</p><p class="source-code">}</p><p>Writing to the file is done using the <strong class="source-inline">Write</strong> method, which in turn needs bytes. That way, we transform the string containing the type of numbers added (<strong class="source-inline">odd</strong>, <strong class="source-inline">even</strong>) and their sum into bytes.</p></li>
				<li>We now orchestrate everything in the main function:<p class="source-code">func main() {</p><p class="source-code">    wg := &amp;sync.WaitGroup{}</p><p class="source-code">    wg.Add(2)</p><p class="source-code">    wg2 := &amp;sync.WaitGroup{}</p><p class="source-code">    wg2.Add(4)</p></li>
				<li>We used two Waitgroups here; one for the sources and one for the rest of the routines. You will see why soon.</li>
				<li>Next, we create all the channels we need:<p class="source-code">    odd := make(chan int)</p><p class="source-code">    even := make(chan int)</p><p class="source-code">    out := make(chan int)</p><p class="source-code">    sumodd := make(chan int)</p><p class="source-code">    sumeven := make(chan int)</p><p><strong class="source-inline">out</strong> is the channel used by the source functions to pipe the messages to the splitter, <strong class="source-inline">odd</strong> and <strong class="source-inline">even</strong> are the ones where the numbers are piped for being summed, and the last two are the ones holding a single number with the sum.</p></li>
				<li>We then start all the routines we need:<p class="source-code">    go source("./input1.dat", out, wg)</p><p class="source-code">    go source("./input2.dat", out, wg)</p><p class="source-code">    go splitter(out, odd, even, wg2)</p><p class="source-code">    go sum(even, sumeven, wg2)</p><p class="source-code">    go sum(odd, sumodd,wg2)</p><p class="source-code">    go merger(sumeven, sumodd, wg2, "./result.txt")</p></li>
				<li>We then wait for the routines to finish:<p class="source-code">    wg.Wait()</p><p class="source-code">    close(out)</p><p>Please note that here, we could have used more than two files. You could have even used an arbitrary number of files. Hence, there is no way for the splitter to know how to terminate the execution, so we close the channel after the sources have finished piping numbers in. </p></li>
				<li>After that, we have a second Waitgroup for the rest. Essentially, we need to keep all the routines running until the last sum has been added:<p class="source-code">    wg2.Wait()</p><p class="source-code">}</p></li>
				<li>While the files you can use as input can be different, use the following two files to test the output. <p><strong class="source-inline">input1.dat</strong></p><p class="source-code">1</p><p class="source-code">2</p><p class="source-code">5</p><p><strong class="source-inline">input2.dat</strong></p><p class="source-code">3</p><p class="source-code">4</p><p class="source-code">6</p><p>Note the newline at the end of each file.</p></li>
				<li>Now that you have created the input file, run the following command: <p class="source-code">go run main.go</p><p>You should see a file called <strong class="source-inline">results.txt</strong> with the following content. </p><p class="source-code">Odd 9</p><p class="source-code">Even 12</p></li>
			</ol>
			<h1 id="_idParaDest-512"><a id="_idTextAnchor602"/>Chapter 17: Using Go Tools</h1>
			<h2 id="_idParaDest-513"><a id="_idTextAnchor603"/>Activity 17.01: Using gofmt, goimport, go vet, and go get to Correct a File</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Run <strong class="source-inline">gofmt</strong> against the file to check for any formatting issues and see that they make sense:<p class="source-code">gofmt main.go</p><p>This should output a much neater-looking file, as follows:</p><div id="_idContainer366" class="IMG---Figure"><img src="image/B14177_17_11.jpg" alt="Figure 17.11: Expected output from gofmt&#13;&#10;"/></div><p class="figure-caption">Figure 17.11: Expected output from gofmt</p></li>
				<li>Use the <strong class="source-inline">-w</strong> option on <strong class="source-inline">gofmt</strong> to make the changes to the file and save them:<p class="source-code">gofmt -w main.go</p></li>
				<li>Check the imports are correct using <strong class="source-inline">goimports</strong>:<p class="source-code">goimport main.go</p></li>
				<li>Use <strong class="source-inline">goimports</strong> to fix the import statements in the file:<p class="source-code">goimports -w main.go</p></li>
				<li>The final stage is to use <strong class="source-inline">go vet</strong> to check for any issues the compiler might miss. Run it against <strong class="source-inline">main.go</strong> to check for any issues:<p class="source-code">go vet main.go</p></li>
				<li>It will find an issue with unreachable code, as shown in the following output:<div id="_idContainer367" class="IMG---Figure"><img src="image/B14177_17_12.jpg" alt="Figure 17.12: Expected output from go vet&#13;&#10;"/></div><p class="figure-caption">Figure 17.12: Expected output from go vet</p></li>
				<li>Correct the issue by moving the <strong class="source-inline">log.Println("completed")</strong> line so that it runs before the <strong class="source-inline">return</strong> statement:<p class="source-code">func ExampleHandler(w http.ResponseWriter, r *http.Request) {</p><p class="source-code">  w.WriteHeader(http.StatusOK)</p><p class="source-code">  fmt.Fprintf(w, "Hello Packt")</p><p class="source-code">  log.Println("completed")</p><p class="source-code">  return</p><p class="source-code">}</p></li>
				<li>You should ensure that you have the third-party package downloaded by running <strong class="source-inline">go get</strong>:<p class="source-code">go get github.com/gorilla/mux</p></li>
				<li>This will start the web server:<div id="_idContainer368" class="IMG---Figure"><img src="image/B14177_17_13.jpg" alt="Figure 17.13: Expected output when running the code&#13;&#10;"/></div><p class="figure-caption">Figure 17.13: Expected output when running the code</p></li>
				<li>You can check whether it worked by going to <strong class="source-inline">http://localhost:8888</strong> in your web browser:</li>
			</ol>
			<div>
				<div id="_idContainer369" class="IMG---Figure">
					<img src="image/B14177_17_14.jpg" alt="Figure 17.14: Expected output when accessing the web server through Firefox&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.14: Expected output when accessing the web server through Firefox</p>
			<h1 id="_idParaDest-514"><a id="_idTextAnchor604"/>Chapter 18: Security</h1>
			<h2 id="_idParaDest-515"><a id="_idTextAnchor605"/>Activity 18.01: Authenticating Users on the Application Using Hashed Passwords</h2>
			<p><strong class="bold">Solution:</strong></p>
			<ol>
				<li value="1">Create a <strong class="source-inline">main.go</strong> file and import the following packages:<p><strong class="source-inline">crypto/sha512</strong>: This package will provide the hashing required to encrypt the password.</p><p><strong class="source-inline">database/sql</strong>: The database to store user details will be created using this package.</p><p><strong class="source-inline">github.com/mattn/go-sqlite3</strong>: This is a third-party library used to create a <strong class="source-inline">sqlite</strong> instance for testing.</p><p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "crypto/sha512"</p><p class="source-code">  "database/sql"</p><p class="source-code">  "fmt"</p><p class="source-code">  "os"</p><p class="source-code">  _ "github.com/mattn/go-sqlite3"</p><p class="source-code">)</p></li>
				<li>Define a function called <strong class="source-inline">getConnection()</strong> to initialize a database connection:<p class="source-code">func getConnection() (*sql.DB, error) {</p><p class="source-code">  conn, err := sql.Open("sqlite3", "test.DB")</p><p class="source-code">  if err != nil {</p><p class="source-code">    return nil, fmt.Errorf("could not open db connection %v", err)</p><p class="source-code">  }</p><p class="source-code">  return conn, nil</p><p class="source-code">}</p></li>
				<li>Define helper functions to set up and tear down the database:<p class="source-code-heading">main.go</p><p class="source-code">13 var testData = []*UserDetails{</p><p class="source-code">14   {</p><p class="source-code">15     Id:       "1",</p><p class="source-code">16     Password: "1234",</p><p class="source-code">17   },</p><p class="source-code">18   {</p><p class="source-code">19     Id:       "2",</p><p class="source-code">20     Password: "5678",</p><p class="source-code">21   },</p><p class="source-code">22 }</p><p class="source-code">23 func initializeDB(db *sql.DB) error {</p><p class="source-code">24   _, err := db.Exec(`CREATE TABLE IF NOT EXISTS USER_DETAILS (USER_ID TEXT,     PASSWORD TEXT)`)</p><p class="source-code">25   if err != nil {</p><p class="source-code">26     return err</p><p class="source-code">27   }</p><p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/2sUYVlg">https://packt.live/2sUYVlg</a></p></li>
				<li>Define the <strong class="source-inline">GetPassword()</strong> function to retrieve a user password from the database:<p class="source-code">func GetPassword(db *sql.DB, userID string) (resp []byte, err error) {</p><p class="source-code">  query := `SELECT PASSWORD FROM USER_DETAILS WHERE USER_ID = ?`</p><p class="source-code">  row := db.QueryRow(query, userID)</p><p class="source-code">  switch err = row.Scan(&amp;resp); err {</p><p class="source-code">  case sql.ErrNoRows:</p><p class="source-code">    return resp, fmt.Errorf("no rows returned")</p><p class="source-code">  case nil:</p><p class="source-code">    return resp, err</p><p class="source-code">  default:</p><p class="source-code">    return resp, err</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Define a function called <strong class="source-inline">UpdatePassword()</strong> to update the user password in the database with a hashed password:<p class="source-code-heading">main.go</p><p class="source-code">55 func UpdatePassword(db *sql.DB, Id string, Password string) error {</p><p class="source-code">56   query := `UPDATE USER_DETAILS SET PASSWORD=? WHERE USER_ID=?`</p><p class="source-code">57   cipher := sha512.Sum512([]byte(Password))</p><p class="source-code">58   fmt.Printf("storing encrypted password:\n%x\n", string(cipher[:]))</p><p class="source-code">59   result, err := db.Exec(query, string(cipher[:]), Id)</p><p class="source-code">60   if err != nil {</p><p class="source-code">61     return err</p><p class="source-code">62   }</p><p class="source-code">63   rows, err := result.RowsAffected()</p><p class="source-code">64   if err != nil {</p><p class="source-code">65     return err</p><p class="source-code">66   }</p><p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/35QwJi8">https://packt.live/35QwJi8</a></p></li>
				<li>Write the <strong class="source-inline">main()</strong> function. In the <strong class="source-inline">main()</strong> function, you should set up a database connection and initialize the database with some test data. The <strong class="source-inline">UpdatePassword()</strong> function should be called to update the user password to a hashed password. The <strong class="source-inline">GetPassword()</strong> function should be called to verify the hashed password:<p class="source-code-heading">main.go</p><p class="source-code">87 func main() {</p><p class="source-code">88   db, err := getConnection()</p><p class="source-code">89   if err != nil {</p><p class="source-code">90     fmt.Println(err)</p><p class="source-code">91     os.Exit(1)</p><p class="source-code">92   }</p><p class="source-code">93   err = initializeDB(db)</p><p class="source-code">94   if err != nil {</p><p class="source-code">95     fmt.Println(err)</p><p class="source-code">96     os.Exit(1)</p><p class="source-code">97   }</p><p class="source-code">98   defer tearDownDB(db)</p><p class="source-code">99   err = UpdatePassword(db, "1", "NewPassword")</p><p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/2PVxWPH">https://packt.live/2PVxWPH</a></p></li>
				<li>Run the program using the following command:<p class="source-code">go run -v main.go</p><p>You should get the following output.</p></li>
			</ol>
			<div>
				<div id="_idContainer370" class="IMG---Figure">
					<img src="image/B14177_18_13.jpg" alt="Figure 18.13: Expected output&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 18.13: Expected output</p>
			<p>In thi<a id="_idTextAnchor606"/>s activity, we have implemented a real-world scenario of storing and verifying user passwords with hashing. Should the database details be leaked, the hashed passwords, by themselves, will not be useful to the attacker.</p>
			<h2 id="_idParaDest-516"><a id="_idTextAnchor607"/>Activity 18.02: Creating CA Signed Certificates Using Crypto Libraries</h2>
			<p><strong class="bold">Solution</strong>:</p>
			<ol>
				<li value="1"> Create a <strong class="source-inline">main.go</strong> file and import the following packages:<p>The crypto packages here will be used to generate and verify x509 certificates:</p><p class="source-code">package main</p><p class="source-code">import (</p><p class="source-code">  "crypto"</p><p class="source-code">  "crypto/ecdsa"</p><p class="source-code">  "crypto/elliptic"</p><p class="source-code">  "crypto/rand"</p><p class="source-code">  "crypto/x509"</p><p class="source-code">  "crypto/x509/pkix"</p><p class="source-code">  "fmt"</p><p class="source-code">  "math/big"</p><p class="source-code">  "os"</p><p class="source-code">  "time"</p><p class="source-code">)</p></li>
				<li>Create a function called <strong class="source-inline">generateCert()</strong>, which returns an x509 certificate and its private key:<p class="source-code-heading">main.go</p><p class="source-code">44 func generateCert(cn string, caCert *x509.Certificate, caPriv      crypto.PrivateKey) (cert *x509.Certificate, privateKey        crypto.PrivateKey, err error) {</p><p class="source-code">45   serialNumber, err := rand.Int(rand.Reader, big.NewInt(27))</p><p class="source-code">46   if err != nil {</p><p class="source-code">47     return cert, privateKey, err</p><p class="source-code">48   }</p><p class="source-code">49   var isCA bool</p><p class="source-code">50   if caCert == nil {</p><p class="source-code">51     isCA = true</p><p class="source-code">52   }</p><p class="source-code">53   template := &amp;x509.Certificate{</p><p class="source-code">54     SerialNumber:          serialNumber,</p><p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/39a2R24">https://packt.live/39a2R24</a></p></li>
				<li>Create the <strong class="source-inline">main()</strong> function to call the <strong class="source-inline">generateCert() </strong>function. This will generate a root certificate and a leaf certificate from the root certificate. Verify the leaf certificate:<p class="source-code-heading">main.go</p><p class="source-code">14 func main() {</p><p class="source-code">15   // Generate CA certificates</p><p class="source-code">16   caCert, caPriv, err := generateCert("CA cert", nil, nil)</p><p class="source-code">17   if err != nil {</p><p class="source-code">18     fmt.Printf("error generating server certificate: %v", err)</p><p class="source-code">19     os.Exit(1)</p><p class="source-code">20   } else {</p><p class="source-code">21     fmt.Println("ca certificate generated successfully")</p><p class="source-code">22    }</p><p class="source-code">23   // User CA cert to generate and sign server certificate</p><p class="source-code">24   cert, _, err := generateCert("Test Cert", caCert, caPriv)</p><p class="source-code-link">The full code for this step is available at: <a href="https://packt.live/398aM04">https://packt.live/398aM04</a></p></li>
				<li>Test the code by running <strong class="source-inline">main.go</strong> using the following command:<p class="source-code">go run main.go</p><p>The output should appear as follows:</p><p class="source-code">gobin:activity2 Gobin$ go run main.go</p><p class="source-code">ca certificate generated successfully </p><p class="source-code">leaf certificate generated successfully</p><p class="source-code">leaf certificate successfully verified</p></li>
			</ol>
			<p>In this activity, we have generated x509 public key certificates. We have also seen how to use a root certificate to generate a leaf certificate. This can be handy when you are trying to implement your own PKI server.</p>
			<h1 id="_idParaDest-517"><a id="_idTextAnchor608"/>Chapter 19: Special Features</h1>
			<h2 id="_idParaDest-518"><a id="_idTextAnchor609"/>Activity 19.01: Defining Build Constraints Using Filenames</h2>
			<p><strong class="bold">Solution</strong>:</p>
			<ol>
				<li value="1">Create a directory called <strong class="source-inline">custom</strong>.</li>
				<li>Inside this directory, create a file called <strong class="source-inline">print_darwin.go</strong>.</li>
				<li>Define a function called <strong class="source-inline">Print()</strong>:<p class="source-code">package custom</p><p class="source-code">import "fmt"</p><p class="source-code">func Print() {</p><p class="source-code">  fmt.Println("Hello I am running on a darwin machine.")</p><p class="source-code">}</p></li>
				<li>Create another file inside the <strong class="source-inline">custom</strong> directory called <strong class="source-inline">print_386.go</strong>.</li>
				<li>Define a function inside this package called <strong class="source-inline">Print()</strong>:<p class="source-code">import "fmt"</p><p class="source-code">func Print() {</p><p class="source-code">  fmt.Println("Hello I am running on 386 machine.")</p><p class="source-code">}</p></li>
				<li>Run the program using the following command:<p class="source-code">go run main.go</p><p>You should see the following output:</p><p class="source-code">$ go run main.go</p><p class="source-code">Hello I am running on a darwin machine.</p></li>
			</ol>
			<h2 id="_idParaDest-519"><a id="_idTextAnchor610"/>Activity 19.02: Using Wildcard with Go Test</h2>
			<p><strong class="bold">Solution</strong>:</p>
			<ol>
				<li value="1">Create a directory called <strong class="source-inline">package1</strong>:<div id="_idContainer371" class="IMG---Figure"><img src="image/B14177_19_05.jpg" alt="Figure 19.5: Directory structure&#13;&#10;"/></div><p class="figure-caption">Figure 19.5: Directory structure</p></li>
				<li>Create <strong class="source-inline">run_test.go</strong> in this directory with the following test cases defined:<p class="source-code">package package1</p><p class="source-code">import "testing"</p><p class="source-code">func TestPackage1(t *testing.T){</p><p class="source-code">  t.Log("running TestPackage1")</p><p class="source-code">}</p></li>
				<li>In the parent directory, create another directory called <strong class="source-inline">package2</strong>:<div id="_idContainer372" class="IMG---Figure"><img src="image/B14177_19_06.jpg" alt="Figure 19.6: Directory structure&#13;&#10;"/></div><p class="figure-caption">Figure 19.6: Directory structure</p></li>
				<li>Create a file called <strong class="source-inline">run_test.go</strong> in this directory with the following content:<p class="source-code">package package2</p><p class="source-code">import "testing"</p><p class="source-code">func TestPackage2(t *testing.T){</p><p class="source-code">  t.Log("running TestPackage2")</p><p class="source-code">}</p></li>
				<li>Run all the test cases using the follo<a id="_idTextAnchor611"/>wing command from the parent directory:<p class="source-code">go test -v ./...</p><p>You should get the following output:</p></li>
			</ol>
			<div>
				<div id="_idContainer373" class="IMG---Figure">
					<img src="image/B14177_19_07.jpg" alt="Figure 19.7: Recursive test with the wildcard pattern"/>
				</div>
			</div>
			<p class="figure-caption">Figure 19.7: Recursive test with the wildcard pattern</p>
		</div>
	</body></html>