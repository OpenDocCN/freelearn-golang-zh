["```go\n    package main\n    ```", "```go\n    import \"fmt\"\n    ```", "```go\n    func main() {\n    ```", "```go\n      firstName := \"Bob\"\n    ```", "```go\n      familyName := \"Smith\" \n    ```", "```go\n      age := 34 \n    ```", "```go\n      peanutAllergy := false\n    ```", "```go\n      fmt.Println(firstName)\n      fmt.Println(familyName)\n      fmt.Println(age)\n      fmt.Println(pean\n    utAllergy)\n    ```", "```go\n    }\n    ```", "```go\n    package main\n    import \"fmt\"\n    func main() {\n      a, b := 5, 10\n    ```", "```go\n      swap(&a, &b)\n      fmt.Println(a == 10, b == 5)\n    }\n    func swap(a *int, b *int) {\n    ```", "```go\n      *a, *b = *b, *a\n    }\n    ```", "```go\n    true true\n    ```", "```go\n    package main\n    import \"fmt\"\n    func main() {\n      count := 5\n    ```", "```go\n      var message string\n      if count > 5 {\n    ```", "```go\n      message = \"Greater than 5\"\n      } else {\n    ```", "```go\n      message = \"Not greater than 5\"\n      }\n      fmt.Println(message)\n    }\n    ```", "```go\n    Not greater than 5\n    ```", "```go\n    package main\n    import \"fmt\"\n    func main() {\n      count := 0\n      if count < 5 {\n    ```", "```go\n        count = 10\n        count++\n      }\n      fmt.Println(count == 11)\n    }\n    ```", "```go\n    true\n    ```", "```go\n    package main\n    import (\n      \"fmt\"\n      \"strconv\"\n    )\n    ```", "```go\n    func main() {\n    ```", "```go\n      for i := 1; i <= 100; i++{\n    ```", "```go\n      out := \"\"\n    ```", "```go\n      if i%3 == 0 {\n      out += \"Fizz\"\n      }\n    ```", "```go\n      if i%5 == 0 {\n      out += \"Buzz\"\n      }\n    ```", "```go\n      if out == \"\" {\n      out = strconv.Itoa(i)\n      }\n    ```", "```go\n      fmt.Println(out)\n    ```", "```go\n      }\n    }\n    ```", "```go\n    go run main.go\n    ```", "```go\n    package main\n    ```", "```go\n    import \"fmt\"\n    ```", "```go\n    func main() {\n    ```", "```go\n      words := map[string]int{\n        \"Gonna\": 3,\n        \"You\":   3,\n        \"Give\":  2,\n        \"Never\": 1,\n        \"Up\":    4,\n      }\n    ```", "```go\n      topWord := \"\"\n      topCount := 0\n    ```", "```go\n      for key, value := range words {\n    ```", "```go\n        if value > topCount {\n    ```", "```go\n          topCount = value\n          topWord = key\n    ```", "```go\n        }\n    ```", "```go\n      }\n    ```", "```go\n      fmt.Println(\"Most popular word:\", topWord)\n      fmt.Println(\"With a count of  :\", topCount)\n    }\n    ```", "```go\n    go run main.go\n    ```", "```go\n    Most popular word: Up\n    With a count of  : 4\n    ```", "```go\n    package main\n    import \"fmt\"\n    ```", "```go\n    func main() {\n    ```", "```go\n      nums := []int{5, 8, 2, 4, 0, 1, 3, 7, 9, 6}\n    ```", "```go\n      fmt.Println(\"Before:\", nums)\n    ```", "```go\n      for swapped := true; swapped; {\n    ```", "```go\n        swapped = false\n    ```", "```go\n        for i := 1; i < len(nums); i++ {\n    ```", "```go\n          if nums[i-1] > nums[i] {\n    ```", "```go\n            nums[i], nums[i-1] = nums[i-1], nums[i]\n    ```", "```go\n            swapped = true\n    ```", "```go\n          }\n        }\n      }\n    ```", "```go\n      fmt.Println(\"After :\", nums)\n    }\n    ```", "```go\n    go run main.go\n    ```", "```go\n    Before: [5, 8, 2, 4, 0, 1, 3, 7, 9, 6]\n    After : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    ```", "```go\n    package main\n    ```", "```go\n    import \"fmt\"\n    ```", "```go\n    func salesTax(cost float64, taxRate float64) float64 {\n    ```", "```go\n      return cost * taxRate\n    ```", "```go\n    }\n    ```", "```go\n    func main() {\n    ```", "```go\n      taxTotal := .0\n    ```", "```go\n      // Cake\n      taxTotal += salesTax(.99, .075)\n    ```", "```go\n      // Milk\n      taxTotal += salesTax(2.75, .015)\n    ```", "```go\n      // Butter\n      taxTotal += salesTax(.87, .02)\n    ```", "```go\n      // Total\n      fmt.Println(\"Sales Tax Total: \", taxTotal)\n    ```", "```go\n    }\n    ```", "```go\n    go run main.go\n    ```", "```go\n    Sales Tax Total: 0.1329\n    ```", "```go\n    package main\n    ```", "```go\n    import (\n      \"errors\"\n      \"fmt\"\n    )\n    ```", "```go\n    const (\n      goodScore      = 450\n      lowScoreRatio  = 10\n      goodScoreRatio = 20\n    )\n    ```", "```go\n    var (\n      ErrCreditScore = errors.New(\"invalid credit score\")\n      ErrIncome      = errors.New(\"income invalid\")\n      ErrLoanAmount  = errors.New(\"loan amount invalid\")\n      ErrLoanTerm    = errors.New(\"loan term not a multiple of 12\")\n    )\n    ```", "```go\n    func checkLoan(creditScore int, income float64, loanAmount float64, loanTerm   float64) error {\n    ```", "```go\n      interest := 20.0\n    ```", "```go\n      if creditScore >= goodScore {\n        interest = 15.0\n      }\n    ```", "```go\n      if creditScore < 1 {\n        return ErrCreditScore\n      }\n    ```", "```go\n      if income < 1 {\n        return ErrIncome\n      }\n    ```", "```go\n      if loanAmount < 1 {\n        return ErrLoanAmount\n      }\n    ```", "```go\n      if loanTerm < 1 || int(loanTerm)%12 != 0 {\n        return ErrLoanTerm\n      }\n    ```", "```go\n      rate := interest / 100\n    ```", "```go\n      payment := ((loanAmount * rate) / loanTerm) + (loanAmount / loanTerm)\n    ```", "```go\n      totalInterest := (payment * loanTerm) - loanAmount\n    ```", "```go\n      approved := false\n    ```", "```go\n      if income > payment {\n    ```", "```go\n        ratio := (payment / income) * 100\n    ```", "```go\n        if creditScore >= goodScore && ratio < goodScoreRation {\n          approved = true\n        } else if ratio < lowScoreRation {\n          approved = true\n        }\n      }\n    ```", "```go\n      fmt.Println(\"Credit Score    :\", creditScore)\n      fmt.Println(\"Income          :\", income)\n      fmt.Println(\"Loan Amount     :\", loanAmount)\n      fmt.Println(\"Loan Term       :\", loanTerm)\n      fmt.Println(\"Monthly Payment :\", payment)\n      fmt.Println(\"Rate            :\", interest)\n      fmt.Println(\"Total Cost      :\", totalInterest)\n      fmt.Println(\"Approved        :\", approved)\n      fmt.Println(\"\")\n    ```", "```go\n      return nil\n    }\n    ```", "```go\n    func main() {\n    ```", "```go\n      // Approved\n      fmt.Println(\"Applicant 1\")\n      fmt.Println(\"-----------\")\n      err := checkLoan(500, 1000, 1000, 24)\n    ```", "```go\n      if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n      }\n    ```", "```go\n      // Denied\n      fmt.Println(\"Applicant 2\")\n      fmt.Println(\"-----------\")\n      err = checkLoan(350, 1000, 10000, 12)\n    ```", "```go\n      if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n      }\n    ```", "```go\n    }\n    ```", "```go\n    go run main.go\n    ```", "```go\n    package main\n    import \"fmt\"\n    ```", "```go\n    func getArr() [10]int {\n    ```", "```go\n      var arr [10]int\n    ```", "```go\n      for i := 0; i < 10; i++ {\n    ```", "```go\n      arr[i] = i + 1\n      }\n    ```", "```go\n      return arr\n    }\n    ```", "```go\n    func main() {\n      fmt.Println(getArr())\n    }\n    ```", "```go\n    go run .\n    ```", "```go\n    [1 2 3 4 5 6 7 8 9 10]\n    ```", "```go\n    package main\n    import (\n      \"fmt\"\n      \"os\"\n    )\n    ```", "```go\n    var users = map[string]string{\n      \"305\": \"Sue\",\n      \"204\": \"Bob\",\n      \"631\": \"Jake\",\n      \"073\": \"Tracy\",\n    }\n    ```", "```go\n    func getName(id string) (string, bool) {\n      name, exists := users[id]\n      return name, exists\n    }\n    ```", "```go\n    func main() {\n      if len(os.Args) < 2 {\n        fmt.Println(\"User ID not passed\")\n        os.Exit(1)\n      }\n      name, exists := getName(os.Args[1])\n      if !exists {\n        fmt.Printf(\"error: user (%v) not found\", os.Args[1])\n        os.Exit(1)\n      }\n      fmt.Println(\"Hi,\", name)\n    }\n    ```", "```go\n    go run .\n    ```", "```go\n    Hi, Tracy\n    ```", "```go\n    package main\n    import (\n      \"fmt\"\n      \"os\"\n      \"strings\"\n    )\n    ```", "```go\n    type locale struct {\n      language string\n      territory string\n    }\n    ```", "```go\n    func getLocales() map[locale]struct{} {\n      supportedLocales := make(map[locale]struct{}, 5)\n      supportedLocales[locale{\"en\", \"US\"}] = struct{}{}\n      supportedLocales[locale{\"en\", \"CN\"}] = struct{}{}\n      supportedLocales[locale{\"fr\", \"CN\"}] = struct{}{}\n      supportedLocales[locale{\"fr\", \"FR\"}] = struct{}{}\n      supportedLocales[locale{\"ru\", \"RU\"}] = struct{}{}\n      return supportedLocales\n    }\n    ```", "```go\n    func localeExists(l locale) bool {\n      _, exists := getLocales()[l]\n      return exists\n    }\n    ```", "```go\n    func main() {\n    ```", "```go\n      if len(os.Args) < 2 {\n        fmt.Println(\"No locale passed\")\n        os.Exit(1)\n      }\n    ```", "```go\n      localeParts := strings.Split(os.Args[1], \"_\")\n      if len(localeParts) != 2 {\n        fmt.Printf(\"Invalid locale passed: %v\\n\", os.Args[1])\n        os.Exit(1)\n      }\n    ```", "```go\n      passedLocale := locale{\n        territory: localeParts[1],\n        language:  localeParts[0],\n      }\n    ```", "```go\n      if !localeExists(passedLocale) {\n        fmt.Printf(\"Locale not supported: %v\\n\", os.Args[1])\n        os.Exit(1)\n      }\n      fmt.Println(\"Locale passed is supported\")\n    }\n    ```", "```go\n    go run .\n    ```", "```go\n    package main\n    import \"fmt\"\n    ```", "```go\n    func getWeek() []string {\n    ```", "```go\n      week := []string{\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\",     \"Saturday\", \"Sunday\"}\n    ```", "```go\n      week = append(week[6:], week[:6]...)\n    ```", "```go\n      return week\n    }\n    ```", "```go\n    func main() {\n      fmt.Println(getWeek())\n    }\n    ```", "```go\n    go run .\n    ```", "```go\n    [Sunday Monday Tuesday Wednesday Thursday Friday Saturday]\n    ```", "```go\n    package main\n    import \"fmt\"\n    ```", "```go\n    func removeBad() []string {\n    ```", "```go\n      sli := []string{\"Good\", \"Good\", \"Bad\", \"Good\", \"Good\"}\n    ```", "```go\n      sli = append(sli[:2], sli[3:]...)\n    ```", "```go\n      return sli\n    }\n    ```", "```go\n    func main() {\n      fmt.Println(removeBad())\n    }\n    ```", "```go\n    go run .\n    ```", "```go\n    [Good Good Good Good]\n    ```", "```go\n    package main\n    ```", "```go\n    import \"fmt\"\n    ```", "```go\n    func getData() []interface{} {\n      return []interface{}{\n        1,\n        3.14,\n        \"hello\",\n        true,\n        struct{}{},\n      }\n    }\n    ```", "```go\n    func getTypeName(v interface{}) string {\n    ```", "```go\n      switch v.(type) {\n    ```", "```go\n      case int, int32, int64:\n    ```", "```go\n        return \"int\"\n    ```", "```go\n      case float64, float32:\n        return \"float\"\n    ```", "```go\n      case bool:\n        return \"bool\"\n    ```", "```go\n      case string:\n        return \"string\"\n    ```", "```go\n      default:\n        return \"unknown\"\n    ```", "```go\n      }\n    }\n    ```", "```go\n    func main() {\n    ```", "```go\n      data := getData()\n    ```", "```go\n      for i := 0; i < len(data); i++ {\n    ```", "```go\n        fmt.Printf(\"%v is %v\\n\", data[i], getTypeName(data[i]))\n    ```", "```go\n      }\n    }\n    ```", "```go\n    go run .\n    ```", "```go\n    package main\n    import \"fmt\"\n    ```", "```go\n    type Developer struct {\n      Individual Employee\n      HourlyRate int\n      WorkWeek   [7]int\n    }\n    ```", "```go\n    type Employee struct {\n      Id        int\n      FirstName string\n      LastName  string\n    }\n    ```", "```go\n    type Weekday int\n    ```", "```go\n    const (\n      Sunday Weekday = iota //starts at zero\n      Monday\n      Tuesday\n      Wednesday\n      Thursday\n      Friday\n      Saturday\n    )\n    ```", "```go\n    func main() {\n      d := Developer{Individual:Employee{Id: 1, FirstName: \"Tony\", LastName:     \"Stark\"}, HourlyRate: 10}\n    ```", "```go\n      d.LogHours(Monday, 8)\n      d.LogHours(Tuesday, 10)\n    ```", "```go\n      fmt.Println(\"Hours worked on Monday:  \" ,d.WorkWeek[Monday])\n      fmt.Println(\"Hours worked on Tuesday:  \" ,d.WorkWeek[Tuesday])\n      fmt.Printf(\"Hours worked this week:  %d\",d.HoursWorked())\n    }\n    ```", "```go\n    func (d *Developer) LogHours(day Weekday, hours int) {\n      d.WorkWeek[day] = hours\n    }\n    ```", "```go\n    func (d *Developer) HoursWorked() int {\n      total := 0\n      for _, v := range d.WorkWeek {\n        total += v\n      }\n      return total\n    }\n    ```", "```go\n    Hours worked on Monday:  8\n    Hours worked on Tuesday:  10\n    Hours worked this week:  18\n    ```", "```go\n    main.go\n    3  type Developer struct {\n    4    Individual Employee\n    5    HourlyRate int\n    6    WorkWeek   [7]int\n    7  }\n    8  type Employee struct {\n    9    Id        int\n    10   FirstName string\n    11   LastName  string\n    12 }\n    13 type Weekday int\n    14 const (\n    15   Sunday Weekday = iota //starts at zero\n    The full code for this step is available at: https://packt.live/34NsT7T\n    ```", "```go\n    func main() {\n      d := Developer{Individual: Employee{Id: 1, FirstName: \"Tony\", LastName:     \"Stark\"}, HourlyRate: 10}\n      x := nonLoggedHours()\n      fmt.Println(\"Tracking hours worked thus far today: \", x(2))\n      fmt.Println(\"Tracking hours worked thus far today: \", x(3))\n      fmt.Println(\"Tracking hours worked thus far today: \", x(5))\n      fmt.Println()\n      d.LogHours(Monday, 8)\n      d.LogHours(Tuesday, 10)\n      d.LogHours(Wednesday, 10)\n      d.LogHours(Thursday, 10)\n      d.LogHours(Friday, 6)\n      d.LogHours(Saturday, 8)\n      d.PayDetails()\n    }\n    ```", "```go\n    func (d *Developer) LogHours(day Weekday, hours int) {\n      d.WorkWeek[day] = hours\n    }\n    func (d *Developer) HoursWorked() int {\n      total := 0\n      for _, v := range d.WorkWeek {\n        total += v\n      }\n      return total\n    }\n    ```", "```go\n    func (d *Developer) PayDay() (int, bool) {\n      if d.HoursWorked() > 40 {\n        hoursOver := d.HoursWorked() - 40\n        overTime := hoursOver * 2\n        regularPay := d.HoursWorked() * d.HourlyRate\n        return regularPay + overTime, true\n      }\n      return d.HoursWorked() * d.HourlyRate, false\n    }\n    ```", "```go\n    func nonLoggedHours() func(int) int {\n      total := 0\n      return func(i int) int {\n        total += i\n        return total\n      }\n    }\n    ```", "```go\nmain.go\n64 func (d *Developer) PayDetails() {\n65   for i, v := range d.WorkWeek {\n66     switch i {\n67     case 0:\n68       fmt.Println(\"Sunday hours: \", v)\n69     case 1:\n70       fmt.Println(\"Monday hours: \", v)\n71     case 2:\nThe full code for this step is available at: https://packt.live/2QeUNEF\n```", "```go\n    package main\n    import (\n      «errors»\n      «fmt»\n    )\n    ```", "```go\n    var ErrInvalidLastName = errors.New(\"invalid last name\")\n    ```", "```go\n    var ErrInvalidRoutingNum = errors.New(\"invalid routing number\")\n    ```", "```go\n    func main() {\n      fmt.Println(ErrInvalidLastName)\n      fmt.Println(ErrInvalidRoutingNum)\n    }\n    ```", "```go\n    go build\n    ```", "```go\ninvalid last name\ninvalid routing number\n```", "```go\n    package main\n    import (\n      \"errors\"\n      \"fmt\"\n      \"strings\"\n    )\n    ```", "```go\n    type directDeposit struct {\n      lastName      string\n      firstName     string\n      bankName      string\n      routingNumber int\n      accountNumber int\n    }\n    ```", "```go\n    var ErrInvalidLastName = errors.New(\"invalid last name\")\n    var ErrInvalidRoutingNum = errors.New(\"invalid routing number\")\n    ```", "```go\n    func main() {\n      dd := directDeposit{\n        lastName:      \"  \",\n        firstName:     \"Abe\",\n        bankName:      \"XYZ Inc\",\n        routingNumber: 17,\n        accountNumber: 1809,\n      }\n    ```", "```go\n      err := dd.validateRoutingNumber()\n      if err != nil {\n        fmt.Println(err)\n      }\n      err = dd.validateLastName()\n      if err != nil {\n        fmt.Println(err)\n      }\n    ```", "```go\n      dd.report()\n    }\n    ```", "```go\n    func (dd *directDeposit) validateRoutingNumber() error {\n      if dd.routingNumber < 100 {\n        return ErrInvalidRoutingNum\n      }\n      return nil\n    }\n    ```", "```go\n    func (dd *directDeposit) validateLastName() error {\n      dd.lastName = strings.TrimSpace(dd.lastName)\n      if len(dd.lastName) == 0 {\n        return ErrInvalidLastName\n      }\n      return nil\n    }\n    ```", "```go\n    func (dd *directDeposit) report() {\n      fmt.Println(strings.Repeat(\"*\", 80))\n      fmt.Println(\"Last Name: \", dd.lastName)\n      fmt.Println(\"First Name: \", dd.firstName)\n      fmt.Println(\"Bank Name: \", dd.bankName)\n      fmt.Println(\"Routing Number: \", dd.routingNumber)\n      fmt.Println(\"Account Number: \", dd.accountNumber)\n    }\n    ```", "```go\n    go build\n    ```", "```go\n    func (dd *directDeposit) validateRoutingNumber() error {\n      if dd.routingNumber < 100 {\n        panic(ErrInvalidRoutingNum)\n      }\n      return nil\n    }\n    ```", "```go\n    go build\n    ```", "```go\n    func (dd *directDeposit) validateRoutingNumber() error {\n      defer func() {\n        if r:= recover(); r != nil {\n          fmt.Println(r)\n        }\n      }()\n      if dd.routingNumber < 100 {\n        panic(ErrInvalidRoutingNum)\n      }\n      return nil\n    }\n    ```", "```go\n    go build\n    ```", "```go\n    package main\n    import (\n      \"errors\"\n      \"fmt\"\n      \"os\"\n    )\n    ```", "```go\n    type Employee struct {\n      Id        int\n      FirstName string\n      LastName  string\n    }\n    ```", "```go\n    type Developer struct {\n      Individual        Employee\n      HourlyRate        float64\n      HoursWorkedInYear float64\n      Review            map[string]interface{}\n    }\n    ```", "```go\n    type Manager struct {\n      Individual     Employee\n      Salary         float64\n      CommissionRate float64\n    }\n    ```", "```go\n    type Payer interface {\n      Pay() (string, float64)\n    }\n    ```", "```go\n    func (d Developer) FullName() string {\n      fullName := d.Individual.FirstName + \" \" + d.Individual.LastName\n      return fullName\n    }\n    ```", "```go\n    func (d Developer) Pay() (string, float64) {\n      fullName := d.FullName()\n      return fullName, d.HourlyRate * d.HoursWorkedInYear\n    }\n    ```", "```go\n    func (m Manager) Pay() (string, float64) {\n      fullName := m.Individual.FirstName + \" \" + m.Individual.LastName\n      return fullName, m.Salary + (m.Salary * m.CommissionRate)\n    }\n    ```", "```go\n    func payDetails(p Payer) {\n      fullName, yearPay := p.Pay()\n      fmt.Printf(\"%s got paid %.2f for the year\\n\", fullName, yearPay)\n    }\n    ```", "```go\n      d := Developer{Individual: Employee{Id: 1, FirstName: \"Eric\", LastName: \"Davis\"}, HourlyRate: 35, HoursWorkedInYear: 2400, Review: employeeReview}\n      m := Manager{Individual: Employee{Id: 2, FirstName: \"Mr.\", LastName: \"Boss\"}, Salary: 150000, CommissionRate: .07}\n    ```", "```go\n      payDetails(d)\n      payDetails(m)\n    ```", "```go\n      employeeReview := make(map[string]interface{})\n      employeeReview[\"WorkQuality\"] = 5\n      employeeReview[\"TeamWork\"] = 2\n      employeeReview[\"Communication\"] = \"Poor\"\n      employeeReview[\"Problem-solving\"] = 4\n      employeeReview[\"Dependability\"] = \"Unsatisfactory\"\n    ```", "```go\n    func convertReviewToInt(str string) (int, error) {\n      switch str {\n      case \"Excellent\":\n        return 5, nil\n      case \"Good\":\n        return 4, nil\n      case \"Fair\":\n        return 3, nil\n      case \"Poor\":\n        return 2, nil\n      case \"Unsatisfactory\":\n        return 1, nil\n      default:\n        return 0, errors.New(\"invalid rating: \" + str)\n      }\n    }\n    ```", "```go\n    func OverallReview(i interface{}) (int, error) {\n      switch v := i.(type) {\n      case int:\n        return v, nil\n      case string:\n        rating, err := convertReviewToInt(v)\n        if err != nil {\n          return 0, err\n        }\n        return rating, nil\n      default:\n        return 0, errors.New(\"unknown type\")\n      }\n    }\n    ```", "```go\n    func (d Developer) ReviewRating() error {\n      total := 0\n      for _, v := range d.Review {\n        rating, err := OverallReview(v)\n        if err != nil {\n          return err\n        }\n        total += rating\n      }\n      averageRating := float64(total) / float64(len(d.Review))\n      fmt.Printf(\"%s got a review rating of %.2f\\n\",d.FullName(),averageRating)\n      return nil\n    }\n    ```", "```go\n    err := d.ReviewRating()\n      if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n      }\n    ```", "```go\n        payDetails(d)\n        payDetails(m)\n    }\n    ```", "```go\n    go build\n    ```", "```go\nEric Davis got a review rating of 2.80\nEric Davis got paid 84000.00 for the year\nMr. Boss got paid 160500.00 for the year\n```", "```go\n    package payroll\n    import (\n      \"errors\"\n      \"fmt\"\n    )\n    ```", "```go\n    developer.go\n    1  package payroll\n    2  import (\n    3    \"errors\"\n    4    \"fmt\"\n    5  )\n    6  type Developer struct {\n    7    Individual        Employee\n    8    HourlyRate        float64\n    9    HoursWorkedInYear float64\n    10   Review            map[string]interface{}\n    11 }\n    The full code for this step is available at: https://packt.live/34NTAtn\n    ```", "```go\n    package payroll\n    import \"fmt\"\n    ```", "```go\n    package payroll\n    import \"fmt\"\n    type Payer interface {\n      Pay() (string, float64)\n    }\n    type Employee struct {\n      Id        int\n      FirstName string\n      LastName  string\n    }\n    func PayDetails(p Payer) {\n      fullName, yearPay := p.Pay()\n      fmt.Printf(\"%s got paid %.2f for the year\\n\", fullName, yearPay)\n    }\n    ```", "```go\n    package payroll\n    ```", "```go\n    package payroll\n    type Manager struct {\n      Individual     Employee\n      Salary         float64\n      CommissionRate float64\n    }\n    func (m Manager) Pay() (string, float64) {\n      fullName := m.Individual.FirstName + \" \" + m.Individual.LastName\n      return fullName, m.Salary + (m.Salary * m.CommissionRate)\n    }\n    ```", "```go\n    package main\n    ```", "```go\n    import (\n      \"fmt\"\n      \"os\"\n      pr \"github.com/PacktWorkshops/Get-Ready-To-Go/Chapter08/Activity8.01/payroll\"\n    )\n    ```", "```go\n    var employeeReview = make(map[string]interface{})\n    ```", "```go\n    func init() {\n      fmt.Println(\"Welcome to the Employee Pay and Performance Review\")\n      fmt.Println(\"++++++++++++++++++++++++++++++++++++++++++++++++++\")\n    }\n    ```", "```go\n    func init() {\n      fmt.Println(\"Initializing variables\")\n      employeeReview[\"WorkQuality\"] = 5\n      employeeReview[\"TeamWork\"] = 2\n      employeeReview[\"Communication\"] = \"Poor\"\n      employeeReview[\"Problem-solving\"] = 4\n      employeeReview[\"Dependability\"] = \"Unsatisfactory\"\n    }\n    ```", "```go\n    func main() {\n    ```", "```go\n      d := pr.Developer{Individual: pr.Employee{Id: 1, FirstName: \"Eric\", LastName: \"Davis\"}, HourlyRate: 35, HoursWorkedInYear: 2400, Review: employeeReview}\n    ```", "```go\n      m := pr.Manager{Individual: pr.Employee{Id: 2, FirstName: \"Mr.\", LastName: \"Boss\"}, Salary: 150000, CommissionRate: .07}\n    ```", "```go\n      err := d.ReviewRating()\n      if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n      }\n    ```", "```go\n      pr.PayDetails(d)\n      pr.PayDetails(m)\n    }\n    ```", "```go\n    go build\n    ```", "```go\n    ./pay\n    ```", "```go\n    Welcome to the Employee Pay and Performance Review\n    ++++++++++++++++++++++++++++++++++++++++++++++++++\n    Initializing variables\n    Eric Davis got a review rating of 2.80\n    Eric Davis got paid 84000.00 for the year\n    Mr. Boss got paid 160500.00 for the year\n    ```", "```go\n    package main\n    import (\n        \"errors\"\n        \"fmt\"\n        \"log\"\n        \"strconv\"\n        \"strings\"\n    )\n    ```", "```go\n    var (\n        ErrInvalidSSNLength     = errors.New(\"ssn is not nine characters long\")\n        ErrInvalidSSNNumbers    = errors.New(\"ssn has non-numeric digits\")\n        ErrInvalidSSNPrefix     = errors.New(\"ssn has three zeros as a prefix\")\n        ErrInvalidSSNDigitPlace = errors.New(\"ssn starts with a 9 requires 7 or       9 in the fourth place\")\n    )\n    ```", "```go\n    func validLength(ssn string) error {\n        ssn = strings.TrimSpace(ssn)\n        if len(ssn) != 9 {\n            return fmt.Errorf(\"the value of %s caused an error: %v\\n\", ssn,           ErrInvalidSSNLength)\n        }\n        return nil\n    }\n    ```", "```go\n    func isNumber(ssn string) error {\n        _, err := strconv.Atoi(ssn)\n        if err != nil {\n            return fmt.Errorf(\"the value of %s caused an error: %v\\n\", ssn,           ErrInvalidSSNNumbers)\n        }\n        return nil\n    }\n    ```", "```go\n    func isPrefixValid(ssn string) error {\n        if strings.HasPrefix(ssn, \"000\") {\n            return fmt.Errorf(\"the value of %s caused an error: %v\\n\", ssn,           ErrInvalidSSNPrefix)\n        }\n        return nil\n    }\n    ```", "```go\n    func validDigitPlace(ssn string) error {\n        if string(ssn[0]) == \"9\" && (string(ssn[3]) != \"9\" && string(ssn[3]) !=       \"7\") {\n            return fmt.Errorf(\"the value of %s caused an error: %v\\n\", ssn,           ErrInvalidSSNDigitPlace)\n        }\n        return nil\n    }\n    ```", "```go\n    func main() {\n        log.SetFlags(log.Ldate | log.Lmicroseconds | log.Llongfile)\n    ```", "```go\n        validateSSN := []string{\"123-45-6789\", \"012-8-678\", \"000-12-0962\", \"999-      33-3333\", \"087-65-4321\",\"123-45-zzzz\"}\n    ```", "```go\n        log.Printf(\"Checking data %#v\",validateSSN)\n    ```", "```go\n        for idx,ssn := range validateSSN {\n    ```", "```go\n            log.Printf(\"Validate data %#v %d of %d \",ssn,idx+1,len(validateSSN))\n    ```", "```go\n            ssn = strings.Replace(ssn, \"-\", \"\", -1)\n    ```", "```go\n            Err := isNumber(ssn)\n            if err != nil {\n                log.Print(err)\n            }\n            err = validLength(ssn)\n            if err != nil {\n                log.Print(err)\n            }\n            err = isPrefixValid(ssn)\n            if err != nil {\n                log.Print(err)\n            }\n            err = validDigitPlace(ssn)\n            if err != nil {\n                log.Print(err)\n            }\n        }\n    }\n    ```", "```go\n    cd Chapter09/Exercise9.02/ \n    ```", "```go\n    go build\n    ```", "```go\n    package main\n    import \"fmt\"\n    import \"time\"\n    import \"strconv\"\n    func main(){\n    ```", "```go\n      date := time.Now()\n      day := strconv.Itoa(date.Day())\n      month := strconv.Itoa(int(date.Month()))\n      year := strconv.Itoa(date.Year())\n      hour := strconv.Itoa(date.Hour())\n      minute := strconv.Itoa(date.Minute())\n      second := strconv.Itoa(date.Second())\n    ```", "```go\n      fmt.Println(hour + \":\" + minute + \":\" + second + \" \" + year + \"/\" + month   + \"/\" + day)\n    }\n    ```", "```go\n    15:32:30 2019/10/17\n    ```", "```go\n    package main\n    import \"fmt\"\n    import \"time\"\n    import \"strconv\"\n    func main(){\n    ```", "```go\n      date := time.Date(2019, 1, 31, 2, 49, 21, 324359102, time.UTC)\n      day := strconv.Itoa(date.Day())\n      month := strconv.Itoa(int(date.Month()))\n      year := strconv.Itoa(date.Year())\n      hour := strconv.Itoa(date.Hour())\n      minute := strconv.Itoa(date.Minute())\n      second := strconv.Itoa(date.Second())\n    ```", "```go\n    fmt.Println(hour + \":\" + minute + \":\" + second + \" \" + year + \"/\" + month +   \"/\" + day)\n    }\n    ```", "```go\n    2:49:21 2019/1/31\n    ```", "```go\n    package main\n    import \"fmt\"\n    import \"time\"\n    func main(){\n    ```", "```go\n      start := time.Now()\n      time.Sleep(2 * time.Second)\n    ```", "```go\n      end := time.Now()\n      length := end.Sub(start)\n    ```", "```go\n    fmt.Println(\"The execution took exactly\",length.Seconds(),\"seconds!\")\n    }\n    ```", "```go\n    The execution took exactly 2.0016895 seconds!\n    ```", "```go\n    package main\n    import \"fmt\"\n    import \"time\"\n    func main(){\n    ```", "```go\n      Current := time.Now()\n      fmt.Println(\"The current time is:\",Current.Format(time.ANSIC))\n    ```", "```go\n      SSS := time.Duration(21966 * time.Second)\n      Future := Current.Add(SSS)\n    ```", "```go\n    fmt.Println(\"6 hours, 6 minutes and 6 seconds from now the time will be:   \",Future.Format(time.ANSIC))\n    }\n    ```", "```go\n    The current time: Thu Oct 17 15:16:48 2019\n    6 hours, 6 minutes and 6 seconds from now the time will be:  Thu Oct 17 21:22:54 2019\n    ```", "```go\n    package main\n    import \"fmt\"\n    import \"time\"\n    func main(){\n    ```", "```go\n    Current := time.Now()\n      NYtime, _ := time.LoadLocation(\"America/New_York\")\n      LA, _ := time.LoadLocation(\"America/Los_Angeles\")\n    ```", "```go\n    fmt.Println(\"The local current time is:\",Current.Format(time.ANSIC))\n      fmt.Println(\"The time in New York is:     \",Current.In(NYtime).Format(time.ANSIC))\n      fmt.Println(\"The time in Los Angeles is:     \",Current.In(LA).Format(time.ANSIC))\n    }\n    ```", "```go\n    The local current time is: Thu Oct 17 15:16:13 2019\n    The time in New York is: Thu Oct 17 09:16:13 2019\n    The time in Los Angeles is: Thu Oct 17 06:16:13 2019\n    ```", "```go\n    package main\n    import (\n      \"encoding/json\"\n      \"fmt\"\n      \"os\"\n    )\n    ```", "```go\n    type customer struct {\n      UserName      string  `json:\"username\"`\n      Password      string  `json:\"-\"`\n      Token         string  `json:\"-\"`\n      ShipTo        address `json:\"shipto\"`\n      PurchaseOrder order   `json:\"order\"`\n    }\n    ```", "```go\n    type order struct {\n      TotalPrice  int    `json:\"total\"`\n      IsPaid      bool   `json:\"paid\"`\n      Fragile     bool   `json:\",omitempty\"`\n      OrderDetail []item `json:\"orderdetail\"`\n    }\n    ```", "```go\n    type item struct {\n      Name        string `json:\"itemname\"`\n      Description string `json:\"desc,omitempty\"`\n      Quantity    int    `json:\"qty\"`\n      Price       int    `json:\"price\"`\n    }\n    ```", "```go\n    type address struct {\n      Street  string `json:\"street\"`\n      City    string `json:\"city\"`\n      State   string `json:\"state\"`\n      ZipCode int    `json:\"zipcode\"`\n    }\n    ```", "```go\n    func (c *customer) Total() {\n      price := 0\n      for _, item := range c.PurchaseOrder.OrderDetail {\n        price += item.Quantity * item.Price\n      }\n      c.PurchaseOrder.TotalPrice = price\n    }\n    ```", "```go\n    func main() {\n      jsonData := []byte(`\n      {\n        \"username\" :\"blackhat\",\n        \"shipto\":  \n          {\n              \"street\": \"Sulphur Springs Rd\",\n              \"city\": \"Park City\",\n              \"state\": \"VA\",\n              \"zipcode\": 12345\n          },\n        \"order\":\n          {\n            \"paid\":false,\n            \"orderdetail\" : \n               [{\n                \"itemname\":\"A Guide to the World of zeros and ones\",\n                \"desc\": \"book\",\n                \"qty\": 3,\n                \"price\": 50\n              }]\n          }\n      }\n      `)\n    ```", "```go\n      if !json.Valid(jsonData) {\n        fmt.Printf(\"JSON is not valid: %s\", jsonData)\n        os.Exit(1)\n      }\n    ```", "```go\n      var c customer\n    ```", "```go\n      err := json.Unmarshal(jsonData, &c)\n      if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n      }\n    ```", "```go\n      game := item{}\n      game.Name = \"Final Fantasy The Zodiac Age\"\n      game.Description = \"Nintendo Switch Game\"\n      game.Quantity = 1\n      game.Price = 50\n    ```", "```go\n      glass := item{}\n      glass.Name = \"Crystal Drinking Glass\"\n      glass.Quantity = 11\n      glass.Price = 25\n    ```", "```go\n      c.PurchaseOrder.OrderDetail = append(c.PurchaseOrder.OrderDetail, game)\n      c.PurchaseOrder.OrderDetail = append(c.PurchaseOrder.OrderDetail, glass)\n    ```", "```go\n      c.Total()\n    ```", "```go\n      c.PurchaseOrder.IsPaid = true\n      c.PurchaseOrder.Fragile = true\n    ```", "```go\n      customerOrder, err := json.MarshalIndent(c, \"\", \"    \")\n      if err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n      }\n    ```", "```go\n      fmt.Println(string(customerOrder))\n    }\n    ```", "```go\n    go build\n    ```", "```go\n    package main\n    import (\n      \"encoding/csv\"\n      \"errors\"\n      \"flag\"\n      \"fmt\"\n      \"io\"\n      \"log\"\n      \"os\"\n      \"strconv\"\n      \"strings\"\n    )\n    ```", "```go\n    type budgetCategory string\n    const (\n      autoFuel   budgetCategory = \"fuel\"\n      food     budgetCategory = \"food\"\n      mortgage   budgetCategory = \"mortgage\"\n      repairs  budgetCategory = \"repairs\"\n      insurance  budgetCategory = \"insurance\"\n      utilities  budgetCategory = \"utilities\"\n      retirement budgetCategory = \"retirement\"\n    )\n    ```", "```go\n    var (\n      ErrInvalidBudgetCategory = errors.New(\"budget category not found\")\n    )\n    ```", "```go\n    type transaction struct {\n      id     int\n      payee  string\n      spent  float64\n      category budgetCategory\n    }\n    ```", "```go\n    func main() {\n      bankFile := flag.String(\"c\", \"\", \"location of the bank transaction csv file\")\n    //…\n    }\n    ```", "```go\n      logFile := flag.String(\"l\", \"\", \"logging of errors\")\n    ```", "```go\n      flag.Parse()\n    ```", "```go\n      if *bankFile == \"\" {\n      fmt.Println(\"csvFile is required.\")\n      flag.PrintDefaults()\n      os.Exit(1)\n      }\n    ```", "```go\n      if *logFile == \"\" {\n      fmt.Println(\"logFile is required.\")\n      flag.PrintDefaults()\n      os.Exit(1)\n      }\n    ```", "```go\n      _, err := os.Stat(*bankFile)\n      if os.IsNotExist((err)) {\n      fmt.Println(\"BankFile does not exist: \", *bankFile)\n      os.Exit(1)\n      }\n    ```", "```go\n      _, err = os.Stat(*logFile)\n      if !os.IsNotExist((err)) {\n      os.Remove(*logFile)\n      }\n    ```", "```go\n      csvFile, err := os.Open(*bankFile)\n      if err != nil {\n      fmt.Println(\"Error opening file: \", *bankFile)\n      os.Exit(1)\n      }\n    ```", "```go\n      trxs := parseBankFile(csvFile, *logFile)\n        fmt.Println()\n        for _, trx := range trxs {\n        fmt.Printf(\"%v\\n\", trx)\n      }\n    }\n    ```", "```go\n    func parseBankFile(bankTransactions io.Reader, logFile string) []transaction {\n    /…\n    }\n    ```", "```go\n      r := csv.NewReader(bankTransactions)\n      trxs := []transaction{}\n      header := true\n    ```", "```go\n    for {\n      trx := transaction{}\n      record, err := r.Read()\n      if err == io.EOF {\n        break\n      }\n      if err != nil {\n        log.Fatal(err)\n      }\n    ```", "```go\n    if !header\n    ```", "```go\n    for idx, value := range record {\n    ```", "```go\n    switch idx {\n    // id\n    case 0:\n    // payee\n    case 1:\n    // spent\n    case 2:\n    // category\n    } \n    ```", "```go\n    // id\n    case 0:\n    value = strings.TrimSpace(value)\n    trx.id, err = strconv.Atoi(value)\n    ```", "```go\n    // payee\n    case 1:\n      value = strings.TrimSpace(value)\n      trx.payee = value\n    ```", "```go\n    // spent\n    case 2:\n      value = strings.TrimSpace(value)\n      trx.spent, err = strconv.ParseFloat(value, 64)\n      if err != nil {\n      log.Fatal(err)\n      }\n    ```", "```go\n    // category\n      case 3:\n      trx.category, err = convertToBudgetCategory(value)\n      if err != nil {\n        s := strings.Join(record, \", \")\n        writeErrorToLog(\"error converting csv category column - \", err, s, logFile)\n      }\n      }\n    }\n    ```", "```go\n    trxs = append(trxs, trx)\n    }\n    ```", "```go\n        header = false\n      }\n    ```", "```go\n      return trxs\n    }\n    ```", "```go\n    func convertToBudgetCategory(value string) (budgetCategory, error) {\n      value = strings.TrimSpace(strings.ToLower(value))\n      switch value {\n      case \"fuel\", \"gas\":\n      return autoFuel, nil\n      case \"food\":\n      return food, nil\n      case \"mortgage\":\n      return mortgage, nil\n      case \"repairs\":\n      return repairs, nil\n      case \"car insurance\", \"life insurance\":\n      return insurance, nil\n      case \"utilities\":\n      return utilities, nil\n      default:\n      return \"\", ErrInvalidBudgetCategory\n      }\n    }\n    ```", "```go\n    func writeErrorToLog(msg string, err error, data string, logFile string) error {\n      msg += \"\\n\" + err.Error() + \"\\nData: \" + data + \"\\n\\n\"\n      f, err := os.OpenFile(logFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n      if err != nil {\n      return err\n      }\n      defer f.Close()\n      if _, err := f.WriteString(msg); err != nil {\n      return err\n      }\n      return nil\n    }\n    ```", "```go\n    go run main.go -c bank.csv -l log.log\n    ```", "```go\n    package main\n    import \"fmt\"\n    import \"database/sql\"\n    import _ \"github.com/lib/pq\"\n    func main(){\n    }\n    ```", "```go\n    type Users struct {\n        id int\n        name string\n        email string\n    }\n    ```", "```go\n    users := []Users{\n      {1,\"Szabo Daniel\",\"daniel@packt.com\"},\n      {2,\"Szabo Florian\",\"florian@packt.com\"},\n    }\n    ```", "```go\n    db, err := sql.Open(\"postgres\", \"user=postgres password=Start!123   host=127.0.0.1 port=5432 dbname=postgres sslmode=disable\")\n    if err != nil {\n      panic(err)\n    }else{\n      fmt.Println(\"The connection to the DB was successfully initialized!\")\n    }\n    ```", "```go\n    connectivity := db.Ping()\n    if connectivity != nil{\n      panic(connectivity)\n    }else{\n      fmt.Println(\"Good to go!\")\n    }\n    ```", "```go\n    TableCreate := `\n    CREATE TABLE users\n    (\n      ID integer NOT NULL,\n      Name text COLLATE pg_catalog.\"default\" NOT NULL,\n      Email text COLLATE pg_catalog.\"default\" NOT NULL,\n      CONSTRAINT \"Users_pkey\" PRIMARY KEY (ID)\n    )\n    WITH (\n      OIDS = FALSE\n    )\n    TABLESPACE pg_default;\n    ALTER TABLE users\n      OWNER to postgres;\n    `\n    ```", "```go\n    _,err = db.Exec(TableCreate)\n    if err != nil {\n      panic(err)\n    } else{\n      fmt.Println(\"The table called Users was successfully created!\")\n    }\n    ```", "```go\n    insert, insertErr := db.Prepare(\"INSERT INTO users VALUES($1,$2,$3)\")\n    if insertErr != nil{\n      panic(insertErr)\n    }\n    for _, u := range users{\n      _, err = insert.Exec(u.id,u.name,u.email)\n      if err != nil{\n        panic(err)\n      }else{\n        fmt.Println(\"The user with name:\",u.name,\"and email:\",u.email,\"was   successfully added!\")\n      }\n    }\n    insert.Close()\n    ```", "```go\n    update, updateErr := db.Prepare(\"UPDATE users SET Email=$1 WHERE ID=$2\")\n    if updateErr != nil{\n      panic(updateErr)\n    }\n    _, err = update.Exec(\"user@packt.com\",1)\n    if err != nil{\n      panic(err)\n    } else{\n      fmt.Println(\"The user's email address was successfully updated!\")\n    }\n    update.Close()\n    ```", "```go\n    remove, removeErr := db.Prepare(\"DELETE FROM users WHERE ID=$1\")\n    if removeErr != nil{\n      panic(removeErr)\n    }\n    _,err = remove.Exec(2)\n    if err != nil{\n      panic(err)\n    }else{\n      fmt.Println(\"The second user was successfully removed!\")\n    }\n    remove.Close()\n    ```", "```go\n    db.Close()\n    ```", "```go\n    package main\n    import \"fmt\"\n    import \"bufio\"\n    import \"os\"\n    import \"strings\"\n    import \"database/sql\"\n    import _ \"github.com/lib/pq\"\n    func main(){\n    }\n    ```", "```go\n    type Messages struct {\n      UserID int\n      Message string\n    }\n    ```", "```go\n    var toLookFor string\n    var message string\n    var email string\n    var name string\n    ```", "```go\n    reader := bufio.NewReader(os.Stdin)\n    ```", "```go\n    messages := []Messages{\n      {1,\"Hi Florian, when are you coming home?\"},\n      {1,\"Can you send some cash?\"},\n      {2,\"Hi can you bring some bread and milk?\"},\n      {7,\"Well...\"},\n    }\n    ```", "```go\n    db, err := sql.Open(\"postgres\", \"user=postgres password=Start!123   host=127.0.0.1 port=5432 dbname=postgres sslmode=disable\")\n    if err != nil {\n      panic(err)\n    }else{\n      fmt.Println(\"The connection to the DB was successfully initialized!\")\n    }\n    ```", "```go\n    connectivity := db.Ping()\n    if connectivity != nil{\n      panic(connectivity)\n    }else{\n      fmt.Println(\"Good to go!\")\n    }\n    ```", "```go\n    TableCreate := `\n    CREATE TABLE public.messages\n    (\n        UserID integer NOT NULL,\n        Message character varying(280) COLLATE pg_catalog.\"default\" NOT NULL\n    )\n    WITH (\n        OIDS = FALSE\n    )\n    TABLESPACE pg_default;\n    ALTER TABLE public.messages\n        OWNER to postgres;\n    `\n    ```", "```go\n    _,err = db.Exec(TableCreate)\n    if err != nil {\n      panic(err)\n    } else{\n      fmt.Println(\"The table called Messages was successfully created!\")\n    }\n    ```", "```go\n    insertMessages, insertErr := db.Prepare(\"INSERT INTO messages   VALUES($1,$2)\")\n    if insertErr != nil{\n      panic(insertErr)\n    }\n    for _, u := range messages{\n      _, err = insertMessages.Exec(u.UserID,u.Message)\n      if err != nil{\n        panic(err)\n      }else{\n        fmt.Println(\"The UserID:\",u.UserID,\"with message:\",u.Message,\"was   successfully added!\")\n      }\n    }\n    insertMessages.Close()\n    ```", "```go\n    fmt.Print(\"Give me the user's name: \")\n    toLookFor, err = reader.ReadString('\\n')\n    toLookFor = strings.TrimRight(toLookFor, \"\\r\\n\")\n    if err != nil{\n      panic(err)\n    } else {\n      fmt.Println(\"Looking for all the messages of user with   name:\",toLookFor,\"##\")\n    }\n    ```", "```go\n    UserMessages := \"SELECT users.Name, users.Email, messages.Message FROM   messages INNER JOIN users ON users.ID=messages.UserID WHERE users.Name     LIKE $1\"\n    ```", "```go\n    usersMessages, err := db.Prepare(UserMessages)\n    if err != nil {\n      panic(err)\n    }\n    result, err := usersMessages.Query(toLookFor)\n    numberof := 0\n    for result.Next(){\n      numberof++\n    }\n    ```", "```go\n    if numberof == 0 {\n       fmt.Println(\"The query returned nothing, no such user:\",toLookFor)\n    }else{\n      fmt.Println(\"There are a total of\",numberof,\"messages from the     user:\",toLookFor)\n      result, err := usersMessages.Query(toLookFor)\n      for result.Next(){\n        err = result.Scan(&name, &email, &message)\n        if err != nil{\n        panic(err)\n        }\n        fmt.Println(\"The user:\",name,\"with email:\",email,\"has sent the following       message:\",message)\n      }\n    }\n    usersMessages.Close()\n    ```", "```go\n    db.Close()\n    ```", "```go\n    package main\n    import (\n        \"encoding/json\"\n        \"fmt\"\n        \"io/ioutil\"\n        \"log\"\n        \"net/http\"\n    )\n    ```", "```go\n    type Names struct {\n        Names []string `json:\"names\"`\n    }\n    ```", "```go\n    func getDataAndParseResponse() (int, int) {\n    ```", "```go\n        r, err := http.Get(\"http://localhost:8080\")\n        if err != nil {\n            log.Fatal(err)\n        }\n    ```", "```go\n        defer r.Body.Close()\n        data, err := ioutil.ReadAll(r.Body)\n        if err != nil {\n            log.Fatal(err)\n        }\n        names := Names{}\n        err = json.Unmarshal(data, &names)\n        if err != nil {\n            log.Fatal(err)\n        }\n    ```", "```go\n        electricCount := 0\n        boogalooCount := 0\n        for _, name := range names.Names {\n            if name == \"Electric\" {\n                electricCount++\n            } else if name == \"Boogaloo\" {\n                boogalooCount++\n            }\n        }\n    ```", "```go\n        return electricCount, boogalooCount\n    ```", "```go\n    func main() {\n        electricCount, boogalooCount := getDataAndParseResponse()\n        fmt.Println(\"Electric Count: \", electricCount)\n        fmt.Println(\"Boogaloo Count: \", boogalooCount)\n    }\n    ```", "```go\nserver.go\n12 func (srv server) ServeHTTP(w http.ResponseWriter, r      *http.Request) {\n13     names := Names{}\n14     // Generate random number of 'Electric' names\n15     for i := 0; i < rand.Intn(5)+1; i++ {\n16         names.Names = append(names.Names, \"Electric\")\n17     }\n18     // Generate random number of 'Boogaloo' names\n19     for i := 0; i < rand.Intn(5)+1; i++ {\n20         names.Names = append(names.Names, \"Boogaloo\")\n21     }\n22     // convert struct to bytes\n23     jsonBytes, _ := json.Marshal(names)\n24     log.Println(string(jsonBytes))\n25     w.Write(jsonBytes)\n26 }\nThe full code is available at: https://packt.live/2sfnWaR\n```", "```go\n    package main\n    import (\n        \"bytes\"\n        \"encoding/json\"\n        \"errors\"\n        \"fmt\"\n        \"io/ioutil\"\n        \"log\"\n        \"net/http\"\n    )\n    ```", "```go\n    var url = \"http://localhost:8088\"\n    type Name struct {\n        Name string `json:\"name\"`\n    }\n    type Names struct {\n        Names []string `json:\"names\"`\n    }\n    type Resp struct {\n        OK bool `json:\"ok\"`\n    }\n    ```", "```go\n    func addNameAndParseResponse(nameToAdd string) error {\n    ```", "```go\n        name := Name{Name: nameToAdd}\n        nameBytes, err := json.Marshal(name)\n        if err != nil {\n            return err\n        }\n        r, err := http.Post(fmt.Sprintf(\"%s/addName\", url),      \"text/json\", bytes.NewReader(nameBytes))\n        if err != nil {\n            return err\n        }\n    ```", "```go\n        defer r.Body.Close()\n        data, err := ioutil.ReadAll(r.Body)\n        if err != nil {\n            return err\n        }\n        resp := Resp{}\n        err = json.Unmarshal(data, &resp)\n        if err != nil {\n            return err\n        }\n    ```", "```go\n        if !resp.OK {\n            return errors.New(\"response not ok\")\n        }\n        return nil\n    ```", "```go\n    func getDataAndParseResponse() []string {\n    ```", "```go\n        r, err := http.Get(fmt.Sprintf(\"%s/\", url))\n        if err != nil {\n            log.Fatal(err)\n        }\n        // get data from the response body\n        defer r.Body.Close()\n        data, err := ioutil.ReadAll(r.Body)\n        if err != nil {\n            log.Fatal(err)\n        }\n    ```", "```go\n        names := Names{}\n        err = json.Unmarshal(data, &names)\n        if err != nil {\n            log.Fatal(err)\n        }\n        // return the data\n        return names.Names\n    ```", "```go\n    func main() {\n        err := addNameAndParseResponse(\"Electric\")\n        if err != nil {\n            log.Fatal(err)\n        }\n        err = addNameAndParseResponse(\"Boogaloo\")\n        if err != nil {\n            log.Fatal(err)\n        }\n        names := getDataAndParseResponse()\n        for _, name := range names {\n            log.Println(name)\n        }\n    }\n    ```", "```go\nserver.go\n1 package main\n2 import (\n3     \"encoding/json\"\n4     \"log\"\n5     \"net/http\"\n6 )\n7 var names []string\n8 type Name struct {\n9     Name string `json:\"name\"`\n10 }\n11 type Names struct {\n12     Names []string `json:\"names\"`\n13 }\n14 type Resp struct {\n15     OK bool `json:\"ok\"`\nThe full code for this step is available at: https://packt.live/2Qg5dE8\n```", "```go\n    package main\n    import (\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    )\n    ```", "```go\n    type PageWithCounter struct{\n    counter int\n    heading string\n    content string\n    }\n    func(h *PageWithCounter) ServeHTTP(w http.ResponseWriter, r *http.Request)   {\n    ```", "```go\n       h.counter++\n       msg := fmt.Sprintf(\"<h1>%s</h1>\\n<p>%s<p>\\n<p>Views: %d</p>\", h.heading,   h.content, h.counter)\n       w.Write([]byte(msg))\n    }\n    ```", "```go\n    func main() {\n      hello := PageWithCounter{heading: \"Hello World\",content:\"This is the main   page\"}\n      cha1 := PageWithCounter{heading: \"Chapter 1\",content:\"This is the first   chapter\"}\n      cha2 := PageWithCounter{heading: \"Chapter 2\",content:\"This is the second   chapter\"}\n    ```", "```go\n    http.Handle(\"/\", &hello)\n    http.Handle(\"/chapter1\", &cha1)\n    http.Handle(\"/chapter2\", &cha2)\n    ```", "```go\n      log.Fatal(http.ListenAndServe(\":8080\", nil))\n    }\n    ```", "```go\n    package main\n    import (\n       \"encoding/json\"\n       \"log\"\n       \"net/http\"\n    )\n    ```", "```go\n    type PageWithCounter struct{\n       Counter int `json:\"views\"`\n       Heading string `json:\"title\"`\n       Content string `json:\"content\"`\n    }\n    ```", "```go\n    func(h *PageWithCounter) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    ```", "```go\n       h.Counter++\n    ```", "```go\n       bts, err := json.Marshal(h)\n    ```", "```go\n       if err!=nil {\n      w.WriteHeader(400)\n      return\n       }\n    ```", "```go\n       w.Write([]byte(bts))\n    }\n    ```", "```go\n    func main() {\n       hello :=PageWithCounter{Heading: \"Hello World\",Content:\"This is the main   page\"}\n       cha1 := PageWithCounter{Heading: \"Chapter 1\",Content:\"This is the first   chapter\"}\n       cha2 := PageWithCounter{Heading: \"Chapter 2\",Content:\"This is the second   chapter\"}\n       http.Handle(\"/\", &hello)\n       http.Handle(\"/chapter1\", &cha1)\n       http.Handle(\"/chapter2\", &cha2)\n       log.Fatal(http.ListenAndServe(\":8080\", nil))\n    }\n    ```", "```go\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n      <meta charset=\"UTF-8\">\n      <title>Welcome</title>\n    </head>\n    <body>\n    ```", "```go\n      <h1>Hello {{if .Name}}{{.Name}}{{else}}visitor{{end}}</h1>\n    ```", "```go\n      <p>May I give you a warm welcome</p>\n    </body>\n    </html>\n    ```", "```go\n    package main\n    import (\n       \"html/template\"\n       \"log\"\n       \"net/http\"\n       \"strings\"\n    )\n    ```", "```go\n    type Visitor struct {\n       Name string\n    }\n    ```", "```go\n    type Hello struct {\n       tpl *template.Template\n    }\n    ```", "```go\n    func (h Hello) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    ```", "```go\n       vl := r.URL.Query()\n    ```", "```go\n       cust := Visitor{}\n       name, ok := vl[\"name\"]\n    ```", "```go\n       if ok {\n      cust.Name = strings.Join(name, \",\")\n       }\n    ```", "```go\n       h.tpl.Execute(w, cust)\n    }\n    ```", "```go\n    // NewHello returns a new Hello handler\n    func NewHello(tplPath string) (*Hello, error){\n    ```", "```go\n       tmpl, err := template.ParseFiles(tplPath)\n       if err != nil {\n      return nil, err\n       }\n    ```", "```go\n       return &Hello{tmpl}, nil\n    }\n    ```", "```go\n    func main() {\n    ```", "```go\n       hello, err := NewHello(\"./index.html\")\n       if err != nil {\n      log.Fatal(err)\n       }\n    ```", "```go\n       http.Handle(\"/\", hello)\n    ```", "```go\n       log.Fatal(http.ListenAndServe(\":8080\", nil))\n    }\n    ```", "```go\n    package main\n    import (\n        \"fmt\"\n        \"log\"\n        \"sync\"\n    )\n    ```", "```go\n    func sum(from,to int, wg *sync.WaitGroup, res *string, mtx *sync.Mutex) {\n        for i:=from;i<=to; i++ {\n            mtx.Lock()\n            *res = fmt.Sprintf(\"%s|%d|\",*res, i)\n            mtx.Unlock()\n        }\n        wg.Done()\n        return\n    }\n    ```", "```go\n    func main() {\n        s1 := \"\"\n        mtx := &sync.Mutex{}\n        wg := &sync.WaitGroup{}\n        wg.Add(4)\n        go sum(1,25, wg,&s1, mtx)\n        go sum(26,50, wg, &s1, mtx)\n        go sum(51,75, wg, &s1, mtx)\n        go sum(76,100, wg, &s1, mtx)\n        wg.Wait()\n        log.Println(s1)\n    }\n    ```", "```go\n    func sum(from,to int, wg *sync.WaitGroup, res *string, mtx *sync.Mutex) {\n        for i:=from;i<=to; i++ {\n    ```", "```go\n            mtx.Lock()\n            *res = fmt.Sprintf(\"%s|%d|\",*res, i)\n            mtx.Unlock()\n        }\n    ```", "```go\n        wg.Done()\n        return\n    }\n    ```", "```go\n    func main() {\n        s1 := \"\"\n        mtx := &sync.Mutex{}\n        wg := &sync.WaitGroup{}\n    ```", "```go\n    package main\n    import (\n        \"bufio\"\n        \"fmt\"\n        \"os\"\n        \"strconv\"\n        \"strings\"\n        \"sync\"\n    )\n    ```", "```go\n    func source(filename string, out chan int, wg *sync.WaitGroup)  {\n        f, err :=  os.Open(filename)\n        if err != nil {\n            panic(err)\n        }\n        rd := bufio.NewReader(f)\n        for {\n            str, err := rd.ReadString('\\n')\n            if err != nil {\n                if err.Error() == \"EOF\" {\n                    wg.Done()\n                    return\n                } else {\n                    panic(err)\n                }\n            }\n            iStr := strings.ReplaceAll(str, \"\\n\", \"\")\n            i, err := strconv.Atoi(iStr)\n            if err != nil {\n                panic(err)\n            }\n            out <- i\n        }\n    }\n    ```", "```go\n    func splitter(in, odd, even chan int, wg *sync.WaitGroup)  {\n        for i := range in {\n            switch i%2 {\n            case 0:\n                even <- i\n            case 1:\n                odd <- i\n            }\n        }\n        close(even)\n        close(odd)\n        wg.Done()\n    )\n    ```", "```go\n    func sum(in, out chan int, wg *sync.WaitGroup) {\n        sum := 0\n        for i := range in {\n            sum += i\n        }\n        out <- sum\n        wg.Done()\n    }\n    ```", "```go\n    func merger(even, odd chan int, wg *sync.WaitGroup, resultFile string) {\n        rs, err := os.Create(resultFile)\n        if err != nil {\n            panic(err)\n        }\n        for i:= 0; i< 2; i++{\n            select {\n            case i:= <- even:\n                rs.Write([]byte(fmt.Sprintf(\"Even %d\\n\", i)))\n            case i:= <- odd:\n                rs.Write([]byte(fmt.Sprintf(\"Odd %d\\n\", i)))\n            }\n        }\n        wg.Done()\n    }\n    ```", "```go\n    func main() {\n        wg := &sync.WaitGroup{}\n        wg.Add(2)\n        wg2 := &sync.WaitGroup{}\n        wg2.Add(4)\n        odd := make(chan int)\n        even := make(chan int)\n        out := make(chan int)\n        sumodd := make(chan int)\n        sumeven := make(chan int)\n        go source(\"./input1.dat\", out, wg)\n        go source(\"./input2.dat\", out, wg)\n        go splitter(out, odd, even, wg2)\n        go sum(even, sumeven, wg2)\n        go sum(odd, sumodd,wg2)\n        go merger(sumeven, sumodd, wg2, \"./result.txt\")\n        wg.Wait()\n        close(out)\n        wg2.Wait()\n    }\n    ```", "```go\n    rd := bufio.NewReader(f)\n        for {\n            str, err := rd.ReadString('\\n')\n    ```", "```go\n    if err.Error() == \"EOF\" {\n                    wg.Done()\n                    return\n                }\n    ```", "```go\n    iStr := strings.ReplaceAll(str, \"\\n\", \"\")\n            i, err := strconv.Atoi(iStr)\n            if err != nil {\n                panic(err)\n            }\n            out <- i\n        }\n    }\n    ```", "```go\n    func splitter(in, odd, even chan int, wg *sync.WaitGroup)  {\n    ```", "```go\n        for i := range in {\n    ```", "```go\n            switch i%2 {\n            case 0:\n                even <- i\n            case 1:\n                odd <- i\n            }\n        }\n    ```", "```go\n        close(even)\n        close(odd)\n        wg.Done()\n    }\n    ```", "```go\n    func sum(in, out chan int, wg *sync.WaitGroup) {\n        sum := 0\n        for i := range in {\n            sum += i\n        }\n        out <- sum\n        wg.Done()\n    }\n    ```", "```go\n    func merger(even, odd chan int, wg *sync.WaitGroup, resultFile string) {\n    ```", "```go\n        rs, err := os.Create(resultFile)\n        if err != nil {\n            panic(err)\n        }\n    ```", "```go\n        for i:= 0; i< 2; i++{\n    ```", "```go\n            select {\n            case i:= <- even:\n                rs.Write([]byte(fmt.Sprintf(\"Even %d\\n\", i)))\n            case i:= <- odd:\n                rs.Write([]byte(fmt.Sprintf(\"Odd %d\\n\", i)))\n            }\n        }\n        wg.Done()\n    }\n    ```", "```go\n    func main() {\n        wg := &sync.WaitGroup{}\n        wg.Add(2)\n        wg2 := &sync.WaitGroup{}\n        wg2.Add(4)\n    ```", "```go\n        odd := make(chan int)\n        even := make(chan int)\n        out := make(chan int)\n        sumodd := make(chan int)\n        sumeven := make(chan int)\n    ```", "```go\n        go source(\"./input1.dat\", out, wg)\n        go source(\"./input2.dat\", out, wg)\n        go splitter(out, odd, even, wg2)\n        go sum(even, sumeven, wg2)\n        go sum(odd, sumodd,wg2)\n        go merger(sumeven, sumodd, wg2, \"./result.txt\")\n    ```", "```go\n        wg.Wait()\n        close(out)\n    ```", "```go\n        wg2.Wait()\n    }\n    ```", "```go\n    1\n    2\n    5\n    ```", "```go\n    3\n    4\n    6\n    ```", "```go\n    go run main.go\n    ```", "```go\n    Odd 9\n    Even 12\n    ```", "```go\n    gofmt main.go\n    ```", "```go\n    gofmt -w main.go\n    ```", "```go\n    goimport main.go\n    ```", "```go\n    goimports -w main.go\n    ```", "```go\n    go vet main.go\n    ```", "```go\n    func ExampleHandler(w http.ResponseWriter, r *http.Request) {\n      w.WriteHeader(http.StatusOK)\n      fmt.Fprintf(w, \"Hello Packt\")\n      log.Println(\"completed\")\n      return\n    }\n    ```", "```go\n    go get github.com/gorilla/mux\n    ```", "```go\n    package main\n    import (\n      \"crypto/sha512\"\n      \"database/sql\"\n      \"fmt\"\n      \"os\"\n      _ \"github.com/mattn/go-sqlite3\"\n    )\n    ```", "```go\n    func getConnection() (*sql.DB, error) {\n      conn, err := sql.Open(\"sqlite3\", \"test.DB\")\n      if err != nil {\n        return nil, fmt.Errorf(\"could not open db connection %v\", err)\n      }\n      return conn, nil\n    }\n    ```", "```go\n    main.go\n    13 var testData = []*UserDetails{\n    14   {\n    15     Id:       \"1\",\n    16     Password: \"1234\",\n    17   },\n    18   {\n    19     Id:       \"2\",\n    20     Password: \"5678\",\n    21   },\n    22 }\n    23 func initializeDB(db *sql.DB) error {\n    24   _, err := db.Exec(`CREATE TABLE IF NOT EXISTS USER_DETAILS (USER_ID TEXT,     PASSWORD TEXT)`)\n    25   if err != nil {\n    26     return err\n    27   }\n    The full code for this step is available at: https://packt.live/2sUYVlg\n    ```", "```go\n    func GetPassword(db *sql.DB, userID string) (resp []byte, err error) {\n      query := `SELECT PASSWORD FROM USER_DETAILS WHERE USER_ID = ?`\n      row := db.QueryRow(query, userID)\n      switch err = row.Scan(&resp); err {\n      case sql.ErrNoRows:\n        return resp, fmt.Errorf(\"no rows returned\")\n      case nil:\n        return resp, err\n      default:\n        return resp, err\n      }\n    }\n    ```", "```go\n    main.go\n    55 func UpdatePassword(db *sql.DB, Id string, Password string) error {\n    56   query := `UPDATE USER_DETAILS SET PASSWORD=? WHERE USER_ID=?`\n    57   cipher := sha512.Sum512([]byte(Password))\n    58   fmt.Printf(\"storing encrypted password:\\n%x\\n\", string(cipher[:]))\n    59   result, err := db.Exec(query, string(cipher[:]), Id)\n    60   if err != nil {\n    61     return err\n    62   }\n    63   rows, err := result.RowsAffected()\n    64   if err != nil {\n    65     return err\n    66   }\n    The full code for this step is available at: https://packt.live/35QwJi8\n    ```", "```go\n    main.go\n    87 func main() {\n    88   db, err := getConnection()\n    89   if err != nil {\n    90     fmt.Println(err)\n    91     os.Exit(1)\n    92   }\n    93   err = initializeDB(db)\n    94   if err != nil {\n    95     fmt.Println(err)\n    96     os.Exit(1)\n    97   }\n    98   defer tearDownDB(db)\n    99   err = UpdatePassword(db, \"1\", \"NewPassword\")\n    The full code for this step is available at: https://packt.live/2PVxWPH\n    ```", "```go\n    go run -v main.go\n    ```", "```go\n    package main\n    import (\n      \"crypto\"\n      \"crypto/ecdsa\"\n      \"crypto/elliptic\"\n      \"crypto/rand\"\n      \"crypto/x509\"\n      \"crypto/x509/pkix\"\n      \"fmt\"\n      \"math/big\"\n      \"os\"\n      \"time\"\n    )\n    ```", "```go\n    main.go\n    44 func generateCert(cn string, caCert *x509.Certificate, caPriv      crypto.PrivateKey) (cert *x509.Certificate, privateKey        crypto.PrivateKey, err error) {\n    45   serialNumber, err := rand.Int(rand.Reader, big.NewInt(27))\n    46   if err != nil {\n    47     return cert, privateKey, err\n    48   }\n    49   var isCA bool\n    50   if caCert == nil {\n    51     isCA = true\n    52   }\n    53   template := &x509.Certificate{\n    54     SerialNumber:          serialNumber,\n    The full code for this step is available at: https://packt.live/39a2R24\n    ```", "```go\n    main.go\n    14 func main() {\n    15   // Generate CA certificates\n    16   caCert, caPriv, err := generateCert(\"CA cert\", nil, nil)\n    17   if err != nil {\n    18     fmt.Printf(\"error generating server certificate: %v\", err)\n    19     os.Exit(1)\n    20   } else {\n    21     fmt.Println(\"ca certificate generated successfully\")\n    22    }\n    23   // User CA cert to generate and sign server certificate\n    24   cert, _, err := generateCert(\"Test Cert\", caCert, caPriv)\n    The full code for this step is available at: https://packt.live/398aM04\n    ```", "```go\n    go run main.go\n    ```", "```go\n    gobin:activity2 Gobin$ go run main.go\n    ca certificate generated successfully \n    leaf certificate generated successfully\n    leaf certificate successfully verified\n    ```", "```go\n    package custom\n    import \"fmt\"\n    func Print() {\n      fmt.Println(\"Hello I am running on a darwin machine.\")\n    }\n    ```", "```go\n    import \"fmt\"\n    func Print() {\n      fmt.Println(\"Hello I am running on 386 machine.\")\n    }\n    ```", "```go\n    go run main.go\n    ```", "```go\n    $ go run main.go\n    Hello I am running on a darwin machine.\n    ```", "```go\n    package package1\n    import \"testing\"\n    func TestPackage1(t *testing.T){\n      t.Log(\"running TestPackage1\")\n    }\n    ```", "```go\n    package package2\n    import \"testing\"\n    func TestPackage2(t *testing.T){\n      t.Log(\"running TestPackage2\")\n    }\n    ```", "```go\n    go test -v ./...\n    ```"]