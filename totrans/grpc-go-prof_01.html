<html><head></head><body>
<div id="_idContainer016">
<h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor014"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.2.1">Networking Primer</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Communication over networks is at the core of all of our modern technology and gRPC is one of the high-level frameworks that we can use to achieve efficient reception and transmission of data. </span><span class="koboSpan" id="kobo.3.2">As it is high level, it gives you abstractions for sending and receiving data without thinking about all the things that could go wrong when communicating over the wire. </span><span class="koboSpan" id="kobo.3.3">In this chapter, the goal is to understand, at a lower level (not the lowest), what happens when we send/receive messages in gRPC Go. </span><span class="koboSpan" id="kobo.3.4">This will help you get a sense of what’s going on and, later on, when we talk about debugging and observability, you’ll be able to grasp the concepts presented </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">more easily.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">main topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.7.1">HTTP/2</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.8.1">RPC operations</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.9.1">RPC types</span></span></li>
<li><span class="koboSpan" id="kobo.10.1">The life cycle of </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">an RPC</span></span></li>
</ul>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.12.1">Prerequisites</span></h1>
<p><span class="koboSpan" id="kobo.13.1">In this chapter, I will be using </span><a href="https://www.wireshark.org"><strong class="bold"><span class="koboSpan" id="kobo.14.1">Wireshark</span></strong></a><span class="koboSpan" id="kobo.15.1"> (</span><a href="https://www.wireshark.org/)"><span class="koboSpan" id="kobo.16.1">https://www.wireshark.org/)</span></a><span class="koboSpan" id="kobo.17.1"> to analyze a gRPC call and get the necessary captures that illustrate the different concepts presented. </span><span class="koboSpan" id="kobo.17.2">As this is still early in this book, I do not expect you to reproduce all of this. </span><span class="koboSpan" id="kobo.17.3">However, if you plan to do a little bit more digging, you can install Wireshark and open the capture files provided in the Git repository (</span><a href="https://github.com/PacktPublishing/gRPC-Go-for-Professionals"><span class="koboSpan" id="kobo.18.1">https://github.com/PacktPublishing/gRPC-Go-for-Professionals</span></a><span class="koboSpan" id="kobo.19.1">) under the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.20.1">chapter1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.21.1"> directory.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">To display these capture files, you can simply import them into Wireshark and apply a display filter to them. </span><span class="koboSpan" id="kobo.22.2">As we are interested specifically in HTTP/2 and gRPC payloads, and I was using port </span><strong class="source-inline"><span class="koboSpan" id="kobo.23.1">50051</span></strong><span class="koboSpan" id="kobo.24.1"> for communication, you can use the following filter: </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">tcp.port == 50051 and (grpc </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.26.1">or http2)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">.</span></span></p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.28.1">Understanding HTTP/2</span></h1>
<p><span class="koboSpan" id="kobo.29.1">If you are </span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.30.1">reading this book, I’m going to assume that you have familiarity with HTTP/1.1 or that at least you have a sense of how to make traditional HTTP API calls over the network. </span><span class="koboSpan" id="kobo.30.2">I guess so because most of the APIs that we interact with, as developers, have concepts that were brought about by this protocol. </span><span class="koboSpan" id="kobo.30.3">I’m talking about concepts such as headers, which can provide metadata for a call; the body, which contains the main data; and actions such as GET, POST, UPDATE, and so on, which define what you intend to do with the data in </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">the body.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">HTTP/2 still has all of these concepts but improves efficiency, security, and usability in a few ways. </span><span class="koboSpan" id="kobo.32.2">The first advantage of HTTP/2 over plain old HTTP/1.1 is the compression down to binary. </span><span class="koboSpan" id="kobo.32.3">Before HTTP/2, everything sent over the network was pure text and it was up to the user to compress it or not. </span><span class="koboSpan" id="kobo.32.4">With version 2, every part of the HTTP semantic is translated down to binary, thus making it faster for computers to serialize and deserialize data between calls and thereby reducing the request/response </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">payload size.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">The second advantage that HTTP/2 has is a feature called server push. </span><span class="koboSpan" id="kobo.34.2">This is a feature that gives the server the ability to send multiple responses for only one call from the client. </span><span class="koboSpan" id="kobo.34.3">The overall goal here is to reduce the chatter between the server and client, and thus the total payload to reach the same end result. </span><span class="koboSpan" id="kobo.34.4">Without this feature, when a client wants to request a web page and all its resources, it has to do a request per resource. </span><span class="koboSpan" id="kobo.34.5">However, with the server push feature, the client can just send a request for a web page, and the server will return that web page, then return the CSS and potentially some JS script. </span><span class="koboSpan" id="kobo.34.6">This results in only one call from the client, instead </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">of three.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer005">
<span class="koboSpan" id="kobo.36.1"><img alt="Figure 1.1 – HTTP/2 server push" src="image/B19664_01_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.37.1">Figure 1.1 – HTTP/2 server push</span></p>
<p><span class="koboSpan" id="kobo.38.1">Another</span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.39.1"> important efficiency aspect is the creation of a long-lived TCP connection instead of individual connections per request. </span><span class="koboSpan" id="kobo.39.2">In HTTP/0.9, every call is preceded by the creation of a TCP connection and succeeded by the closing of that connection. </span><span class="koboSpan" id="kobo.39.3">This is highly inefficient for today’s use of </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">the internet.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">Then, HTTP/1.1 introduced the concept of KeepAlive, which permitted the reuse of a single TCP connection. </span><span class="koboSpan" id="kobo.41.2">However, this didn’t mean that we could send interleaved packets to fulfill multiple requests concurrently; it meant that after finishing request one, we could reuse the same connection for </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">request two.</span></span><span class="koboSpan" id="kobo.43.1">
This was probably fine in 1997 when the protocol was released, but nowadays we make more and more requests, and also bigger and bigger ones, and waiting for requests to finish before starting another one is not feasible. </span><span class="koboSpan" id="kobo.43.2">HTTP/2 solves this by creating a single long-lived connection that can handle multiple requests and responses as </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">interleaved packets.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer006">
<span class="koboSpan" id="kobo.45.1"><img alt="Figure 1.2 – HTTP/2 interleaved packets over the wire" src="image/B19664_01_002.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.46.1">Figure 1.2 – HTTP/2 interleaved packets over the wire</span></p>
<p><span class="koboSpan" id="kobo.47.1">What’s presented</span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.48.1"> here is obviously an oversimplification of the HTTP/2 protocol. </span><span class="koboSpan" id="kobo.48.2">It would take a book in itself to explain all the implementation details of the protocol. </span><span class="koboSpan" id="kobo.48.3">As we talk about gRPC, we mostly need to understand that in HTTP/2, we can send structured binary messages over the wire instead of text, we can have streams where the server can send multiple responses for one response, and finally, we do that in an efficient way because we only create one TCP connection and it will handle multiple requests and responses. </span><span class="koboSpan" id="kobo.48.4">However, it is also important to understand that gRPC has its own communication protocol on top of HTTP/2. </span><span class="koboSpan" id="kobo.48.5">This means that aIl the HTTP protocol improvements presented here are facilitators for communication. </span><span class="koboSpan" id="kobo.48.6">gRPC uses all of these in conjunction with four </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">RPC operations.</span></span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.50.1">RPC operations</span></h1>
<p><span class="koboSpan" id="kobo.51.1">Each interaction </span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.52.1">done with gRPC between the server and the client can be described as four RPC operations. </span><span class="koboSpan" id="kobo.52.2">These operations are composed in a way that creates complex high-level operations in the framework. </span><span class="koboSpan" id="kobo.52.3">Let us see these operations and then</span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.53.1"> I will explain how a simple gRPC call </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">uses them.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.55.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.56.1">In this section, I’m going to use Wireshark’s result for an RPC call. </span><span class="koboSpan" id="kobo.56.2">I will explain how to replicate what I did in this section later in the book. </span><span class="koboSpan" id="kobo.56.3">For now, I will just highlight what is important to notice in </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">the dumps.</span></span></p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.58.1">Send Header</span></h2>
<p><span class="koboSpan" id="kobo.59.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">Send Header</span></strong><span class="koboSpan" id="kobo.61.1"> operation</span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.62.1"> lets the server </span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.63.1">know that the client will send a request or lets the client know that the server will send a response. </span><span class="koboSpan" id="kobo.63.2">This acts as a switch between the server and client to let both sides know who needs to read and who needs </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">to write.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">By using Wireshark to analyze a simple gRPC call, we can observe the following header (simplified) being sent by the client in order to let the server know that it will send </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">a request:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.67.1">HyperText Transfer Protocol 2</span></strong><span class="koboSpan" id="kobo.68.1">
    Stream: </span><strong class="bold"><span class="koboSpan" id="kobo.69.1">HEADERS</span></strong><span class="koboSpan" id="kobo.70.1">, Stream ID: 1, Length 67, </span><strong class="bold"><span class="koboSpan" id="kobo.71.1">POST</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.72.1">        /greet.GreetService/Greet</span></strong><span class="koboSpan" id="kobo.73.1">
        Flags: 0x04, End Headers
            00.0 ..0. </span><span class="koboSpan" id="kobo.73.2">= Unused: 0x00
            ..0. </span><span class="koboSpan" id="kobo.73.3">.... </span><span class="koboSpan" id="kobo.73.4">= Priority: False
            .... </span><span class="koboSpan" id="kobo.73.5">0... </span><span class="koboSpan" id="kobo.73.6">= Padded: False
            .... </span><span class="koboSpan" id="kobo.73.7">.1.. </span><span class="koboSpan" id="kobo.73.8">= </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">End Headers: True</span></strong><span class="koboSpan" id="kobo.75.1">
            .... </span><span class="koboSpan" id="kobo.75.2">...0 = </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">End Stream: False</span></strong><span class="koboSpan" id="kobo.77.1">
         Header: :method: POST
         Header: content-type: application/grpc</span></pre>
<p><span class="koboSpan" id="kobo.78.1">What is</span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.79.1"> important to note in this header is that it mentions that the client wants to call HTTP POST on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">/greet.GreetService/Greet</span></strong><span class="koboSpan" id="kobo.81.1"> route and then in the flags, it mentions that this is the end of the </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">header data.</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">Then, later</span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.84.1"> in the call, we will see the following header (simplified) sent by the server to let the client know that it will send </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">the response:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.86.1">HyperText Transfer Protocol 2</span></strong><span class="koboSpan" id="kobo.87.1">
    Stream: </span><strong class="bold"><span class="koboSpan" id="kobo.88.1">HEADERS</span></strong><span class="koboSpan" id="kobo.89.1">, Stream ID: 1, Length 14, </span><strong class="bold"><span class="koboSpan" id="kobo.90.1">200 OK</span></strong><span class="koboSpan" id="kobo.91.1">
        Flags: 0x04, End Headers
            00.0 ..0. </span><span class="koboSpan" id="kobo.91.2">= Unused: 0x00
            ..0. </span><span class="koboSpan" id="kobo.91.3">.... </span><span class="koboSpan" id="kobo.91.4">= Priority: False
            .... </span><span class="koboSpan" id="kobo.91.5">0... </span><span class="koboSpan" id="kobo.91.6">= Padded: False
          </span><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.92.1">  .... </span><span class="koboSpan" id="kobo.92.2">.1.. </span><span class="koboSpan" id="kobo.92.3">= </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">End Headers: True</span></strong><span class="koboSpan" id="kobo.94.1">
            .... </span><span class="koboSpan" id="kobo.94.2">...0 = </span><strong class="bold"><span class="koboSpan" id="kobo.95.1">End Stream: False</span></strong><span class="koboSpan" id="kobo.96.1">
        Header: </span><strong class="bold"><span class="koboSpan" id="kobo.97.1">:status: 200 OK</span></strong><span class="koboSpan" id="kobo.98.1">
        Header: content-type: application/grpc</span></pre>
<p><span class="koboSpan" id="kobo.99.1">And here, once again, we can see that this is a header and that this is the last one that will be sent. </span><span class="koboSpan" id="kobo.99.2">The main difference though, is that the server is telling the client that the request was handled properly, and it says that by sending a </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">code 200.</span></span></p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.101.1">Send Message</span></h2>
<p><span class="koboSpan" id="kobo.102.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">Send Message</span></strong><span class="koboSpan" id="kobo.104.1"> operation</span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.105.1"> is the operation</span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.106.1"> that sends the actual data. </span><span class="koboSpan" id="kobo.106.2">This is the operation that matters the most to us as API developers. </span><span class="koboSpan" id="kobo.106.3">After sending the header, the client can send a message as a request and the server can send a message as </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">a response.</span></span></p>
<p><span class="koboSpan" id="kobo.108.1">By using Wireshark to analyze the same gRPC call as we did for </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">Send Header</span></strong><span class="koboSpan" id="kobo.110.1">, we can observe the following data (simplified) being sent by the client as </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">a request:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.112.1">GRPC Message</span></strong><span class="koboSpan" id="kobo.113.1">: /</span><strong class="bold"><span class="koboSpan" id="kobo.114.1">greet.GreetService/Greet</span></strong><span class="koboSpan" id="kobo.115.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">Request</span></strong><span class="koboSpan" id="kobo.117.1">
    0... </span><span class="koboSpan" id="kobo.117.2">.... </span><span class="koboSpan" id="kobo.117.3">= Frame Type: Data (0)
    .... </span><span class="koboSpan" id="kobo.117.4">...0 = Compressed Flag: Not Compressed (0)
    Message Length: 9
    Message Data: 9 bytes
</span><strong class="bold"><span class="koboSpan" id="kobo.118.1">Protocol Buffers</span></strong><span class="koboSpan" id="kobo.119.1">: /greet.GreetService/Greet,</span><strong class="bold"><span class="koboSpan" id="kobo.120.1">request</span></strong><span class="koboSpan" id="kobo.121.1">
    Message: &lt;UNKNOWN&gt; Message Type
        Field(1):
            [Field Name: &lt;UNKNOWN&gt;]
            .000 1... </span><span class="koboSpan" id="kobo.121.2">= Field Number: 1
            .... </span><span class="koboSpan" id="kobo.121.3">.010 = Wire Type: Length-delimited (2)
            Value Length: 7
            Value: </span><strong class="bold"><span class="koboSpan" id="kobo.122.1">436c656d656e74</span></strong></pre>
<p><span class="koboSpan" id="kobo.123.1">What is important to note in this header is that it mentions that the client sends data on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">/greet.GreetService/Greet</span></strong><span class="koboSpan" id="kobo.125.1"> route, which is the same as the one that was sent in the header. </span><span class="koboSpan" id="kobo.125.2">And then, we can see that we are sending Protocol Buffers data (more on that later) and that the binary value of that message </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">436c656d656e74</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">After, later</span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.130.1"> in the call, just after the server header, we see the following data (simplified) sent by the </span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.131.1">server as </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">a response:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.133.1">GRPC Message</span></strong><span class="koboSpan" id="kobo.134.1">: </span><strong class="bold"><span class="koboSpan" id="kobo.135.1">/greet.GreetService/Greet</span></strong><span class="koboSpan" id="kobo.136.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.137.1">Response</span></strong><span class="koboSpan" id="kobo.138.1">
    0... </span><span class="koboSpan" id="kobo.138.2">.... </span><span class="koboSpan" id="kobo.138.3">= Frame Type: Data (0)
    .... </span><span class="koboSpan" id="kobo.138.4">...0 = Compressed Flag: Not Compressed (0)
    Message Length: 15
    Message Data: 15 bytes
</span><strong class="bold"><span class="koboSpan" id="kobo.139.1">Protocol Buffers</span></strong><span class="koboSpan" id="kobo.140.1">: /greet.GreetService/Greet,</span><strong class="bold"><span class="koboSpan" id="kobo.141.1">response</span></strong><span class="koboSpan" id="kobo.142.1">
    Message: &lt;UNKNOWN&gt; Message Ty</span><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.143.1">pe
        Field(1):
            [Field Name: &lt;UNKNOWN&gt;]
            .000 1... </span><span class="koboSpan" id="kobo.143.2">= Field Number: 1
            .... </span><span class="koboSpan" id="kobo.143.3">.010 = Wire Type: Length-delimited (2)
            Value Length: 13
            Value: </span><strong class="bold"><span class="koboSpan" id="kobo.144.1">48656c6c6f20436c656d656e74</span></strong></pre>
<p><span class="koboSpan" id="kobo.145.1">And here, we can see that this is a message sent as a response to a call made on route </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">/greet.GreetService/Greet</span></strong><span class="koboSpan" id="kobo.147.1"> and the binary value of that message </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">48656c6c6f20436c656d656e74</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">.</span></span></p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.151.1">Send Half Close</span></h2>
<p><span class="koboSpan" id="kobo.152.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">Send Half Close</span></strong><span class="koboSpan" id="kobo.154.1"> operation</span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.155.1"> closes either</span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.156.1"> the input or the output of an actor. </span><span class="koboSpan" id="kobo.156.2">For example, in a traditional request/response setting, when the client is done sending the request, sending a </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">Half Close</span></strong><span class="koboSpan" id="kobo.158.1"> closes the client stream. </span><span class="koboSpan" id="kobo.158.2">This is a little bit like </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">Send Header</span></strong><span class="koboSpan" id="kobo.160.1"> in the sense that it is acting as a switch to let the server know that it is time </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">to work.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">Once again, if </span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.163.1">we look at the Wireshark transcript for the same gRPC call, we should be able to see</span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.164.1"> that a header was set during the </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">Send Message</span></strong><span class="koboSpan" id="kobo.166.1"> operations. </span><span class="koboSpan" id="kobo.166.2">We can observe the following </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">data (simplified):</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.168.1">HyperText Transfer Protocol 2</span></strong><span class="koboSpan" id="kobo.169.1">
    Stream: </span><strong class="bold"><span class="koboSpan" id="kobo.170.1">DATA</span></strong><span class="koboSpan" id="kobo.171.1">, Stream ID: 1, Length 14
        Length: 14
        Type: DATA (0)
        Flags: 0x01, End Stream
            0000 .00. </span><span class="koboSpan" id="kobo.171.2">= Unused: 0x00
            .... </span><span class="koboSpan" id="kobo.171.3">0... </span><span class="koboSpan" id="kobo.171.4">= Padded: False
            .... </span><span class="koboSpan" id="kobo.171.5">...1 = </span><strong class="bold"><span class="koboSpan" id="kobo.172.1">End Stream: True</span></strong></pre>
<p><span class="koboSpan" id="kobo.173.1">This time, we have a flag that denotes the end of the request. </span><span class="koboSpan" id="kobo.173.2">Notice however that here, we are sending a payload of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">DATA</span></strong><span class="koboSpan" id="kobo.175.1">. </span><span class="koboSpan" id="kobo.175.2">This is different than what we saw up until now because </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">DATA</span></strong><span class="koboSpan" id="kobo.177.1"> is much lighter than a header. </span><span class="koboSpan" id="kobo.177.2">This is used for the Half Close because we simply </span><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.178.1">want to send a boolean saying that the client </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">is done.</span></span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.180.1">Send Trailer</span></h2>
<p><span class="koboSpan" id="kobo.181.1">And finally, we </span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.182.1">have an operation for terminating an</span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.183.1"> entire RPC. </span><span class="koboSpan" id="kobo.183.2">This is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">Send Trailer</span></strong><span class="koboSpan" id="kobo.185.1"> operation. </span><span class="koboSpan" id="kobo.185.2">This operation also gives us more information about the call, such as the status code, error message, and so on. </span><span class="koboSpan" id="kobo.185.3">At this point in the book, we only need to know that this information is mostly necessary for handling </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">API errors.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">If we take a look at the same Wireshark call, we will have the following </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">data (simplified):</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.189.1">HyperText Transfer Protocol 2</span></strong><span class="koboSpan" id="kobo.190.1">
    Stream: </span><strong class="bold"><span class="koboSpan" id="kobo.191.1">HEADERS</span></strong><span class="koboSpan" id="kobo.192.1">, Stream ID: 1, Length 24
        Length: 24
        Type: HEADERS (1)
        Flags: 0x05, End Headers, End Stream
            00.0 ..0. </span><span class="koboSpan" id="kobo.192.2">= Unused: 0x00
            ..0. </span><span class="koboSpan" id="kobo.192.3">.... </span><span class="koboSpan" id="kobo.192.4">= Priority: False
            .... </span><span class="koboSpan" id="kobo.192.5">0... </span><span class="koboSpan" id="kobo.192.6">= Padded: False
            .... </span><span class="koboSpan" id="kobo.192.7">.1.. </span><span class="koboSpan" id="kobo.192.8">= </span><strong class="bold"><span class="koboSpan" id="kobo.193.1">End Headers: True</span></strong><span class="koboSpan" id="kobo.194.1">
            .... </span><span class="koboSpan" id="kobo.194.2">...1 = </span><strong class="bold"><span class="koboSpan" id="kobo.195.1">End Stream: True</span></strong><span class="koboSpan" id="kobo.196.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.197.1">Header: grpc-status: 0</span></strong><span class="koboSpan" id="kobo.198.1">
        </span><strong class="bold"><span class="koboSpan" id="kobo.199.1">Header: grpc-message:</span></strong></pre>
<p><span class="koboSpan" id="kobo.200.1">Note that </span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.201.1">the trailer is basically a header. </span><span class="koboSpan" id="kobo.201.2">With this header, we </span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.202.1">will get more information about the call (</span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">grpc-status</span></strong><span class="koboSpan" id="kobo.204.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">grpc-message</span></strong><span class="koboSpan" id="kobo.206.1">). </span><span class="koboSpan" id="kobo.206.2">And then we receive two flags – one saying that this is the end of the stream (in our case, request/response). </span><span class="koboSpan" id="kobo.206.3">And another one to say that this trailer </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">ends here.</span></span></p>
<h1 id="_idParaDest-24"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.208.1">RPC types</span></h1>
<p><span class="koboSpan" id="kobo.209.1">Now that</span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.210.1"> we know that there are four RPC operations, we can see how they are combined to create the different RPC types that gRPC provides. </span><span class="koboSpan" id="kobo.210.2">We will talk about the Unary, Server Streaming, Client Streaming, and Bidirectional RPC types. </span><span class="koboSpan" id="kobo.210.3">We will see that each type presented is a combination of the RPC operations </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">presented earlier.</span></span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.212.1">Unary</span></h2>
<p><span class="koboSpan" id="kobo.213.1">A </span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.214.1">unary RPC</span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.215.1"> is an RPC that performs one request and returns one response. </span><span class="koboSpan" id="kobo.215.2">We already touched upon this in the previous section, but let us go ahead and make the </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">process clearer.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">As always, the first step is the client sending the initial header. </span><span class="koboSpan" id="kobo.217.2">This header will contain the information related to the RPC endpoint that we want to invoke. </span><span class="koboSpan" id="kobo.217.3">As of this point in the book, we simply need to know that this mostly includes the RPC route and the stream ID. </span><span class="koboSpan" id="kobo.217.4">The former is to let the server know which user code function it should call to process the request. </span><span class="koboSpan" id="kobo.217.5">The latter is a way to identify on which stream the data should be sent. </span><span class="koboSpan" id="kobo.217.6">This is because we can have multiple streams going on at the </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">same time.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">Since the server is now aware of the fact that the client will send a request, the client can now send a message. </span><span class="koboSpan" id="kobo.219.2">This message will contain the actual request payload. </span><span class="koboSpan" id="kobo.219.3">In our case, we are going to only send Protocol Buffers encoded data, but be aware that you can send any kind of data </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">with gRPC.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">After that, because we are in a unary setting, the client is done sending the request. </span><span class="koboSpan" id="kobo.221.2">As we know, the client itself should now send a Half Close. </span><span class="koboSpan" id="kobo.221.3">This is saying to the server </span><em class="italic"><span class="koboSpan" id="kobo.222.1">I’m done, please send me </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.223.1">the response.</span></em></span></p>
<p><span class="koboSpan" id="kobo.224.1">At this point, the server will do similar work. </span><span class="koboSpan" id="kobo.224.2">As shown in the next figure, it will send a header, send the response as a Protobuf encoded message, and end the RPC. </span><span class="koboSpan" id="kobo.224.3">However, as we know, the server will not send a Half Close; it will send the Trailer. </span><span class="koboSpan" id="kobo.224.4">This is some data that says whether or not the call was successful, has an optional error message, and some other key-value pairs that we can add through the </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">user code.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer007">
<span class="koboSpan" id="kobo.226.1"><img alt="Figure 1.3 – Unary RPC flow" src="image/B19664_01_003.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.227.1">Figure 1.3 – Unary RPC flow</span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.228.1">Server streaming</span></h2>
<p><span class="koboSpan" id="kobo.229.1">A </span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.230.1">server streaming RPC is an RPC that performs one request and</span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.231.1"> returns one or more responses. </span><span class="koboSpan" id="kobo.231.2">This RPC type is useful for situations where the client is expecting to get updates from the server. </span><span class="koboSpan" id="kobo.231.3">For example, we could have a client display the stock prices for selected companies. </span><span class="koboSpan" id="kobo.231.4">With server streaming, the client could subscribe and the server could send different prices </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">In this situation, nothing changes for the client. </span><span class="koboSpan" id="kobo.233.2">It will send the header, the message, and the Half Close. </span><span class="koboSpan" id="kobo.233.3">However, on the server side, we are going to interleave HTTP data messages and </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">data payloads.</span></span></p>
<p><span class="koboSpan" id="kobo.235.1">As shown in the following figure, the server will first send its header. </span><span class="koboSpan" id="kobo.235.2">This is customary when an actor wants to let the other one know that it will send messages. </span><span class="koboSpan" id="kobo.235.3">After that, as mentioned above, the server will alternate between sending HTTP data messages and Protobuf payloads. </span><span class="koboSpan" id="kobo.235.4">The first data messages will look like </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">this (simplified):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.237.1">
HyperText Transfer Protocol 2
    Stream: </span><strong class="bold"><span class="koboSpan" id="kobo.238.1">DATA</span></strong><span class="koboSpan" id="kobo.239.1">, Stream ID: 1, Length 30
        Length: 30
        Type: DATA (0)
        Flags: 0x00
            0000 .00. </span><span class="koboSpan" id="kobo.239.2">= Unused: 0x00
            .... </span><span class="koboSpan" id="kobo.239.3">0... </span><span class="koboSpan" id="kobo.239.4">= Padded: False
            .... </span><span class="koboSpan" id="kobo.239.5">...0 = </span><strong class="bold"><span class="koboSpan" id="kobo.240.1">End Stream: False</span></strong></pre>
<p><span class="koboSpan" id="kobo.241.1">This says</span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.242.1"> that a message will be sent. </span><span class="koboSpan" id="kobo.242.2">This is a lightweight </span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.243.1">header. </span><span class="koboSpan" id="kobo.243.2">And later, once we arrive at the last message to be sent, the server will finish the RPC with the trailer, and at that point, the client will know that the server is done </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">sending responses.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer008">
<span class="koboSpan" id="kobo.245.1"><img alt="Figure 1.4 – Server streaming flow" src="image/B19664_01_004.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.246.1">Figure 1.4 – Server streaming flow</span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.247.1">Client streaming</span></h2>
<p><span class="koboSpan" id="kobo.248.1">A</span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.249.1"> client streaming RPC is</span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.250.1"> similar to server streaming, but this time, the client can send one or more requests and the server returns one response. </span><span class="koboSpan" id="kobo.250.2">This is useful in situations where the client sends real-time information to the server. </span><span class="koboSpan" id="kobo.250.3">For example, this might be useful for microcontrollers to send data coming from some kind of sensor and update the server on the current state of what the sensor </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">is measuring.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">Client streaming is similar to server streaming. </span><span class="koboSpan" id="kobo.252.2">As you can see in the following figure, the client will do what the server did in server streaming. </span><span class="koboSpan" id="kobo.252.3">This means that the client will interleave HTTP data messages, which are like the ones previously mentioned about server streaming, with the Protobuf messages. </span><span class="koboSpan" id="kobo.252.4">And in the end, when the client is done, it will simply send a </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">Half Close.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer009">
<span class="koboSpan" id="kobo.254.1"><img alt="Figure 1.5 – Client streaming flow" src="image/B19664_01_005.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.255.1">Figure 1.5 – Client streaming flow</span></p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor030"/><span class="koboSpan" id="kobo.256.1">Bidirectional streaming</span></h2>
<p><span class="koboSpan" id="kobo.257.1">By now, you</span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.258.1"> might have guessed that bidirectional streaming</span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.259.1"> is a mix of server streaming and client streaming. </span><span class="koboSpan" id="kobo.259.2">A client can send one or more requests and the server returns one or more responses. </span><span class="koboSpan" id="kobo.259.3">This is especially useful when one of the actors needs feedback on its data. </span><span class="koboSpan" id="kobo.259.4">For example, if you have an app to find taxis, it might not be enough for the server to send updates about cabs. </span><span class="koboSpan" id="kobo.259.5">The user might also walk toward their destination in the hope of catching a taxi on the road. </span><span class="koboSpan" id="kobo.259.6">Thus, the server also needs to know the </span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">user’s location.</span></span></p>
<p><span class="koboSpan" id="kobo.261.1">Bidirectional streaming is less predictable than client and server streaming. </span><span class="koboSpan" id="kobo.261.2">This is because there is no defined order in which each actor will send messages. </span><span class="koboSpan" id="kobo.261.3">The server could give a response per request or any number of requests. </span><span class="koboSpan" id="kobo.261.4">Thus, for this section, let us pretend that we are working with a server that returns a response </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">per request.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">In this case, as you can see in the following figure, the client will send a header and a message. </span><span class="koboSpan" id="kobo.263.2">Then, the server will send its header and message. </span><span class="koboSpan" id="kobo.263.3">And after that, we will get data and a message </span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.264.1">per actor. </span><span class="koboSpan" id="kobo.264.2">And finally, we will get the Half Close from the client and the Trailer from </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">the server.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer010">
<span class="koboSpan" id="kobo.266.1"><img alt="Figure 1.6 – Bidirectional streaming flow" src="image/B19664_01_006.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.267.1">Figure 1.6 – Bidirectional streaming flow</span></p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor031"/><span class="koboSpan" id="kobo.268.1">The life cycle of an RPC</span></h1>
<p><span class="koboSpan" id="kobo.269.1">Now that </span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.270.1">we understand the basic RPC operations that can be executed in gRPC and the different types of RPC, we can take a look at the life cycle of an RPC. </span><span class="koboSpan" id="kobo.270.2">In this section, we are going to go top-down by first explaining the overall idea of what is happening when a client sends a request and the server receives it, sends a response, and the client receives it. </span><span class="koboSpan" id="kobo.270.3">And after that, we will go a bit deeper and talk about </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">three stages:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.272.1">The connection – What happens when a client connects to </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">a server?</span></span></li>
<li><span class="koboSpan" id="kobo.274.1">The client side – What happens when a client sends </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">a message?</span></span></li>
<li><span class="koboSpan" id="kobo.276.1">The server side – What happens when a server receives </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">a message?</span></span></li>
</ol>
<p class="callout-heading"><span class="koboSpan" id="kobo.278.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.279.1">gRPC has multiple implementations in different languages. </span><span class="koboSpan" id="kobo.279.2">The original one was in C++ and some implementations are just wrappers around the C++ code. </span><span class="koboSpan" id="kobo.279.3">However, gRPC Go is a standalone implementation. </span><span class="koboSpan" id="kobo.279.4">This means that it was implemented from scratch in Go and doesn’t wrap up the C++ code. </span><span class="koboSpan" id="kobo.279.5">As such, in this section, we are going to talk specifically about gRPC Go, and this might prove to be implemented differently in </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">other implementations.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">Before going</span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.282.1"> into too much detail, let’s start with a bird’s-eye view by defining some concepts. </span><span class="koboSpan" id="kobo.282.2">The first thing that we need to be clear on is that gRPC is driven by generated code in the user code. </span><span class="koboSpan" id="kobo.282.3">This means that we interact with only a few points of the gRPC API and we mostly deal with code that was generated based on our Protocol Buffer service definition. </span><span class="koboSpan" id="kobo.282.4">Do not worry too much about that yet; we are going to cover that in the </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">last section.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">The second important concept is the concept of transport. </span><span class="koboSpan" id="kobo.284.2">The transport can be seen as the manager of the connection between the actors and it sends/receives raw bytes over the network. </span><span class="koboSpan" id="kobo.284.3">It contains a read-write stream that is designed to be able to read and write over the network in any order. </span><span class="koboSpan" id="kobo.284.4">And the most important aspect in our case is that we can call the read on an </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">io.Reader</span></strong><span class="koboSpan" id="kobo.286.1"> and we can call write on </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">an </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">io.Writer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">Finally, the last thing to clarify is that a client and a server are very similar. </span><span class="koboSpan" id="kobo.290.2">All the functions called on the client will be called on the server too. </span><span class="koboSpan" id="kobo.290.3">They will simply be called on different objects (for instance, </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">ClientTransport</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.292.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">ServerTransport</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">Now, that we understand all of this, we can take a look at a visual representation of the life cycle of </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">an RPC.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<span class="koboSpan" id="kobo.297.1"><img alt="Figure 1.7 – Bird’s-eye view of the RPC life cycle" src="image/B19664_01_007.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.298.1">Figure 1.7 – Bird’s-eye view of the RPC life cycle</span></p>
<p><span class="koboSpan" id="kobo.299.1">We can </span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.300.1">see that we can simply define only one generic actor and that it will represent both a server and a client. </span><span class="koboSpan" id="kobo.300.2">Then, we can see that the generated code will interact directly with the gRPC framework by calling a function </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">SendMsg</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.304.1">This is designed, as its name suggests, to send data over the network. </span><span class="koboSpan" id="kobo.304.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">SendMsg</span></strong><span class="koboSpan" id="kobo.306.1"> function will call a lower-level function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">Write</span></strong><span class="koboSpan" id="kobo.308.1">. </span><span class="koboSpan" id="kobo.308.2">This is the function provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">io.Writer</span></strong><span class="koboSpan" id="kobo.310.1"> in the Transport. </span><span class="koboSpan" id="kobo.310.2">Once this is done, the other actor will read on an </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">io.Reader</span></strong><span class="koboSpan" id="kobo.312.1">, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">RcvMsg</span></strong><span class="koboSpan" id="kobo.314.1"> function, and finally, the user code will receive </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">the data.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">We are now going to go a bit deeper into the important parts of gRPC communication. </span><span class="koboSpan" id="kobo.316.2">And as for every kind of transmission over the wire, the client needs to connect to a server, we are going to start with the specifics of </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">a connection.</span></span></p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor032"/><span class="koboSpan" id="kobo.318.1">The connection</span></h2>
<p><span class="koboSpan" id="kobo.319.1">To </span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.320.1">create a connection, the client code will call a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">Dial</span></strong><span class="koboSpan" id="kobo.322.1"> with a target URI and some options as parameters. </span><span class="koboSpan" id="kobo.322.2">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">Dial</span></strong><span class="koboSpan" id="kobo.324.1"> request is received, the gRPC framework will parse the target address according to RFC 3986 and it will create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">Resolver</span></strong><span class="koboSpan" id="kobo.326.1"> depending on the scheme of the URI. </span><span class="koboSpan" id="kobo.326.2">So, for example, if we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">dns:</span><a id="_idTextAnchor033"/><span class="koboSpan" id="kobo.328.1">//</span></strong><span class="koboSpan" id="kobo.329.1"> scheme, which is the default scheme that gRPC uses when we omit the scheme in the URI or if the scheme provided is unknown, gRPC will create a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">dnsResolver</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.331.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.332.1">dnsResolver Then the resolver will do its job, which is resolving the hostname and returning a list of addresses that can be connected to. </span><span class="koboSpan" id="kobo.332.2">With these addresses, gRPC will create a load balancer based on the configuration the user passed in the Dial options. </span><span class="koboSpan" id="kobo.332.3">The framework provides two load balancers </span><span class="No-Break"><span class="koboSpan" id="kobo.333.1">by default:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.334.1">Pick first (the default), which connects to the first address it can connect to, and sends all the RPCs </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">to it</span></span></li>
<li><span class="koboSpan" id="kobo.336.1">Round robin, which connects to all the addresses and sends an RPC to each backend one at a time and </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">in order</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.338.1">As we can see, the goal of the load balancer is to find out on which address(es) the client should create a connection(s). </span><span class="koboSpan" id="kobo.338.2">So, it will return a list of addresses to which gRPC should connect, and then gRPC will create a channel, which is an abstraction for the connection used by RPCs, and subchannels, which are abstractions for connections that the load balancer can use to direct the data to one or </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">more backends.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer012">
<span class="koboSpan" id="kobo.340.1"><img alt="Figure 1.8 – Channels versus subchannels" src="image/B19664_01_008.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.341.1">Figure 1.8 – Channels versus subchannels</span></p>
<p><span class="koboSpan" id="kobo.342.1">In the end, </span><a id="_idTextAnchor034"/><span class="koboSpan" id="kobo.343.1">the </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.344.1">user code will receive a </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">ClientConn</span></strong><span class="koboSpan" id="kobo.346.1"> object that will be used for closing the connection, but most importantly, to create a client object that is defined in the generated code and on which we will be able to call the RPC endpoints. </span><span class="koboSpan" id="kobo.346.2">The last thing to note here is that, by default, the overall process is non-blocking. </span><span class="koboSpan" id="kobo.346.3">This means that gRPC does not wait for the connections to</span><a id="_idTextAnchor035"/><span class="koboSpan" id="kobo.347.1"> be established to return the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">ClientConn</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.349.1"> object.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<span class="koboSpan" id="kobo.350.1"><img alt="Figure 1.9 – Summary of a﻿n RPC connection" src="image/B19664_01_009.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.351.1">Figure 1.9 – Summary of a</span><a id="_idTextAnchor036"/><span class="koboSpan" id="kobo.352.1">n RPC connection</span></p>
<h2 id="_idParaDest-31"><a id="_idTextAnchor037"/><span class="koboSpan" id="kobo.353.1">The client side</span></h2>
<p><span class="koboSpan" id="kobo.354.1">Now that we </span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.355.1">have a connection, we can start thinking about making requests. </span><span class="koboSpan" id="kobo.355.2">For now, let us say that we have generated code and that it has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">Greet</span></strong><span class="koboSpan" id="kobo.357.1"> RPC endpoint. </span><span class="koboSpan" id="kobo.357.2">And for our current purpose, it is not important what it is doing; it is just an </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">API endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">To send a request, the user code will simply call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">Greet</span></strong><span class="koboSpan" id="kobo.361.1"> endpoint. </span><span class="koboSpan" id="kobo.361.2">This will trigger a function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">NewStream</span></strong><span class="koboSpan" id="kobo.363.1"> in the gRPC framework. </span><span class="koboSpan" id="kobo.363.2">The name of that function is a little bit of a misnomer because here a stream does not necessarily represent a streaming RPC. </span><span class="koboSpan" id="kobo.363.3">In fact, whether you are doing a streaming RPC or not, it will be called and it will create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">ClientStream</span></strong><span class="koboSpan" id="kobo.365.1"> object. </span><span class="koboSpan" id="kobo.365.2">So here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">Stream</span></strong><span class="koboSpan" id="kobo.367.1"> is roughly equivalent to an abstraction for </span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">all RPCs.</span></span></p>
<p><span class="koboSpan" id="kobo.369.1">During the creation of that </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">ClientStream</span></strong><span class="koboSpan" id="kobo.371.1">, the gRPC framework will perform two actions. </span><span class="koboSpan" id="kobo.371.2">The first one is that it will call the load balancer to get a subchannel that can be used. </span><span class="koboSpan" id="kobo.371.3">This is done depending on the load balancer policy chosen during the connection creation. </span><span class="koboSpan" id="kobo.371.4">The second action is to interact with the transport. </span><span class="koboSpan" id="kobo.371.5">The g</span><a id="_idTextAnchor038"/><span class="koboSpan" id="kobo.372.1">RPC framework will create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">ClientTransport</span></strong><span class="koboSpan" id="kobo.374.1">, which contains the read-write stream to send and receive data, and it will send the header to the server to initiate an </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">RPC call.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">Once this is </span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.377.1">done, the gRPC framework will simply return </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">ClientStream</span></strong><span class="koboSpan" id="kobo.379.1"> to the generated code and the generated code will simply encapsulate it with another object to provide the user code with a smaller set of functions to</span><a id="_idTextAnchor039"/><span class="koboSpan" id="kobo.380.1"> be called (for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">Send</span></strong><span class="koboSpan" id="kobo.382.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">Recv</span></strong><span class="koboSpan" id="kobo.384.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">so on).</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer014">
<span class="koboSpan" id="kobo.386.1"><img alt="Figure 1.10 – Summary of client-﻿side communication" src="image/B19664_01_010.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.387.1">Figure 1.10 – Summary of client-</span><a id="_idTextAnchor040"/><span class="koboSpan" id="kobo.388.1">side communication</span></p>
<h2 id="_idParaDest-32"><a id="_idTextAnchor041"/><span class="koboSpan" id="kobo.389.1">The server side</span></h2>
<p><span class="koboSpan" id="kobo.390.1">Naturally, after </span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.391.1">sending a request, we expect a response from the server. </span><span class="koboSpan" id="kobo.391.2">As we know by now, the client sent a header to initiate an RPC call. </span><span class="koboSpan" id="kobo.391.3">This header will be handled by </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">ServerTransport</span></strong><span class="koboSpan" id="kobo.393.1">. </span><span class="koboSpan" id="kobo.393.2">The server is now aware that a client wants to send a request for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">Greet</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.395.1">RPC endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">With t</span><a id="_idTextAnchor042"/><span class="koboSpan" id="kobo.397.1">hat, the </span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.398.1">transport will send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">transport.Stream</span></strong><span class="koboSpan" id="kobo.400.1"> object to the gRPC framework. </span><span class="koboSpan" id="kobo.400.2">Then, again, this str</span><a id="_idTextAnchor043"/><span class="koboSpan" id="kobo.401.1">eam will be thinly wrapped in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">ServerStream</span></strong><span class="koboSpan" id="kobo.403.1"> object and passed to the generated code. </span><span class="koboSpan" id="kobo.403.2">At this point, the generated code is aware of which user code function to call. </span><span class="koboSpan" id="kobo.403.3">It is aware of that because the user code registers functions to specific </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">RPC endpoints.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">And that is it, the server will do the computation of the data received and it will simply return a response on the correspondi</span><a id="_idTextAnchor044"/><span class="koboSpan" id="kobo.406.1">ng transport to the client. </span><span class="koboSpan" id="kobo.406.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">ClientTransport</span></strong><span class="koboSpan" id="kobo.408.1"> will read that and return the response to the </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">user code.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer015">
<span class="koboSpan" id="kobo.410.1"><img alt="Figure 1.11 – Summary of server-side communication" src="image/B19664_01_011.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.411.1">Figure 1.11 – Summary of server-side communication</span></p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor045"/><span class="koboSpan" id="kobo.412.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.413.1">All that knowledge might be overwhelming right now, but do not worry, you do not need to remember all the names of the objects presented to understand how gRPC works. </span><span class="koboSpan" id="kobo.413.2">The point of this chapter is more about giving you a sense of the different actors involved in the process of making a connection and </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">sending/receiving data.</span></span></p>
<p><span class="koboSpan" id="kobo.415.1">We saw that we have four RPC operations that can be performed by the client and/or the server. </span><span class="koboSpan" id="kobo.415.2">Each actor sends a header to indicate it is its turn to send data, then they send messages, and finally, each of them has a special operation to indicate that it is done with </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">sending messages.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">After that, we saw how gRPC creates a connection between the server and the client. </span><span class="koboSpan" id="kobo.417.2">This is done with the help of the resolver, which finds IP addresses depending on the address we try to connect to, and with the load balancer, which helps gRPC work out which subchannels to send the </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">data to.</span></span></p>
<p><span class="koboSpan" id="kobo.419.1">Then, we talked about channels and subchannels. </span><span class="koboSpan" id="kobo.419.2">We saw how they are created by the client to connect to the server. </span><span class="koboSpan" id="kobo.419.3">And finally, we saw that the server will receive data and call some code that the user code registered for an </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">RPC endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">In the next chapter, we will introduce Protocol Buffers and how they relate </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">to gRPC.</span></span></p>
<h1 id="_idParaDest-34"><a id="_idTextAnchor046"/><span class="koboSpan" id="kobo.423.1">Quiz</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.424.1">What is the RPC operation that tells the server that the client is ready to send </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">a request?</span></span><ol><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">Send Trailer</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">Send Message</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">Send Header</span></strong></span></li></ol></li>
<li><span class="koboSpan" id="kobo.429.1">What is the RPC operation that tells the client that the server is done </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">returning response(s)?</span></span><ol><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">Send Half-Close</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">Send Trailer</span></strong></span></li><li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">Send Header</span></strong></span></li></ol></li>
<li><span class="koboSpan" id="kobo.434.1">Which RPC type can be used for downloading information by chunks in one request from the client side? </span><ol><li><span class="No-Break"><span class="koboSpan" id="kobo.435.1">Server streaming</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.436.1">Client streaming</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.437.1">Bidirectional streaming</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.438.1">Unary</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.439.1">Which RPC type is the equivalent of a traditional </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">HTTP/1.1 request?</span></span><ol><li><span class="No-Break"><span class="koboSpan" id="kobo.441.1">Server streaming</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.442.1">Client streaming</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.443.1">Bidirectional streaming</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.444.1">Unary</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.445.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">a channel?</span></span><ol><li><span class="koboSpan" id="kobo.447.1">An abstraction used by RPCs for representing a connection to any available server discovered by the </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">load balancer.</span></span></li><li><span class="koboSpan" id="kobo.449.1">An abstraction used by the load balancer for representing a connection to a </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">specific server.</span></span></li><li><span class="koboSpan" id="kobo.451.1">Both of </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">the above</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.453.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">a subchannel?</span></span><ol><li><span class="koboSpan" id="kobo.455.1">An abstraction used by RPCs for representing a connection to any available server discovered by the </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">load balancer.</span></span></li><li><span class="koboSpan" id="kobo.457.1">An abstraction used by the load balancer for representing a connection to a </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">specific server.</span></span></li><li><span class="koboSpan" id="kobo.459.1">Both of </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">the above</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.461.1">When receiv</span><a id="_idTextAnchor047"/><span class="koboSpan" id="kobo.462.1">ing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">ClientConn</span></strong><span class="koboSpan" id="kobo.464.1"> object from </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">grpc.Dial</span></strong><span class="koboSpan" id="kobo.466.1">, can you be sure that the client has established a connection with </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">the server?</span></span><ol><li><span class="No-Break"><span class="koboSpan" id="kobo.468.1">Yes</span></span></li><li><span class="No-Break"><span class="koboSpan" id="kobo.469.1">No</span></span></li></ol></li>
</ol>
<h1 id="_idParaDest-35"><a id="_idTextAnchor048"/><span class="koboSpan" id="kobo.470.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.471.1">C</span></li>
<li><span class="koboSpan" id="kobo.472.1">B</span></li>
<li><span class="koboSpan" id="kobo.473.1">A</span></li>
<li><span class="koboSpan" id="kobo.474.1">D</span></li>
<li><span class="koboSpan" id="kobo.475.1">A</span></li>
<li><span class="koboSpan" id="kobo.476.1">B</span></li>
<li><span class="koboSpan" id="kobo.477.1">B</span></li>
</ol>
</div>
</body></html>