- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Networking Primer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络基础
- en: Communication over networks is at the core of all of our modern technology and
    gRPC is one of the high-level frameworks that we can use to achieve efficient
    reception and transmission of data. As it is high level, it gives you abstractions
    for sending and receiving data without thinking about all the things that could
    go wrong when communicating over the wire. In this chapter, the goal is to understand,
    at a lower level (not the lowest), what happens when we send/receive messages
    in gRPC Go. This will help you get a sense of what’s going on and, later on, when
    we talk about debugging and observability, you’ll be able to grasp the concepts
    presented more easily.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络通信是我们所有现代技术的核心，而 gRPC 是我们可以用来实现高效数据接收和传输的高级框架之一。由于它是高级的，它为你提供了发送和接收数据的抽象，无需考虑在通过网络通信时可能出现的所有问题。在本章中，目标是理解在较低级别（不是最低级别）上，当我们发送/接收
    gRPC Go 中的消息时会发生什么。这将帮助你了解正在发生的事情，并且在我们讨论调试和可观察性时，你将能够更容易地掌握所提出的概念。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: HTTP/2
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP/2
- en: RPC operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RPC 操作
- en: RPC types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RPC 类型
- en: The life cycle of an RPC
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RPC 的生命周期
- en: Prerequisites
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前提条件
- en: In this chapter, I will be using [`chapter1` directory.](https://www.wireshark.org)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将使用 [第 1 章目录](https://www.wireshark.org)。
- en: '[To display these capture files, you can simply import them into Wireshark
    and apply a display filter to them. As we are interested specifically in HTTP/2
    and gRPC payloads, and I was using port `50051` for communication, you can use
    the following filter: `tcp.port == 50051 and (grpc` `or http2)`.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[要显示这些捕获文件，您可以将它们导入 Wireshark 并应用显示过滤器。由于我们特别关注 HTTP/2 和 gRPC 有效负载，而我使用端口 `50051`
    进行通信，您可以使用以下过滤器：`tcp.port == 50051 and (grpc or http2)`。'
- en: Understanding HTTP/2
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 HTTP/2
- en: If you are reading this book, I’m going to assume that you have familiarity
    with HTTP/1.1 or that at least you have a sense of how to make traditional HTTP
    API calls over the network. I guess so because most of the APIs that we interact
    with, as developers, have concepts that were brought about by this protocol. I’m
    talking about concepts such as headers, which can provide metadata for a call;
    the body, which contains the main data; and actions such as GET, POST, UPDATE,
    and so on, which define what you intend to do with the data in the body.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在阅读这本书，我将假设您熟悉 HTTP/1.1，或者至少您对如何在网络上进行传统 HTTP API 调用有一个概念。我猜是这样，因为与我们交互的大多数
    API 都有由该协议带来的概念。我指的是像头部这样的概念，它可以提供调用的元数据；主体，它包含主要数据；以及诸如 GET、POST、UPDATE 等操作，这些操作定义了您打算对主体中的数据做什么。
- en: HTTP/2 still has all of these concepts but improves efficiency, security, and
    usability in a few ways. The first advantage of HTTP/2 over plain old HTTP/1.1
    is the compression down to binary. Before HTTP/2, everything sent over the network
    was pure text and it was up to the user to compress it or not. With version 2,
    every part of the HTTP semantic is translated down to binary, thus making it faster
    for computers to serialize and deserialize data between calls and thereby reducing
    the request/response payload size.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2 仍然具有所有这些概念，但在几个方面提高了效率、安全性和可用性。HTTP/2 相对于传统的 HTTP/1.1 的第一个优势是压缩到二进制。在
    HTTP/2 之前，通过网络发送的所有内容都是纯文本，用户需要决定是否对其进行压缩。在版本 2 中，HTTP 语义的每一部分都被转换为二进制，从而使计算机在调用之间序列化和反序列化数据时更快，从而减少了请求/响应的有效负载大小。
- en: The second advantage that HTTP/2 has is a feature called server push. This is
    a feature that gives the server the ability to send multiple responses for only
    one call from the client. The overall goal here is to reduce the chatter between
    the server and client, and thus the total payload to reach the same end result.
    Without this feature, when a client wants to request a web page and all its resources,
    it has to do a request per resource. However, with the server push feature, the
    client can just send a request for a web page, and the server will return that
    web page, then return the CSS and potentially some JS script. This results in
    only one call from the client, instead of three.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/2 的第二个优势是一个名为服务器推送的功能。这是一个赋予服务器从客户端的单次调用中发送多个响应的能力的功能。这里的总体目标是减少服务器和客户端之间的嘈杂通信，从而减少达到相同最终结果的总有效负载。没有这个功能，当客户端想要请求一个网页及其所有资源时，它必须为每个资源进行一次请求。然而，有了服务器推送功能，客户端只需发送一个网页请求，服务器就会返回该网页，然后返回
    CSS 和可能的一些 JS 脚本。这导致客户端只需一个调用，而不是三个。
- en: '![Figure 1.1 – HTTP/2 server push](img/B19664_01_001.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – HTTP/2 服务器推送](img/B19664_01_001.jpg)'
- en: Figure 1.1 – HTTP/2 server push
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – HTTP/2 服务器推送
- en: Another important efficiency aspect is the creation of a long-lived TCP connection
    instead of individual connections per request. In HTTP/0.9, every call is preceded
    by the creation of a TCP connection and succeeded by the closing of that connection.
    This is highly inefficient for today’s use of the internet.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的效率方面是创建一个长连接而不是每个请求一个连接。在 HTTP/0.9 中，每个调用都由创建 TCP 连接开始，并以关闭该连接结束。这在当今互联网的使用中非常低效。
- en: Then, HTTP/1.1 introduced the concept of KeepAlive, which permitted the reuse
    of a single TCP connection. However, this didn’t mean that we could send interleaved
    packets to fulfill multiple requests concurrently; it meant that after finishing
    request one, we could reuse the same connection for request two. This was probably
    fine in 1997 when the protocol was released, but nowadays we make more and more
    requests, and also bigger and bigger ones, and waiting for requests to finish
    before starting another one is not feasible. HTTP/2 solves this by creating a
    single long-lived connection that can handle multiple requests and responses as
    interleaved packets.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，HTTP/1.1 引入了 KeepAlive 的概念，允许单个 TCP 连接的重用。然而，这并不意味着我们可以发送交错的数据包来同时满足多个请求；这意味着在完成第一个请求后，我们可以重用相同的连接来处理第二个请求。这在
    1997 年协议发布时可能还可以接受，但如今我们发送的请求越来越多，而且请求的大小也越来越大，等待请求完成后再开始下一个请求是不切实际的。HTTP/2 通过创建一个可以处理多个交错请求和响应的单个长连接来解决这个问题。
- en: '![Figure 1.2 – HTTP/2 interleaved packets over the wire](img/B19664_01_002.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 通过网络传输的 HTTP/2 交错数据包](img/B19664_01_002.jpg)'
- en: Figure 1.2 – HTTP/2 interleaved packets over the wire
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 通过网络传输的 HTTP/2 交错数据包
- en: What’s presented here is obviously an oversimplification of the HTTP/2 protocol.
    It would take a book in itself to explain all the implementation details of the
    protocol. As we talk about gRPC, we mostly need to understand that in HTTP/2,
    we can send structured binary messages over the wire instead of text, we can have
    streams where the server can send multiple responses for one response, and finally,
    we do that in an efficient way because we only create one TCP connection and it
    will handle multiple requests and responses. However, it is also important to
    understand that gRPC has its own communication protocol on top of HTTP/2\. This
    means that aIl the HTTP protocol improvements presented here are facilitators
    for communication. gRPC uses all of these in conjunction with four RPC operations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的显然是对 HTTP/2 协议的过度简化。要解释协议的所有实现细节，可能需要一本书。当我们谈论 gRPC 时，我们主要需要了解的是，在 HTTP/2
    中，我们可以通过网络发送结构化二进制消息而不是文本，我们可以有流，其中服务器可以为单个响应发送多个响应，最后，我们以高效的方式做到这一点，因为我们只创建一个
    TCP 连接，它将处理多个请求和响应。然而，了解 gRPC 在 HTTP/2 之上有自己的通信协议也很重要。这意味着这里展示的所有 HTTP 协议改进都是通信的促进者。gRPC
    使用所有这些，并结合四个 RPC 操作。
- en: RPC operations
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPC 操作
- en: Each interaction done with gRPC between the server and the client can be described
    as four RPC operations. These operations are composed in a way that creates complex
    high-level operations in the framework. Let us see these operations and then I
    will explain how a simple gRPC call uses them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器和客户端之间通过 gRPC 进行的每个交互都可以描述为四个 RPC 操作。这些操作以创建框架中的复杂高级操作的方式组合。让我们看看这些操作，然后我将解释一个简单的
    gRPC 调用是如何使用它们的。
- en: Important note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In this section, I’m going to use Wireshark’s result for an RPC call. I will
    explain how to replicate what I did in this section later in the book. For now,
    I will just highlight what is important to notice in the dumps.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将使用 Wireshark 的 RPC 调用结果。我将在本书后面的章节中解释如何复制我在本节中做的事情。现在，我将只强调在转储中需要注意的重要事项。
- en: Send Header
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送头部
- en: The `Send Header` operation lets the server know that the client will send a
    request or lets the client know that the server will send a response. This acts
    as a switch between the server and client to let both sides know who needs to
    read and who needs to write.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`发送头部`操作让服务器知道客户端将发送请求，或者让客户端知道服务器将发送响应。这充当服务器和客户端之间的开关，让双方都知道谁需要读取谁需要写入。'
- en: 'By using Wireshark to analyze a simple gRPC call, we can observe the following
    header (simplified) being sent by the client in order to let the server know that
    it will send a request:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Wireshark分析一个简单的gRPC调用，我们可以观察到以下头部（简化版）是由客户端发送的，以便让服务器知道它将发送一个请求：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What is important to note in this header is that it mentions that the client
    wants to call HTTP POST on the `/greet.GreetService/Greet` route and then in the
    flags, it mentions that this is the end of the header data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个头部中需要注意的重要信息是，它提到客户端想要在`/greet.GreetService/Greet`路由上调用HTTP POST，然后在标志中提到这是头部数据的结束。
- en: 'Then, later in the call, we will see the following header (simplified) sent
    by the server to let the client know that it will send the response:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在调用过程中稍后，我们将看到以下头部（简化版）由服务器发送，以便让客户端知道它将发送响应：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And here, once again, we can see that this is a header and that this is the
    last one that will be sent. The main difference though, is that the server is
    telling the client that the request was handled properly, and it says that by
    sending a code 200.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次可以看到这是一个头部，这是将要发送的最后一个。不过，主要区别在于服务器告诉客户端请求已被正确处理，并且通过发送状态码200来表示。
- en: Send Message
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送消息
- en: The `Send Message` operation is the operation that sends the actual data. This
    is the operation that matters the most to us as API developers. After sending
    the header, the client can send a message as a request and the server can send
    a message as a response.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Send Message`操作是发送实际数据的操作。对于我们这些API开发者来说，这是最重要的操作。在发送头部之后，客户端可以发送一个消息作为请求，服务器可以发送一个消息作为响应。'
- en: 'By using Wireshark to analyze the same gRPC call as we did for `Send Header`,
    we can observe the following data (simplified) being sent by the client as a request:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Wireshark分析与`Send Header`相同的gRPC调用，我们可以观察到以下数据（简化版）作为请求由客户端发送：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What is important to note in this header is that it mentions that the client
    sends data on the `/greet.GreetService/Greet` route, which is the same as the
    one that was sent in the header. And then, we can see that we are sending Protocol
    Buffers data (more on that later) and that the binary value of that message is
    `436c656d656e74`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个头部中需要注意的重要信息是，它提到客户端在`/greet.GreetService/Greet`路由上发送数据，这与头部中发送的相同。然后，我们可以看到我们正在发送协议缓冲区数据（稍后详细介绍）以及该消息的二进制值为`436c656d656e74`。
- en: 'After, later in the call, just after the server header, we see the following
    data (simplified) sent by the server as a response:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，在调用过程中，在服务器头部之后，我们看到以下数据（简化版）作为响应由服务器发送：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: And here, we can see that this is a message sent as a response to a call made
    on route `/greet.GreetService/Greet` and the binary value of that message is `48656c6c6f20436c656d656e74`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这是一个对在`/greet.GreetService/Greet`路由上进行的调用发送的响应消息，该消息的二进制值为`48656c6c6f20436c656d656e74`。
- en: Send Half Close
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送半关闭
- en: The `Send Half Close` operation closes either the input or the output of an
    actor. For example, in a traditional request/response setting, when the client
    is done sending the request, sending a `Half Close` closes the client stream.
    This is a little bit like `Send Header` in the sense that it is acting as a switch
    to let the server know that it is time to work.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Send Half Close`操作关闭了actor的输入或输出。例如，在传统的请求/响应设置中，当客户端完成发送请求时，发送`Half Close`关闭客户端流。这在某种程度上类似于`Send
    Header`，因为它作为一个开关来通知服务器现在是工作的时间。'
- en: 'Once again, if we look at the Wireshark transcript for the same gRPC call,
    we should be able to see that a header was set during the `Send Message` operations.
    We can observe the following data (simplified):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看与相同gRPC调用相关的Wireshark转储，我们应该能够看到在`Send Message`操作期间设置了头部。我们可以观察到以下数据（简化版）：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time, we have a flag that denotes the end of the request. Notice however
    that here, we are sending a payload of type `DATA`. This is different than what
    we saw up until now because `DATA` is much lighter than a header. This is used
    for the Half Close because we simply want to send a boolean saying that the client
    is done.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们有一个表示请求结束的标志。然而请注意，在这里，我们发送的是类型为`DATA`的有效负载。这与我们之前看到的不同，因为`DATA`比头部要轻得多。这是用于半关闭的，因为我们只想发送一个布尔值，表示客户端已完成。
- en: Send Trailer
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送尾部
- en: And finally, we have an operation for terminating an entire RPC. This is the
    `Send Trailer` operation. This operation also gives us more information about
    the call, such as the status code, error message, and so on. At this point in
    the book, we only need to know that this information is mostly necessary for handling
    API errors.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个用于终止整个 RPC 的操作。这是 `Send Trailer` 操作。这个操作也给我们提供了更多关于调用的信息，例如状态码、错误消息等。就本书的这一部分而言，我们只需要知道这些信息主要用于处理
    API 错误。
- en: 'If we take a look at the same Wireshark call, we will have the following data
    (simplified):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看相同的 Wireshark 调用，我们将得到以下数据（简化版）：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the trailer is basically a header. With this header, we will get more
    information about the call (`grpc-status` and `grpc-message`). And then we receive
    two flags – one saying that this is the end of the stream (in our case, request/response).
    And another one to say that this trailer ends here.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，拖车基本上是一个头。有了这个头，我们将获得更多关于调用的信息（`grpc-status` 和 `grpc-message`）。然后我们接收两个标志
    – 一个表示这是流的结束（在我们的情况下，请求/响应）。另一个表示这个拖车在这里结束。
- en: RPC types
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPC 类型
- en: Now that we know that there are four RPC operations, we can see how they are
    combined to create the different RPC types that gRPC provides. We will talk about
    the Unary, Server Streaming, Client Streaming, and Bidirectional RPC types. We
    will see that each type presented is a combination of the RPC operations presented
    earlier.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了有四种 RPC 操作，我们可以看到它们是如何组合起来创建 gRPC 提供的不同 RPC 类型的。我们将讨论一元、服务器流、客户端流和双向
    RPC 类型。我们将看到每种类型都是之前提出的 RPC 操作的组合。
- en: Unary
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一元
- en: A unary RPC is an RPC that performs one request and returns one response. We
    already touched upon this in the previous section, but let us go ahead and make
    the process clearer.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一元 RPC 是执行一个请求并返回一个响应的 RPC。我们已经在上一节中提到了这一点，但让我们继续并使这个过程更清晰。
- en: As always, the first step is the client sending the initial header. This header
    will contain the information related to the RPC endpoint that we want to invoke.
    As of this point in the book, we simply need to know that this mostly includes
    the RPC route and the stream ID. The former is to let the server know which user
    code function it should call to process the request. The latter is a way to identify
    on which stream the data should be sent. This is because we can have multiple
    streams going on at the same time.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总是首先，客户端发送初始头。这个头将包含与我们想要调用的 RPC 端点相关的信息。就本书的这一部分而言，我们只需要知道这主要包含 RPC 路由和流 ID。前者是让服务器知道它应该调用哪个用户代码函数来处理请求。后者是确定数据应该发送到哪个流的方式。这是因为我们可以同时进行多个流。
- en: Since the server is now aware of the fact that the client will send a request,
    the client can now send a message. This message will contain the actual request
    payload. In our case, we are going to only send Protocol Buffers encoded data,
    but be aware that you can send any kind of data with gRPC.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务器现在知道客户端将发送请求，客户端现在可以发送消息。这个消息将包含实际的请求有效负载。在我们的情况下，我们只将发送 Protocol Buffers
    编码的数据，但请注意，您可以使用 gRPC 发送任何类型的数据。
- en: After that, because we are in a unary setting, the client is done sending the
    request. As we know, the client itself should now send a Half Close. This is saying
    to the server *I’m done, please send me* *the response.*
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，因为我们处于一元设置中，客户端已经完成了请求的发送。正如我们所知，客户端现在应该发送一个半关闭。这是告诉服务器 *我已经完成，请发送给我* *响应*。
- en: At this point, the server will do similar work. As shown in the next figure,
    it will send a header, send the response as a Protobuf encoded message, and end
    the RPC. However, as we know, the server will not send a Half Close; it will send
    the Trailer. This is some data that says whether or not the call was successful,
    has an optional error message, and some other key-value pairs that we can add
    through the user code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，服务器将执行类似的工作。如图中所示，它将发送一个头，发送作为 Protobuf 编码消息的响应，并结束 RPC。然而，正如我们所知，服务器不会发送半关闭；它会发送拖车。这是表示调用是否成功的一些数据，有一个可选的错误消息，以及一些我们可以通过用户代码添加的其他键值对。
- en: '![Figure 1.3 – Unary RPC flow](img/B19664_01_003.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 一元 RPC 流](img/B19664_01_003.jpg)'
- en: Figure 1.3 – Unary RPC flow
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 一元 RPC 流
- en: Server streaming
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器流
- en: A server streaming RPC is an RPC that performs one request and returns one or
    more responses. This RPC type is useful for situations where the client is expecting
    to get updates from the server. For example, we could have a client display the
    stock prices for selected companies. With server streaming, the client could subscribe
    and the server could send different prices over time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器流式 RPC 是执行一个请求并返回一个或多个响应的 RPC。这种 RPC 类型在客户端期望从服务器获取更新时很有用。例如，我们可以有一个客户端显示选定公司的股票价格。使用服务器流式，客户端可以订阅，服务器可以在一段时间内发送不同的价格。
- en: In this situation, nothing changes for the client. It will send the header,
    the message, and the Half Close. However, on the server side, we are going to
    interleave HTTP data messages and data payloads.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，客户端没有任何变化。它将发送头部、消息和半关闭。然而，在服务器端，我们将交错发送 HTTP 数据消息和数据有效负载。
- en: 'As shown in the following figure, the server will first send its header. This
    is customary when an actor wants to let the other one know that it will send messages.
    After that, as mentioned above, the server will alternate between sending HTTP
    data messages and Protobuf payloads. The first data messages will look like this
    (simplified):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，服务器将首先发送其头部。当一个演员想要让另一个演员知道它将发送消息时，这是惯例。之后，如上所述，服务器将在发送 HTTP 数据消息和 Protobuf
    有效负载之间交替。最初的数据消息将看起来像这样（简化版）：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This says that a message will be sent. This is a lightweight header. And later,
    once we arrive at the last message to be sent, the server will finish the RPC
    with the trailer, and at that point, the client will know that the server is done
    sending responses.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示将发送一条消息。这是一个轻量级的头部。一旦我们到达要发送的最后一条消息，服务器将使用尾部完成 RPC，此时客户端将知道服务器已完成发送响应。
- en: '![Figure 1.4 – Server streaming flow](img/B19664_01_004.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 服务器流式处理流程](img/B19664_01_004.jpg)'
- en: Figure 1.4 – Server streaming flow
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 服务器流式处理流程
- en: Client streaming
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端流式
- en: A client streaming RPC is similar to server streaming, but this time, the client
    can send one or more requests and the server returns one response. This is useful
    in situations where the client sends real-time information to the server. For
    example, this might be useful for microcontrollers to send data coming from some
    kind of sensor and update the server on the current state of what the sensor is
    measuring.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端流式 RPC 与服务器流式 RPC 类似，但这次客户端可以发送一个或多个请求，而服务器返回一个响应。这在客户端需要向服务器发送实时信息的情况下非常有用。例如，这可能对微控制器发送来自某种传感器的数据并更新服务器当前测量状态很有用。
- en: Client streaming is similar to server streaming. As you can see in the following
    figure, the client will do what the server did in server streaming. This means
    that the client will interleave HTTP data messages, which are like the ones previously
    mentioned about server streaming, with the Protobuf messages. And in the end,
    when the client is done, it will simply send a Half Close.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端流式与服务器流式类似。正如你在以下图中可以看到的，客户端将执行服务器在服务器流式中所做的操作。这意味着客户端将交错发送 HTTP 数据消息，这些消息类似于之前提到的服务器流式中的消息，以及
    Protobuf 消息。最后，当客户端完成时，它将简单地发送半关闭。
- en: '![Figure 1.5 – Client streaming flow](img/B19664_01_005.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – 客户端流式处理流程](img/B19664_01_005.jpg)'
- en: Figure 1.5 – Client streaming flow
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 客户端流式处理流程
- en: Bidirectional streaming
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双向流
- en: By now, you might have guessed that bidirectional streaming is a mix of server
    streaming and client streaming. A client can send one or more requests and the
    server returns one or more responses. This is especially useful when one of the
    actors needs feedback on its data. For example, if you have an app to find taxis,
    it might not be enough for the server to send updates about cabs. The user might
    also walk toward their destination in the hope of catching a taxi on the road.
    Thus, the server also needs to know the user’s location.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经猜到双向流是服务器流式和客户端流的混合。客户端可以发送一个或多个请求，服务器返回一个或多个响应。这在其中一个演员需要对其数据反馈时特别有用。例如，如果你有一个寻找出租车的应用程序，服务器发送有关出租车的更新可能就不够了。用户可能也在向目的地走去，希望能在路上截到出租车。因此，服务器也需要知道用户的位置。
- en: Bidirectional streaming is less predictable than client and server streaming.
    This is because there is no defined order in which each actor will send messages.
    The server could give a response per request or any number of requests. Thus,
    for this section, let us pretend that we are working with a server that returns
    a response per request.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 双向流比客户端和服务器流更不可预测。这是因为每个参与者发送消息的顺序没有定义。服务器可以为每个请求或任何数量的请求提供响应。因此，对于本节，让我们假设我们正在与一个为每个请求返回响应的服务器一起工作。
- en: In this case, as you can see in the following figure, the client will send a
    header and a message. Then, the server will send its header and message. And after
    that, we will get data and a message per actor. And finally, we will get the Half
    Close from the client and the Trailer from the server.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，正如你在下面的图中可以看到的，客户端将发送一个头部和一个消息。然后，服务器将发送其头部和消息。之后，我们将从每个参与者那里获取数据和消息。最后，我们将从客户端获得半关闭（Half
    Close）和从服务器获得尾部（Trailer）。
- en: '![Figure 1.6 – Bidirectional streaming flow](img/B19664_01_006.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 双向流流程](img/B19664_01_006.jpg)'
- en: Figure 1.6 – Bidirectional streaming flow
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 双向流流程
- en: The life cycle of an RPC
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RPC的生命周期
- en: 'Now that we understand the basic RPC operations that can be executed in gRPC
    and the different types of RPC, we can take a look at the life cycle of an RPC.
    In this section, we are going to go top-down by first explaining the overall idea
    of what is happening when a client sends a request and the server receives it,
    sends a response, and the client receives it. And after that, we will go a bit
    deeper and talk about three stages:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了可以在gRPC中执行的基本RPC操作和不同类型的RPC，我们可以看看RPC的生命周期。在本节中，我们将自上而下地介绍，首先解释当客户端发送请求和服务器接收它、发送响应和客户端接收响应时发生了什么。然后，我们将深入一点，讨论三个阶段：
- en: The connection – What happens when a client connects to a server?
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接 - 当客户端连接到服务器时会发生什么？
- en: The client side – What happens when a client sends a message?
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端端 - 当客户端发送消息时会发生什么？
- en: The server side – What happens when a server receives a message?
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器端 - 当服务器接收到消息时会发生什么？
- en: Important note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: gRPC has multiple implementations in different languages. The original one was
    in C++ and some implementations are just wrappers around the C++ code. However,
    gRPC Go is a standalone implementation. This means that it was implemented from
    scratch in Go and doesn’t wrap up the C++ code. As such, in this section, we are
    going to talk specifically about gRPC Go, and this might prove to be implemented
    differently in other implementations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC在不同语言中有多种实现。最初的是C++，一些实现只是C++代码的包装器。然而，gRPC Go是一个独立的实现。这意味着它是从头开始在Go中实现的，并没有包装C++代码。因此，在本节中，我们将专门讨论gRPC
    Go，这可能在其他实现中有所不同。
- en: Before going into too much detail, let’s start with a bird’s-eye view by defining
    some concepts. The first thing that we need to be clear on is that gRPC is driven
    by generated code in the user code. This means that we interact with only a few
    points of the gRPC API and we mostly deal with code that was generated based on
    our Protocol Buffer service definition. Do not worry too much about that yet;
    we are going to cover that in the last section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，让我们先从宏观的角度出发，通过定义一些概念来开始。首先，我们需要明确的是，gRPC是由用户代码中生成的代码驱动的。这意味着我们只与gRPC
    API的几个点进行交互，我们主要处理的是基于我们的Protocol Buffer服务定义生成的代码。现在不必过于担心这一点；我们将在最后一节中介绍它。
- en: The second important concept is the concept of transport. The transport can
    be seen as the manager of the connection between the actors and it sends/receives
    raw bytes over the network. It contains a read-write stream that is designed to
    be able to read and write over the network in any order. And the most important
    aspect in our case is that we can call the read on an `io.Reader` and we can call
    write on an `io.Writer`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重要的概念是传输的概念。传输可以看作是参与者和连接之间的管理者，它通过网络发送/接收原始字节。它包含一个读写流，该流设计为能够以任何顺序在网络中读写。在我们的情况下，最重要的方面是我们可以在`io.Reader`上调用读取，我们可以在`io.Writer`上调用写入。
- en: Finally, the last thing to clarify is that a client and a server are very similar.
    All the functions called on the client will be called on the server too. They
    will simply be called on different objects (for instance, `ClientTransport` and
    `ServerTransport`).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要澄清的是，客户端和服务器非常相似。在客户端上调用的所有函数也将被服务器调用。它们只是在不同的对象上被调用（例如，`ClientTransport`和`ServerTransport`）。
- en: Now, that we understand all of this, we can take a look at a visual representation
    of the life cycle of an RPC.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们理解了所有这些，我们可以看看 RPC 生命周期的可视化表示。
- en: '![Figure 1.7 – Bird’s-eye view of the RPC life cycle](img/B19664_01_007.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7 – RPC 生命周期的鸟瞰图](img/B19664_01_007.jpg)'
- en: Figure 1.7 – Bird’s-eye view of the RPC life cycle
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – RPC 生命周期的鸟瞰图
- en: We can see that we can simply define only one generic actor and that it will
    represent both a server and a client. Then, we can see that the generated code
    will interact directly with the gRPC framework by calling a function called `SendMsg`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们可以简单地定义一个通用的参与者，它将代表服务器和客户端。然后，我们可以看到生成的代码将通过调用名为 `SendMsg` 的函数直接与
    gRPC 框架交互。
- en: This is designed, as its name suggests, to send data over the network. This
    `SendMsg` function will call a lower-level function called `Write`. This is the
    function provided by the `io.Writer` in the Transport. Once this is done, the
    other actor will read on an `io.Reader`, then the `RcvMsg` function, and finally,
    the user code will receive the data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这正如其名所示，是为了在网络中发送数据。这个 `SendMsg` 函数将调用一个名为 `Write` 的底层函数。这是 Transport 中 `io.Writer`
    提供的函数。一旦完成，其他参与者将在 `io.Reader` 上读取，然后是 `RcvMsg` 函数，最后，用户代码将接收到数据。
- en: We are now going to go a bit deeper into the important parts of gRPC communication.
    And as for every kind of transmission over the wire, the client needs to connect
    to a server, we are going to start with the specifics of a connection.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更深入地探讨 gRPC 通信的重要部分。对于任何类型的有线传输，客户端都需要连接到服务器，因此我们将从连接的具体细节开始。
- en: The connection
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接
- en: To create a connection, the client code will call a function called `Dial` with
    a target URI and some options as parameters. When the `Dial` request is received,
    the gRPC framework will parse the target address according to RFC 3986 and it
    will create a `Resolver` depending on the scheme of the URI. So, for example,
    if we use the `dns://` scheme, which is the default scheme that gRPC uses when
    we omit the scheme in the URI or if the scheme provided is unknown, gRPC will
    create a `dnsResolver` object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个连接，客户端代码将调用一个名为 `Dial` 的函数，该函数带有目标 URI 和一些选项作为参数。当接收到 `Dial` 请求时，gRPC 框架将根据
    RFC 3986 解析目标地址，并根据 URI 的方案创建一个 `Resolver`。例如，如果我们使用 `dns://` 方案，这是 gRPC 在 URI
    中省略方案或提供的方案未知时使用的默认方案，gRPC 将创建一个 `dnsResolver` 对象。
- en: 'dnsResolver Then the resolver will do its job, which is resolving the hostname
    and returning a list of addresses that can be connected to. With these addresses,
    gRPC will create a load balancer based on the configuration the user passed in
    the Dial options. The framework provides two load balancers by default:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: dnsResolver 然后，解析器将执行其工作，即解析主机名并返回一个可以连接的地址列表。有了这些地址，gRPC 将根据用户在 `Dial` 选项中提供的配置创建一个负载均衡器。框架默认提供两个负载均衡器：
- en: Pick first (the default), which connects to the first address it can connect
    to, and sends all the RPCs to it
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先选择（默认），它连接到它可以连接的第一个地址，并将所有 RPC 发送到它
- en: Round robin, which connects to all the addresses and sends an RPC to each backend
    one at a time and in order
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮询，它连接到所有地址，并按顺序逐个将 RPC 发送到每个后端
- en: As we can see, the goal of the load balancer is to find out on which address(es)
    the client should create a connection(s). So, it will return a list of addresses
    to which gRPC should connect, and then gRPC will create a channel, which is an
    abstraction for the connection used by RPCs, and subchannels, which are abstractions
    for connections that the load balancer can use to direct the data to one or more
    backends.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，负载均衡器的目标是找出客户端应该在哪个地址（们）上创建连接（们）。因此，它将返回一个地址列表，gRPC 应连接到这些地址，然后 gRPC 将创建一个通道，这是
    RPC 使用的连接的抽象，以及子通道，这是负载均衡器可以用来将数据定向到一个或多个后端的连接的抽象。
- en: '![Figure 1.8 – Channels versus subchannels](img/B19664_01_008.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – 通道与子通道](img/B19664_01_008.jpg)'
- en: Figure 1.8 – Channels versus subchannels
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 通道与子通道
- en: In the end, the user code will receive a `ClientConn` object that will be used
    for closing the connection, but most importantly, to create a client object that
    is defined in the generated code and on which we will be able to call the RPC
    endpoints. The last thing to note here is that, by default, the overall process
    is non-blocking. This means that gRPC does not wait for the connections to be
    established to return the `ClientConn` object.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，用户代码将接收到一个`ClientConn`对象，该对象将用于关闭连接，但更重要的是，用于创建在生成的代码中定义的客户端对象，我们可以在其上调用RPC端点。最后要注意的是，默认情况下，整个过程是非阻塞的。这意味着gRPC不会等待连接建立就返回`ClientConn`对象。
- en: "![Figure 1.9 – Summary of a\uFEFFn RPC connection](img/B19664_01_009.jpg)"
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9 – RPC连接摘要](img/B19664_01_009.jpg)'
- en: Figure 1.9 – Summary of an RPC connection
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – RPC连接摘要
- en: The client side
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端端
- en: Now that we have a connection, we can start thinking about making requests.
    For now, let us say that we have generated code and that it has a `Greet` RPC
    endpoint. And for our current purpose, it is not important what it is doing; it
    is just an API endpoint.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了连接，我们可以开始考虑发送请求。目前，让我们假设我们已经生成了代码，并且它有一个`Greet` RPC端点。并且对于我们的当前目的，它正在做什么并不重要；它只是一个API端点。
- en: To send a request, the user code will simply call the `Greet` endpoint. This
    will trigger a function called `NewStream` in the gRPC framework. The name of
    that function is a little bit of a misnomer because here a stream does not necessarily
    represent a streaming RPC. In fact, whether you are doing a streaming RPC or not,
    it will be called and it will create a `ClientStream` object. So here, `Stream`
    is roughly equivalent to an abstraction for all RPCs.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送请求，用户代码将简单地调用`Greet`端点。这将触发gRPC框架中名为`NewStream`的函数。那个函数的名字有点误导，因为在这里流不一定代表一个流式RPC。实际上，无论你是否在进行流式RPC，它都会被调用，并创建一个`ClientStream`对象。所以在这里，`Stream`大致等同于所有RPC的抽象。
- en: During the creation of that `ClientStream`, the gRPC framework will perform
    two actions. The first one is that it will call the load balancer to get a subchannel
    that can be used. This is done depending on the load balancer policy chosen during
    the connection creation. The second action is to interact with the transport.
    The gRPC framework will create the `ClientTransport`, which contains the read-write
    stream to send and receive data, and it will send the header to the server to
    initiate an RPC call.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建那个`ClientStream`的过程中，gRPC框架将执行两个操作。第一个操作是它会调用负载均衡器以获取一个可用的子通道。这是根据在连接创建期间选择的负载均衡器策略来完成的。第二个操作是与传输交互。gRPC框架将创建`ClientTransport`，它包含用于发送和接收数据的读写流，并将头部发送到服务器以初始化一个RPC调用。
- en: Once this is done, the gRPC framework will simply return `ClientStream` to the
    generated code and the generated code will simply encapsulate it with another
    object to provide the user code with a smaller set of functions to be called (for
    example, `Send`, `Recv`, and so on).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些，gRPC框架将简单地返回`ClientStream`给生成的代码，生成的代码将简单地用另一个对象封装它，为用户提供一组更小的可调用函数（例如，`Send`、`Recv`等）。
- en: "![Figure 1.10 – Summary of client-\uFEFFside communication](img/B19664_01_010.jpg)"
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图1.10 – 客户端通信摘要](img/B19664_01_010.jpg)'
- en: Figure 1.10 – Summary of client-side communication
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.10 – 客户端通信摘要
- en: The server side
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器端
- en: Naturally, after sending a request, we expect a response from the server. As
    we know by now, the client sent a header to initiate an RPC call. This header
    will be handled by `ServerTransport`. The server is now aware that a client wants
    to send a request for the `Greet` RPC endpoint.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，在发送请求后，我们期望从服务器获得响应。正如我们目前所知，客户端发送了一个头部来初始化一个RPC调用。这个头部将由`ServerTransport`处理。现在服务器已经知道客户端想要发送一个针对`Greet`
    RPC端点的请求。
- en: With that, the transport will send a `transport.Stream` object to the gRPC framework.
    Then, again, this stream will be thinly wrapped in a `ServerStream` object and
    passed to the generated code. At this point, the generated code is aware of which
    user code function to call. It is aware of that because the user code registers
    functions to specific RPC endpoints.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在此基础上，传输将向gRPC框架发送一个`transport.Stream`对象。然后，再次，这个流将被薄薄地封装在一个`ServerStream`对象中，并传递给生成的代码。此时，生成的代码知道要调用哪个用户代码函数。它之所以知道这一点，是因为用户代码将函数注册到特定的RPC端点上。
- en: And that is it, the server will do the computation of the data received and
    it will simply return a response on the corresponding transport to the client.
    The `ClientTransport` will read that and return the response to the user code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，服务器将对接收到的数据进行计算，并将简单地通过相应的传输向客户端返回响应。`ClientTransport` 将读取它并将响应返回给用户代码。
- en: '![Figure 1.11 – Summary of server-side communication](img/B19664_01_011.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11 – 服务器端通信摘要](img/B19664_01_011.jpg)'
- en: Figure 1.11 – Summary of server-side communication
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 服务器端通信摘要
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: All that knowledge might be overwhelming right now, but do not worry, you do
    not need to remember all the names of the objects presented to understand how
    gRPC works. The point of this chapter is more about giving you a sense of the
    different actors involved in the process of making a connection and sending/receiving
    data.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些知识现在可能令人感到压倒，但不要担心，你不需要记住所有展示给对象的名称来理解 gRPC 的工作原理。本章的重点是更多地给你一个关于在建立连接和发送/接收数据过程中涉及的不同角色的感觉。
- en: We saw that we have four RPC operations that can be performed by the client
    and/or the server. Each actor sends a header to indicate it is its turn to send
    data, then they send messages, and finally, each of them has a special operation
    to indicate that it is done with sending messages.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，我们有四个客户端和/或服务器可以执行 RPC 操作。每个参与者发送一个头部来指示轮到它发送数据，然后他们发送消息，最后，他们各自有一个特殊操作来指示他们已完成发送消息。
- en: After that, we saw how gRPC creates a connection between the server and the
    client. This is done with the help of the resolver, which finds IP addresses depending
    on the address we try to connect to, and with the load balancer, which helps gRPC
    work out which subchannels to send the data to.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们看到了 gRPC 是如何创建服务器和客户端之间的连接的。这是通过解析器完成的，解析器根据我们尝试连接的地址找到 IP 地址，以及负载均衡器，它帮助
    gRPC 确定将数据发送到哪个子通道。
- en: Then, we talked about channels and subchannels. We saw how they are created
    by the client to connect to the server. And finally, we saw that the server will
    receive data and call some code that the user code registered for an RPC endpoint.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了通道和子通道。我们看到了它们是如何由客户端创建来连接服务器的。最后，我们看到了服务器将接收数据并调用用户代码为 RPC 端点注册的某些代码。
- en: In the next chapter, we will introduce Protocol Buffers and how they relate
    to gRPC.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍 Protocol Buffers 以及它们与 gRPC 的关系。
- en: Quiz
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测验
- en: What is the RPC operation that tells the server that the client is ready to
    send a request?
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 RPC 操作告诉服务器客户端已准备好发送请求？
- en: '`Send Trailer`'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`发送尾部`'
- en: '`Send Message`'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`发送消息`'
- en: '`Send Header`'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`发送头部`'
- en: What is the RPC operation that tells the client that the server is done returning
    response(s)?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 RPC 操作告诉客户端服务器已完成返回响应（s）？
- en: '`Send Half-Close`'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`发送半关闭`'
- en: '`Send Trailer`'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`发送尾部`'
- en: '`Send Header`'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`发送头部`'
- en: Which RPC type can be used for downloading information by chunks in one request
    from the client side?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种 RPC 类型可以从客户端以块的形式在一个请求中下载信息？
- en: Server streaming
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器流式传输
- en: Client streaming
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端流式传输
- en: Bidirectional streaming
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双向流式传输
- en: Unary
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单一
- en: Which RPC type is the equivalent of a traditional HTTP/1.1 request?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种 RPC 类型相当于传统的 HTTP/1.1 请求？
- en: Server streaming
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器流式传输
- en: Client streaming
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端流式传输
- en: Bidirectional streaming
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双向流式传输
- en: Unary
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单一
- en: What is a channel?
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是通道？
- en: An abstraction used by RPCs for representing a connection to any available server
    discovered by the load balancer.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: RPCs 用于表示通过负载均衡器发现的任何可用服务器连接的抽象。
- en: An abstraction used by the load balancer for representing a connection to a
    specific server.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 负载均衡器用于表示连接到特定服务器的抽象。
- en: Both of the above
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上两者
- en: What is a subchannel?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是子通道？
- en: An abstraction used by RPCs for representing a connection to any available server
    discovered by the load balancer.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: RPCs 用于表示通过负载均衡器发现的任何可用服务器连接的抽象。
- en: An abstraction used by the load balancer for representing a connection to a
    specific server.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 负载均衡器用于表示连接到特定服务器的抽象。
- en: Both of the above
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上两者
- en: When receiving the `ClientConn` object from `grpc.Dial`, can you be sure that
    the client has established a connection with the server?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当从 `grpc.Dial` 接收 `ClientConn` 对象时，你能确定客户端已与服务器建立了连接吗？
- en: 'Yes'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是
- en: 'No'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否
- en: Answers
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: C
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: B
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: A
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: D
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D
- en: A
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: B
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: B](https://www.wireshark.org) [](https://www.wireshark.org)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B](https://www.wireshark.org) [](https://www.wireshark.org)
