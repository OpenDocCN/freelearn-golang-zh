<html><head></head><body>
<div class="Content" id="_idContainer017">
<h1 class="chapter-number" id="_idParaDest-36"><a id="_idTextAnchor049"/><span class="koboSpan" id="kobo.1.1">2</span></h1>
<h1 id="_idParaDest-37"><a id="_idTextAnchor050"/><span class="koboSpan" id="kobo.2.1">Protobuf Primer</span></h1>
<p><span class="koboSpan" id="kobo.3.1">As we now understand the basic networking concepts behind gRPC, we can touch upon another pillar in the construction of your gRPC APIs. </span><span class="koboSpan" id="kobo.3.2">This </span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.4.1">pillar is </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">Protocol Buffers</span></strong><span class="koboSpan" id="kobo.6.1">, more commonly </span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.7.1">known as </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">Protobuf</span></strong><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">It is an important part of the communication process because, as we saw in the previous chapter, every message is encoded into binary, and this is exactly what Protobuf is doing for us in gRPC. </span><span class="koboSpan" id="kobo.9.3">In this chapter, the goal is to understand what Protobuf is and why it is needed for high-efficiency communication. </span><span class="koboSpan" id="kobo.9.4">Finally, we are going to look at some details concerning the serialization and deserialization </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">of messages.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Protobuf is an </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">Interface Description </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.15.1">Language</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.16.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.17.1">IDL</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">)</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Serialization/deserialization</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Protobuf </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">versus JSON</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.22.1">Encoding details</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.23.1">Common types</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.24.1">Services</span></span></li>
</ul>
<h1 id="_idParaDest-38"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.25.1">Prerequisites</span></h1>
<p><span class="koboSpan" id="kobo.26.1">You can find the code for this chapter at </span><a href=""><span class="koboSpan" id="kobo.27.1">https://github.com/PacktPublishing/gRPC-Go-for-Professionals/tree/main/chapter2</span></a><span class="koboSpan" id="kobo.28.1">. </span><span class="koboSpan" id="kobo.28.2">In this chapter, we are going to discuss how Protocol Buffers serializes and deserializes data. </span><span class="koboSpan" id="kobo.28.3">While this can be done by writing code, we are going to stay away from that in order to learn how to use the protoc compiler to debug and optimize our Protobuf schemas. </span><span class="koboSpan" id="kobo.28.4">Thus, if you want to reproduce the examples specified, you will need to download the protoc compiler from the Protobuf GitHub </span><em class="italic"><span class="koboSpan" id="kobo.29.1">Releases</span></em><span class="koboSpan" id="kobo.30.1"> page (</span><a href=""><span class="koboSpan" id="kobo.31.1">https://github.com/protocolbuffers/protobuf/releases</span></a><span class="koboSpan" id="kobo.32.1">). </span><span class="koboSpan" id="kobo.32.2">The easiest way to get started is to download the binary releases. </span><span class="koboSpan" id="kobo.32.3">These releases are named with this convention: </span><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">protoc-${VERSION}-${OS}-{ARCHITECTURE}</span></strong><span class="koboSpan" id="kobo.34.1">. </span><span class="koboSpan" id="kobo.34.2">Uncompress the zip file and follow the </span><strong class="source-inline"><span class="koboSpan" id="kobo.35.1">readme.txt</span></strong><span class="koboSpan" id="kobo.36.1"> instructions (note: we do intend to use Well-Known Types in the future so make sure you also install the includes). </span><span class="koboSpan" id="kobo.36.2">After that, you should be able to run the </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.38.1">
$ protoc --version</span></pre>
<p><span class="koboSpan" id="kobo.39.1">Finally, as always, you will be able to find the companion code in the GitHub repository under the folder for the current </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">chapter (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">chapter2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">).</span></span></p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.43.1">Protobuf is an IDL</span></h1>
<p><span class="koboSpan" id="kobo.44.1">Protobuf is a</span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.45.1"> language. </span><span class="koboSpan" id="kobo.45.2">More precisely, it is an IDL. </span><span class="koboSpan" id="kobo.45.3">It is important to make such a distinction because, as we will see more in detail later, in Protobuf, we do not write any logic the way we do in a programming language, but instead, we write data schemas, which are contracts to be used for serialization and are to be fulfilled by deserialization. </span><span class="koboSpan" id="kobo.45.4">So, before explaining all the rules that we need to follow when writi</span><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.46.1">ng a </span><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">.proto</span></strong><span class="koboSpan" id="kobo.48.1"> file and going through all the details about serialization and deserialization, we need to first get a sense of what an IDL is and what is the goal of such </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">a language.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">An IDL, as we saw earlier, is </span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.51.1">an acronym for </span><em class="italic"><span class="koboSpan" id="kobo.52.1">Interface Description Language</span></em><span class="koboSpan" id="kobo.53.1">, and as we can see, the name contains three parts. </span><span class="koboSpan" id="kobo.53.2">The first part, </span><strong class="bold"><span class="koboSpan" id="kobo.54.1">Interface</span></strong><span class="koboSpan" id="kobo.55.1">, describes a piece of code that sits in between two or more applications and hides the complexity of implementation. </span><span class="koboSpan" id="kobo.55.2">As such, we do not make any assumptions about the hardware on which an application is running, the OS on which it runs, and in which programming language it is written. </span><span class="koboSpan" id="kobo.55.3">This interface is, by design, hardware-, OS-, and language-agnostic. </span><span class="koboSpan" id="kobo.55.4">This is important for Protobuf and several other serialization data schemas because it lets developers write the code once and it can be used across </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">different projects.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">The second part is </span><strong class="bold"><span class="koboSpan" id="kobo.58.1">Description</span></strong><span class="koboSpan" id="kobo.59.1">, and this sits on top of the concept of Interface. </span><span class="koboSpan" id="kobo.59.2">Our interface is describing what the two applications can expect to receive and what they are expected to send to each other. </span><span class="koboSpan" id="kobo.59.3">This includes describing some types and their properties, the relationship between these types, and the way these types are serialized and deserialized. </span><span class="koboSpan" id="kobo.59.4">As this may be a bit abstract, let us look at an example in Protobuf. </span><span class="koboSpan" id="kobo.59.5">If we wanted to create a type called </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">Account</span></strong><span class="koboSpan" id="kobo.61.1"> that contains an ID, a username, and the rights this account has, we could write </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.63.1">
syntax = "proto3</span><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.64.1">";
enum AccountRight {
  ACCOUNT_</span><strong class="bold"><span class="koboSpan" id="kobo.65.1">RIGHT_UNSPECIFIED</span></strong><span class="koboSpan" id="kobo.66.1"> = 0;
  ACCOUNT_</span><strong class="bold"><span class="koboSpan" id="kobo.67.1">RIGHT_READ</span></strong><span class="koboSpan" id="kobo.68.1"> = 1;
  ACCOUNT_</span><strong class="bold"><span class="koboSpan" id="kobo.69.1">RIGHT_READ_WRITE</span></strong><span class="koboSpan" id="kobo.70.1"> = 2;
  ACCOUNT_</span><strong class="bold"><span class="koboSpan" id="kobo.71.1">RIGHT_ADMIN</span></strong><span class="koboSpan" id="kobo.72.1"> = 3;
}
message Account {
  uint64 </span><strong class="bold"><span class="koboSpan" id="kobo.73.1">id</span></strong><span class="koboSpan" id="kobo.74.1"> = 1;
  string </span><strong class="bold"><span class="koboSpan" id="kobo.75.1">username</span></strong><span class="koboSpan" id="kobo.76.1"> = 2;
  AccountRight </span><strong class="bold"><span class="koboSpan" id="kobo.77.1">right</span></strong><span class="koboSpan" id="kobo.78.1"> = 3;
}</span></pre>
<p><span class="koboSpan" id="kobo.79.1">If we skip some of the details that are not important at this stage, we can see that we define </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.81.1">An enumeration listing all the possible rights and an extra role </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">called </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">ACCOUNT_RIGHT_UNSPECIFIED</span></strong></span></li>
<li><span class="koboSpan" id="kobo.84.1">A message (equivalent to a class or struct) listing the three properties that an </span><strong class="source-inline"><span class="koboSpan" id="kobo.85.1">Account</span></strong><span class="koboSpan" id="kobo.86.1"> type </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">should have</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.88.1">Again, without looking at the details, it is readable, and the relationship between </span><strong class="source-inline"><span class="koboSpan" id="kobo.89.1">Account</span></strong><span class="koboSpan" id="kobo.90.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.91.1">AccountRight</span></strong><span class="koboSpan" id="kobo.92.1"> is easy </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">to understand.</span></span></p>
<p><span class="koboSpan" id="kobo.94.1">Finally, the last </span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.95.1">part is </span><strong class="bold"><span class="koboSpan" id="kobo.96.1">Language</span></strong><span class="koboSpan" id="kobo.97.1">. </span><span class="koboSpan" id="kobo.97.2">This is here to say that, as with every language—computer ones or not—we have rules that we need to follow so that another human, or a compiler, can understand our intent. </span><span class="koboSpan" id="kobo.97.3">In Protobuf, we write our code to please the compi</span><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.98.1">ler (protoc), and then it does all the heavy lifting for us. </span><span class="koboSpan" id="kobo.98.2">It will read our code and generate code in the language that we need for our application, and then our user code will interact with the generated code. </span><span class="koboSpan" id="kobo.98.3">Let us look at a simplified output of what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">Account</span></strong><span class="koboSpan" id="kobo.100.1"> type defined previously would give </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">in Go:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.102.1">
type AccountRight int32
const</span><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.103.1"> (
  AccountRight_ACCOUNT_RIGHT_UNSPECIFIED AccountRight =</span><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.104.1"> 0
  AccountRight_ACCOUNT_RIGHT_READ AccountRight =</span><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.105.1"> 1
  AccountRight_ACCOUNT_RIGHT_READ_WRITE AccountRight =</span><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.106.1"> 2
  AccountRight_ACCOUNT_RIGHT_ADMIN AccountRight = 3
)
type Account struct {
  Id uint64 `protobuf:"varint,1,…`
  Username string `protobuf:"bytes,2,…`
  Right AccountRight `protobuf:"varint,3,…`
}</span></pre>
<p><span class="koboSpan" id="kobo.107.1">In this code, there </span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.108.1">are important things to notice. </span><span class="koboSpan" id="kobo.108.2">Let us break this code </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">into pieces:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.110.1">
type AccountRight </span><strong class="bold"><span class="koboSpan" id="kobo.111.1">int32</span></strong><span class="koboSpan" id="kobo.112.1">
const (
  AccountRight_</span><strong class="bold"><span class="koboSpan" id="kobo.113.1">ACCOUNT_RIGHT_UNSPECIFIED</span></strong><span class="koboSpan" id="kobo.114.1"> AccountRight = </span><strong class="bold"><span class="koboSpan" id="kobo.115.1">0</span></strong><span class="koboSpan" id="kobo.116.1">
  AccountRight_</span><strong class="bold"><span class="koboSpan" id="kobo.117.1">ACCOUNT_RIGHT_READ</span></strong><span class="koboSpan" id="kobo.118.1"> AccountRight = </span><strong class="bold"><span class="koboSpan" id="kobo.119.1">1</span></strong><span class="koboSpan" id="kobo.120.1">
  AccountRight_</span><strong class="bold"><span class="koboSpan" id="kobo.121.1">ACCOUNT_RIGHT_READ_WRITE</span></strong><span class="koboSpan" id="kobo.122.1"> AccountRight = </span><strong class="bold"><span class="koboSpan" id="kobo.123.1">2</span></strong><span class="koboSpan" id="kobo.124.1">
  AccountRight_</span><strong class="bold"><span class="koboSpan" id="kobo.125.1">ACCOUNT_RIGHT_ADMIN</span></strong><span class="koboSpan" id="kobo.126.1"> AccountRight = </span><strong class="bold"><span class="koboSpan" id="kobo.127.1">3</span></strong><span class="koboSpan" id="kobo.128.1">
)</span></pre>
<p><span class="koboSpan" id="kobo.129.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">AccountRight</span></strong><span class="koboSpan" id="kobo.131.1"> enum is defined as constants with values of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">int32</span></strong><span class="koboSpan" id="kobo.133.1">. </span><span class="koboSpan" id="kobo.133.2">Each enum variant’s name is prefixed with the name of the enum, and each constant has the value that we set after the equals sign in the Protobuf code. </span><span class="koboSpan" id="kobo.133.3">These values are called field tags, and we will introduce them later in </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.135.1">Now, take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.137.1">
type Account </span><strong class="bold"><span class="koboSpan" id="kobo.138.1">struct</span></strong><span class="koboSpan" id="kobo.139.1"> {
  </span><strong class="bold"><span class="koboSpan" id="kobo.140.1">Id uint64</span></strong><span class="koboSpan" id="kobo.141.1"> `protobuf:"varint,</span><strong class="bold"><span class="koboSpan" id="kobo.142.1">1</span></strong><span class="koboSpan" id="kobo.143.1">,…`
  </span><strong class="bold"><span class="koboSpan" id="kobo.144.1">Username string</span></strong><span class="koboSpan" id="kobo.145.1"> `protobuf:"bytes,</span><strong class="bold"><span class="koboSpan" id="kobo.146.1">2</span></strong><span class="koboSpan" id="kobo.147.1">,…`
  </span><strong class="bold"><span class="koboSpan" id="kobo.148.1">Right AccountRight</span></strong><span class="koboSpan" id="kobo.149.1"> `protobuf:"varint,</span><strong class="bold"><span class="koboSpan" id="kobo.150.1">3</span></strong><span class="koboSpan" id="kobo.151.1">,…`
}</span></pre>
<p><span class="koboSpan" id="kobo.152.1">Here, we have our </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">Account</span></strong><span class="koboSpan" id="kobo.154.1"> message transpiled to a struct with </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">Id</span></strong><span class="koboSpan" id="kobo.156.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">Username</span></strong><span class="koboSpan" id="kobo.158.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">Right</span></strong><span class="koboSpan" id="kobo.160.1"> exported </span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.161.1">fields. </span><span class="koboSpan" id="kobo.161.2">Each of these fields has a type that is converted from a Protobuf type to a Golang type. </span><span class="koboSpan" id="kobo.161.3">In our example</span><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.162.1"> here, Go types and Protobuf types have the exact same names, but it is important to know that in some cases, the types will translate differently. </span><span class="koboSpan" id="kobo.162.2">Such an example is </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">double</span></strong><span class="koboSpan" id="kobo.164.1"> in Protobuf, which will translate to </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">float64</span></strong><span class="koboSpan" id="kobo.166.1"> for Go. </span><span class="koboSpan" id="kobo.166.2">Finally, we have the field tags, referenced in the metadata following the field. </span><span class="koboSpan" id="kobo.166.3">Once again, their meaning will be explained later in </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">So, to recapitulate, an IDL is a piece of code sitting between different applications and describing objects and their relationships by following certain defined rules. </span><span class="koboSpan" id="kobo.168.2">This IDL, in the case of Protobuf, will be read, and it will be used to generate code in another language. </span><span class="koboSpan" id="kobo.168.3">And after that, this generated code will be used by the user code to serialize and </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">deserialize data.</span></span></p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.170.1">Serialization and deserialization</span></h1>
<p><span class="koboSpan" id="kobo.171.1">Serialization and deserialization </span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.172.1">are two concepts that are used in many ways and in many kinds of applications. </span><span class="koboSpan" id="kobo.172.2">This section is going to discuss these two concepts in the context of Protobuf. </span><span class="koboSpan" id="kobo.172.3">So, even if you feel confident about your understanding of these two notions, it is important to get your head straight and understand them properly. </span><span class="koboSpan" id="kobo.172.4">Once you do, it will be easier to deal with the </span><em class="italic"><span class="koboSpan" id="kobo.173.1">Encoding details</span></em><span class="koboSpan" id="kobo.174.1"> section where we are going to delve deeper into how Protobuf serializes and deserializes data under </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">the hood.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">Let us start </span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.177.1">with serialization and then let us touch upon deserialization, which is just the opposite process. </span><span class="koboSpan" id="kobo.177.2">The goal of serialization is to sto</span><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.178.1">re data, generally in a more compact or readable representation, to use it later. </span><span class="koboSpan" id="kobo.178.2">For Protobuf, this serialization happens on the data that you set in your generated code’s objects. </span><span class="koboSpan" id="kobo.178.3">For example, if we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">Id</span></strong><span class="koboSpan" id="kobo.180.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">Username</span></strong><span class="koboSpan" id="kobo.182.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">Right</span></strong><span class="koboSpan" id="kobo.184.1"> fields in our</span><a id="_idTextAnchor063"/> <strong class="source-inline"><span class="koboSpan" id="kobo.185.1">Account</span></strong><span class="koboSpan" id="kobo.186.1"> struct, this data will be what Protobuf will work on. </span><span class="koboSpan" id="kobo.186.2">It will turn each field into a binary representation with different algorithms depending on the field type. </span><span class="koboSpan" id="kobo.186.3">And after that, we use this in-memory binary to either send data over the network (with gRPC, for example) or store it in more </span><span class="No-Break"><span class="koboSpan" id="kobo.187.1">persistent storage.</span></span></p>
<p><span class="koboSpan" id="kobo.188.1">Once it is time for </span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.189.1">us to use this serialized data again, Protobuf will perform deserialization. </span><span class="koboSpan" id="kobo.189.2">This is the process of reading the binary created earlier and populating the data back </span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.190.1">into an object in your favorite programming language to be able to act on it. </span><span class="koboSpan" id="kobo.190.2">Once again, Protobuf will use different algorithms depending on the type of data to read the underlying binary and know how to set or not set each of the fields of the object </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">in question.</span></span></p>
<p><span class="koboSpan" id="kobo.192.1">To summarize, Protobuf performs binary serialization to make data more compact than other formats such as XML or JSON. </span><span class="koboSpan" id="kobo.192.2">To do so, it will read data from the different fields of the generated code’s object, turn it into binary with different algorithms, and then when we finally need the data, Protobuf will read the data and populate the fields of a </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">given object.</span></span></p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.194.1">Protobuf versus JSON</span></h1>
<p><span class="koboSpan" id="kobo.195.1">If you’ve </span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.196.1">already worked on the backend or even frontend, there is a 99.99 percent chance that you’ve worked with JSON. </span><span class="koboSpan" id="kobo.196.2">This is by far the most popular data schema out there and there are reasons why it is the case. </span><span class="koboSpan" id="kobo.196.3">In this section, we are going to discuss the pros and cons of both JSON and Protobuf and we are going to explain which one is more suitable for which situation. </span><span class="koboSpan" id="kobo.196.4">The goal here is to be objective because as engineers, we need to be to choose the right tool for the </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">right job.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">As we could write chapters about the pros and cons of each technology, we are going to reduce the scope of these advantages and disadvantages to three categories. </span><span class="koboSpan" id="kobo.198.2">These categories are the ones that developers care the most about when developing applications, as </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">detailed here:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.200.1">Size of serialized data</span></strong><span class="koboSpan" id="kobo.201.1">: We want to reduce the bandwidth when sending data over </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">the network</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.203.1">Readability of the data schema and the serialized data</span></strong><span class="koboSpan" id="kobo.204.1">: We want to be able to have a descriptive schema so that newcomers or users can quickly understand it, and we want to be able to visualize the data serialized for debugging or </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">editing purposes</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.206.1">Strictness of the schema</span></strong><span class="koboSpan" id="kobo.207.1">: This quickly becomes a requirement when APIs grow, and we need to ensure the correct type of data is being sent and received between </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">different applications</span></span></li>
</ul>
<h2 id="_idParaDest-42"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.209.1">Serialized data size</span></h2>
<p><span class="koboSpan" id="kobo.210.1">In </span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.211.1">serialization, the Holy Grail is, in a lot of use cases, reducing the size of your data. </span><span class="koboSpan" id="kobo.211.2">This is because most often, we want to send that data to another application across the network, and the lighter the payload, the faster it should arrive on the other side. </span><em class="italic"><span class="koboSpan" id="kobo.212.1">In this space, Protobuf is the clear winner against JSON</span></em><span class="koboSpan" id="kobo.213.1">. </span><span class="koboSpan" id="kobo.213.2">This is the case because JSON serializes to text whereas Protobuf serializes to binary and thus has more room to improve how compact the serialized data is. </span><span class="koboSpan" id="kobo.213.3">An example of that is numbers. </span><span class="koboSpan" id="kobo.213.4">If you set a number to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">id</span></strong><span class="koboSpan" id="kobo.215.1"> field in JSON, you would get something </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.217.1">
{ id: 123 }</span></pre>
<p><span class="koboSpan" id="kobo.218.1">First, we have some boilerplate with the braces, but most importantly we have a number that takes three characters, or three bytes. </span><span class="koboSpan" id="kobo.218.2">In Protobuf, if we set the same value to the same field, we would get the hexadecimal shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">following callout.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.220.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.221.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">chapter2</span></strong><span class="koboSpan" id="kobo.223.1"> folder of the companion GitHub repository, you will find the files need to reproduce all the results in this chapter. </span><span class="koboSpan" id="kobo.223.2">With protoc, we will be able to display the hexadecimal representation of our serialized data. </span><span class="koboSpan" id="kobo.223.3">To do that, you can run the </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">following command:</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.225.1">Linux/Mac: </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">cat ${INPUT_FILE_NAME}.txt | protoc --encode=${MESSAGE_NAME} ${PROTO_FILE_NAME}.proto |</span></strong> <span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">hexdump –C</span></strong></span></p>
<p class="callout"><span class="koboSpan" id="kobo.228.1">Windows (PowerShell): </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">(Get-Content ${INPUT_FILE_NAME}.txt | protoc --encode=${MESSAGE_NAME} ${PROTO_FILE_NAME}.proto) -join "`n" | </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">Format-Hex</span></strong></span></p>
<p class="callout"><span class="No-Break"><span class="koboSpan" id="kobo.231.1">For example:</span></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">$ cat account.txt</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.233.1">| protoc --en</span><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.234.1">code=Account account.proto |</span></strong> <span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">hexdump -C</span></strong></span></p>
<p class="callout"><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">00000000  08 7b                                     |.{|</span></strong></p>
<p class="callout"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">00000002</span></strong></span></p>
<p><span class="koboSpan" id="kobo.238.1">Right </span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.239.1">now, this might look like magic numbers, but we are going to see in the next section how it is encoded into two bytes. </span><span class="koboSpan" id="kobo.239.2">Now, two bytes instead of three might look negligible but imagine this kind of difference at scale, and you would have wasted millions </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">of bytes.</span></span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.241.1">Readability</span></h2>
<p><span class="koboSpan" id="kobo.242.1">The</span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.243.1"> next important thing about data schema serialization is readability. </span><span class="koboSpan" id="kobo.243.2">However, readability is a little bit too broad, especially in the context of Protobuf. </span><span class="koboSpan" id="kobo.243.3">As we saw, as opposed to JSON, Protobuf separates the schema from the serialized data. </span><span class="koboSpan" id="kobo.243.4">We write</span><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.244.1"> the schema in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">.proto</span></strong><span class="koboSpan" id="kobo.246.1"> file and then the serialization will give us some binary. </span><span class="koboSpan" id="kobo.246.2">In JSON, the schema is the actual serialized data. </span><span class="koboSpan" id="kobo.246.3">So, to be clearer and more precise about readability, let us split readability into two parts: the readability of the schema and the readability of the </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">serialized data.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">As for the readability of the schema, this is a matter of preference, but there are a few points that make Protobuf stand out. </span><span class="koboSpan" id="kobo.248.2">The first one of them is that Protobuf can contain comments, and this is nice to have for extra documentation describing requirements. </span><span class="koboSpan" id="kobo.248.3">JSON does not allow comments in the schema, s</span><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.249.1">o we must find a different way to provide </span><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.250.1">documentation. </span><span class="koboSpan" id="kobo.250.2">Generally, it is done with GitHub wikis or other external documentation platforms. </span><span class="koboSpan" id="kobo.250.3">This is a problem because this kind of documentation quickly becomes outdated when the project and the team working on it get bigger. </span><span class="koboSpan" id="kobo.250.4">A simple oversight and your documentation do not describe the real state of your API. </span><span class="koboSpan" id="kobo.250.5">With Protobuf, it is still possible to have outdated documentation, but as the documentation is closer to the code, it provides more incentive and awareness to change the </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">related comment.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">The second feature that makes Protobuf more readable is the fact that it has explicit types. </span><span class="koboSpan" id="kobo.252.2">JSON has types but they are implicit. </span><span class="koboSpan" id="kobo.252.3">You know that a field contains a string if its value is surrounded by double quotes, a number when the value is only digits, and so on. </span><span class="koboSpan" id="kobo.252.4">In Protobuf, especially for numbers, we get more information out of types. </span><span class="koboSpan" id="kobo.252.5">If we have an </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">int32</span></strong><span class="koboSpan" id="kobo.254.1"> type, we can obviously know that this is a number, but on top of that, we know that it can accept negative numbers and we are able to know the range of numbers that</span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.255.1"> can be stored in this field. </span><span class="koboSpan" id="kobo.255.2">Explicit types are important not only for security (more on that later) but also for letting the developer know the details of each field and letting them describe accurately their schemas to fulfill the </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">business requirements.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.257.1">For readability of the schema, I think we can agree that Protobuf is the winner here</span></em><span class="koboSpan" id="kobo.258.1"> because it can be written as self-documenting code and we get explicit types for every field </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">in objects.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.260.1">As for the readability of serialized data, JSON is the clear winner here</span></em><span class="koboSpan" id="kobo.261.1">. </span><span class="koboSpan" id="kobo.261.2">As mentioned, JSON is both the data schema and the serialized data. </span><span class="koboSpan" id="kobo.261.3">What you see is what you get. </span><span class="koboSpan" id="kobo.261.4">Protobuf, however, serializes the data to binary, and it is way harder to read that, even if you know how Protobuf serializes and deserializes data. </span><span class="koboSpan" id="kobo.261.5">In the end, this is a trade-off between readability and serialized data size here. </span><span class="koboSpan" id="kobo.261.6">Protobuf will outperform JSON on serialized data and is way more explicit on the readability of the data schema. </span><span class="koboSpan" id="kobo.261.7">However, if you need human-readable data that can be edited by hand, Protobuf is not the right fit for your </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">use case.</span></span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.263.1">Schema strictness</span></h2>
<p><span class="koboSpan" id="kobo.264.1">Finally, the</span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.265.1"> last category is the strictness of the schema. </span><span class="koboSpan" id="kobo.265.2">This is usually a nice feature to have when your team and your project scale because it ensures that the schema is correctly populated, and for a certain target language, it shortens the feedback loop for </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">the developers.</span></span></p>
<p><span class="koboSpan" id="kobo.267.1">Schemas are always valid ones because every field has an explicit type that can only contain certain values. </span><span class="koboSpan" id="kobo.267.2">We simply cannot pass a string to a field that was expecting a number or a negative number to a field that was expecting a positive number. </span><span class="koboSpan" id="kobo.267.3">This is enforced in the generated code by either runtime checks for dynamic languages or at compile time for typed languages. </span><span class="koboSpan" id="kobo.267.4">In our case, since Go is a typed language, we will have </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">compile-time checks.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">And finally, in typed languages, a schema shortens the feedback loop because instead of having a runtime check that might or might not trigger an error, we simply have a compilation error. </span><span class="koboSpan" id="kobo.269.2">This makes our software more reliable, and developers can feel confident that if they were able to compile, the data set into the object would </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">be valid.</span></span></p>
<p><span class="koboSpan" id="kobo.271.1">In pure JSON, we cannot ensure that our schema is correct at compile time. </span><span class="koboSpan" id="kobo.271.2">Most often, developers will add extra configurations such as JSON Schema to have this kind of assurance at runtime. </span><span class="koboSpan" id="kobo.271.3">This adds complexity to our project and requires every developer to be disciplined because they could simply go about their code without developing the schema. </span><span class="koboSpan" id="kobo.271.4">In Protobuf, we do schema-driven development. </span><span class="koboSpan" id="kobo.271.5">The schema comes first, and then our </span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.272.1">application revolves around the generated types. </span><span class="koboSpan" id="kobo.272.2">Furthermore, we have assurance at compile time that the values that we set are correct and we do not need to replicate the setup to all our microservices or subprojects. </span><span class="koboSpan" id="kobo.272.3">In the end, we spend less time on configuration and we spend more time thinking about our data schemas and the </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">data encoding.</span></span></p>
<h1 id="_idParaDest-45"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.274.1">Encoding details</span></h1>
<p><span class="koboSpan" id="kobo.275.1">Up until now, we talked a lot about “algorithms”; however, we did not get too much into the specifics. </span><span class="koboSpan" id="kobo.275.2">In this section, we are going to see the major algorithms that are behind the serialization and deserialization processes in Protobuf. </span><span class="koboSpan" id="kobo.275.3">We are first going to see all the types that we can use for our fields, then with that, we are going to divide them into three categories, and finally, we are going to explain which algorithm is used for </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">each category.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">In Protobuf, types</span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.278.1"> that are </span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.279.1">considered simple and that are provided by Protobuf out</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.280.1"> of the box are called </span><strong class="bold"><span class="koboSpan" id="kobo.281.1">scalar types</span></strong><span class="koboSpan" id="kobo.282.1">. </span><span class="koboSpan" id="kobo.282.2">We can use 15 of such types, as </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">listed here:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">int32</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">int64</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">uint32</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">uint64</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">sint32</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">sint64</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">fixed32</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">fixed64</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">sfixed32</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">sfixed64</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">double</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">float</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">string</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">bytes</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">bool</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.299.1">And out of</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.300.1"> these 15 types, 10 are for integers (the 10 first ones). </span><span class="koboSpan" id="kobo.300.2">These types might be intimidating at first, but do not worry too much about how to choose between them right now; we are going to discuss that throughout this section. </span><span class="koboSpan" id="kobo.300.3">The most important thing to understand right now is that two-thirds of the types are for integers, and this shows what Protobuf is good </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">at—encoding integers.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">Now that we know the scalar types, let us separate these types into three categories. </span><span class="koboSpan" id="kobo.302.2">However, we are not here to make simple categories such as numbers, arrays, and so on. </span><span class="koboSpan" id="kobo.302.3">We want to make categories that are related to the Protobuf serialization algorithms. </span><span class="koboSpan" id="kobo.302.4">In total, we have three: fixed-size numbers, variable-size integers (varints), and length-delimited types. </span><span class="koboSpan" id="kobo.302.5">Here is a table with each </span><span class="No-Break"><span class="koboSpan" id="kobo.303.1">category populated:</span></span></p>
<table class="No-Table-Style" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.304.1">Fixed-size numbers</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.305.1">Varints</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.306.1">Length-delimited types</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p class="IMG---Figure"><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">fixed32</span></strong></p>
</td>
<td class="No-Table-Style">
<p class="IMG---Figure"><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">int32</span></strong></p>
</td>
<td class="No-Table-Style">
<p class="IMG---Figure"><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">string</span></strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p class="IMG---Figure"><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">fixed64</span></strong></p>
</td>
<td class="No-Table-Style">
<p class="IMG---Figure"><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">int64</span></strong></p>
</td>
<td class="No-Table-Style">
<p class="IMG---Figure"><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">bytes</span></strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p class="IMG---Figure"><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">sfixed32</span></strong></p>
</td>
<td class="No-Table-Style">
<p class="IMG---Figure"><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">uint32</span></strong></p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p class="IMG---Figure"><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">sfixed64</span></strong></p>
</td>
<td class="No-Table-Style">
<p class="IMG---Figure"><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">uint64</span></strong></p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p class="IMG---Figure"><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">double</span></strong></p>
</td>
<td class="No-Table-Style">
<p class="IMG---Figure"><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">bool</span></strong></p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p class="IMG---Figure"><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">float</span></strong></p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style"/>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.320.1">Let’s go through </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">each now.</span></span></p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.322.1">Fixed-size numbers</span></h2>
<p><span class="koboSpan" id="kobo.323.1">The</span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.324.1"> easiest one to understand for developers who are used to</span><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.325.1"> typed languages is fixed-size numbers. </span><span class="koboSpan" id="kobo.325.2">If you worked with lower-level languages in which you tried to optimize storage space, you know that we can, on most hardware, store an integer in 32 bits (4 bytes) or in 64 bits (8 bytes). </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">fixed32</span></strong><span class="koboSpan" id="kobo.327.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">fixed64</span></strong><span class="koboSpan" id="kobo.329.1"> are just binary representations of a normal number that you would have in languages that give you control over the storage size of your integers (for example, Go, C++, Rust, and so on). </span><span class="koboSpan" id="kobo.329.2">If we serialize the number 42 into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">fixed32</span></strong><span class="koboSpan" id="kobo.331.1"> type, we will have </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.333.1">$ cat fixed.txt | protoc --encode=Fixed32Value</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.334.1">  wrappers.proto | hexdump -C</span></strong><span class="koboSpan" id="kobo.335.1">
00000000  0d 2a 00 00 00                          |.*...|
00000005</span></pre>
<p><span class="koboSpan" id="kobo.336.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">2a</span></strong><span class="koboSpan" id="kobo.338.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">42</span></strong><span class="koboSpan" id="kobo.340.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">0d</span></strong><span class="koboSpan" id="kobo.342.1"> is a combination of the field tag and the type of the field (more about that later in this section). </span><span class="koboSpan" id="kobo.342.2">In the same manner, if we serialize </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">42</span></strong><span class="koboSpan" id="kobo.344.1"> in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">fixed64</span></strong><span class="koboSpan" id="kobo.346.1"> type, we will have </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.348.1">$ cat fixed.txt | protoc --encode=Fixed64Value</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.349.1">  wrappers.proto | hexdump -C</span></strong><span class="koboSpan" id="kobo.350.1">
00000000  09 2a 00 00 00 00 00 00  00         |.*.......|
00000009</span></pre>
<p><span class="koboSpan" id="kobo.351.1">And the only thing that changed is the combination between the type of the field and the field tag (</span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">09</span></strong><span class="koboSpan" id="kobo.353.1">). </span><span class="koboSpan" id="kobo.353.2">This is mostly because we changed the type to </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">64-bit numbers.</span></span></p>
<p><span class="koboSpan" id="kobo.355.1">Two other scalar types that are easy to understand are </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">float</span></strong><span class="koboSpan" id="kobo.357.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">double</span></strong><span class="koboSpan" id="kobo.359.1">. </span><span class="koboSpan" id="kobo.359.2">Once again, Protobuf produces the binary representation of these types. </span><span class="koboSpan" id="kobo.359.3">If we encode </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">42.42</span></strong><span class="koboSpan" id="kobo.361.1"> as </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">float</span></strong><span class="koboSpan" id="kobo.363.1">, we will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">following output:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.365.1">$ cat floating_point.txt | protoc --encode=FloatValue</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.366.1">  wrappers.proto | hexdump -C</span></strong><span class="koboSpan" id="kobo.367.1">
00000000  0d 14 ae 29 42                          |...)B|
00000005</span></pre>
<p><span class="koboSpan" id="kobo.368.1">In this case, this is a little bit more complicated to decode, but this is simply because float numbers are encoded differently. </span><span class="koboSpan" id="kobo.368.2">If you are interested in this kind of data storage, you can</span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.369.1"> look at the </span><em class="italic"><span class="koboSpan" id="kobo.370.1">IEEE Standard for Floating-Point Arithmetic</span></em><span class="koboSpan" id="kobo.371.1"> (</span><em class="italic"><span class="koboSpan" id="kobo.372.1">IEEE 754</span></em><span class="koboSpan" id="kobo.373.1">), which explains how a float is formed in memory. </span><span class="koboSpan" id="kobo.373.2">What is important to note here is that floats are encoded in 4 bytes, and in front, we have our tag + type. </span><span class="koboSpan" id="kobo.373.3">And for a </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">double</span></strong><span class="koboSpan" id="kobo.375.1"> type with a value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">42.42</span></strong><span class="koboSpan" id="kobo.377.1">, we will get </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.379.1">$ cat floating_point.txt | protoc --encode=DoubleValue</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.380.1">  wrappers.proto | hexdump -C</span></strong><span class="koboSpan" id="kobo.381.1">
00000000  09 f6 28 5c 8f c2 35 45  40         |.</span><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.382.1">.(\..5E@|
00000009</span></pre>
<p><span class="koboSpan" id="kobo.383.1">This is encoded in 8 bytes and the tag + type. </span><span class="koboSpan" id="kobo.383.2">Note that the tag + type also changed here because we are in the realm of </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">64-bit numbers.</span></span></p>
<p><span class="koboSpan" id="kobo.385.1">Finally, we are left with </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">sfixed32</span></strong><span class="koboSpan" id="kobo.387.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">sfixed64</span></strong><span class="koboSpan" id="kobo.389.1">. </span><span class="koboSpan" id="kobo.389.2">We did not mention it earlier, but </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">fixed32</span></strong><span class="koboSpan" id="kobo.391.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">fixed64</span></strong><span class="koboSpan" id="kobo.393.1"> are unsigned numbers. </span><span class="koboSpan" id="kobo.393.2">This means that we cannot store negative numbers in fields with these types. </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">sfixed32</span></strong><span class="koboSpan" id="kobo.395.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">sfixed64</span></strong><span class="koboSpan" id="kobo.397.1"> solve that. </span><span class="koboSpan" id="kobo.397.2">So, if we encode –42 in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">sfixed32</span></strong><span class="koboSpan" id="kobo.399.1"> type, we will have </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.401.1">$ cat sfixed.txt | protoc --encode=SFixed32Value</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.402.1">  wrappers.proto | hexdump -C</span></strong><span class="koboSpan" id="kobo.403.1">
00000000  0d d6 f</span><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.404.1">f f</span><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.405.1">f ff                          |.....|
00000005</span></pre>
<p><span class="koboSpan" id="kobo.406.1">This is obtained by taking the binary for 42, flipping all the bits (1’s complement), and adding one (2’s complement). </span><span class="koboSpan" id="kobo.406.2">Otherwise, if you serialize a positive number, you will have the same binary as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">fixed32</span></strong><span class="koboSpan" id="kobo.408.1"> type. </span><span class="koboSpan" id="kobo.408.2">Then, if we encode –42 in a field with type </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">sfixed64</span></strong><span class="koboSpan" id="kobo.410.1">, we will get </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.412.1">$ cat sfixed.txt | protoc --encode=SFixed64Value</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.413.1">  wrappers.proto | hexdump -C</span></strong><span class="koboSpan" id="kobo.414.1">
00000000  09 d6 f</span><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.415.1">f f</span><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.416.1">f f</span><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.417.1">f f</span><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.418.1">f f</span><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.419.1">f ff</span><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.420.1">  ff         |.........|
00000009</span></pre>
<p><span class="koboSpan" id="kobo.421.1">This is like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">sfixed32</span></strong><span class="koboSpan" id="kobo.423.1"> type, only the tag + type </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">was changed.</span></span></p>
<p><span class="koboSpan" id="kobo.425.1">To summarize, fixed integers are simple binary representations of integers that resemble how they are stored in most computers’ memory. </span><span class="koboSpan" id="kobo.425.2">As their name suggests, their serialized</span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.426.1"> data will always be serialized into the same number of bytes. </span><span class="koboSpan" id="kobo.426.2">For some use cases, this is fine to use such representations; however, in most cases, we would like to reduce the number of bits that are just here for padding. </span><span class="koboSpan" id="kobo.426.3">And in these use cases, we will use something </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">called varints.</span></span></p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.428.1">Varints</span></h2>
<p><span class="koboSpan" id="kobo.429.1">Now that we</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.430.1"> have seen fixed integers, let us move to another type of serialization for numbers: variable-length integers. </span><span class="koboSpan" id="kobo.430.2">As its name suggests, we will not get a fixed number of bytes when serializing </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">an integer.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">To be more precise, the smaller the integer, the smaller the number of bytes it will be serialized into, and the bigger the integer, the larger the number of bytes. </span><span class="koboSpan" id="kobo.432.2">Let us look at how the </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">algorithm works.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">In this example, let us serialize the number 300. </span><span class="koboSpan" id="kobo.434.2">To start, we are going to take the binary representation of </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">that number:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.436.1">
100101100</span></pre>
<p><span class="koboSpan" id="kobo.437.1">With this binary, we can now split it into groups of 7 bits and pad with zeros </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">if needed:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.439.1">
0000010
0101100</span></pre>
<p><span class="koboSpan" id="kobo.440.1">Now, since we lack 2 more bits to create 2 bytes, we are going to add 1 as the </span><strong class="bold"><span class="koboSpan" id="kobo.441.1">most significant bit</span></strong><span class="koboSpan" id="kobo.442.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.443.1">MSB</span></strong><span class="koboSpan" id="kobo.444.1">) for all the groups except the first one, and we are going to add 0 as the MSB for the </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">first group:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.446.1">
00000010
10101100</span></pre>
<p><span class="koboSpan" id="kobo.447.1">These MSBs are continuation bits. </span><span class="koboSpan" id="kobo.447.2">This means that, when we have 1, we still have 7 bits to read after, and if we have 0, this is the last group to be read. </span><span class="koboSpan" id="kobo.447.3">Finally, we put this number into little-endian order, and we have </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.449.1">
10101100 00000010</span></pre>
<p><span class="koboSpan" id="kobo.450.1">Or, we would have </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">AC 02</span></strong><span class="koboSpan" id="kobo.452.1"> in hexadecimal. </span><span class="koboSpan" id="kobo.452.2">Now that we have serialized 300 into </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">AC 02</span></strong><span class="koboSpan" id="kobo.454.1">, and keeping in mind that deserialization is the opposite of serialization, we can deserialize that data. </span><span class="koboSpan" id="kobo.454.2">We take our binary representation for </span><strong class="source-inline"><span class="koboSpan" id="kobo.455.1">AC 02</span></strong><span class="koboSpan" id="kobo.456.1">, drop the continuation bits (MSBs), and we reverse the order of bytes. </span><span class="koboSpan" id="kobo.456.2">In the end, we have the </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">following binary:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.458.1">
100101100</span></pre>
<p><span class="koboSpan" id="kobo.459.1">This is the same binary we started with. </span><span class="koboSpan" id="kobo.459.2">It </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">equals 300.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">Now, in</span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.462.1"> the real world, you might have larger numbers. </span><span class="koboSpan" id="kobo.462.2">For a quick reference on positive numbers, here is a list of the thresholds at which the number of bytes </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">will increase:</span></span></p>
<table class="No-Table-Style" id="table002">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.464.1">Threshold value</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.465.1">Byte size</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.466.1">0</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.467.1">0</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.468.1">1</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.469.1">1</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.470.1">128</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.471.1">2</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.472.1">16,384</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.473.1">3</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.474.1">2,097,152</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.475.1">4</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.476.1">268,435,456</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.477.1">5</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.478.1">34,359,738,368</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.479.1">6</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.480.1">4,398,046,511,104</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.481.1">7</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.482.1">562,949,953,421,312</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.483.1">8</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.484.1">72,057,594,037,927,936</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.485.1">9</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.486.1">9,223,372,036,854,775,807</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.487.1">9</span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.488.1">An astute reader might have noticed that having a varint is often beneficial, but in some cases, we might encode our values into more bytes than needed. </span><span class="koboSpan" id="kobo.488.2">For example, if we encode 72,057,594,037,927,936 into an </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">int64</span></strong><span class="koboSpan" id="kobo.490.1"> type, it will be serialized into 9 bytes, while with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">fixed64</span></strong><span class="koboSpan" id="kobo.492.1"> type, it will be encoded into 8. </span><span class="koboSpan" id="kobo.492.2">Furthermore, a problem coming from the encoding that we just saw is that negative numbers will be encoded into a large positive number and thus will be encoded into 9 bytes. </span><span class="koboSpan" id="kobo.492.3">That begs the following question: </span><em class="italic"><span class="koboSpan" id="kobo.493.1">How can we efficiently choose between the different </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.494.1">integer types?</span></em></span></p>
<h3><span class="koboSpan" id="kobo.495.1">How to choose?</span></h3>
<p><span class="koboSpan" id="kobo.496.1">The</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.497.1"> answer is, as always, it depends. </span><span class="koboSpan" id="kobo.497.2">However, we can be systematic in our choices to avoid many errors. </span><span class="koboSpan" id="kobo.497.3">We mostly have three choices that we need to make depending on the data we want </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">to serialize:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.499.1">The range of </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">numbers needed</span></span></li>
<li><span class="koboSpan" id="kobo.501.1">The need for </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">negative numbers</span></span></li>
<li><span class="koboSpan" id="kobo.503.1">The </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">data distribution</span></span></li>
</ul>
<h4><span class="koboSpan" id="kobo.505.1">The range</span></h4>
<p><span class="koboSpan" id="kobo.506.1">By now, you</span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.507.1"> might have noticed that the 32 and 64 suffixes on our types are not always about the number of bits into which our data will be serialized. </span><span class="koboSpan" id="kobo.507.2">For varints, this is more about the range of numbers that can be serialized. </span><span class="koboSpan" id="kobo.507.3">These ranges are dependent on the algorithm used </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">for serialization.</span></span></p>
<p><span class="koboSpan" id="kobo.509.1">For fixed, signed, and variable-length integers, the range of numbers is the same as the on</span><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.510.1">e developers are used to with 32 and 64 bits. </span><span class="koboSpan" id="kobo.510.2">This means that we get </span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.512.1">
[-2^(NUMBER_OF_BITS – 1), 2^(NUMBER_OF_BITS – 1) – 1]</span></pre>
<p><span class="koboSpan" id="kobo.513.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.514.1">NUMBER_OF_BITS</span></strong><span class="koboSpan" id="kobo.515.1"> is either 32 or 64 depending on the type you want </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">to use.</span></span></p>
<p><span class="koboSpan" id="kobo.517.1">For unsigned numbers (</span><strong class="source-inline"><span class="koboSpan" id="kobo.518.1">uint</span></strong><span class="koboSpan" id="kobo.519.1">)—this is again like what developers are expecting—we will get the </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">following range:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.521.1">
[0, 2 *</span><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.522.1"> 2^(NUMBER_OF_BITS – 1) - 1]</span></pre>
<h4><span class="koboSpan" id="kobo.523.1">The need for negative numbers</span></h4>
<p><span class="koboSpan" id="kobo.524.1">In the case </span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.525.1">where you simply do not need negative numbers (for example, for IDs), the ideal type to use is an unsigned integer (</span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">uint32</span></strong><span class="koboSpan" id="kobo.527.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">uint64</span></strong><span class="koboSpan" id="kobo.529.1">). </span><span class="koboSpan" id="kobo.529.2">This will prevent you from encoding negative numbers, it will have twice the range in positive numbers compared to signed integers, and it will serialize using the </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">varint algorithm.</span></span></p>
<p><span class="koboSpan" id="kobo.531.1">And another type that you will potentially work with is the one for signed integers (</span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">sint32</span></strong><span class="koboSpan" id="kobo.533.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">sint64</span></strong><span class="koboSpan" id="kobo.535.1">). </span><span class="koboSpan" id="kobo.535.2">We won’t go into details about how to serialize them, but the algorithm transforms any negative number into a positive number (ZigZag encoding) and serializes</span><a id="_idIndexMarker072"/><span class="koboSpan" id="kobo.536.1"> the positive number with the varint algorithm. </span><span class="koboSpan" id="kobo.536.2">This is more efficient for serializing negative numbers because instead of being serialized</span><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.537.1"> as a large positive number (9 bytes), we take advantage of the varint encoding. </span><span class="koboSpan" id="kobo.537.2">However, this is less efficient for serializing positive numbers because now we interleave the previously negative numbers and the positive numbers. </span><span class="koboSpan" id="kobo.537.3">This means that for the same positive number, we might have different amounts of </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">encoding bytes.</span></span></p>
<h4><span class="koboSpan" id="kobo.539.1">The data distribution</span></h4>
<p><span class="koboSpan" id="kobo.540.1">Finally, one </span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.541.1">thing that is worth mentioning is that encoding efficiency is highly dependent on your data distribution. </span><span class="koboSpan" id="kobo.541.2">You might have chosen some types depending on some assumptions, but your actual data might be different. </span><span class="koboSpan" id="kobo.541.3">Two common examples are choosing an </span><strong class="source-inline"><span class="koboSpan" id="kobo.542.1">int32</span></strong><span class="koboSpan" id="kobo.543.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">int64</span></strong><span class="koboSpan" id="kobo.545.1"> type because we expect to have few negative values and choosing an </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">int64</span></strong><span class="koboSpan" id="kobo.547.1"> type because we expect to have</span><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.548.1"> few very big numbers. </span><span class="koboSpan" id="kobo.548.2">Both situations might result in significant inefficiencies because, in both cases, we might get a lot of values serialized into </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">9 bytes.</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">Unfortunately, there is no way of deciding the type that will always perfectly fit the data. </span><span class="koboSpan" id="kobo.550.2">In this kind of situation, there is nothing better than doing experiments on real data that is representative of your whole dataset. </span><span class="koboSpan" id="kobo.550.3">This will give you an idea of what you are doing correctly and what you are </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">doing wrong.</span></span></p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.552.1">Length-delimited types</span></h2>
<p><span class="koboSpan" id="kobo.553.1">Now that </span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.554.1">we’ve seen all the types for numbers, we are left with the length-delimited types. </span><span class="koboSpan" id="kobo.554.2">These are the types, such as string and bytes, from which we cannot know the length at compile time. </span><span class="koboSpan" id="kobo.554.3">Think about these as </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">dynamic arrays.</span></span></p>
<p><span class="koboSpan" id="kobo.556.1">To serialize such a dynamic structure, we simply prefix the raw data with the length of that data that is following. </span><span class="koboSpan" id="kobo.556.2">This means that if we have a string of length 10 and content “0123456789”, we will have the following sequence </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">of bytes:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.558.1">$ cat length-delimited.txt | protoc --encode=StringValue</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.559.1">  wrappers.proto | hexdump -C</span></strong><span class="koboSpan" id="kobo.560.1">
0000000</span><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.561.1">0  0a 0a 30 31 32 33 34 35  36 37 38
  39              |..0123456789|
0000000c</span></pre>
<p><span class="koboSpan" id="kobo.562.1">Here, the first </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">0a</span></strong><span class="koboSpan" id="kobo.564.1"> instance </span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.565.1">is the field tag + type, the second </span><strong class="source-inline"><span class="koboSpan" id="kobo.566.1">0a</span></strong><span class="koboSpan" id="kobo.567.1"> instance is the hexadecimal representation of 10, and then we have the ASCII values for each character. </span><span class="koboSpan" id="kobo.567.2">To see why 0 turns into 30, you can check the ASCII manual by typing </span><strong class="source-inline"><span class="koboSpan" id="kobo.568.1">man ascii</span></strong><span class="koboSpan" id="kobo.569.1"> in your terminal and looking for the hexadecimal set. </span><span class="koboSpan" id="kobo.569.2">You should have a similar output to </span><span class="No-Break"><span class="koboSpan" id="kobo.570.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.571.1">
30  0    31  1    32  2    33  3    34  4
35  5    36  6    37  7    38  8    39  9</span></pre>
<p><span class="koboSpan" id="kobo.572.1">Here, the first number of each pair is the hexadecimal value for the </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">second one.</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">Another kind of message field that will be serialized into a length-delimited type is a repeated field. </span><span class="koboSpan" id="kobo.574.2">A repeated field is the equivalent of a list. </span><span class="koboSpan" id="kobo.574.3">To write such a field, we simply add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">repeated</span></strong><span class="koboSpan" id="kobo.576.1"> keyword before the field type. </span><span class="koboSpan" id="kobo.576.2">If we wanted to serialize a list of IDs, we could write </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.578.1">
repeated uint64 ids = 1;</span></pre>
<p><span class="koboSpan" id="kobo.579.1">And with this, we could store 0 or </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">more IDs.</span></span></p>
<p><span class="koboSpan" id="kobo.581.1">Similarly, these fields will be serialized with the length as a prefix. </span><span class="koboSpan" id="kobo.581.2">If we take the </span><strong class="source-inline"><span class="koboSpan" id="kobo.582.1">ids</span></strong><span class="koboSpan" id="kobo.583.1"> field and serialize the numbers from 1 to 9, we will have </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">the following:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.585.1">$ cat repeated.txt | protoc --encode=RepeatedUInt64Values</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.586.1">  wrappers.proto | hexdump -C</span></strong><span class="koboSpan" id="kobo.587.1">
00000000  0a 09 01 02 03 04 05 06  07 08 09 |...........|
0000000b</span></pre>
<p><span class="koboSpan" id="kobo.588.1">This is a list of 9 elements followed by 1, 2, … and </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">so on.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.590.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.591.1">Repeated fields are only serialized as length-delimited types when they are storing scalar types except for strings and bytes. </span><span class="koboSpan" id="kobo.591.2">These repeated fields are considered packed. </span><span class="koboSpan" id="kobo.591.3">For complex types or user-defined types (messages), the values will be encoded in a less optimal way. </span><span class="koboSpan" id="kobo.591.4">Each value will be encoded separately and prefixed by the type + tag byte(s) instead of having the type + tag serialized </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">only once.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.593.1">Field tags and wire types</span></h2>
<p><span class="koboSpan" id="kobo.594.1">Up until now, you read “tag + type” multiple times and we did not really see what this means. </span><span class="koboSpan" id="kobo.594.2">As mentioned, the first byte(s) of every serialized field will be a combination of the field type and the field tag. </span><span class="koboSpan" id="kobo.594.3">Let us start by seeing what a field tag is. </span><span class="koboSpan" id="kobo.594.4">You surely noticed something different about the syntax of a field. </span><span class="koboSpan" id="kobo.594.5">Each time we define a field, we add an equals sign and then an incrementing number. </span><span class="koboSpan" id="kobo.594.6">Here’s </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">an example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.596.1">
uint64 id </span><strong class="bold"><span class="koboSpan" id="kobo.597.1">= 1</span></strong><span class="koboSpan" id="kobo.598.1">;</span></pre>
<p><span class="koboSpan" id="kobo.599.1">While they </span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.600.1">look like an</span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.601.1"> assignment of value to the field, they are only here to give a unique identifier to the field. </span><span class="koboSpan" id="kobo.601.2">These identifiers, called tags, might look insignificant but they are the most important bit of information for serialization. </span><span class="koboSpan" id="kobo.601.3">They are used to tell Protobuf into which field to deserialize which data. </span><span class="koboSpan" id="kobo.601.4">As we saw earlier during the presentation of the different serialization algorithms, the field name is not serialized—only the type and the tag are. </span><span class="koboSpan" id="kobo.601.5">And thus, when deserialization kicks in, it will see a number and it will know where to redirect the </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">following datum.</span></span></p>
<p><span class="koboSpan" id="kobo.603.1">Now that we know that these tags are simply identifiers, let us see how these values are encoded. </span><span class="koboSpan" id="kobo.603.2">Tags are simply serialized as varints but they are serialized with a wire type. </span><span class="koboSpan" id="kobo.603.3">A wire type is a number that is given to a group of types in Protobuf. </span><span class="koboSpan" id="kobo.603.4">Here is the list of </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">wire types:</span></span></p>
<table class="No-Table-Style" id="table003">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.605.1">Type</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.606.1">Meaning</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.607.1">Used for</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.608.1">0</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.609.1">Varint</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">int32</span></strong><span class="koboSpan" id="kobo.611.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">int64</span></strong><span class="koboSpan" id="kobo.613.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.614.1">uint32</span></strong><span class="koboSpan" id="kobo.615.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">uint64</span></strong><span class="koboSpan" id="kobo.617.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">sint32</span></strong><span class="koboSpan" id="kobo.619.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">sint64</span></strong><span class="koboSpan" id="kobo.621.1">, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.622.1">bool</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">enum</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.625.1">1</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.626.1">64-bit</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.627.1">fixed64</span></strong><span class="koboSpan" id="kobo.628.1">, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">sfixed64</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">double</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.632.1">2</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.633.1">Length-delimited</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.634.1">string, bytes, packed </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">repeated fields</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.636.1">5</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.637.1">32-bit</span></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">fixed32</span></strong><span class="koboSpan" id="kobo.639.1">, </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">sfixed32</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.642.1">float</span></strong></span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.643.1">Here, 0 is the type for varints, 1 is for 64-bit, and </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.645.1">To combine the tag and the wire type, Protobuf uses a concept called bit packing. </span><span class="koboSpan" id="kobo.645.2">This is a technique that is designed to reduce the number of bits into which the data will be serialized. </span><span class="koboSpan" id="kobo.645.3">In our case here, the data is the field metadata (the famous tag + type). </span><span class="koboSpan" id="kobo.645.4">So, here is how</span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.646.1"> it works. </span><span class="koboSpan" id="kobo.646.2">The </span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.647.1">last 3 bits of the serialized metadata are reserved for the wire type, and the rest is for the tag. </span><span class="koboSpan" id="kobo.647.2">If we take the first example that we mentioned in the </span><em class="italic"><span class="koboSpan" id="kobo.648.1">Fixed-size numbers</span></em><span class="koboSpan" id="kobo.649.1"> section, where we serialized 42 in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">fixed32</span></strong><span class="koboSpan" id="kobo.651.1"> field with tag 1, we had </span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.653.1">
0d 2a 00 00 00</span></pre>
<p><span class="koboSpan" id="kobo.654.1">This time we are only interested in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">0d</span></strong><span class="koboSpan" id="kobo.656.1"> part. </span><span class="koboSpan" id="kobo.656.2">This is the metadata of the field. </span><span class="koboSpan" id="kobo.656.3">To see how this was serialized, let us turn </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">0d</span></strong><span class="koboSpan" id="kobo.658.1"> into binary (with </span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">0 padding):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.660.1">
00001101</span></pre>
<p><span class="koboSpan" id="kobo.661.1">Here, we have 101 (5) for the wire type—this is the wire type for 32 bits—and we have 00001 (1) for tag 1. </span><span class="koboSpan" id="kobo.661.2">Now, since the tag is serialized as a varint, it means that we could have more than 1 byte for that metadata. </span><span class="koboSpan" id="kobo.661.3">Here’s a reference for knowing the thresholds at which the number of bytes </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">will increase:</span></span></p>
<table class="No-Table-Style" id="table004">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.663.1">Field tag</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold"><span class="koboSpan" id="kobo.664.1">Size (</span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.665.1">in bits)</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.666.1">1</span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.667.1">5</span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.668.1">16</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.669.1">13</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.670.1">2,048</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.671.1">21</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.672.1">262,144</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.673.1">29</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.674.1">33,554,432</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.675.1">37</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.676.1">536,870,911</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.677.1">37</span></span></p>
</td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.678.1">This means that, as fields without values set to them will not be serialized, we need to keep the lowest tags to the fields that are the most often populated. </span><span class="koboSpan" id="kobo.678.2">This will lower the overhead needed to store the metadata. </span><span class="koboSpan" id="kobo.678.3">In general, 15 tags are enough, but if you come up with a situation where you need more tags, you might consider moving a group of data into a new message with </span><span class="No-Break"><span class="koboSpan" id="kobo.679.1">lower tags.</span></span></p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.680.1">Common types</span></h1>
<p><span class="koboSpan" id="kobo.681.1">As of now, if </span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.682.1">you checked the companion code, you could see that we are </span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.683.1">defining a lot of “boring” types that are just wrappers around one field. </span><span class="koboSpan" id="kobo.683.2">It is important to note that we wrote them by hand to simply give an example of how you would inspect the serialization of certain data. </span><span class="koboSpan" id="kobo.683.3">Most of the time, you will be able to use already defined types that are doing </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">the same.</span></span></p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.685.1">Well-known types</span></h2>
<p><span class="koboSpan" id="kobo.686.1">Protobuf itself</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.687.1"> comes with a bunch of already defined types. </span><span class="koboSpan" id="kobo.687.2">We call them </span><em class="italic"><span class="koboSpan" id="kobo.688.1">well-known types</span></em><span class="koboSpan" id="kobo.689.1">. </span><span class="koboSpan" id="kobo.689.2">While a lot of them are rarely useful outside</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.690.1"> of the Protobuf library itself or advanced use cases, some of them are important, and we are going to use some of them in </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">this book.</span></span></p>
<p><span class="koboSpan" id="kobo.692.1">The ones that we can understand quite easily are the wrappers. </span><span class="koboSpan" id="kobo.692.2">We wrote some by hand earlier. </span><span class="koboSpan" id="kobo.692.3">They usually start with the name of the type they are wrapping and finish with </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">Value</span></strong><span class="koboSpan" id="kobo.694.1">. </span><span class="koboSpan" id="kobo.694.2">Here is a list </span><span class="No-Break"><span class="koboSpan" id="kobo.695.1">of wrappers:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">BoolValue</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">BytesValue</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">DoubleValue</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">EnumValue</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">FloatValue</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">Int32Value</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">Int64Value</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.703.1">StringValue</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">UInt32Value</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">UInt64Value</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.706.1">These types might be interesting for debugging use cases such as the ones we saw earlier or just to serialize simple data such as a number, a string, and </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.708.1">Then, there are types representing time, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.709.1">Duration</span></strong><span class="koboSpan" id="kobo.710.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">Timestamp</span></strong><span class="koboSpan" id="kobo.712.1">. </span><span class="koboSpan" id="kobo.712.2">These two types </span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.713.1">are </span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.714.1">defined in the exact same way ([Duration | Timestamp] is not proper protobuf syntax, it means that we could replace by either of </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">both terms):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.716.1">
message [Duration | Timestamp] {
  // Represents seconds of UTC time since Unix epoch
  // 1970-01-01T00:00:00Z. </span><span class="koboSpan" id="kobo.716.2">Must be from 0001-01-
    01T00:00:00Z to
  // 9999-12-31T23:59:59Z inclusive.
</span><span class="koboSpan" id="kobo.716.3">  int64 seconds = 1;
  // Non-negative fractions of a second at nanosecond
  // resolution. </span><span class="koboSpan" id="kobo.716.4">Negative
  // second values with fractions must still have non-
  // negative nanos values
  // that count forward in time. </span><span class="koboSpan" id="kobo.716.5">Must be from 0 to
  // 999,999,999
  // inclusive.
</span><span class="koboSpan" id="kobo.716.6">  int32 nanos = 2;
}</span></pre>
<p><span class="koboSpan" id="kobo.717.1">However, as their name suggests, they represent different concepts. </span><span class="koboSpan" id="kobo.717.2">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">Duration</span></strong><span class="koboSpan" id="kobo.719.1"> type is the difference between the start and end time, whereas a </span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">Timestamp</span></strong><span class="koboSpan" id="kobo.721.1"> type is a simple point </span><span class="No-Break"><span class="koboSpan" id="kobo.722.1">in time.</span></span></p>
<p><span class="koboSpan" id="kobo.723.1">Finally, one last important well-known type is </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">FieldMask</span></strong><span class="koboSpan" id="kobo.725.1">. </span><span class="koboSpan" id="kobo.725.2">This is a type that represents a set of fields that should be included when serializing another type. </span><span class="koboSpan" id="kobo.725.3">To understand this one, it might be better to give an example. </span><span class="koboSpan" id="kobo.725.4">Let us say that we have an API endpoint returning an account with </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">id</span></strong><span class="koboSpan" id="kobo.727.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">username</span></strong><span class="koboSpan" id="kobo.729.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">email</span></strong><span class="koboSpan" id="kobo.731.1">. </span><span class="koboSpan" id="kobo.731.2">If you wanted to only get the account’s email address to prepare a list of people you want to send a promotional email to, you could use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">FieldMask</span></strong><span class="koboSpan" id="kobo.733.1"> type to tell Protobuf to only serialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">email</span></strong><span class="koboSpan" id="kobo.735.1"> field. </span><span class="koboSpan" id="kobo.735.2">This lets us reduce the additional cost of serialization and deserialization because now we only deal with one field instead </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">of three.</span></span></p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.737.1">Google common types</span></h2>
<p><span class="koboSpan" id="kobo.738.1">On </span><a id="_idIndexMarker086"/><span class="koboSpan" id="kobo.739.1">top of well-known types, there are types that </span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.740.1">are defined by Google. </span><span class="koboSpan" id="kobo.740.2">These are defined</span><a href=""><span class="koboSpan" id="kobo.741.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.742.1">googleapis/api-commo</span></strong></a><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">n-protos</span></strong><span class="koboSpan" id="kobo.744.1"> GitHub repository un</span><a href=""><span class="koboSpan" id="kobo.745.1">der the </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">goo</span></strong></a><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">gle/type</span></strong><span class="koboSpan" id="kobo.748.1"> directory and are easily usable in Golang code. </span><span class="koboSpan" id="kobo.748.2">I encourage you to check all the types, but I want to mention some </span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">interesting ones:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">LatLng</span></strong><span class="koboSpan" id="kobo.751.1">: A latitude/longitude pair storing the values </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">as doubles</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">Money</span></strong><span class="koboSpan" id="kobo.754.1">: An amount of money with its currency as defined by </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">ISO 4217</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.756.1">Date</span></strong><span class="koboSpan" id="kobo.757.1">: Year, Month, and Day stored </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">int32</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.760.1">Once again, go to the repository to check all the others. </span><span class="koboSpan" id="kobo.760.2">These types are battle-tested and in a lot of cases more optimized than trivial types that we would write. </span><span class="koboSpan" id="kobo.760.3">However, be aware that these types might also not be a good fit for your use cases. </span><span class="koboSpan" id="kobo.760.4">There is no such thing as a </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">one-size-fits-all solution.</span></span></p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.762.1">Services</span></h1>
<p><span class="koboSpan" id="kobo.763.1">Finally, the</span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.764.1"> last construct that is important to see and that we are going to work with during this book is the service one. </span><span class="koboSpan" id="kobo.764.2">In Protobuf, a service is a collection of RPC endpoints that contains two major parts. </span><span class="koboSpan" id="kobo.764.3">The first part is the input of the RPC, and the second is the output. </span><span class="koboSpan" id="kobo.764.4">So, if we wanted to define a service for our accounts, we could have something like </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.766.1">
message GetAccountRequest {…}
message GetAccountResponse {…}
service AccountService {
  rpc GetAccount(GetAccountRequest) returns (GetAccountResponse);
  //...
</span><span class="koboSpan" id="kobo.766.2">}</span></pre>
<p><span class="koboSpan" id="kobo.767.1">Here, we define a message representing a request, and another one representing the response and we use these as input and output of our </span><strong class="source-inline"><span class="koboSpan" id="kobo.768.1">getAccount</span></strong><span class="koboSpan" id="kobo.769.1"> RPC call. </span><span class="koboSpan" id="kobo.769.2">In the next chapter, we are going to cover more advanced usage of the services, but right now what is important to understand is that Protobuf defines the services but does not generate the code for them. </span><span class="koboSpan" id="kobo.769.3">Only </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">gRPC will.</span></span></p>
<p><span class="koboSpan" id="kobo.771.1">Protobuf’s services </span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.772.1">are here to describe a contract, and it is the job of an RPC framework to fulfill that contract on the client and server part. </span><span class="koboSpan" id="kobo.772.2">Notice that I wrote </span><em class="italic"><span class="koboSpan" id="kobo.773.1">an RPC framework</span></em><span class="koboSpan" id="kobo.774.1"> and not simply gRPC. </span><span class="koboSpan" id="kobo.774.2">Any RPC framework could read the information provided by Protobuf’s services and generate code out of it. </span><span class="koboSpan" id="kobo.774.3">The goal of Protobuf here is to be independent of any language and framework. </span><span class="koboSpan" id="kobo.774.4">What the application does with the serialized data is not important </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">to Protobuf.</span></span></p>
<p><span class="koboSpan" id="kobo.776.1">Finally, these services are the pillars of gRPC. </span><span class="koboSpan" id="kobo.776.2">As we are going to see later in this book, we will use them to make requests, and we are going to implement them on the server side to return responses. </span><span class="koboSpan" id="kobo.776.3">Using the defined services on the client side will let us feel like we are directly calling a function on the server. </span><span class="koboSpan" id="kobo.776.4">If we talk about </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">AccountService</span></strong><span class="koboSpan" id="kobo.778.1">, for example, we can make a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">GetAccount</span></strong><span class="koboSpan" id="kobo.780.1"> by having the </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.782.1">
res := client.GetAccount(req)</span></pre>
<p><span class="koboSpan" id="kobo.783.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">client</span></strong><span class="koboSpan" id="kobo.785.1"> is an instance of a gRPC client, </span><strong class="source-inline"><span class="koboSpan" id="kobo.786.1">req</span></strong><span class="koboSpan" id="kobo.787.1"> is an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.788.1">GetAccountRequest</span></strong><span class="koboSpan" id="kobo.789.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">res</span></strong><span class="koboSpan" id="kobo.791.1"> is an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">GetAccountResponse</span></strong><span class="koboSpan" id="kobo.793.1">. </span><span class="koboSpan" id="kobo.793.2">In this case, it feels a little bit like we are calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">GetAccount</span></strong><span class="koboSpan" id="kobo.795.1">, which is implemented on the server side. </span><span class="koboSpan" id="kobo.795.2">However, this is the doing of gRPC. </span><span class="koboSpan" id="kobo.795.3">It will hide all the complex ceremony of serializing and deserializing objects and sending those to the client </span><span class="No-Break"><span class="koboSpan" id="kobo.796.1">and server.</span></span></p>
<h1 id="_idParaDest-54"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.797.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.798.1">In this chapter, we saw how to write messages and services, and we saw how scalar types are serialized and deserialized. </span><span class="koboSpan" id="kobo.798.2">This prepared us for the rest of the book, where we are going to use this </span><span class="No-Break"><span class="koboSpan" id="kobo.799.1">knowledge extensively.</span></span></p>
<p><span class="koboSpan" id="kobo.800.1">In the next chapter, we are going to talk about gRPC, why it uses Protobuf for serialization and deserialization, and what it is doing behind the scenes, and we are going to compare it with REST and </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">GraphQL APIs.</span></span></p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.802.1">Quiz</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.803.1">What is the number 32 representing in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.804.1">int32</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.805.1">scalar type?</span></span><ol><li><span class="koboSpan" id="kobo.806.1">The number of bits the serialized data will be </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">stored in</span></span></li><li><span class="koboSpan" id="kobo.808.1">The range of numbers that can fit into the </span><span class="No-Break"><span class="koboSpan" id="kobo.809.1">scalar type</span></span></li><li><span class="koboSpan" id="kobo.810.1">Whether the type can accept negative numbers </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">or not</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.812.1">What is varint </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">encoding doing?</span></span><ol><li><span class="koboSpan" id="kobo.814.1">Compressing data in such a way that a smaller number of bytes will be required for </span><span class="No-Break"><span class="koboSpan" id="kobo.815.1">serializing data</span></span></li><li><span class="koboSpan" id="kobo.816.1">Turning every negative number into </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">positive numbers</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.818.1">What is ZigZag </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">encoding doing?</span></span><ol><li><span class="koboSpan" id="kobo.820.1">Compressing data in such a way that a smaller number of bytes will be required for </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">serializing data</span></span></li><li><span class="koboSpan" id="kobo.822.1">Turning every negative number into a </span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">positive number</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.824.1">In the following code, what is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">= 1</span></strong><span class="koboSpan" id="kobo.826.1"> syntax and what is it </span><span class="No-Break"><span class="koboSpan" id="kobo.827.1">used for?</span></span><pre class="source-code"><span class="koboSpan" id="kobo.828.1">
uint64 ids = 1;</span></pre><ol><li><span class="koboSpan" id="kobo.829.1">This is assigning the value 1 to </span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">a field</span></span></li><li><span class="koboSpan" id="kobo.831.1">1 is an identifier that has no other purpose than </span><span class="No-Break"><span class="koboSpan" id="kobo.832.1">helping developers</span></span></li><li><span class="koboSpan" id="kobo.833.1">1 is an identifier that is helping the compiler know into which field to deserialize the </span><span class="No-Break"><span class="koboSpan" id="kobo.834.1">binary data.</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.835.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">a message?</span></span><ol><li><span class="koboSpan" id="kobo.837.1">An object that contains fields and represents </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">an entity</span></span></li><li><span class="koboSpan" id="kobo.839.1">A collection of </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">API endpoints</span></span></li><li><span class="koboSpan" id="kobo.841.1">A list of </span><span class="No-Break"><span class="koboSpan" id="kobo.842.1">possible states</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.843.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">an enum?</span></span><ol><li><span class="koboSpan" id="kobo.845.1">An object that contains fields and represents </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">an entity</span></span></li><li><span class="koboSpan" id="kobo.847.1">A collection of </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">API endpoints</span></span></li><li><span class="koboSpan" id="kobo.849.1">A list of </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">possible states</span></span></li></ol></li>
<li><span class="koboSpan" id="kobo.851.1">What is </span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">a service?</span></span><ol><li><span class="koboSpan" id="kobo.853.1">An object that contains fields and represents </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">an entity</span></span></li><li><span class="koboSpan" id="kobo.855.1">A collection of </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">API endpoints</span></span></li><li><span class="koboSpan" id="kobo.857.1">A list of </span><span class="No-Break"><span class="koboSpan" id="kobo.858.1">possible states</span></span></li></ol></li>
</ol>
<h1 id="_idParaDest-56"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.859.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.860.1">B</span></li>
<li><span class="koboSpan" id="kobo.861.1">A</span></li>
<li><span class="koboSpan" id="kobo.862.1">B</span></li>
<li><span class="koboSpan" id="kobo.863.1">C</span></li>
<li><span class="koboSpan" id="kobo.864.1">A</span></li>
<li><span class="koboSpan" id="kobo.865.1">C</span></li>
<li><span class="koboSpan" id="kobo.866.1">B</span></li>
</ol>
</div>
</body></html>